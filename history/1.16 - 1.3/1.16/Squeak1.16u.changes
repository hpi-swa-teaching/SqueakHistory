'From Squeak 1.1 of September 21, 1996 on 23 September 1996 at 8:34:59 pm'!!AbstractSound methodsFor: 'playing'!playSampleCount: n into: aSoundBuffer startingAt: startIndex stereo: stereoFlag	"Mixes the next count samples of this sound into the given buffer starting at the given index, updating the receiver's control parameters at periodic intervals."	| leftRightPan samplesBetweenControlUpdates pastEnd i remainingSamples count |	stereoFlag ifTrue: [leftRightPan _ 500] ifFalse: [leftRightPan _ 1000].	samplesBetweenControlUpdates _ self samplingRate // self controlRate.	pastEnd _ startIndex + n.  "index just index of after last sample"	i _ startIndex.	[i < pastEnd] whileTrue: [		remainingSamples _ self samplesRemaining.		remainingSamples <= 0 ifTrue: [ ^ self ].		count _ pastEnd - i.		samplesUntilNextControl < count ifTrue: [ count _ samplesUntilNextControl ].		remainingSamples < count		ifTrue: [ count _ remainingSamples ].		self mixSampleCount: count into: aSoundBuffer startingAt: i pan: leftRightPan.		samplesUntilNextControl _ samplesUntilNextControl - count.		samplesUntilNextControl <= 0 ifTrue: [			self doControl.			samplesUntilNextControl _ samplesBetweenControlUpdates.		].		i _ i + count.	].! !!AbstractSound class methodsFor: 'primitive generation'!cCodeForSoundPrimitives	"Return a string containing the C code for the sound primitives. This string is pasted into a file, compiled, and linked into the virtual machine. Note that the virtual machine's primitive table must also be edited to make new primitives available."	^ CCodeGenerator new codeStringForPrimitives: #(		(WaveTableSound mixSampleCount:into:startingAt:pan:)		(FMSound mixSampleCount:into:startingAt:pan:)		(PluckedSound mixSampleCount:into:startingAt:pan:)	).! !Alias comment:'An objects whose contents consist of a reference to another object.  6/8/96 sw'!!Alias methodsFor: 'everything'!comeFullyUpOnReload	"recompute my referent object (contants) from the path I have saved.  Upon coming in from the disk.  8/8/96 tk" 	| pp |	super comeFullyUpOnReload.	contents class == PathFromHome ifTrue:		["I refer to an object outside the hierarchy in this file.  			Hopefully it is here and found by the same path as before."		(pp _ contents copy) removeFirst.	" 'Home' "		contents _ Home resolvePath: pp].	^ self!contents: anObject	"Smash anObject into the receiver's contents.  For aliases, we pass the contents-setting message on to the referent.  7/13/96 sw"	contents isExtant ifTrue:		[contents contents: anObject]!contentsString	^ contents isExtant		ifTrue:			[contents contentsString]		ifFalse:			['<gone>']!currentNumericValue	^ self contents currentNumericValue!displayContentsOnCanvas: aCanvas	contents isExtant		ifTrue:			[contents displayContentsOnCanvas: aCanvas]!editTextIn: aView	"Fire up a text editor in my layoutRectangle of aView, to operate on the text of my referent.  Derived from Dan's work for TextObjs.  8/10/96 sw"	| newView screenRect textToEdit |	textToEdit _ contents contents.	screenRect _ (layoutRectangle insetBy: 2@2)				translateBy: aView insetDisplayBox topLeft.	newView _ DisplayTextView new model: textToEdit.	newView window: (0@0 extent: screenRect extent) viewport: screenRect.	textToEdit wrappingBox: screenRect clippingBox: screenRect.	textToEdit display.	newView controller changeParagraph: textToEdit.	newView controller startUp.	self invalidateCanvas.	contents invalidateCanvas!emphasisForName	"Italics for Alias.   6/8/96 sw"	^ 3!maximumValue	^ self contents maximumValue!mimicCostumeOf: anotherObject	"Just view the other guy?  Alias to text not wear a text costume.  9/13/96 tk"	currentCostume _  self useStandardCostumeNamed: 'Contents'.	(anotherObject costumes includes: currentCostume)		ifTrue:			[self costumes add: currentCostume]	!minimumValue	^ self contents minimumValue!mouseUpAt: aPoint in: aView	"The mouse came up in the receiver.  As in the Finder, we take this for the moment to be a request to open the referent in its own window.  6/12/96 sw"	((contents isKindOf: Obj) and: [contents isExtant]) ifFalse: [^ self beep].	(contents isKindOf: TextObj) ifTrue: [^ self editTextIn: aView].	contents mouseUpAt: aPoint in: aView!refersTo: anObject	"Answer whether the receiver refers to anObject.  8/13/96 sw"	^ contents == anObject!referTo: anObject	"Make the receiver refer to anObject.  7/15/96 sw"	contents _ anObject!storeDataOn: byteStream	"Write myself out on the ReferenceStream.  If I am a sole instance of a unique User class, use my generic class instead.  	Prepare a Path for my referent, stored in my conents.  8/8/96 tk"	| cntInstVars cntIndexedVars class |	class _ (self ioType = #User) ifTrue: [self class superclass]				ifFalse: [self class].	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	cntIndexedVars > 0 ifTrue: [		self error: 'not prepared to read variable Obj instances'].	byteStream		beginInstance: class			"Must be a standard subclass of Obj, i.e. Folder"		size: cntInstVars "+ cntIndexedVars".	1 to: cntInstVars do: [:i | 		(#(2 5 7 9) includes: i) "objectContainedIn, currentCostume, contents"			ifTrue: [i = 9 				ifTrue: [byteStream nextPut: nil] "don't write the canvas"				ifFalse: [byteStream nextPut: 					(self pathOrObj: (self instVarAt: i))]]		"path for referent"			ifFalse: [byteStream nextPut: (self instVarAt: i)]].	"1 to: cntIndexedVars do:		[:i | byteStream nextPut: (self basicAt: i)]."	(self parameters includesKey: #PictureName) ifTrue: [		IncomingObjects recent animation: #PictureName in: self].	(self parameters includesKey: #BackgroundPaintingName) ifTrue: [		IncomingObjects recent animation: #BackgroundPaintingName in: self].!type	"Answer the formal type of the receiver.  6/12/96 sw"	^ #Alias! !AnimationCostume comment:'A costume consisting of a sequence of frames that, combined, produce an animation.  The receiver''s contents (workings?) contain the sequence of picture costumes, and we need to deal with registration points, etc.  Each object wearing this costume needs to store, for it, a sequence number representing which element it currently is showing.    6/22/96 sw '!!AnimationCostume methodsFor: 'display'!animationNameFor: anObject	"Acting as a costume for anObject,  Return the key into the animation dictionary.  7/19/96 sw"	| parm |	^ (parm _ anObject parameterFor: #PictureName) == nil		ifFalse:			[parm]		ifTrue:			[self defaultAnimationNameFor: anObject]!desiredExtentFor: anObject	"Answer the extent needed for anObject.  8/8/96 sw"	| frameNumber |	frameNumber _ anObject parameterFor: #FrameNumber ifAbsent: [1].	^ (SqueakSupport animationNamed: (self animationNameFor: anObject) frameNumber: frameNumber rotatedBy: anObject heading) boundingBox extent!display: anObject onCanvas: aCanvas	"Display anObject wearing the receiver as a costume, on the given canvas.  8/9/96 sw"	| pictureName animationStage registrationPoint  |	pictureName _ anObject parameterFor: #PictureName ifAbsent: ['Ship'].	animationStage _ anObject parameterFor: #AnimationStage ifAbsent: [1].	registrationPoint _ anObject parameterFor: #RegistrationPoint ifAbsent:		[anObject layoutRectangle center].	anObject showPicture: pictureName animationStage: animationStage rotatedBy: anObject heading on: aCanvas! !!AnimationCostume methodsFor: 'picture choice'!chooseCostumeDetailsFor: anObject in: aView	"At user menu request, put up a list of available pictures and let the user choose one.  6/12/96 sw	 6/23/96 sw: call chooseStandardPictureFor:"	anObject chooseAnimatedPictureFor: self!defaultAnimationNameFor: anObject	^ 'Ship'!defaultGraphic	^ SqueakSupport animationLibrary at: 'Ship' ifAbsent: [self halt: 'No Ship!!']! !!AnimationCostume methodsFor: 'miscellaneous'!advanceAnimationFor: anObject in: aView	"The receiver, acting as a costume for anObject, is asked to advance to the next phase in the animation.  8/12/96 sw" 	| aGraphic frameCount aStage newStage |	aGraphic _ SqueakSupport libraryGraphicAtKey: (anObject parameterFor: #PictureName).	aGraphic == nil ifTrue: [^ self].	(frameCount _ aGraphic frameCount) < 2 ifTrue: [^ self].	aStage _ anObject parameterFor: #AnimationStage.	aStage == nil ifTrue: [aStage _ 0].	newStage _ aStage + 1.	newStage > frameCount ifTrue: [newStage _ 1].	anObject setParameter: newStage forKey: #AnimationStage! !!AnimationInspectController methodsFor: 'everything'!animateOneStep	currentAnimationStage _ self animationStage + 1.	currentAnimationStage > model selection frameCount ifTrue:		[currentAnimationStage _ 1]!animateRotations: aBoolean	"Run through all the frames in the animation, in forwards direction if aBoolean is true, else in backwards direction.  7/24/96 sw"	| rotatedImages aDelay box  aGraphicFrame stage |	model selectionIndex == 0 ifTrue: [^ self beep].	aGraphicFrame _ model selection frameNumber: (stage _ self animationStage).	rotatedImages _ aGraphicFrame imageCount.	rotatedImages < 2 ifTrue: [^ self beep].	box _ view insetDisplayBox merge: scrollBar.	[true] whileTrue:		[aDelay _ Delay forMilliseconds: 500.		1 to: rotatedImages do:			[:i | view displayFrameNumber: stage rotationNumber:				(aBoolean					ifTrue: [i]					ifFalse: [rotatedImages - i + 1]).			(box containsPoint: Sensor cursorPoint) ifFalse:				[^ self].			aDelay wait]]!animationStage	currentAnimationStage == nil ifTrue:		[currentAnimationStage _ 1].	^ currentAnimationStage!initialize	"Initialize the receiver; here we get its menu set up.  6/28/96 sw"	super initialize.	self initializeYellowButtonMenu!initializeYellowButtonMenu	"Initialize the yellow-button menu of the receiver.  6/28/96 sw"	self yellowButtonMenu: YellowButtonMenu		yellowButtonMessages: YellowButtonMessages!reset	currentRotationStage _ 1.	currentAnimationStage _ 1!rotateBackward	"Run through all rotations of the current frame, in backward order. 8/11/96 sw"	self animateRotations: false!rotateForward	"Run through all the frames in the animation, in forward order.  6/28/96 sw"	self animateRotations: true!rotationStage	^ currentRotationStage! !!AnimationInspectController class methodsFor: 'as yet unclassified'!initialize	"Initialize the receiver -- namely set up its menu.  6/28/96 sw"	"AnimationInspectController initialize"	YellowButtonMenu _ PopUpMenu labels: 'rotate forwardrotate backwardrotate one stepanimate forwardanimate backwardanimate one step'		lines: #(2 3).	YellowButtonMessages _ #(rotateForward rotateBackward rotateOneStep animateForward animateBackward animateOneStep)! !!AnimationInspectView methodsFor: 'as yet unclassified'!defaultControllerClass	"Answer the class of controller to be used.  6/28/96 sw"	^ AnimationInspectController!displayFrameNumber: aFrameNumber rotationNumber: aRotationNumber	"Display the given frame number of the animation.  6/28/96 sw"	| oldOffset formToUse frameToUse |	Display fill: self insetDisplayBox fillColor: Color white.	model selectionIndex == 0 ifTrue: [^ self].	frameToUse _ model selection frameNumber: aFrameNumber.	formToUse _ frameToUse imageNumber: aRotationNumber.	oldOffset _ formToUse offset.	offset == nil ifFalse: [formToUse offset: offset asPoint].	formToUse		displayOn: Display		transformation: (WindowingTransformation			scale: 1@1			translation: self displayTransformation translation)		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor.	formToUse offset: oldOffset!displayView 	"Display the default (first) frame of the receiver's animation.  6/28/96 sw"	|  formToUse oldOffset |	Display fill: self insetDisplayBox fillColor: Color white.	model selectionIndex == 0 ifTrue: [^ self].	formToUse _ model selection primaryImage.	oldOffset _ formToUse offset.	offset == nil ifFalse: [formToUse offset: offset asPoint].	formToUse		displayOn: Display		transformation: (WindowingTransformation			scale: 1@1			translation: self displayTransformation translation)		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor.	formToUse offset: oldOffset! !!AssignmentNode methodsFor: 'C translation'!asTranslatorNode	^TAssignmentNode new		setVariable: variable asTranslatorNode		expression: value asTranslatorNode! !BitBltSimulation comment:'This class implements BitBlt, much as specified in the Blue Book spec.Performance has been enhanced through the use of pointer variables such as sourceIndex and destIndex, and by separating several special cases of the inner loop.Operation has been extended to color, with support for 1, 2, 4, 8, 16, and 32-bit pixel sizes.  Conversion between different pixel sizes is facilitated by accepting an optional color map.In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWordThis implementation has also been fitted with an experimental "warp drive" that allows abritrary scaling and rotation (and even limited affine deformations) with all BitBlt storage modes supported.'!!BitBltSimulation methodsFor: 'interpreter interface'!drawLoopX: xDelta Y: yDelta 	"This is the primitive implementation of the line-drawing loop"	| dx1 dy1 px py P affL affR affT affB i |	xDelta > 0 ifTrue: [		dx1 _ 1.	] ifFalse: [		xDelta = 0 ifTrue: [ dx1 _ 0 ] ifFalse: [ dx1 _ -1 ].	].	yDelta > 0 ifTrue: [		dy1 _ 1.	] ifFalse: [		yDelta = 0 ifTrue: [ dy1 _ 0 ] ifFalse: [ dy1 _ -1 ].	].	px _ yDelta abs.	py _ xDelta abs.	self copyBits.	affL _ affectedL.	affR _ affectedR.	affT _ affectedT.	affB _ affectedB.	py > px		ifTrue: 			["more horizontal"			P _ py // 2.			1 to: py do: 				[:i |				destX _ destX + dx1.				(P _ P - px) < 0 ifTrue: 						[destY _ destY + dy1.						P _ P + py].				self copyBits]]		ifFalse: 			["more vertical"			P _ px // 2.			1 to: px do:				[:i |				destY _ destY + dy1.				(P _ P - py) < 0 ifTrue: 						[destX _ destX + dx1.						P _ P + px].				self copyBits]].	"Compute affected rect from start, end"	affectedL _ affL min: affectedL.	affectedR _ affR max: affectedR.	affectedT _ affT min: affectedT.	affectedB _ affB max: affectedB.	"store destX, Y back"		interpreterProxy storeInteger: BBDestXIndex ofObject: bitBltOop withValue: destX.	interpreterProxy storeInteger: BBDestYIndex ofObject: bitBltOop withValue: destY.!loadBitBltFrom: bbObj	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!!"	| destBitsSize destWidth destHeight sourceBitsSize sourcePixPerWord cmSize halftoneBits |	bitBltOop _ bbObj.	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.	(interpreterProxy failed		or: [combinationRule < 0 or: [combinationRule > 26]])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.	noSource _ self ignoreSourceOrHalftone: sourceForm.	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bitBltOop.		((interpreterProxy isPointers: destForm) and: [(interpreterProxy lengthOf: destForm) >= 4])			ifFalse: [^ false].		destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.		destBitsSize _ interpreterProxy byteLengthOf: destBits.		destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.		destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.		(destWidth >= 0 and: [destHeight >= 0])			ifFalse: [^ false].		destPixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.		pixPerWord _ 32 // destPixSize.		destRaster _ destWidth + (pixPerWord-1) // pixPerWord.		((interpreterProxy isWordsOrBytes: destBits)			and: [destBitsSize = (destRaster * destHeight * 4)])			ifFalse: [^ false].		destX _ interpreterProxy fetchInteger: BBDestXIndex ofObject: bitBltOop.	destY _ interpreterProxy fetchInteger: BBDestYIndex ofObject: bitBltOop.	width _ interpreterProxy fetchInteger: BBWidthIndex ofObject: bitBltOop.	height _ interpreterProxy fetchInteger: BBHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	noSource ifTrue:		[sourceX _ sourceY _ 0]		ifFalse: 		[((interpreterProxy isPointers: sourceForm) and: [(interpreterProxy lengthOf: sourceForm) >= 4])			ifFalse: [^ false].		sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.		sourceBitsSize _ interpreterProxy byteLengthOf: sourceBits.		srcWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: sourceForm.		srcHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: sourceForm.		(srcWidth >= 0 and: [srcHeight >= 0])			ifFalse: [^ false].		sourcePixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.		sourcePixPerWord _ 32 // sourcePixSize.		sourceRaster _ srcWidth + (sourcePixPerWord-1) // sourcePixPerWord.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourceRaster * srcHeight * 4)])			ifFalse: [^ false].		colorMap _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.		"ColorMap, if not nil, must be longWords, and 		2^N long, where N = sourcePixSize for 1, 2, 4, 8 bits, 		or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits."		colorMap = interpreterProxy nilObject ifFalse:			[(interpreterProxy isWords: colorMap)			ifTrue:			[cmSize _ interpreterProxy lengthOf: colorMap.			sourcePixSize <= 8				ifTrue: [cmSize = (1 << sourcePixSize) ifFalse: [^ false] ]				ifFalse: [cmSize = 512 ifTrue: [cmBitsPerColor _ 3]						ifFalse: 						[cmSize = 4096 ifTrue: [cmBitsPerColor _ 4]						ifFalse: 						[cmSize = 32768 ifTrue: [cmBitsPerColor _ 5]						ifFalse: [^ false]]]]			]			ifFalse: [^ false]].		sourceX _ interpreterProxy fetchInteger: BBSourceXIndex ofObject: bitBltOop.		sourceY _ interpreterProxy fetchInteger: BBSourceYIndex ofObject: bitBltOop].	noHalftone ifFalse: 		[((interpreterProxy isPointers: halftoneForm) and: [(interpreterProxy lengthOf: halftoneForm) >= 4])		ifTrue:		["Old-style 32xN monochrome halftone Forms"		halftoneBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: halftoneForm.		halftoneHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: halftoneForm.		(interpreterProxy isWords: halftoneBits)			ifFalse: [noHalftone _ true]]		ifFalse:		["New spec accepts, basically, a word array"		((interpreterProxy isPointers: halftoneForm) not			and: [interpreterProxy isWords: halftoneForm])			ifFalse: [^ false].		halftoneBits _ halftoneForm.		halftoneHeight _ interpreterProxy lengthOf: halftoneBits].	halftoneBase _ halftoneBits + 4].	clipX _ interpreterProxy fetchInteger: BBClipXIndex ofObject: bitBltOop.	clipY _ interpreterProxy fetchInteger: BBClipYIndex ofObject: bitBltOop.	clipWidth _ interpreterProxy fetchInteger: BBClipWidthIndex ofObject: bitBltOop.	clipHeight _ interpreterProxy fetchInteger: BBClipHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].	^ true!loadScannerFrom: bbObj	start: start stop: stop string: string rightX: rightX	stopArray: stopArray displayFlag: displayFlag	"Load arguments and Scanner state"	scanStart _ start.	scanStop _ stop.	scanString _ string.	scanRightX _ rightX.	scanStopArray _ stopArray.	scanDisplayFlag _ displayFlag.	interpreterProxy success: (		(interpreterProxy isPointers: scanStopArray)			and: [(interpreterProxy lengthOf: scanStopArray) >= 1]).	scanXTable _ interpreterProxy fetchPointer: BBXTableIndex ofObject: bbObj.	interpreterProxy success: (		(interpreterProxy isPointers: scanXTable)			and: [(interpreterProxy lengthOf: scanXTable) >= 1]).	"width and sourceX may not be set..."	interpreterProxy storeInteger: BBWidthIndex ofObject: bbObj withValue: 0.	interpreterProxy storeInteger: BBSourceXIndex ofObject: bbObj withValue: 0.	"Now load BitBlt state if displaying"	scanDisplayFlag		ifTrue: [interpreterProxy success: (self loadBitBltFrom: bbObj)]		ifFalse: [bitBltOop _ bbObj.				destX _ interpreterProxy fetchInteger: BBDestXIndex ofObject: bbObj].	^interpreterProxy failed not!scanCharacters	| left top lastIndex charVal ascii sourceX2 nextDestX |	scanDisplayFlag ifTrue:		[self clipRange.  "Need to get true x, y for affectedRectangle"		left _ dx.		top _ dy].	lastIndex _ scanStart.	[lastIndex <= scanStop]		whileTrue: [			charVal _ interpreterProxy stObject: scanString at: lastIndex.			ascii _ interpreterProxy integerValueOf: charVal.			interpreterProxy failed ifTrue: [^ nil].			stopCode _ interpreterProxy stObject: scanStopArray at: ascii + 1.			interpreterProxy failed ifTrue: [^ nil].			stopCode = interpreterProxy nilObject				ifFalse: [^ self returnAt: ascii + 1							 lastIndex: lastIndex								  left: left								  top: top].			sourceX _ interpreterProxy stObject: scanXTable at: ascii + 1.			sourceX2 _ interpreterProxy stObject: scanXTable at: ascii + 2.			interpreterProxy failed ifTrue: [^ nil].			(interpreterProxy isIntegerObject: sourceX) & (interpreterProxy isIntegerObject: sourceX2)				ifTrue: [sourceX _ interpreterProxy integerValueOf: sourceX.						sourceX2 _ interpreterProxy integerValueOf: sourceX2]				ifFalse: [interpreterProxy primitiveFail. ^ nil].			nextDestX _ destX + (width _ sourceX2 - sourceX).			nextDestX > scanRightX				ifTrue: [^ self returnAt: CrossedX							 lastIndex: lastIndex								  left: left								  top: top].			scanDisplayFlag ifTrue: [self copyBits].			destX _ nextDestX.			interpreterProxy storeInteger: BBDestXIndex ofObject: bitBltOop withValue: destX.			lastIndex _ lastIndex + 1].	self returnAt: EndOfRun		 lastIndex: scanStop			  left: left			  top: top!setInterpreter: anInterpreter	"Interface for InterpreterSimulator. Allows BitBltSimulation object to send messages to the interpreter. The translator will replace sends to 'interpreterProxy' with sends to self, as if BitBltSimulation were part of the interpreter."	interpreterProxy _ anInterpreter.! !!BitBltSimulation methodsFor: 'accessing'!affectedBottom	^affectedB!affectedLeft	^affectedL!affectedRight	^affectedR!affectedTop	^affectedT!stopReason	^stopCode!targetForm	"Return the destination form of a copyBits or scanCharacters operation."	^destForm! !!BitBltSimulation methodsFor: 'setup'!checkSourceOverlap	| t |	"check for possible overlap of source and destination"	(sourceForm = destForm and: [dy >= sy]) ifTrue:		[dy > sy ifTrue:			["have to start at bottom"			vDir _ -1.			sy _ sy + bbH - 1.			dy _ dy + bbH - 1]		ifFalse:			[dx > sx ifTrue:				["y's are equal, but x's are backward"				hDir _ -1.				sx _ sx + bbW - 1.				"start at right"				dx _ dx + bbW - 1.				"and fix up masks"				nWords > 1 ifTrue: 					[t _ mask1.					mask1 _ mask2.					mask2 _ t]]].		"Dest inits may be affected by this change"		destIndex _ (destBits + 4) + (dy * destRaster + (dx // pixPerWord) *4).		destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir))]!clipRange	"clip and adjust source origin and extent appropriately"	"first in x"	destX >= clipX		ifTrue: [sx _ sourceX.				dx _ destX.				bbW _ width]		ifFalse: [sx _ sourceX + (clipX - destX).				bbW _ width - (clipX - destX).				dx _ clipX].	(dx + bbW) > (clipX + clipWidth)		ifTrue: [bbW _ bbW - ((dx + bbW) - (clipX + clipWidth))].	"then in y"	destY >= clipY		ifTrue: [sy _ sourceY.				dy _ destY.				bbH _ height]		ifFalse: [sy _ sourceY + clipY - destY.				bbH _ height - (clipY - destY).				dy _ clipY].	(dy + bbH) > (clipY + clipHeight)		ifTrue: [bbH _ bbH - ((dy + bbH) - (clipY + clipHeight))].	noSource ifTrue: [^ nil].	sx < 0		ifTrue: [dx _ dx - sx.				bbW _ bbW + sx.				sx _ 0].	sx + bbW > srcWidth		ifTrue: [bbW _ bbW - (sx + bbW - srcWidth)].	sy < 0		ifTrue: [dy _ dy - sy.				bbH _ bbH + sy.				sy _ 0].	sy + bbH > srcHeight		ifTrue: [bbH _ bbH - (sy + bbH - srcHeight)]!copyBits	self clipRange.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil]. 	self destMaskAndPointerInit.	bitCount _ 0.	noSource		ifTrue: [self copyLoopNoSource]		ifFalse: [self checkSourceOverlap.				(sourcePixSize ~= destPixSize					or: [colorMap ~= interpreterProxy nilObject])					ifTrue: [self copyLoopPixMap]					ifFalse: [self sourceSkewAndPointerInit.							self copyLoop]]. 	combinationRule = 22 ifTrue:		["zero width and height; return the count"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		interpreterProxy pop: 1.		^ interpreterProxy pushInteger: bitCount]. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW.				affectedR _ dx].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH.				affectedB _ dy]!destMaskAndPointerInit	"Compute masks for left and right destination words"	| startBits pixPerM1 endBits |	pixPerM1 _ pixPerWord - 1.  "A mask, assuming power of two"	"how many pixels in first word"	startBits _ pixPerWord - (dx bitAnd: pixPerM1).	mask1 _ AllOnes >> (32 - (startBits*destPixSize)).	"how many pixels in last word"	endBits _ ((dx + bbW - 1) bitAnd: pixPerM1) + 1.	mask2 _ AllOnes << (32 - (endBits*destPixSize)).	"determine number of words stored per line; merge masks if only 1"	bbW < startBits		ifTrue: [mask1 _ mask1 bitAnd: mask2.				mask2 _ 0.				nWords _ 1]		ifFalse: [nWords _ (bbW - startBits) + pixPerM1 // pixPerWord + 1].	hDir _ vDir _ 1. "defaults for no overlap with source"	"calculate byte addr and delta, based on first word of data"	"Note raster and nwords are longs, not bytes"	destIndex _ (destBits + 4) + (dy * destRaster + (dx // pixPerWord) *4).	destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir)).  "byte addr delta"!ignoreSourceOrHalftone: formPointer	formPointer = interpreterProxy nilObject ifTrue: [ ^true ].	combinationRule = 0 ifTrue: [ ^true ].	combinationRule = 5 ifTrue: [ ^true ].	combinationRule = 10 ifTrue: [ ^true ].	combinationRule = 15 ifTrue: [ ^true ].	^false!returnAt: stopIndex lastIndex: lastIndex left: left top: top	stopCode _ interpreterProxy stObject: scanStopArray at: stopIndex.	interpreterProxy failed ifTrue: [^ nil].	interpreterProxy storeInteger: BBLastIndex ofObject: bitBltOop withValue: lastIndex.	scanDisplayFlag ifTrue: [		"Now we know extent of affected rectangle"		affectedL _ left.		affectedR _ bbW + dx.		affectedT _ top.		affectedB _ bbH + dy.	].!sourceSkewAndPointerInit	"This is only used when source and dest are same depth,	ie, when the barrel-shift copy loop is used."	| dWid sxLowBits dxLowBits pixPerM1 |	pixPerM1 _ pixPerWord - 1.  "A mask, assuming power of two"	sxLowBits _ sx bitAnd: pixPerM1.	dxLowBits _ dx bitAnd: pixPerM1.	"check if need to preload buffer	(i.e., two words of source needed for first word of destination)"	hDir > 0 ifTrue:		["n Bits stored in 1st word of dest"		dWid _ bbW min: pixPerWord - dxLowBits.		preload _ (sxLowBits + dWid) > pixPerM1]	ifFalse:		[dWid _ bbW min: dxLowBits + 1.		preload _ (sxLowBits - dWid + 1) < 0].	"calculate right-shift skew from source to dest"	skew _ (sxLowBits - dxLowBits) * destPixSize.  " -32..32 "	preload ifTrue: 		[skew < 0			ifTrue: [skew _ skew+32]			ifFalse: [skew _ skew-32]].	"Calc byte addr and delta from longWord info"	sourceIndex _ (sourceBits + 4) + (sy * sourceRaster + (sx // (32//sourcePixSize)) *4).	"calculate increments from end of 1 line to start of next"	sourceDelta _ 4 * ((sourceRaster * vDir) - (nWords * hDir)).	preload ifTrue:		["Compensate for extra source word fetched"		sourceDelta _ sourceDelta - (4*hDir)].!warpBits	"Need to check that inst has 12 extra integer fields"	| ns |	ns _ noSource.  noSource _ true.		self clipRange.  "noSource suppresses sourceRect clipping"		noSource _ ns.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil]. 	self destMaskAndPointerInit.	noSource		ifTrue: [self copyLoopNoSource]		ifFalse: [self warpLoop]. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW.				affectedR _ dx].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH.				affectedB _ dy]! !!BitBltSimulation methodsFor: 'inner loop'!copyLoop 	| prevWord thisWord skewWord halftoneWord mergeWord hInc y i word unskew skewMask notSkewMask |	"This version of the inner loop assumes noSource = false."	hInc _ hDir*4.  "Byte delta"	skew < 0 ifTrue:		[unskew _ skew+32.		skewMask _ AllOnes << (0-skew)]		ifFalse:		[unskew _ skew-32.		skewMask _ AllOnes >> skew].	notSkewMask _ skewMask bitInvert32.	noHalftone		ifTrue: [halftoneWord _ AllOnes.  halftoneHeight _ 0]		ifFalse: [halftoneWord _ interpreterProxy longAt: halftoneBase].	y _ dy.	1 to: bbH do: "here is the vertical loop"		[ :i |		halftoneHeight > 1 ifTrue:  "Otherwise, its always the same"			[halftoneWord _ interpreterProxy longAt:						(halftoneBase + (y \\ halftoneHeight * 4)).			y _ y + vDir].		preload ifTrue:			["load the 64-bit shifter"			prevWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc]			ifFalse:			[prevWord _ 0].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)								with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask1 bitAnd: mergeWord)					bitOr: (mask1 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc.		"This central horizontal loop requires no store masking"combinationRule = 3ifTrue: [2 to: nWords-1 do: "Special inner loop for STORE"			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			interpreterProxy longAt: destIndex put: (skewWord bitAnd: halftoneWord).			destIndex _ destIndex + hInc]] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)								with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + hInc]].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)								with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask2 bitAnd: mergeWord)					bitOr: (mask2 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]!copyLoopNoSource	| halftoneWord mergeWord i word |	"Faster copyLoop when source not used.  hDir and vDir are both	positive, and perload and skew are unused"	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			mergeWord _ self merge: halftoneWord with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask1 bitAnd: mergeWord)					bitOr: (mask1 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.		"This central horizontal loop requires no store masking"combinationRule = 3ifTrue: [2 to: nWords-1 do: "Special inner loop for STORE"			[ :word |			interpreterProxy longAt: destIndex put: halftoneWord.			destIndex _ destIndex + 4].] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge"			[ :word |			mergeWord _ self merge: halftoneWord with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + 4].].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[mergeWord _ self merge: halftoneWord with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask2 bitAnd: mergeWord)					bitOr: (mask2 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4].	destIndex _ destIndex + destDelta]!copyLoopPixMap	| skewWord halftoneWord mergeWord i word destMask srcPixPerWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask nullMap |	"This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop."	"Additional inits peculiar to unequal source and dest pix size..."	srcPixPerWord _ 32//sourcePixSize.	sourcePixMask _ (1 bitShift: sourcePixSize) - 1.	destPixMask _ (1 bitShift: destPixSize) - 1.	nullMap _ colorMap = interpreterProxy nilObject.	sourceIndex _ (sourceBits + 4) +					(sy * sourceRaster + (sx // srcPixPerWord) *4).	scrStartBits _ srcPixPerWord - (sx bitAnd: srcPixPerWord-1).	bbW < scrStartBits		ifTrue: [nSourceIncs _ 0]		ifFalse: [nSourceIncs _ (bbW - scrStartBits)//srcPixPerWord + 1].	sourceDelta _ (sourceRaster - nSourceIncs) * 4.	"Note following two items were already calculated in destmask setup!!"	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	endBits _ ((dx + bbW - 1) bitAnd: pixPerWord-1) + 1.	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		srcBitIndex _ (sx bitAnd: srcPixPerWord - 1)*sourcePixSize.		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self pickSourcePixels: bbW nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self pickSourcePixels: startBits nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]. 		"Here is the horizontal loop..."		1 to: nWords do: "here is the inner horizontal loop"			[ :word |			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self pickSourcePixels: endBits nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord							bitShift: (pixPerWord-endBits)*destPixSize]]				ifFalse: 				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self pickSourcePixels: pixPerWord nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]!warpLoop	| skewWord halftoneWord mergeWord i word destMask startBits p1x p1y	  deltaP12x deltaP12y deltaP43x deltaP43y p4x p4y pAx pAy	  xDelta yDelta pBx pBy d |	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation." 	d _ height-1.  d<=0 ifTrue: [d _ 1].	p1x _ interpreterProxy fetchInteger: BBWarpBase ofObject: bitBltOop.	p1y _ interpreterProxy fetchInteger: BBWarpBase+1 ofObject: bitBltOop.	deltaP12x _ (interpreterProxy fetchInteger: BBWarpBase+3 ofObject: bitBltOop) - p1x // d.	deltaP12y _ (interpreterProxy fetchInteger: BBWarpBase+4 ofObject: bitBltOop) - p1y // d.	p4x _ interpreterProxy fetchInteger: BBWarpBase+9 ofObject: bitBltOop.	p4y _ interpreterProxy fetchInteger: BBWarpBase+10 ofObject: bitBltOop.	deltaP43x _ (interpreterProxy fetchInteger: BBWarpBase+6 ofObject: bitBltOop) - p4x // d.	deltaP43y _ (interpreterProxy fetchInteger: BBWarpBase+7 ofObject: bitBltOop) - p4y // d.	pAx _ p1x.	pAy _ p1y.	pBx _ p4x.	pBy _ p4y.	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	d _ width-1.  d<=0 ifTrue: [d _ 1]. 	1 to: bbH do: "here is the vertical loop"		[ :i |		sx _ pAx.		sy _ pAy.		xDelta _ pBx - pAx // d.		yDelta _ pBy - pAy // d. 		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self warpSourcePixels: bbW xDelta: xDelta yDelta: yDelta.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self warpSourcePixels: startBits xDelta: xDelta yDelta: yDelta]. 		"Here is the horizontal loop..."		1 to: nWords do: "here is the inner horizontal loop"			[ :word |			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self warpSourcePixels: pixPerWord xDelta: xDelta yDelta: yDelta]]				ifFalse:				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self warpSourcePixels: pixPerWord xDelta: xDelta yDelta: yDelta].		].	pAx _ pAx + deltaP12x.	pAy _ pAy + deltaP12y.	pBx _ pBx + deltaP43x.	pBy _ pBy + deltaP43y.	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'translation support'!cCode: codeString	"For translation only; noop when running in Smalltalk."	^ codeString! !!BitBltSimulation methodsFor: 'combination rules'!alphaBlend: sourceWord with: destinationWord	"Blend sourceWord with destinationWord, assuming both are 32-bit pixels.	The source is assumed to have 255*alpha in the high 8 bits of each pixel,	while the high 8 bits of the destinationWord will be ignored.	The blend produced is alpha*source + (1-alpha)*dest, with	the computation being performed independently on each color	component.  The high byte of the result will be 0."	| alpha unAlpha colorMask result blend i shift |	alpha _ sourceWord >> 24.  "High 8 bits of source pixel"	unAlpha _ 255 - alpha.	colorMask _ 16rFF.	result _ 0.	1 to: 3 do:		[:i | shift _ (i-1)*8.		blend _ (((sourceWord>>shift bitAnd: colorMask) * alpha)					+ ((destinationWord>>shift bitAnd: colorMask) * unAlpha))			 	+ 254 // 255 bitAnd: colorMask.		result _ result bitOr: blend<<shift].	^ result!merge: sourceWord with: destinationWord"	^ self dispatchOn: combinationRule		with: sourceWord with: destinationWord		in: RuleTable."	"These are the combination rules..."combinationRule < 16 ifTrue:[combinationRule < 8 ifTrue:	[combinationRule < 4 ifTrue:		[combinationRule < 2 ifTrue:			[combinationRule < 1 ifTrue:				["0" ^ 0]				ifFalse:				["1" ^ sourceWord bitAnd: destinationWord]]			ifFalse:			[combinationRule < 3 ifTrue:				["2" ^ sourceWord bitAnd: destinationWord bitInvert32]				ifFalse:				["3" ^ sourceWord]]]		ifFalse:		[combinationRule < 6 ifTrue:			[combinationRule < 5 ifTrue:				["4" ^ sourceWord bitInvert32 bitAnd: destinationWord]				ifFalse:				["5" ^ destinationWord]]			ifFalse:			[combinationRule < 7 ifTrue:				["6" ^ sourceWord bitXor: destinationWord]				ifFalse:				["7" ^ sourceWord bitOr: destinationWord]]]]	ifFalse:	[combinationRule < 12 ifTrue:		[combinationRule < 10 ifTrue:			[combinationRule < 9 ifTrue:				["8" ^ sourceWord bitInvert32 bitAnd: destinationWord bitInvert32]				ifFalse:				["9" ^ sourceWord bitInvert32 bitXor: destinationWord]]			ifFalse:			[combinationRule < 11 ifTrue:				["10" ^ destinationWord bitInvert32]				ifFalse:				["11" ^ sourceWord bitOr: destinationWord bitInvert32]]]		ifFalse:		[combinationRule < 14 ifTrue:			[combinationRule < 13 ifTrue:				["12" ^ sourceWord bitInvert32]				ifFalse:				["13" ^ sourceWord bitInvert32 bitOr: destinationWord]]			ifFalse:			[combinationRule < 15 ifTrue:				["14" ^ sourceWord bitInvert32 bitOr: destinationWord bitInvert32]				ifFalse:				["15" ^ destinationWord]]]]]ifFalse:[combinationRule < 24 ifTrue:	[combinationRule < 20 ifTrue:		[combinationRule < 18 ifTrue:			[combinationRule < 17 ifTrue:				["16" ^ destinationWord "no op"]				ifFalse:				["17" ^ destinationWord "no op"]]			ifFalse:			[combinationRule < 19 ifTrue:				["18" ^ sourceWord + destinationWord]				ifFalse:				["19" ^ sourceWord - destinationWord]]]		ifFalse:		[combinationRule < 22 ifTrue:			[combinationRule < 21 ifTrue:				["20" ^ self rgbAdd: sourceWord with: destinationWord]				ifFalse:				["21" ^ self rgbSub: sourceWord with: destinationWord]]			ifFalse:			[combinationRule < 23 ifTrue:				["22" ^ self rgbDiff: sourceWord with: destinationWord]				ifFalse:				["23" ^ self tallyIntoMap: destinationWord]]]]	ifFalse:	[combinationRule < 28 ifTrue:		[combinationRule < 26 ifTrue:			[combinationRule < 25 ifTrue:				["24" ^ self alphaBlend: sourceWord with: destinationWord]				ifFalse:				["25"  ^ self pixPaint: sourceWord with: destinationWord]]			ifFalse:			[combinationRule < 27 ifTrue:				["26" ^ self pixMask: sourceWord with: destinationWord]				ifFalse:				["27" ^ destinationWord "no op"]]]		ifFalse:		[combinationRule < 30 ifTrue:			[combinationRule < 29 ifTrue:				["28" ^ destinationWord "no op"]				ifFalse:				["29" ^ destinationWord "no op"]]			ifFalse:			[combinationRule < 31 ifTrue:				["30" ^ destinationWord "no op"]				ifFalse:				["31" ^ destinationWord "no op"]]]]]!partitionedAdd: word1 to: word2 nBits: nBits nPartitions: nParts	"Add word1 to word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask sum result i |	mask _ (1 << nBits) - 1.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		sum _ (word1 bitAnd: mask) + (word2 bitAnd: mask).		sum <= mask  "result must not carry out of partition"			ifTrue: [result _ result bitOr: sum]			ifFalse: [result _ result bitOr: mask].		mask _ mask << nBits  "slide left to next partition"].	^ result!partitionedAND: word1 to: word2 nBits: nBits nPartitions: nParts	"AND word1 to word2 as nParts partitions of nBits each.	Any field of word1 not all-ones is treated as all-zeroes.	Used for erasing, eg, brush shapes prior to ORing in a color"	| mask result i |	mask _ (1 << nBits) - 1.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		(word1 bitAnd: mask) = mask			ifTrue: [result _ result bitOr: (word2 bitAnd: mask)].		mask _ mask << nBits  "slide left to next partition"].	^ result!partitionedSub: word1 from: word2 nBits: nBits nPartitions: nParts	"Subtract word1 from word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask result i p1 p2 |	mask _ (1 << nBits) - 1.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		p1 _ word1 bitAnd: mask.		p2 _ word2 bitAnd: mask.		p1 < p2  "result is really abs value of thedifference"			ifTrue: [result _ result bitOr: p2 - p1]			ifFalse: [result _ result bitOr: p1 - p2].		mask _ mask << nBits  "slide left to next partition"].	^ result!pixMask: sourceWord with: destinationWord	^ self partitionedAND: sourceWord bitInvert32 to: destinationWord					nBits: destPixSize nPartitions: pixPerWord!pixPaint: sourceWord with: destinationWord	^ sourceWord bitOr:		(self partitionedAND: sourceWord bitInvert32 to: destinationWord						nBits: destPixSize nPartitions: pixPerWord)!rgbAdd: sourceWord with: destinationWord	destPixSize < 16 ifTrue:		["Add each pixel separately"		^ self partitionedAdd: sourceWord to: destinationWord						nBits: destPixSize nPartitions: pixPerWord].	destPixSize = 16 ifTrue:		["Add RGB components of each pixel separately"		^ (self partitionedAdd: sourceWord to: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedAdd: sourceWord>>16 to: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Add RGB components of the pixel separately"		^ self partitionedAdd: sourceWord to: destinationWord						nBits: 8 nPartitions: 3]!rgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, XOR the two and return the number of differing pixels.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| diff pixMask |	destPixSize < 16 ifTrue:		["Just xor and count differing bits if not RGB"		diff _ sourceWord bitXor: destinationWord.		pixMask _ (1 bitShift: destPixSize) - 1.		[diff = 0] whileFalse:			[(diff bitAnd: pixMask) ~= 0 ifTrue: [bitCount _ bitCount + 1].			diff _ diff >> destPixSize].		^ destinationWord "for no effect"]. 	destPixSize = 16		ifTrue:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F).		diff _ (self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F)]		ifFalse:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16rFF)							+ (diff>>8 bitAnd: 16rFF)							+ (diff>>16 bitAnd: 16rFF)].	^ destinationWord  "For no effect on dest"!rgbSub: sourceWord with: destinationWord	destPixSize < 16 ifTrue:		["Sub each pixel separately"		^ self partitionedSub: sourceWord from: destinationWord						nBits: destPixSize nPartitions: pixPerWord].	destPixSize = 16 ifTrue:		["Sub RGB components of each pixel separately"		^ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Sub RGB components of the pixel separately"		^ self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3]!tallyIntoMap: destinationWord	"Tally pixels into the color map.  Note that the source should be 	specified = destination, in order for the proper color map checks 	to be performed at setup.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| mapIndex pixMask shiftWord i |	colorMap = interpreterProxy nilObject		ifTrue: [^ destinationWord "no op"].	destPixSize < 16 ifTrue:		["loop through all packed pixels."		pixMask _ (1<<destPixSize) - 1.		shiftWord _ destinationWord.		1 to: pixPerWord do:			[:i |			mapIndex _ shiftWord bitAnd: pixMask.			interpreterProxy storeWord: mapIndex ofObject: colorMap				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.			shiftWord _ shiftWord >> destPixSize].		^ destinationWord].	destPixSize = 16 ifTrue:		["Two pixels  Tally the right half..."		mapIndex _ self rgbMap: destinationWord from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.		"... and then left half"		mapIndex _ self rgbMap: destinationWord>>16 from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1]	ifFalse:		["Just one pixel."		mapIndex _ self rgbMap: destinationWord from: 8 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'pixel mapping'!pickSourcePixels: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask	"This is intended to be expanded in-line; it merely calls the others"	sourcePixSize >= 16 ifTrue:		[^ self pickSourcePixelsRGB: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask].	nullMap ifTrue:		[^ self pickSourcePixelsNullMap: nPix srcMask: sourcePixMask destMask: destPixMask].	^ self pickSourcePixels: nPix srcMask: sourcePixMask destMask: destPixMask!pickSourcePixels: nPix srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for sourcePixSize <= 8		and colorMap notNil"	"Pick nPix pixels from the source, mapped by the	color map, and right-justify them in the resulting destWord."	| sourceWord destWord sourcePix destPix i |	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		"look up sourcePix in colorMap"		destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask.		destWord _ (destWord << destPixSize) bitOr: destPix.		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord!pickSourcePixelsNullMap: nPix srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for colorMap==nil.		SourcePixelSize is also known to be 8 bits or less."	"With no color map, pixels are just masked or zero-filled."	| sourceWord destWord sourcePix i |	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		destWord _ (destWord << destPixSize) 					bitOr: (sourcePix bitAnd: destPixMask).		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord!pickSourcePixelsRGB: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for destPixSize >= 16"	"Pick nPix pixels from the source, mapped by the	color map, and right-justify them in the resulting destWord.	Incoming pixels of 16 or 32 bits are first reduced to cmBitsPerColor.	With no color map, pixels are just masked or zero-filled or	if 16- or 32-bit pixels, the r, g, and b are so treated individually."	| sourceWord destWord sourcePix destPix i |	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		nullMap		ifTrue:			["Map between RGB pixels"			sourcePixSize = 16				ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]				ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]		ifFalse:			["RGB pixels first get reduced to cmBitsPerColor"			sourcePixSize = 16				ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]				ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor].			"Then look up sourcePix in colorMap"			destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask].		destWord _ (destWord << destPixSize) bitOr: destPix.		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord!rgbMap: sourcePixel from: nBitsIn to: nBitsOut	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."	| mask d srcPix destPix |	(d _ nBitsOut - nBitsIn) > 0		ifTrue:			["Expand to more bits by zero-fill"			mask _ (1 << nBitsIn) - 1.  "Transfer mask"			srcPix _ sourcePixel << d.			mask _ mask << nBitsOut.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix << d.			^ destPix + (srcPix bitAnd: mask)				 	+ (srcPix << d bitAnd: mask << nBitsOut)]		ifFalse:			["Compress to fewer bits by truncation"			d = 0 ifTrue: [^ sourcePixel].			d _ nBitsIn - nBitsOut.			mask _ (1 << nBitsOut) - 1.  "Transfer mask"			srcPix _ sourcePixel >> d.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix >> d.			^ destPix + (srcPix bitAnd: mask)					+ (srcPix >> d bitAnd: mask << nBitsOut)]!warpSourcePixels: nPix xDelta: xDelta yDelta: yDelta	"Pick nPix using arbitrary x- and y-incs, and map color if necess."	| sourceWord destWord sourcePix i sourcePixMask destPixMask x y srcPixPerWord nullMap destPix |	sourcePixMask _ (1 << sourcePixSize) - 1.	srcPixPerWord _ 32 // sourcePixSize.	destPixMask _ (1 << destPixSize) - 1.	destWord _ 0.	nullMap _ colorMap = interpreterProxy nilObject.	1 to: nPix do:		[:i |		x _ sx // FixedPt1.		y _ sy // FixedPt1.		((x >= 0 and: [x < srcWidth])			and:  [y >= 0 and: [y < srcHeight]])		ifTrue:			[sourceIndex _ (sourceBits + 4) + (y * sourceRaster + (x // srcPixPerWord) *4).			sourceWord _ interpreterProxy longAt: sourceIndex.			sourcePix _ sourceWord >> ((32-sourcePixSize) - (x\\srcPixPerWord*sourcePixSize))						bitAnd: sourcePixMask.			nullMap ifTrue:				[destPixSize = sourcePixSize ifTrue:					[destPix _ sourcePix]				ifFalse:					[sourcePixSize >= 16 ifTrue:						["Map between RGB pixels"						sourcePixSize = 16							ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]							ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]					ifFalse: [destPix _ sourcePix bitAnd: destPixMask]]]			ifFalse:				[sourcePixSize >= 16 ifTrue:					["RGB pixels first get reduced to cmBitsPerColor"					sourcePixSize = 16						ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]						ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor]].				"Then look up sourcePix in colorMap"				destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask]]		ifFalse: [destPix _ 0].		destWord _ (destWord << destPixSize) bitOr: destPix.		sx _ sx + xDelta.		sy _ sy + yDelta.		].	^ destWord! !!BitBltSimulation class methodsFor: 'initialization'!initialize	"BitBltSimulation initialize" 	"Mask constants"	AllOnes _ 16rFFFFFFFF.	FixedPt1 _ 16384.  "Value of 1.0 in fixed-point representation" 	"Indices into stopConditions for scanning"	EndOfRun _ 257.	CrossedX _ 258. 	"Form fields"	FormBitsIndex _ 0.	FormWidthIndex _ 1.	FormHeightIndex _ 2.	FormDepthIndex _ 3. 	"BitBlt fields"	BBDestFormIndex _ 0.	BBSourceFormIndex _ 1.	BBHalftoneFormIndex _ 2.	BBRuleIndex _ 3.	BBDestXIndex _ 4.	BBDestYIndex _ 5.	BBWidthIndex _ 6.	BBHeightIndex _ 7.	BBSourceXIndex _ 8.	BBSourceYIndex _ 9.	BBClipXIndex _ 10.	BBClipYIndex _ 11.	BBClipWidthIndex _ 12.	BBClipHeightIndex _ 13.	BBColorMapIndex _ 14.	BBWarpBase _ 15.	BBLastIndex _ 15.	BBXTableIndex _ 16.!test2  "BitBltSimulation test2"	| f |	Display fillWhite: (0@0 extent: 300@140).	1 to: 12 do:		[:i | f _ (Form extent: i@5) fillBlack.		0 to: 20 do:			[:x | f displayOn: Display					at: (x*13) @ (i*10)]]!timingTest: extent  "BitBltSimulation timingTest: 640@480"	| f f2 map |	f _ Form extent: extent depth: 8.	f2 _ Form extent: extent depth: 8.	map _ Bitmap new: 1 << f2 depth.	^ Array with:	(Time millisecondsToRun: [100 timesRepeat:		[f fillWithColor: Color white]])	with:	(Time millisecondsToRun: [100 timesRepeat:		[f copy: f boundingBox from: 0@0 in: f2 rule: Form over]])	with:	(Time millisecondsToRun: [100 timesRepeat:		[f copyBits: f boundingBox from: f2 at: 0@0 colorMap: map]])! !!BitBltSimulation class methodsFor: 'translation'!declareCVarsIn: aCCodeGenerator	"Nothing to declare..."! !!BlockNode methodsFor: 'C translation'!asTranslatorNode	| statementList newS |	statementList _ OrderedCollection new.	statements do: [ :s |		newS _ s asTranslatorNode.		newS isStmtList ifTrue: [			"inline the statement list returned when a CascadeNode is translated"			statementList addAll: newS statements.		] ifFalse: [			statementList add: newS.		].	].	^TStmtListNode new		setArguments: (arguments asArray collect: [ :arg | arg key ])		statements: statementList! !BooleanObj comment:'An object whose contents are constrained to boolean values'!!BooleanObj methodsFor: 'everything'!mouseUpAt: aPoint in: aView	"The mouse came up in the object, at the given point.  User overrides this if desired.  6/12/96 sw"	contents _ (contents == true) not.	self setExtentToMatchCostume.	aView displayInterior!setDefaultContents	"For a newly-launched object, set its contents to a default value, if appropriate.  6/2/96 sw" 	contents _ true!type	"Answer the receiver's formal type.  6/12/96 sw"	^ #Boolean! !BoxCostume comment:'Displays a simple colored rectangle.'!!BoxCostume methodsFor: 'display'!chooseCostumeDetailsFor: anObject in: aView	"Choose color for the object.  Later on we may wish to deal with different geometric shapes, border widths, etc. but for now just color.  6/6/96 sw	 7/8/96 sw: new Color formalism"	| aColor |	(aColor _ Color fromUser) ~~ nil ifTrue:		[anObject setParameter: aColor forKey: #BoxColor]!display: anObject onCanvas: aCanvas	"Display the object on the canvas, using the receiver as its rectangular, solid-color costume.  Obtain the desired color from the object itself.  6/6/96 sw"	| aColor |	((aColor _ anObject parameterFor: #BoxColor) == nil)		ifTrue:			[aColor _ Color blue].	aCanvas fillWithColor: aColor.! !!BrowserView class methodsFor: 'instance creation'!instanceBrowserViewOn: aBrowser	"Answer an instance of me on the model, aBrowser, which looks at a user-defined instance-class. The view has three subviews.  3/11/96 sw"	| browserView  messageCategoryListView messageListView browserCodeView |	browserView _ self new model: aBrowser.	messageCategoryListView _ self buildMessageCategoryListView: aBrowser.	messageListView _ self buildMessageListView: aBrowser.	browserCodeView _ self buildBrowserCodeView: aBrowser editString: nil.	browserView addSubView: messageCategoryListView.	browserView addSubView: messageListView.	browserView addSubView: browserCodeView.	messageListView 		align: messageListView viewport topLeft 		with: messageCategoryListView viewport topRight.	browserCodeView 		window: browserCodeView window 		viewport: (messageCategoryListView viewport bottomLeft 					corner: messageListView viewport bottomRight + (0 @ 110)).	^ browserView! !!ByteArray methodsFor: 'private'!printOn: aStream 	"Refer to the comment in Object|printOn:."	| tooMany |	tooMany _ aStream position + self maxPrint.	aStream nextPutAll: self class name, ' ('.	self do: 		[:element | 		aStream position > tooMany ifTrue: [aStream nextPutAll: '...etc...)'. ^self].		aStream nextPutAll: element asCharacter hex; space].	aStream nextPut: $)! !!CascadeNode methodsFor: 'C translation'!asTranslatorNode	^TStmtListNode new		setArguments: #()		statements: (messages collect:			[ :msg | msg asTranslatorNode receiver: receiver asTranslatorNode ])! !CCodeGenerator comment:'This class oversees the translation of a subset of Smalltalk to C, allowing the comforts of Smalltalk during development and the efficiency and portability of C for the resulting interpreter.  Executing	Interpreter translate: ''InterpTest.c'' doInlining: true.(with single quotes) will cause all the methods of Interpreter, ObjectMemory and BitBltSimulation to be translated to C, and stored in the named file.  This file together with the files emitted by InterpreterSupportCode (qv) should be adequate to produce a complete interpreter for the Macintosh environment.'!!CCodeGenerator methodsFor: 'public'!addClass: aClass	"Add the variables and methods of the given class to the code base."	| source |	self checkClassForNameConflicts: aClass.	aClass classPool associationsDo: [ :assoc |		constants at: assoc key put: (TConstantNode new setValue: assoc value).	].	variables addAll: aClass instVarNames.'Adding Class ' , aClass name , '...'displayProgressAt: Sensor cursorPointfrom: 0 to: aClass selectors sizeduring: [:bar |	aClass selectors doWithIndex: [ :sel :i | bar value: i.		source _ aClass sourceCodeAt: sel.		self addMethod: ((Compiler new parse: source in: aClass notifying: nil) asTMethodFromClass: aClass).	]].!codeString	"Return a string containing all the C code for the code base. Used for testing."	| stream |	stream _ ReadWriteStream on: (String new: 1000).	self emitCCodeOn: stream doInlining: true.	^stream contents!codeStringForPrimitives: classAndSelectorList	"CCodeGenerator new codeStringForPrimitives: #(		(FMSound mixSampleCount:into:startingAt:)	)"	| sel aClass source s verbose meth |	self initialize.	classAndSelectorList do: [ :classAndSelector |		aClass _ Smalltalk at: (classAndSelector at: 1).		sel _ classAndSelector at: 2.		source _ aClass sourceCodeAt: sel.		meth _ ((Compiler new parse: source in: aClass notifying: nil)				asTMethodFromClass: aClass).		meth preparePrimitiveInClass: aClass.		self addMethod: meth.	].	s _ ReadWriteStream on: (String new: 1000).	"method preparation"	verbose _ false.	self prepareMethods.	verbose ifTrue: [		self printUnboundCallWarnings.		self printUnboundVariableReferenceWarnings.		Transcript cr.	].	"code generation"	methods _ methods asSortedCollection: [ :m1 :m2 | m1 selector < m2 selector ].	self emitCHeaderForPrimitivesOn: s.	self emitCVariablesOn: s.	self emitCFunctionPrototypesOn: s.	methods do: [ :m | m emitCCodeOn: s generator: self ].	^ s contents!globalsAsSet	"Used by the inliner to avoid name clashes with global variables."	((variablesSetCache == nil) or:	 [variablesSetCache size ~= variables size]) ifTrue: [		variablesSetCache _ variables asSet.	].	^ variablesSetCache!initialize	translationDict _ Dictionary new.	inlineList _ Array new.	constants _ Dictionary new.	variables _ OrderedCollection new.	variableDeclarations _ Dictionary new.	methods _ Dictionary new.	self initializeCTranslationDictionary.!storeCodeOnFile: fileName doInlining: inlineFlag	"Store C code for this code base on the given file."	| stream |	stream _ FileStream fileNamed: fileName.	self emitCCodeOn: stream doInlining: inlineFlag.	stream close.!var: varName declareC: declarationString	"Record the given C declaration for a global variable."	variableDeclarations at: varName put: declarationString.! !!CCodeGenerator methodsFor: 'error notification'!checkClassForNameConflicts: aClass	"Verify that the given class does not have constant, variable, or method names that conflict with those of previously added classes. Raise an error if a conflict is found, otherwise just return."	"check for constant name collisions"	aClass classPool associationsDo: [ :assoc |		(constants includesKey: assoc key) ifTrue: [			self error: 'Constant was defined in a previously added class: ', assoc key.		].	].	"check for instance variable name collisions"	aClass instVarNames do: [ :varName |		(variables includes: varName) ifTrue: [			self error: 'Instance variable was defined in a previously added class: ', varName.		].	].	"check for method name collisions"	aClass selectors do: [ :sel |		(methods includesKey: sel) ifTrue: [			self error: 'Method was defined in a previously added class: ', sel.		].	].!printUnboundCallWarnings	"Print a warning message for every unbound method call in the code base."	| knownSelectors undefinedCalls |	undefinedCalls _ Dictionary new.	knownSelectors _ translationDict keys asSet.	knownSelectors add: #error:.	methods do: [ :m | knownSelectors add: m selector ].	methods do: [ :m |		m allCalls do: [ :sel |			(knownSelectors includes: sel) ifFalse: [				(undefinedCalls includesKey: sel)					ifTrue: [ (undefinedCalls at: sel) add: m selector ]					ifFalse: [ undefinedCalls at: sel put: (OrderedCollection with: m selector) ].			].		].	].	Transcript cr.	undefinedCalls keys asSortedCollection do: [ :undefined |		Transcript show: undefined, ' -- undefined method sent by:'; cr.		(undefinedCalls at: undefined) do: [ :caller |			Transcript tab; show: caller; cr.		].	].!printUnboundVariableReferenceWarnings	"Print a warning message for every unbound variable reference in the code base."	| undefinedRefs globalVars knownVars |	undefinedRefs _ Dictionary new.	globalVars _ Set new: 100.	globalVars addAll: variables.	methods do: [ :m |		knownVars _ globalVars copy.		m args do: [ :var | knownVars add: var ].		m locals do: [ :var | knownVars add: var ].		m freeVariableReferences do: [ :varName |			(knownVars includes: varName) ifFalse: [				(undefinedRefs includesKey: varName)					ifTrue: [ (undefinedRefs at: varName) add: m selector ]					ifFalse: [ undefinedRefs at: varName put: (OrderedCollection with: m selector) ].			].		].	].	Transcript cr.	undefinedRefs keys asSortedCollection do: [ :var |		Transcript show: var, ' -- undefined variable used in:'; cr.		(undefinedRefs at: var) do: [ :sel |			Transcript tab; show: sel; cr.		].	].! !!CCodeGenerator methodsFor: 'inlining'!collectInlineList	"Make a list of methods that should be inlined."	"Details: The method must not include any inline C, since the translator cannot currently map variable names in inlined C code. Methods to be inlined must be small or called from only one place."	| callsOf hasCCode nodeCount senderCount methodsWithCCode |	methodsWithCCode _ Set new: methods size.	"build dictionary to record the number of calls to each method"	callsOf _ Dictionary new: methods size * 2.	methods keys do: [ :sel | callsOf at: sel put: 0 ].	"For each method, scan its parse tree once to:		1. determine if the method contains C code or declarations		2. determine how many nodes it has		3. increment the sender counts of the methods it calls		4. determine if it includes any C declarations or code"	inlineList _ Set new: methods size * 2.	methods do: [ :m |		(translationDict includesKey: m selector) ifTrue: [			hasCCode _ true.		] ifFalse: [			hasCCode _ m declarations size > 0.			nodeCount _ 0.			m parseTree nodesDo: [ :node |				node isSend ifTrue: [					sel _ node selector.					sel = #cCode: ifTrue: [ hasCCode _ true ].					senderCount _ callsOf at: sel ifAbsent: [ nil ].					nil = senderCount ifFalse: [						callsOf at: sel put: senderCount + 1.					].				].				nodeCount _ nodeCount + 1.			].		].		hasCCode ifTrue: [			methodsWithCCode add: m selector.		] ifFalse: [			(nodeCount < 40) ifTrue: [ inlineList add: m selector ].		].	].	callsOf associationsDo: [ :assoc |		((assoc value = 1) and: [(methodsWithCCode includes: assoc key) not]) ifTrue: [			inlineList add: assoc key.		].	].!doInline: selList	"Inline calls to the given methods (if possible) even if it is over the size threshold."	| m |	selList do: [ :sel |		(translationDict includesKey: sel) ifTrue: [ ^self ].		m _ self methodNamed: sel.		((m ~= nil) and: [m hasNoCCode]) ifTrue: [			inlineList add: sel.		].	].!doInlining	"Inline the bodies of all methods that are suitable for inlining."	"Interpreter translate: 'InterpTest.c' doInlining: true"	| progress pass |	self collectInlineList.	self doInline: #(		sendSelectorToClass:		internalSendSelector:argumentCount:		stObject:at:		stObject:at:put:		sufficientSpaceToInstantiate:indexableSize:.		sufficientSpaceToAllocate:.		booleanCheat:		findNewMethodInClass:		objectAfter:		objectAfterWhileForwarding:		remapFieldsAndClassOf:		lastPointerWhileForwarding:		lastPointerOf:		initForwardBlock:mapping:to:		extraHeaderBytes:		allocate:headerSize:h1:h2:h3:fill:		allocateOrRecycleContext:		recycleContextIfPossible:		fetchClassOf:		subscript:with:		lengthOf:		subscript:with:storing:		merge:with:		rgbMap:from:to:		extendedStoreBytecode		returnToActiveContext:		fetchContextRegisters		storeContextRegisters		transfer:fromIndex:ofObject:toIndex:ofObject:	).	self doNotInline: #(		externalSendSelector:argumentCount:		returnValue:to:		rgbAdd:with:  "complex BitBlt functions"		rgbSub:with:		rgbDiff:with:		tallyIntoMap:		pixPaint:with:		pixMask:with:		alphaBlend:with:		lowestFreeAfter:		sufficientSpaceAfterGC:		instantiateClass:indexableSize:		loadScannerFrom:start:stop:string:rightX:stopArray:displayFlag:		beRootIfOld:		checkForInterrupts		activateNewMethod		commonSelectorPrimitive:		fullGC		incrementalGC		markPhase		sweepPhase		incCompBody		fwdTableInit		mapPointersInObjectsFrom:to:		remap:		incCompMove		synchronousSignal:		resume:		initializeObjectMemory:		copyLoop		copyLoopNoSource		copyLoopPixMap.		accessibleObjectAfter:		executeNewMethod:		fetchInteger:ofObject:		fetchWordLengthOf:		possibleRootStoreInto:value:	).	self flag: #jhm.	self doNotInline: Interpreter primitiveTable.	progress _ true.	pass _ 0.	[progress] whileTrue: [		"repeatedly attempt to inline methods until no further progress is made"		progress _ false.		'Inlining pass #' , (pass _ pass+1) printString , '...'			displayProgressAt: Sensor cursorPoint			from: 0 to: methods size			during: [:bar |				methods doWithIndex:					[ :m :i | bar value: i.					(m tryToInlineMethodsIn: self)						ifTrue: [ progress _ true ]]].	].	self inlineDispatchesInMethodNamed: #interpret		localizingVars: #(currentBytecode localIP localSP).	self removeMethodsReferingToGlobals: #(currentBytecode localIP localSP)		except: #interpret.!doNotInline: selList	"Remove the methods with the given selectors from the list of methods to be inlined."	selList do: [ :sel |		inlineList remove: sel ifAbsent: [].	].!inlineDispatchesInMethodNamed: selector localizingVars: varsList	"Inline dispatches (case statements) in the method with the given name."	| m |	m _ self methodNamed: selector.	m = nil ifFalse: [		m inlineCaseStatementBranchesIn: self localizingVars: varsList.		m parseTree nodesDo: [ :n |			n isCaseStmt ifTrue: [				n customizeShortCasesForDispatchVar: #currentBytecode.			].		].	].	variables _ variables asOrderedCollection.	varsList do: [ :v | variables remove: v asString ifAbsent: [] ].!mayInline: sel	"Answer true if the method with the given selector may be inlined."	^ inlineList includes: sel!methodStatsString	"Return a string describing the size, # of locals, and # of senders of each method. Note methods that have inline C code or C declarations."	| methodsWithCCode sizesOf callsOf hasCCode nodeCount senderCount sel s calls registers |	methodsWithCCode _ Set new: methods size.	sizesOf _ Dictionary new: methods size * 2.  "selector -> nodeCount"	callsOf _ Dictionary new: methods size * 2.  "selector -> senderCount"	"For each method, scan its parse tree once to:		1. determine if the method contains C code or declarations		2. determine how many nodes it has		3. increment the sender counts of the methods it calls		4. determine if it includes any C declarations or code"	methods do: [ :m |		(translationDict includesKey: m selector) ifTrue: [			hasCCode _ true.		] ifFalse: [			hasCCode _ m declarations size > 0.			nodeCount _ 0.			m parseTree nodesDo: [ :node |				node isSend ifTrue: [					sel _ node selector.					sel = #cCode: ifTrue: [ hasCCode _ true ].					senderCount _ callsOf at: sel ifAbsent: [ 0 ].					callsOf at: sel put: senderCount + 1.				].				nodeCount _ nodeCount + 1.			].		].		hasCCode ifTrue: [ methodsWithCCode add: m selector ].		sizesOf at: m selector put: nodeCount.	].	s _ (String new: 5000) writeStream.	methods keys asSortedCollection do: [ :sel |		m _ methods at: sel.		registers _ m locals size + m args size.		calls _ callsOf at: sel ifAbsent: [0].		registers > 11 ifTrue: [			s nextPutAll: sel; tab.			s nextPutAll: (sizesOf at: sel) printString; tab.			s nextPutAll: calls printString; tab.			s nextPutAll: registers printString; tab.			(methodsWithCCode includes: sel) ifTrue: [ s nextPutAll: 'CCode' ].		s cr.		].	].	^ s contents!removeMethodsReferingToGlobals: varList except: methodName	"Remove any methods (presumably inlined) that still contain references to the given obsolete global variables."	| varListAsStrings removeIt mVars |	varListAsStrings _ varList collect: [ :sym | sym asString ].	methods keys copy do: [ :sel |		removeIt _ false.		mVars _ (self methodNamed: sel) freeVariableReferences asSet.		varListAsStrings do: [ :v |			(mVars includes: v) ifTrue: [ removeIt _ true ].		].		(removeIt and: [sel ~= methodName]) ifTrue: [			methods removeKey: sel ifAbsent: [].		].	].! !!CCodeGenerator methodsFor: 'utilities'!addMethod: aTMethod	"Add the given method to the code base."	(methods includesKey:  aTMethod selector) ifTrue: [		self error: 'Method name conflict: ', aTMethod selector.	].	methods at: aTMethod selector put: aTMethod.!builtin: sel	"Answer true if the given selector is one of the builtin selectors."	((sel = #longAt:) or: [(sel = #longAt:put:) or: [sel = #error:]]) ifTrue: [ ^true ].	((sel = #byteAt:) or: [sel = #byteAt:put:]) ifTrue: [ ^true ].	^translationDict includesKey: sel!cCodeForMethod: selector	"Answer a string containing the C code for the given method."	"Example:		((CCodeGenerator new initialize addClass: TestCClass1; prepareMethods)			cCodeForMethod: #ifTests)"	| m s |	m _ self methodNamed: selector.	m = nil ifTrue: [ self error: 'method not found in code base: ', selector ].	s _ (ReadWriteStream on: '').	m emitCCodeOn: s generator: self.	^ s contents!emitBuiltinConstructFor: msgNode on: aStream level: level	"If the given selector is in the translation dictionary, translate it into a target code construct and return true. Otherwise, do nothing and return false."	| action |	action _ translationDict at: msgNode selector ifAbsent: [ ^false ].	self perform: action with: msgNode with: aStream with: level.	^true!methodNamed: selector	"Answer the method in the code base with the given selector."	^ methods at: selector ifAbsent: [ nil ]!methodsReferringToGlobal: v	"Return a collection of methods that refer to the given global variable."	| out |	out _ OrderedCollection new.	methods associationsDo: [ :assoc |		(assoc value freeVariableReferences includes: v) ifTrue: [			out add: assoc key.		].	].	^ out!methodsThatCanInvoke: aSelectorList	"Return a set of methods that can invoke one of the given selectors, either directly or via a sequence of intermediate methods."	| out todo sel mSelector |	out _ Set new.	todo _ aSelectorList copy asOrderedCollection.	[todo isEmpty] whileFalse: [		sel _ todo removeFirst.		out add: sel.		methods do: [ :m |			(m allCalls includes: sel) ifTrue: [				mSelector _ m selector.				((out includes: mSelector) or:				 [todo includes: mSelector]) ifFalse: [					todo add: mSelector.				].			].		].	].	^ out	!prepareMethods	"Prepare methods for browsing."	| globals |	globals _ Set new: 200.	globals addAll: variables.	methods do: [ :m |		(m locals, m args) do: [ :var |			(globals includes: var) ifTrue: [				self error: 'Local variable name may mask global when inlining: ', var.			].			(methods includesKey: var) ifTrue: [				self error: 'Local variable name may mask method when inlining: ', var.			].			].		m bindClassVariablesIn: constants.		m prepareMethodIn: self.	].!reportRecursiveMethods	"Report in transcript all methods that can call themselves directly or indirectly or via a chain of N intermediate methods."	| visited calls newCalls sel called |	methods do: [: m |		visited _ translationDict keys asSet.		calls _ m allCalls asOrderedCollection.		5 timesRepeat: [			newCalls _ Set new: 50.			[calls isEmpty] whileFalse: [				sel _ calls removeFirst.				sel = m selector ifTrue: [					Transcript show: m selector, ' is recursive'; cr.				] ifFalse: [					(visited includes: sel) ifFalse: [						called _ self methodNamed: sel.						called = nil ifFalse: [ newCalls addAll: called allCalls ].					].					visited add: sel.				].			].			calls _ newCalls asOrderedCollection.		].	].!unreachableMethods	"Return a collection of methods that are never invoked."	| sent out |	sent _ Set new.	methods do: [ :m |		sent addAll: m allCalls.	].	out _ OrderedCollection new.	methods keys do: [ :sel |		(sent includes: sel) ifFalse: [ out add: sel ].	].	^ out! !!CCodeGenerator methodsFor: 'C code generator'!cFunctionNameFor: aSelector	"Create a C function name from the given selector by omitting colons."	^aSelector copyWithout: $:!cLiteralFor: anObject	"Return a string representing the C literal value for the given object."	| s |	(anObject isKindOf: Integer) ifTrue: [^ anObject printString ].	(anObject isKindOf: String) ifTrue: [^ '"', anObject, '"' ].	(anObject isKindOf: Float) ifTrue: [^ anObject printString ].	anObject == nil ifTrue: [^ 'null' ].	Transcript show:		'Warning: A Smalltalk literal could not be translated into a C constant'; cr.	^'"XXX UNTRANSLATABLE CONSTANT XXX"'!emitCCodeOn: aStream doInlining: inlineFlag	"Emit C code for all methods in the code base onto the given stream. All inlined method calls should already have been expanded."	| verbose |	"method preparation"	verbose _ false.	self prepareMethods.	verbose ifTrue: [		self printUnboundCallWarnings.		self printUnboundVariableReferenceWarnings.		Transcript cr.	].	inlineFlag ifTrue: [ self doInlining ].	"code generation"	methods _ methods asSortedCollection: [ :m1 :m2 | m1 selector < m2 selector ].	self emitCHeaderOn: aStream.	self emitCVariablesOn: aStream.	self emitCFunctionPrototypesOn: aStream.'Writing Translated Code...'displayProgressAt: Sensor cursorPointfrom: 0 to: methods sizeduring: [:bar |	methods doWithIndex: [ :m :i | bar value: i.		m emitCCodeOn: aStream generator: self.]].!emitCExpression: aParseNode on: aStream	"Emit C code for the expression described by the given parse node."	aParseNode isLeaf ifTrue: [		"omit parens"		aParseNode emitCCodeOn: aStream level: 0 generator: self.	] ifFalse: [		aStream nextPut: $(.		aParseNode emitCCodeOn: aStream level: 0 generator: self.		aStream nextPut: $).	].!emitCFunctionPrototypesOn: aStream	"Store prototype declarations for all non-inlined methods on the given stream."	aStream nextPutAll: '/*** Function Prototypes ***/'; cr.	methods do: [ :m |		m emitCFunctionPrototype: aStream generator: self.		aStream nextPutAll: ';'; cr.	].!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: '*/'; cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr; cr.	aStream nextPutAll: '#define true 1'; cr.	aStream nextPutAll: '#define false 0'; cr.	"Note: Using 'null' because nil is predefined in Think C"	aStream nextPutAll: '#define null 0'; cr.	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define floatAt(i) (*((double *) (i)))#define floatAtput(i, val) (*((double *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Imported Variables ***/extern int stackPointer;extern int successFlag;'.	aStream cr.!emitCHeaderOn: aStream	"Write a C file header onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: '*/'; cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr; cr.	aStream nextPutAll: '#define true 1'; cr.	aStream nextPutAll: '#define false 0'; cr.	"Note: Using 'null' because nil is predefined in Think C"	aStream nextPutAll: '#define null 0'; cr.	aStream nextPutAll: '/* memory access macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define floatAt(i) (*((double *) (i)))#define floatAtput(i, val) (*((double *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)int printCallStack(void);void error(char *s);void error(char *s) {	/* Print an error message and exit. */	static int printingStack = false;	printf("\n%s\n\n", s);	if (!!printingStack) {		/* flag prevents recursive error when trying to print a broken stack */		printingStack = true;		printCallStack();	}	exit(-1);}'.	aStream cr.!emitCTestBlock: aBlockNode on: aStream	"Emit C code for the given block node to be used as a loop test."	aBlockNode statements size > 1 ifTrue: [		aBlockNode emitCCodeOn: aStream level: 0 generator: self.	] ifFalse: [		aBlockNode statements first emitCCodeOn: aStream level: 0 generator: self.	].!emitCVariablesOn: aStream	"Store the global variable declarations on the given stream."	aStream nextPutAll: '/*** Variables ***/'; cr.	variables asSortedCollection do: [ :var |		(variableDeclarations includesKey: var) ifTrue: [			aStream nextPutAll: (variableDeclarations at: var), ';'; cr.		] ifFalse: [			"default variable declaration"			aStream nextPutAll: 'int ', var, ';'; cr.		].	].	aStream cr.! !!CCodeGenerator methodsFor: 'C translation'!generateAnd: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' && '.	self emitCExpression: msgNode args first on: aStream.!generateAt: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '['.	msgNode args first emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ']'.!generateAtPut: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '['.	msgNode args first emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: '] = '.	self emitCExpression: msgNode args last on: aStream.!generateBitAnd: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' & '.	self emitCExpression: msgNode args first on: aStream.!generateBitInvert32: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '~'.	self emitCExpression: msgNode receiver on: aStream.!generateBitOr: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' | '.	self emitCExpression: msgNode args first on: aStream.!generateBitShift: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| arg rcvr |	arg _ msgNode args first.	rcvr _ msgNode receiver.	arg isConstant ifTrue: [		"bit shift amount is a constant"		aStream nextPutAll: '((unsigned) '.		self emitCExpression: rcvr on: aStream.		arg value < 0 ifTrue: [			aStream nextPutAll: ' >> ', arg value negated printString.		] ifFalse: [			aStream nextPutAll: ' << ', arg value printString.		].		aStream nextPutAll: ')'.	] ifFalse: [		"bit shift amount is an expression"		aStream nextPutAll: '(('.		self emitCExpression: arg on: aStream.		aStream nextPutAll: ' < 0) ? ((unsigned) '.		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' >> -'.		self emitCExpression: arg on: aStream.		aStream nextPutAll: ') : ((unsigned) '.		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' << '.		self emitCExpression: arg on: aStream.		aStream nextPutAll: '))'.	].!generateBitXor: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' ^ '.	self emitCExpression: msgNode args first on: aStream.!generateDivide: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' / '.	self emitCExpression: msgNode args first on: aStream.!generateEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' == '.	self emitCExpression: msgNode args first on: aStream.!generateGreaterThan: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' > '.	self emitCExpression: msgNode args first on: aStream.!generateGreaterThanOrEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' >= '.	self emitCExpression: msgNode args first on: aStream.!generateIfFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler produces two arguments for ifFalse:, presumably	 to help with inlining later. Taking the last agument should do the correct	 thing even if your compiler is different."	aStream nextPutAll: 'if (!!('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ')) {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateIfFalseIfTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler reverses the argument blocks for ifFalse:ifTrue:,       presumably to help with inlining later. That is, the first argument       is the block to be evaluated if the condition is true."	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} else {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateIfTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateIfTrueIfFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} else {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateInlineCCode: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: msgNode args first value.!generateIntegerObjectOf: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ' << 1) | 1)'.!generateIntegerValueOf: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '('.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ' >> 1)'.!generateIsIntegerObject: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ' & 1) == 1)'.!generateIsNil: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' == '.	aStream nextPutAll: (self cLiteralFor: nil).!generateLessThan: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' < '.	self emitCExpression: msgNode args first on: aStream.!generateLessThanOrEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' <= '.	self emitCExpression: msgNode args first on: aStream.!generateMax: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' < '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ') ? '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ' : '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ')'.!generateMin: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' < '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ') ? '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' : '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.!generateMinus: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' - '.	self emitCExpression: msgNode args first on: aStream.!generateModulo: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' % '.	self emitCExpression: msgNode args first on: aStream.!generateNot: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '!!'.	self emitCExpression: msgNode receiver on: aStream.!generateNotEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' !!= '.	self emitCExpression: msgNode args first on: aStream.!generateNotNil: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' !!= '.	aStream nextPutAll: (self cLiteralFor: nil).!generateOr: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' || '.	self emitCExpression: msgNode args first on: aStream.!generatePlus: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' + '.	self emitCExpression: msgNode args first on: aStream.!generatePreDecrement: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| varNode |	varNode _ msgNode receiver.	varNode isVariable		ifFalse: [ self error: 'preDecrement can only be applied to variables' ].	aStream nextPutAll: '--'.	aStream nextPutAll: varNode name.!generatePreIncrement: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| varNode |	varNode _ msgNode receiver.	varNode isVariable		ifFalse: [ self error: 'preIncrement can only be applied to variables' ].	aStream nextPutAll: '++'.	aStream nextPutAll: varNode name.!generateSequentialAnd: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' && ('.	self emitCTestBlock: msgNode args first on: aStream.	aStream nextPutAll: ')'.!generateSequentialOr: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler produces two arguments for or:, presumably	 to help with inlining later. Taking the last agument should do the correct	 thing even if your compiler is different."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' || ('.	self emitCTestBlock: msgNode args last on: aStream.	aStream nextPutAll: ')'.!generateShiftLeft: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' << '.	self emitCExpression: msgNode args first on: aStream.!generateShiftRight: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '((unsigned) '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ')'.	aStream nextPutAll: ' >> '.	self emitCExpression: msgNode args first on: aStream.!generateTimes: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' * '.	self emitCExpression: msgNode args first on: aStream.!generateToByDo: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| iterationVar |	(msgNode args last args size = 1) ifFalse: [		self error: 'wrong number of block arguments'.	].	iterationVar _ msgNode args last args first.	aStream nextPutAll: 'for (', iterationVar, ' = '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '; ', iterationVar, ' <= '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: '; ', iterationVar, ' += '.	self emitCExpression: (msgNode args at: 2) on: aStream.	aStream nextPutAll: ') {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateToDo: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| iterationVar |	(msgNode args last args size = 1) ifFalse: [		self error: 'wrong number of block arguments'.	].	iterationVar _ msgNode args last args first.	aStream nextPutAll: 'for (', iterationVar, ' = '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '; ', iterationVar, ' <= '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: '; ', iterationVar, '++) {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateWhileFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'while (!!('.	self emitCTestBlock: msgNode receiver on: aStream.	aStream nextPutAll: ')) {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateWhileTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'while ('.	self emitCTestBlock: msgNode receiver on: aStream.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	translationDict _ Dictionary new: 200.	pairs _ #(	#&				#generateAnd:on:indent:	#|				#generateOr:on:indent:	#and:			#generateSequentialAnd:on:indent:	#or:			#generateSequentialOr:on:indent:	#not			#generateNot:on:indent:	#+				#generatePlus:on:indent:	#-				#generateMinus:on:indent:	#*				#generateTimes:on:indent:	#//				#generateDivide:on:indent:	#\\				#generateModulo:on:indent:	#<<				#generateShiftLeft:on:indent:	#>>				#generateShiftRight:on:indent:	#min:			#generateMin:on:indent:	#max:			#generateMax:on:indent:	#bitAnd:		#generateBitAnd:on:indent:	#bitOr:			#generateBitOr:on:indent:	#bitXor:			#generateBitXor:on:indent:	#bitShift:		#generateBitShift:on:indent:	#bitInvert32	#generateBitInvert32:on:indent:	#<				#generateLessThan:on:indent:	#<=				#generateLessThanOrEqual:on:indent:	#=				#generateEqual:on:indent:	#>				#generateGreaterThan:on:indent:	#>=				#generateGreaterThanOrEqual:on:indent:	#~=			#generateNotEqual:on:indent:	#==				#generateEqual:on:indent:	#isNil			#generateIsNil:on:indent:	#notNil			#generateNotNil:on:indent:	#whileTrue:	#generateWhileTrue:on:indent:	#whileFalse:	#generateWhileFalse:on:indent:	#to:do:			#generateToDo:on:indent:	#to:by:do:		#generateToByDo:on:indent:	#ifTrue:		#generateIfTrue:on:indent:	#ifFalse:		#generateIfFalse:on:indent:	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:	#at:				#generateAt:on:indent:	#at:put:			#generateAtPut:on:indent:	#integerValueOf:	#generateIntegerValueOf:on:indent:	#integerObjectOf:	#generateIntegerObjectOf:on:indent:	#isIntegerObject:	#generateIsIntegerObject:on:indent:	#cCode:				#generateInlineCCode:on:indent:	#preIncrement		#generatePreIncrement:on:indent:	#preDecrement		#generatePreDecrement:on:indent:	).	1 to: pairs size by: 2 do: [ :i |		translationDict at: (pairs at: i) put: (pairs at: i + 1).	].! !!CCodeGenerator class methodsFor: 'removing from system'!removeCompilerMethods	"Before removing the C code generator classes from the system, use this method to remove the compiler node methods that support it. This avoids leaving dangling references to C code generator classes in the compiler node classes."	ParseNode withAllSubclasses do: [ :nodeClass |		nodeClass removeCategory: 'C translation'.	].	AbstractSound class removeCategory: 'primitive generation'.! !!ClassListController class methodsFor: 'class initialization'!initialize	"Initialize the yellow button menu information.	 2/1/96 sw: added class vars	 7/29/96 sw: added 'find method' feature"		ClassListYellowButtonMenu _		PopUpMenu 				labels: 'browse classprintOutfileOuthierarchydefinitioncommentinst var refs..inst var defs..class var refs...class varsclass refsrename...removefind method...' 				lines: #(3 6 11 13).	ClassListYellowButtonMessages _ 		#(browse printOut fileOut		hierarchy definition comment		browseInstVarRefs browseInstVarDefs browseClassVarRefs classVariables browseClassRefs		rename remove findMethod)	"	ClassListController initialize.	ClassListController allInstancesDo:		[:x | x initializeYellowButtonMenu].	"! !Costume comment:'An abstract superclass for the predefined costume classes.  its only code is Costume class.acceptsLoggingOfCompilation, which returns true so that the generic code will be logged.  6/7/96 sw'!!Costume methodsFor: 'everything'!canSetContentsTextually	"Answer whether the receiver's contents can be set by typing in an expression.  For costumes, nossir.  6/12/96 sw"	^ false!couldBeWornBy: anObject	"Answer whether the receiver could be worn by anObject.  For most kinds of objects, and most kinds of costumes, the answer is simply TRUE.  9/20/96 sw"	^ true!couldWearStringCostume	"Answer whether the receiver could wear a string costume.  9/20/96 sw"	^ false!mouseDownAt: aPoint in: aView	"Allow costumes to be dragged around. 9/20/96 sw"	^ self dragIn: aView!mouseUpAt: aPoint in: aView	"The mouse came up in the object, at the given point.  Overridden to get around inherited behavior.  6/12/96 sw"	 aView flash!revealsContentsFor: anObject	"Answer whether the receiver reveals nested subparts on the contents side.  Here so no one gets left out.  9/5/96 tk"	^ anObject isKindOf: Folder!type	"Answer the receiver's formal type.  6/12/96 sw"	^ #Costume! !!Costume class methodsFor: 'compilation'!acceptsLoggingOfCompilation	"Set to true so that the code of subclasses will be logged to the system changes file.  System-defined costume code occupies a strange middle-ground between system code, predefined in the image, and user code, resident in ephemeral user classes.  The latter code, for economy, is not presently logged, the former of course is.  6/7/96 sw"	^ true!initializeStandardPaths	"Costume initializeStandardPaths"	"A list of the Paths to the system standard costumes.  8/8/96 tk	 8/12/96 sw: call standardCostumeNames to get the name list; also, this method moved out from Costume class initialize because it caused problems both with file-in and with the build process.	9/7/96 tk: include Costume Library itself."	| lib |	lib _ Home contentsAtKey: 'Costume Library'.	StandardPaths _ self standardCostumeNames collect: [:each |		(lib contentsAtKey: each) path].	StandardPaths _ StandardPaths copyWith: lib path.!standardCostumeNames	"Answer an array of the names of the universal, built-in costumes, which are not to be stored to disk with save-files.  8/12/96 sw	Add Text  9/6/96 tk"	^ #('Workings' 'Contents' 'Picture' 'Name' 'Element' 'Box' 'Slider' 'Contents String' 'Text')!standardCostumePaths	"A list of the Paths to the system standard costumes.  8/8/96 tk.	8/12/96 sw: initialize if found to be nil"	StandardPaths == nil ifTrue: [self initializeStandardPaths].	^ StandardPaths! !!DataStream methodsFor: 'as yet unclassified'!checkForPaths: anObject	"After an object is fully internalized, it should have no PathFromHome in it.	The only exception is Array, as pointed to by an IncomingObjects.  8/16/96 tk"	| pfh |	pfh _ Smalltalk at: #PathFromHome ifAbsent: [^ self].	1 to: anObject class instSize do:		[:i | (anObject instVarAt: i) class == pfh ifTrue: [			self error: 'Unresolved Path']].!readInstance	"PRIVATE -- Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next."	| instSize aSymbol refPosn anObject |	instSize _ (byteStream nextNumber: 4) - 1.	refPosn _ self getCurrentReference.	aSymbol _ self next.	self setCurrentReference: refPosn.  "before readDataFrom:size:"	aSymbol endsWithDigit ifTrue:		[self flag: #noteToTed.		"Remove this once we know no Alias123 are written"		aSymbol _ aSymbol stemAndNumericSuffix at: 1].	anObject _ (Smalltalk at: aSymbol asSymbol)		readDataFrom: self size: instSize.	self setCurrentReference: refPosn.  "before returning to next"	^ anObject!writeClass: aClass	"PRIVATE -- For now, no classes may be written.  HyperSqueak user unique classes have not state other than methods and should be reconstructed.  Could put standard fileOut code here if necessary.  7/29/96 tk."	"Just halt for now -- 9/20/96 di."	self error: 'Should not be trying to write a class'"	Obj classPool at: #ErrorHolder put: aClass.	Transcript cr; show: 'The class ', aClass printString,' is trying to be written out.  See Obj class variable ErrorHolder.'."! !!Dictionary methodsFor: 'user interface'!inspectAnimationsWithLabel: aLabel	"Open a Animation Dictionary inspector on the receiver, with the given label.  6/28/96 sw"	InspectorView open: (InspectorView animationDictionaryInspector:		(DictionaryInspector inspect: self)) withLabel: aLabel! !FastObj comment:'A class created by Ted Kaehler, 7/96, to achieve a HyperSqueak implementation of a word-wrap demo he did the previous summer in Star Logo.  The class is entirely specific to this example'!!FastObj methodsFor: 'everything'!beLeader: str at: ind	"Make me a leader by installing variables leed, chars, space in my workings.	 7/17/96 sw: use newUserInstance"	| chars leed charObj width |	chars _ str findDelimiters: ' -	()' startingAt: ind.	chars _ chars - ind.	"Count me but not space"	leed _ BooleanObj newUserInstance.	"I am start of a word"	leed contents: true.	self addToWorkings: leed atKey: 'leed'.	charObj _ NumberObj newUserInstance.	"number of letters in me"	charObj contents: chars.	self addToWorkings: charObj atKey: 'chars'.	width _ NumberObj newUserInstance.	"pixels in word"	width contents: -1.	self addToWorkings: width atKey: 'width'.!charWidth	"My true proportional width"	^ layoutRectangle width!clear	"force recomputing"	canvas _ nil.	blitter _ nil.!computedVelocity	^ fastVelocity!copyStateFrom: donor	"Copy the donor object's state into the receiver's instance variables. 6/6/96 sw	 7/17/96 sw"	super copyStateFrom: donor.	fastVelocity _ donor velocity!march: goal	"Proceed toward the goal, a little at a time.  Set velocity and/or position.  7/8/96 tk	 7/17/96 sw: convert to using speed; then, since it slowed things down so much, added a new inst variable called fastVelocity.  Awaiting Ted's cleanup..."	| dd x y |	dd _ goal - layoutRectangle topLeft.	dd abs < (5@5) ifTrue: ["close"		fastVelocity _ 0 @ 0.		layoutRectangle moveTo: goal.		^ self].		x _ (dd x < 0 ifTrue: [-5] ifFalse: [dd x = 0 ifTrue: [0] ifFalse: [5]]).	y _ (dd y < 0 ifTrue: [-5] ifFalse: [dd y = 0 ifTrue: [0] ifFalse: [5]]).	"Ted; generic Obj no longer using a velocity inst var; the below makes your code work but is slow; you'll probably want to change this so that it directly uses speed and heading.  7/17/96 sw"	self velocity: x@y!mouseDownAt: aPoint in: aView	"Allow letters to be dragged around.  7/10/96 tk"	^ self dragIn: aView!nextLine	"Aim for left margin, one line below target (char before me)"	| y x |	y _ (self workingsAtKey: 'target').	y == nil		ifTrue: [y _ 30]	"I am leader"		ifFalse: [y _ y contents layoutRectangle bottom + 4 "leading"].	x _ (objectContainedIn contentsAtKey: 'leftMargin') layoutRectangle right.	self march: x@y!overEnd	"I am a leader (first letter of a word).  Would my word be hanging over the right margin?"	| width myInd rt target |	(target _ self workingsAtKey: 'target') == nil ifTrue: [^ false].		"First character in paragraph"	width _ (self workingsAtKey: 'width') contents.	width < 0 ifTrue: ["recompute"		width _ 0.		myInd _ objectContainedIn contents indexOf: self.		1 to: (self workingsAtKey: 'chars') contents do: [:ind |			width _ width + 				(objectContainedIn contents at: myInd+ind-1) 					layoutRectangle width].		(self workingsAtKey: 'width') contents: width].	rt _ (objectContainedIn contentsAtKey: 'rightMargin') layoutRectangle left.	^ target contents layoutRectangle right + width > rt!renderOnCanvas: t1 	"Or the letters on.  Don't use MaskedForms.  7/9/96 tk"	canvas == nil ifTrue: [^ super renderOnCanvas: t1].	blitter == nil		ifTrue: [blitter _ BitBlt toForm: t1 form.			blitter combinationRule: Form under "OR"]		ifFalse: [blitter destForm == t1 form 			ifFalse: [				blitter _ BitBlt toForm: t1 form.				blitter combinationRule: Form under "OR"]].	blitter copyForm: canvas form to: self layoutRectangle origin		rule: 7.	"Form under = bit OR"	"canvas form displayOnPort: blitter at: self layoutRectangle origin."!runIn: aTopView	"Compute new velocity and position.  First do lining up.  7/8/96 tk"	| target v wild |	v _ 19.	wild _ (objectContainedIn contentsAtKey: 'wild') contents == true.	wild ifFalse:			[(self workingsAtKey: 'leed') == nil 				ifFalse: ["first letter of a word"					self overEnd 						ifTrue: [self nextLine]						ifFalse: [self snuggle]]				ifTrue: [self snuggle]]		ifTrue: 			[fastVelocity = (0 @ 0) ifTrue:				[self velocity: (v atRandom - (v//2)) @ (v atRandom - (v//2))]]!snuggle	"try to be just to the right of the character in front of me in the text."	| target x |	target _ self workingsAtKey: 'target'.	target == nil  "first guy"		ifTrue: [x _ (objectContainedIn contentsAtKey: 'leftMargin') 					layoutRectangle right.			self march: x@30]	"corner of the page"		ifFalse: [self march: (target contents layoutRectangle topRight)]!type	^ #String!velocity: vel	"Set the fastVeloctiy inst var as indicted"	fastVelocity _ vel! !!FastObj class methodsFor: 'as yet unclassified'!fastDemo: folder 	"Create the objects.  7/3/96 tk  from in an inspector:	FastObj fastDemo: self	7/16/96 sw: use referTo: rather than contents: to set the alias's referent	7/17/96 sw: use newUserInstance	7/25/96 sw: use BoxColor parameter"	| v leader str new other wild leftMargin rightMargin newExtent |	folder removeAll.	"Clear out old"	(folder contentsAtKey: 'wild') == nil ifTrue: [		wild _ BooleanObj newUserInstance.  "create an alias object"		folder addToContents: wild atKey: 'wild'.		wild contents: true.		wild useStandardCostumeNamed: 'Box'].	(folder contentsAtKey: 'leftMargin') == nil ifTrue: [		leftMargin _ Obj newUserInstance.		leftMargin speed: 0.		leftMargin layoutRectangle: (30@30 extent: 5@200).		" folder layoutRectangle center x - 50."		folder addToContents: leftMargin atKey: 'leftMargin'.		leftMargin useStandardCostumeNamed: 'Box'; setExtentToMatchCostume.		leftMargin setParameter: Color lightBlue darker forKey: #BoxColor].	(folder contentsAtKey: 'rightMargin') == nil ifTrue: [		rightMargin _ Obj newUserInstance.		rightMargin speed: 0.		rightMargin layoutRectangle: (160@30 extent: 5@200).		" folder layoutRectangle center x + 50."		folder addToContents: rightMargin atKey: 'rightMargin'.		rightMargin useStandardCostumeNamed: 'Box'; setExtentToMatchCostume.		rightMargin setParameter: Color lightBlue darker forKey: #BoxColor].	v _ 19.	"make it odd"	leader _ true.	(str _ 'Have you ever thought what a letter must go through in order to do word-wrap?') doWithIndex: [:letter :ind |  		new _ self newUserInstance.	"later just use instances??"		new layoutRectangle: (5 @ 10 extent: 12 @ 12).		new velocity: (v atRandom - (v//2)) @ (v atRandom - (v//2)).		new contents: (String with: letter).		new speed: 1.  "To work around optimization!!"		new setParameter: -1 forKey: #StringBorderWidth.			"Counter act space added for a border"		new setDefaultCostume; setExtentToMatchCostume.		folder addToContents: new atKey: (String with: letter).		"alias of guy I follow"		ind > 1 ifTrue: ["have a guy in front of me"			other _ Alias newUserInstance.  "create an alias object"			new addToWorkings: other atKey: 'target'.			"watch out for spaces that are not objects"			other referTo: (folder contents at: folder contents size-1)].		leader ifTrue: [new beLeader: str at: ind.			leader _ false].		(' -	()' includes: letter) ifTrue: [leader _ true].		]!lettersExample	"Construct the Wandering Letters example.  7/9/96 tk	 7/10/96 sw: call openInOwnWindowTellingView:, so that names and halos can be specified not to show.	7/17/96 sw: use newUserInstance"	"FastObj lettersExample"	| exampleWindow |	exampleWindow _ Folder newUserInstance.	Home addToContents: exampleWindow atKey: 'Wandering Letters'.	exampleWindow assumePictureCostumeNamed: 'Folder'.	exampleWindow windowBounds: (40 @ 20 extent: 300 @ 250).	FastObj fastDemo: exampleWindow.	exampleWindow openInOwnWindowTellingView:		[:aView | aView showNames: false; showHalos: false]!newUserInstance	^ self new! !!FileDirectory methodsFor: 'file names'!fullNameFor: fileName	pathName isEmpty ifTrue:		[^ self checkName: fileName fixErrors: true].	"Return <explicit or implicit path>,<corrected local name>"	FileDirectory splitName: fileName to:		[:path :localName |		^ (path isEmpty ifTrue: [pathName] ifFalse: [path]) ,			self pathNameDelimiter asString , 			(self checkName: localName fixErrors: true)]! !!FileDirectory class methodsFor: 'name service'!convertName: fileName to: volAndNameBlock	"Convert the fileName to a directory object and a local fileName.  FileName must be of the form: <path><name> where the optional <path> specifies a known directory and <name> is the file name within that directory."	self splitName: fileName to:		[:path :localName |		path isEmpty		ifTrue:			[^ volAndNameBlock value: DefaultDirectory								value: localName]		ifFalse:			[^ volAndNameBlock value: (self newOnPath: path)								value: localName]]! !!FileDirectory class methodsFor: 'primitives'!pathNameDelimiter	^ self actualPathNameDelimiter! !!FileList methodsFor: 'list access'!toggleFileListIndex: anInteger	"Select the file name in the receiver's list whose index is the argument, 	anInteger. If the current selection index is already anInteger, deselect it."	| item name |	listIndex = anInteger	ifTrue:		[listIndex _ 0.		contents _ ''.		fileName _ nil]	ifFalse: 		[listIndex _ anInteger.		item _ list at: anInteger.		item first = $( ifTrue:  "remove size or date"			[item _ item copyFrom: (item indexOf: $)) + 2 to: item size].		(item endsWith: self folderString)			ifTrue:			["remove [...] folder string and open the folder"			name _ item copyFrom: 1 to: item size - self folderString size.			listIndex _ 0.			^ self directory: (FileDirectory newOnPath:				(directory fullNameFor: name))]			ifFalse:			["open the file selected"			self setFileName: item]].	self changed: #fileListIndex! !!FileModel methodsFor: 'accessing'!readContentsBrief: brevityFlag	"retrieve the contents from the external file unless it is too long.	9/21/96 tk  Don't create a file here.  Check if exists."	| f size newContents first1000 last1000 |	f _ FileStream oldFileOrNoneNamed: self fullName. 	f == nil ifTrue:		[^ 'For some reason, this file cannot be read'].	(brevityFlag and: [(size _ f size) > 30000]) ifFalse: 		[^ f contentsOfEntireFile].	"Don't display long files at first.	Composing the paragraph may take a long time."	first1000 _ f next: 1000.	f position: size - 1000.	last1000 _ f next: 1000.	f close.	^ 'File ''' , fileName , ''' is ', size printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 1000 characters:--------------------------------' , first1000 , '... and here are the last 1000 characters:--------------------------------------' , last1000!readContentsHex	"retrieve the contents from the external file unless it is too long.	9/21/96 tk  Don't create a file here.  Check if exists."	| f size data hexData s |	f _ FileStream oldFileOrNoneNamed: self fullName. 	f == nil ifTrue:		[^ 'For some reason, this file cannot be read'].	(size _ f size) > 10000		ifTrue: [data _ f next: 10000. f close]		ifFalse: [data _ f contentsOfEntireFile].	s _ WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].		s cr].	hexData _ s contents.	size > 10000		ifTrue: [^ 'First 10k bytes:------------------' , hexData]		ifFalse: [^ hexData].! !!FileStream class methodsFor: 'instance creation'!fileNamed: fileName 	^ self concreteStream fileNamed: (self fullName: fileName)!newFileNamed: fileName 	^ self concreteStream newFileNamed: (self fullName: fileName)!oldFileNamed: fileName 	^ self concreteStream oldFileNamed: (self fullName: fileName)!oldFileOrNoneNamed: fileName	"Only open the file if it exists already.  Don't get an error if not there.  9/21/96 tk"| myName |myName _ self fullName: fileName.^ (self concreteStream isAFileNamed: myName) 	ifTrue: [self concreteStream oldFileNamed: myName]	ifFalse: [nil].!readOnlyFileNamed: fileName 	^ self concreteStream readOnlyFileNamed: (self fullName: fileName)! !!FileStream class methodsFor: 'concrete classes'!concreteStream	"Who should we really direct class queries to?  9/21/96 tk"	^ StandardFileStream! !!FMSound methodsFor: 'sound generation'!doControl	super doControl.	modulationDecay ~= 1.0 ifTrue: [		modulation _ (modulationDecay * modulation asFloat) truncated.	].! !Folder comment:'An Obj type whose contents consist of a list of other Objs'!!Folder methodsFor: 'contents'!addToContents: anObject atKey: aKey 	"Add anObject to the receiver's contents, using a key similar to aKey, and return the actual key settled upon as the method's result.  5/30/96 sw	 8/8/96 sw: the real work devolved to another method"	^ self addToContents: anObject atKey: aKey after: nil!addToContents: anObject atKey: aKey after: priorObject	"Add anObject to the receiver's contents, using a key similar to aKey, and return the actual key settled upon as the method's result.  If priorObject is supplied, place the receiver just after it in z-ordering.  8/8/96 sw	9/11/96 tk: declare it from LostAndFound"	| keyToUse laf |	contents == nil		ifTrue: [contents _ OrderedCollection with: anObject]		ifFalse: [priorObject == nil			ifTrue:				[contents add: anObject]			ifFalse:				[contents add: anObject after: priorObject]].	contentsDictionary == nil ifTrue: [contentsDictionary _ FastDictionary new].	keyToUse _ (contentsDictionary includesKey: aKey)				ifTrue: [self uniqueContentsKeyLike: aKey]				ifFalse: [aKey].	anObject objectContainedIn: self.	laf _ self class classPool at: #LostAndFound ifAbsent: [].	laf == nil 		ifFalse: [contentsDictionary declare: keyToUse from: laf].		"reuse the association in case script depends on it"	contentsDictionary at: keyToUse put: anObject.	^ keyToUse!addToContentsSafely: anObject atKey: aKey path: path	"Add anObject to the receiver's contents, but never rename it.  When there is a conflict, ask user whether to delete or rename the old one.  Used when circumstances do not allow renaming anObject.  8/12/96 tk"	| keyToUse pp banner choice what old |	contentsDictionary == nil ifTrue: [contentsDictionary _ FastDictionary new].	keyToUse _ (contentsDictionary includesKey: aKey)				ifTrue: [self uniqueContentsKeyLike: aKey]				ifFalse: [aKey].	keyToUse = aKey ifTrue: [^ self addToContents: anObject atKey: aKey].	"ask user replace, or rename old.  "	pp _ path collect: [:each | each = 'w	w' ifTrue: ['workings'] ifFalse: [each]].	pp removeLast. 	banner _ 'The object ''', path last, ''' already exists in', pp asArray printString.	choice _ 'Rename Old VersionDelete Old Version'.	what _ (PopUpMenu labels: choice lines: nil) startUpWithCaption: banner.	old _ self contentsAtKey: aKey.	what = 2 ifTrue: ["Delete old"		self removeFromContents: old.		^ self addToContents: anObject atKey: aKey].	"what = 2 ifTrue: [" "Rename"		self removeFromContents: old.		self addToContents: old atKey: keyToUse.		^ self addToContents: anObject atKey: aKey.	!allSubparts	"Return a list of all subparts, workings and contents if applicable, in back-to-front order.  5/30/96 sw"	^ super allSubparts, self contentsBackToFront!canSetContentsTextually	"Answer whether the receiver admits to having its contents set via textual expression.  In the case of folders, CERTAINLY NOT!!!!  6/12/96 sw"	^ false!canShowContents	"Answer whether the receiver is able to show its individual contents in a window, i.e., whether it behaves like a Folder.  6/7/96 sw"	^ true!contents	"Answer the receiver's list of contents subparts.  6/7/96 sw"	contents == nil ifTrue: [contents _ OrderedCollection new].	^ contents!contentsAtKey: aKey	"Return the element in the receiver's contents at the given key.  6/7/96 sw"	^ self contentsDictionary at: aKey ifAbsent: [nil]!contentsBackToFront	"Return the receiver's contents in back-to-front order.  6/7/96 sw"	^ self contents!contentsDictionary	"Answer the receiver's contentsDictionary, creating it if necesary.  5/30/96 sw"	contentsDictionary == nil ifTrue: [contentsDictionary _ FastDictionary new].	^ contentsDictionary!copyContentsFrom: donor	"Copy the the donor's contents to the receiver; in this case, we need clones of the subparts.  7/17/96 sw"	| subs |	(subs _ donor contentsBackToFront) size > 0 ifTrue:		[subs do:			[:aSub | self addToContents: aSub clonedInstance atKey: aSub name]]!copyStateFrom: donor	"Copy the donor object's state into the receiver's instance variables. 6/6/96 sw	 7/17/96 sw: removed velocity	7/17/96 sw: seemingly can dispense with this override now."	^ super copyStateFrom: donor!displayContentsOnWindowCanvas: aCanvas except: anObject	"Render the receiver's contents on the window canvas.  5/30/96 sw"	self contents do:		[:aSubpart | aSubpart == anObject			ifFalse: [aSubpart renderOnCanvas: aCanvas]]!removeAll	"Useful for repeated experiments in the same folder.  7/8/96 tk"	"self contents do: [:each | self removeFromContents: each].	slow"	contentsDictionary _ FastDictionary new.	contents _ OrderedCollection new.	self flag: #noteToTed	"The old contents objects, and anything they contained, will however remain on the screen in this formulation, so before it is put into general use, it will need some cleanup.  7/10/96 sw" !removeFromContents: anObject	"Remove the given object from the receiver's contents.  5/30/96 sw	9/11/96 tk: put in LostAndFound"	| assoc |	assoc _ contentsDictionary associationAt: anObject name.	contentsDictionary removeKey: anObject name.	contents remove: anObject.	self lost: assoc.!revealsContentsFor: anObject	"Answer whether, acting as a costume for anObject, the receiver reveals contents subparts.  6/7/96 sw"	^ anObject == self and: [contents size > 0]!setDefaultCostume	"Set up an initial costume for the receiver, if desired.  6/12/96 sw.	7/12/96 sw: set it to show rainbow folder"	currentCostume _ self costumeNamed: 'Picture'.	self setParameter: 'Folder' forKey: #PictureName!stringObjHas: contentsString	"Search for the StringObj in this folder that contains exactly this string.  For finding buttons who show a nice label, but whose real name is unknown.  9/21/96 tk"contents do: [:obj |		contentsString = obj contents ifTrue: [^ obj]].^ 'not found'!uniqueContentsKeyLike: aString	"Return a key similar to aString which is not currently in use as a contents key of the receiver.  5/30/96 sw 	6/7/96 sw: polished the algorithm	8/11/96 sw: call a new generic Utility to do the work."	^ Utilities keyLike: aString satisfying:		[:aKey | (self contentsDictionary includesKey: aKey) not]! !!Folder methodsFor: 'display'!displayCollectionContentsOnCanvas: aCanvas	"Render the receiver's collection contents on the indicated canvas.  5/29/96 sw"	self contents do:		[:aSubpart | aSubpart renderOnCanvas: aCanvas]!displayContentsOnCanvas: aCanvas	"Render the receiver's contents on the indicated canvas.  6/2/96 sw"	self drawFrameOn: aCanvas.	self displayCollectionContentsOnCanvas: aCanvas!displayContentsOnWindowCanvas: aCanvas	"Render the receiver's contents on the window canvas.  5/30/96 sw"	self contents do:		[:aSubpart | aSubpart renderOnCanvas: aCanvas].!userDisplayOn: aDisplayMedium	"The default display method for a folder object: show the receiver's contents if there are are any, otherwise put the receiver's name up.  6/2/96 sw"	contents size > 0		ifTrue:			[self displayContentsOnCanvas: aDisplayMedium]		ifFalse:			[(self name, ' <empty>') displayOn: aDisplayMedium]! !!Folder methodsFor: 'miscellany'!advanceElementFor: aOneElementCostume forward: fwd wrapping: wrap	"Move the receiver's mark of its 'current element' forward or backward by one for the given costume.  If wrap is true, then at the end wrap around to the other end of the element, else just stick at the end.  6/5/96 sw"	| current  newElement |	current _ self parameterFor: #CurrentElement		ifAbsent: [contents size == 0 ifTrue: [^ self].				contents first].	newElement _ fwd		ifTrue:			[self elementAfter: current wrapping: wrap]		ifFalse:			[self elementBefore: current wrapping: wrap].	self setParameter: newElement forKey: #CurrentElement!backwardOne	"Advance the 'current element' backward by one, to the previous element.  7/16/96 sw"	(self currentCostume isKindOf: ShowOneElementCostume) ifFalse: [^ self].	self advanceElementFor: self currentCostume forward: false wrapping: true!bringToFront: anObject in: aView	"Bring the object to the front.  8/13/96 sw"	aView showingContents ifFalse:		[^ super bringToFront: anObject in: aView].	contents remove: anObject.	contents add: anObject!couldWearStringCostume	"Answer whether the receiver could wear a string costume.  9/20/96 sw"	^ false!elementAfter: anElement wrapping: wrap	"Return the element of the receiver's contents that folllows anElement, wrapping back to the beginning if necesary and if wrap is true.  6/5/96 sw"	| curInd newInd |	newInd _ (curInd _ self contentsBackToFront indexOf: anElement ifAbsent: [^ nil]) == contents size		ifTrue:			[wrap ifTrue: [1] ifFalse: [contents size]]		ifFalse:			[curInd + 1].	^ contents at: newInd!elementBefore: anElement wrapping: wrap	"Return the element of the receiver's contents that preceeds anElement, wrapping back to the end if necesary and if wrap is true.  6/5/96 sw	 7/14/96 sw: bug fix on the indexing"	| curInd newInd |	newInd _ (curInd _ self contentsBackToFront indexOf: anElement ifAbsent: [^ nil]) == 1		ifTrue:			[wrap ifTrue: [contents size] ifFalse: [1]]		ifFalse:			[curInd - 1].	^ contents at: newInd!everyContentsSubpartSatisfying: aBlock	"Answer a list of contents subparts that satisfy aBlock. 6/29/96 sw"	^ self contentsBackToFront select:		[:anObject | (aBlock value: anObject) == true]!folderOfAliasesIn: aView offsetBy: delta	"Produce a new folder that looks like the receiver, is named similarly to the receiver, and whose contents consist of aliases to the contents of the receiver.  8/8/96 sw"	| newInst aKey anAlias |	newInst _ self class instanceOfUniqueClass.	aView showingContents		ifTrue:			[aKey _ objectContainedIn uniqueContentsKeyLike: self name.			objectContainedIn addToContents: newInst atKey: aKey]		ifFalse:			[aKey _ objectContainedIn uniqueWorkingsKeyLike: self name.			objectContainedIn addToWorkings: newInst atKey: aKey].	newInst layoutRectangle: (self layoutRectangle translateBy: delta).	newInst mimicCostumeOf: self.	self contentsBackToFront do:		[:anObject |			anAlias _ Alias newUserInstance.			anAlias referTo: anObject.			anAlias mimicCostumeOf: anObject.			anAlias layoutRectangle: anObject layoutRectangle.			newInst addToContents: anAlias atKey: anObject name].	aView invalidateVisibleObjectCache.	^ newInst!forwardOne	"Advance the 'current element' forward by one, to the previous element.  7/16/96 sw"	(self currentCostume isKindOf: ShowOneElementCostume) ifFalse: [^ self].	self advanceElementFor: self currentCostume forward: true wrapping: true!mouseDownInDragBarAt: aPoint in: aView	"The mouse went down at the given point, in the receiver's top halo  	8/8/96 sw: on control-option drag, we'll get a folderful of aliases to the receiver's contents"	| folderOfAliases |	(Sensor optionKeyPressed and: [Sensor controlKeyPressed]) ifFalse:		[^ super mouseDownInDragBarAt: aPoint in: aView].	folderOfAliases _ self folderOfAliasesIn: aView offsetBy: 0@0.	^ Cursor move showWhile: [folderOfAliases dragIn: aView]!mouseUpAt: aPoint in: aView	"The mouse came up in the receiver.  By default, treat this as a request to open.  6/12/96 sw"	aView relinquishControl.	self openInOwnWindow!nameOf: aSubpart	"Return the formal name by which aSubpart is known in the receiver -- may be in contents side or workings side.  5/30/96 sw"	^ self contentsDictionary keyAtValue: aSubpart ifAbsent:		[super nameOf: aSubpart]!sendToBack: anObject in: aView	"Send the object to the back.  6/6/96 sw"	aView showingContents ifFalse:		[^ super sendToBack: anObject in: aView].	contents remove: anObject.	contents addFirst: anObject!type	"Answer the receiver's formal type.  6/12/96 sw"	^ #Folder! !!GraphicFrame methodsFor: 'access'!extentOfRotatedImages	^ rotatedImages first boundingBox extent!imageCount	^ rotatedImages size max: 1!imageNumber: n	^ rotatedImages at: n!initializeForSingleFrame: aForm rotated: rotationCount registrationPoint: regPoint centerOfRotation: rotCenter	"Initialize the receiver with aForm as the primary image.  Perform the rotations if needed.   8/9/96 sw"	| flippedForm |	primaryImage _ aForm.	registrationPoint _  regPoint == nil ifTrue: [aForm boundingBox center] ifFalse: [regPoint].	centerOfRotation _ rotCenter == nil ifTrue: [aForm boundingBox center] ifFalse: [rotCenter].	rotationCount == 99 "signals left-right rotation" ifTrue:		[flippedForm _ aForm theForm flipBy: #horizontal centerAt: 0@0 " aForm boundingBox center".		flippedForm _ MaskedForm transparentBorder: flippedForm.		rotatedImages _ Array with: aForm with: aForm with: flippedForm with: flippedForm.		^ self].			rotationCount > 1		ifTrue:			[rotatedImages _ SqueakSupport reversedFormSetFrom: 				(aForm form opaqueRotationSet: rotationCount rotationCenter: rotCenter)]		ifFalse:			[rotatedImages _ Array with: (MaskedForm transparentBorder: aForm theForm)] !initializeWithRotations: formList	"Unusual -- instead of performing the rotations, accept the list of rotations from formList.  8/11/96 sw"	| aPoint |	primaryImage _ formList first.	aPoint _ primaryImage boundingBox center.	registrationPoint _ aPoint.	centerOfRotation _ aPoint.	rotatedImages _ formList.	!primaryImage	^ primaryImage!primaryImage: aForm	primaryImage _ aForm!registrationPoint: aPoint	registrationPoint _ aPoint! !!GraphicFrame methodsFor: 'rotation'!centerOfRotation: aPoint	centerOfRotation _ aPoint!rotationCount	^ rotatedImages size max: 1! !HaloButtonIcon comment:'A halo icon that functions as a button -- when you press it, something happens.  6/7/96 sw'!!HaloButtonIcon methodsFor: 'mouse'!mouseDownBlock	"Answer the block to be evaluated (with the top view as its argument) while the mouse is down in the receiver.  6/7/96 sw"	^ mouseDownBlock ~~ nil		ifTrue:			[mouseDownBlock]		ifFalse:			[[:aView | ]]!mouseDownBlock: aBlock	"Set the receiver's mouse-down block.  6/12/96 sw"	mouseDownBlock _ aBlock!mouseDownIn: anIconStrip	"The mouse went down in the receiver; take appropriate action.  6/7/96 sw"	| aBox |	aBox _ form boundingBox translateBy: (offset + anIconStrip origin).	Utilities awaitMouseUpIn: aBox whileMouseDownDo: [] whileMouseDownInsideDo: [self mouseDownBlock value: topView] ifSucceed: 		[actionBlock value: topView.		wantsRefresh == false ifFalse: [anIconStrip display]]! !!HaloButtonIcon methodsFor: 'access'!wantsRefresh: aBoolean	wantsRefresh _ aBoolean! !!HaloButtonIcon methodsFor: 'action'!actionBlock: aBlock	"Set the receiver's action block.  6/12/96 sw"	actionBlock _ aBlock! !HaloIcon comment:'Represents an object in the window halo.  Lives in a HaloStrip.'!!HaloIcon methodsFor: 'initialization'!caption: aCaption	caption _ aCaption!mouseHandlingBlock: aBlock	"Set the receiver's mouse-handling block.  6/12/96 sw"	mouseHandlingBlock _ aBlock!offset: anOffset	offset _ anOffset!view: aView	"set the receiver's view as indicated.  6/7/96 sw"	topView _ aView!view: aView offset: anOffset form: aForm menu: aMenu	"Initialize the receiver's instance variables.  6/7/96 sw"	topView _ aView.	offset _ anOffset.	form _ aForm.	menu _ aMenu! !!HaloIcon methodsFor: 'display'!displayIn: anIconStrip	"Render the receiver in the given icon strip.  6/12/96 sw"	form displayAt: offset + anIconStrip origin! !!HaloIcon methodsFor: 'input handling'!catchMouseAt: aPoint in: anIconStrip	"If aPoint is within the receiver, take action and return true, else pass on it and return false. 6/7/96 sw"	((form boundingBox translateBy: (offset + anIconStrip origin)) containsPoint: aPoint)		ifTrue:			[self mouseDownIn: anIconStrip.			^ true]		ifFalse:			[^ false]!mouseDown	"The mouse went down in the receiver; take appropriate action.  6/7/96 sw	 7/17/96 sw: add caption"	| reply |	(reply _ menu startUpWithCaption: caption) ~~ nil ifTrue:		[topView perform: reply]!mouseDownIn: aHaloStrip	"The mouse went down in the receiver; take appropriate action.  6/7/96 sw"	mouseHandlingBlock ~~ nil ifTrue:		[^ mouseHandlingBlock value: topView].	^ self mouseDown! !HaloStrip comment:'A strip of icons around the periphery of the window.  May be vertical or horizontal.  CAUTION:  Because this is a subclass of Quadrangle, some of its functions, like align, return copies rather than the original, so must be used with care.'!!HaloStrip methodsFor: 'setup'!addIcon: anIcon	"Add the given icon to the receiver.  6/7/96 sw"	icons add: anIcon!align: aPoint1 with: aPoint2 	"Answer a new HaloStrip translated by aPoint2 - aPoint1.  5/24/96 sw"	| newStrip |	newStrip _ super align: aPoint1 with: aPoint2.	newStrip view: topView icons: icons.	^ newStrip!icons	"Return the receiver's icon list.  6/7/96 sw"	^ icons!initializeFor: aTopView	"Initialize the receiver, with an empty list of icons.  6/7/96 sw"	topView _ aTopView.	icons _ OrderedCollection new!view: aTopView	"Set the view as indicated,, and tell all my icons about it.  6/7/96 sw"	topView _ aTopView.	icons do:		[:anIcon | anIcon view: aTopView]!view: aView icons: iconList	"Set up the view and iconList asindicated.  6/7/96 sw"	topView _ aView.	icons _ iconList! !!HaloStrip methodsFor: 'mouse handling'!mouseDown	"The mouse went down in the receiver; hand it on to the appropriate icon, if any, else do nothing.  6/7/96 sw"	| aPoint |	aPoint _ Sensor cursorPoint.	icons do:		[:anIcon | (anIcon catchMouseAt: aPoint in: self)			ifTrue:				[^ self]]! !!HaloStrip methodsFor: 'display'!display	"Display the receiver -- first the enclosing Quadrangle, then the respective icons.  6/7/96 sw"	super display.  "Show the strip"	icons do:		[:anIcon | anIcon displayIn: self]! !HaloToggleIcon comment:'A Halo icon that shows alternatively one or another image.  Choice is determined by the value of its stateBlock'!!HaloToggleIcon methodsFor: 'everything'!displayIn: anIconStrip	"Display the receiver in the strip.  Differs from inherited version in that the image used may change.  6/12/96 sw"	| formToUse |	formToUse _ (stateBlock value: topView)		ifTrue:	[form]		ifFalse:	[formIfFalse].	formToUse displayAt: offset + anIconStrip origin!stateBlock: aBlock formIfFalse: aForm	"Set the instance variables as indicated.  6/12/96 sw"	stateBlock _ aBlock.	formIfFalse _ aForm! !IncomingObjects comment:'This class holds meta information about a net of HyperSqueak objects out on the disk.  This object is written first on the file, and it can be used to get everything right during the fileIn.  8/8/96 tkobjects 	OrderedCollection.  First is the Root Obj of tree we wrote out.  	Others are custom costumes and other trees we need to write out also.paths 	OrderedCollection.  For each thing in "objects", a PathFromHome 	down to where this object should be.instVarDict 	Dictionary of (class name -> string of inst var names) used 	to see if class has had major renaming.fileName	Not filled in until reading this in.  Name of file read from.  	For debugging.Recent  (class var) holds most recent IncomingObjects read. '!!IncomingObjects methodsFor: 'as yet unclassified'!aComment"	7/29/96 tk| rr |	rr _ ReferenceStream fileNamed: 'test1'.	AA _ rr next.	rr close. 	AA inspectThis class is a wrapper for any tree of Objs that need to be filed out.  Writing is in SqueakView.saveToDisk.  Reading is in FileModel.loadIntoHyperSqueak.Here are the conventions for writing out soleInstance classes that we create.  User classes.  > Only state a User class can hold are methods and its className (secret name). The methods are already stored in the object workings.  We put out the standard superclass and then remake the class and instance.> Method ioType returns #System, #User, or #Obj.  It is the #User ones whose classes we have to reconstruct.> For User objects, use a special writeUser:/readUser.  It gobbles the name, creates the class, creates the object normally, and installs the methods.> Methods.  Write source code.  Reinstall all scripts after read in.> Block these:  View, Controller, CompiledMethod, StrikeFont (for now), > Alias contents, Obj currentCostume, Obj objectContainedInAll have the same situation:  If it points to an object in this hierarchy, put out a reference.  If point to an object outside, put out a path and fixup on way in.> Custom costumes:  List of system costumes.  Any others used by tree are written out by IncomingObject as a co-object.  Reference mechanism hooks them up again.  Custom costumes are treated as inside the tree.Things that work (except for the one thing I just broke): > Write and read any tree of Objs. > User unique classes handled correctly.  New secret name generated. > objectContainedIn written as a PathFromHome and fixed up on the way back in. > Tree of objects encased in a meta-information object. > Tree of objects placed in proper folder when come in. > Aliases to objects inside the tree are correct > Aliases to objects outside the tree correctly re-find their referent!! > recordable PathFromHome in the tree implemented (used for Aliases)> Costumes do not go out if standard, do go out if defined by the user (changes by user to standard costumes are lost). Ad hoc, but works (fix it later): > Pens go out and come back in. (not tested) > Canvases go out and come back in. (can they be blocked and regenerated?)> Open windows come back in closed and forget their old positions. > Classes have a place to write their instance variable names for future compatibility.  (simply needs to be hooked up for writing.  Then lots of work to read and interpret correctly.)"!animation: kindOfPic in: anObj	"anObj uses a picture in SqueakSupport animationLibrary.  Write the association for that picture out with the file.  Make up a path.  8/12/96 tk"	| picName path |	picName _ anObj parameters at: kindOfPic.	objects add: ((SqueakSupport animationLibrary) associationAt: picName).	path _ PathFromHome new.	path addLast: 'Home'.	path addLast: 'animationLibrary'.	paths add: path.!comeFullyUpOnReload	"Install the object that has just been read in.  Put him in the proper place in the hierarchy.  See Obj.path.  Do AnimationLibrary objects and any others that are not pointed at directly from an Obj but still need to come with the file.  8/13/96 tk"| container path name ll hh done |objects doWithIndex: [:obj :ind |	path _ (paths at: ind) copy.	"copy is for debugging"	hh _ path removeFirst.	"Home itself"	name _ path removeLast.	done _ false.	(name = 'animationLibrary' and: [obj class == Association]) ifTrue: [		ll _ (SqueakSupport animationLibrary).		(ll includesKey: obj key) ifFalse: [ll at: obj key put: obj value].		done _ true].	"Only force install of the main tree of objects we are reading in"	done not & (ind = 1) ifTrue:  			[(path isEmpty not and: [path last = 'w	w']) 	"in the workings"				ifFalse: ["contents"					container _ Obj homeObject resolvePath: path.	"destroys path"					container addToContentsSafely: obj atKey: name 						path: (paths at: ind)]				ifTrue: ["workings"					container _ Obj homeObject resolvePath: path.	"destroys path"					container addToWorkingsSafely: obj atKey: name 						path: (paths at: ind)].			done _ true].	"For others, we defer to a copy that is already here.  If you disagree, 		you should have included that object in the tree you filed out."	done ifFalse: 			[container _ Obj homeObject resolvePath: path.	"destroys path"			(path isEmpty not and: [path last = 'w	w']) 	"in the workings"				ifFalse: ["contents"					(container contentsAtKey: name) == nil ifTrue: [						container addToContents: obj atKey: name]]				ifTrue: ["workings"					(container workingsAtKey: name) == nil ifTrue: [						container addToWorkings: obj atKey: name]].			done _ true]	].	^ self!install: anObj	"gather us my state prior to writing on the disk.  8/9/96 tk"	| sz |	sz _ (Obj homeObject contentsAtKey: 'Costume Library') contents size * 4.	sz _ sz + (SqueakSupport animationLibrary size + 4).		"Be sure not to grow the OrderedCollections while writing."	objects _ OrderedCollection new: sz.	objects add: anObj.	paths _ OrderedCollection new: sz.	(anObj respondsTo: #path) 		ifTrue: [paths add: anObj path]		ifFalse: [paths add: #('no path')].	instVarDict  _ Dictionary new.	fileName _ ''.  "file name when read in"	Recent _ self.	"So DataStream can know where to inst var info"!instVarInfo	"Return an object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  8/16/96 tk"	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs classes array cls |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy nextPut: self.	refs _ dummy references.	classes _ Dictionary new.		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	refs keysDo: [:each | 		cls _ each class.		(cls category asString = 'HyperSqueak-UserObjects') ifFalse: [			classes at: cls name put: false]].	"Save work by only computing inst vars once for each class"	classes keysDo: [:nm | 		cls _ Smalltalk at: nm.		classes at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames))].	^ Array with: 'class structure' with: classes!objects	^ objects!pathOrObj: anObject	"Find out whether anObject is in the entire set of object being written out.  If so, return anObject.  Return a Path if anObject is outside the tree that is being written.  User-defined costumes are handled specially.  8/8/96 tk"	| path |	(anObject ioType = #System) ifTrue: [^ anObject].  "not an Obj"	objects do: [:obj |		"Test to see if anObject is outside the tree that is being written."		(anObject amContainedIn: obj) ifTrue: [^ anObject].		(anObject == obj) ifTrue: [^ anObject]].	"Must be outside"	path _ anObject path.	(path at: 2 ifAbsent: ['']) = 'Costume Library' ifTrue:		[(Costume standardCostumePaths includes: path) 			ifTrue: [^ path]	"Not a custom costume"			ifFalse: ["A custom job"				"self halt.	debugging"				objects add: anObject.				paths add: path.				^ anObject]].	"Write it out in this file"	^ path	"a true outside object"!paths	^ paths! !!IncomingObjects class methodsFor: 'as yet unclassified'!acceptStructures: anArray	"Remember the structures of the classes that whose instances are about to come in from the disk.  Compare to current structures.  8/17/96 tk"	ExternalClassStructures _ anArray at: 2.	"a Dictonary"	^ self verifyStructure!recent	^ Recent!verifyStructure	"Compare the incoming inst var names list to the existing classes.  Later do something intelligent.  8/17/96 tk"| cls mine |ExternalClassStructures keysDo: [:nm |	cls _ Smalltalk at: nm ifAbsent: [			self error: 'Never hears of class ', nm, '.  Proceed to skip rest.'.			^ false].	mine _ (Array with: cls classVersion), (cls allInstVarNames).	(ExternalClassStructures at: nm) = mine ifFalse: [			"Try to rectify the two structures here"			self error: 'Class ', nm, 				' has changed too much.  Proceed to skip rest.'.			^ false].	].^ true! !!InspectorView class methodsFor: 'instance creation'!animationDictionaryInspector: anInspector 	"Answer an instance of me on the model, anInspector. The instance 	consists of an InspectListView and an InspectFormView  6/28/96 sw."	| anInspectorView anInspectorListView aFormView |	anInspectorView _ View new.		anInspectorView model: anInspector.		anInspectorListView _ InspectListView new.		anInspectorListView model: anInspector;				controller: DictionaryListController new.		anInspectorListView window: (0 @ 0 extent: 40 @ 40).		anInspectorListView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	anInspectorView addSubView: anInspectorListView.	aFormView _ self buildAnimationView: anInspector.	anInspectorView		addSubView: aFormView		align: aFormView viewport topLeft		with: anInspectorListView viewport topRight.	^ anInspectorView! !!InspectorView class methodsFor: 'private'!buildAnimationView: anInspector	"Build a view in the right side of the Inspector that will support animation.  6/28/96 sw"	| inspectFormView |	inspectFormView _ AnimationInspectView new.	inspectFormView model: anInspector.	inspectFormView window: (0 @ 0 extent: 75 @ 40).	inspectFormView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	^ inspectFormView! !Interpreter comment:'This class is a complete implementation of the Smalltalk-80 virtual machine, derived originally from the Blue Book specification.It has been modernized with 32-bit pointers, better management of Contexts, and attention to variable use that allows the CCodeGenerator (qv) to keep, eg, the instruction pointer and stack pointer in registers.In addition to SmallInteger arithmetic and Floats, it supports logic on 32-bit PositiveLargeIntegers, thus allowing it to simulate itself much more effectively than would otherwise be the case.'!!Interpreter methodsFor: 'initialization'!initializeInterpreter: bytesToShift	"Initialize Interpreter state before starting execution of a new image."	self initializeObjectMemory: bytesToShift.	activeContext	_ nilObj.	theHomeContext	_ nilObj.	method			_ nilObj.	receiver			_ nilObj.	messageSelector	_ nilObj.	newMethod		_ nilObj.	self primitiveFlushCache.	self loadInitialContext.	interruptCheckCounter _ 0.	nextPollTick _ 0.	nextWakeupTick _ 0.	interruptKeycode _ 2094.  "cmd-."	interruptPending _ false.!loadInitialContext	| sched proc |	sched _ self fetchPointer: ValueIndex ofObject: (self splObj: SchedulerAssociation).	proc _ self fetchPointer: ActiveProcessIndex ofObject: sched.	activeContext _ self fetchPointer: SuspendedContextIndex ofObject: proc.	(activeContext < youngStart) ifTrue: [ self beRootIfOld: activeContext ].	self fetchContextRegisters.	reclaimableContextCount _ 0.! !!Interpreter methodsFor: 'utilities'!areFloats: oop1 and: oop2	"Answer true if both arguments are floats."	| floatClass cl1 cl2 |	floatClass _ self splObj: ClassFloat.	cl1 _ self fetchClassOf: oop1.	cl2 _ self fetchClassOf: oop2.	^ (cl1 = floatClass) and: [cl2 = floatClass]!areIntegers: oop1 and: oop2	^ ((oop1 bitAnd: oop2) bitAnd: 1) ~= 0!arrayValueOf: arrayOop	"Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."	self returnTypeC: 'void *'.	((self isIntegerObject: arrayOop) not and:	 [self isWordsOrBytes: arrayOop]) ifTrue: [		^ self cCode: '(void *) (arrayOop + 4)'	].	self primitiveFail.!booleanCheat: cond	| peek |	peek _ self fetchByte.  "peek ahead for jumpIfFalse (99%)"	(peek >= 152 and: [peek <= 159]) ifTrue: [  "short jumpIfFalse"		self internalPop: 2.		cond ifFalse: [ ^ self jump: peek - 151 ].		^ nil	].	peek = 172 ifTrue: [  "long jumpIfFalse"		self internalPop: 2.		cond ifFalse: [ ^ self jump: self fetchByte ].		^ self jump: 1	].	"was not followed by a jumpIfFalse; just leave boolean result on the stack"	localIP _ localIP - 1.	cond		ifTrue: [ self longAt: (localSP _ localSP - 4) put: trueObj ]		ifFalse: [ self longAt: (localSP _ localSP - 4) put: falseObj ].!booleanValueOf: obj	obj = trueObj ifTrue: [ ^ true ].	obj = falseObj ifTrue: [ ^ false ].	successFlag _ false.	^ nil!checkedIntegerValueOf: intOop	(self isIntegerObject: intOop)		ifTrue: [ ^ self integerValueOf: intOop ]		ifFalse: [ self primitiveFail. ^ 0 ]!externalizeIPandSP	"Copy the local instruction and stack pointer to global variables for use in primitives and other functions outside the interpret loop."	instructionPointer _ localIP.	stackPointer _ localSP.!fetchArray: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."	| arrayOop |	self returnTypeC: 'void *'.	arrayOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self arrayValueOf: arrayOop!fetchFloat: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."	| floatOop |	self returnTypeC: 'double'.	floatOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self floatValueOf: floatOop!fetchInteger: fieldIndex ofObject: objectPointer	| intOop |	intOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	(self isIntegerObject: intOop)		ifTrue: [ ^ self integerValueOf: intOop ]		ifFalse: [ self primitiveFail. ^ 0 ]!internalizeIPandSP	"Copy the local instruction and stack pointer to local variables for rapid access within the interpret loop."	localIP _ instructionPointer.	localSP _ stackPointer.!makePointwithxValue: xValue yValue: yValue	| pointResult |	pointResult _ self instantiateSmallClass: (self splObj: ClassPoint)							   sizeInBytes: 12									   fill: nilObj.	self storePointer: XIndex ofObject: pointResult withValue: (self integerObjectOf: xValue).	self storePointer: YIndex ofObject: pointResult withValue: (self integerObjectOf: yValue).	^ pointResult!quickFetchInteger: fieldIndex ofObject: objectPointer	"Return the integer value of the field without verifying that it is an integer value!! For use in time-critical places where the integer-ness of the field can be guaranteed."	^ self integerValueOf:		(self fetchPointer: fieldIndex ofObject: objectPointer).!storeInteger: fieldIndex ofObject: objectPointer withValue: integerValue	(self isIntegerValue: integerValue) ifTrue: [		self storeWord: fieldIndex			ofObject: objectPointer			withValue: (self integerObjectOf: integerValue).	] ifFalse: [		self primitiveFail	].!transfer: count	fromIndex: firstFrom ofObject: fromOop	toIndex: firstTo ofObject: toOop	"Assume: beRootIfOld: will be called on toOop."	| fromIndex toIndex lastFrom |	fromIndex _ fromOop + BaseHeaderSize + (firstFrom * 4).	toIndex _ toOop + BaseHeaderSize + (firstTo * 4).	lastFrom _ fromIndex + (count * 4).	[fromIndex < lastFrom] whileTrue: [		self longAt: toIndex put: (self longAt: fromIndex).		fromIndex _ fromIndex + 4.		toIndex _ toIndex + 4.	].! !!Interpreter methodsFor: 'object memory support'!mapInterpreterOops	"Map all oops in the interpreter's state to their new values during garbage collection or a become: operation."	"Assume: All traced variables contain valid oops."	| i oop |	nilObj				_ self remap: nilObj.	falseObj				_ self remap: falseObj.	trueObj				_ self remap: trueObj.	specialObjectsOop	_ self remap: specialObjectsOop.	stackPointer 		_ stackPointer - activeContext.	"*rel to active"	activeContext		_ self remap: activeContext.	stackPointer 		_ stackPointer + activeContext.	"*rel to active"	theHomeContext		_ self remap: theHomeContext.	instructionPointer 	_ instructionPointer - method.	"*rel to method"	method				_ self remap: method.	instructionPointer 	_ instructionPointer + method.	"*rel to method"	receiver				_ self remap: receiver.	messageSelector		_ self remap: messageSelector.	newMethod			_ self remap: newMethod.	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			remapBuffer at: i put: (self remap: oop).		].	].	"For now the method cache uses oops as hashes -- toss the whole thing"	self primitiveFlushCache.!markAndTraceInterpreterOops	"Mark and trace all oops in the interpreter's state."	"Assume: All traced variables contain valid oops."	| i oop |	self markAndTrace: specialObjectsOop.		"also covers nilObj, trueObj, falseObj, and compact classes"	self markAndTrace: activeContext.  "traces entire stack"		"also covers theHomeContext, receiver, method"	self markAndTrace: messageSelector.	self markAndTrace: newMethod.	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			self markAndTrace: oop.		].	].!postGCAction	"Mark the active and home contexts as roots if old. This allows the interpreter to use storePointerUnchecked to store into them."	(activeContext    < youngStart) ifTrue: [ self beRootIfOld: activeContext ].	(theHomeContext < youngStart) ifTrue: [ self beRootIfOld: theHomeContext ].! !!Interpreter methodsFor: 'compiled methods'!argumentCountOf: methodPointer	^ ((self headerOf: methodPointer) >> 25) bitAnd: 16r1F!headerOf: methodPointer	^self fetchPointer: HeaderIndex		ofObject: methodPointer!literal: offset	^self literal: offset		ofMethod: method!literal: offset ofMethod: methodPointer	^self fetchPointer: offset + LiteralStart		ofObject: methodPointer!literalCountOf: methodPointer	^self literalCountOfHeader: (self headerOf: methodPointer)!literalCountOfHeader: headerPointer	^ (headerPointer >> 10) bitAnd: 16rFF!methodClassOf: methodPointer	| literalCount association |	literalCount _ self literalCountOf: methodPointer.	association _ self literal: literalCount - 1				ofMethod: methodPointer.	^self fetchPointer: ValueIndex		ofObject: association!primitiveIndexOf: methodPointer	^ ((self headerOf: methodPointer) >> 1) bitAnd: 16r1FF!primitiveNewMethod	| header bytecodeCount class size theMethod literalCount i |	header _ self popStack.	bytecodeCount _ self popInteger.	self success: (self isIntegerObject: header).	successFlag ifFalse: [self unPop: 2].	class _ self popStack.	size _ (self literalCountOfHeader: header) + 1 * 4 + bytecodeCount.	theMethod _ self instantiateClass: class indexableSize: size.	self storePointer: HeaderIndex ofObject: theMethod withValue: header.	literalCount _ self literalCountOfHeader: header.	1 to: literalCount do:		[:i | self storePointer: i ofObject: theMethod withValue: nilObj].	self push: theMethod! !!Interpreter methodsFor: 'contexts'!argumentCountOfBlock: blockPointer	| argCount |	argCount _ self fetchPointer: BlockArgumentCountIndex							ofObject: blockPointer.	(self isIntegerObject: argCount)		ifTrue: [ ^ self integerValueOf: argCount ]		ifFalse: [ self primitiveFail. ^0 ].!caller	^self fetchPointer: SenderIndex		ofObject: activeContext!fetchContextRegisters	| m |	m _ self fetchPointer: MethodIndex ofObject: activeContext.	(self isIntegerObject: m) ifTrue: [		"activeContext is a block context"		theHomeContext _			self fetchPointer: HomeIndex ofObject: activeContext.		(theHomeContext < youngStart) ifTrue: [ self beRootIfOld: theHomeContext ].	] ifFalse: [		theHomeContext _ activeContext.	].	receiver _		self fetchPointer: ReceiverIndex ofObject: theHomeContext.	method _		self fetchPointer: MethodIndex ofObject: theHomeContext.	"instructionPointer is a pointer variable equal to	method oop + ip + BaseHeaderSize		-1 for 0-based addressing of fetchByte		-1 because it gets incremented BEFORE fetching currentByte"	instructionPointer _		self quickFetchInteger: InstructionPointerIndex ofObject: activeContext.	instructionPointer _ method + instructionPointer + BaseHeaderSize - 2.	"stackPointer is a pointer variable also..."	stackPointer _ self quickFetchInteger: StackPointerIndex ofObject: activeContext.	stackPointer _ activeContext + BaseHeaderSize				+ ((TempFrameStart + stackPointer - 1) * 4).!internalPop: nItems	localSP _ localSP - (nItems * 4).!internalPush: object	self longAt: (localSP _ localSP + 4) put: object.!internalStackTop	^ self longAt: localSP!internalStackValue: offset	^ self longAt: localSP - (offset * 4)!newActiveContext: aContext	self storeContextRegisters.	activeContext _ aContext.	(activeContext < youngStart) ifTrue: [ self beRootIfOld: activeContext ].	self fetchContextRegisters.!nilContextFields	self storePointerUnchecked: SenderIndex		ofObject: activeContext		withValue: nilObj.	self storePointerUnchecked: InstructionPointerIndex		ofObject: activeContext		withValue: nilObj!pop: nItems	stackPointer _ stackPointer - (nItems*4).!popInteger	| integerPointer |	integerPointer _ self popStack.	(self isIntegerObject: integerPointer)		ifTrue: [^ self integerValueOf: integerPointer]		ifFalse: [successFlag _ false.				^ 1  "in case need SOME integer prior to fail"]!popPos32BitInteger	"May set successFlag, and return false if not valid"	| top |	top _ self popStack.	^ self positive32BitValueOf: top!popStack	| top |	top _ self longAt: stackPointer.	stackPointer _ stackPointer - 4.	^ top!push: object	self longAt: (stackPointer _ stackPointer + 4) put: object!pushBool: trueOrFalse	trueOrFalse		ifTrue: [ self push: trueObj ]		ifFalse: [ self push: falseObj ].!pushInteger: integerValue	self push: (self integerObjectOf: integerValue).!returnToActiveContext: returnContext	| methodContextClass contextOfCaller thisCntxClass |	methodContextClass _ self splObj: ClassMethodContext.	[activeContext = returnContext] whileFalse: [		"climb up stack to returnContext"		contextOfCaller _ self caller.		"Zap exited contexts so any future attempted use will be caught"		self nilContextFields.		reclaimableContextCount > 0 ifTrue: [			thisCntxClass _ self fetchClassOf: activeContext.			thisCntxClass = methodContextClass ifTrue: [				"This context can be reclaimed immediately"				reclaimableContextCount _ reclaimableContextCount - 1.				self recycleContextIfPossible: activeContext.			].		].		activeContext _ contextOfCaller.	].	(activeContext < youngStart) ifTrue: [ self beRootIfOld: activeContext ].	self fetchContextRegisters.!sender	^self fetchPointer: SenderIndex		ofObject: theHomeContext!stackIntegerValue: offset	| integerPointer |	integerPointer _ self longAt: stackPointer - (offset*4).	(self isIntegerObject: integerPointer)		ifTrue: [ ^self integerValueOf: integerPointer ]		ifFalse: [ self primitiveFail. ^0 ]!stackPointerIndex	"Return the 0-based index rel to the current context.	(This is what stackPointer used to be before conversion to pointer"	^ (stackPointer - activeContext - BaseHeaderSize) // 4!stackTop	^self longAt: stackPointer!stackValue: offset	^ self longAt: stackPointer - (offset*4)!storeContextRegisters 	"InstructionPointer is a pointer variable equal to	method oop + ip + BaseHeaderSize		-1 for 0-based addressing of fetchByte		-1 because it gets incremented BEFORE fetching currentByte"	self storeWord: InstructionPointerIndex	ofObject: activeContext		withValue: (self integerObjectOf: 			(instructionPointer - method - (BaseHeaderSize - 2))).	self storeWord: StackPointerIndex			ofObject: activeContext		withValue: (self integerObjectOf:			(self stackPointerIndex - TempFrameStart + 1)).!storeInstructionPointerValue: value inContext: contextPointer	"Assume: value is an integerValue"	self storeWord: InstructionPointerIndex		ofObject: contextPointer		withValue: (self integerObjectOf: value).!storeStackPointerValue: value inContext: contextPointer	"Assume: value is an integerValue"	self storeWord: StackPointerIndex		ofObject: contextPointer		withValue: (self integerObjectOf: value).!temporary: offset	^self fetchPointer: offset + TempFrameStart		ofObject: theHomeContext!unPop: nItems	stackPointer _ stackPointer + (nItems*4)! !!Interpreter methodsFor: 'object format'!fixedFieldsOf: instPointer	| classPointer fmt |	classPointer _ self fetchClassOf: instPointer.	fmt _ self formatOfClass: classPointer.	^ ((fmt >> 2) bitAnd: 16r3F) - 1!formatOfClass: classPointer	"**should be in-lined**"	"Note that, in Smalltalk, the instSpec will be equal to the inst spec	part of the base header of an instance (without hdr type) shifted left 1.	In this way, apart from the smallInt bit, the bits	are just where you want them for the first header word."	"Callers expect low 2 bits (header type) to be zero!!"	^ (self fetchPointer: InstanceSpecificationIndex ofObject: classPointer) - 1! !!Interpreter methodsFor: 'message sending'!activateNewMethod	| methodHeader smallContext newContext initialIP tempCount i contextEnd |	methodHeader _ self headerOf: newMethod.	smallContext _ ((methodHeader >> 18) bitAnd: 1) = 0.	newContext _ self allocateOrRecycleContext: smallContext.	initialIP _		((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1.	tempCount _		(methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf: initialIP).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	self transfer: argumentCount + 1		fromIndex: self stackPointerIndex - argumentCount		ofObject: activeContext		toIndex: ReceiverIndex		ofObject: newContext.	"clear extra context fields to nil in case it is recycled"	i _ newContext + ((ReceiverIndex + argumentCount + 2) * 4).	smallContext		ifTrue: [ contextEnd _ newContext + SmallContextSize ]		ifFalse: [ contextEnd _ newContext + LargeContextSize ].	[i < contextEnd] whileTrue: [		self longAt: i put: nilObj.		i _ i + 4.	].	self pop: argumentCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self newActiveContext: newContext.!createActualMessage	| argumentArray message |	argumentArray _		self instantiateClass: (self splObj: ClassArray) indexableSize: argumentCount.	"remap argumentArray in case GC happens during allocation"	self pushRemappableOop: argumentArray.	message _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	argumentArray _ self popRemappableOop.	(argumentArray < youngStart) ifTrue: [ self beRootIfOld: argumentArray ].	self storePointer: MessageSelectorIndex		ofObject: message		withValue: messageSelector.	self storePointer: MessageArgumentsIndex		ofObject: message		withValue: argumentArray.	self transfer: argumentCount		fromIndex: self stackPointerIndex - (argumentCount - 1)		ofObject: activeContext		toIndex: 0		ofObject: argumentArray.	self pop: argumentCount.	self push: message.	argumentCount _ 1.!executeNewMethod	(primitiveIndex = 0 or: [self primitiveResponse not]) ifTrue: [		"if not primitive, or primitive failed, activate the method"		self activateNewMethod.		"check for possible interrupts at each real send"		self quickCheckForInterrupts.	].!findNewMethodInClass: class	| hash probe p |	"NOTE: Does NOT use hash field, but direct oops instead.	Therefore must relocate or flush when compacting storage.	[Have to do this for class oop anyway]."	hash _ (messageSelector bitXor: class) >> 2.	"This shift drops two low-order zeros from addresses"	"First try a few probes in the cache"	0 to: CacheProbeMax-1 do: [:p |		probe _ ((hash >> p) bitAnd: MethodCacheMask) + 1.  "see reprobes, below"		((methodCache at: probe) = messageSelector				and: [(methodCache at: probe + MethodCacheEntries) = class]) ifTrue:					[newMethod _ methodCache at: probe + MethodCacheEntries + MethodCacheEntries.					primitiveIndex _ self primitiveIndexOf: newMethod.					^ nil]].	"Not found in the cache."	self lookupMethodInClass: class.  "Look it up the hard way"	mcProbe _ (mcProbe+1) \\ CacheProbeMax.  "Pick a randomish reprobe for it"	probe _ ((hash >> (mcProbe*3))  "see below"				bitAnd: MethodCacheMask) + 1.	methodCache at: probe put: messageSelector.  "and install it there"	methodCache at: probe + MethodCacheEntries put: class.	methodCache at: probe + MethodCacheEntries + MethodCacheEntries put: newMethod	"About the reprobe scheme...	The hash is the low bits of the xor of two large addresses.	By shifting 3 bits right, we should introduce 3 new randomish bits,	leading to an 8-way scatter at each level of reprobe."!lookupMethodInClass: class	| currentClass dictionary |	currentClass _ class.	[currentClass~=nilObj] whileTrue:		[dictionary _ self fetchPointer: MessageDictionaryIndex					ofObject: currentClass.		(self lookupMethodInDictionary: dictionary)			ifTrue: [^ currentClass].		currentClass _ self superclassOf: currentClass].	messageSelector = (self splObj: SelectorDoesNotUnderstand)		ifTrue: [self error: 'Recursive not understood error encountered'].	self createActualMessage.	messageSelector _ (self splObj: SelectorDoesNotUnderstand).	^ self lookupMethodInClass: class!lookupMethodInDictionary: dictionary	"NOTE: This method has been converted to do an exhaustive search,	since hashes will not be the same when we start up the new system.	Unless the method cache is VERY effective, proper hashing will need	to be reinstated here." 	| length index mask wrapAround nextSelector methodArray |	length _ self fetchWordLengthOf: dictionary.	mask _ length - SelectorStart - 1.	index _ (mask bitAnd: (self hashBitsOf: messageSelector)) + SelectorStart.	wrapAround _ false.	[true] whileTrue:		[nextSelector _ self fetchPointer: index					ofObject: dictionary.		nextSelector=nilObj ifTrue: [^false].		nextSelector=messageSelector			ifTrue: [methodArray _ self fetchPointer: MethodArrayIndex							ofObject: dictionary.				newMethod _ self fetchPointer:  index - SelectorStart							ofObject: methodArray.				primitiveIndex _ self primitiveIndexOf: newMethod.				^true].		index _ index + 1.		index = length			ifTrue: [wrapAround ifTrue: [^false].				wrapAround _ true.				index _ SelectorStart]]!superclassOf: classPointer	^self fetchPointer: SuperclassIndex		ofObject: classPointer! !!Interpreter methodsFor: 'interpreter shell'!fetchByte	"This method uses the preIncrement builtin function which has no Smalltalk equivalent. Thus, it must be overridden in the simulator."	^ self byteAt: localIP preIncrement!getCurrentBytecode	"currentBytecode will be private to the main dispatch loop in the generated code. This method allows the currentBytecode to be retrieved from global variables."	^ self byteAt: instructionPointer!interpret	self internalizeIPandSP.	[true] whileTrue: [		currentBytecode _ self fetchByte.		self dispatchOn: currentBytecode in: BytecodeTable.	].	self externalizeIPandSP.!unknownBytecode	"This should never get called; it means that an unimplemented bytecode appears in a CompiledMethod."	self error: 'Unknown bytecode'.! !!Interpreter methodsFor: 'stack bytecodes'!duplicateTopBytecode	self internalPush: self internalStackTop.!extendedPushBytecode	| descriptor variableType variableIndex |	descriptor _ self fetchByte.	variableType _ (descriptor >> 6) bitAnd: 16r3.	variableIndex _ descriptor bitAnd: 16r3F.	variableType=0 ifTrue: [^self pushReceiverVariable: variableIndex].	variableType=1 ifTrue: [^self pushTemporaryVariable: variableIndex].	variableType=2 ifTrue: [^self pushLiteralConstant: variableIndex].	variableType=3 ifTrue: [^self pushLiteralVariable: variableIndex].!extendedStoreAndPopBytecode	self extendedStoreBytecode.	self popStackBytecode.!extendedStoreBytecode	| descriptor variableType variableIndex association |	descriptor _ self fetchByte.	variableType _ (descriptor >> 6) bitAnd: 16r3.	variableIndex _ descriptor bitAnd: 16r3F.	variableType = 0 ifTrue:		[^self storePointer: variableIndex			ofObject: receiver			withValue: self internalStackTop].	variableType = 1 ifTrue:		[^self storePointerUnchecked: variableIndex + TempFrameStart			ofObject: theHomeContext			withValue: self internalStackTop].	variableType = 2 ifTrue:		[self error: 'illegal store'].	variableType = 3 ifTrue:		[association _ self literal: variableIndex.		^self storePointer: ValueIndex			ofObject: association			withValue: self internalStackTop].!popStackBytecode	self internalPop: 1.!pushActiveContextBytecode	"Puts reclaimability of this context in question."	reclaimableContextCount _ 0.	self internalPush: activeContext.!pushConstantFalseBytecode	self internalPush: falseObj.!pushConstantMinusOneBytecode	self internalPush: ConstMinusOne.!pushConstantNilBytecode	self internalPush: nilObj.!pushConstantOneBytecode	self internalPush: ConstOne.!pushConstantTrueBytecode	self internalPush: trueObj.!pushConstantTwoBytecode	self internalPush: ConstTwo.!pushConstantZeroBytecode	self internalPush: ConstZero.!pushLiteralConstant: literalIndex	self internalPush: (self literal: literalIndex).!pushLiteralConstantBytecode	self pushLiteralConstant: (currentBytecode bitAnd: 16r1F).!pushLiteralVariable: literalIndex	self internalPush:		(self fetchPointer: ValueIndex ofObject: (self literal: literalIndex)).!pushLiteralVariableBytecode	self pushLiteralVariable: (currentBytecode bitAnd: 16r1F).!pushReceiverBytecode	self internalPush: receiver.!pushReceiverVariable: fieldIndex	self internalPush:		(self fetchPointer: fieldIndex ofObject: receiver).!pushReceiverVariableBytecode	self pushReceiverVariable: (currentBytecode bitAnd: 16rF).!pushTemporaryVariable: temporaryIndex	self internalPush: (self temporary: temporaryIndex).!pushTemporaryVariableBytecode	self pushTemporaryVariable: (currentBytecode bitAnd: 16rF).!storeAndPopReceiverVariableBytecode	self storePointer: (currentBytecode bitAnd: 7)		ofObject: receiver		withValue: self internalStackTop.	self internalPop: 1.!storeAndPopTemporaryVariableBytecode	self storePointerUnchecked: (currentBytecode bitAnd: 7) + TempFrameStart		ofObject: theHomeContext		withValue: self internalStackTop.	self internalPop: 1.! !!Interpreter methodsFor: 'jump bytecodes'!jump: offset	localIP _ localIP + offset.!jumplfFalseBy: offset	| boolean |	boolean _ self internalStackTop.	self internalPop: 1.	boolean = falseObj ifTrue: [		self jump: offset.	] ifFalse: [		boolean = trueObj ifFalse: [			self externalizeIPandSP.			self unPop: 1.			self externalSendSelector: (self splObj: SelectorMustBeBoolean)					 argumentCount: 0.			self internalizeIPandSP.		].	].!jumplfTrueBy: offset	| boolean |	boolean _ self internalStackTop.	self internalPop: 1.	boolean = trueObj ifTrue: [		self jump: offset.	] ifFalse: [		boolean = falseObj ifFalse: [			self externalizeIPandSP.			self unPop: 1.			self externalSendSelector: (self splObj: SelectorMustBeBoolean)					 argumentCount: 0.			self internalizeIPandSP.		].	].!longJumpIfFalse	self jumplfFalseBy:		((currentBytecode bitAnd: 3) * 256) + self fetchByte.!longJumpIfTrue	self jumplfTrueBy:		((currentBytecode bitAnd: 3) * 256) + self fetchByte.!longUnconditionalJump	| offset |	offset _ (((currentBytecode bitAnd: 7) - 4) * 256) + self fetchByte.	localIP _ localIP + offset.	offset < 0 ifTrue: [		"backward jump means we're in a loop; check for possible interrupts"		self internalQuickCheckForInterrupts.	].!shortConditionalJump	self jumplfFalseBy: (currentBytecode bitAnd: 7) + 1.!shortUnconditionalJump	self jump: (currentBytecode bitAnd: 7) + 1.! !!Interpreter methodsFor: 'send bytecodes'!doubleExtendedDoAnythingBytecode	"Replaces the Blue Book double-extended send [132], in which	the first byte was wasted on 8 bits of argument count.	Here we use 3 bits for the operation sub-type (opType),	and the remaining 5 bits for argument count where needed.	The last byte give access to 256 instVars or literals.	See also secondExtendedSendBytecode"	| byte2 byte3 opType top |	byte2 _ self fetchByte.	byte3 _ self fetchByte.	opType _ byte2 >> 5.	opType = 0 ifTrue: [		"Note: Use non-inlined version of sendSelector:argumentCount:"		self externalizeIPandSP.		self externalSendSelector: (self literal: byte3) argumentCount: (byte2 bitAnd: 16r1F).		self internalizeIPandSP.		^ nil	].	opType = 1 ifTrue: [		messageSelector _ self literal: byte3.		argumentCount _ byte2 bitAnd: 16r1F.		self externalizeIPandSP.		self sendSelectorToClass: (self superclassOf: (self methodClassOf: method)).		self internalizeIPandSP.		^ nil	].	opType = 2 ifTrue: [ ^ self pushReceiverVariable: byte3 ].	opType = 3 ifTrue: [ ^ self pushLiteralConstant: byte3 ].	opType = 4 ifTrue: [ ^ self pushLiteralVariable: byte3 ].	opType = 5 ifTrue: [		^ self storePointer: byte3 ofObject: receiver withValue: self internalStackTop	].	opType = 6 ifTrue: [		top _ self internalStackTop.		self internalPop: 1.		self storePointer: byte3 ofObject: receiver withValue: top.		^ nil	].	opType = 7 ifTrue: [		self storePointer: ValueIndex			    ofObject: (self literal: byte3)			 withValue: (self internalStackTop).		^ nil	].!externalSendSelector: selector argumentCount: count	"Note: Requires that instructionPointer and stackPointer be externalized."	"Note: This version is NOT inlined, for use in uncommon cases (errors, etc.)."	| rcvrClass |	messageSelector _ selector.	argumentCount _ count.	rcvrClass _ self fetchClassOf: (self stackValue: argumentCount).	self sendSelectorToClass: rcvrClass.!internalSendSelector: selector argumentCount: count	"Note: This method is inlined into the interpreter dispatch loop."	| rcvrClass |	messageSelector _ selector.	argumentCount _ count.	rcvrClass _ self fetchClassOf: (self internalStackValue: argumentCount).	self externalizeIPandSP.	self sendSelectorToClass: rcvrClass.	self internalizeIPandSP.!secondExtendedSendBytecode	"This replaces the Blue Book double-extended super-send [134],	which is subsumed by the new double-extended do-anything [132].	It offers a 2-byte send of 0-3 args for up to 63 literals, for which 	the Blue Book opcode set requires a 3-byte instruction."	| descriptor selectorIndex |	descriptor _ self fetchByte.	selectorIndex _ descriptor bitAnd: 16r3F.	self internalSendSelector: (self literal: selectorIndex)		argumentCount: (descriptor >> 6)!sendLiteralSelectorBytecode	| selector |	selector _ self literal: (currentBytecode bitAnd: 16rF).	self internalSendSelector: selector		argumentCount: ((currentBytecode >> 4) bitAnd: 3) - 1.!sendSelectorToClass: classPointer	"Note: Requires that instructionPointer and stackPointer be externalized."	self findNewMethodInClass: classPointer.	self executeNewMethod.!singleExtendedSendBytecode	| descriptor selectorIndex |	descriptor _ self fetchByte.	selectorIndex _ descriptor bitAnd: 16r1F.	self internalSendSelector: (self literal: selectorIndex)		argumentCount: (descriptor >> 5)!singleExtendedSuperBytecode	| descriptor selectorIndex |	descriptor _ self fetchByte.	argumentCount _ descriptor >> 5.	selectorIndex _ descriptor bitAnd: 16r1F.	messageSelector _ self literal: selectorIndex.	self externalizeIPandSP.	self sendSelectorToClass: (self superclassOf: (self methodClassOf: method)).	self internalizeIPandSP.! !!Interpreter methodsFor: 'return bytecodes'!returnFalse	self externalizeIPandSP.	self returnValue: falseObj to: self sender.	self internalizeIPandSP.!returnNil	self externalizeIPandSP.	self returnValue: nilObj to: self sender.	self internalizeIPandSP.!returnReceiver	self externalizeIPandSP.	self returnValue: receiver to: self sender.	self internalizeIPandSP.!returnTopFromBlock	"Return to caller of the method containing the block."	self externalizeIPandSP.	self returnValue: (self popStack) to: (self caller).	self internalizeIPandSP.!returnTopFromMethod	self externalizeIPandSP.	self returnValue: (self popStack) to: (self sender).	self internalizeIPandSP.!returnTrue	self externalizeIPandSP.	self returnValue: trueObj to: self sender.	self internalizeIPandSP.!returnValue: resultObj to: contextPointer	| sendersIP |	contextPointer = nilObj ifTrue: [		self push: activeContext.		self push: resultObj.		^ self externalSendSelector: (self splObj: SelectorCannotReturn)				   argumentCount: 1.	].	sendersIP _ self fetchPointer: InstructionPointerIndex ofObject: contextPointer.	sendersIP = nilObj ifTrue: [		self push: activeContext.		self push: resultObj.		^ self externalSendSelector: (self splObj: SelectorCannotReturn)				   argumentCount: 1.	].	self returnToActiveContext: contextPointer.	self push: resultObj.	self quickCheckForInterrupts.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimAdd	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).		(self isIntegerValue: result) ifTrue: [			self longAt: (localSP _ localSP - 4)					put: (self integerObjectOf: result).			^ nil		].	].	self externalizeIPandSP.	self primitiveAdd.	self internalizeIPandSP.!bytecodePrimAt	"This version of at: is run directly from the special byteCode.	It requires that its array be one of the 'ok' classes that will not	attempt to redefine at:.  Otherwise it will fail and do a lookup"	| arrayClass stringy |	self externalizeIPandSP.	successFlag _ true.	arrayClass _ self fetchClassOf: (self stackValue: 1).	stringy _ arrayClass = (self splObj: ClassString).	(stringy or: [self okStreamArrayClass: arrayClass])		ifTrue: [ self commonAt: stringy ]		ifFalse: [ self failSpecialPrim: 0 ].	self internalizeIPandSP.!bytecodePrimAtEnd	self externalizeIPandSP.	self primitiveAtEnd.	self internalizeIPandSP.!bytecodePrimAtPut	"See the comment in bytePrimitiveAt."	| arrayClass stringy |	self externalizeIPandSP.	successFlag _ true.	arrayClass _ self fetchClassOf: (self stackValue: 2).	stringy _ arrayClass = (self splObj: ClassString).	(stringy or: [self okStreamArrayClass: arrayClass])		ifTrue: [ self commonAtPut: stringy ]		ifFalse: [ self failSpecialPrim: 0 ].	self internalizeIPandSP.!bytecodePrimBitAnd	self externalizeIPandSP.	self primitiveBitAnd.	self internalizeIPandSP.!bytecodePrimBitOr	self externalizeIPandSP.	self primitiveBitOr.	self internalizeIPandSP.!bytecodePrimBitShift	self externalizeIPandSP.	self primitiveBitShift.	self internalizeIPandSP.!bytecodePrimBlockCopy	| sel rcvrClass |	self externalizeIPandSP.	successFlag _ true.	argumentCount _ 1.	rcvrClass _ self fetchClassOf: (self stackValue: argumentCount).	self success:		((rcvrClass = (self splObj: ClassBlockContext)) or:		 [rcvrClass = (self splObj: ClassMethodContext)]).	successFlag ifTrue: [ self primitiveBlockCopy ].	successFlag ifFalse: [		sel _ self fetchPointer: (24 * 2) ofObject: (self splObj: SpecialSelectors).		self externalSendSelector: sel argumentCount: argumentCount.	].	self internalizeIPandSP.!bytecodePrimClass	self externalizeIPandSP.	self primitiveClass.	self internalizeIPandSP.!bytecodePrimDiv	self externalizeIPandSP.	self primitiveDiv.	self internalizeIPandSP.!bytecodePrimDivide	self externalizeIPandSP.	self primitiveDivide.	self internalizeIPandSP.!bytecodePrimDo	| sel |	sel _ self fetchPointer: (27 * 2) ofObject: (self splObj: SpecialSelectors).	"Note: Use non-inlined version of sendSelector:argumentCount:"	self externalizeIPandSP.	self externalSendSelector: sel argumentCount: 1.	self internalizeIPandSP.!bytecodePrimEqual	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr = arg	].	self externalizeIPandSP.	self primitiveEqual.	self internalizeIPandSP.!bytecodePrimEquivalent	self booleanCheat: (self internalStackValue: 1) = (self internalStackValue: 0).!bytecodePrimGreaterOrEqual	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr >= arg	].	self externalizeIPandSP.	self primitiveGreaterOrEqual.	self internalizeIPandSP.!bytecodePrimGreaterThan	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr > arg	].	self externalizeIPandSP.	self primitiveGreaterThan.	self internalizeIPandSP.!bytecodePrimLessOrEqual	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr <= arg	].	self externalizeIPandSP.	self primitiveLessOrEqual.	self internalizeIPandSP.!bytecodePrimLessThan	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr < arg	].	self externalizeIPandSP.	self primitiveLessThan.	self internalizeIPandSP.!bytecodePrimMakePoint	self externalizeIPandSP.	self primitiveMakePoint.	self internalizeIPandSP.!bytecodePrimMod	self externalizeIPandSP.	self primitiveMod.	self internalizeIPandSP.!bytecodePrimMultiply	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		rcvr _ self integerValueOf: rcvr.		arg _ self integerValueOf: arg.		result _ rcvr * arg.		((arg = 0 or: [(result // arg) = rcvr]) and:		 [self isIntegerValue: result]) ifTrue: [			self longAt: (localSP _ localSP - 4)					put: (self integerObjectOf: result).			^ nil		].	].	self externalizeIPandSP.	self primitiveMultiply.	self internalizeIPandSP.!bytecodePrimNew	| sel |	sel _ self fetchPointer: (28 * 2) ofObject: (self splObj: SpecialSelectors).	"Note: Use non-inlined version of sendSelector:argumentCount:"	self externalizeIPandSP.	self externalSendSelector: sel argumentCount: 0.	self internalizeIPandSP.!bytecodePrimNewWithArg	| sel |	sel _ self fetchPointer: (29 * 2) ofObject: (self splObj: SpecialSelectors).	"Note: Use non-inlined version of sendSelector:argumentCount:"	self externalizeIPandSP.	self externalSendSelector: sel argumentCount: 1.	self internalizeIPandSP.!bytecodePrimNext	| rcvrClass sel |	self externalizeIPandSP.	successFlag _ true.	rcvrClass _ self fetchClassOf: (self stackValue: 0).	self success: (self okStreamArrayClass: rcvrClass).	successFlag ifTrue: [ self primitiveNext ].	successFlag ifFalse: [		sel _ self fetchPointer: (19 * 2) ofObject: (self splObj: SpecialSelectors).		self externalSendSelector: sel argumentCount: 0.	].	self internalizeIPandSP.!bytecodePrimNextPut	self externalizeIPandSP.	self primitiveNextPut.	self internalizeIPandSP.!bytecodePrimNotEqual	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr ~= arg	].	self externalizeIPandSP.	self primitiveNotEqual.	self internalizeIPandSP.!bytecodePrimPointX	self externalizeIPandSP.	self primitivePointX.	self internalizeIPandSP.!bytecodePrimPointY	self externalizeIPandSP.	self primitivePointY.	self internalizeIPandSP.!bytecodePrimSize	"See the comment in bytePrimitiveAt"	| arrayClass |	self externalizeIPandSP.	successFlag _ true.	arrayClass _ self fetchClassOf: (self stackValue: 0).	(self okStreamArrayClass: arrayClass)		ifTrue: [self primitiveSize]		ifFalse: [self failSpecialPrim: 0].	self internalizeIPandSP.!bytecodePrimSubtract	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		result _ (self integerValueOf: rcvr) - (self integerValueOf: arg).		(self isIntegerValue: result) ifTrue: [			self longAt: (localSP _ localSP - 4)					put: (self integerObjectOf: result).			^ nil		].	].	self externalizeIPandSP.	self primitiveSubtract.	self internalizeIPandSP.!bytecodePrimValue	| sel rcvrClass |	self externalizeIPandSP.	successFlag _ true.	argumentCount _ 0.	rcvrClass _ self fetchClassOf: (self stackValue: argumentCount).	self success: rcvrClass = (self splObj: ClassBlockContext).	successFlag ifTrue: [ self primitiveValue ].	successFlag ifFalse: [		sel _ self fetchPointer: (25 * 2) ofObject: (self splObj: SpecialSelectors).		self externalSendSelector: sel argumentCount: argumentCount.	].	self internalizeIPandSP.!bytecodePrimValueWithArg	| sel rcvrClass |	self externalizeIPandSP.	successFlag _ true.	argumentCount _ 1.	rcvrClass _ self fetchClassOf: (self stackValue: argumentCount).	self success: rcvrClass = (self splObj: ClassBlockContext).	successFlag ifTrue: [ self primitiveValue ].	successFlag ifFalse: [		sel _ self fetchPointer: (26 * 2) ofObject: (self splObj: SpecialSelectors).		self externalSendSelector: sel argumentCount: argumentCount.	].	self internalizeIPandSP.! !!Interpreter methodsFor: 'primitive support'!failed	^successFlag not!failSpecialPrim: primIndex	"Used only for failing from a primitive that was entered as a special	bytecode.  This routine will look up the real method and, only if its	primitiveIndex is different, then it will run that primitive, otherwise	it will simply activate to run the fail code"	| bytecode selectorIndex newReceiver rcvrClass |	bytecode _ self getCurrentBytecode.	(bytecode < 176 or: [bytecode > 207])		ifTrue: ["Primitive was not running as a special bytecode"				^ self primitiveFail].	selectorIndex _ (bytecode - 176) * 2.	messageSelector _ self fetchPointer: selectorIndex				ofObject: (self splObj: SpecialSelectors).	argumentCount _ self quickFetchInteger: selectorIndex + 1				ofObject: (self splObj: SpecialSelectors)."	self sendSelector: messageSelector argumentCount: count"	"The above line of code must be expanded and altered, because we only	want to run the ST code, not re-run the primitive and get into a loop"	newReceiver _ self stackValue: argumentCount.	rcvrClass _ self fetchClassOf: newReceiver.	self findNewMethodInClass: rcvrClass.	(primitiveIndex > 37 and: [primitiveIndex ~= primIndex])		ifTrue: [self executeNewMethod]		ifFalse: [self activateNewMethod]!positive32BitIntegerFor: integerValue	| newLargeInteger |	"Note - integerValue is interpreted as POSITIVE, eg, as the result of		Bitmap>at:, or integer>bitAnd:."	(integerValue >= 0 and: [self isIntegerValue: integerValue])		ifTrue: [^ self integerObjectOf: integerValue].	newLargeInteger _		self instantiateSmallClass: (self splObj: ClassLargePositiveInteger)				sizeInBytes: 8						 fill: 0.	self storeByte: 3 ofObject: newLargeInteger		withValue: ((integerValue >> 24) bitAnd: 16rFF).	self storeByte: 2 ofObject: newLargeInteger		withValue: ((integerValue >> 16) bitAnd: 16rFF).	self storeByte: 1 ofObject: newLargeInteger		withValue: ((integerValue >> 8) bitAnd: 16rFF).	self storeByte: 0 ofObject: newLargeInteger		withValue: (integerValue bitAnd: 16rFF).	^ newLargeInteger!positive32BitValueOf: integerPointer	"Convert the given object into an integer value.	The object may be either a positive ST integer or a four-byte LargePositiveInteger."	| sz value |	(self isIntegerObject: integerPointer)		ifTrue: [value _ self integerValueOf: integerPointer.				value < 0 ifTrue: [^ self primitiveFail].				^ value].	sz _ self lengthOf: integerPointer.	(((self fetchClassOf: integerPointer) = (self splObj: ClassLargePositiveInteger)) and: [sz = 4])		ifFalse: [^ self primitiveFail].	value _		(self fetchByte: 0 ofObject: integerPointer) +		((self fetchByte: 1 ofObject: integerPointer) <<  8) +		((self fetchByte: 2 ofObject: integerPointer) << 16) +		((self fetchByte: 3 ofObject: integerPointer) << 24).	^ value!primitiveFail	successFlag _ false.!primitiveResponse	| thisReceiver |	primitiveIndex >= 256		ifTrue:			[thisReceiver _ self popStack.			primitiveIndex < 264				ifTrue: ["Quick return of self or a constant"						primitiveIndex = 256 ifTrue: [self push: thisReceiver].						primitiveIndex = 257 ifTrue: [self push: trueObj].						primitiveIndex = 258 ifTrue: [self push: falseObj].						primitiveIndex = 259 ifTrue: [self push: nilObj].						primitiveIndex = 260 ifTrue: [self push: ConstMinusOne].						primitiveIndex = 261 ifTrue: [self push: ConstZero].						primitiveIndex = 262 ifTrue: [self push: ConstOne].						primitiveIndex = 263 ifTrue: [self push: ConstTwo].						^ true]				ifFalse: ["Quick return of an instance field"							self push: (self fetchPointer: primitiveIndex-264 ofObject: thisReceiver).						^ true]]		ifFalse:			[successFlag _ true.			self dispatchOn: primitiveIndex in: PrimitiveTable.			^ successFlag]!success: successValue	successFlag _ successValue & successFlag.! !!Interpreter methodsFor: 'arithmetic primitives'!checkBooleanResult: result from: primIndex	successFlag		ifTrue: [self pushBool: result]		ifFalse: [self unPop: 2.  self failSpecialPrim: primIndex]!checkIntegerResult: integerResult from: primIndex	(successFlag and: [self isIntegerValue: integerResult])		ifTrue: [self pushInteger: integerResult]		ifFalse: [self unPop: 2.  self failSpecialPrim: primIndex]!compare31or32Bits: obj1 equal: obj2	"May set success to false"	"First compare two ST integers..."	((self isIntegerObject: obj1)		and: [self isIntegerObject: obj2])		ifTrue: [^ obj1 = obj2].	"Now compare, assuming positive integers, but setting fail if not"	^ (self positive32BitValueOf: obj1) = (self positive32BitValueOf: obj2)!primitiveAdd	| rcvr arg result |	successFlag _ true.	rcvr _ self stackValue: 1.	arg _ self stackValue: 0.	(self areFloats: rcvr and: arg) ifTrue: [		self primitiveFloatAdd.		successFlag ifTrue: [ ^ nil ].	].	self pop: 2.	self success: (self areIntegers: rcvr and: arg).	successFlag ifTrue: [		result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).	].	self checkIntegerResult: result from: 1.!primitiveBitAnd	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitAnd: integerArgument))]		ifFalse: [self unPop: 2.  self failSpecialPrim: 14]!primitiveBitOr	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitOr: integerArgument))]		ifFalse: [self unPop: 2.  self failSpecialPrim: 15]!primitiveBitShift 	| integerReceiver integerArgument shifted |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popPos32BitInteger.	integerArgument >= 0		ifTrue:		["Left shift -- must fail if we lose bits beyond 32"		self success: integerArgument <= 31.		shifted _ integerReceiver << integerArgument.		self success: (shifted >> integerArgument) = integerReceiver.		]		ifFalse:		["Right shift -- OK to lose bits"		self success: integerArgument >= -31.		shifted _ integerReceiver bitShift: integerArgument.		].	successFlag		ifTrue: [self push: (self positive32BitIntegerFor: shifted)]		ifFalse: [self unPop: 2.  self failSpecialPrim: 17]!primitiveBitXor	"Note: unlike all the other arithmetic primitives, this is called as	a real send, not as a special byte.  Thus successFlag has already	been set, and failure is normal, not through failSpecialPrim."	| integerReceiver integerArgument |	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitXor: integerArgument))]		ifFalse: [self unPop: 2]!primitiveDiv	"Rounds negative results towards negative infinity, rather than zero."	| rcvr arg result posArg posRcvr |	successFlag _ true.	arg _ self popInteger.	rcvr _ self popInteger.	self success: arg ~= 0.	successFlag ifTrue: [		rcvr > 0 ifTrue: [			arg > 0 ifTrue: [				result _ rcvr // arg.			] ifFalse: [				"round negative result toward negative infinity"				posArg _ 0 - arg.				result _ 0 - ((rcvr + (posArg - 1)) // posArg).			].		] ifFalse: [			posRcvr _ 0 - rcvr.			arg > 0 ifTrue: [				"round negative result toward negative infinity"				result _ 0 - ((posRcvr + (arg - 1)) // arg).			] ifFalse: [				posArg _ 0 - arg.				result _ posRcvr // posArg.			].		].		self checkIntegerResult: result from: 12]	ifFalse:		[self checkIntegerResult: 0 from: 12 "will fail"]!primitiveDivide	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self success: integerArgument ~= 0.	successFlag ifFalse: [integerArgument _ 1].  "fall through to fail"	self success: integerReceiver \\ integerArgument = 0.	self checkIntegerResult: integerReceiver // integerArgument from: 10!primitiveEqual	| integerReceiver integerArgument result |	successFlag _ true.	integerArgument _ self popStack.	integerReceiver _ self popStack.	result _ self compare31or32Bits: integerReceiver equal: integerArgument.	self checkBooleanResult: result from: 7!primitiveGreaterOrEqual	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver >= integerArgument from: 6!primitiveGreaterThan	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver > integerArgument from: 4!primitiveLessOrEqual	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver <= integerArgument from: 5!primitiveLessThan	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver < integerArgument from: 3!primitiveMakePoint	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	successFlag		ifTrue: [self push: (self makePointwithxValue: integerReceiver yValue: integerArgument)]		ifFalse: [self checkIntegerResult: 0 from: 18  "will fail"]!primitiveMod	| integerReceiver integerArgument integerResult |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self success: integerArgument ~= 0.	successFlag ifFalse: [integerArgument _ 1].  "fall through to fail"	integerResult _ integerReceiver \\ integerArgument.	integerResult < 0 ifTrue: [integerResult _ integerResult + integerArgument].	self checkIntegerResult: integerResult from: 11!primitiveMultiply	| rcvr arg result |	successFlag _ true.	rcvr _ self stackValue: 1.	arg _ self stackValue: 0.	(self areFloats: rcvr and: arg) ifTrue: [		self primitiveFloatMultiply.		successFlag ifTrue: [ ^ nil ].	].	self pop: 2.	self success: (self areIntegers: rcvr and: arg).	successFlag ifTrue: [		rcvr _ self integerValueOf: rcvr.		arg _ self integerValueOf: arg.		result _ rcvr * arg.		"check for C overflow by seeing if computation is reversible"		self success: ((arg = 0) or: [(result // arg) = rcvr]).	].	self checkIntegerResult: result from: 9.!primitiveNotEqual	| integerReceiver integerArgument result |	successFlag _ true.	integerArgument _ self popStack.	integerReceiver _ self popStack.	result _ (self compare31or32Bits: integerReceiver equal: integerArgument) not.	self checkBooleanResult: result from: 8!primitiveQuo	"Rounds negative results towards zero."	"Note: unlike the other arithmetic primitives, this is called as	a real send, not as a special byte.  Thus successFlag has already	been set, and failure is normal, not through failSpecialPrim."	| rcvr arg result |	arg _ self popInteger.	rcvr _ self popInteger.	self success: arg ~= 0.	successFlag ifTrue: [		rcvr > 0 ifTrue: [			arg > 0 ifTrue: [				result _ rcvr // arg.			] ifFalse: [				result _ 0 - (rcvr // (0 - arg)).			].		] ifFalse: [			arg > 0 ifTrue: [				result _ 0 - ((0 - rcvr) // arg).			] ifFalse: [				result _ (0 - rcvr) // (0 - arg).			].		].		self success: (self isIntegerValue: result)].	successFlag		ifTrue: [self pushInteger: result]		ifFalse: [self unPop: 2]!primitiveSubtract	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkIntegerResult: integerReceiver - integerArgument from: 2! !!Interpreter methodsFor: 'float primitives'!floatObjectOf: f	"Note: Argument declaration commented out to allow inlining."	| newFloat |	"self var: #f declareC: 'double f'."	newFloat _ self instantiateSmallClass: (self splObj: ClassFloat) sizeInBytes: 12 fill: 0.	self floatAt: newFloat + BaseHeaderSize put: f.	^ newFloat!floatValueOf: floatOop	| cl |	self returnTypeC: 'double'.	cl _ self fetchClassOf: floatOop.	self success: cl = (self splObj: ClassFloat).	successFlag ifTrue: [		^ self floatAt: floatOop + BaseHeaderSize	].	^ 0.0!popFloat	| top |	self returnTypeC: 'double'.	top _ self popStack.	^ self floatValueOf: top!primitiveAsFloat	| arg |	arg _ self popInteger.	successFlag		ifTrue: [ self pushFloat: (self cCode: '((double) arg)') ]		ifFalse: [ self unPop: 1 ].!primitiveExponent	| rcvr frac pwr |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	rcvr _ self popFloat.	successFlag		ifTrue: [			self cCode: 'frac = frexp(rcvr, &pwr)'.  "rcvr = m * 2^pwr, where m is in [0.5..1.0)"			(pwr = 0)				ifTrue: [self pushInteger: 0]				ifFalse: [self pushInteger: pwr - 1]]		ifFalse: [self unPop: 1].!primitiveFloatAdd	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr + arg]		ifFalse: [self unPop: 2]!primitiveFloatDivide	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	arg _ self popFloat.	rcvr _ self popFloat.	self success: arg ~= 0.0.	successFlag		ifTrue: [self pushFloat: rcvr // arg]  "// generates C / operation"		ifFalse: [self unPop: 2]!primitiveFloatEqual	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr = arg]		ifFalse: [self unPop: 2]!primitiveFloatGreaterOrEqual	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr >= arg]		ifFalse: [self unPop: 2]!primitiveFloatGreaterThan	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr > arg]		ifFalse: [self unPop: 2]!primitiveFloatLessOrEqual	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr <= arg]		ifFalse: [self unPop: 2]!primitiveFloatLessThan	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr < arg]		ifFalse: [self unPop: 2]!primitiveFloatMultiply	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr * arg]		ifFalse: [self unPop: 2]!primitiveFloatNotEqual	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr ~= arg]		ifFalse: [self unPop: 2]!primitiveFloatSubtract	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr - arg]		ifFalse: [self unPop: 2]!primitiveFractionalPart	| rcvr frac trunc |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	self var: #trunc declareC: 'double trunc'.	rcvr _ self popFloat.	successFlag		ifTrue: [			self cCode: 'frac = modf(rcvr, &trunc)'.			self pushFloat: frac]		ifFalse: [self unPop: 1]!primitiveTimesTwoPower	| rcvr arg |	self var: #arg declareC: 'double arg'.	arg _ self popInteger.	rcvr _ self popFloat.	successFlag		ifTrue: [ self pushFloat: (self cCode: 'ldexp(rcvr, arg)') ]		ifFalse: [ self unPop: 2 ].!primitiveTruncated	| rcvr frac trunc |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	self var: #trunc declareC: 'double trunc'.	rcvr _ self popFloat.	successFlag ifTrue: [		self cCode: 'frac = modf(rcvr, &trunc)'.		self cCode: 'success((-4294967296.0 <= trunc) && (trunc <= 4294967295.0))'.	].	successFlag		ifTrue: [self cCode: 'pushInteger((int) trunc)']		ifFalse: [self unPop: 1]!pushFloat: f	"Note: Argument declaration commented out to allow inlining."	"self var: #f declareC: 'double f'."	self push: (self floatObjectOf: f).! !!Interpreter methodsFor: 'array and stream primitives'!asciiOfCharacter: characterObj  "Returns an integer object"	self success: (self fetchClassOf: characterObj) = (self splObj: ClassCharacter).	successFlag		ifTrue: [^ self fetchPointer: CharacterValueIndex ofObject: characterObj]		ifFalse: [^ ConstZero]  "in case some code needs an int"!byteLengthOf: oop	"Return the number of indexable bytes in the given object. This is basically a special copy of lengthOf: for BitBlt."	| header sz fmt |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: 16rFC ].	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize)]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3)]  "bytes"!characterForAscii: integerObj  "Arg must lie in range 0-255!!"	^ self fetchPointer: (self integerValueOf: integerObj)			ofObject: (self splObj: CharacterTable)!commonAt: stringy	"This version of at: is called from the special byteCode, from	primitiveAt, and from primStringAt.  The boolean 'stringy'	indicates that the result should be converted to a Character."	| index array result |	index _ self popInteger.	array _ self popStack.	self success: (self isIntegerObject: array) not.	successFlag ifTrue: [		result _ self stObject: array at: index.	].	successFlag ifTrue: [		stringy			ifTrue: [ self push: (self characterForAscii: result) ]			ifFalse: [ self push: result ].	] ifFalse: [		self unPop: 2.		stringy			ifTrue: [ self failSpecialPrim: 63 ]			ifFalse: [ self failSpecialPrim: 60 ].	].!commonAtPut: stringy	"See the comment in commonAt"	| index array value storeVal |	value _ self popStack.	index _ self popInteger.	array _ self popStack.	stringy ifTrue: [storeVal _ self asciiOfCharacter: value]			ifFalse: [storeVal _ value].	self stObject: array at: index put: storeVal.	successFlag		ifTrue: [self push: value]		ifFalse: [self unPop: 3.				stringy ifTrue: [self failSpecialPrim: 64]						ifFalse: [self failSpecialPrim: 61]]!lengthOf: oop	"Return the number of indexable bytes or words in the given object. Assume the argument is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result."	| header sz fmt |	"from ObjectMemory>sizeBitsOf:..."	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: 16rFC ].	"from ObjectMemory>formatOf:..."	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) // 4 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"!okStreamArrayClass: cl	^(cl = (self splObj: ClassString) or:	  [cl = (self splObj: ClassArray) or:	  [cl = (self splObj: ClassByteArray) or:	  [cl = (self splObj: ClassBitmap)]]])!primitiveAt	^ self commonAt: false!primitiveAtEnd	| stream array index limit arrayClass size |	successFlag _ true.	stream _ self popStack.	self success: ((self isPointers: stream) and: [(self lengthOf: stream) >= 3]). 	successFlag ifTrue: [		array _ self fetchPointer: StreamArrayIndex ofObject: stream.		index _ self fetchInteger: StreamIndexIndex ofObject: stream.		limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.		arrayClass _ self fetchClassOf: array.		self success: (self okStreamArrayClass: arrayClass).		size _ self stSizeOf: array.	]. 	successFlag		ifTrue: [self pushBool: (index >= limit) | (index >= size)]		ifFalse: [self unPop: 1.  self failSpecialPrim: 67].!primitiveAtPut	^ self commonAtPut: false!primitiveNext	| stream array index limit arrayClass result |	successFlag _ true.	stream _ self popStack.	array _ self fetchPointer: StreamArrayIndex ofObject: stream.	index _ self fetchInteger: StreamIndexIndex ofObject: stream.	limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.	arrayClass _ self fetchClassOf: array.	self success: (self okStreamArrayClass: arrayClass).	self success: index < limit.	successFlag ifTrue:		[index _ index + 1.		result _ self stObject: array at: index].	successFlag ifTrue:		[self storeInteger: StreamIndexIndex ofObject: stream				withValue: index].	successFlag ifTrue:		[arrayClass = (self splObj: ClassString)			ifTrue: [self push: (self characterForAscii: result)]			ifFalse: [self push: result]]		ifFalse:		[self unPop: 1. "self failSpecialPrim: 65" ]  "experimental: new way to handle bytecode sends"!primitiveNextPut	| value stream index limit array arrayClass storeVal |	successFlag _ true.	value _ self popStack.	stream _ self popStack.	array _ self fetchPointer: StreamArrayIndex ofObject: stream.	index _ self fetchInteger: StreamIndexIndex ofObject: stream.	limit _ self fetchInteger: StreamWriteLimitIndex ofObject: stream.	arrayClass _ self fetchClassOf: array.	self success: (self okStreamArrayClass: arrayClass).	self success: index < limit.	successFlag ifTrue:		[index _ index + 1.		arrayClass = (self splObj: ClassString)			ifTrue: [storeVal _ self asciiOfCharacter: value]			ifFalse: [storeVal _ value].		self stObject: array at: index put: storeVal].	successFlag ifTrue:		[self storeInteger: StreamIndexIndex ofObject: stream			withValue: index].	successFlag		ifTrue: [self push: value]		ifFalse: [self unPop: 2. self failSpecialPrim: 66]!primitiveSize	| array sz |	array _ self popStack.	sz _ self stSizeOf: array.	successFlag		ifTrue: [self pushInteger: sz]		ifFalse: [self unPop: 1. self failSpecialPrim: 62]!primitiveStringAt	^ self commonAt: true!primitiveStringAtPut	^ self commonAtPut: true!primitiveStringReplace"<array> primReplaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>"	| array start stop replacement repStart arrayInstSize repInstSize fmt repi i | 	array _ self stackValue: 4.	start _ self stackIntegerValue: 3.	stop _ self stackIntegerValue: 2.	replacement _ self stackValue: 1.	repStart _ self stackIntegerValue: 0.	arrayInstSize _ self fixedFieldsOf: array.	repInstSize _ self fixedFieldsOf: replacement.	self success: start >= 1.	self success: start <= stop.	self success: (stop + arrayInstSize <= (self lengthOf: array)).	self success: repStart >= 1.	self success: (stop - start + repStart + repInstSize <= (self lengthOf: replacement)).	fmt _ self formatOf: array.	fmt < 8  "Array formats (without byteSize bits) must be same"		ifTrue: [self success: fmt = (self formatOf: replacement)]		ifFalse: [self success: (fmt bitAnd: 16rC) = ((self formatOf: replacement) bitAnd: 16rC)].	successFlag ifFalse: [^ self primitiveFail].	repi _ repStart + repInstSize - 1.   " - 1 for 0-based access"	start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do:		[:i | 		fmt < 4 ifTrue:			["pointer type objects"			self storePointer: i ofObject: array withValue:				(self fetchPointer: repi ofObject: replacement)]		ifFalse:			[fmt < 8 ifTrue:				["long-word type objects"				self storeWord: i ofObject: array withValue:				(self fetchWord: repi ofObject: replacement)]			ifFalse: 				["byte-type objects"				self storeByte: i ofObject: array withValue:				(self fetchByte: repi ofObject: replacement)]].		repi _ repi + 1].	self pop: 4.!stObject: array at: index	"Return what ST would return for <obj> at: index."	| fixedFields totalLength i |	fixedFields _ self fixedFieldsOf: array.	totalLength _ self lengthOf: array.	i _ index + fixedFields.	self success: ((index >= 1) and: [i <= totalLength]).	successFlag		ifTrue: [ ^ self subscript: array with: i ]		ifFalse: [ ^ nilObj ].!stObject: array at: index put: value	"Do what ST would return for <obj> at: index put: value."	| fixedFields totalLength i |	fixedFields _ self fixedFieldsOf: array.	totalLength _ self lengthOf: array.	i _ index + fixedFields.	self success: ((index >= 1) and: [i <= totalLength]).	successFlag ifTrue: [		self subscript: array with: i storing: value.	].!stSizeOf: oop	"Return the number of indexable fields in the given object. (i.e. what ST would return for <obj> size)."	"Note: oop may be a SmallInteger!!"	| totalLength fixedFields |	(self isIntegerObject: oop) ifTrue: [ ^ 0 ].  "integers have no indexable fields"	totalLength _ self lengthOf: oop.	fixedFields _ self fixedFieldsOf: oop.	^ totalLength - fixedFields!subscript: array with: index	"Note: This method assumes that the index is within bounds!!"	| fmt byteVal |	fmt _ self formatOf: array.	fmt < 4 ifTrue:		["pointer type objects"		^ self fetchPointer: index - 1 ofObject: array].	fmt < 8 ifTrue:		["long-word type objects"		^ self positive32BitIntegerFor:			(self fetchWord: index - 1 ofObject: array)].	"byte-type objects"	byteVal _ self fetchByte: index - 1 ofObject: array.	^ self integerObjectOf: byteVal!subscript: array with: index storing: value	"Note: This method assumes that the index is within bounds!!"	| fmt byte bitValue |	fmt _ self formatOf: array.	fmt < 4 ifTrue:		["pointer type objects"		self storePointer: index - 1 ofObject: array withValue: value.		^ nil].	fmt < 8 ifTrue:		["long-word type objects"		bitValue _ self positive32BitValueOf: value.		successFlag ifTrue:			[self storeWord: index-1 ofObject: array withValue: bitValue].		^ nil].	"byte-type objects"	self success: (self isIntegerObject: value).	byte _ self integerValueOf: value.	self success: ((byte >= 0) and: [byte <= 255]).	successFlag ifTrue:		[self storeByte: index - 1 ofObject: array withValue: byte].! !!Interpreter methodsFor: 'object access primitives'!checkInstanceVariableBoundsOf: index in: object	"NOTE: this should really only work for index <= fixed instSize"	self success: index >= 1.	self success: index <= (self lengthOf: object)!primitiveArrayBecome	| arg rcvr |	arg _ self popStack.	rcvr _ self stackTop.	self success: (self become: rcvr with: arg).	successFlag ifFalse: [ self unPop: 1 ].!primitiveAsOop	| thisReceiver |	thisReceiver _ self popStack.	self success: (self isIntegerObject: thisReceiver) not.	successFlag		ifTrue: [self pushInteger: (self hashBitsOf: thisReceiver)]		ifFalse: [self unPop: 1]!primitiveClass	| instance |	instance _ self popStack.	self push: (self fetchClassOf: instance)!primitiveEquivalent	| thisObject otherObject |	otherObject _ self popStack.	thisObject _ self popStack.	self pushBool: thisObject = otherObject!primitiveInstVarAt	| index thisReceiver value |	index _ self popInteger.	thisReceiver _ self popStack.	self checkInstanceVariableBoundsOf: index in: thisReceiver.	successFlag		ifTrue: [value _ self subscript: thisReceiver with: index].	successFlag		ifTrue: [self push: value]		ifFalse: [self unPop: 2]!primitiveInstVarAtPut	| newValue index thisReceiver |	newValue _ self popStack.	index _ self popInteger.	thisReceiver _ self popStack.	self checkInstanceVariableBoundsOf: index in: thisReceiver.	successFlag		ifTrue: [self subscript: thisReceiver with: index storing: newValue].	successFlag		ifTrue: [self push: newValue]		ifFalse: [self unPop: 3]!primitiveNew	"Allocate a new fixed-size instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free."	| class spaceOkay |	class _ self popStack.	spaceOkay _ self sufficientSpaceToInstantiate: class indexableSize: 0.	self success: spaceOkay.	successFlag		ifTrue: [ self push: (self instantiateClass: class indexableSize: 0) ]		ifFalse: [ self unPop: 1 ].!primitiveNewWithArg	"Allocate a new indexable instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free."	| size class spaceOkay |	size _ self popInteger.	class _ self popStack.	self success: size >= 0.	successFlag ifTrue: [		spaceOkay _ self sufficientSpaceToInstantiate: class indexableSize: size.		self success: spaceOkay.	].	successFlag		ifTrue: [ self push: (self instantiateClass: class indexableSize: size) ]		ifFalse: [ self unPop: 2 ].!primitiveNextInstance	| object instance |	object _ self popStack.	instance _ self instanceAfter: object.	instance = nilObj		ifTrue: [self primitiveFail]		ifFalse: [self push: instance]!primitiveNextObject	"Return the object following the receiver in the heap. Return the SmallInteger zero when there are no more objects."	| object instance |	object _ self popStack.	instance _ self accessibleObjectAfter: object.	instance = nil		ifTrue: [ self pushInteger: 0 ]		ifFalse: [ self push: instance ].!primitiveObjectAt  "Defined for CompiledMethods only"	| thisReceiver index |	index  _ self popInteger.	thisReceiver _ self popStack.	self success: index > 0.	self success: index <= ((self literalCountOf: thisReceiver) + LiteralStart).	successFlag		ifTrue: [self push: (self fetchPointer: index - 1					ofObject: thisReceiver)]		ifFalse: [self unPop: 2]!primitiveObjectAtPut  "Defined for CompiledMethods only"	| thisReceiver index newValue |	newValue _ self popStack.	index _ self popInteger.	thisReceiver _ self popStack.	self success: index > 0.	self success: index <= ((self literalCountOf: thisReceiver) + LiteralStart).	successFlag		ifTrue: [self storePointer: index - 1				ofObject: thisReceiver				withValue: newValue.			self push: newValue]		ifFalse: [self unPop: 3]!primitiveObjectPointsTo	| rcvr thang lastField i |	thang _ self popStack.	rcvr _ self popStack.	(self isIntegerObject: rcvr) ifTrue: [^ self pushBool: false].	lastField _ self lastPointerOf: rcvr.	BaseHeaderSize to: lastField by: 4 do:		[:i | (self longAt: rcvr + i) = thang			ifTrue: [^ self pushBool: true]].	self pushBool: false.!primitivePointX	| rcvr | 	successFlag _ true.	rcvr _ self popStack.	self success: (self fetchClassOf: rcvr) = (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: XIndex ofObject: rcvr)]		ifFalse: [self unPop: 1.  self failSpecialPrim: 0  "will fail"]!primitivePointY	| rcvr | 	successFlag _ true.	rcvr _ self popStack.	self success: (self fetchClassOf: rcvr) = (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: YIndex ofObject: rcvr)]		ifFalse: [self unPop: 1.  self failSpecialPrim: 0  "will fail"]!primitiveSomeInstance	| class instance |	class _ self popStack.	instance _ self initialInstanceOf: class.	instance = nilObj		ifTrue: [self primitiveFail]		ifFalse: [self push: instance]!primitiveSomeObject	"Return the first object in the heap."	self pop: 1.	self push: self firstAccessibleObject.!sufficientSpaceToInstantiate: classOop indexableSize: size	"Return the number of bytes required to allocate an instance of the given class with the given number of indexable fields."	"Details: For speed, over-estimate space needed for fixed fields or literals; the low space threshold is a blurry line."	| format okay |	format _ ((self formatOfClass: classOop) >> 8) bitAnd: 16rF.	"fail if attempting to call new: on non-indexable class"	(size > 0 and: [format < 2]) ifTrue: [ ^ false ].	format < 8 ifTrue: [		"indexable fields are words or pointers"		okay _ self sufficientSpaceToAllocate: (2500 + (size * 4)).	] ifFalse: [		"indexable fields are bytes"		okay _ self sufficientSpaceToAllocate: (2500 + size).	].	^ okay! !!Interpreter methodsFor: 'control primitives'!primitiveBlockCopy	| context methodContext contextSize newContext initialIP |	context _ self stackValue: 1.	(self isIntegerObject: (self fetchPointer: MethodIndex ofObject: context)) ifTrue: [		"context is a block; get the context of its enclosing method"		methodContext _ self fetchPointer: HomeIndex ofObject: context.	] ifFalse: [		methodContext _ context.	].	contextSize _ self sizeBitsOf: methodContext.  "in bytes, including header"	context _ nil.  "context is no longer needed and is not preserved across allocation"	"remap methodContext in case GC happens during allocation"	self pushRemappableOop: methodContext.	newContext _ self instantiateSmallClass: (self splObj: ClassBlockContext)							   sizeInBytes: contextSize									   fill: nilObj.	methodContext _ self popRemappableOop.	initialIP _ self integerObjectOf: instructionPointer - method.	"Was instructionPointer + 3, but now it's greater by 		methodOop + 4 (headerSize) and less by 1 due to preIncrement"	"Assume: have just allocated a new context; it must be young.	 Thus, can use uncheck stores. See the comment in fetchContextRegisters."	self storeWord: InitialIPIndex					ofObject: newContext		withValue: initialIP.	self storeWord: InstructionPointerIndex		ofObject: newContext		withValue: initialIP.	self storeStackPointerValue: 0				inContext: newContext.	self storePointerUnchecked: BlockArgumentCountIndex	ofObject: newContext		withValue: (self stackValue: 0).	self storePointerUnchecked: HomeIndex		ofObject: newContext		withValue: methodContext.	self pop: 2.  "block argument count, rcvr"	self push: newContext.!primitivePerform	| performSelector newReceiver selectorIndex |	performSelector _ messageSelector.	messageSelector _ self stackValue: argumentCount - 1.	newReceiver _ self stackValue: argumentCount.	self lookupMethodInClass: (self fetchClassOf: newReceiver).	self success: (self argumentCountOf: newMethod) = (argumentCount - 1).	successFlag		ifTrue: [selectorIndex _ self stackPointerIndex - argumentCount + 1.			self transfer: argumentCount - 1				fromIndex: selectorIndex + 1				ofObject: activeContext				toIndex: selectorIndex				ofObject: activeContext.			self pop: 1.			argumentCount _ argumentCount - 1.			self executeNewMethod.  "Recursive xeq affects successFlag"			successFlag _ true]		ifFalse: [messageSelector _ performSelector]!primitivePerformWithArgs	| thisReceiver performSelector argumentArray arrayClass arraySize index cntxSize |	argumentArray _ self popStack.	arraySize _ self fetchWordLengthOf: argumentArray.	arrayClass _ self fetchClassOf: argumentArray.	cntxSize _ self fetchWordLengthOf: activeContext.	self success: (self stackPointerIndex + arraySize) < cntxSize.	self success: (arrayClass = (self splObj: ClassArray)).	successFlag		ifTrue: [performSelector _ messageSelector.			messageSelector _ self popStack.			thisReceiver _ self stackTop.			argumentCount _ arraySize.			index _ 1.			[index <= argumentCount]				whileTrue: [self push: (self fetchPointer: index - 1								ofObject: argumentArray).					index _ index + 1].			self lookupMethodInClass:				(self fetchClassOf: thisReceiver).			self success: (self argumentCountOf: newMethod)						= argumentCount.			successFlag				ifTrue: [self executeNewMethod.  "Recursive xeq affects successFlag"						successFlag _ true]				ifFalse: [self unPop: argumentCount.						self push: messageSelector.						self push: argumentArray.						argumentCount _ 2.						messageSelector _ performSelector]]	ifFalse: [self unPop: 1]!primitiveValue	| blockContext blockArgumentCount initialIP |	blockContext _ self stackValue: argumentCount.	blockArgumentCount _ self argumentCountOfBlock: blockContext.	self success: argumentCount = blockArgumentCount.	successFlag		ifTrue: [self transfer: argumentCount				fromIndex: self stackPointerIndex - argumentCount + 1				ofObject: activeContext				toIndex: TempFrameStart				ofObject: blockContext.			"Assume: The call to transfer:... makes blockContext a root if necessary,			 allowing use to use unchecked stored in the following code."			self pop: argumentCount + 1.			initialIP _ self fetchPointer: InitialIPIndex	ofObject: blockContext.			self storePointerUnchecked: InstructionPointerIndex ofObject: blockContext				withValue: initialIP.			self storeStackPointerValue: argumentCount	inContext: blockContext.			self storePointerUnchecked: CallerIndex		ofObject: blockContext				withValue: activeContext.			self newActiveContext: blockContext]!primitiveValueWithArgs	| argumentArray blockContext blockArgumentCount	arrayClass arrayArgumentCount initialIP |	argumentArray _ self popStack.	blockContext _ self popStack.	blockArgumentCount _ self argumentCountOfBlock: blockContext.	arrayClass _ self fetchClassOf: argumentArray.	self success: (arrayClass = (self splObj: ClassArray)).	successFlag		ifTrue: [arrayArgumentCount _ self fetchWordLengthOf: argumentArray.			self success: arrayArgumentCount = blockArgumentCount].	successFlag		ifTrue: [self transfer: arrayArgumentCount				fromIndex: 0				ofObject: argumentArray				toIndex: TempFrameStart				ofObject: blockContext.			"Assume: The call to transfer:... makes blockContext a root if necessary,			 allowing use to use unchecked stored in the following code."			initialIP _ self fetchPointer: InitialIPIndex		ofObject: blockContext.			self storePointerUnchecked: InstructionPointerIndex ofObject: blockContext				withValue: initialIP.			self storeStackPointerValue: arrayArgumentCount inContext: blockContext.			self storePointerUnchecked: CallerIndex			ofObject: blockContext				withValue: activeContext.			self newActiveContext: blockContext]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'processes'!addLastLink: proc toList: aList	"Add the given process to the given linked list and set the backpointer	of process to its new list."	| lastLink |	(self isEmptyList: aList) ifTrue: [		self storePointer: FirstLinkIndex ofObject: aList withValue: proc.	] ifFalse: [		lastLink _ self fetchPointer: LastLinkIndex ofObject: aList.		self storePointer: NextLinkIndex ofObject: lastLink withValue: proc.	].	self storePointer: LastLinkIndex ofObject: aList withValue: proc.	self storePointer: MyListIndex   ofObject:  proc withValue: aList.!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now |	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		lowSpaceThreshold _ 0.  "disable additional interrupts until this is reset by image"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [ ^ self synchronousSignal: sema ].	].	now _ self ioMSecs.	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500.  "msecs to wait before next call to ioProcessEvents"	].	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [ ^ self synchronousSignal: sema ].	].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [ ^ self synchronousSignal: sema ].	].!internalQuickCheckForInterrupts	"Internal version of quickCheckForInterrupts for use within jumps."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		interruptCheckCounter _ 1000.		self externalizeIPandSP.		self checkForInterrupts.		self internalizeIPandSP.	].!isEmptyList: aLinkedList	^ (self fetchPointer: FirstLinkIndex ofObject: aLinkedList) = nilObj!primitiveResume	| proc |	proc _ self stackTop.  "rcvr"	"self success: ((self fetchClassOf: proc) = (self splObj: ClassProcess))."	successFlag ifTrue: [ self resume: proc ].!primitiveSignal	| sema |	sema _ self stackTop.  "rcvr"	self success: ((self fetchClassOf: sema) = (self splObj: ClassSemaphore)).	successFlag ifTrue: [ self synchronousSignal: sema ].!primitiveSuspend	| activeProc |	activeProc _ self fetchPointer: ActiveProcessIndex						 ofObject: self schedulerPointer.	self success: self stackTop = activeProc.	successFlag ifTrue: [		self pop: 1.		self push: nilObj.		self transferTo: self wakeHighestPriority.	].!primitiveWait	| sema excessSignals activeProc |	sema _ self stackTop.  "rcvr"	self success: ((self fetchClassOf: sema) = (self splObj: ClassSemaphore)).	successFlag ifTrue: [		excessSignals _			self fetchInteger: ExcessSignalsIndex ofObject: sema.		excessSignals > 0 ifTrue: [			self storeInteger: ExcessSignalsIndex				ofObject: sema withValue: excessSignals - 1.		] ifFalse: [			activeProc _ self fetchPointer: ActiveProcessIndex								 ofObject: self schedulerPointer.			self addLastLink: activeProc toList: sema.			self transferTo: self wakeHighestPriority.		].	].!putToSleep: aProcess	"Save the given process on the scheduler process list for its priority."	| priority processLists processList |	priority _ self quickFetchInteger: PriorityIndex ofObject: aProcess.	processLists _ self fetchPointer: ProcessListsIndex ofObject: self schedulerPointer.	processList _ self fetchPointer: priority - 1 ofObject: processLists.	self addLastLink: aProcess toList: processList.!quickCheckForInterrupts	"Quick check for possible user or timer interrupts. Decrement a counter and only do a real check when counter reaches zero or when a low space or user interrupt is pending."	"Note: Clients who set signalLowSpace or interruptPending should also set interruptCheckCounter to zero to get immediate results."	"Note: Requires that instructionPointer and stackPointer be external."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		interruptCheckCounter _ 1000.		self checkForInterrupts.	].!removeFirstLinkOfList: aList	"Remove the first process from the given linked list."	| first last next |	first _ self fetchPointer: FirstLinkIndex ofObject: aList.	last  _ self fetchPointer: LastLinkIndex ofObject: aList.	first = last ifTrue: [		self storePointer: FirstLinkIndex ofObject: aList withValue: nilObj.		self storePointer:  LastLinkIndex ofObject: aList withValue: nilObj.	] ifFalse: [		next _ self fetchPointer: NextLinkIndex ofObject: first.		self storePointer: FirstLinkIndex ofObject: aList withValue: next.	].	self storePointer: NextLinkIndex ofObject: first withValue: nilObj.	^ first!resume: aProcess	| activeProc activePriority newPriority |	activeProc _ self fetchPointer: ActiveProcessIndex						 ofObject: self schedulerPointer.	activePriority _ self quickFetchInteger: PriorityIndex ofObject: activeProc.	newPriority   _ self quickFetchInteger: PriorityIndex ofObject: aProcess.	newPriority > activePriority ifTrue: [		self putToSleep: activeProc.		self transferTo: aProcess.	] ifFalse: [		self putToSleep: aProcess.	].!schedulerPointer	^ self fetchPointer: ValueIndex		ofObject: (self splObj: SchedulerAssociation)!synchronousSignal: aSemaphore	"Signal the given semaphore from within the interpreter."	| excessSignals |	(self isEmptyList: aSemaphore) ifTrue: [		"no process is waiting on this semaphore"		excessSignals _			self fetchInteger: ExcessSignalsIndex ofObject: aSemaphore.		self storeInteger: ExcessSignalsIndex			ofObject: aSemaphore withValue: excessSignals + 1.	] ifFalse: [		self resume: (self removeFirstLinkOfList: aSemaphore).	].!transferTo: newProc	"Record a process to be awoken on the next interpreter cycle."	| sched oldProc |	sched _ self schedulerPointer.	oldProc _ self fetchPointer: ActiveProcessIndex ofObject: sched.	self storePointer: SuspendedContextIndex ofObject: oldProc withValue: activeContext.	self storePointer: ActiveProcessIndex      ofObject:   sched withValue: newProc.	self newActiveContext:		(self fetchPointer: SuspendedContextIndex ofObject: newProc).	reclaimableContextCount _ 0.!wakeHighestPriority	"Return the highest priority process that is ready to run."	"Note: It is a fatal VM error if there is no runnable process."	| schedLists p processList |	schedLists _ self fetchPointer: ProcessListsIndex				ofObject: self schedulerPointer.	p _ self fetchWordLengthOf: schedLists.	p _ p - 1.  "index of last indexable field"	processList _ self fetchPointer: p ofObject: schedLists.	[self isEmptyList: processList] whileTrue: [		p _ p - 1.		p < 0 ifTrue: [ self error: 'scheduler could not find a runnable process' ].		processList _ self fetchPointer: p ofObject: schedLists.	].	^ self removeFirstLinkOfList: processList! !!Interpreter methodsFor: 'I/O primitives'!fullDisplayUpdate	"Repaint the entire smalltalk screen, ignoring the affected rectangle. Used when the Smalltalk window is brought to the front or uncovered."	| displayObj dispBits w h dispBitsIndex d |	displayObj _ self splObj: TheDisplay.	((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]) ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, 0, w, 0, h)'.	].!primitiveBeCursor	"Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk."	| cursorObj bitsObj extentX extentY offsetObj offsetX offsetY cursorBitsIndex |	cursorObj _ self stackTop.	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 5]).	successFlag ifTrue: [		bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		extentX _ self fetchInteger: 1 ofObject: cursorObj.		extentY _ self fetchInteger: 2 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj.		self success: ((self isPointers: offsetObj) and: [(self lengthOf: offsetObj) >= 2]).	].	successFlag ifTrue: [		offsetX _ self fetchInteger: 0 ofObject: offsetObj.		offsetY _ self fetchInteger: 1 ofObject: offsetObj.		self success: ((extentX = 16) and: [extentY = 16]).		self success: ((offsetX >= -16) and: [offsetX <= 0]).		self success: ((offsetY >= -16) and: [offsetY <= 0]).		self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).		cursorBitsIndex _ bitsObj + BaseHeaderSize.	].	successFlag ifTrue: [		self cCode: 'ioSetCursor(cursorBitsIndex, offsetX, offsetY)'.		self pop: 1.	].!primitiveBeDisplay	"Record the system Display object."	| rcvr |	rcvr _ self stackTop.	self success: ((self isPointers: rcvr) and: [(self lengthOf: rcvr) >= 4]).	successFlag ifTrue: [		"record the display object both in a variable and in the specialObjectsOop"		self storePointer: TheDisplay ofObject: specialObjectsOop withValue: rcvr.		self pop: 1.	].!primitiveBeep	self pop: 1.  "pop rcvr"	self ioBeep.!primitiveCopyBits	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackTop.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self copyBits.		self targetForm = (self splObj: TheDisplay) ifTrue: [self showDisplayBits].	].!primitiveDrawLoop	"Invoke the line drawing primitive."	| rcvr xDelta yDelta |	rcvr _ self stackValue: 2.	xDelta _ self stackIntegerValue: 1.	yDelta _ self stackIntegerValue: 0.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self drawLoopX: xDelta Y: yDelta.		self targetForm = (self splObj: TheDisplay) ifTrue: [self showDisplayBits].		self pop: 2].!primitiveInputSemaphore	"Register the input semaphore. If the argument is not a Semaphore, unregister the current input semaphore."	| arg |	arg _ self popStack.	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [		self storePointer: TheInputSemaphore ofObject: specialObjectsOop withValue: arg.	] ifFalse: [		self storePointer: TheInputSemaphore ofObject: specialObjectsOop withValue: nilObj.	].!primitiveInputWord	"Return an integer indicating the reason for the most recent input interrupt."	self pop: 1.	self pushInteger: 0.	"noop for now"!primitiveInterruptSemaphore	"Register the user interrupt semaphore. If the argument is not a Semaphore, unregister the current interrupt semaphore."	| arg |	arg _ self popStack.	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [		self storePointer: TheInterruptSemaphore ofObject: specialObjectsOop withValue: arg.	] ifFalse: [		self storePointer: TheInterruptSemaphore ofObject: specialObjectsOop withValue: nilObj.	].!primitiveKbdNext	"Return the next keycode and remove it from the input buffer. The low byte is the 8-bit ISO character. The next four bits are the Smalltalk modifier bits <cmd><option><ctrl><shift>."	| keystrokeWord |	self pop: 1.	keystrokeWord _ self ioGetKeystroke.	keystrokeWord >= 0		ifTrue: [self pushInteger: keystrokeWord]		ifFalse: [self push: nilObj].!primitiveKbdPeek	"Return the next keycode and without removing it from the input buffer. The low byte is the 8-bit ISO character. The next four bits are the Smalltalk modifier bits <cmd><option><ctrl><shift>."	| keystrokeWord |	self pop: 1.	keystrokeWord _ self ioPeekKeystroke.	keystrokeWord >= 0		ifTrue: [self pushInteger: keystrokeWord]		ifFalse: [self push: nilObj].!primitiveMouseButtons	"Return the mouse button state. The low three bits encode the state of the <red><yellow><blue> mouse buttons. The next four bits encode the Smalltalk modifier bits <cmd><option><ctrl><shift>."	| buttonWord |	self pop: 1.	buttonWord _ self ioGetButtonState.	self pushInteger: buttonWord.!primitiveMousePoint	"Return a Point indicating current position of the mouse. Note that mouse coordinates may be negative if the mouse moves above or to the left of the top-left corner of the Smalltalk window."	| pointWord x y |	self pop: 1.	pointWord _ self ioMousePoint.	x _ self signExtend16: ((pointWord >> 16) bitAnd: 16rFFFF).	y _ self signExtend16: (pointWord bitAnd: 16rFFFF).	self push: (self makePointwithxValue: x  yValue: y).!primitiveScanCharacters	"Invoke the scanCharacters primitive."	| rcvr start stop string rightX stopArray displayFlag |	rcvr _ self stackValue: 6.	start _ self stackIntegerValue: 5.	stop _ self stackIntegerValue: 4.	string _ self stackValue: 3.	rightX _ self stackIntegerValue: 2.	stopArray _ self stackValue: 1.	displayFlag _ self booleanValueOf: (self stackValue: 0).	successFlag ifFalse: [^ nil].	self success: (self loadScannerFrom: rcvr					start: start stop: stop string: string rightX: rightX					stopArray: stopArray displayFlag: displayFlag).	successFlag		ifTrue: [self scanCharacters].	successFlag		ifTrue: [			(displayFlag and: [self targetForm = (self splObj: TheDisplay)])				ifTrue: [self showDisplayBits].			self pop: 7.			self push: self stopReason].!primitiveScreenSize	"Return a point indicating the current size of the Smalltalk window."	| pointWord |	self pop: 1.	pointWord _ self ioScreenSize.	self push:		(self makePointwithxValue: ((pointWord >>16) bitAnd: 16rFFFF)						   yValue: (pointWord bitAnd: 16rFFFF)).!primitiveSetInterruptKey	"Set the user interrupt keycode. The keycode is an integer whose encoding is described in the comment for primitiveKbdNext."	| keycode |	keycode _ self popInteger.	successFlag		ifTrue: [ interruptKeycode _ keycode ]		ifFalse: [ self unPop: 1 ].!primitiveWarpBits	"Invoke the warpBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackTop.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self warpBits.		self targetForm = (self splObj: TheDisplay) ifTrue: [self showDisplayBits].	].!showDisplayBits	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h affectedRectL affectedRectR affectedRectT affectedRectB dispBitsIndex d |	displayObj _ self splObj: TheDisplay.	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	successFlag ifTrue: [		affectedRectL _ self affectedLeft.		affectedRectR _ self affectedRight.		affectedRectT _ self affectedTop.		affectedRectB _ self affectedBottom.		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.	].! !!Interpreter methodsFor: 'file primitives'!asciiDirectoryDelimiter	^ self cCode: 'dir_Delimitor()'!fileRecordSize	"Return the size of a Smalltalk file record in bytes."	^ self cCode: 'sizeof(SQFile)'.!fileValueOf: objectPointer	"Return a pointer to the first byte of of the file record within the given Smalltalk object, or nil if objectPointer is not a file record."	| fileIndex |	self returnTypeC: 'SQFile *'.	self success:		((self isBytes: objectPointer) and:		 [(self lengthOf: objectPointer) = self fileRecordSize]).	successFlag ifTrue: [		fileIndex _ objectPointer + BaseHeaderSize.		^ self cCode: '(SQFile *) fileIndex'	] ifFalse:  [		^ nil	].!makeDirEntryName: entryName size: entryNameSize	createDate: createDate modDate: modifiedDate	isDir: dirFlag fileSize: fileSize	| modDateOop createDateOop nameString results i |	self var: 'entryName' declareC: 'char *entryName'.	"allocate storage for results, remapping newly allocated	 oops in case GC happens during allocation"	self pushRemappableOop:		(self instantiateClass: (self splObj: ClassArray) indexableSize: 5).	self pushRemappableOop:		(self instantiateClass: (self splObj: ClassString) indexableSize: entryNameSize)..	self pushRemappableOop: (self positive32BitIntegerFor: createDate).	self pushRemappableOop: (self positive32BitIntegerFor: modifiedDate).	modDateOop   _ self popRemappableOop.	createDateOop _ self popRemappableOop.	nameString    _ self popRemappableOop.	results         _ self popRemappableOop.	"copy name into Smalltalk string"	0 to: entryNameSize - 1 do: [ :i |		self storeByte: i ofObject: nameString withValue: (entryName at: i).	].	self storePointer: 0 ofObject: results withValue: nameString.	self storePointer: 1 ofObject: results withValue: createDateOop.	self storePointer: 2 ofObject: results withValue: modDateOop.	dirFlag		ifTrue: [ self storePointer: 3 ofObject: results withValue: trueObj ]		ifFalse: [ self storePointer: 3 ofObject: results withValue: falseObj ].	self storePointer: 4 ofObject: results		withValue: (self integerObjectOf: fileSize).	^ results!primitiveDirectoryCreate	| dirName dirNameIndex dirNameSize |	dirName _ self stackTop.	self success: (self isBytes: dirName).	successFlag ifTrue: [		dirNameIndex _ dirName + BaseHeaderSize.		dirNameSize _ self lengthOf: dirName.	].	successFlag ifTrue: [		self success:			(self cCode: 'dir_Create((char *) dirNameIndex, dirNameSize)').	].	successFlag ifTrue: [		self pop: 1.  "pop dirName; leave rcvr on stack"	].!primitiveDirectoryDelimitor	| ascii |	ascii _ self asciiDirectoryDelimiter.	self success: ((ascii >= 0) and: [ascii <= 255]).	successFlag ifTrue: [		self pop: 1.  "pop rcvr"		self push: (self fetchPointer: ascii ofObject: (self splObj: CharacterTable)).	].!primitiveDirectoryLookup	| index pathName pathNameIndex pathNameSize status entryName entryNameSize createDate modifiedDate dirFlag fileSize |	self var: 'entryName' declareC: 'char entryName[256]'.	index _ self stackIntegerValue: 0.	pathName _ self stackValue: 1.	self success: (self isBytes: pathName).	successFlag ifTrue: [		pathNameIndex _ pathName + BaseHeaderSize.		pathNameSize _ self lengthOf: pathName.	].	successFlag ifTrue: [		status _ self cCode:			'dir_Lookup(				(char *) pathNameIndex, pathNameSize, index,				entryName, &entryNameSize, &createDate, &modifiedDate,				&dirFlag, &fileSize)'.		status = DirNoMoreEntries ifTrue: [			"no more entries; return nil"			self pop: 3.  "pop pathName, index, rcvr"			self push: nilObj.			^ nil		].		status = DirBadPath ifTrue: [ ^ self primitiveFail ].  "bad path"	].	successFlag ifTrue: [		self pop: 3.  "pop pathName, index, rcvr"		self push:			(self makeDirEntryName: entryName size: entryNameSize				createDate: createDate modDate: modifiedDate				isDir: dirFlag fileSize: fileSize).	].!primitiveDirectorySetMacTypeAndCreator	| creatorString typeString fileName creatorStringIndex typeStringIndex fileNameIndex fileNameSize |	creatorString _ self stackTop.	typeString _ self stackValue: 1.	fileName _ self stackValue: 2.	self success: ((self isBytes: creatorString) and: [(self lengthOf: creatorString) = 4]).	self success: ((self isBytes: typeString) and: [(self lengthOf: typeString) = 4]).	self success: (self isBytes: fileName).	successFlag ifTrue: [		creatorStringIndex _ creatorString + BaseHeaderSize.		typeStringIndex _ typeString + BaseHeaderSize.		fileNameIndex _ fileName + BaseHeaderSize.		fileNameSize _ self lengthOf: fileName.	].	successFlag ifTrue: [		self success:			(self cCode: 'dir_SetMacFileTypeAndCreator(				(char *) fileNameIndex, fileNameSize,				(char *) typeStringIndex, (char *) creatorStringIndex)').	].	successFlag ifTrue: [		self pop: 3.  "pop filename, type, creator; leave rcvr on stack"	].!primitiveFileAtEnd	| file atEnd |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: self stackTop.	successFlag ifTrue: [ atEnd _ self sqFileAtEnd: file ].	successFlag ifTrue: [		self pop: 2.  "rcvr, file"		self pushBool: atEnd.	].!primitiveFileClose	| file |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: self stackTop.	successFlag ifTrue: [ self sqFileClose: file ].	successFlag ifTrue: [ self pop: 1  "pop file; leave rcvr on stack" ].!primitiveFileDelete	| namePointer nameIndex nameSize |	namePointer _ self stackTop.	self success: (self isBytes: namePointer).	successFlag ifTrue: [		nameIndex _ namePointer + BaseHeaderSize.		nameSize _ self lengthOf: namePointer.	].	successFlag ifTrue: [		self sqFileDeleteName: nameIndex Size: nameSize.	].	successFlag ifTrue: [ self pop: 1. "pop name, leave rcvr on stack" ].!primitiveFileGetPosition	| file position |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: (self stackTop).	successFlag ifTrue: [ position _ self sqFileGetPosition: file ].	successFlag ifTrue: [		self pop: 2.  "rcvr, file"		self pushInteger: position.	].!primitiveFileOpen	| writeFlag namePointer filePointer file nameIndex nameSize |	self var: 'file' declareC: 'SQFile *file'.	writeFlag _ self booleanValueOf: (self stackTop).	namePointer _ self stackValue: 1.	self success: (self isBytes: namePointer).	successFlag ifTrue: [		filePointer _ self instantiateClass: (self splObj: ClassByteArray)						   indexableSize: self fileRecordSize.		file _ self fileValueOf: filePointer.		nameIndex _ namePointer + BaseHeaderSize.		nameSize _ self lengthOf: namePointer.	].	successFlag ifTrue: [		self cCode: 'sqFileOpen(file, nameIndex, nameSize, writeFlag)'.	].	successFlag ifTrue: [		self pop: 3.  "rcvr, name, writeFlag"		self push: filePointer.	].!primitiveFileRead	| count startIndex array file byteSize arrayIndex bytesRead |	self var: 'file' declareC: 'SQFile *file'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	file			_ self fileValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [ byteSize _ 4 ]		ifFalse: [ byteSize _ 1 ].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= (self lengthOf: array)]).	successFlag ifTrue: [		arrayIndex _ array + BaseHeaderSize.		"Note: adjust startIndex for zero-origin indexing"		bytesRead _ self sqFile: file Read: (count * byteSize)						 Into: arrayIndex						   At: ((startIndex - 1) * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, file, array, startIndex, count"		self pushInteger: bytesRead // byteSize.  "push # of elements read"	].!primitiveFileRename	| oldNamePointer newNamePointer oldNameIndex oldNameSize newNameIndex newNameSize |	newNamePointer _ self stackTop.	oldNamePointer _ self stackValue: 1.	self success: (self isBytes: newNamePointer).	self success: (self isBytes: oldNamePointer).	successFlag ifTrue: [		newNameIndex _ newNamePointer + BaseHeaderSize.		newNameSize _ self lengthOf: newNamePointer.		oldNameIndex _ oldNamePointer + BaseHeaderSize.		oldNameSize _ self lengthOf: oldNamePointer.	].	successFlag ifTrue: [		self sqFileRenameOld: oldNameIndex Size: oldNameSize New: newNameIndex Size: newNameSize.	].	successFlag ifTrue: [		self pop: 2.  "pop new and old names, leave rcvr on stack"	].!primitiveFileSetPosition	| newPosition file |	self var: 'file' declareC: 'SQFile *file'.	newPosition _ self stackIntegerValue: 0.	file _ self fileValueOf: (self stackValue: 1).	successFlag ifTrue: [ self sqFile: file SetPosition: newPosition ].	successFlag ifTrue: [ self pop: 2 "pop position, file; leave rcvr on stack" ].!primitiveFileSize	| file size |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: (self stackTop).	successFlag ifTrue: [ size _ self sqFileSize: file ].	successFlag ifTrue: [		self pop: 2.  "rcvr, file"		self pushInteger: size.	].!primitiveFileWrite	| count startIndex array file byteSize arrayIndex bytesWritten |	self var: 'file' declareC: 'SQFile *file'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	file			_ self fileValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [ byteSize _ 4 ]		ifFalse: [ byteSize _ 1 ].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= (self lengthOf: array)]).	successFlag ifTrue: [		arrayIndex _ array + BaseHeaderSize.		"Note: adjust startIndex for zero-origin indexing"		bytesWritten _			self sqFile: file				Write: (count * byteSize)				From: arrayIndex At: ((startIndex - 1) * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, file, array, startIndex, count"		self pushInteger: bytesWritten // byteSize.  "push # of elements written"	].! !!Interpreter methodsFor: 'memory space primitives'!primitiveBytesLeft	"Reports bytes available at this moment. For more meaningful results, calls to this primitive should be preceeded by a full or incremental garbage collection."	self pop: 1.	self pushInteger: (self sizeOfFree: freeBlock).!primitiveFullGC	"Do a quick, incremental garbage collection and return the number of bytes available."	self pop: 1.	self incrementalGC.  "maximimize space for forwarding table"	self fullGC.	self pushInteger: (self sizeOfFree: freeBlock).!primitiveIncrementalGC	"Do a quick, incremental garbage collection and return the number of bytes immediately available. (Note: more space may be made available by doing a full garbage collection."	self pop: 1.	self incrementalGC.	self pushInteger: (self sizeOfFree: freeBlock).!primitiveLowSpaceSemaphore	"Register the low-space semaphore. If the argument is not a Semaphore, unregister the current low-space Semaphore."	| arg |	arg _ self popStack.	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [		self storePointer: TheLowSpaceSemaphore ofObject: specialObjectsOop withValue: arg.	] ifFalse: [		self storePointer: TheLowSpaceSemaphore ofObject: specialObjectsOop withValue: nilObj.	].!primitiveSignalAtBytesLeft	"Set the low-water mark for free space. When the free space falls below this level, the new and new: primitives fail and system attempts to allocate space (e.g., to create a method context) cause the low-space semaphore (if one is registered) to be signalled."	| bytes |	bytes _ self popInteger.	successFlag		ifTrue: [ lowSpaceThreshold _ bytes ]		ifFalse: [			lowSpaceThreshold _ 0.			self unPop: 1.		].! !!Interpreter methodsFor: 'sound primitives'!primitiveConstantFill	"Fill the receiver, which must be an indexable bytes or words objects, with the given integer value."	| fillValue rcvr rcvrIsBytes end i |	fillValue _ self stackIntegerValue: 0.	rcvr _ self stackValue: 1.	self success: (self isWordsOrBytes: rcvr).	rcvrIsBytes _ self isBytes: rcvr.	rcvrIsBytes ifTrue: [		self success: ((fillValue >= 0) and: [fillValue <= 255]).	].	successFlag ifTrue: [		end _ rcvr + (self sizeBitsOf: rcvr).		i _ rcvr + BaseHeaderSize.		rcvrIsBytes ifTrue: [			[i < end] whileTrue: [				self byteAt: i put: fillValue.				i _ i + 1.			].		] ifFalse: [			[i < end] whileTrue: [				self longAt: i put: fillValue.				i _ i + 4.			].		].		self pop: 1.  "pop fillValue; leave rcvr on stack"	].!primitiveShortAt	"Treat the receiver, which can be indexible by either bytes or words, as an array of signed 16-bit values. Return the contents of the given index. Note that the index specifies the i-th 16-bit entry, not the i-th byte or word."	| index rcvr sz addr value |	index _ self stackIntegerValue: 0.	rcvr _ self stackValue: 1.	self success: ((self isIntegerObject: rcvr) not and: [self isWordsOrBytes: rcvr]).	successFlag ifFalse: [ ^ nil ].	sz _ ((self sizeBitsOf: rcvr) - BaseHeaderSize) // 2.  "number of 16-bit fields"	self success: ((index >= 1) and: [index <= sz]).	successFlag ifTrue: [		addr _ rcvr + BaseHeaderSize + (2 * (index - 1)).		value _ self cCode: '*((short int *) addr)'.		self pop: 2.  "pop rcvr, index"		self pushInteger: value.  "push element value"	].!primitiveShortAtPut	"Treat the receiver, which can be indexible by either bytes or words, as an array of signed 16-bit values. Set the contents of the given index to the given value. Note that the index specifies the i-th 16-bit entry, not the i-th byte or word."	| index rcvr sz addr value |	value _ self stackIntegerValue: 0.	index _ self stackIntegerValue: 1.	rcvr _ self stackValue: 2.	self success: ((self isIntegerObject: rcvr) not and: [self isWordsOrBytes: rcvr]).	successFlag ifFalse: [ ^ nil ].	sz _ ((self sizeBitsOf: rcvr) - BaseHeaderSize) // 2.  "number of 16-bit fields"	self success: ((index >= 1) and: [index <= sz]).	self success: ((value >= -32768) and: [value <= 32767]).	successFlag ifTrue: [		addr _ rcvr + BaseHeaderSize + (2 * (index - 1)).		self cCode: '*((short int *) addr) = value'.		self pop: 2.  "pop index and value; leave rcvr on stack"	].!primitiveSoundAvailableSpace	"Returns the number of sample frames of available sound output buffer space."	| frames |	frames _ self cCode: 'snd_AvailableSpace()'.  "-1 if sound output not started"	self success: frames >= 0.	successFlag ifTrue: [		self pop: 1.  "rcvr"		self push: (self positive32BitIntegerFor: frames).	].!primitiveSoundPlaySamples	"Output a buffer's worth of sound samples."	| startIndex buf frameCount framesPlayed |	startIndex _ self stackIntegerValue: 0.	buf _ self stackValue: 1.	frameCount _ self stackIntegerValue: 2.	self success: (self isWords: buf).	self success: (		(startIndex >= 1) and:		[(startIndex + frameCount - 1) <= (self lengthOf: buf)]).	successFlag ifTrue: [		framesPlayed _			self cCode: 'snd_PlaySamplesFromAtLength(frameCount, buf + 4, startIndex - 1)'.		self success: framesPlayed >= 0.	].	successFlag ifTrue: [		self pop: 4.  "pop frameCount, buf, startIndex, rcvr"		self push: (self positive32BitIntegerFor: framesPlayed).	].!primitiveSoundPlaySilence	"Output a buffer's worth of silence. Returns the number of sample frames played."	| framesPlayed |	framesPlayed _ self cCode: 'snd_PlaySilence()'.  "-1 if sound output not started"	self success: framesPlayed >= 0.	successFlag ifTrue: [		self pop: 1.  "rcvr"		self push: (self positive32BitIntegerFor: framesPlayed).	].!primitiveSoundStart	"Start the double-buffered sound output with the given buffer size and sample rate."	| stereoFlag samplesPerSec bufFrames |	stereoFlag		_ self booleanValueOf: (self stackValue: 0).	samplesPerSec	_ self stackIntegerValue: 1.	bufFrames		_ self stackIntegerValue: 2.	successFlag ifTrue: [		self success: (self cCode: 'snd_Start(bufFrames, samplesPerSec, stereoFlag)').	].	successFlag ifTrue: [		self pop: 3.  "pop bufFrames, samplesPerSec, stereoFlag; leave rcvr on stack"	].!primitiveSoundStop	"Stop double-buffered sound output."	self cCode: 'snd_Stop()'.  "leave rcvr on stack"	! !!Interpreter methodsFor: 'other primitives'!primitiveClipboardText	"When called with a single string argument, post the string to the clipboard. When called with zero arguments, return a string containing the current clipboard contents."	| s sz |	argumentCount = 1 ifTrue: [		s _ self stackTop.		self success: (self fetchClassOf: s) = (self splObj: ClassString).		successFlag ifTrue: [			sz _ self stSizeOf:  s.			self clipboardWrite: sz From: (s + BaseHeaderSize) At: 0.			self pop: 1.  "pop s, leave rcvr on stack"		].	] ifFalse: [		sz _ self clipboardSize.		s _ self instantiateClass: (self splObj: ClassString)					  indexableSize: sz.		self clipboardRead: sz Into: (s + BaseHeaderSize) At: 0.		self pop: 1.  "rcvr"		self push: s.	].!primitiveExitToDebugger	self error: 'Exit to debugger at user request'.!primitiveFlushCache	"Clear the method cache."	| i |	1 to:  MethodCacheSize do: [ :i | methodCache at: i put: 0 ].	mcProbe _ 0.!primitiveImageName	"When called with a single string argument, record the string as the current image file name. When called with zero arguments, return a string containing the current image file name."	| s sz |	argumentCount = 1 ifTrue: [		s _ self stackTop.		self success: (self fetchClassOf: s) = (self splObj: ClassString).		successFlag ifTrue: [			sz _ self stSizeOf:  s.			self imageNamePut: (s + BaseHeaderSize) Length: sz.			self pop: 1.  "pop s, leave rcvr on stack"		].	] ifFalse: [		sz _ self imageNameSize.		s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.		self imageNameGet: (s + BaseHeaderSize) Length: sz.		self pop: 1.  "rcvr"		self push: s.	].!primitiveMillisecondClock	"Return the value of the millisecond clock as an integer. Note that the millisecond clock wraps around every so many days."	self pop: 1.  "pop rcvr"	self push: (self positive32BitIntegerFor: self ioMSecs).!primitiveNoop	"A placeholder for primitives that haven't been implemented or are being withdrawn gradually. Just absorbs any arguments and returns the receiver."	self pop: argumentCount.  "pop args, leave rcvr on stack"!primitiveQuit	self exit: 0.	self error: 'Execution should not continue after quit'.!primitiveReadJoystick	"Read an input word from the joystick with the given index."	| index |	index _ self stackIntegerValue: 0.	successFlag ifTrue: [		self pop: 2.  "index, rcvr"		self push: (self positive32BitIntegerFor: (self joystickRead: index)).	].!primitiveSecondsClock	"Return the number of seconds since January 1, 1901 as an integer."	self pop: 1.  "pop rcvr"	self push: (self positive32BitIntegerFor: self ioSeconds).!primitiveSignalAtMilliseconds	"Cause the time semaphore, if one has been registered, to be signalled when the millisecond clock is greater than or equal to the given tick value. A tick value of zero turns off timer interrupts."	| tick sema |	tick _ self popInteger.	sema _ self popStack.	successFlag ifTrue: [		(self fetchClassOf: sema) = (self splObj: ClassSemaphore) ifTrue: [			self storePointer: TheTimerSemaphore ofObject: specialObjectsOop withValue: sema.			nextWakeupTick _ tick.		] ifFalse: [			self storePointer: TheTimerSemaphore ofObject: specialObjectsOop withValue: nilObj.			nextWakeupTick _ 0.		].	] ifFalse: [		self unPop: 2.  "sema, tick"	].!primitiveSnapshot	| activeProc dataSize rcvr |	"save the state of the current process and save it on the scheduler queue"	self storeContextRegisters.	activeProc _		self fetchPointer: ActiveProcessIndex ofObject: self schedulerPointer.	self storePointer: SuspendedContextIndex		    ofObject: activeProc		  withValue: activeContext.	"compact memory and compute the size of the memory actually in use"	self incrementalGC.  "maximimize space for forwarding table"	self fullGC.	dataSize _ freeBlock - (self startOfMemory).	"Assume: all objects are below the start of the free block"	successFlag ifTrue: [		rcvr _ self popStack.  "pop rcvr"		self push: trueObj.		self writeImageFile: dataSize.		self pop: 1.  "pop true"	].	successFlag		ifTrue: [ self push: falseObj ]		ifFalse: [ self push: rcvr ].!primitiveSpecialObjectsOop	"Return the oop of the SpecialObjectsArray."	self pop: 1.	self push: specialObjectsOop.!primitiveVMPath	"Return a string containing the path name of VM's directory."	| s sz |	sz _ self vmPathSize.	s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.	self vmPathGet: (s + BaseHeaderSize) Length: sz.	self pop: 1.  "rcvr"	self push: s.! !!Interpreter methodsFor: 'debug printing'!cr	"For testing in Smalltalk, this method should be overridden in a subclass."	self printf: '\n'.!print: s	"For testing in Smalltalk, this method should be overridden in a subclass."	self var: #s declareC: 'char *s'.	self cCode: 'printf("%s", s)'.!printChar: aByte	"For testing in Smalltalk, this method should be overridden in a subclass."	self putchar: aByte.!printNum: n	"For testing in Smalltalk, this method should be overridden in a subclass."	self cCode: 'printf("%ld", (long) n)'.! !!Interpreter methodsFor: 'debug support'!allAccessibleObjectsOkay	"Ensure that all accessible objects in the heap are okay."	| oop |	oop _ self firstAccessibleObject.	[oop = nil] whileFalse: [		self okayFields: oop.		oop _ self accessibleObjectAfter: oop.	].!findClassOfMethod: meth forReceiver: rcvr	| currClass classDict classDictSize methodArray i done |	currClass _ self fetchClassOf: rcvr.	done _ false.	[done] whileFalse: [		classDict _ self fetchPointer: MessageDictionaryIndex ofObject: currClass.		classDictSize _ self fetchWordLengthOf: classDict.		methodArray _ self fetchPointer: MethodArrayIndex ofObject: classDict.		i _ 0.		[i < (classDictSize - SelectorStart)] whileTrue: [			meth = (self fetchPointer: i ofObject: methodArray) ifTrue: [ ^currClass ].			i _ i + 1.		].		currClass _ self fetchPointer: SuperclassIndex ofObject: currClass.		done _ currClass = nilObj.	].	^self fetchClassOf: rcvr    "method not found in superclass chain"!findSelectorOfMethod: meth forReceiver: rcvr	| currClass done classDict classDictSize methodArray i |	currClass _ self fetchClassOf: rcvr.	done _ false.	[done] whileFalse: [		classDict _ self fetchPointer: MessageDictionaryIndex ofObject: currClass.		classDictSize _ self fetchWordLengthOf: classDict.		methodArray _ self fetchPointer: MethodArrayIndex ofObject: classDict.		i _ 0.		[i <= (classDictSize - SelectorStart)] whileTrue: [			meth = (self fetchPointer: i ofObject: methodArray) ifTrue: [				^(self fetchPointer: i + SelectorStart ofObject: classDict)			].			i _ i + 1.		].		currClass _ self fetchPointer: SuperclassIndex ofObject: currClass.		done _ currClass = nilObj.	].	^self splObj: SelectorDoesNotUnderstand    "method not found in superclass chain"!okayActiveProcessStack	| cntxt |	cntxt _ activeContext.		[cntxt = nilObj] whileFalse: [		self okayFields: cntxt.		cntxt _ (self fetchPointer: SenderIndex ofObject: cntxt).	].!okayFields: oop	"If this is a pointers object, check that its fields are all okay oops."	| i fieldOop |	(oop = nil or: [oop = 0]) ifTrue: [ ^true ].	(self isIntegerObject: oop) ifTrue: [ ^true ].	self okayOop: oop.	self oopHasOkayClass: oop.	(self isPointers: oop) ifFalse: [ ^true ].	i _ (self lengthOf: oop) - 1.	[i >= 0] whileTrue: [		fieldOop _ self fetchPointer: i ofObject: oop.		(self isIntegerObject: fieldOop) ifFalse: [			self okayOop: fieldOop.			self oopHasOkayClass: fieldOop.		].		i _ i - 1.	].!okayInterpreterObjects	| i oopOrZero oop |	self okayFields: nilObj.	self okayFields: falseObj.	self okayFields: trueObj.	self okayFields: specialObjectsOop.	self okayFields: activeContext.	self okayFields: method.	self okayFields: receiver.	self okayFields: theHomeContext.	self okayFields: messageSelector.	self okayFields: newMethod.	1 to: MethodCacheEntries do: [ :i |		oopOrZero _ methodCache at: i.		oopOrZero = 0 ifFalse: [			self okayFields: (methodCache at: i).							"selector"			self okayFields: (methodCache at: i + MethodCacheEntries).		"class"			self okayFields: (methodCache at: i + (2 * MethodCacheEntries)).	"method"		].	].	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			self okayFields: oop.		].	].	self okayActiveProcessStack.!okayOop: oop	"Verify that the given oop is legitimate. Check address, header, and size but not class."	| sz type fmt |	"address and size checks"	(self isIntegerObject: oop) ifTrue: [ ^true ].	((0 < oop) & (oop < endOfMemory))		ifFalse: [ self error: 'oop is not a valid address' ].	((oop \\ 4) = 0)		ifFalse: [ self error: 'oop is not a word-aligned address' ].	sz _ self sizeBitsOf: oop.	(oop + sz) < endOfMemory		ifFalse: [ self error: 'oop size would make it extend beyond the end of memory' ].	"header type checks"	type _ self headerType: oop.	type = HeaderTypeFree		ifTrue:  [ self error: 'oop is a free chunk, not an object' ].	type = HeaderTypeShort ifTrue: [		(((self baseHeader: oop) >> 12) bitAnd: 16r1F) = 0			ifTrue:  [ self error: 'cannot have zero compact class field in a short header' ].	].	type = HeaderTypeClass ifTrue: [		((oop >= 4) and: [(self headerType: oop - 4) = type])			ifFalse: [ self error: 'class header word has wrong type' ].	].	type = HeaderTypeSizeAndClass ifTrue: [		((oop >= 8) and:		 [(self headerType: oop - 8) = type and:		 [(self headerType: oop - 4) = type]])			ifFalse: [ self error: 'class header word has wrong type' ].	].	"format check"	fmt _ self formatOf: oop.	((fmt = 4) | (fmt = 5) | (fmt = 7))		ifTrue:  [ self error: 'oop has an unknown format type' ].	"mark and root bit checks"	((self longAt: oop) bitAnd: 16r20000000) = 0		ifFalse: [ self error: 'unused header bit 30 is set; should be zero' ]."xxx	((self longAt: oop) bitAnd: MarkBit) = 0		ifFalse: [ self error: 'mark bit should not be set except during GC' ].xxx"	(((self longAt: oop) bitAnd: RootBit) = 1 and:	 [oop >= youngStart])		ifTrue: [ self error: 'root bit is set in a young object' ].	^true!oopHasOkayClass: oop	"Attempt to verify that the given oop has a reasonable behavior. The class must be a valid, non-integer oop and must not be nilObj. It must be a pointers object with three or more fields. Finally, the instance specification field of the behavior must match that of the instance."	| oopClass formatMask behaviorFormatBits oopFormatBits |	self okayOop: oop.	oopClass _ self fetchClassOf: oop.	(self isIntegerObject: oopClass)		ifTrue: [ self error: 'a SmallInteger is not a valid class or behavior' ].	self okayOop: oopClass.	((self isPointers: oopClass) and: [(self lengthOf: oopClass) >= 3])		ifFalse: [ self error: 'a class (behavior) must be a pointers object of size >= 3' ].	(self isBytes: oop)		ifTrue: [ formatMask _ 16rC00 ]  "ignore extra bytes size bits"		ifFalse: [ formatMask _ 16rF00 ].	behaviorFormatBits _ (self formatOfClass: oopClass) bitAnd: formatMask.	oopFormatBits _ (self baseHeader: oop) bitAnd: formatMask.	behaviorFormatBits = oopFormatBits		ifFalse: [ self error: 'object and its class (behavior) formats differ' ].	^true!printCallStack	| ctxt home methodClass methodSel |	ctxt _ activeContext.	[ctxt = nilObj] whileFalse: [		(self fetchClassOf: ctxt) = (self splObj: ClassBlockContext)			ifTrue: [ home _ self fetchPointer: HomeIndex ofObject: ctxt ]			ifFalse: [ home _ ctxt ].		methodClass _			self findClassOfMethod: (self fetchPointer: MethodIndex ofObject: home)					   forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		methodSel _			self findSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)						 forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		self printNum: ctxt.		self print: ' '.		ctxt = home ifFalse: [ self print: '[] in ' ].		self printNameOfClass: methodClass count: 5.		self print: '>'.		self printStringOf: methodSel.		self cr.		ctxt _ (self fetchPointer: SenderIndex ofObject: ctxt).	].!printNameOfClass: classOop count: cnt	"Details: The count argument is used to avoid a possible infinite recursion if classOop is a corrupted object."	cnt <= 0 ifTrue: [ ^ self print: 'bad class' ].	(self sizeBitsOf: classOop) = 16r20 ifTrue: [		self printNameOfClass: (self fetchPointer: 6 "thisClass" ofObject: classOop) count: cnt - 1.		self print: ' class'.	] ifFalse: [		self printStringOf: (self fetchPointer: 6 "name" ofObject: classOop).	].!printStringOf: oop	| fmt cnt i |	fmt _ self formatOf: oop.	fmt < 8 ifTrue: [ ^nil ].	cnt _ 100 min: (self lengthOf: oop).	i _ 0.	[i < cnt] whileTrue: [		self printChar: (self fetchByte: i ofObject: oop).		i _ i + 1.	].!reportContexts	| cntxt big small |	big _ 0.	cntxt _ freeLargeContexts.	[cntxt = NilContext] whileFalse: [		big _ big + 1.		cntxt _ self fetchWord: 0 ofObject: cntxt.	].	small _ 0.	cntxt _ freeSmallContexts.	[cntxt = NilContext] whileFalse: [		small _ small + 1.		cntxt _ self fetchWord: 0 ofObject: cntxt.	].	self print: 'Recycled contexts: '.	self printNum: small; print: ' small, '.	self printNum: big; print: ' large ('.	self printNum: (big * LargeContextSize) + (small * SmallContextSize).	self print: ' bytes)'.	self cr.! !!Interpreter class methodsFor: 'initialization'!initialize	"Interpreter initialize"	super initialize.  "initialize ObjectMemory constants"	self initializeAssociationIndex.	self initializeBytecodeTable.	self initializeCharacterIndex.	self initializeClassIndices.	self initializeContextIndices.	self initializeDirectoryLookupResultCodes.	self initializeMessageIndices.	self initializeMethodIndices.	self initializePointIndices.	self initializePrimitiveTable.	self initializeSchedulerIndices.	self initializeSmallIntegers.	self initializeStreamIndices.	MethodCacheEntries _ 512. 	MethodCacheMask _ MethodCacheEntries - 1.	(MethodCacheEntries bitAnd: MethodCacheMask) = 0		ifFalse: [ self error: 'MethodCacheEntries must be a power of two' ].	MethodCacheSize _ MethodCacheEntries * 3.	CacheProbeMax _ 3.!initializeAssociationIndex	ValueIndex _ 1!initializeBytecodeTable	"Interpreter initializeBytecodeTable"	"Note: This table will be used to generate a C switch statement."	BytecodeTable _ Array new: 256.	self table: BytecodeTable from:	#(		(  0  15 pushReceiverVariableBytecode)		( 16  31 pushTemporaryVariableBytecode)		( 32  63 pushLiteralConstantBytecode)		( 64  95 pushLiteralVariableBytecode)		( 96 103 storeAndPopReceiverVariableBytecode)		(104 111 storeAndPopTemporaryVariableBytecode)		(112 pushReceiverBytecode)		(113 pushConstantTrueBytecode)		(114 pushConstantFalseBytecode)		(115 pushConstantNilBytecode)		(116 pushConstantMinusOneBytecode)		(117 pushConstantZeroBytecode)		(118 pushConstantOneBytecode)		(119 pushConstantTwoBytecode)		(120 returnReceiver)		(121 returnTrue)		(122 returnFalse)		(123 returnNil)		(124 returnTopFromMethod)		(125 returnTopFromBlock)		(126 unknownBytecode)		(127 unknownBytecode)		(128 extendedPushBytecode)		(129 extendedStoreBytecode)		(130 extendedStoreAndPopBytecode)		(131 singleExtendedSendBytecode)		(132 doubleExtendedDoAnythingBytecode)		(133 singleExtendedSuperBytecode)		(134 secondExtendedSendBytecode)		(135 popStackBytecode)		(136 duplicateTopBytecode)		(137 pushActiveContextBytecode)		(138 143 unknownBytecode)		(144 151 shortUnconditionalJump)		(152 159 shortConditionalJump)		(160 167 longUnconditionalJump)		(168 171 longJumpIfTrue)		(172 175 longJumpIfFalse)		"176-191 were sendArithmeticSelectorBytecode"		(176 bytecodePrimAdd)		(177 bytecodePrimSubtract)		(178 bytecodePrimLessThan)		(179 bytecodePrimGreaterThan)		(180 bytecodePrimLessOrEqual)		(181 bytecodePrimGreaterOrEqual)		(182 bytecodePrimEqual)		(183 bytecodePrimNotEqual)		(184 bytecodePrimMultiply)		(185 bytecodePrimDivide)		(186 bytecodePrimMod)		(187 bytecodePrimMakePoint)		(188 bytecodePrimBitShift)		(189 bytecodePrimDiv)		(190 bytecodePrimBitAnd)		(191 bytecodePrimBitOr)			"192-207 were sendCommonSelectorBytecode"		(192 bytecodePrimAt)		(193 bytecodePrimAtPut)		(194 bytecodePrimSize)		(195 bytecodePrimNext)		(196 bytecodePrimNextPut)		(197 bytecodePrimAtEnd)		(198 bytecodePrimEquivalent)		(199 bytecodePrimClass)		(200 bytecodePrimBlockCopy)		(201 bytecodePrimValue)		(202 bytecodePrimValueWithArg)		(203 bytecodePrimDo)		(204 bytecodePrimNew)		(205 bytecodePrimNewWithArg)		(206 bytecodePrimPointX)		(207 bytecodePrimPointY)		(208 255 sendLiteralSelectorBytecode)	).!initializeCharacterIndex	CharacterValueIndex _ 0!initializeClassIndices	"Class Class"	SuperclassIndex _ 0.	MessageDictionaryIndex _ 1.	InstanceSpecificationIndex _ 2.	"Fields of a message dictionary"	MethodArrayIndex _ 1.	SelectorStart _ 2!initializeContextIndices	"Class MethodContext"	SenderIndex _ 0.	InstructionPointerIndex _ 1.	StackPointerIndex _ 2.	MethodIndex _ 3.	ReceiverIndex _ 5.	TempFrameStart _ 6.	"Class BlockContext"	CallerIndex _ 0.	BlockArgumentCountIndex _ 3.	InitialIPIndex _ 4.	HomeIndex _ 5!initializeDirectoryLookupResultCodes	DirEntryFound _ 0.	DirNoMoreEntries _ 1.	DirBadPath _ 2.!initializeMessageIndices	MessageSelectorIndex _ 0.	MessageArgumentsIndex _ 1.	MessageSize _ 2!initializeMethodIndices	"Class CompiledMethod"	HeaderIndex _ 0.	LiteralStart _ 1!initializePointIndices	XIndex _ 0.	YIndex _ 1!initializePrimitiveTable	"Interpreter initializePrimitiveTable"	"Note: This table will be used to generate a C switch statement."	PrimitiveTable _ Array new: 256.	self table: PrimitiveTable from: 	#(		"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 59 primitiveFail)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveFail)		(118 primitiveFail)		(119 primitiveFail)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)				"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		(126 primitiveFail)		(127 primitiveFail)		"AppleSmalltalk Primitives Start Here"		"Apple Miscellaneous Primitives (128-149)"		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 149 primitiveFail)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveFail)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 199 primitiveFail)		"Unimplemented Primitives (200-249)"		(200 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveFail)		(255 primitiveFail)	).!initializeSchedulerIndices	"Class ProcessorScheduler"	ProcessListsIndex _ 0.	ActiveProcessIndex _ 1.	"Class LinkedList"	FirstLinkIndex _ 0.	LastLinkIndex _ 1.	"Class Semaphore"	ExcessSignalsIndex _ 2.	"Class Link"	NextLinkIndex _ 0.	"Class Process"	SuspendedContextIndex _ 1.	PriorityIndex _ 2.	MyListIndex _ 3!initializeSmallIntegers	"SmallIntegers"	ConstMinusOne _ Interpreter new integerObjectOf: -1.	ConstZero _ Interpreter new integerObjectOf: 0.	ConstOne _ Interpreter new integerObjectOf: 1.	ConstTwo _ Interpreter new integerObjectOf: 2!initializeStreamIndices	StreamArrayIndex _ 0.	StreamIndexIndex _ 1.	StreamReadLimitIndex _ 2.	StreamWriteLimitIndex _ 3.!table: anArray from: specArray	"SpecArray is an array of either (index selector) or (index1 index2 selector)."	| contiguous |	contiguous _ 0.	specArray do: [ :spec |		(spec at: 1) = contiguous ifFalse: [ self error: 'Non-contiguous table entry' ].		spec size = 2 ifTrue: [			anArray at: ((spec at: 1) + 1) put: (spec at: 2).			contiguous _ contiguous + 1.		] ifFalse: [			(spec at: 1) to: (spec at: 2) do: [ :i | anArray at: (i + 1) put: (spec at: 3) ].			contiguous _ contiguous + ((spec at: 2) - (spec at: 1)) + 1.		].	].! !!Interpreter class methodsFor: 'constants'!bytecodeTable	^ BytecodeTable!primitiveTable	^ PrimitiveTable! !!Interpreter class methodsFor: 'translation'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'methodCache'		declareC: 'int methodCache[', (MethodCacheSize + 1) printString, ']'.	aCCodeGenerator var: 'currentBytecode'		declareC: 'unsigned char currentBytecode'.!patchInterp: fileName	"Interpreter patchInterp: 'Squeak VM PPC'"	"This will patch out the unneccesary range check (a compare	 and branch) in the inner interpreter dispatch loop."	"NOTE: You must edit in the Interpeter file name, and the	 number of instructions (delta) to count back to find the compare	 and branch that we want to get rid of."	| delta f code len remnant i |	delta _ 6.	f _ FileStream fileNamed: fileName.	f binary.	code _ Bitmap new: (len _ f size) // 4.	f nextInto: code.	remnant _ f next: len - (code size * 4).	i _ 0.	["Look for a BCTR instruction"	(i _ code indexOf: 16r4E800420 startingAt: i + 1 ifAbsent: [0]) > 0] whileTrue: [		"Look for a CMPLWI FF, 6 instrs back"	       ((code at: i - delta) bitAnd: 16rFFE0FFFF) = 16r280000FF ifTrue: [	       	"Copy dispatch instrs back over the compare"			PopUpMenu notify: 'Patching at ', i hex.			0 to: delta - 2 do: [ :j |				code at: (i - delta) + j put: (code at: (i - delta) + j + 2).			].		].	].	f position: 0; nextPutAll: code; nextPutAll: remnant.	f close.!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'InterpTest.c' doInlining: true.		Smalltalk beep]"	| cg |	BitBltSimulation initialize.	Interpreter initialize.	ObjectMemory initialize.	cg _ CCodeGenerator new initialize.	cg addClass: BitBltSimulation.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	BitBltSimulation declareCVarsIn: cg.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !InterpreterSimulator comment:'This class defines basic memory access and primitive simulation so that the Interpreter can run simulated in the Squeak environment.  It also defines a number of handy object viewing methods to facilitate pawing around in the object memory.To see the thing actually run, you could (after backing up this image and changes), execute	(InterpreterSimulator new openOn: Smalltalk imageName) testand be patient both to wait for things to happen, and to accept various things that may go wrong depending on how large or unusual your image may be.  We usually do this with a small and simple benchmark image.'!!InterpreterSimulator methodsFor: 'initialization'!close  "close any files that ST may have opened"	filesOpen do: [:f | f setToEnd; close]!initialize	"Initialize the InterpreterSimulator when running the interpreter inside Smalltalk. The primary responsibility of this method is to allocate Smalltalk Arrays for variables that will be declared as statically-allocated global arrays in the translated code."	"initialize class variables"	ObjectMemory initialize.	Interpreter initialize.	methodCache _ Array new: MethodCacheSize.	rootTable _ Array new: RootTableSize.	remapBuffer _ Array new: RemapBufferSize.	"initialize InterpreterSimulator variables used for debugging"	byteCount _ 0.	sendCount _ 0.	traceOn _ true.	myBitBlt _ BitBltSimulation new setInterpreter: self.	displayForm _ nil.  "displayForm is created in response to primitiveBeDisplay"	filesOpen _ OrderedCollection new.!nextLongFrom: aStream	"Read a 32-bit quantity from the given (binary) stream."	| bytes |	bytes _ aStream nextInto: (ByteArray new: 4).	^ Integer		byte1: (bytes at: 4)		byte2: (bytes at: 3)		byte3: (bytes at: 2)		byte4: (bytes at: 1)!openOn: fileName	"(InterpreterSimulator new openOn: 'clonex.image') test"	self openOn: fileName extraMemory: 500000.!openOn: fileName extraMemory: extraBytes	"InterpreterSimulator new openOn: 'clone.im' extraMemory: 100000"	| f version headerSize count oldBaseAddr bytesToShift |	"open image file and read the header"	f _ FileStream oldFileNamed: fileName.	imageName _ f fullName.	f binary; readOnly.	version _ self nextLongFrom: f.  "current version: 6501"	headerSize _ self nextLongFrom: f.	endOfMemory _ self nextLongFrom: f.  "first unused location in heap"	oldBaseAddr _ self nextLongFrom: f.  "object memory base address of image"	specialObjectsOop _ self nextLongFrom: f.	lastHash _ 999.  "Should be loaded from, and saved to the image header"	"allocate interpreter memory"	memoryLimit _ endOfMemory + extraBytes.	"read in the image"	f position: headerSize.	memory _ Bitmap new: memoryLimit // 4.	count _ f readInto: memory startingAt: 1 count: endOfMemory // 4.	count ~= (endOfMemory // 4) ifTrue: [self halt].	f close.	self initialize.	bytesToShift _ 0 - oldBaseAddr.  "adjust pointers for zero base address"	endOfMemory _ endOfMemory.	self initializeInterpreter: bytesToShift.	checkAssertions _ false.!startOfMemory	"Return the start of object memory."	^ 0! !!InterpreterSimulator methodsFor: 'testing'!findNewMethodInClass: class"	| cName tab |	traceOn ifTrue:		[cName _ (self sizeBitsOf: class) = 16r20			ifTrue: ['class ' , (self nameOfClass: (self fetchPointer: 6 ofObject: class))]			ifFalse: [(self nameOfClass: class)].		tab _ String new: (self stackDepthOf: activeContext) withAll: $|.		self cr; print: tab , cName , '>>' , (self stringOf: messageSelector)].	(self stackDepthOf: activeContext) > 40 ifTrue: [self halt].	Sensor yellowButtonPressed ifTrue: [self halt]."	sendCount _ sendCount + 1.	super findNewMethodInClass: class.!profile: nBytecodes	"(InterpreterSimulator new openOn: 'clonex.image') profile: 60000"	Transcript clear.	byteCount _ 0.	MessageTally spyOn: [		self internalizeIPandSP.		[byteCount < nBytecodes] whileTrue: [			currentBytecode _ self fetchByte.			self dispatchOn: currentBytecode in: BytecodeTable.			byteCount _ byteCount + 1.		].		self externalizeIPandSP.	].!profileSends: nBytecodes	"(InterpreterSimulator new openOn: 'clonex.image') profileSends: 5000"	Transcript clear.	byteCount _ 0.	MessageTally tallySendsTo: self inBlock: [		self internalizeIPandSP.		[byteCount < nBytecodes] whileTrue: [			currentBytecode _ self fetchByte.			self dispatchOn: currentBytecode in: BytecodeTable.			byteCount _ byteCount + 1.		].		self externalizeIPandSP.	] showTree: true.!test	Transcript clear.	byteCount _ 0.	self internalizeIPandSP.	[true] whileTrue: [		currentBytecode _ self fetchByte.		self dispatchOn: currentBytecode in: BytecodeTable.		byteCount _ byteCount + 1.	].	self externalizeIPandSP.!testBecome	"Become some young things.  AA testBecome    "	| array list1 list2 p1 p2 p3 p4 |	array _ self splObj: ClassArray.	list1 _ self instantiateClass: array indexableSize: 2.	list2 _ self instantiateClass: array indexableSize: 2.	p1 _ self instantiateClass: (self splObj: ClassPoint) indexableSize: 0.	self push: p1.	self storePointer: 0 ofObject: list1 withValue: p1.	p2 _ self instantiateClass: (self splObj: ClassPoint) indexableSize: 0.	self push: p2.	self storePointer: 1 ofObject: list1 withValue: p2.	p3 _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	self push: p3.	self storePointer: 0 ofObject: list2 withValue: p3.	p4 _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	self push: p4.	self storePointer: 1 ofObject: list2 withValue: p4.	(self become: list1 with: list2) ifFalse: [self error: 'failed'].	self popStack = p2 ifFalse: [self halt].	self popStack = p1 ifFalse: [self halt].	self popStack = p4 ifFalse: [self halt].	self popStack = p3 ifFalse: [self halt].	(self fetchPointer: 0 ofObject: list1) = p3 ifFalse: [self halt].	(self fetchPointer: 1 ofObject: list1) = p4 ifFalse: [self halt].	(self fetchPointer: 0 ofObject: list2) = p1 ifFalse: [self halt].	(self fetchPointer: 1 ofObject: list2) = p2 ifFalse: [self halt].!validate	| oop prev |	Transcript show: 'Validating...'.	oop _ self firstObject.	[oop < endOfMemory] whileFalse: [		self validate: oop.		prev _ oop.  "look here if debugging prev obj overlapping this one"		oop _ self objectAfter: oop.	].	Transcript show: 'done.'; cr!validate: oop	| header type cc sz fmt nextChunk | 	header _ self longAt: oop.	type _ header bitAnd: 3.	type = 2 ifFalse: [type = (self rightType: header) ifFalse: [self halt]].	sz _ (header >> 2) bitAnd: 16r3F.	(sz = 1) & (type = 3) ifTrue: [self halt].	"object only 4 bytes long"	(sz = 1) & (type = 0) ifTrue: [self halt].	"object only 4 bytes long"	(self isFreeObject: oop)		ifTrue: [ nextChunk _ oop + (self sizeOfFree: oop) ]		ifFalse: [  nextChunk _ oop + (self sizeBitsOf: oop) ].	nextChunk > endOfMemory		ifTrue: [oop = endOfMemory ifFalse: [self halt]].	(self headerType: nextChunk) = 0 ifTrue: [		(self headerType: (nextChunk + 8)) = 0 ifFalse: [self halt]].	(self headerType: nextChunk) = 1 ifTrue: [		(self headerType: (nextChunk + 4)) = 1 ifFalse: [self halt]].	type = 2 ifTrue:		["free block" ^ self].	fmt _ (header >> 8) bitAnd: 16rF.	cc _ (header >> 12) bitAnd: 31.	cc > 15 ifTrue: [self halt].	type = 0 ifTrue:		["three-word header"		((self longAt: oop-4) bitAnd: 3) = type ifFalse: [self halt].		((self longAt: oop-8) bitAnd: 3) = type ifFalse: [self halt].		((self longAt: oop-4) = type) ifTrue: [self halt].	"Class word is 0"		sz = 0 ifFalse: [self halt]].	type = 1 ifTrue:		["two-word header"		((self longAt: oop-4) bitAnd: 3) = type ifFalse: [self halt].		cc > 0 ifTrue: [sz = 1 ifFalse: [self halt]].		sz = 0 ifTrue: [self halt]].	type = 3 ifTrue:		["one-word header"		cc = 0 ifTrue: [self halt].		sz <= 1 ifTrue: [self halt]].	fmt = 0 ifTrue: [self halt].	fmt = 4 ifTrue: [self halt].	fmt = 5 ifTrue: [self halt].	fmt = 7 ifTrue: [self halt].	fmt >= 12 ifTrue:		["CompiledMethod -- check for integer header"		(self isIntegerObject: (self longAt: oop + 4)) ifFalse: [self halt]].!validateActiveContext	self validateOopsIn: activeContext.	"debug -- test if messed up"!validateOopsIn: object	| fieldPtr limit former header | 	"for each oop in me see if it is legal"	fieldPtr _ object + BaseHeaderSize.	"first field"	limit _ object + (self lastPointerOf: object).	"a good field"	[fieldPtr > limit] whileFalse: [		former _ self longAt: fieldPtr.		self validOop: former.		fieldPtr _ fieldPtr + 4].	"class"	header _ self baseHeader: object.	(header bitAnd: 16r1F000 "compact class bits") = 0 ifTrue: [			former _ (self classHeader: object) bitAnd: 16rFFFFFFFC.		self validOop: former].!validOop: oop	"halt if invalid active object"	(oop bitAnd: 1) = 1 ifTrue: [^ self].	(oop bitAnd: 3) = 0 ifFalse: [self halt].	oop >= endOfMemory ifTrue: [self halt].	"could test if within the first large freeblock"	(self longAt: oop) = 4 ifTrue: [self halt].	(self headerType: oop) = 2 ifTrue: [self halt].	"free object"! !!InterpreterSimulator methodsFor: 'debug printing'!cr	traceOn ifTrue: [ Transcript cr; endEntry ].!print: s	traceOn ifTrue: [ Transcript show: s ]!printChar: aByte	traceOn ifTrue: [ Transcript nextPut: aByte asCharacter ].!printNum: anInteger	traceOn ifTrue: [ Transcript show: anInteger printString ].! !!InterpreterSimulator methodsFor: 'debug support'!charsOfLong: long	^ (4 to: 1 by: -1) collect:		[:i | ((long digitAt: i) between: 14 and: 126)					ifTrue: [(long digitAt: i) asCharacter]					ifFalse: [$?]]!classAndSelectorOfMethod: meth forReceiver: rcvr	| mClass dict length methodArray |	mClass _ self fetchClassOf: rcvr.	[dict _ self fetchPointer: MessageDictionaryIndex ofObject: mClass.	length _ self fetchWordLengthOf: dict.	methodArray _ self fetchPointer: MethodArrayIndex ofObject: dict.	0 to: length-SelectorStart-1 do: 		[:index | 		meth = (self fetchPointer: index ofObject: methodArray) 			ifTrue: [^ Array				with: mClass				with: (self fetchPointer: index + SelectorStart ofObject: dict)]].	mClass _ self fetchPointer: SuperclassIndex ofObject: mClass.	mClass = nilObj]		whileFalse: [].	^ Array		with: (self fetchClassOf: rcvr)		with: (self splObj: SelectorDoesNotUnderstand)!compactClassAt: ccIndex	"Index must be between 1 and compactClassArray size. (A zero compact class index in the base header indicate that the class is in the class header word.)"	| classArray |	classArray _ self fetchPointer: CompactClasses ofObject: specialObjectsOop.	^ self fetchPointer: (ccIndex - 1) ofObject: classArray!dumpHeader: hdr	| cc |	^ String streamContents:		[:strm |		strm nextPutAll: '<cc=', (cc_ (hdr >> 12) bitAnd: 16r1F) hex.			cc > 0 ifTrue:				[strm nextPutAll: ':' , (self nameOfClass: (self compactClassAt: cc))].			strm nextPutAll: '>'.		strm nextPutAll: '<ft=', ((hdr bitShift: -8) bitAnd: 16rF) hex , '>'.		strm nextPutAll: '<sz=', (hdr bitAnd: 16rFC) hex , '>'.		strm nextPutAll: '<hdr=', (#(big class gcMark short) at: (hdr bitAnd: 3) +1) , '>'.		]!dumpMethodHeader: hdr	^ String streamContents:		[:strm |		strm nextPutAll: '<nArgs=', ((hdr >> 25) bitAnd: 16r1F) printString , '>'.		strm nextPutAll: '<nTemps=', ((hdr >> 19) bitAnd: 16r3F) printString , '>'.		strm nextPutAll: '<lgCtxt=', ((hdr >> 18) bitAnd: 16r1) printString , '>'.		strm nextPutAll: '<nLits=', ((hdr >> 10) bitAnd: 16rFF) printString , '>'.		strm nextPutAll: '<prim=', ((hdr >> 1) bitAnd: 16r1FF) printString , '>'.		]!headerStart: oop	^ (self extraHeaderBytes: oop) negated!hexDump100: oop	| byteSize val |	^ String streamContents:		[:strm |		byteSize _ 256.		(self headerStart: oop) to: byteSize by: 4 do:			[:a | val _ self longAt: oop+a.			strm cr; nextPutAll: (oop+a) hex8; space; space; 				nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8;				space; space.			strm nextPutAll: (self charsOfLong: val).			strm space; space; nextPutAll: (oop+a) printString]]!hexDump: oop	| byteSize val |	(self isIntegerObject: oop) ifTrue: [^ self shortPrint: oop].	^ String streamContents:		[:strm |		byteSize _ 256 min: (self sizeBitsOf: oop)-4.		(self headerStart: oop) to: byteSize by: 4 do:			[:a | val _ self longAt: oop+a.			strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8;				space; space.			a=0				ifTrue: [strm nextPutAll: (self dumpHeader: val)]				ifFalse: [strm nextPutAll: (self charsOfLong: val)]]]!longPrint: oop	| lastPtr val lastLong hdrType prevVal |	(self isIntegerObject: oop) ifTrue: [^ self shortPrint: oop].	^ String streamContents:		[:strm |		lastPtr _ 256 min: (self lastPointerOf: oop).		hdrType _ self headerType: oop.		hdrType = 2 ifTrue: [lastPtr _ 0].		prevVal _ 0.		(self headerStart: oop) to: lastPtr by: 4 do:			[:a | val _ self longAt: oop+a.			(a > 0 and: [(val = prevVal) & (a ~= lastPtr)])			ifTrue:			[prevVal = (self longAt: oop+a-8) ifFalse: [strm cr; nextPutAll: '        ...etc...']]			ifFalse:			[strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8; space; space.			a=-8 ifTrue: [strm nextPutAll: 'size = ' , (val - hdrType) hex].			a=-4 ifTrue: [strm nextPutAll: '<' , (self nameOfClass: (val - hdrType)) , '>'].			a=0 ifTrue: [strm cr; tab; nextPutAll: (self dumpHeader: val)].			a>0 ifTrue: [strm nextPutAll: (self shortPrint: val)].			a=4 ifTrue: [(self fetchClassOf: oop) = (self splObj: ClassCompiledMethod) ifTrue:							[strm cr; tab; nextPutAll: (self dumpMethodHeader: val)]]].			prevVal _ val].		lastLong _ 256 min: (self sizeBitsOf: oop) - 4.		hdrType = 2			ifTrue: ["free" strm cr; nextPutAll: (oop+(self longAt: oop)-2) hex;				space; space; nextPutAll: (oop+(self longAt: oop)-2) printString]			ifFalse: [lastPtr+4 to: lastLong by: 4 do:				[:a | val _ self longAt: oop+a.				strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 					space; space; space.				strm nextPutAll: val hex8; space; space;						nextPutAll: (self charsOfLong: val)]].	]!nameOfClass: classOop	(self sizeBitsOf: classOop) = 16r20 ifTrue:		[^ (self nameOfClass:				(self fetchPointer: 6 "thisClass" ofObject: classOop)) , ' class'].	^ self stringOf: (self fetchPointer: 6 "name" ofObject: classOop)!printStack	| ctxt classAndSel home |	ctxt _ activeContext.	^ String streamContents:		[:strm |			[home _ (self fetchClassOf: ctxt) = (self splObj: ClassBlockContext)				ifTrue: [self fetchPointer: HomeIndex ofObject: ctxt]				ifFalse: [ctxt].			classAndSel _ self				classAndSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)				forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).			strm cr; nextPutAll: ctxt hex8.			ctxt = home ifFalse: [strm nextPutAll: ' [] in'].			strm space; nextPutAll: (self nameOfClass: classAndSel first).			strm nextPutAll: '>>'; nextPutAll: (self shortPrint: classAndSel last).			(ctxt _ (self fetchPointer: SenderIndex ofObject: ctxt)) = nilObj]				whileFalse: [].		]!shortPrint: oop	| name classOop |	(self isIntegerObject: oop) ifTrue: [^ '=' , (self integerValueOf: oop) printString , ' (' , (self integerValueOf: oop) hex , ')'].	classOop _ self fetchClassOf: oop.	(self sizeBitsOf: classOop) =16r20 ifTrue: [^ 'class ' , (self nameOfClass: oop)].	name _ self nameOfClass: classOop.	name size = 0 ifTrue: [name _ '??'].	name = 'String' ifTrue: [^ (self stringOf: oop) printString].	name = 'Symbol' ifTrue: [^ '#' , (self stringOf: oop)].	name = 'Character' ifTrue: [^ '=' ,			(Character value: (self integerValueOf: (self fetchPointer: 0 ofObject: oop))) printString].	name = 'UndefinedObject' ifTrue: [^ 'nil'].	name = 'False' ifTrue: [^ 'false'].	name = 'True' ifTrue: [^ 'true'].	name = 'Float' ifTrue: [^ '=' , (self floatValueOf: oop) printString].	name = 'Association' ifTrue: [^ '(' ,				(self shortPrint: (self longAt: oop + BaseHeaderSize)) ,				' -> ' ,				(self longAt: oop + BaseHeaderSize + 4) hex8 , ')'].	('AEIOU' includes: name first)		ifTrue: [^ 'an ' , name]		ifFalse: [^ 'a ' , name]!stringOf: oop	| size long nLongs chars |	^ String streamContents:		[:strm |		size _ 100 min: (self stSizeOf: oop).		nLongs _ size-1//4+1.		1 to: nLongs do:			[:i | long _ self longAt: oop + BaseHeaderSize + (i-1*4).			chars _ self charsOfLong: long.			strm nextPutAll: (i=nLongs							ifTrue: [chars copyFrom: 1 to: size-1\\4+1]							ifFalse: [chars])]]! !!InterpreterSimulator methodsFor: 'interpreter shell'!fetchByte	^ self byteAt: (localIP _ localIP + 1).!isIntegerValue: valueWord 	^ valueWord >= 16r-40000000 and: [valueWord <= 16r3FFFFFFF]! !!InterpreterSimulator methodsFor: 'translation support'!cCode: codeString	"For translation only; noop when running in Smalltalk."!dispatchOn: anInteger in: selectorArray	"Simulate a case statement via selector table lookup.	The given integer must be between 0 and selectorArray size-1, inclusive.	For speed, no range test is done, since it is done by the at: operation."	"assert: (anInteger >= 0) | (anInteger < selectorArray size)"	self perform: (selectorArray at: (anInteger + 1)).!returnTypeC: typeString	"For translation only; noop when running in Smalltalk."!var: varSymbol declareC: declString	"For translation only; noop when running in Smalltalk."! !!InterpreterSimulator methodsFor: 'I/O primitives'!ioProcessEvents!primitiveBeCursor	"Take note of the current cursor"	| cursorObj bitsObj offsetObj ourCursor |	cursorObj _ self stackTop.	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 4]).	successFlag ifTrue:		[bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj.		ourCursor _ Cursor			extent: (self fetchInteger: 1 ofObject: cursorObj)@(self fetchInteger: 2 ofObject: cursorObj)			fromArray: ((1 to: 16) collect: [:i |					((self fetchWord: i-1 ofObject: bitsObj) >> 16) bitAnd: 16rFFFF])			offset: (self fetchInteger: 0 ofObject: offsetObj)@(self fetchInteger: 1 ofObject: offsetObj)].	successFlag		ifTrue: [ourCursor show]		ifFalse: [self primitiveFail].!primitiveBeDisplay	"Extended to create a scratch Form for use by showDisplayBits."	| rcvr destWidth destHeight destDepth |	rcvr _ self stackTop.	self success: ((self isPointers: rcvr) and: [(self lengthOf: rcvr) >= 4]).	successFlag ifTrue: [		destWidth _ self fetchInteger: 1 ofObject: rcvr.		destHeight _ self fetchInteger: 2 ofObject: rcvr.		destDepth _ self fetchInteger: 3 ofObject: rcvr.	].	successFlag ifTrue: [		"create a scratch form the same size as Smalltalk displayObj"		displayForm _ Form extent: destWidth @ destHeight							depth: destDepth.	].	super primitiveBeDisplay.!primitiveKbdNext	self pop: 1.	Sensor keyboardPressed		ifTrue: [self pushInteger: Sensor keyboardPeek asciiValue]		ifFalse: [self push: nilObj]!primitiveKbdPeek	self pop: 1.	Sensor keyboardPressed		ifTrue: [self pushInteger: Sensor keyboardPeek asciiValue]		ifFalse: [self push: nilObj]!primitiveMouseButtons	| rcvr relPt buttons |	self pop: 1.	buttons _ 0.	Sensor redButtonPressed ifTrue: [buttons _ buttons + 4].	Sensor yellowButtonPressed ifTrue: [buttons _ buttons + 2].	Sensor blueButtonPressed ifTrue: [buttons _ buttons + 1].	self pushInteger: buttons!primitiveMousePoint	| relPt |	self pop: 1.	displayForm == nil		ifTrue: [self push: (self makePointwithxValue: 99 yValue: 66)]		ifFalse: [relPt _ Sensor cursorPoint - (Display extent - displayForm extent - (10@10)).				self push: (self makePointwithxValue: relPt x yValue: relPt y)]!primitiveScreenSize  "Dummied for now"	self pop: 1.	self push: (self makePointwithxValue: 640 yValue: 480).!showDisplayBits	| displayObj destBits sRaster dRaster destDepth pixPerWord srcWord destWord |	displayObj _ self splObj: TheDisplay.	destBits _ self fetchPointer: 0 ofObject: displayObj.	destDepth _ self fetchInteger: 3 ofObject: displayObj.	pixPerWord _ 32 // destDepth.	sRaster _ displayForm width + (pixPerWord-1) // pixPerWord * 4.	dRaster _ sRaster // 4.	myBitBlt affectedTop to: myBitBlt affectedBottom - 1 do:		[:y | 		srcWord _ destBits + 4 + (y * sRaster).		destWord _ y*dRaster.		1 to: dRaster do: 			[:i | displayForm bits at: destWord + i put: (self longAt: srcWord).			srcWord _ srcWord + 4]].	Display border: ((displayForm boundingBox expandBy: 2)						translateBy: self displayLocation) width: 2.	displayForm displayAt: self displayLocation! !!InterpreterSimulator methodsFor: 'I/O primitives support'!copyBits	^ myBitBlt copyBits!displayLocation	^ Display extent - displayForm extent - (10@10)!drawLoopX: xDelta Y: yDelta	^ myBitBlt drawLoopX: xDelta Y: yDelta!ioMSecs	"Return the value of the millisecond clock."	^ Time millisecondClockValue!ioProcessEventsEveryMSecs: mSecs	"Noop during simulation."!loadBitBltFrom: bbObj	^ myBitBlt loadBitBltFrom: bbObj!loadScannerFrom: bbObj	start: start stop: stop string: string rightX: rightX	stopArray: stopArray displayFlag: displayFlag	^ myBitBlt loadScannerFrom: bbObj		start: start stop: stop string: string rightX: rightX		stopArray: stopArray displayFlag: displayFlag!scanCharacters	^ myBitBlt scanCharacters!stopReason	^ myBitBlt stopReason!targetForm	^ myBitBlt targetForm! !!InterpreterSimulator methodsFor: 'file primitives'!asciiDirectoryDelimiter	^ FileDirectory pathNameDelimiter asciiValue!fileValueOf: integerPointer	"Convert the (integer) fileID to the actual fileStream it uses"	self success: (self isIntegerObject: integerPointer).	successFlag		ifTrue: [^ filesOpen at: (self integerValueOf: integerPointer)]		ifFalse: [^ nil]!primitiveFileDelete	| namePointer |	namePointer _ self stackTop.	self success: (self isBytes: namePointer).	self success: (FileDirectory includesKey: (self stringOf: namePointer)).	successFlag ifTrue: [		FileDirectory removeKey: (self stringOf: namePointer) ifAbsent: [].	].	successFlag ifTrue: [		self pop: 1.  "fileName; leave rcvr on stack"	].!primitiveFileOpen	| namePointer writeFlag fileName |	writeFlag _ self booleanValueOf: self stackTop.	namePointer _ self stackValue: 1.	self success: (self isBytes: namePointer).	successFlag ifTrue:		[fileName _ self stringOf: namePointer.		filesOpen addLast: (writeFlag			ifTrue: [(FileStream fileNamed: fileName) binary]			ifFalse: [(FileDirectory default includesKey: fileName)				ifTrue: [(FileStream oldFileNamed: fileName) readOnly; binary]				ifFalse: [^ self primitiveFail]]).		self pop: 3.  "rcvr, name, write"		self pushInteger: filesOpen size]!primitiveFileRename	| oldNamePointer newNamePointer f |	oldNamePointer _ self stackTop.	newNamePointer _ self stackValue: 1.	self success: (self isBytes: oldNamePointer).	self success: (self isBytes: newNamePointer).	self success: (FileDirectory includesKey: (self stringOf: oldNamePointer)).	self success: (FileDirectory includesKey: (self stringOf: newNamePointer)) not.	successFlag ifTrue: [		f _ FileStream oldFileNamed: (self stringOf: oldNamePointer).		f rename: (self stringOf: newNamePointer).		f close.	].	successFlag ifTrue: [		self pop: 2.  "oldName, newName; leave rcvr on stack"	].!primitiveImageName	"Note: For now, this only implements getting, not setting, the image file name."	| result imageNameSize i |	self pop: 1.	imageNameSize _ imageName size.	result _ self instantiateClass: (self splObj: ClassString)				   indexableSize: imageNameSize.	1 to: imageNameSize do:		[:i | self storeByte: i-1 ofObject: result			withValue: (imageName at: i) asciiValue].	self push: result.!sqFile: file Read: count Into: byteArrayIndex At: startIndex	startIndex to: (startIndex + count - 1) do: [ :i |		file atEnd ifTrue: [ ^ i - startIndex ].		self byteAt: byteArrayIndex + i put: file next.	].	^ count!sqFile: file SetPosition: newPosition	file position: newPosition.!sqFile: file Write: count From: byteArrayIndex At: startIndex	startIndex to: (startIndex + count - 1) do: [ :i |		file nextPut: (self byteAt: byteArrayIndex + i).	].	^ count!sqFileAtEnd: file	^ file atEnd!sqFileClose: file	file close.!sqFileGetPosition: file	^ file position!sqFileSize: file	^ file size!vmPathGet: stringBase Length: stringSize	| pathName stringOop |	pathName _ Smalltalk vmPath.	stringOop _ stringBase - BaseHeaderSize. "Due to C call in Interp"	1 to: stringSize do:		[:i | self storeByte: i-1 ofObject: stringOop			withValue: (pathName at: i) asciiValue].!vmPathSize	^ Smalltalk vmPath size! !!InterpreterSimulator methodsFor: 'float primitives'!floatObjectOf: float	| result sign exponent mantissa mantSize long0 long1 |true ifTrue: [	"No conversion needed in Apple ST"	long0 _ float at: 1.	long1 _ float at: 2.] ifFalse: ["Following code useful when porting to different formats"	((float at: 1) = 0 and: [(float at: 2) = 0])		ifTrue: [long0 _ 0. long1 _ 0]		ifFalse: 	["Read from the PPS 32-bit format"	sign _ ((float at: 1) bitAnd: 16r8000) bitShift: -15.				"1-bit sign"	exponent _ (((float at: 1) bitShift: -7) bitAnd: 16rFF) - 16r80. 		"8-bit expt"	mantissa _ (((float at: 1) bitAnd: 16r7F) bitShift: 16) + (float at: 2).	"23 bit mantissa"	mantSize _ 23.	"Convert to first 32 bits of 64-bit IEEE format"	long0 _ (sign bitShift: 31)										"1-bit sign"			+ (exponent + 16r400 bitShift: 20)						"11-bit expt"			+ ((mantissa bitShift: 20 - mantSize) bitAnd: 16rFFFFF).	"20 bit mantissa"	]. ]. "end of porting code"	result _ self instantiateClass: (self splObj: ClassFloat) indexableSize: 2.	self storeWord: 0 ofObject: result withValue: long0.	self storeWord: 1 ofObject: result withValue: long1.	^ result!floatValueOf: objectPointer	| float len long0 long1 sign exponent mantissa mantSize |	(self isIntegerObject: objectPointer)		ifTrue: [^ (self integerValueOf: objectPointer) asFloat].	(self fetchClassOf: objectPointer) = (self splObj: ClassFloat)		ifFalse: [self success: false.  ^0.0].	len _ self fetchWordLengthOf: objectPointer.	(len between: 2 and: 3)		ifFalse: [self success: false.  ^0.0].	"FIRST convert image formats to sign/exponent/mantissa"	len = 2 ifTrue:  		["Normal 64-bit IEEE format"		long0 _ self fetchWord: 0 ofObject: objectPointer.		long1 _ self fetchWord: 1 ofObject: objectPointer.true ifTrue: [float _ Float new: 2.  "No conversion needed for AST"			float at: 1 put: long0.			float at: 2 put: long1.			^ float].		long0 = 0 ifTrue: [^ 0.0].		sign _ (long0 bitAnd: 16r80000000) bitShift: -31.				"1-bit sign"		exponent _ ((long0 bitShift: -20) bitAnd: 16r7FF) - 16r400.		"11-bit exponent"		mantissa _ ((long0 bitAnd: 16rFFFFF) bitShift: 32) + long1.		"52-bit mantissa"		mantSize _ 52]		ifFalse:  		["Weird 80-bit Apple format -- will go away soon"		long0 _ self fetchWord: 0 ofObject: objectPointer.		long1 _ self fetchWord: 1 ofObject: objectPointer.		long0 = 0 ifTrue: [^ 0.0].		sign _ (long0 bitAnd: 16r80000000) bitShift: -31.				"1-bit sign"		exponent _ ((long0 bitShift: -16) bitAnd: 16r7FFF) - 16r4000. 	"15-bit exponent"		"Note: drop the (redundant) high bit (16r8000) of mantissa"		mantissa _ ((long0 bitAnd: 16r7FFF) bitShift: 32) + long1.		"47-bit mantissa"		mantSize _ 47].	"THEN convert sign/exponent/mantissa to host format"	float _ Float new: 2.  "PPSST FP uses 2 16-bit words"	float at: 1 put: (sign bitShift: 15)							"1-bit sign"				+ (exponent + 16r80 bitShift: 7)				"8-bit expt"				+ ((mantissa bitShift: 7 - mantSize) bitAnd: 16r7F).	"7 bits of mantissa"	float at: 2 put: ((mantissa bitShift: 16 - (mantSize - 7)) bitAnd: 16rFFFF).  "16 more bits of mantissa"	^ float!primitiveAsFloat	"Use native Smalltalk's asFloat."	| arg |	arg _ self popInteger.	successFlag		ifTrue: [self pushFloat: arg asFloat]		ifFalse: [self unPop: 1].!primitiveExponent	"Use native Smalltalk's exponent."	| rcvr |	rcvr _ self popFloat.	self pushInteger: rcvr exponent.!primitiveFloatDivide	"Note: This method overridden here because the translator (intentionally) doesn't translate the / operator (since the semantics of C / are the semantics of Smalltalk //). This allows the version of this method to be translated to express division as //, which translates to the float division operator /."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	self success: arg ~= 0.0.	successFlag		ifTrue: [self pushFloat: rcvr / arg]		ifFalse: [self unPop: 2].!primitiveFractionalPart	"Use native Smalltalk's fractaionPart."	| rcvr |	rcvr _ self popFloat.	self pushFloat: rcvr fractionPart.!primitiveTruncated	"Use native Smalltalk's truncated."	| rcvr |	rcvr _ self popFloat.	self pushInteger: rcvr truncated.! !!InterpreterSimulator methodsFor: 'memory access'!byteAt: byteAddress	| lowBits |	lowBits _ byteAddress bitAnd: 3.	^((self longAt: byteAddress - lowBits)		bitShift: (lowBits - 3) * 8)		bitAnd: 16rFF!byteAt: byteAddress put: byte	| longWord shift lowBits |	lowBits _ byteAddress bitAnd: 3.	longWord _ self longAt: byteAddress - lowBits.	shift _ (3 - lowBits) * 8.	longWord _ longWord - (longWord bitAnd: (16rFF bitShift: shift)) + (byte bitShift: shift).	self longAt: byteAddress put: longWord!longAt: byteAddress	"Note: Adjusted for Smalltalk's 1-based array indexing."	^memory at: (byteAddress // 4) + 1!longAt: byteAddress put: a32BitValue	"Note: Adjusted for Smalltalk's 1-based array indexing."	^memory at: (byteAddress // 4) + 1 put: a32BitValue! !InterpreterSupportCode comment:'This class is a shell that includes all the ancillary C code for supporting Squeak in the Macintosh operating environment.  Executing	InterpreterSupportCode writeMacSourceFileswill cause the creation of a number of files in your working directory which, together with the one large interpreter file (see CCodeGenerator) should be adequate to compile a complete running interpreter.'!InterpreterSupportCode class comment:'This class is a shell that includes all the ancillary C code for supporting Squeak in the Macintosh operating environment.  Executing	InterpreterSupportCode writeMacSourceFileswill cause the creation of a number of files in your working directory which, together with the one large interpreter file (see CCodeGenerator) should be adequate to compile a womplete running interpreter.'!!InterpreterSupportCode class methodsFor: 'source file exporting'!storeProjectArchiveOnFileNamed: fileName	"Store into this image's folder a StuffIt archive file containing the CodeWarrier project files for the virtual machine. You will need to use a StuffIt unpacking utility such as StuffIt Expander to unpack the file. The result will be two project files for CodeWarrier, version 8."	| f |	f _ (FileStream newFileNamed: fileName) binary.	self archiveBinaryFile do: [ :byte | f nextPut: byte ].	f close.	MacFileDirectory setMacFileNamed: fileName type: 'SITD' creator: 'SIT!!'.!storeString: s onFileNamed: fileName	"Store the given string in a file of the given name."	| f |	f _ FileStream newFileNamed: fileName.	f nextPutAll: s.	f close.!writeMacSourceFiles	"Store into this image's folder the C sources files required to support the interpreter on the Macintosh. It also generates the code for the sound synthesis primitives. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate that code, use the method 'translate:doInlining:' in Interpreter class."	"InterpreterSupportCode writeMacSourceFiles"	self storeString: self readmeFile			onFileNamed: 'readme'.	self storeString: self squeakHeaderFile	onFileNamed: 'sq.h'.	self storeString: self joystickHeaderFile	onFileNamed: 'MouseStickII.h'.	self storeString: self filePrimsFile			onFileNamed: 'sqFilePrims.c'.	self storeString: self saveRestoreFile		onFileNamed: 'sqSaveRestore.c'.	self storeString: self macDirectoryFile		onFileNamed: 'sqMacDirectory.c'.	self storeString: self macJoystickFile		onFileNamed: 'sqMacJoystick.c'.	self storeString: self macSoundFile		onFileNamed: 'sqMacSound.c'.	self storeString: self macWindowFile		onFileNamed: 'sqMacWindow.c'.	self storeProjectArchiveOnFileNamed: 'projectArchive.sit'.	self storeString: AbstractSound cCodeForSoundPrimitives											onFileNamed: 'sqSoundPrims.c'.! !!InterpreterSupportCode class methodsFor: 'source files'!archiveBinaryFile	^ #(83 73 84 33 0 2 0 0 28 2 114 76 97 117 2 194 0 0 0 22 0 247 13 13 14 83 113 117 101 97 107 54 56 75 46 112 114 111 106 80 80 67 46 111 117 116 54 0 0 0 0 0 0 0 0 0 232 101 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 13 48 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 90 110 174 106 197 25 0 0 37 198 0 0 15 200 0 0 7 233 0 0 4 193 51 17 163 139 0 0 0 0 0 0 107 212 13 192 248 163 118 121 118 124 101 102 43 63 122 221 102 3 60 243 139 176 139 214 202 142 176 200 49 66 9 35 108 75 241 244 228 244 56 61 174 114 42 167 207 245 57 225 166 120 234 73 57 149 105 122 28 255 148 31 229 126 222 26 39 76 254 132 147 227 71 40 63 194 8 39 220 35 236 9 141 28 107 64 158 69 249 128 176 142 112 194 159 60 35 252 36 156 80 254 18 78 24 225 39 97 157 132 19 26 97 228 248 17 78 152 228 248 19 78 248 19 126 70 142 17 182 2 119 93 215 113 154 29 57 118 54 136 182 178 53 194 9 39 244 8 139 28 123 194 34 51 78 248 83 60 225 192 120 3 2 208 235 236 2 96 0 32 139 7 200 196 147 125 136 211 238 147 184 6 81 240 170 92 147 40 4 56 173 65 208 56 85 106 18 165 128 200 137 126 213 86 113 79 179 40 52 46 200 93 236 144 21 105 249 2 22 88 112 185 220 229 206 170 146 66 6 92 243 142 162 63 34 183 99 177 237 174 59 2 0 227 187 0 102 190 43 114 117 126 193 211 200 73 205 154 223 135 4 9 101 85 231 172 53 248 84 14 15 173 65 228 188 98 189 208 236 215 240 95 109 212 36 153 147 21 95 64 19 21 71 73 37 189 220 127 137 243 8 129 128 164 113 117 200 70 186 87 244 114 82 125 189 65 66 207 83 39 122 132 102 85 228 124 26 161 135 130 176 16 143 85 96 161 133 96 6 19 217 35 117 144 0 44 38 138 67 164 29 255 204 0 106 135 69 22 86 19 1 21 111 33 138 164 186 4 15 87 86 193 45 200 109 228 156 115 157 57 57 142 87 143 102 193 142 7 96 49 126 140 255 219 153 118 38 137 93 217 159 199 1 137 6 50 170 115 202 64 38 59 48 140 157 21 216 198 184 119 72 183 217 244 53 192 218 13 148 89 60 3 161 80 56 77 40 196 144 32 208 52 253 151 196 250 245 0 121 33 242 25 202 38 37 184 164 128 224 145 134 20 176 192 44 176 50 111 179 193 200 255 64 16 122 19 23 65 60 169 18 90 36 139 185 82 95 160 81 84 142 51 49 50 184 221 206 83 25 50 242 221 238 210 177 146 173 197 51 95 150 253 230 0 60 92 174 210 130 88 30 91 169 175 142 43 105 146 37 69 35 210 158 204 225 114 151 22 153 4 240 168 114 222 100 14 160 107 121 69 249 32 193 75 60 42 11 171 43 89 135 39 218 194 92 85 122 215 60 163 170 206 195 226 240 228 228 152 2 240 136 115 120 206 9 242 7 15 217 52 64 87 121 136 200 5 30 98 203 57 65 126 11 189 94 27 254 174 215 212 8 143 168 26 87 33 15 183 160 122 4 255 89 97 117 93 101 65 53 11 224 225 25 82 54 166 43 49 54 132 71 2 225 241 107 39 26 229 193 58 142 251 155 254 136 43 23 87 196 234 181 218 89 54 236 27 82 73 146 162 168 115 240 74 158 230 127 91 7 237 247 138 170 68 155 253 8 15 181 193 95 23 203 99 115 23 158 87 21 121 104 205 38 1 60 72 88 28 88 37 127 233 234 38 181 24 243 192 38 32 14 23 165 61 153 227 178 195 61 195 195 52 192 225 150 21 220 66 102 114 81 61 92 238 170 152 30 102 13 78 249 180 26 151 157 114 148 199 5 167 60 204 99 196 41 15 235 58 226 148 99 60 204 23 156 242 160 30 127 58 229 51 194 94 114 202 49 30 35 78 121 144 198 21 167 28 229 97 14 224 148 205 63 28 238 233 130 189 236 112 207 118 70 211 0 135 91 229 11 220 48 159 107 201 93 112 202 225 90 47 58 29 36 114 42 199 69 167 19 229 113 193 161 12 235 49 226 80 98 60 70 59 240 32 143 43 29 56 202 35 206 17 237 122 137 200 3 11 127 216 10 143 117 152 94 30 126 223 80 219 251 101 146 112 182 210 8 15 169 110 249 16 143 178 186 229 49 30 73 174 211 235 10 145 226 112 57 139 77 1 68 255 125 70 144 136 106 208 138 62 207 3 59 149 127 200 43 78 32 60 252 130 170 114 78 169 73 246 249 143 169 27 238 12 88 209 98 189 41 128 174 99 157 161 215 75 71 61 249 40 143 88 7 142 213 89 111 231 212 134 202 108 36 44 25 116 109 136 129 56 198 138 27 62 11 161 6 241 165 71 54 67 205 117 7 117 12 96 7 64 13 31 252 236 8 158 223 240 65 62 216 253 233 204 165 184 241 51 30 246 96 230 7 241 31 150 16 10 165 124 235 166 93 80 115 125 49 44 253 177 22 130 251 119 67 176 173 133 15 110 176 210 59 193 181 216 14 9 19 157 31 151 202 183 146 124 124 235 198 253 112 231 190 71 142 114 65 36 248 240 243 125 130 235 255 95 232 146 81 126 125 193 183 190 52 141 111 125 17 111 27 252 32 237 46 216 131 103 63 159 182 47 160 38 239 0 254 191 70 185 116 81 206 223 193 122 170 116 26 102 69 198 184 81 196 78 94 168 143 82 43 154 101 210 157 9 90 140 219 132 162 162 46 180 219 186 96 194 214 89 17 226 204 28 93 17 204 202 120 95 152 7 246 219 15 224 185 167 33 244 19 143 248 108 188 23 2 251 213 115 16 59 132 103 42 164 181 86 98 254 29 217 96 177 32 206 245 229 7 196 221 58 62 71 99 114 62 232 80 61 138 15 210 113 32 137 249 233 86 149 183 19 235 0 245 161 249 19 49 255 182 221 96 207 232 221 137 202 126 242 21 126 221 118 13 17 44 2 194 167 179 19 236 211 183 49 55 198 167 34 182 23 249 181 211 58 159 176 117 149 158 31 245 32 249 237 51 194 182 50 3 102 144 109 56 82 3 147 6 106 0 77 143 34 40 62 81 93 8 166 22 53 192 252 255 182 31 76 3 106 32 17 216 244 129 26 8 55 1 128 142 44 232 89 188 19 122 202 91 248 182 7 222 47 35 83 245 56 72 194 15 224 115 198 123 63 225 24 34 183 225 224 115 29 240 205 174 167 129 153 187 150 241 174 64 61 238 111 239 54 130 222 239 81 87 35 147 15 249 117 168 41 205 223 145 133 57 190 45 128 204 2 72 254 184 26 38 230 178 180 135 165 37 235 134 225 224 150 183 98 253 28 121 206 11 67 58 190 50 3 210 186 55 226 217 142 88 29 189 159 214 115 24 108 111 118 133 48 16 231 111 194 90 224 183 36 101 195 33 6 235 117 77 8 152 125 116 18 206 90 113 211 47 185 194 215 36 251 69 174 64 20 199 38 155 166 29 193 0 99 6 83 4 24 118 176 224 194 44 93 234 164 27 158 172 113 207 6 227 140 107 225 166 179 19 119 107 225 42 125 207 154 91 226 34 163 65 178 111 61 60 62 232 143 162 252 138 74 125 103 37 93 214 251 249 63 145 135 17 1 79 236 200 194 184 221 3 41 231 163 142 87 246 130 173 145 202 32 245 176 151 110 24 15 52 20 51 160 88 182 76 213 4 133 88 61 19 135 176 83 167 136 197 60 80 207 216 253 204 0 218 85 158 9 132 190 140 157 236 121 155 210 196 27 100 194 20 219 204 39 110 67 119 47 12 153 89 224 73 118 245 171 77 1 124 76 172 108 251 124 206 9 151 163 123 19 171 254 88 128 145 18 207 222 247 51 152 120 167 54 177 5 175 76 97 2 192 202 75 232 124 118 178 172 224 48 54 29 174 173 168 44 207 194 140 253 27 119 89 221 116 184 137 158 15 183 88 190 130 169 120 223 70 176 242 247 0 231 54 12 29 110 223 252 24 228 34 70 223 43 40 118 3 142 243 25 50 241 3 249 35 40 67 214 153 4 107 90 3 203 16 171 36 152 187 24 240 113 0 214 75 48 237 127 176 26 177 85 4 179 127 13 109 136 117 18 172 122 59 60 138 216 97 202 47 7 158 0 184 102 17 193 110 45 129 205 40 89 53 193 132 215 225 25 148 146 14 146 87 119 195 203 136 33 23 212 105 54 224 44 101 10 153 213 128 99 31 224 91 30 83 105 190 228 201 240 9 98 143 19 172 118 10 124 137 216 70 130 101 78 7 124 241 96 250 189 4 155 244 20 252 140 24 205 49 251 123 124 119 3 56 58 100 172 125 150 73 1 152 129 111 131 96 224 116 5 179 206 39 80 220 183 20 195 90 192 87 67 220 248 230 136 232 209 56 172 43 213 39 5 82 112 195 40 50 8 183 209 77 135 8 156 76 118 93 156 146 87 188 89 12 88 123 247 94 232 53 131 198 120 99 235 42 156 50 140 87 9 74 192 23 184 91 181 133 233 22 182 104 138 160 38 20 122 125 154 164 88 138 164 128 150 80 41 40 119 139 90 74 190 199 35 226 48 222 45 104 13 120 159 166 73 166 102 221 32 222 187 82 74 175 25 132 108 250 114 71 68 57 29 14 211 78 112 22 185 48 89 50 121 112 33 204 163 247 241 133 113 4 194 205 33 122 221 224 243 31 0 0 11 192 248 26 154 223 164 181 86 118 102 107 29 225 228 168 228 249 202 34 183 25 161 156 114 242 156 240 149 181 50 143 83 249 81 57 149 223 90 29 37 199 143 48 15 207 214 147 43 0 167 190 52 252 211 203 35 252 200 49 9 39 148 60 39 199 201 152 19 78 24 57 118 114 50 224 71 56 121 234 145 103 17 118 228 89 132 69 56 229 132 145 231 228 56 57 78 56 225 70 56 57 78 102 156 76 248 145 227 100 196 9 37 199 41 121 78 142 2 55 232 54 75 241 17 118 146 245 8 245 146 19 60 39 156 112 194 200 152 31 65 1 37 28 79 86 224 91 177 128 29 0 164 84 53 3 0 18 254 246 2 248 94 197 223 69 220 37 240 183 30 127 223 131 58 120 12 92 48 208 148 84 231 181 148 162 131 244 221 183 240 6 12 207 108 253 26 129 38 36 208 175 89 204 248 185 92 156 231 137 203 169 224 24 57 167 201 26 65 234 51 140 215 40 32 38 151 127 140 231 61 245 124 50 246 127 224 165 42 15 143 252 135 103 237 168 126 108 62 241 142 203 11 245 82 170 123 210 166 129 235 73 215 83 151 182 224 103 212 30 26 55 193 3 159 225 159 218 153 71 196 13 116 112 199 114 134 162 205 253 239 137 193 112 170 120 193 189 239 184 152 219 215 250 151 63 71 182 87 204 254 124 107 215 89 156 15 136 125 167 152 187 197 220 33 230 46 49 31 68 222 20 206 1 49 31 194 121 26 231 195 98 239 91 35 27 191 224 220 131 123 25 103 79 129 92 79 224 252 105 73 63 175 126 1 61 157 75 39 52 146 213 247 36 108 219 247 65 191 119 49 133 208 110 69 253 124 168 159 188 160 188 168 232 134 170 41 85 1 221 98 54 117 235 205 75 31 172 226 124 36 239 14 124 115 87 71 71 159 162 46 95 193 215 120 85 231 3 93 48 251 158 85 151 116 131 164 102 171 186 180 218 190 58 138 243 250 190 10 254 234 43 60 254 197 201 187 122 126 8 31 161 26 158 162 158 30 166 231 203 36 151 86 47 214 146 174 229 161 207 250 215 126 251 233 173 191 244 10 10 63 20 125 119 21 222 103 169 100 235 212 198 116 98 145 246 71 32 155 109 197 209 233 216 218 75 167 122 254 205 133 114 94 181 51 125 78 19 77 73 97 96 45 85 52 50 219 203 254 3 121 85 238 1 232 239 17 146 81 254 172 1 86 187 218 191 161 7 140 192 104 221 143 56 187 182 245 243 199 101 99 6 139 224 224 208 115 193 129 147 228 196 80 58 20 198 245 125 253 104 159 165 95 249 142 22 116 231 120 50 156 217 65 219 109 178 118 135 127 78 83 95 67 67 105 131 67 179 3 201 172 156 201 132 74 71 97 187 188 119 135 185 55 125 153 140 141 159 153 12 163 172 37 57 183 105 149 59 252 172 41 11 103 4 163 149 131 26 126 191 41 130 87 172 62 226 104 144 119 247 190 45 45 199 19 99 35 116 3 46 70 237 112 156 148 119 135 110 155 212 208 109 168 99 212 54 199 55 216 26 62 225 84 186 129 122 70 109 118 220 143 23 70 172 91 35 208 192 168 117 142 39 242 30 207 247 130 138 27 76 62 244 248 202 101 39 41 11 228 227 47 165 229 137 225 201 9 186 193 28 103 84 39 247 145 21 176 168 1 108 39 140 234 180 25 204 196 43 38 245 250 21 236 94 166 66 181 174 86 32 55 110 154 212 27 55 177 129 50 170 211 88 11 228 218 134 73 189 182 129 205 198 164 214 250 119 225 245 71 127 16 84 220 96 95 99 84 231 213 161 64 110 249 204 91 111 249 120 27 93 185 92 175 95 8 207 84 35 144 54 4 203 13 9 240 70 48 235 175 158 109 30 94 80 114 134 190 75 102 125 132 81 217 198 199 169 77 19 75 115 74 5 10 172 157 112 42 221 180 115 106 87 84 205 165 137 65 212 156 156 65 51 105 170 125 129 125 107 7 167 186 95 152 71 199 165 53 249 98 233 94 155 218 41 168 113 178 168 164 227 106 90 249 155 218 197 169 62 235 214 9 101 209 184 79 182 169 221 156 218 50 158 60 99 144 204 174 31 108 234 1 225 188 184 146 165 89 247 208 121 126 70 237 108 204 98 150 87 125 206 122 38 163 178 77 15 167 54 45 45 200 21 125 24 85 182 168 50 28 20 84 221 72 19 181 70 157 178 168 83 16 224 212 102 164 98 39 217 197 218 212 67 22 85 35 185 243 123 212 105 139 58 13 135 133 27 12 146 45 27 124 231 214 222 8 230 235 106 168 13 195 103 84 145 211 138 86 178 4 123 75 224 84 186 57 194 169 244 181 86 80 177 10 237 52 54 124 121 88 142 199 163 163 108 211 199 83 217 27 87 231 117 37 73 75 67 44 246 224 90 250 190 36 82 25 55 112 84 36 202 105 69 159 125 122 126 47 81 214 173 108 88 135 160 153 202 232 6 173 154 202 219 212 126 70 125 165 213 236 148 101 48 123 137 226 84 186 57 38 110 229 181 171 114 43 125 23 226 84 186 57 206 155 141 243 30 92 32 155 119 204 142 178 121 135 255 71 194 55 119 112 37 146 202 249 173 45 11 132 255 145 128 254 135 186 76 106 136 190 137 83 31 125 137 78 140 233 6 163 54 68 87 240 25 203 143 79 69 231 18 35 25 157 254 231 63 0 13 13 14 83 113 117 101 97 107 80 80 67 46 112 114 111 106 80 80 67 46 111 117 116 54 0 0 0 0 0 0 0 0 0 48 77 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 22 0 0 0 0 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 174 106 197 11 0 0 42 109 0 0 16 196 0 0 9 117 0 0 4 237 193 213 31 60 0 0 0 0 0 0 83 80 13 192 213 101 47 91 153 121 221 186 79 202 37 108 179 214 242 26 116 180 91 153 132 21 97 132 237 149 108 182 25 158 158 253 166 185 169 157 13 58 147 159 159 107 158 204 179 51 127 175 31 225 180 237 197 200 90 223 27 217 71 56 173 35 140 220 62 118 125 132 18 78 24 217 132 253 102 157 110 9 219 172 142 117 145 205 200 62 70 246 81 178 237 200 49 178 9 219 140 240 235 164 156 176 77 142 19 182 141 240 167 92 194 200 102 197 200 38 180 91 129 175 26 212 121 117 190 155 125 180 149 173 183 143 108 105 132 109 114 91 183 145 217 38 155 108 134 39 27 24 239 1 1 232 117 118 120 0 6 0 51 63 11 48 3 79 213 231 220 161 63 46 124 144 65 232 61 47 204 17 67 39 241 28 104 232 154 107 12 189 45 223 42 51 106 191 220 46 217 90 173 86 179 209 235 243 180 88 5 16 192 98 177 214 152 235 23 151 48 176 20 12 161 39 130 72 110 56 118 173 108 202 1 200 60 0 112 87 91 238 34 99 232 232 142 173 229 37 171 53 75 186 118 236 54 221 129 200 228 50 119 168 123 174 17 50 241 212 225 153 86 185 239 148 166 234 93 200 92 165 91 210 69 111 189 154 157 53 117 85 5 41 21 253 83 78 134 188 149 43 43 219 11 0 82 56 183 20 254 169 99 100 73 220 161 80 167 96 64 229 82 128 178 223 179 236 25 248 66 224 201 213 120 231 239 65 165 127 1 239 45 97 28 223 167 122 109 246 86 91 147 244 129 150 114 140 11 191 55 250 215 180 93 120 63 190 118 141 63 32 181 153 93 54 191 95 242 95 164 144 119 94 169 11 161 1 1 19 169 16 217 132 183 143 114 142 134 128 44 180 10 0 44 34 81 78 138 100 90 108 118 67 85 173 1 91 132 193 60 215 156 159 111 252 222 80 22 81 46 51 249 18 190 47 97 155 88 186 240 192 217 60 90 96 72 7 79 46 51 161 49 216 200 171 147 154 207 88 48 181 34 64 181 40 131 4 54 212 72 73 140 101 212 13 103 210 99 17 62 47 108 19 126 173 250 14 193 79 191 3 176 97 43 103 150 130 198 33 20 73 19 10 97 193 82 201 2 76 149 175 20 91 182 0 44 10 209 23 238 23 233 26 139 199 109 179 123 70 21 80 195 44 208 178 31 11 193 232 253 92 117 147 44 203 33 133 122 79 184 245 84 56 221 173 146 239 125 38 201 12 147 11 173 214 138 91 69 182 10 207 66 175 215 165 12 192 195 98 169 40 74 228 201 168 112 54 26 22 183 121 61 190 0 73 123 49 135 197 90 81 170 16 192 163 222 92 172 12 160 107 77 109 205 8 193 143 121 212 149 44 171 83 25 27 155 237 125 125 125 192 126 186 153 63 124 235 137 0 93 197 71 90 222 64 187 84 172 43 178 185 92 30 143 219 80 38 185 188 244 112 210 2 1 222 234 234 129 238 153 11 96 135 233 32 61 33 30 130 209 30 111 133 150 122 217 211 92 174 14 153 135 218 104 207 207 87 4 224 161 50 218 175 10 242 15 30 92 118 69 0 93 189 163 68 110 240 144 58 174 10 242 183 144 235 181 249 191 245 154 25 229 17 87 99 60 242 176 218 252 118 155 235 138 176 178 174 94 219 136 193 255 23 15 251 168 178 9 93 201 32 17 15 13 241 248 176 19 93 231 33 24 223 247 73 103 67 85 35 125 229 163 122 245 95 237 211 26 148 161 208 223 198 251 52 127 127 190 79 47 51 87 37 125 76 38 37 41 141 59 25 135 199 222 254 191 22 196 253 135 207 239 139 155 134 49 30 254 102 87 99 34 79 134 181 228 154 170 200 35 208 174 16 192 131 66 109 196 42 249 143 174 86 170 69 217 113 207 95 240 37 229 18 199 141 210 94 204 113 211 113 95 230 161 24 224 184 171 138 202 13 73 61 44 214 250 132 30 74 31 206 253 146 170 55 157 123 156 199 13 231 158 228 49 230 220 147 186 142 57 247 4 15 229 5 231 62 162 199 191 157 251 101 97 63 118 238 9 30 99 206 125 132 198 39 206 61 206 67 57 192 185 171 141 126 169 233 195 62 13 208 125 231 105 156 198 207 130 162 60 236 207 251 135 250 116 41 239 211 202 31 142 251 82 225 223 116 220 87 58 172 98 128 227 174 119 186 239 158 103 232 88 48 255 47 142 91 251 79 199 132 68 174 118 134 235 142 41 206 227 134 211 73 234 49 230 116 18 60 174 119 242 17 30 159 116 242 56 15 149 49 222 245 210 144 7 22 126 210 154 223 234 48 49 30 46 231 104 219 59 51 217 184 82 105 196 195 211 216 50 202 163 170 177 37 193 35 221 114 105 157 35 90 28 22 115 153 34 128 232 127 159 53 164 161 26 188 162 175 241 192 78 229 26 245 156 89 196 131 150 198 12 102 79 155 215 233 58 167 110 164 51 96 69 75 171 21 1 116 189 213 25 98 158 60 238 237 175 243 72 116 224 68 157 197 58 103 96 180 204 198 66 99 224 203 106 2 168 25 237 162 153 160 1 241 21 167 191 5 13 119 189 41 99 0 251 1 26 196 224 111 79 227 217 47 6 197 96 223 43 211 87 224 70 212 4 56 132 153 215 225 29 112 239 16 88 133 216 249 244 47 160 97 78 25 172 120 111 21 4 95 63 8 193 135 58 196 224 86 45 127 19 220 128 237 144 152 200 252 12 153 98 39 229 19 59 159 122 29 150 191 186 113 136 11 34 193 71 182 15 10 46 223 209 147 99 96 126 228 55 24 98 103 207 84 177 115 55 190 14 243 131 137 43 225 16 158 103 249 60 244 6 52 44 58 130 247 189 156 75 47 231 124 28 182 112 165 39 98 86 100 204 112 251 80 48 153 214 139 235 15 44 11 147 99 160 154 90 204 220 117 15 227 137 76 83 207 152 176 57 60 129 252 246 41 16 222 125 133 112 131 90 196 252 6 189 184 126 167 60 183 77 159 215 195 154 158 148 181 163 124 213 63 232 16 215 111 47 5 109 201 30 24 248 238 97 86 253 179 94 204 181 22 82 91 191 14 143 158 24 96 213 47 108 194 145 4 15 204 113 132 165 60 254 4 156 186 119 187 248 240 241 74 174 62 60 179 138 102 18 192 94 45 102 213 223 7 161 41 123 26 12 252 114 138 204 238 254 31 114 205 70 99 224 20 181 34 94 252 81 141 185 46 63 218 7 176 118 39 123 13 132 60 147 60 222 174 109 247 146 67 49 149 73 54 135 228 243 155 10 43 107 23 227 204 82 6 113 74 242 226 105 58 217 194 151 143 48 71 79 0 207 89 108 33 149 215 164 195 156 145 227 89 107 17 164 233 64 151 171 143 178 215 23 190 150 232 73 236 243 107 222 228 128 35 204 131 112 84 156 248 176 47 76 250 235 52 252 40 248 225 36 244 98 174 205 84 47 204 241 220 70 210 4 243 247 240 247 186 105 27 33 235 27 219 243 32 77 205 245 120 134 101 241 83 142 108 200 193 130 16 38 15 215 0 162 17 229 245 25 189 144 181 109 86 76 176 217 145 234 22 88 203 59 5 160 95 114 4 207 67 205 161 63 137 136 223 137 239 66 160 255 212 108 196 78 226 153 9 19 59 235 48 255 254 60 80 171 17 55 12 230 7 196 173 50 62 59 192 242 95 238 246 219 125 78 184 13 7 81 152 159 111 31 182 244 99 63 68 125 120 254 52 204 255 246 65 208 103 199 118 7 115 143 175 19 55 239 161 41 22 54 67 226 211 255 28 232 239 216 197 138 117 86 196 14 35 191 77 188 226 179 182 61 40 231 71 61 40 191 62 39 210 217 80 127 218 197 165 26 184 125 184 6 208 252 250 108 62 167 132 197 175 248 80 3 226 230 43 53 192 90 127 247 146 146 64 13 76 24 174 1 218 5 21 145 19 113 86 70 233 3 40 166 54 188 136 174 244 18 225 149 109 5 152 208 227 172 32 90 18 131 145 1 169 88 34 252 8 191 60 64 14 51 185 57 127 45 22 97 200 187 84 44 184 236 252 159 23 110 6 241 137 130 23 54 244 145 231 112 202 121 168 99 88 234 152 11 76 142 131 180 232 2 162 203 226 236 176 220 75 135 26 138 18 80 220 119 159 63 96 243 241 165 13 229 134 208 131 74 8 255 212 33 246 71 0 12 236 126 220 122 41 126 232 203 244 10 49 238 239 131 216 71 179 165 241 242 159 99 12 75 45 100 112 232 15 50 248 255 152 193 36 165 133 181 117 178 123 185 13 125 117 42 109 12 209 244 77 9 160 49 36 203 118 208 231 92 112 57 242 63 70 180 231 126 43 19 251 103 14 75 49 59 38 117 224 147 41 108 47 8 222 165 124 78 63 217 235 195 161 252 103 96 70 109 93 77 46 102 124 236 12 165 244 66 174 45 159 42 222 243 19 160 121 71 6 97 213 15 128 9 175 159 38 172 252 81 160 173 216 13 132 181 223 14 247 226 117 23 97 227 235 160 9 175 52 60 132 156 233 128 92 89 57 97 181 179 97 45 98 223 36 108 190 15 186 16 251 54 97 133 207 67 55 98 123 8 91 158 5 207 34 118 148 176 212 99 88 151 32 244 19 246 213 62 248 57 42 201 183 67 27 95 132 223 32 134 255 212 1 48 255 10 254 128 24 223 156 176 158 130 99 136 241 109 49 205 65 56 129 88 47 97 83 159 132 1 28 129 240 217 206 196 189 44 29 95 144 110 176 240 49 134 26 27 238 225 60 118 48 156 186 26 248 254 130 110 55 155 137 24 215 53 231 107 236 110 188 241 124 214 63 51 220 186 205 89 71 88 253 106 86 141 24 205 93 192 244 56 195 9 115 46 111 21 115 95 98 14 196 120 142 2 145 225 79 67 242 184 246 211 212 236 126 128 233 242 58 74 47 205 157 102 208 159 125 64 117 140 99 92 215 9 86 236 55 146 61 96 192 250 244 59 61 238 108 139 173 201 105 55 152 109 222 225 37 11 180 225 145 135 242 78 73 86 236 65 152 67 6 95 180 137 102 28 71 171 86 102 143 67 250 162 228 214 198 214 174 248 179 112 198 76 218 127 46 118 250 145 168 212 214 72 44 201 229 159 121 160 147 119 223 113 203 208 45 185 116 184 150 23 165 55 33 188 120 120 14 175 183 249 220 78 119 147 63 35 162 108 73 71 192 103 243 107 74 28 206 128 199 167 46 245 184 3 154 58 155 175 73 10 232 10 237 118 9 37 182 218 2 205 248 158 167 25 71 138 68 68 139 109 103 243 103 17 153 229 189 164 8 239 48 28 161 173 49 151 90 48 217 56 62 174 8 243 136 253 87 37 149 32 92 122 227 207 195 124 254 15 0 0 12 192 120 58 203 115 210 160 179 149 121 217 90 3 114 44 114 252 86 126 228 248 17 214 147 231 132 175 241 181 36 244 184 171 156 226 105 107 153 156 112 114 204 195 83 79 118 226 153 166 244 240 95 121 156 12 216 74 56 97 228 57 65 1 127 194 8 215 227 100 192 142 112 114 124 61 57 57 22 97 71 158 145 163 156 112 202 201 132 145 227 228 24 225 228 24 153 112 114 156 60 63 50 225 148 19 78 70 156 80 242 148 60 37 156 2 119 217 49 66 143 175 140 208 227 132 30 161 30 91 11 207 141 112 66 57 225 100 200 201 113 50 166 132 1 16 60 240 133 5 108 30 64 49 69 73 0 0 135 223 102 0 95 63 126 117 236 9 248 45 195 239 93 172 94 128 18 188 171 141 4 40 227 243 166 31 176 6 48 22 251 104 157 59 37 64 121 199 255 225 225 249 159 103 29 238 187 118 128 203 203 92 84 63 14 207 195 247 92 84 155 95 165 253 70 69 89 227 245 204 14 83 94 207 236 131 187 228 44 33 238 181 146 215 47 47 195 47 80 10 80 249 62 120 225 35 188 87 67 119 132 205 64 10 175 54 30 21 39 164 211 146 166 43 170 20 140 109 170 5 224 102 181 55 211 154 254 26 217 7 179 220 245 25 172 91 178 53 254 121 172 27 179 213 245 231 176 246 99 61 128 245 1 86 55 97 61 136 117 51 235 239 199 90 196 218 99 200 183 4 172 191 132 175 112 42 223 67 93 60 168 139 146 74 198 5 85 30 213 10 178 160 162 230 169 101 186 88 250 88 122 236 99 253 122 86 239 101 117 29 171 27 88 237 232 230 203 200 11 191 254 171 159 91 27 239 144 19 210 159 242 65 229 174 15 250 125 176 225 11 62 109 156 23 99 237 178 42 197 208 24 166 242 18 86 237 90 224 11 55 224 83 234 58 107 123 133 186 156 149 147 113 229 82 113 175 170 119 116 57 146 89 154 127 239 47 125 14 227 28 115 235 58 77 195 39 56 165 235 161 78 46 170 19 181 176 162 76 176 103 71 167 67 153 190 182 198 255 246 232 30 124 139 211 213 173 251 62 234 243 166 50 165 233 114 108 164 32 145 43 231 79 173 108 15 118 79 240 169 128 241 242 221 151 158 248 109 77 87 82 151 212 177 23 95 61 177 189 110 112 116 215 7 191 237 128 206 210 159 176 198 136 185 154 119 218 222 138 118 5 194 65 65 8 7 35 242 80 94 63 75 247 205 57 220 209 174 238 51 253 79 198 128 242 220 28 152 18 87 253 139 238 211 121 49 38 109 143 97 207 191 57 135 119 76 85 206 99 16 82 137 34 137 194 40 21 219 115 84 242 162 62 252 88 10 122 44 238 230 28 30 254 108 248 116 42 169 203 163 210 246 130 144 119 131 149 57 172 190 189 103 227 41 73 28 9 244 241 129 19 175 156 42 232 113 108 101 119 67 56 197 76 169 179 235 89 247 169 119 185 52 47 68 58 72 7 74 40 181 214 217 200 76 247 245 16 151 214 134 19 67 164 3 165 148 90 229 236 205 103 31 191 77 168 122 106 136 116 160 140 82 27 156 45 201 214 70 234 152 66 216 129 114 74 61 230 120 79 182 166 249 67 70 197 14 84 80 170 203 113 136 204 210 207 207 154 84 210 193 188 140 142 115 229 170 147 175 13 249 139 111 184 116 239 201 254 94 210 193 148 74 169 78 170 69 150 223 166 250 49 155 81 170 147 229 208 217 175 89 212 91 215 48 121 90 10 21 147 170 33 223 190 99 81 111 223 193 4 78 169 206 187 135 33 207 122 45 234 172 23 211 25 165 58 105 206 144 111 46 88 212 155 11 152 170 45 106 241 237 199 184 248 220 143 140 138 29 240 16 231 187 114 181 76 27 15 14 23 12 143 228 28 123 27 4 240 134 48 105 76 159 171 58 57 33 37 117 109 139 76 83 21 165 210 142 207 164 86 246 78 141 73 121 40 208 140 101 82 73 167 214 164 214 135 149 100 92 214 101 37 41 38 112 45 84 37 55 65 110 214 58 147 90 211 147 194 221 137 171 226 165 141 121 115 212 122 70 229 229 73 41 206 43 113 233 111 106 131 73 245 218 179 246 74 147 250 26 57 71 221 107 82 247 116 71 207 232 114 98 107 31 114 212 125 108 243 120 105 148 120 221 206 230 53 134 208 27 166 235 42 70 49 55 20 246 156 166 101 74 165 157 253 38 181 114 106 66 204 235 67 169 162 77 21 193 207 168 154 30 151 149 34 117 192 166 14 192 1 147 90 133 84 140 11 91 216 28 181 201 166 170 114 242 194 35 234 160 77 29 132 102 182 13 52 9 21 183 97 101 214 131 33 76 157 51 207 184 208 124 58 37 49 46 169 27 43 65 95 122 76 42 233 180 152 84 247 3 42 38 162 63 82 20 190 11 165 121 62 220 73 59 135 152 83 154 241 36 239 148 228 245 200 220 114 210 9 152 94 238 225 149 148 38 69 73 104 232 234 90 135 147 183 23 230 229 216 129 86 230 67 237 146 54 242 70 234 145 15 205 217 142 50 7 135 45 47 199 29 82 11 10 253 78 61 66 169 239 84 91 233 112 19 76 95 239 76 42 233 28 53 147 141 243 26 100 200 139 247 173 140 178 120 31 51 186 153 216 30 103 122 227 98 112 132 75 183 9 66 132 116 204 59 28 254 111 0 37 66 84 186 176 188 108 131 240 14 7 228 14 217 50 174 60 60 134 85 11 121 133 23 34 26 249 47 129 220 153 196 167 211 27 120 231 158 208 145 208 200 157 167 0).!filePrimsFile	^ '#include "sq.h"#define true  1#define false 0/***	The state of a file is kept in the following structure,	which is stored directly in a Squeak bytes object.	NOTE: The Squeak side is responsible for creating an	object with enough room to store sizeof(SQFile) bytes.	The session ID is used to detect stale file objects--	files that were still open when an image was written.	The file pointer of such files is meaningless.	typedef struct {		File	*file;		int		sessionID;		int		writable;		int		fileSize;	} SQFile;***//*** Variables ***/int thisSession = 0;extern unsigned char *memory;int sqFileAtEnd(SQFile *f) {	/* Return true if the file''s read/write head is at the end of the file. */	if (!!sqFileValid(f)) return success(false);	return ftell(f->file) == f->fileSize;}int sqFileClose(SQFile *f) {	/* Close the given file. */	if (!!sqFileValid(f)) return success(false);	fclose(f->file);	f->file = NULL;	f->sessionID = 0;	f->writable = false;	f->fileSize = 0;}int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize) {	char cFileName[1000];	int i, err;	if (sqFileNameSize >= 1000) {		return success(false);	}	/* copy the file name into a null-terminated C string */	for (i = 0; i < sqFileNameSize; i++) {		cFileName[i] = *((char *) (sqFileNameIndex + i));	}	cFileName[sqFileNameSize] = 0;	err = remove(cFileName);	if (err) {		return success(false);	}}int sqFileGetPosition(SQFile *f) {	/* Return the current position of the file''s read/write head. */	int position;	if (!!sqFileValid(f)) return success(false);	position = ftell(f->file);	if (position < 0) return success(false);	return position;}int sqFileInit(void) {	/* Create a session ID that is unlikely to be repeated.	   Zero is never used for a valid session number.	   Should be called once at startup time.	*/	thisSession = clock() + time(NULL);	if (thisSession == 0) thisSession = 1;	/* don''t use 0 */}int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag) {	/* Opens the given file using the supplied sqFile structure	   to record its state. Fails with no side effects if f is	   already open. Files are always opened in binary mode;	   Squeak must take care of any line-end character mapping.	*/	char cFileName[1001];	int i;	/* don''t open an already open file */	if (sqFileValid(f)) return success(false);	/* copy the file name into a null-terminated C string */	if (sqFileNameSize > 1000) {		return success(false);	}	for (i = 0; i < sqFileNameSize; i++) {		cFileName[i] = *((char *) (sqFileNameIndex + i));	}	cFileName[sqFileNameSize] = 0;	if (writeFlag) {		/* First try to open an existing file read/write: */		f->file = fopen(cFileName, "rb+");		if (f->file == NULL) {			/* Previous call fails if file does not exist. In that case,			   try opening it in write mode to create a new, empty file.			*/			f->file = fopen(cFileName, "wb");			if (f->file !!= NULL) {				/* set the type and creator of newly created Mac files */				dir_SetMacFileTypeAndCreator(cFileName, strlen(cFileName), "TEXT", "R*ch");				}		}		f->writable = true;	} else {		f->file = fopen(cFileName, "rb");		f->writable = false;	}	if (f->file == NULL) {		f->sessionID = 0;		f->fileSize = 0;		return success(false);	} else {		f->sessionID = thisSession;		/* compute and cache file size */		fseek(f->file, 0, SEEK_END);		f->fileSize = ftell(f->file);		fseek(f->file, 0, SEEK_SET);	}}int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Read count bytes from the given file into byteArray starting at	   startIndex. byteArray is the address of the first byte of a	   Squeak bytes object (e.g. String or ByteArray). startIndex	   is a zero-based index; that is a startIndex of 0 starts writing	   at the first byte of byteArray.	*/	char *dst;	int bytesRead;	if (!!sqFileValid(f)) return success(false);	dst = (char *) (byteArrayIndex + startIndex);	bytesRead = fread(dst, 1, count, f->file);	return bytesRead;}int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize) {	char cOldName[1000], cNewName[1000];	int i, err;	if ((oldNameSize >= 1000) || (newNameSize >= 1000)) {		return success(false);	}	/* copy the file names into null-terminated C strings */	for (i = 0; i < oldNameSize; i++) {		cOldName[i] = *((char *) (oldNameIndex + i));	}	cOldName[oldNameSize] = 0;	for (i = 0; i < newNameSize; i++) {		cNewName[i] = *((char *) (newNameIndex + i));	}	cNewName[newNameSize] = 0;	err = rename(cOldName, cNewName);	if (err) {		return success(false);	}}int sqFileSetPosition(SQFile *f, int position) {	/* Set the file''s read/write head to the given position. */	if (!!sqFileValid(f)) return success(false);	fseek(f->file, position, SEEK_SET);}int sqFileSize(SQFile *f) {	/* Return the length of the given file. */	if (!!sqFileValid(f)) return success(false);	return f->fileSize;}int sqFileValid(SQFile *f) {	return (		(f !!= NULL) &&		(f->file !!= NULL) &&		(f->sessionID == thisSession));}int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Write count bytes to the given writable file starting at startIndex	   in the given byteArray. (See comment in sqFileReadIntoAt for interpretation	   of byteArray and startIndex).	*/	char *src;	int bytesWritten, position;	if (!!(sqFileValid(f) && f->writable)) return success(false);	src = (char *) (byteArrayIndex + startIndex);	bytesWritten = fwrite(src, 1, count, f->file);	position = ftell(f->file);	if (position > f->fileSize) {		f->fileSize = position;  /* update file size */	}	if (bytesWritten !!= count) {		success(false);	}	return bytesWritten;}'.!joystickHeaderFile	^ '#define MOUSESTICK_SIGNATURE 0x4A656666#define MAX_STICKS 4typedef struct {	short			rawX;				/* absolute stick position */	short			rawY;	unsigned char	buttons;	char			private1;	short			cursorX;			/* cursor position */	short			cursorY;	char			oldStickType;	char			private2;	char			stickOn;			/* true if stick is connected */	char			private3;	char			stickControlsCursor;	char			applicationAware;	/* settings change with application changes */	char			private4[152];} MouseStickRec;typedef struct {	long			signature;	char			private1[18];	short			stickCount;	char			private2[22];	MouseStickRec	stick[MAX_STICKS];} MouseStickSetRec, *MouseStickSetPtr;'.!macDirectoryFile	^ '#include <MacHeaders.h>#include "sq.h"/***	The interface to the directory primitive is path based.	That is, the client supplies a Squeak string describing	the path to the directory on every call. To avoid traversing	this path on every call, a cache is maintained of the last	path seen, along with the Mac volume and folder reference	numbers corresponding to that path.***//*** Constants ***/#define ENTRY_FOUND     0#define NO_MORE_ENTRIES 1#define BAD_PATH        2#define DELIMITOR '':''#define MAX_PATH 2000/*** Variables ***/char lastPath[MAX_PATH + 1];int  lastPathValid = false;int  lastRefNum = 0;int  lastVolNum = 0;/*** Functions ***/int convertToSqueakTime(int macTime);int equalsLastPath(char *pathString, int pathStringLength);int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr);int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr);int lookupVolume(char *volName, int *refNumPtr);int prefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);int recordPath(char *pathString, int pathStringLength, int refNum, int volNum);int convertToSqueakTime(int macTime) {	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than Mac one */	return macTime + (3 * 365 * 24 * 60 * 60);}int dir_Create(char *pathString, int pathStringLength) {	/* Create a new directory with the given path. By default, this	   directory is created in the current directory. Use	   a full path name such as "MyDisk:Working:New Folder" to	   create folders elsewhere. */	Str255 name;	HParamBlockRec pb;	int i;	for (i = 0; i < pathStringLength; i++) {		name[i] = pathString[i];	}	name[i] = 0; /* string terminator */	c2pstr((char *) name);	pb.fileParam.ioNamePtr = name;	pb.fileParam.ioVRefNum = 0;	pb.fileParam.ioDirID = 0;	return PBDirCreateSync(&pb) == noErr;}int dir_Delimitor(void) {	return DELIMITOR;}int dir_Lookup(char *pathString, int pathStringLength, int index,  /* outputs: */  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile) {	/* Lookup the index-th entry of the directory with the given path, starting	   at the root of the file system. Set the name, name length, creation date,	   creation time, directory flag, and file size (if the entry is a file).	   Return:	0 	if a entry is found at the given index	   			1	if the directory has fewer than index entries	   			2	if the given path has bad syntax or does not reach a directory	*/	int okay, newRefNum, newVolNum;	HVolumeParam volumeParams;	CInfoPBRec dirParams;	/* default return values */	*name             = 0;	*nameLength       = 0;	*creationDate     = 0;	*modificationDate = 0;	*isDirectory      = false;	*sizeIfFile       = 0;	if ((pathStringLength == 0)) {		/* get volume info */		volumeParams.ioNamePtr = (unsigned char *) name;		volumeParams.ioVRefNum = 0;		volumeParams.ioVolIndex = index;		okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;		if (okay) {			p2cstr((unsigned char *) name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(volumeParams.ioVCrDate);			*modificationDate = convertToSqueakTime(volumeParams.ioVLsMod);			*isDirectory      = true;			*sizeIfFile       = 0;			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	} else {		/* get file or directory info */		if (!!equalsLastPath(pathString, pathStringLength)) {			/* lookup and cache the refNum for this path */			okay = lookupPath(pathString, pathStringLength, &newRefNum, &newVolNum);			if (okay) {				recordPath(pathString, pathStringLength, newRefNum, newVolNum);			} else {				return BAD_PATH;			}		}		dirParams.hFileInfo.ioNamePtr = (unsigned char *) name;		dirParams.hFileInfo.ioFVersNum = 0;		dirParams.hFileInfo.ioFDirIndex = index;		if (lastRefNum < 0) {			dirParams.hFileInfo.ioVRefNum = lastRefNum;			dirParams.hFileInfo.ioDirID = 0;		} else {			dirParams.hFileInfo.ioVRefNum = lastVolNum;			dirParams.hFileInfo.ioDirID = lastRefNum;		}		okay = PBGetCatInfoSync(&dirParams) == noErr;		if (okay) {			p2cstr((unsigned char *) name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(dirParams.hFileInfo.ioFlCrDat);			*modificationDate = convertToSqueakTime(dirParams.hFileInfo.ioFlMdDat);			if ((dirParams.hFileInfo.ioFlAttrib & 16) !!= 0) {				*isDirectory  = true;				*sizeIfFile   = 0;			} else {				*isDirectory  = false;				*sizeIfFile   = dirParams.hFileInfo.ioFlLgLen;			}			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	}}int dir_PathToWorkingDir(char *pathName, int pathNameMax) {	/* Fill in the given string with the full path from a root volume to	   to current working directory. (At startup time, the working directory	   is set to the application''s directory. Fails if the given string is not	   long enough to hold the entire path. (Use at least 1000 characters to	   be safe.)	*/	char thisName[256];	CInfoPBRec pb;	int nextDirRefNum, pathLen;	/* initialize string copying state */	pathName[0] = 0;	pathLen = 0;	/* get refNum of working directory */	strcpy(thisName, ":");	pb.hFileInfo.ioNamePtr = c2pstr(thisName);	pb.hFileInfo.ioVRefNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	if (PBGetCatInfoSync(&pb) !!= noErr) {		nextDirRefNum = 0;	}	nextDirRefNum = pb.hFileInfo.ioDirID;	while (true) {		thisName[0] = 0;		pb.hFileInfo.ioFDirIndex = -1; /* map ioDirID -> name */		pb.hFileInfo.ioVRefNum = 0;		pb.hFileInfo.ioDirID = nextDirRefNum;		if (PBGetCatInfoSync(&pb) !!= noErr) {			break;  /* we''ve reached the root */		}		p2cstr((unsigned char *) thisName);		pathLen = prefixPathWith(pathName, pathLen, pathNameMax, thisName);		nextDirRefNum = pb.dirInfo.ioDrParID;	}	return pathLen;}dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Set the Macintosh type and creator of the given file. */	Str255 name;	FInfo finderInfo;	int i;	/* copy file name into a Pascal string */	if (filenameSize > 255) return false;	name[0] = filenameSize;	for (i = 1; i <= filenameSize; i++) {		name[i] = filename[i - 1];	}	if (GetFInfo(name, 0, &finderInfo) !!= noErr) return false;	finderInfo.fdType = *((int *) fType);	finderInfo.fdCreator = *((int *) fCreator);	if (SetFInfo(name, 0, &finderInfo) !!= noErr) return false;	return true;}int equalsLastPath(char *pathString, int pathStringLength) {	/* Return true if the lastPath cache is valid and the	   given Squeak string equals it. */	int i, ch;	if (!!lastPathValid ||		(pathStringLength > MAX_PATH)) {			return false;	}	for (i = 0; i < pathStringLength; i++) {		ch = lastPath[i];		if ((ch == 0) || (ch !!= pathString[i])) return false;	}	return lastPath[i] == 0;}int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr) {	/* Look up the next directory in a path starting from the folder and volume	   with the given reference numbers and setting *refNumPtr to the reference	   number of the resulting folder. Return true if this succeeds. */	CInfoPBRec pb;	c2pstr((char *) name);	pb.hFileInfo.ioNamePtr = (unsigned char *) name;	pb.hFileInfo.ioFVersNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioVRefNum = volRefNum;	pb.hFileInfo.ioDirID = folderRefNum;	if (PBGetCatInfoSync(&pb) == noErr) {		p2cstr((unsigned char *) name);		*refNumPtr = pb.hFileInfo.ioDirID;		return true;	}	p2cstr((unsigned char *) name);	return false;}int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr) {	/* Resolve the given path and return the resulting folder or volume	   reference number in *refNumPtr. Return false if the path is bad. */	char chunk[100];	int stIndex, chunkIndex, ch;	int okay, thisVolNum = 0, thisRefNum = 0;	int firstChunk = true, hasLeadingDelimitors = false;	stIndex = 0;	while (stIndex < pathStringLength) {		chunkIndex = 0;		while ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {			/* copy any leading delimitors */			chunk[chunkIndex++] = pathString[stIndex++];			hasLeadingDelimitors = true;		}		while ((stIndex < pathStringLength) && (pathString[stIndex] !!= DELIMITOR)) {			/* copy up to the next delimitor */			ch = chunk[chunkIndex++] = pathString[stIndex++];		}		if (firstChunk && (chunk[chunkIndex] !!= DELIMITOR)) {			/* Add a trailing delimiter to the first chunk of the			   path to indicate that it is a volume name. If the			   path starts with an initial delimitor, it will be			   interpreted as a path relative to the current working			   directory even with a trailing delimitor, which is			   exactly the behavior we want. */			chunk[chunkIndex++] = DELIMITOR;			if ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {				stIndex++;			}			firstChunk = false;		}		chunk[chunkIndex] = 0;  /* terminate this chunk */		if ((thisVolNum == 0) && !!hasLeadingDelimitors) {			okay = lookupVolume(chunk, &thisVolNum);			thisRefNum = 0;		} else {			okay = lookupDirectory(thisVolNum, thisRefNum, chunk, &thisRefNum);		}		if (!!okay) {			*refNumPtr = 0;			*volNumPtr = 0;			return false;		}	}	*refNumPtr = thisRefNum;	*volNumPtr = thisVolNum;	return true;}int lookupVolume(char *volName, int *refNumPtr) {	/* Look up the volume with the given name and set *refNumPtr	   to the reference number of the resulting volume.	   Return true if this succeeds. */	int okay;	HVolumeParam volumeParams;	volumeParams.ioNamePtr = c2pstr(volName);	volumeParams.ioVRefNum = 0;	volumeParams.ioVolIndex = -1;	okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;	p2cstr((unsigned char *) volName);	if (okay) {		*refNumPtr = volumeParams.ioVRefNum;		return true;	}	return false;}int prefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {	/* Insert the given prefix C string plus a delimitor character at the	   beginning of the given C string. Return the new pathName size. Fails	   if pathName is does not have sufficient space for the result.	   Assume: pathName is null terminated.	*/	int offset, i;	offset = strlen(prefix) + 1;	if ((pathNameSize + offset) > pathNameMax) {		error("path name to working directory is too long for available space");	}	for (i = pathNameSize; i >= 0; i--) {		/* make room in pathName for prefix (moving string terminator, too) */		pathName[i + offset] = pathName[i];	}	for (i = 0; i < offset; i++) {		/* make room in pathName for prefix */		pathName[i] = prefix[i];	}	pathName[offset - 1] = DELIMITOR;  /* insert delimitor */	return pathNameSize + offset;}int recordPath(char *pathString, int pathStringLength, int refNum, int volNum) {	/* Copy the given Squeak string into the lastPath cache. */	int i;	if (pathStringLength > MAX_PATH) {		lastPath[0] = 0; /* set to empty string */		lastPathValid = false;		lastRefNum = 0;		lastVolNum = 0;		return;	}	for (i = 0; i < pathStringLength; i++) {		lastPath[i] = pathString[i];	}	lastPath[i] = 0; /* string terminator */	lastPathValid = true;	lastRefNum = refNum;	lastVolNum = volNum;}'.!macJoystickFile	^ '#include "sq.h"#include "MouseStickII.h"#include <DeskBus.h>/*** global variable -- pointer to joystick data structure or nil ***/MouseStickSetPtr joySticks = nil;/*** joystick test functions ***/void joystickTest1(void);void joystickTest2(void);void joystickTest1(void) {	int i, inputWord, buttons;	joystickInit();	if ((joySticks == nil) || (joySticks->stickCount == 0)) {		printf("No joysticks currently connected\n");		return;	}	printf("Stick count: %d\n", joySticks->stickCount);	while (true) {		for (i = 1; i <= joySticks->stickCount; i++) {			inputWord = joystickRead(i);			if (inputWord !!= 0) {				buttons = (inputWord >> 22) & 0x1F;				printf("%d: %d [%o]    %d@%d\n",					i,					inputWord >> 27,					buttons,					((inputWord >> 11) & 0x7FF) - 0x400, 					(inputWord         & 0x7FF) - 0x400);				if (buttons & 4) return;			}		}	}}void joystickTest2(void) {	int i, buttons;	joystickInit();	if ((joySticks == nil) || (joySticks->stickCount == 0)) {		printf("No joysticks currently connected\n");		return;	}	printf("Found %d joysticks\n", joySticks->stickCount);	for (i = 0; i < joySticks->stickCount; i++) {		printf("Stick %d:", i + 1);		printf(" on: %d old: %d controlsCursor: %d applicationAware: %d\n",			joySticks->stick[i].stickOn,        	 joySticks->stick[i].oldStickType,			joySticks->stick[i].stickControlsCursor, joySticks->stick[i].applicationAware);	}	while (true) {		buttons = ~joySticks->stick[0].buttons & 255;		printf("1: [%x]   %d@%d => %d@%d\n",			buttons,			joySticks->stick[0].rawX, 			joySticks->stick[0].rawY,			joySticks->stick[0].cursorX,			joySticks->stick[0].cursorY);		if (buttons & 4) return;		buttons = ~joySticks->stick[1].buttons & 255;		printf("2: [%x]   %d@%d => %d@%d\n",			buttons,			joySticks->stick[1].rawX, 			joySticks->stick[1].rawY,			joySticks->stick[1].cursorX,			joySticks->stick[1].cursorY);		if (buttons & 4) return;	}}/*** exported functions ***/int joystickInit(void) {	/* Initialize the pointer to the joystick datastructure, if 	   a joystick is plugged in and its control panel is installed.	*/	ADBDataBlock adbGetInfo;	MouseStickSetPtr sticks;	int count, i;	joySticks = nil;  /* set to nil in case we don''t find any joysticks */	count = CountADBs();	for (i = 1; i <= count; i++) {		GetADBInfo(&adbGetInfo, GetIndADB(&adbGetInfo, i));		sticks = (MouseStickSetPtr) adbGetInfo.dbDataAreaAddr;		if ((sticks !!= nil) && (sticks->signature == MOUSESTICK_SIGNATURE)) {			joySticks = sticks;			return;		}	}}int joystickRead(int stickIndex) {	/* Return input word for the joystick with the given index (in range [1..2]).	   This word is encoded as follows:		<onFlag (1 bit)><buttonFlags (5 bits)><x-value (11 bits)><y-value (11 bits)>	   The highest four bits of the input word are zero. If the onFlag bit is zero,	   there is no joystick at the given index. This will be the case if a joystick	   is not connected or if the joystick control panel is not installed. In such,	   cases, the entire word will be zero. A maximum of two joysticks are supported	   by Gravis''s current version of the control panel. The x- and y- values are	   11-bit signed values in the range [-1024..1023] representing the raw (unencoded)	   joystick position. The MouseStick II only uses the approximate range [-650..650].	*/	MouseStickRec stickData;	int buttons, xBits, yBits;	if ((joySticks == nil) || (stickIndex < 1) || (stickIndex > 2) ||		(stickIndex > joySticks->stickCount)) {			return 0;  /* no joystick at the given index */	}	stickData = joySticks->stick[stickIndex - 1];  /* 1-based index */	buttons = ~stickData.buttons & 0x1F;	xBits = (0x400 + stickData.rawX) & 0x7FF;	yBits = (0x400 + stickData.rawY) & 0x7FF;	return (1 << 27) | (buttons << 22) | (yBits << 11) | xBits;}'.!macSoundFile	^ '#include <MacHeaders.h>#include <Sound.h>#include "sq.h"/******  Mac Sound Notes:	On Macs that support it (all PPC Macs, I believe), 16-bit sound should	be used. I measured a slight increase in overhead for background sound	generation (5% to 7.5% for 16-bit sound version 2.5% to 5% for 8-bit).	The cost of copying the larger buffer in snd_PlaySamplesFromAtLength	was too small to easily measure in both 8-bit and 16-bits. On the other	hand, 16-bits give far, far superiour sound quality.	My understanding is that SoundManager 3.0 or later supports the 16-bit	sound interface an all Macs, even if the hardware only supports 8-bits.	If this is not true, however, change BYTES_PER_SAMPLE to 1. Then, either	the Squeak code will need to be changed to use 8-bit sound buffers,	or (preferrably) snd_PlaySamplesFromAtLength will need to do the conversion	from 16 to 8 bits. I plan to cross that bridge if and when we need to.	The code as currently written was to support Squeak code that generated	8-bit sound buffers.	Here are the various sound buffer formats from Squeak:		1. mono,    8-bits -- packed array of bytes		2. stereo,  8-bits -- as above, with L and R channels in alternate bytes		3. mono,   16-bits -- array of 32-bit words, samples in low-order 16 bits (high bits ignored)		4. stereo, 16-bits -- array of 32-bit words; with L and R channels in high and low half-words	Note:  8-bit samples are encoded with 0x80 as the center (zero) value	Note: 16-bit samples are encoded as standard, signed integers (i.e., 2''s-complement)	-- John Maloney, July 28, 1996******/#define BYTES_PER_SAMPLE 2/*** double-buffer state record ***/typedef struct {	int open;	int stereo;	int frameCount;	int bufSizeInBytes;	int bufState0;	int bufState1;	int done;} BufferStateRec;/*** possible buffer states ***/#define BUF_EMPTY	0#define BUF_FULL	1#define BUF_PLAYING	2/*** variables ***/SndChannelPtr chan;BufferStateRec bufState = {false, false, 0, 0, NULL, NULL, true};SndDoubleBufferHeader dblBufHeader;/*** local functions ***/pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf);int FillBufferWithSilence(SndDoubleBufferPtr buf);pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf) {	BufferStateRec *state;	chan;  /* reference argument to avoid compiler warnings */	/* insert a click to help user detect failure to fill buffer in time */	*(unsigned int *) &buf->dbSoundData[0] = 0;	*(unsigned int *) &buf->dbSoundData[4] = 0xFFFFFFFF;	state = (BufferStateRec *) buf->dbUserInfo[0];	if (buf->dbUserInfo[1] == 0) {		state->bufState0 = BUF_EMPTY;		state->bufState1 = BUF_PLAYING;	} else {		state->bufState0 = BUF_PLAYING;		state->bufState1 = BUF_EMPTY;	}	buf->dbNumFrames = state->frameCount;	buf->dbFlags = buf->dbFlags | dbBufferReady;	if (state->done) {		FillBufferWithSilence(buf);		buf->dbFlags = buf->dbFlags | dbLastBuffer;	}}int FillBufferWithSilence(SndDoubleBufferPtr buf) {	unsigned int *sample, *lastSample;	sample		= (unsigned int *) &buf->dbSoundData[0];	lastSample	= (unsigned int *) &buf->dbSoundData[bufState.bufSizeInBytes];	/* word-fill buffer with silence */	if (BYTES_PER_SAMPLE == 1) {		while (sample < lastSample) {			*sample++ = 0x80808080;  /* Note: 0x80 is zero value for 8-bit samples */		}	} else {		while (sample < lastSample) {			*sample++ = 0;		}	}}/*** exported functions ***/int snd_AvailableSpace(void) {	if (!!bufState.open) return -1;	if ((bufState.bufState0 == BUF_EMPTY) ||		(bufState.bufState1 == BUF_EMPTY)) {			return bufState.bufSizeInBytes;	}	return 0;}int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex) {	SndDoubleBufferPtr buf;	int framesWritten;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		buf = dblBufHeader.dbhBufferPtr[0];		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			buf = dblBufHeader.dbhBufferPtr[1];			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	if (bufState.frameCount < frameCount) {		framesWritten = bufState.frameCount;	} else {		framesWritten = frameCount;	}	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) (arrayIndex + startIndex);		end = (unsigned char *) src + (framesWritten * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) &buf->dbSoundData[0];		while (src < end) {			*dst++ = *src++;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (arrayIndex + (startIndex * 4));		end = (short int *) (arrayIndex + ((startIndex + framesWritten) * 4));		dst = (short int *) &buf->dbSoundData[0];		if (bufState.stereo) {  /* stereo */			while (src < end) {				*dst++ = *src++;			}		} else {  /* mono */			/* if mono, skip every other frame of the source */			while (src < end) {				src++;  /* skip high word */				*dst++ = *src++;			}		}	}	return framesWritten;}int snd_PlaySilence(void) {	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		FillBufferWithSilence(dblBufHeader.dbhBufferPtr[0]);		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			FillBufferWithSilence(dblBufHeader.dbhBufferPtr[1]);			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	return bufState.bufSizeInBytes;}int snd_Start(int frameCount, int samplesPerSec, int stereo) {	OSErr				err;	SndDoubleBufferPtr	buffer;	int					bytesPerFrame, bufferBytes, i;	bytesPerFrame			= stereo ? 2 * BYTES_PER_SAMPLE : BYTES_PER_SAMPLE;	bufferBytes				= ((frameCount * bytesPerFrame) / 8) * 8;		/* Note: Must round bufferBytes down to an 8-byte boundary to avoid clicking!!!!!! */	if (bufState.open) {		/* still open from last time; clean up before continuing */		snd_Stop();	}	bufState.open			= false;  /* set to true if successful */	bufState.stereo			= stereo;	bufState.frameCount		= bufferBytes / bytesPerFrame;	bufState.bufSizeInBytes	= bufferBytes;	bufState.bufState0  	= BUF_EMPTY;	bufState.bufState1  	= BUF_EMPTY;	bufState.done			= false;	dblBufHeader.dbhNumChannels		= stereo ? 2 : 1;	dblBufHeader.dbhSampleSize		= BYTES_PER_SAMPLE * 8;	dblBufHeader.dbhCompressionID	= 0;	dblBufHeader.dbhPacketSize		= 0;	dblBufHeader.dbhSampleRate		= samplesPerSec << 16; /* convert to fixed point */	dblBufHeader.dbhDoubleBack		= NewSndDoubleBackProc(DoubleBack);	chan = NULL;	err = SndNewChannel(&chan, sampledSynth, 0, NULL);	if (err !!= noErr) return false; /* could not open sound channel */	for (i = 0; i < 2; i++) {		buffer = (SndDoubleBufferPtr) NewPtrClear(sizeof(SndDoubleBuffer) + bufState.bufSizeInBytes);		if (buffer == NULL) return false; /* could not allocate memory for a buffer */		buffer->dbNumFrames		= bufState.frameCount;		buffer->dbFlags			= dbBufferReady;		buffer->dbUserInfo[0]	= (long) &bufState;		buffer->dbUserInfo[1]	= i;		FillBufferWithSilence(buffer);		dblBufHeader.dbhBufferPtr[i] = buffer;	}	err = SndPlayDoubleBuffer(chan, &dblBufHeader);	if (err !!= noErr) return false; /* could not play double buffer */	bufState.open = true;	return true;}int snd_Stop(void) {	OSErr				err;	SndDoubleBufferPtr	buffer;	SCStatus			status;	long				i, junk;	if (!!bufState.open) return;	bufState.done = true;	while (true) {		err = SndChannelStatus(chan, sizeof(status), &status);		if (err !!= noErr) break; /* could not get channel status */		if (!!status.scChannelBusy) break;		Delay(1, &junk);	}	SndDisposeChannel(chan, true);	DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);	for (i = 0; i < 2; i++) {		buffer = dblBufHeader.dbhBufferPtr[i];		if (buffer !!= NULL) {			DisposePtr((char *) buffer);		}		dblBufHeader.dbhBufferPtr[i] = NULL;	}	bufState.open = false;}'.!macWindowFile	^ '#include <MacHeaders.h>#include <Timer.h>#include <profiler.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern unsigned char *memory;extern int interruptKeycode;extern int interruptPending;extern int interruptCheckCounter;/*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 40char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the file name, reported on launch */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;Handle			clipboardBuffer = nil;MenuHandle		editMenu = nil;MenuHandle		fileMenu = nil;int				savedWindowSize = 0;  /* set by readImageFile() */CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>   */ char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);void RecordFullPathForImageName(char *localImageName);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {			AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked application; look for "clone.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "clone.image");	return noErr;}pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) goto done;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;	if (numFiles !!= 1) {		error("You may only open one Squeak image file at a time.");	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;	strcpy(shortImageName, p2cstr(fileSpec.name));	/* make image directory the default */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetItem(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ExitToShell();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AddResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 32768, 32768, 32768);	/* 50% gray */	SetColorEntry(3, 65535, 65535,     0);	/* yellow */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535,     0, 65535);	/* magenta */	SetColorEntry( 9,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(10, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(11, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(12, 32768, 32768, 32768);	/* 4/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = { 44, 8, 408, 648 };  /* default window bounds */	Rect screen;	int right, bottom;	if (savedWindowSize !!= 0) {		right  = windowBounds.left + ((unsigned) savedWindowSize >> 16);		bottom = windowBounds.top  + (savedWindowSize & 0xFFFF);	} else {		right  = windowBounds.right;		bottom = windowBounds.bottom;	}	/* minimum size is 64 x 64 */	right  = ( right > (windowBounds.left + 64)) ?  right : (windowBounds.left + 64);	bottom = (bottom > (windowBounds.top  + 64)) ? bottom : (windowBounds.top  + 64);	/* maximum bottom-right is screen bottom-right */	screen = qd.screenBits.bounds;	right  = ( right <= screen.right)  ?  right : (screen.right  - 8);	bottom = (bottom <= screen.bottom) ? bottom : (screen.bottom - 8);	windowBounds.right = right;	windowBounds.bottom = bottom;	stWindow = NewCWindow(0L, &windowBounds, "\pSqueak", true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowSize(void);void SetWindowSize(void) {	Rect screen;	int width, height, maxWidth, maxHeight;	if (savedWindowSize !!= 0) {		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;	} else {		width  = 640;		height = 480;	}	/* minimum size is 64 x 64 */	width  = ( width > 64) ?   width : 64;	height = (height > 64) ?  height : 64;	/* maximum size is screen size */	screen = qd.screenBits.bounds;	maxWidth  = (screen.right  - screen.left) - 16;	maxHeight = (screen.bottom - screen.top)  - 52;	width  = ( width <= maxWidth)  ?  width : maxWidth;	height = (height <= maxHeight) ? height : maxHeight;	SizeWindow(stWindow, width, height, true);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than ioMSecs!!!!) */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}#endif}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	Cursor macCursor;	int i;	for (i = 0; i < 16; i++) {		macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void RecordFullPathForImageName(char *localImageName) {	int offset, localNameSize, i;	offset = dir_PathToWorkingDir(imageName, IMAGE_NAME_SIZE);	/* copy the file name into a null-terminated C string */	localNameSize = strlen(localImageName);	for (i = 0; i <= localNameSize; i++) {		/* append localName, including terminator */		imageName[i + offset] = localImageName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		imageName[i] = sqImageName[i];	}	imageName[count] = 0;	return count;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	if (memory == nil) {		return;	/* failed to read image */	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	strcpy(imageName, fullImagePath);	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	SetUpClipboard();	SetUpPixmap();	sqFileInit();	joystickInit();}int plugInShutdown(void) {	snd_Stop();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	sqFileInit();	joystickInit();	/* install apple event handlers and wait for open event */	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	RecordFullPathForImageName(shortImageName);	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	readImageFile(imageName);	SetWindowSize();	/* run Squeak */	interpret();}#endif'.!readmeFile	^ 'Building the Squeak Virtual MachineThe virtual machine is build from ten source and header files:	sq.h					-- shared definitions included in all .c files	MouseStickII.h		-- definitions for Gravis MouseStickII joystick	sqFilePrims.c		-- file primitives	sqSaveRestore.c		-- image file reading/writing	sqMacDirectory.c	-- Mac directory enumerations	sqMacJoystick.c		-- primitives to support Gravis MouseStickII joystick	sqMacSound.c		-- Mac audio output primitives	sqMacWindow.c		-- Mac window and event handling; main program	sqSoundPrims.c		-- automatically generated sound synthesis primitives	interpXXX.c			-- automatically generated code for the virtual machineThe only files that are Mac-specific are stMacWindow.c, stMacDirectory.c, stMacJoystick.c, and stMacSound.c, totaling about 1800 lines of code when this document was written. All other code is written to standard ANSI libraries and should port easily to other C environments.The code assumes that C ints and floats are both 8 bytes; this assumption is checked at start up time.The XXX in interpXXX.c represents the current version number. This file is generated automatically, so changes to this file will be lost when the next interpreter is generated. It is fine to make ephemeral changes to this file for the purpose of debugging or statistics gathering. To generate this file, see the "translation" category in Interpreter class.The current VM was compiled with Metrowerks CodeWarrier 8. Earlier, I used Semantec Think C 6.0, but discovered a few bugs in their libraries having to do with 8-byte versus 4-byte integers. These bugs could probably be worked around if one really wanted to use that environment.The virtual machine uses the following libraries:	Libraries for 68K Project:		MathLib68K (4i/8d).Lib		MacOS.lib		profiler68k(Small).lib		SIOUX.68K.Lib		ANSI (4i/8d) C.68K.lib	Libraries for PowerPC Project:		ANSI C.PPC.Lib		SIOUX.PPC.Lib		InterfaceLib		profilerPPC.lib		MathLib		MWCRuntime.LibTo build a fat binary, build the 68K version first, and make sure that the file "Squeak VM 68K" is included in the PowerPC project. Then build the PowerPC version. CodeWarrier will include the 68K interpreter in the resource fork of the output file, resulting in an interpreter that runs on either 68K or PowerPC Macs. To get an additional speedup, the object code for the bytecode dispatch loop can be patched using the method "patchInterp:" in Interpreter class.	-- John Maloney, September 22, 1996'.!saveRestoreFile	^ '#include <MacHeaders.h>#include "sq.h"/***	Note: There is a slight asymmetry in error handling here. readImageFile is called	only from C code at startup time. If it encounters problems, it reports an error	and quits. If it returns, it is assumed to have succeeded. In contrast, writeImageFile	is called from a primitive. If it fails, it prints an error, sets successFlag to	false, and continues. This allows the user to correct the problem and try again.***//*** imported variables (typically initialized by readImageFile, saved by writeImageFile) ***/extern int endOfMemory, lastHash, memoryLimit, specialObjectsOop, successFlag;extern unsigned char *memory;extern int savedWindowSize;extern char imageName[];/*** local functions ***/int nextWord(FILE *f);int nextWordPut(FILE *f, int word);int nextWord(FILE *f) {	int result, count;	count = fread(&result, sizeof(int), 1, f);	if (count !!= 1) {		error("Read failed in nextWord");	}	return result;}int nextWordPut(FILE *f, int word) {	int count;	count = fwrite(&word, sizeof(int), 1, f);	if (count !!= 1) {		printf("Write failed in nextWordPut\n");		return success(false);	}}/*** image file read/write ***/int readImageFile(char *imageFilename) {	FILE	*f;	int		version, headerSize, dataSize, oldBaseAddr, bytesToShift;	int		availableMemory, minimumMemory, err, count;	f = fopen(imageFilename, "rb");	if (f == NULL) {		printf("Could not open the Squeak image file ''%s''\n\n", imageFilename);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''clone.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ExitToShell();	}	version				= nextWord(f);	headerSize			= nextWord(f);	dataSize			= nextWord(f);	oldBaseAddr			= nextWord(f);	specialObjectsOop	= nextWord(f);	lastHash			= nextWord(f);	savedWindowSize		= nextWord(f);	if (lastHash == 0) {		/* lastHash wasn''t stored (e.g. by the cloner); use 999 as the seed */		lastHash = 999;	}	if (version > CURRENT_VERSION) {		printf("This interpreter (vers. %d) cannot read a newer image file (vers. %d)\n",				CURRENT_VERSION, version);		error("Aborting...");	}	/* compute memory requirements and availability */	minimumMemory = dataSize + 20000;	availableMemory = MaxBlock() - 80000;  /* reserve a little memory (use at least 50000) */	/******	  Note: 30K is too little; 40K allows ST to run but crashes if console is opened		50K works and allows the console to be opened (with and w/o the profiler)		increase this by 10-30K to provide for sound buffers and reliability	******/	if (availableMemory < minimumMemory) {		error("Could not allocate memory for the heap");	}	/* allocate a contiguous block of memory for the Squeak heap */	memory = (unsigned char *) NewPtr(availableMemory);	if (memory == NULL) {		error("Failed to allocate memory for the heap");	}	memoryLimit = (((int) memory) + availableMemory) - 24;  /* decrease memoryLimit a tad for safety */	endOfMemory = ((int) memory) + dataSize;	/* position file after the header */	err = fseek(f, headerSize, SEEK_SET);	if (err) {		error("Seek failed; bad image file, perhaps?");	}	/* read in the image */	count = fread(memory, sizeof(unsigned char), dataSize, f);	if (count !!= dataSize) {		error("Read failed or premature end of image file");	}	fclose(f);	/* compute difference between old and new memory base addresses */	bytesToShift = ((int) memory) - oldBaseAddr;	initializeInterpreter(bytesToShift);  /* adjusts all oops to new location */	return dataSize;}int writeImageFile(int imageBytes) {	int		headerSize = 64;  /* header size in bytes */	int		err, count;	FILE	*f;	successFlag = true;	f = fopen(imageName, "wb");	if (f == NULL) {		printf("Could not open image file for writing: %s\n", imageName);		return success(false);	}	nextWordPut(f, CURRENT_VERSION);	nextWordPut(f, headerSize);	nextWordPut(f, imageBytes);	nextWordPut(f, (int) memory);	nextWordPut(f, specialObjectsOop);	nextWordPut(f, lastHash);	nextWordPut(f, ioScreenSize());	if (!!successFlag) {		return success(false);	}	/* position file after the header */	err = fseek(f, headerSize, SEEK_SET);	if (err) {		printf("Seek failed in writeImageFile\n");		return success(false);	}	/* write out the image */	count = fwrite(memory, sizeof(unsigned char), imageBytes, f);	if (count !!= imageBytes) {		printf("Writing image file failed; disk full, perhaps?\n");		return success(false);	}	err = fclose(f);	if (err) {		printf("Closing image file failed; disk full, perhaps?\n");		return success(false);	}	dir_SetMacFileTypeAndCreator(imageName, strlen(imageName), "STim", "FAST");}'.!squeakHeaderFile	^ '#include <Events.h>#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>/*** increment this version number when the image file format changes ***/#define CURRENT_VERSION 6502/* Squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMicroMSecs(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);/* millisecond clock based on vertical retrace timer (1/60th second) */#define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)/* event capture */int recordMouseDown(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordKeystroke(EventRecord *theEvent);/* image file and VM path names */int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFile(char *imageFilename);int writeImageFile(int imageBytes);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* sound output */int snd_AvailableSpace(void);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo);int snd_Stop(void);/* joystick support */int joystickInit(void);int joystickRead(int stickIndex);/* netscape plug-in support */int plugInInit(char *imageName);int plugInShutdown(void);int plugInInterpretCycles(int cycleCount);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* sound generation primitives */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);'.! !!LiteralNode methodsFor: 'C translation'!asTranslatorNode 	^TConstantNode new setValue: key! !!MessageNode methodsFor: 'C translation'!asTranslatorNode	"selector is sometimes a Symbol, sometimes a SelectorNode!!	On top of this, numArgs is needed due to the (truly grody) use of	arguments as a place to store the extra expressions needed to generate	code for in-line to:by:do:, etc.  see below, where it is used."	| sel args |	sel _ (selector isMemberOf: Symbol) ifTrue: [selector] ifFalse: [selector key].	args _ (1 to: sel numArgs) collect:			[:i | (arguments at: i) asTranslatorNode].	(sel = #to:by:do: and: [arguments size = 7 and: [(arguments at: 7) notNil]])		ifTrue: ["Restore limit expr that got moved by transformToDo:"				args at: 1 put: (arguments at: 7) value asTranslatorNode].	(sel = #or: and: [arguments size = 2 and: [(arguments at: 2) notNil]])		ifTrue: ["Restore argument block that got moved by transformOr:"				args at: 1 put: (arguments at: 2) asTranslatorNode].	(sel = #ifFalse: and: [arguments size = 2 and: [(arguments at: 2) notNil]])		ifTrue: ["Restore argument block that got moved by transformIfFalse:"				args at: 1 put: (arguments at: 2) asTranslatorNode].	^ TSendNode new		setSelector: sel		receiver: ((receiver == nil)					ifTrue: [nil]					ifFalse: [receiver asTranslatorNode])		arguments: args! !!MethodNode methodsFor: 'C translation'!asTMethodFromClass: aClass 	^TMethod new		setSelector: selectorOrFalse		args: arguments		locals: temporaries		block: block! !!MixedSound methodsFor: 'sound generation'!samplesRemaining	| remaining r |	remaining _ 0.	1 to: sounds size do: [ :i |		r _ (sounds at: i) samplesRemaining.		r > remaining ifTrue: [ remaining _ r ].	].	^ remaining! !NameCostume comment:'A costume that shows the name of object wearing it.'!!NameCostume methodsFor: 'display'!display: anObject onCanvas: aCanvas	"Display the object's name on the given canvas.  NB: this is not the way object names beneath the objects are shown, but rather the way that an object wears its own name as a costume.  6/7/96 sw"	anObject name displayOn: aCanvas! !!NibBox methodsFor: 'initialization'!adjustBoxToMatchNibSize	nibSize > 4 ifTrue:		[rectangle _ (rectangle center corner: rectangle center) insetBy: (nibSize // 2) negated]!color: aColor nibSize: aNibSize rectangle: aRectangle rounded: roundBoolean	color _ aColor.	nibSize _ aNibSize.	rectangle _ aRectangle.	isRounded _ roundBoolean!nibSize: aSize	nibSize _ aSize! !!NibBox methodsFor: 'display'!display	self isRound ifFalse:		[Display fill: self innerRect fillColor: color]	ifTrue:		[(self roundedNibDots at: nibSize) displayOn: Display at: rectangle center]!highlight	(self innerRect insetBy: (-2 @ -2)) display: Color black!innerRect	| demiNib |	demiNib _ 1 + (nibSize //2).	^ (rectangle center corner: rectangle center) insetBy: (demiNib @ demiNib) negated!isRound	^ isRounded == true!unHighlight	(self innerRect insetBy: (-2 @ -2)) display: Color white! !!NibBox methodsFor: 'accessing'!nibSize	^ nibSize!rectangle	^ rectangle!roundedNibDots	RoundedNibDots == nil ifTrue:		[self initializeNibDots].	^ RoundedNibDots! !!NibBox class methodsFor: 'as yet unclassified'!initializeNibDots	"NibBox initializeNibDots"	RoundedNibDots _ Dictionary new.	PaintPalette new standardNibWidths do:		[:n | RoundedNibDots at: n  put: (Form dotOfSize: n)] ! !NumberObj comment:'An object whose contents are meant to be numeric'!!NumberObj methodsFor: 'everything'!currentNumericValue	"Answer the current numeric value of the receiver.  Needed by Slider costumes.  7/16/96 sw"	^ contents!maximumValue	"For the use of slider costumes, answer the maximum value the receiver is expected to attain.  Sliders map their height to the object's (minimumValue, maximumValue) range.  7/16/96 sw"	^ 100!minimumValue	"For the use of slider costumes, answer the minimum value the receiver is expected to attain.  Sliders map their height to the object's (minimumValue, maximumValue) range.  7/16/96 sw"	^ 0!setDefaultContents	"For a newly-launched object, set its contents to a default value, if appropriate. 6/2/96 sw.	7/13/96 sw: random initial contents." 	contents _ 99 atRandom!type	"Answer the receiver's formal type.  6/12/96 sw"	^ #Number! !Obj comment:'The ancestor class for all user-sensible objects.  2/19/96 swA simple containment hierarchy is enforced, so that every object has a backpointer.  etc'!!Obj methodsFor: 'copying'!clonedInstance	"Answer a new Obj that starts out life with the same set of methods as the receiver has.  5/13/96 sw	7/13/96 sw: use newUserInstance"	| anInstance |	anInstance _ self class officialClass newUserInstance.	anInstance copyStateFrom: self.	anInstance class copyMethodDictionaryFrom: self class.	^ anInstance!contentsCopy	"Squeak: the receiver, serving as the contents of a Squeak object, wishes to have a suitable copy returned.  For most possible contents, the shallow is right; for a collection, i.e. for Folder contents, it is handled in a special-case way.  For alias-valued objects, we come to the crux: the receiver, rather than a copy thereof, must be returned.  6/6/96 sw"	^ self!copyContentsFrom: donor	"Copy the donor's contents to the receiver.  7/17/96 sw"	contents _ donor contents contentsCopy!copyStateFrom: donor	"Copy the donor object's state into the receiver's instance variables.  5/15/96 sw	 5/16/96 sw: make it worked for nested guys as well	 6/2/96 sw: copy over contents	 7/17/96 sw: removed velocity, added speed, heading.	 7/17/96 sw: shift to using copyContentsFrom:"	| subs newSub |	windowBounds _ donor windowBounds deepCopy.	heading _ donor heading deepCopy.	speed _ donor speed deepCopy.	self copyContentsFrom: donor.	layoutRectangle _ donor layoutRectangleIfDefined deepCopy.	self invalidateCanvas.	flags _ donor flags deepCopy.	currentCostume _ donor currentCostume.	self copyParametersFrom: donor.	"What about the costume list, damnit??!!"	(subs _ donor workingsBackToFront) size > 0 ifTrue:		[subs do:			[:aSub | newSub _ aSub clonedInstance.			self addToWorkings: newSub atKey: aSub name]]! !!Obj methodsFor: 'costume'!advanceAnimationFor: anObject in: aView	"The receiver, acting as a costume for anObject, is asked to advance to the next phase in the animation.  8/12/96 sw" !assumePictureCostumeAndResizeAccordingly	"Does what the name implies...  6/10/96 sw"	self useStandardCostumeNamed: 'Picture'.	self setExtentToMatchCostume!assumePictureCostumeNamed: aName	"Make the user wear a picture costume of the given name.  Get the receiver's size right.	 6/10/96 sw"	self useStandardCostumeNamed: 'Picture'.	self setParameter: aName forKey: #PictureName.	self setExtentToMatchCostume!assumeRotationCostumeNamed: aName	"Make the user wear a rotation costume of the given name.  Get the receiver's size right. 6/28/96 sw"	self useStandardCostumeNamed: 'Rotation'.	self setParameter: aName forKey: #RotationName.	self setExtentToMatchCostume!costumeNamed: aName	"Answer the standard system costume of the given name.  6/12/96 sw"	^ self class costumeLibrary contentsAtKey: aName!costumeNames	"Answer a list of costume names available for the receiver"	| costumeList |	costumeList _ Obj costumeLibrary contents select:		[:elem | elem isKindOf: Costume].	^ (costumeList		select:			[:aCostume | aCostume couldBeWornBy: self]		thenCollect:			[:aCostume | aCostume name]) asSortedArray!costumes	"Answer the receiver's list of personal costumes.  This feature is rather in transition at present.  6/12/96 sw"	costumes == nil		ifTrue:			[costumes _ FastDictionary new].	^ costumes			!currentCostume	"Answer the receiver's current costume.  5/17/96 sw"	currentCostume == nil		ifTrue:			[costumes size == 0 ifTrue:				[costumes _ FastDictionary new.				costumes at: 'default' put: self].			currentCostume _ self].	^ currentCostume			!currentCostume: aCostume	"Set the receiver's costume to be aCostume; to be cricket, aCostume is assumed to exist in the system's containment hierarchy somewhere, because the currentCostume slot is not intended as an 'owning' replationship.  6/2/96 sw"	currentCostume _ aCostume!currentElementFor: anObject	"Acting as a single-element costume for anObject, return the current contents-element of anObject  6/1/96 sw"	| parm |	parm _ anObject parameterFor: #CurrentElement.	parm == nil ifTrue:		[parm _ anObject contentsBackToFront size > 0			ifTrue: [anObject contentsBackToFront first]			ifFalse: [nil]].	^ parm!currentlyRevealingContentsIn: aTopView	"Answer if the receiver is wearing a costume that reveals a list of contents subparts.  6/12/96 sw"	^ self currentCostume revealsContentsFor: self!currentlyRevealingWorkingsIn: aTopView	"Answer if the receiver is wearing a costume that reveals a list of workings subparts.  6/12/96 sw"	^ self currentCostume revealsWorkingsFor: self!hasCostumeSet	"Answer whether the receiver already has costume specified.  6/28/96 sw"	^ currentCostume ~~ nil!mimicCostumeOf: anotherObject	"Try to wear the same costume as anotherObject.  6/12/96 sw.	7/18/96 sw: switch to parameters"	currentCostume _ anotherObject currentCostume.	currentCostume == anotherObject		ifTrue:			[^ self].	self copyParametersFrom: anotherObject.	(anotherObject costumes includes: currentCostume)		ifTrue:			[self costumes add: currentCostume]	!parameterFor: aKey	"Answer the parameters stored on behalf of the given key, if any. 7/18/96 sw"	^ self parameters at: aKey ifAbsent: [nil]!parameterFor: aKey ifAbsent: aBlock	"Answer the parameters stored for the given key, or, if none, the results of evaluating aBlock. 7/18/96 sw"	^ self parameters at: aKey ifAbsent: [aBlock value]!parameters	"Answer the receiver's parameters dictionary.  7/18/96 sw"	parameters == nil ifTrue:		[parameters _ FastDictionary new].	^ parameters!pictureNameFor: anObject	"Acting as a costume for anObject, return form representing its desired picture.  6/1/96 sw	 7/12/96 sw: trying alternate default"	| parm |	^ (parm _ anObject parameterFor: #PictureName) == nil		ifFalse:			[parm]		ifTrue:			[self defaultPictureNameFor: anObject]!revealsContentsFor: anObject	"Answer if the receiver, used as a costume for anObject, reveals contents subparts.  6/3/96 sw"	^ false!revealsWorkingsFor: anObject	"Answer whether, acting as a costume for anObject, the receiver reveals workings subparts"	^ anObject == self and: [self workingsBackToFront size > 0]!setDefaultCostume	"Set up an initial costume for the receiver, if desired.  6/12/96 sw"	currentCostume _ self type == #Object		ifTrue:			[self costumeNamed: 'Picture']		ifFalse:			[self costumeNamed: 'Contents String']!setParameter: parm forKey: aKey	"Stash parameters dictionary, under given key.  7/18/96 sw"	self parameters at: aKey put: parm!useStandardCostumeNamed: aName	"Make the receiver's currentCostume be the system costume of the given name.   6/2/96 sw"	| aCostume |	aCostume _ self costumeNamed: aName.	aCostume == nil ifTrue: [^ self beep].	self currentCostume: aCostume! !!Obj methodsFor: 'halo'!displayHaloIn: aView	"The receiver is the current halo object; draw its halo around itself.  Just the rawest of beginnings here.  There would seem to be extensive scope for optimization -- at least for caching the rectangles and Quadrangles and reusing them if the receiver remains the halo object and does not move or get resized.   6/6/96 sw	6/22/96 sw: add ears at top for resizing"	| aRectangle  topHaloRect quad leftHaloRect earRect aCanvas showUpperEars menuAreaTop |	aRectangle _ self layoutRectangle.	aCanvas _ aView canvas.	topHaloRect _ (aRectangle topLeft - (0 @ ObjectHaloWidth))		extent: (aRectangle width @ ObjectHaloWidth).	quad _ Quadrangle region: topHaloRect borderWidth: 1 borderColor: Color black insideColor: Color magenta.	quad displayOn: aCanvas.	showUpperEars _ aRectangle height > 20.	earRect _ (aRectangle bottomLeft - (ObjectHaloWidth @ ObjectHaloWidth)) extent: ObjectHaloWidth @ ObjectHaloWidth.	quad _ Quadrangle region: earRect borderWidth: 1 borderColor: Color black insideColor: Color lightYellow.	quad displayOn: aCanvas.  "the lower-left resize box"	(quad align: quad topLeft with: aRectangle bottomRight - ((0 @ ObjectHaloWidth)))		displayOn: aCanvas.   "the lower-right resize box"	showUpperEars ifTrue:		[(quad align: quad topLeft with: aRectangle topLeft - (ObjectHaloWidth @ ObjectHaloWidth))			displayOn: aCanvas.  "the upper-left resize box"		(quad align: quad topLeft with: aRectangle topRight - ((0 @ ObjectHaloWidth)))			displayOn: aCanvas].  "the upper-right resize box"	menuAreaTop _ showUpperEars		ifFalse:			[aRectangle top - ObjectHaloWidth]		ifTrue:			[aRectangle top].	leftHaloRect _ ((aRectangle left - ObjectHaloWidth) @ menuAreaTop) corner:		(aRectangle left @ (aRectangle bottom - ObjectHaloWidth)).	"leftHaloRect _ aRectangle topLeft - (ObjectHaloWidth @ 0) extent: (ObjectHaloWidth @ (aRectangle height - ObjectHaloWidth))."	quad _ Quadrangle region: leftHaloRect borderWidth: 1 borderColor: Color black insideColor: Color cyan.	quad displayOn: aCanvas.	(quad align: quad bottomLeft with: (aRectangle bottomRight - (0@ ObjectHaloWidth))) displayOn: aCanvas.		quad _ Quadrangle region: (aRectangle bottomLeft - (0 @ 1) corner: (aRectangle bottomRight)) borderWidth: 0 borderColor: Color black insideColor: Color black.	quad displayOn: aCanvas!haloRectangle	"Answer a rectangle that encloses the object and its halo.  6/11/96 sw"	|  aRect |	aRect _ self layoutRectangle.	^ (aRect origin - (ObjectHaloWidth @ ObjectHaloWidth)) extent:		(aRect extent + ((2*ObjectHaloWidth) @ ObjectHaloWidth))!haloWidth	"Return the standard system-wide Object-halo width.  6/11/96 sw"	^ ObjectHaloWidth! !!Obj methodsFor: 'display'!borderWidth	"Answer the width of border to be used when drawing the receiver with its subparts visible within.  User-overridable.  5/17/96 sw"	^ 1!canvasValid	"Answer if the receiver's canvas is known to represent the correct current visible manifiestation.  6/7/96 sw"	^ canvasValid & (canvas ~~ nil)!couldWearStringCostume	"Answer whether the receiver could wear a string costume.  9/20/96 sw"	^ (self class officialClass == Obj) not!defaultFrameDrawingParameter	"Answer whether the receiver, acting as a costume, wishes (by default) to have a frame drawn around the object.  8/13/96 sw"	^ false!display: anObject onCanvas: aCanvas	"Acting in a costuming role, display anObject on the specified canvas.  The normal situation is that the object just displays itself, but this allows objects to serve as 'costumes' for othe objects.  5/17/96 sw"	anObject userDisplayOn: aCanvas!displayContentsOnCanvas: aCanvas	"Render the receiver's contents on the indicated canvas.  6/2/96 sw.	6/6/96 sw: call drawFrameOn:"	|  myContents toDisplay |	self drawFrameOn: aCanvas.	((myContents _ self contents) isKindOf: OrderedCollection) ifFalse:		[toDisplay _ myContents printString asDisplayText.		toDisplay align: toDisplay boundingBox center with: aCanvas boundingBox center.		toDisplay displayOn: aCanvas]!displayNameOn: aCanvas	"Display the receiver's name on the given canvas, centered beneath it.  5/20/96 sw"	| nameText itsBox emphasis |	emphasis _ self emphasisForName.	nameText _ (Text string: self name emphasis: emphasis) asDisplayText.	itsBox _ nameText boundingBox centeredBeneath: self layoutRectangle.	nameText displayOn: aCanvas at: itsBox topLeft!displayNamesOnWindowCanvas: aCanvas except: anObject in: aView	"Show the names of all the receiver's subparts, with the exception of anObject, on the provided canvas.  5/21/96 sw"	aView visibleObjectsInOrder do:		[:aSubpart | aSubpart == anObject			ifFalse: [aSubpart displayNameOn: aCanvas]]!displayWorkingsOnCanvas: aCanvas	"Render the receiver's workings, in a box on the indiated canvas.  5/17/96 sw.	 6/6/96 sw: call drawFrameOn:"	self drawFrameOn: aCanvas.	self workingsDo:		[:aSubpart | aSubpart renderOnCanvas: aCanvas]!displayWorkingsOnWindowCanvas: aCanvas	"Render the receiver's workings on the window canvas.  5/30/96 sw"	self workingsDo:		[:aSubpart | aSubpart renderOnCanvas: aCanvas].!displayWorkingsOnWindowCanvas: aCanvas except: anObject	"Render the receiver's workings on the given canvas.  5/30/96 sw"	self workingsDo:		[:aSubpart | aSubpart == anObject			ifFalse: [aSubpart renderOnCanvas: aCanvas]].!drawFrameOn: aCanvas	"Draw a frame around the user's layout rectangle.  6/6/96 sw"	|  aQuadrangle |	aQuadrangle _ Quadrangle extent: self layoutRectangle extent color: Color white borderWidth: self borderWidth borderColor: Color black. 	aQuadrangle displayOn: aCanvas!flash	"Flash the receiver's rectangle.  Since this is done without a View parameter, it is very slow, and should be used sparingly or not at all.  Perhaps worth making obsolete!!  Historical primarily. 6/12/96 sw"	| aRect |	(aRect _ self screenRect) ~~ nil		ifTrue:	[Display flash: aRect]!invalidateCanvas	"Make a note that the receiver's canvas is invalid.  6/12/96 sw"	canvasValid _ false!shapeToDrag	"Answer a MaskedForm to be dragged around as the user moves the receiver.  5/29/96 sw"	| aForm |	aForm _ Form extent: self layoutRectangle extent depth: 8.	aForm fillWhite:  aForm boundingBox.	aForm _ MaskedForm transparentBorder: aForm.	self currentCostume display: self onCanvas: aForm.	^ aForm!showPicture: aPictureName animationStage: aStageNumber rotatedBy: degrees on: aCanvas	"Show the given picture on the given canvas, rotated to reflect the receiver's current heading, and using the given stage number."	| aPicture |	(aPicture _ SqueakSupport animationNamed: aPictureName frameNumber: aStageNumber rotatedBy: self heading) ~~ nil		ifTrue:			[aPicture displayOn: aCanvas]		ifFalse:			[Transcript cr; show: 'Picture ', aPictureName printString, ' not found']	!showStandardPicture: aPictureName on: aCanvas	"Show the given picture on the given canvas.  6/23/96 sw	 6/23/96 sw: standard picture"	| aPicture |	(aPicture _ SqueakSupport standardPictureNamed: aPictureName) ~~ nil		ifTrue:			[aPicture displayOn: aCanvas]		ifFalse:			[Transcript cr; show: 'Picture ', aPictureName printString, ' not found'.  self halt.]	!userDisplayOn: aDisplayMedium	"This is the default user-display method -- override it to do something different.  6/12/96 sw	7/8/96 sw: by default, display the contents string"	contents ~~ nil		ifTrue:			[contents stringRepresentation displayOn: aDisplayMedium]		ifFalse:			[workingsBackToFront size > 0				ifTrue:					[self displayWorkingsOnCanvas: aDisplayMedium]				ifFalse:					[self name displayOn: aDisplayMedium]]!wantsFrameDrawnForCostume: aCostume	"Answer whether the receiver wishes a frame drawn for the given costume"	| parm |	^ (parm _ self parameterFor: #DrawFrame) == nil		ifTrue:			[aCostume defaultFrameDrawingParameter]		ifFalse:			[parm]! !!Obj methodsFor: 'hierarchy'!addToWorkings: anObject atKey: aKey	"Add the given object as another subpart of the receiver's workings, giving it the requested key in the receiver's subpart dictionary.  3/8/96 sw	9/11/96 tk: declare it from LostAndFound.  check if key is 'actsOn'"	| keyToUse laf |	workingsBackToFront == nil		ifTrue:			[workingsBackToFront _ OrderedCollection with: anObject]		ifFalse:			[workingsBackToFront add: anObject].	workingsDictionary == nil		ifTrue:			[workingsDictionary _ FastDictionary new].	keyToUse _ (workingsDictionary includesKey: aKey)		ifFalse:			[aKey]		ifTrue:			[self uniqueWorkingsKeyLike: aKey].	anObject objectContainedIn: self.	laf _ self class classPool at: #LostAndFound ifAbsent: [].	laf == nil 		ifFalse: [workingsDictionary declare: keyToUse from: laf].		"reuse the association in case script depends on it"	workingsDictionary at: keyToUse put: anObject.	keyToUse = 'actsOn' ifTrue: [self installScripts].	"effects named vars"!addToWorkingsSafely: anObject atKey: aKey path: path	"Add anObject to the receiver's workings, but never rename it.  When there is a conflict, ask user whether to delete or rename the old one.  Used when circumstances do not allow renaming anObject.  8/12/96 tk"	| keyToUse pp banner choice what old |	workingsDictionary == nil ifTrue: [workingsDictionary _ FastDictionary new].	keyToUse _ (workingsDictionary includesKey: aKey)				ifTrue: [self uniqueWorkingsKeyLike: aKey]				ifFalse: [aKey].	keyToUse = aKey ifTrue: [^ self addToWorkings: anObject atKey: aKey].	"ask user replace, or rename old.  "	pp _ path collect: [:each | each = 'w	w' ifTrue: ['workings'] ifFalse: [each]].	pp removeLast. 	banner _ 'The object ''', path last, ''' already exists in', pp asArray printString.	choice _ 'Rename Old VersionDelete Old Version'.	what _ (PopUpMenu labels: choice lines: nil) startUpWithCaption: banner.	old _ self workingsAtKey: aKey.	what = 2 ifTrue: ["Delete old"		self removeFromWorkings: old.		^ self addToWorkings: anObject atKey: aKey].	"what = 2 ifTrue: [" "Rename"		self removeFromWorkings: old.		self addToWorkings: old atKey: keyToUse.		^ self addToWorkings: anObject atKey: aKey.	!allSubparts	"Return a list of all subparts, workings and contents if applicable, in back-to-front order.  5/30/96 sw"	^ self workingsBackToFront!amContainedIn: root	"Return true if self belongs in the tree starting with root.  Note that we do not search the tree.  7/31/96 tk"	| up |	up _ objectContainedIn.	[up isExtant] whileTrue: [		up == root ifTrue: [^ true].		up _ up objectContainedIn].	^ false!assumeNewName: aString	"Make aString the receiver's new name.  7/12/96 sw"	objectContainedIn rename: self toBe: aString!bringToFront: anObject in: aView	"Bring the object to the front. 8/13/96 sw"	workingsBackToFront remove: anObject.	workingsBackToFront add: anObject!contentsBackToFront	"Only Folder objects really have a list of subparts in their contents, but generic Obj needs to be able to supply a vacuous list for various situations, so here it is...  6/12/96 sw"	^ OrderedCollection new!couldBeNamed: aName	"Answer whether the receiver's container would allow it to assume the given name.  7/12/96 sw	8/6/96 sw: bug fix: reverse true/false	8/8/96 sw: another bug fix, so can keep name unchanged"	| other |	self name = aName ifTrue: [^ true].	self == Home ifTrue: [^ false].	other _ self residesInContents		ifFalse:			[objectContainedIn workingsAtKey: aName]		ifTrue:			[objectContainedIn contentsAtKey: aName].	^ other == nil!lost: assoc	"This association is being removed from the contents or workings of me.  Keep it because a script of a child may be holding it as a literal.  See Obj.aComment.  9/11/96 tk"| laf |(self class classPool includesKey: #LostAndFound) ifFalse: [		self class addClassVarName: 'LostAndFound'.		self class classPool at: #LostAndFound put: Dictionary new].laf _ self class classPool at: #LostAndFound.laf add: assoc.assoc value: 'can''t find' asSymbol.!nameOf: aSubpart	"Answer the name by which the given subpart is formally known in the receiver.  5/30/96 sw"	workingsDictionary == nil ifTrue: [^nil].	^ workingsDictionary keyAtValue: aSubpart ifAbsent: [nil]!objectContainedIn	"Answer the receiver's container.  Everybody except Home has one.  6/12/96 sw"	^ objectContainedIn!objectContainedIn: anObject	"Set the receiver's container as indicated.  Not to be called by client code!!  6/12/96 sw	9/11/96 tk: recompile to update named siblings"	objectContainedIn _ anObject.	self whoActsOn == objectContainedIn ifTrue: [self installScripts].!path	"Return a PathFromHome of how to reach this object from Home.  Subclass of OrderedCollection.  My own name is at the end of the list.  Home is first in the list.  'w	w' means workings (tab in middle).  8/8/96 tk"| list par |list _ PathFromHome new.par _ self.list addFirst: par name.[	par residesInContents ifFalse: [list addFirst: 'w	w'].	par _ par objectContainedIn.	par == nil ifFalse: [list addFirst: par name].  	par == nil] whileFalse.list first = 'w	w' ifTrue: [list removeFirst].^ list!removeFromWorkings: anObject	"Remove the given object from the receiver's children.  5/16/96 sw	9/11/96 tk: put in LostAndFound.  check if key is 'actsOn'"	| assoc |	assoc _ workingsDictionary associationAt: anObject name.	workingsDictionary removeKey: anObject name.	workingsBackToFront remove: anObject.	self lost: assoc.	assoc key = 'actsOn' ifTrue: [self installScripts].	"effects named vars"!removeSubpart: anObject	"Remove an object from the receiver.  6/8/96 sw"	anObject residesInContents		ifTrue:			[self removeFromContents: anObject]		ifFalse:			[self removeFromWorkings: anObject]!rename: anObject toBe: aString	"Make aString anObject's new name.  At present this implementation is flawed in that it can change the z-ordering of the objects.  7/12/96 sw"	anObject residesInContents		ifFalse:			[self removeFromWorkings: anObject.			self addToWorkings: anObject atKey: aString]		ifTrue:			[self removeFromContents: anObject.			self addToContents: anObject atKey: aString]!residesInContents	"Answer if the receiver resides in contents of its container. 6/3/96 sw"	^ (objectContainedIn isKindOf: Folder) and:		 [objectContainedIn contentsBackToFront includes: self]!resolvePath: path	"Return the object that is at the end of this path.  If any problem, take the deepest one we matched.  7/31/96 tk"	| who sub |	path isEmpty ifTrue: [^ self].	"We are the container!!"	who _ path removeFirst.	who = 'w	w'	"in the workings"		ifFalse: [sub _ self contentsAtKey: who]		ifTrue: [who _ path removeFirst.			sub _ self workingsAtKey: who].	sub == nil ifTrue: [^ self]		ifFalse: [^ sub resolvePath: path].!sendToBack: anObject in: aView	"Send the object to the back.  6/12/96 sw"	workingsBackToFront remove: anObject.	workingsBackToFront addFirst: anObject!siblingAtKey: aKey	"Answer a sibling object of the given name, or nil if none found. 6/29/96 sw"	^ self residesInContents		ifFalse:			[objectContainedIn workingsAtKey: aKey]		ifTrue:			[objectContainedIn contentsAtKey: aKey]!siblings	"Answer a list of all siblings of the receiver.  6/29/96 sw"	^ self residesInContents		ifFalse:			[objectContainedIn workingsBackToFront copyWithout: self]		ifTrue:			[objectContainedIn contentsBackToFront copyWithout: self]!siblingsSatisfying: aBlock	"Answer a list of all siblings of the receiver which satisfy aBlock.  6/29/96 sw"	^ self siblings select: [:sib | (aBlock value: sib) == true]! !!Obj methodsFor: 'adding subparts'!addNewButtonIn: aView	"Invoked from menu: add a button.  7/15/96 sw	9/12/96 tk: default is that button script can talk about button's siblings.  Contents of the parent."	| aButton itsCostume ss |	aButton _ Obj newUserInstance.	aButton currentCostume: (itsCostume _ aButton costumeNamed: 'Picture').	aButton setParameter: 'RightArrow' forKey: #PictureName.	self addNewObject: aButton in: aView.	aButton addToWorkings: (ss _ StringObj new) atKey: 'actsOn'.	ss setContentsFromString: 'objectContainedIn'.	aButton addDefaultMouseUpScript.!addNewObject: newObj butDoNotDisplayYetIn: aView	"Add a new object, newObj, into the view, as a new subpart of the receiver, invoked at user menu-command request.  If newObj already has a costume set, don't tamper with it.   Don't yet display it in aView.  8/20/96 sw"	| itsExtent itsOrigin aName |	newObj setDefaultContents.	newObj hasCostumeSet ifFalse: [newObj setDefaultCostume].	aName _ newObj defaultNameStem.	aView showingContents		ifFalse:			[self addToWorkings: newObj atKey: (self uniqueWorkingsKeyLike: aName)]		ifTrue:			[self addToContents: newObj atKey: (self uniqueContentsKeyLike: aName)].	aView invalidateVisibleObjectCache.	newObj setExtentToMatchCostume!addNewObject: newObj in: aView	"Add a new object, newObj, into the view, as a new subpart of the receiver, invoked at user menu-command request.  If newObj already has a costume set, don't tamper with it.  6/28/96 sw	8/20/96 sw: call addNewObject: butDoNotDisplayYetIn:"	self addNewObject: newObj butDoNotDisplayYetIn: aView.	aView displayInterior!addNewObject: newObj in: aView name: aName	"Add a new object, newObj, into the view, as a new subpart of the receiver.  this variant dos not tell the object to set contents, does nothing about costume.  8/17/96 sw"	aView showingContents		ifFalse:			[self addToWorkings: newObj atKey: (self uniqueWorkingsKeyLike: aName)]		ifTrue:			[self addToContents: newObj atKey: (self uniqueContentsKeyLike: aName)].	aView invalidateVisibleObjectCache.	aView displayInterior!addNewObjectIn: aView	"Invoked from menu: add a fresh, blank object into the view, as a new subpart of the receiver.  6/2/96 sw"	| anObj aPictName |	anObj _ Obj newUserInstance.	anObj setParameter: self randomStandardPictureName forKey: #PictureName.	self addNewObject: anObj in: aView.	^ anObj!addNewObjectOfClass: aClassName in: aView	"Add a fresh, blank object into the view, as a new subpart of the receiver, invoked at user menu-command request  aClassName tells which kind of new object is needed.  6/2/96 sw	7/13/96 sw: use newUserInstance	7/15/96 sw: return the object"	| newObj |	newObj _ (Smalltalk at: aClassName) newUserInstance.	self addNewObject: newObj in: aView.	^ newObj!addNewPaintingIn: aView	"Invoked from menu: add a fresh, vanilla object into the view, as a new subpart of the receiver, with the initial costume to be painted by the user.  6/28/96 sw	 7/13/96 sw: use newUserInstance"	| result newObj picName |	result _ aView paint.	result == nil ifTrue: [^ self].	newObj _ Obj newUserInstance.	picName _ result first.	self addNewObject: newObj butDoNotDisplayYetIn: aView.	newObj assumePictureCostumeNamed: picName.	newObj layoutRectangle: ((result at: 3) moveBy: aView insetDisplayBox topLeft negated).	aView displayInterior!addNewTurtleIn: aView	"Invoked from menu: add a turtle.  7/17/96 sw"	| anObject aPen |	anObject _ Obj newUserInstance.	anObject currentCostume: (anObject costumeNamed: 'Picture').	anObject setParameter: 'Ship' forKey: #PictureName.	self addNewObject: anObject butDoNotDisplayYetIn: aView.	anObject assurePenExistsIn: aView.	aPen _ anObject pen.	aPen defaultNib: 4 atRandom.	anObject setWhimsicalVelocity.	anObject setExtentToMatchCostume.	aPen fillColor: (Color perform:		(#(blue red green black magenta cyan) at: 6 atRandom)).	anObject penDown!pasteClonedObject: newObj in: aView	"Add a new newObj, which was earlier copied to the clipboard, into the view 7/18/96 sw.  This is very similar to addNewObject:in:, but avoids initializing costume and extent stuff, etc."	| aName |	aName _ newObj defaultNameStem.	aView showingContents		ifFalse:			[self addToWorkings: newObj atKey: (self uniqueWorkingsKeyLike: aName)]		ifTrue:			[self addToContents: newObj atKey: (self uniqueContentsKeyLike: aName)].	newObj layoutRectangle: (self plausibleLayoutRectangleFor: newObj usingExtent: newObj layoutRectangle extent).	aView invalidateVisibleObjectCache.	aView displayInterior!randomStandardPictureName	"Return the name of one of the built-in standard pictures, chosen at random.  8/11/96 sw"	^ #('BlueCat' 'Froglet' 'Jet' 'PolarBear' 'Pig' 'Tuba' 'FrogLeft' 'NightStand') atRandom! !!Obj methodsFor: 'menu cmnds-painting'!chooseRotationsIn: aView	| picName reply |	picName _ self nameOfPictureCostumeOrExit: [^ self beep].	SqueakSupport rerotatePictureNamed: picName.	self setExtentToMatchCostume.	aView displayInterior!nameOfPictureCostumeOrExit: aBlock	"If the receiver is currently wearing a picture costume, return its name, else evaluate aBlock.  8/19/96 sw"	(self currentCostume isKindOf: AnimationCostume) ifFalse:			[^ aBlock value].	^ self parameterFor: #PictureName ifAbsent: ['Ship'] !offerPaintingSubmenuIn: aView	| aMenu aReply |	aMenu _ SelectionMenu labels: 'repaintrename paintingrotations...temp1temp2'	selections:		#(repaintIn: renamePaintingIn: chooseRotationsIn: temp1In; temp2In:).	aReply _ aMenu startUp.	aReply == nil ifTrue: [^ true].	self perform: aReply withArguments: (Array with: aView).	^ true!renamePaintingIn: aView	| picName reply |	picName _ self nameOfPictureCostumeOrExit: [^ self beep].	reply _ FillInTheBlank request: 'Type new name for this picture:' initialAnswer: picName.	reply size == 0 ifTrue: [^ self].	(SqueakSupport renamePictureNamed: picName toBe: reply) ifTrue:		[self setParameter: reply forKey: #PictureName]!repaintIn: aView	| picName reply aForm aPainting aPaintWindow result |	picName _ self nameOfPictureCostumeOrExit: [^ self beep].	aForm _ (SqueakSupport animationLibrary at: picName ifAbsent: [^ self beep]) primaryImage.	aView abandonHaloObject; displayInterior.	aPaintWindow _ PaintWindow new initializeFor: aView.	Display fill: (self layoutRectangle translateBy: aView insetDisplayBox origin) fillColor: Color white.	result _ aPaintWindow getRepaintingStaringWith: aForm at: (self layoutRectangle origin extent: aForm extent).	result == nil ifTrue: [^ self].	SqueakSupport replacePictureNamed: picName withGraphicFrom: result first.	self setExtentToMatchCostume.	aView displayEmphasized	! !!Obj methodsFor: 'menu cmds'!bringToFrontIn: aView	"Move the receiver to the front of the view.  8/13/96 tk"	objectContainedIn bringToFront: self in: aView!browseObjClass	"Open up a class browser on the receiver, so that its instance-specific methods can be viewed and edited.  6/11/96 sw	 6/29/96 sw: use browseObjClassForSelector:"	^ self browseObjClassForSelector: nil!browseObjClassFrom: aView	"Open up a class browser on the receiver, so that its instance-specific methods can be viewed and edited.  8/12/96 sw"	aView relinquishControl.	^ self browseObjClassForSelector: nil!chooseCostumeDetailsFor: anObject in: aView	"The receiver is serving as the current costume for anObject; if appropriate, put up a costume-type-specific menu to allow the user to specify details.  6/1/96 sw"	anObject holdsText ifTrue: 		[^ anObject editTextConventionally].	self beep!chooseCostumeDetailsIn: aView	"Let the receiver's current costume put up its details menu.  6/12/96 sw	6/13/96 sw: invalidate view's visible object cache, in support of Element-Costume's ability to change which subpart is visible"	self currentCostume chooseCostumeDetailsFor: self in: aView.	self setExtentToMatchCostume.	aView invalidateVisibleObjectCache!chooseCostumeIn: aView	"Let the user select a new costume from the available list.  6/12/96 sw	No more line for former 'default' item"	| aList result |	aList _ self costumeNames.	result _ (SelectionMenu labelList: aList lines: #() selections: aList) startUp.	result ~~ nil ifTrue:		[currentCostume _ 			self costumes at: result ifAbsent:				[self costumeNamed: result].		aView invalidateVisibleObjectCache.		self setExtentToMatchCostume]!copyObjectIn: aView	"Produce a clone of the receiver, add it to the container's hierarchy.  6/6/96 sw"	^ self copyObjectIn: aView offsetBy: (50 @ 50)!copyObjectIn: aView offsetBy: delta	"Produce a clone of the receiver, add it to the container's hierarchy.  Start the new fellow's life out offset by delta.  6/6/96 sw	 8/8/96 sw: make it work even if the view is nil, as when acting at a distance"	| newInst aKey |	newInst _ self clonedInstance.	self residesInContents		ifTrue:			[aKey _ objectContainedIn uniqueContentsKeyLike: self name.			objectContainedIn addToContents: newInst atKey: aKey]		ifFalse:			[aKey _ objectContainedIn uniqueWorkingsKeyLike: self name.			objectContainedIn addToWorkings: newInst atKey: aKey].	newInst layoutRectangle: (self layoutRectangle translateBy: delta).	aView == nil ifFalse: [aView invalidateVisibleObjectCache].	^ newInst!copyParametersFrom: donorObject	"Copy the parameters over from donor object.  May be tricky. 7/18/96 sw"	parameters _ FastDictionary new.	"I doubt this is properly thought through?!!"	donorObject parameters associationsDo:		[:assoc |			parameters at: assoc key put: assoc value contentsCopy]!copyToClipboard	"Produce a clone of the receiver, and store it in a place from whence it can be retrieved for subsequent pasting.  7/18/96 sw"	ObjectToPaste _ self clonedInstance!cutObjectIn: aView	"Remove the receiver from its parent and get the display right.  5/16/96 sw"	objectContainedIn removeSubpart: self.	objectContainedIn _ #purgatory.	aView invalidateVisibleObjectCache!dragFrom: aView confined: confinementBoolean	"Drag the receiver within the view until mouse comes up, and return the resulting rectangle, in screen coordinates.	7/8/96 sw: this variant will confine the drag to the within the originating window iff the confinementBoolean is true."	| aForm delta aLoc offset aRect adjustment extentToUse effectiveRect confinementRectangle |	confinementRectangle _ aView insetDisplayBox insetBy: (ObjectHaloWidth @ ObjectHaloWidth).	aView mouseDownObject: self.	delta _ aView insetDisplayBox topLeft.	offset _ Sensor cursorPoint - (self layoutRectangle origin translateBy: delta).	aForm _ self shapeToDrag.	aView displayInteriorExcept: self showHalo: false.	extentToUse _ self layoutRectangle extent.	aForm follow: [aLoc _ Sensor cursorPoint - offset.		aRect _ aLoc extent: extentToUse.		effectiveRect _ confinementBoolean			ifTrue:				[aRect copy forcedWithin: confinementRectangle]			ifFalse:				[aRect].		adjustment _ effectiveRect origin - aRect origin.		aLoc + adjustment] while: [Sensor anyButtonPressed].	^ (aLoc + adjustment) extent: extentToUse!dragIn: aView	"Drag the receiver within the view until mouse comes up.	 5/20/96 sw: call displayInterior	 5/29/96 sw: use shapeToDrag to get exactly the right drawing, and deploy an offset so the damned thing doesn't jump when you touch it.  Much nicer!!	7/8/96 sw: provisionally call dragFrom:confined:	7/8/96 sw: if control key down, don't confine to window	7/10/96 sw: use shift key for unconfined move"	| newRect |	aView mouseDownObject: self.	newRect _ self dragFrom: aView confined: Sensor leftShiftDown not.	self layoutRectangle: (newRect translateBy: aView insetDisplayBox origin negated).	self synchronizePenWithPosition.	aView mouseDownObject: nil.	aView displayInterior!editTextConventionally	"Open up an old MVC-based editor on the receiver's text.  6/1/96 sw"	| topView aDisplayTextView |	aDisplayTextView _ DisplayTextView new model: contents.	aDisplayTextView borderWidth: 2.	topView _ StandardSystemView new.	topView label: self name.	topView addSubView: aDisplayTextView.	topView controller open!makeAliasForObjectIn: aView offsetBy: delta	"Produce a new Alias object whose referent is the receiver, add it to the container's hierarchy.  Start the new fellow's life out offset by delta.  6/8/96 sw	7/13/96 sw: use newUserInstance"	| newInst aKey |	newInst _ Alias newUserInstance.	newInst referTo: self.	newInst mimicCostumeOf: self.	aView showingContents		ifTrue:			[aKey _ objectContainedIn uniqueContentsKeyLike: self name.			objectContainedIn addToContents: newInst atKey: aKey]		ifFalse:			[aKey _ objectContainedIn uniqueWorkingsKeyLike: self name.			objectContainedIn addToWorkings: newInst atKey: aKey].	newInst layoutRectangle: (self layoutRectangle translateBy: delta).	aView invalidateVisibleObjectCache.	^ newInst!makeAliasIn: aView	"Produce an alias to the receiver, add it to the container's hierarchy.  6/10/96 sw"	^ self makeAliasForObjectIn: aView offsetBy: (50 @ 50)!pasteTextIntoObject	"Make the text on the clipboard become the contents of the receiver.   6/28/96 sw: a no-op except for text-bearing objects"	self beep!redisplayIn: aView	"For debugging: redisplay the receiver.  6/9/96 sw"	self invalidateCanvas!reframeIn: aView	"Solicit a new frame for the receiver, reposition it accordingly, and get the display right.  5/20/96 sw"	| aRect delta newRect myContents |	aRect _ Rectangle fromUser forcedWithin: aView insetDisplayBox.	delta _ aView insetDisplayBox topLeft.	self layoutRectangle: (newRect _ aRect translateBy: (delta x negated @ delta y negated)).	canvas _ nil.	self invalidateCanvas.	((myContents _ self contents) isKindOf: Paragraph)		ifTrue:			[newRect _ newRect insetBy: 2 @ 2.			myContents wrappingBox: newRect clippingBox: newRect].	aView displayInterior!renameObjectIn: aView	"The user has asked to rename the object; allow her a chance to submit a new name.  7/24/96 sw"	| newLabel reply |	self == Obj homeObject ifTrue: [^ self inform: 'sorry, you cannot rename Home'].	reply _ FillInTheBlank		request: 'Edit the name, then type RETURN.'		displayAt: Sensor cursorPoint - (0@8)		centered: true		action: [:x | newLabel _ x]		initialAnswer: self name.	newLabel isEmpty ifFalse:		[(self couldBeNamed: newLabel) ifFalse:			[self inform: 'Sorry -- that name is already taken'.			^ self].	self assumeNewName: newLabel.	aView displayInterior]!rotateIn: aView	"Rotate the receiver by 45 degrees.  Dubious, notional.  7/17/96 sw"	self heading: (self heading + 45).	self setExtentToMatchCostume!sendToBackIn: aView	"Move the receiver to the back of the view.  5/16/96 sw"	objectContainedIn sendToBack: self in: aView!setContentsIn: aView	"Let the user specify fresh contents.  6/12/96 sw"	| aString reply |	self canSetContentsTextually ifFalse: [self beep.  ^ false].	aString _ self contentsString.	reply _ FillInTheBlank request: 'Type new contents expression' initialAnswer: self contentsString.	reply size == 0 ifTrue: [^ false].	self setContentsFromString: reply.	self setExtentToMatchCostume.	aView displayInterior!setHeadingIn: aView	"prompt the user for a new heading, and set it.  7/16/96 sw"	| aString aValue |	aString _ FillInTheBlank request: 'New heading: ' initialAnswer: self heading printString.	aString == nil ifTrue: [^ self].	aValue _ Compiler new evaluate: aString in: nil to: nil notifying: nil ifFail: [^ self inform: 'oops, syntax error'].	(aValue isKindOf: Number)		ifTrue:	[self heading: aValue]		ifFalse:	[self beep]!setPenColorIn: aView	"prompt the user for a pen color, and set it.  7/16/96 sw"	| colors aReply |	colors _ #(blue red green black magenta cyan).	aReply _ (SelectionMenu labelList: colors selections: colors) startUp.	aReply == nil ifTrue: [^ self].	self assurePenExistsIn: aView.	self pen fillColor: (Color perform: aReply)!setPenSizeIn: aView	"prompt the user for a pen size, and set it.  7/16/96 sw"	| aPen aString aValue |	self assurePenExistsIn: aView.	aPen _ self pen.	aString _ FillInTheBlank request: 'New pen size: ' initialAnswer: '1'.	aString == nil ifTrue: [^ self].	aValue _ Compiler new evaluate: aString in: nil to: nil notifying: nil ifFail: [^ self inform: 'oops, syntax error'].	(aValue isKindOf: Number)		ifTrue:	[aPen squareNib: aValue]		ifFalse:	[self beep]!setSpeedIn: aView	"prompt the user for a new speed, and set it.  7/16/96 sw"	| aString aValue |	aString _ FillInTheBlank request: 'New speed: ' initialAnswer: self speed printString.	aString == nil ifTrue: [^ self].	aValue _ Compiler new evaluate: aString in: nil to: nil notifying: nil ifFail: [^ self inform: 'oops, syntax error'].	(aValue isKindOf: Number)		ifTrue:	[speed _ aValue]		ifFalse:	[self beep]!showScriptAliasesIn: aView	"Make sure that all of the receiver's scripts are represented by aliases visible in aView.  8/17/96 sw"		| aModel anAlias modelList |	aModel _ aView model.	modelList _ Array with: aModel.	self allScripts do:		[:aScript | (aScript hasAliasIn: modelList)			ifFalse:				[anAlias _ Alias newUserInstance.				anAlias referTo: aScript.				anAlias useStandardCostumeNamed: 'Contents String'.				aModel addNewObject: anAlias in: aView name: (aScript name, ' in ', aModel name)]]! !!Obj methodsFor: 'menu mechanics'!dispatchMenuCommand: aCommand inView: aView andExit: exitBlock	"Dispatch the given menu command.  aView is the top view; exitBlock is evaluated upon exit, typically to allow a quick return out of the caller.  5/20/96 sw	7/16/96 sw..7/24/96 sw: gradually evolving over time..."	"Commands that do not require a redisplay of the view"	#(openReusingWindow: dragIn:  browseObjClassFrom: openInOwnWindowFrom: inspectPenIn:) do:		[:cmd |			aCommand == cmd ifTrue:				[self perform: cmd with: aView.				^ exitBlock value]].	"Commands that do require a redisplay of the view"	#(copyObjectIn: makeAliasIn: cutObjectIn: redisplayIn: reframeIn: sendToBackIn: bringToFrontIn: setContentsIn: chooseCostumeIn: chooseCostumeDetailsIn: recognizeCharactersIn: setSpeedIn: penDownIn: penUpIn: rotateIn: renameObjectIn: setPenColorIn: setPenSizeIn: showScriptAliasesIn: offerPaintingSubmenuIn:) do:		[:cmd |			aCommand == cmd ifTrue:				[self perform: cmd with: aView.				aView displayInterior.				^ exitBlock value]]!offerObjectMenuIn: aSqueakView	"Offer up the individual object menu, and dispatch control to the appropriate menu-handling routine.  5/20/96 sw	8/13/96 sw: added bring to front; deleted boring change history"	| reply aMenu |	aMenu _ SelectionMenu labelList:		#('costume...'			'costume details...'			'painting...'			'scripts...'			'show scripts here'			'rename...'			'open in own window'			'open in this window'			'duplicate'			'make alias'			'cut'			'copy to clipboard'			'send to back'			'bring to front'			'turtle...'			'misc...')		lines: # (3 6 8 11)		selections: #(chooseCostumeIn: chooseCostumeDetailsIn: offerPaintingSubmenuIn: browseObjClassFrom: showScriptAliasesIn: renameObjectIn: openInOwnWindowFrom: openReusingWindow: copyObjectIn: makeAliasIn: cutObjectIn:  copyToClipboard sendToBackIn: bringToFrontIn: offerTurtleMenu  more).	reply _ aMenu startUpWithCaption: self name.	reply == #offerTurtleMenu ifTrue:		[reply _ self turtleMenu startUp].	reply == #more ifTrue:		[reply _ self supplementaryObjectMenu startUp].	reply ~~ nil ifTrue: 		[self dispatchMenuCommand: reply inView: aSqueakView andExit: [^ self].		self perform: reply]	!supplementaryObjectMenu	"Answer a supplementary menu to be invoked from the object halo.  7/17/96 sw	 8/11/96 sw: added inspect pen"	^ SelectionMenu labelList: #('reframe'			'set contents...'			'paste text into me'			'inspect me'			'inspect my pen'			'redisplay')		selections: #(reframeIn:  setContentsIn: pasteTextIntoObject inspect inspectPenIn: redisplayIn:)!turtleMenu	"Answer a menu of turtle-related commands.  7/17/96 sw	 8/11/96 sw: added pen color, pen size, removed inspect pen."	^ SelectionMenu labelList:		#( 'pen down' 'pen up' 'set speed...' 'set heading...'  'rotate 45 degrees' 'pen color...' 'pen size...') 		lines: #(2 5)		selections: #(penDownIn: penUpIn: setSpeedIn: setHeadingIn: rotateIn: setPenColorIn: setPenSizeIn:)! !!Obj methodsFor: 'mouse handling'!catchMouseDownAt: aPoint in: aView	"The mouse went down at the given point, which fell upon the receiver.  This method is generic and not intended to be overridden.  If no special generic processing is indicated, it defers to the user-overridable mouseDownAt:in:.  5/11/96 sw	5/13/96 sw: drag if control key down	7/9/96 sw: dubious: for a vanilla object that doesn't override mouseDownAt:in:, treat the mouse down as a drag request.  At Alan's request, but doubtful...	7/10/96 sw: give the current costume first crack at processing	7/10/96 sw: remove the control key thing -- want to remap it to make-alias	7/12/96 sw: check for mouseUp override, not mouseDown -- for the moment anyway"	| result |	(false "Sensor controlKeyPressed" or: [self type == #Object and:		[(self overrides: #mouseUpAt:in:) not]]) ifTrue:			[^ self dragIn: aView].	Sensor leftShiftDown ifTrue:		[^ self offerObjectMenuIn: aView].	^ self currentCostume mouseDownInCostumeFor: self at: aPoint in: aView!clickIn: aView	"User wants to click on a button from inside a script.  9/21/96 tk"self mouseDownAt: self layoutRectangle center in: aView.self mouseUpAt: self layoutRectangle center in: aView.!mouseDownAt: aPoint in: aView		| result |	Sensor leftShiftDown ifTrue:		[^ self offerObjectMenuIn: aView].	aView mouseDownObject:  self.	Utilities awaitMouseUpIn: (self layoutRectangle translateBy: aView insetDisplayBox origin)	repeating:		[aView frozen ifFalse:			[aView model tickIn: aView.			aView displayInterior]]	ifSucceed:		[aView mouseDownObject: nil.		Cursor normal show.		self mouseUpAt: Sensor cursorPoint in: aView].	aView mouseDownObject: nil!mouseDownInCostumeFor: anObject at: aPoint in: aView	"The mouse has gone down in the interior of anObject at the given point in the given view, and the receiver is currently serving as that object's costume.  7/10/96 sw"	^ anObject mouseDownAt: aPoint in: aView!mouseDownInDragBarAt: aPoint in: aView	"The mouse went down at the given point, in the receiver's top halo  6/17/96 sw	 7/10/96 sw: use control key for make-alias"	| relPoint anObj |	anObj _ Sensor optionKeyPressed		ifTrue:			[self copyObjectIn: aView offsetBy: (0@0)]		ifFalse:			[Sensor controlKeyPressed				ifTrue:					[self makeAliasForObjectIn: aView offsetBy: (0@0)]				ifFalse:					[self]].		^ Cursor move showWhile: [anObj dragIn: aView]!mouseDownInHaloAt: aPoint in: aView	"The mouse went down at the given point, which fell within the receiver's halo rectangle at a time when the receiver is the halo object -- but NOT in the interior.  6/6/96 sw.	6/8/96 sw: cmd key -> make alias	6/17/96 sw devolve control to three alternative methods for top-halo-handling"	"Mouse in top portion of halo"	| lr showUpperEars |	showUpperEars _ (lr _ self layoutRectangle) height > 20.	(aPoint y < lr top) ifTrue:		[aPoint x < lr left			ifTrue:				[^ showUpperEars					ifTrue:						[self mouseDownInLeftEarAt: aPoint in: aView]					ifFalse:						[self offerObjectMenuIn: aView]].		aPoint x < lr right			ifTrue:					[^ self mouseDownInDragBarAt: aPoint in: aView].		^ showUpperEars					ifTrue:						[self mouseDownInRightEarAt: aPoint in: aView]					ifFalse:						[self offerObjectMenuIn: aView]].	"Mouse in a side bar of halo: for now, put up menu"	(aPoint y < (lr bottom - ObjectHaloWidth)) ifTrue:	 	[^ self offerObjectMenuIn: aView].	aPoint x < lr left		ifTrue:			[^ self mouseDownInLeftToeAt: aPoint in: aView]		ifFalse:			[^ self mouseDownInRightToeAt: aPoint in: aView]!mouseDownInLeftEarAt: aPoint in: aView	"The mouse went down at the left ear; resize the object. 6/17/96 sw"	self resizeFromCorner: #topLeft at: aPoint newRectBlock: 		[:topLeft :bottomRight :delta |			topLeft corner: (delta + bottomRight)]		in: aView!mouseDownInLeftToeAt: aPoint in: aView	"The mouse went down at the left lower resize box; resize the object. 6/22/96 sw"	self resizeFromCorner: #bottomLeft at: aPoint newRectBlock: 		[:newBottomLeft :topRight :delta |			(newBottomLeft x @ (topRight y + delta y)) corner: (((topRight x + delta x) @ newBottomLeft y))]		in: aView!mouseDownInRightEarAt: aPoint in: aView	"The mouse went down at the right ear; resize the object. 6/17/96 sw"	self resizeFromCorner: #topRight at: aPoint newRectBlock: 		[:newTopRight :botLeft :delta |			((botLeft x + delta x) @ newTopRight y) corner:				(newTopRight x @ (botLeft y + delta y))]		in: aView!mouseDownInRightToeAt: aPoint in: aView	"The mouse went down at the left right resize box; resize the object. 6/22/96 sw"	self resizeFromCorner: #bottomRight at: aPoint newRectBlock: 		[:newBottomRight :topLeft :delta |			(topLeft + delta) corner: newBottomRight]		in: aView!mouseUpAt: aPoint in: aView	"The mouse came up in the object, at the given point.  User overrides this if desired.  6/12/96 sw"	^ self type == #Object		ifTrue:			[aView flash]		ifFalse:			[self setContentsIn: aView]!resizeFromCorner: corner at: aPoint newRectBlock: newRectBlock in: aView	"The mouse went down in one of the resize handles of the object 6/27/96 sw		corner tells which corner (e.g. #topLeft)		aPoint is where the mouse went down		newRectBlock is a block with three args, that determines the revised rectangle; those args are:			newCorner			oppositeCorner			delta	7/16/96 sw: rectify the rectangle, so that  it doesn't go negative, and enforce min size"	| delta oppositeCorner newCorner aRect myContents originalLayoutRectangle adjustment innerBox |	delta _ aView insetDisplayBox topLeft.	originalLayoutRectangle _ self layoutRectangle.	oppositeCorner _ originalLayoutRectangle perform:		(Utilities oppositeCornerFrom: corner).	adjustment _ (originalLayoutRectangle perform: corner) - aPoint.	innerBox _ aView insetDisplayBox insetBy: ObjectHaloWidth @ ObjectHaloWidth.	Cursor normal showWhile:		[[Sensor noButtonPressed] whileFalse:		[newCorner _ Sensor cursorPoint + adjustment.		aRect _ newRectBlock value: newCorner value: oppositeCorner value: delta.		aRect _ aRect rectified extent: (aRect extent max: 8@8).		aRect _ aRect forcedWithin: innerBox.		aRect _ aRect translateBy: delta negated.		self layoutRectangle: aRect.		canvas _ nil.		self invalidateCanvas.		((myContents _ self contents) isKindOf: Paragraph)			ifTrue:				[aRect _ aRect insetBy: 2 @ 2.				myContents wrappingBox: aRect clippingBox: aRect].		aView displayInterior]].! !!Obj methodsFor: 'retrieval'!everyWorkingsSubpartSatisfying: aBlock	"Answer a list of workings subparts that satisfy aBlock.  6/17/96 sw"	self flag: #scottPrivate.  "Aliases here?  Need example too"	^ self workingsBackToFront select:		[:anObject | (aBlock value: anObject) == true]! !!Obj methodsFor: 'name & contents'!contents	"Return the receiver's contents, without reservation.  6/12/96 sw"	^ contents!contents: anObject	"Smash anObject into the receiver's contents.  Not to be undertaken lightly!!  6/12/96 sw"	contents _ anObject!contentsString	"Answer a string representing the receiver's contents.  6/12/96 sw"	^ self contents stringRepresentation!name	objectContainedIn == #purgatory ifTrue:		[^ 'A deleted object'].	objectContainedIn == nil ifTrue:		[^ 'Home'].	^ objectContainedIn nameOf: self! !!Obj methodsFor: 'running'!addObjectsVisibleIn: aTopView to: aList	"If the receiver is visible in aTopView, add it, and all its visible subparts, to aList.  6/3/96 sw"	aList add: self.  "By virtue of having been called"	(self currentlyRevealingContentsIn: aTopView)		ifTrue:			[self contentsBackToFront do:				[:c | c addObjectsVisibleIn: aTopView to: aList]].	(self currentlyRevealingWorkingsIn: aTopView)		ifTrue:			[self workingsDo:				[:c | c addObjectsVisibleIn: aTopView to: aList]].!runIn: aTopView	"User-overridable method for 'running all the time'.  Control is continuously dispatched to each visible object in a running simulation via this method.  6/12/96 sw"!tickIn: aTopView	"Basic 'running all the time' juncture for a window.  At this point implemented in the most naive way imaginable.  5/8/96 sw	5/11/96 sw don't move mouse-down object.	6/3/96 sw: temp: for demo purposes, since there's no tickIn: user code, just apply velocity.	6/12/96 sw: call runIn: for all visible objects	8/5/96 sw: dispatch collision info	8/12/96 sw: advance animation"	| vel anObj aList objectToAvoid |	objectToAvoid _ aTopView mouseDownObject.	aTopView dispatchCollisionInfo.  "Unsure where this should go"	aList _ aTopView allVisibleObjects.	aList do: [:anObject | anObject == objectToAvoid ifFalse:		[anObject currentCostume advanceAnimationFor: anObject in: aTopView.		anObject applyVelocityIn: aTopView]].	aList do: [:anObject | anObject runIn: aTopView]! !!Obj methodsFor: 'scripts'!aComment	"9/11/96 tk  In scripts you can refer to some objects just by their names.  Because buttons hold most scripts, we let you refer to the contents and workings of objectContainedIn by name.  There is no way to control the order, so name conflicts between objects in the contents and workings randomly refer to one or the other.	How intercept?  Refetch the contents and workings at each compile.  (Obj.createScope).  Upon removing an obj and its association from contents or workings, put (#can't find) into its value, and save assoc in LostAndFound.  Upon changing objectContainedIn, recompile.  	Use a LostAndFound list (class variable in each unique class).  If the guy you put into the contents or workings is in LostAndFound, reuse the association.  (Note that LostAndFound is a cache.  If full, just dump it and recompile (send installScripts to) all scripts of all subparts.)	When compile and can't find variable -- how know whether to put in LostAndFound, or put up error window?  Runtime error only?	Capitalization is not checked for!!  lowercase is fine.To Do:fileIn of an object -- fix up?   --OKAllow names with spaces or odd characters."!assureWorkingsReflectScripts	"Exploratory!!  Enumerate the selectors belonging to the receiver, and then make sure that the receiver's workings hold objects to represent them.  6/17/96 sw	6/22/96 sw: remove any existing script that is no longer represented by a method	7/13/96 sw: use newUserInstance"	| sels itsName scriptObject existingScripts |	sels _ self class selectors array copyWithoutAll: #(DoIt DoItIn:).	sels _ sels copyWithout: nil.	existingScripts  _ self workingsBackToFront select:		[:anObj | anObj isKindOf: Script] thenCollect: [:anObj | anObj name].	sels do:		[:aSel | (self workingsDictionary includesKey: (itsName _ aSel asString))			ifTrue:				[existingScripts remove: itsName]			ifFalse:				[scriptObject _ Script newUserInstance.				self addToWorkings: scriptObject atKey: itsName.				scriptObject contents: (self class sourceCodeAt: aSel)]].	existingScripts do: "Now only has old maids"		[:aKey | self removeFromWorkings: (self workingsAtKey: aKey)]!createScope	"A script is about to be compiled in me.  Look in the 'actsOn' alias in my workings to see what object's workings and contents can be treated as normal named variables in scripts.  Default is objects in my own workings and contents.  Workings first.  9/11/96 tk"| mine who |mine _ OrderedCollection new.who _ self whoActsOn.who workingsDictionary == nil ifFalse: [			mine add: who workingsDictionary].(who respondsTo: #contentsDictionary) ifTrue: [	who contentsDictionary == nil ifFalse: [			mine addLast: who contentsDictionary]].^ mine!establishScriptForSelector: aSelector	"The user has submitted a new or changed method for the given selector; establish a workings object that reflects it.  6/22/96 sw	7/13/96 sw: use newUserInstance	7/17/96 sw: skip it if it's a do it."	| scriptObject selString |	((aSelector == #DoIt) or: [aSelector == #DoItIn:]) ifTrue: [^ self].	scriptObject _ self workingsAtKey: (selString _ aSelector asString).	scriptObject == nil ifTrue:		[scriptObject _ Script newUserInstance.		self addToWorkings: scriptObject atKey: selString].		scriptObject contents: (self class sourceCodeAt: aSelector)!installScripts	"For all scripts in workings, compile each into the unique class.  When reading a User instance in from the disk.  7/31/96 tk"(self isKindOf: Script) 	ifTrue: [		(objectContainedIn isKindOf: Obj) ifTrue: [			contents class == String ifTrue: [				objectContainedIn class compile: contents 				classified: 'as yet unclassified' notifying: nil]]]	"who can I notify?"	ifFalse: [workingsDictionary == nil ifTrue: [^ self].objectContainedIn == nil ifTrue: [^ self].workingsDictionary associationsDo: [:assoc |	(assoc value isKindOf: Script) ifTrue: [		assoc value contents class == String ifTrue: [			"skip if already done"			self class compile: assoc value contents 				classified: 'as yet unclassified' notifying: nil.	"who can I notify?"		]]]].!openingIn: aView	"The receiver is about to be opened as the model of a window, whose top view is aView.  This gives the user a chance to execute some code to accompany the opening.  7/12/96 sw"!removeSelectorFromWorkings: aSelector	"If the receiver has a script object in its workings with the given selector as its name, remove it.  6/22/96 sw"	| obj |	(obj _ self workingsAtKey: aSelector asString) ~~ nil		ifTrue:			[(obj isKindOf: Script)				ifTrue:					[self removeFromWorkings: obj]]!whoActsOn	"Return the object indicated by the 'actsOn' alias in my workings.  For all scripts in me, that is the object whose parts can be called by name.  If 'actsOn' is the string 'objectContainedIn', then (fred size) in a script refers to fred in the contents or workings of my objectContainedIn.  9/12/96 tk"	| who |	who _ self workingsAtKey: 'actsOn'.	(who isKindOf: StringObj) ifTrue: [		who contents = 'self' ifTrue: [^ self].		who contents = 'objectContainedIn' ifTrue: [^ objectContainedIn].		who contents = 'parent' ifTrue: [^ objectContainedIn].		^ self].	(who isKindOf: Alias) ifTrue: [		(who contents isKindOf: Obj) ifTrue: [^ who contents]].	^ self	! !!Obj methodsFor: 'transition'!existingWindow	"If there is an existing window for the receiver, return its controller, else nil.  7/12/96 sw"	^ ScheduledControllers controllerSatisfying:		[:aController | aController model == self and:			[aController isKindOf: SqueakController]]!openInOwnWindow	"Open the receiver in its own window, or activate its already-open existing window.  7/12/96 sw"	self openInOwnWindowTellingView: [:aView | ]!openInOwnWindowFrom: aView	"Invoked from menu command (or maybe otherwise) in aView, open or activate a window for the receiver.  6/12/96 sw"	aView relinquishControl.	self openInOwnWindow!openInOwnWindowTellingView: aViewBlock	| aView existingWindow parm |	"Open the receiver in its own window, or activate such a window if it already exists; before relinquishing control, evaluate aViewBlock for the SqueakView for the window.  7/10/96 sw	7/25/96 sw: restore flags if appropriate"	existingWindow _ ScheduledControllers controllerWhoseModelSatisfies:		[:aModel | aModel == self].	existingWindow == nil ifFalse:		[aViewBlock value: existingWindow view.		^ ScheduledControllers activateController: existingWindow].	aView _ SqueakView new model: self.	aView label: self name.	aView minimumSize: 200 @ 100.	aView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	(parm _ self parameterFor: #BackgroundPaintingName ifAbsent: [nil]) == nil ifFalse:		[aView backgroundPaintingName: parm].	self flagsExist ifTrue:		[self ifFlagExists: #showingNames thenDo: [:val | aView showNames: val].		self ifFlagExists: #showingHalos thenDo: [:val | aView showHalos: val].		self ifFlagExists: #showingContents thenDo: [:val | aView showContents: val].		self ifFlagExists: #frozen thenDo: [:val | aView frozen: val]].	aView addSubView: (SqueakHaloView new model: self).	aViewBlock value: aView.	aView controller open!openReusingWindow: aSqueakView	"Make the window occupied by aSqueakView now be used for the receiver.  This is to support 'navigation-style' use, in the manner of Netscape or HyperCard, but is still in an early stage of implementation and probably has numerous flaws.  7/25/96 sw."	self openReusingWindow: aSqueakView transitionSelector: Form randomTransitionSelector!openReusingWindow: aSqueakView transitionSelector: transitionSelector	"Make the window occupied by aSqueakView now be used for the receiver.  This is to support 'navigation-style' use, in the manner of Netscape or HyperCard, but is still in an early stage of implementation and probably has numerous flaws.  6/12/96 sw	7/12/96 sw: added #openingIn: call, and this variant does not resize the window.	7/25/96 sw: created this variant with a visual effect selector"	| existing parm |	(existing _ self existingWindow) == nil ifFalse:		[existing view == aSqueakView ifFalse: [existing closeAndUnschedule]].	aSqueakView acceptNewModel: self.	self openingIn: aSqueakView.	(parm _ self parameterFor: #BackgroundPaintingName ifAbsent: [nil]) == nil ifFalse:		[aSqueakView backgroundPaintingName: parm].	transitionSelector == nil		ifFalse:			[aSqueakView applyVisualEffect:  transitionSelector].	self allSubparts do:		[:anObject | anObject hasPenDefined			ifTrue:				[anObject pen setDestForm: aSqueakView turtleTrailForm]].	transitionSelector == nil ifTrue:		[aSqueakView uncacheBits; displayEmphasized]!openReusingWindow: aSqueakView visualEffect: visualEffectName	"Make the window occupied by aSqueakView now be used for the receiver.  This is to support 'navigation-style' use, in the manner of Netscape or HyperCard, but is still in an early stage of implementation and probably has numerous flaws.  6/12/96 sw	7/12/96 sw: added #openingIn: call, and this variant does not resize the window.	7/25/96 sw: created this variant with a visual effect name"	| transitionSelector |	transitionSelector _ SqueakSupport visualEffectSelectorFor: visualEffectName.	self openReusingWindow: aSqueakView transitionSelector: transitionSelector.	(visualEffectName ~~ nil and: [transitionSelector == nil]) ifTrue:		[Transcript cr; show: '** Unknown visual effect:  ', visualEffectName stringRepresentation]!setDefaultContents	"For a newly-launched object, set its contents to a default value, if appropriate.  6/2/96 sw" ! !!Obj methodsFor: 'turtle'!assurePenExistsIn: aView	pen == nil ifTrue: [self setPenIn: aView]!hasPenDefined	^ pen ~~ nil!inspectPenIn: aView	"Open up an inspector on the receiver's pen, so that its color, etc., can be set: temporary UI.  7/17/96 sw"	self assurePenExistsIn: aView.	self pen inspectWithLabel: 'Pen for ', self name!noteNewWindowBounds: aRectangle	pen == nil ifFalse:		[pen clipRect: aRectangle]!pen	^ pen!penDown	"Put the pen down, ready to ink.  7/17/96 sw"	self pen down!penDownIn: aView	self assurePenExistsIn: aView.	self penDown!penUp	"Take the pen up, so it inks no more.  7/17/96 sw"	self pen up!penUpIn: aView	self assurePenExistsIn: aView.	self penUp!setPenIn: aSqueakView	pen _ Pen newOnForm: aSqueakView turtleTrailForm.	pen place: self layoutRectangle center.	pen up!setWhimsicalVelocity	"Start the receiver out with a velocity chosen more or less at random.    6/28/96 sw	7/17/96 sw: convert to speed/heading"	speed _ 1 + (7 atRandom).	heading _ 360 atRandom!synchronizePenWithPosition	"Make the receiver's pen reflect its current position.  7/17/96 sw"	pen == nil ifFalse:		[pen place: self layoutRectangle center]!trackPositionWithPen	pen == nil ifFalse:		[pen goto: self layoutRectangle center]! !!Obj methodsFor: 'type'!emphasisForName	"Plain text for all but Alias at present.  6/8/96 sw"	^ 1!holdsText	"Answer whether the receiver bears text in its contents. "	^ false!type	"Answer the receiver's formal type.  6/12/96 sw"	^ #Object! !!Obj methodsFor: 'velocity'!applyVelocityIn: aTopView	"Apply the receiver's velocity in the given top view.  Make the receiver 'bounce off walls' if it hits one -- either the window boundary, if parent is the window's model, or else the view boundary, if this is a 'wheel within a wheel'.  5/21/96 sw	Use corner instead of area for speed 7/9/96 tk	7/17/96 sw: synchronize pen	7/17/96 sw: converted over to heading and speed"	| vel oldVelocity corner |	(speed == nil or: [speed = 0]) ifTrue: [^ self].	vel _ oldVelocity _ self computedVelocity.	corner _ objectContainedIn == aTopView model		ifTrue:			[aTopView insetDisplayBox extent]		ifFalse:			[self objectContainedIn layoutRectangle extent].	((layoutRectangle bottom + vel y > corner y and: [vel y > 0]) or:			[(layoutRectangle top + vel y < 0 and: [vel y < 0])])				ifTrue:					[vel y: vel y negated.  self heading: (180 - self heading)].	((layoutRectangle right + vel x > corner x and: [vel x > 0])		or: [layoutRectangle left + vel x < 0 and: [vel x < 0]])			ifTrue:				[vel x: vel x negated.  self heading: (360 - self heading)].	"vel ~= oldVelocity ifTrue: [self invalidateCanvas].		Why is this test here???? 7/10/96 tk"	layoutRectangle moveBy: vel.	self trackPositionWithPen!computedVelocity	"Compute the receiver's velocity from its heading and its speed.  6/22/96 sw"	| alpha s |	(s _ self speed) = 0 ifTrue: [^ 0 @ 0].	alpha _ self heading degreesToRadians.	^ ((s * alpha sin) @ (s * alpha cos) negated) rounded!heading	"Return the receiver's heading.  6/22/96 sw"	heading == nil ifTrue: [heading _ 0].	^ heading!heading: aHeading	"Set the receiver's heading as indicated.  6/12/96 sw"	heading _ aHeading rounded \\ 360!speed	"Return the receiver's speed.  6/22/96 sw"	speed == nil ifTrue: [speed _ 0].	^ speed!speed: aSpeed	"Set the receiver's speed as indicated.  6/22/96 sw"	speed _ aSpeed!velocity: aVelocity	"Set the receiver's velocity as indictaed.  6/12/96 sw	7/17/96 sw: get speed and heading from it"		heading _ aVelocity asHeading.	speed _ aVelocity r rounded! !!Obj methodsFor: 'view metrics'!beVisibleIn: viewRectangle	"Move the receiver's layout rectangle, if necessary, to assure that it be visible within the current bounds described by viewExtent.  7/8/96 sw"	self layoutRectangle: (self layoutRectangle translatedToBeWithin: viewRectangle)!defaultExtent	"Answer the default extent to be occupied by the receiver.  6/12/96 sw" 	"This wild backstop is here to avoid chicken-and-egg problems in layout, but needs revisiting in due course.  Primary usage now is that an object wishing to bid for something different defines a method to override this, as will be seen, somewhat obscurely, in the pilot example.  Needs more work."	^ 50 @ 14!defaultWindowExtent	"Answer the size required to reveal the stuff inside the receiver.  There is however a chicken-and-egg problem here in that the locations of the contents are by default decided based on the window bounds, etc.  But this is a start.  6/10/96 sw"	^ 230 @ 120 !desiredExtentFor: anObject	"Acting as a costume for anObject, specify the desired extent.  6/12/96 sw"	^ anObject layoutRectangle extent!layoutRectangle	"Answer the receiver's layout rectangle, computing it if necessary.  6/12/96 sw"	layoutRectangle == nil ifTrue:		[self setDefaultLayoutRectangle].	^ layoutRectangle!layoutRectangle: aRectangle	"Set the receiver's layout rectangle as indicated.  6/12/96 sw.	 8/5/96 sw: assure fresh canvas if extents differ"	(layoutRectangle ~~ nil and: [layoutRectangle extent ~~ aRectangle extent])		ifTrue:			[canvas _ nil.			self invalidateCanvas].	layoutRectangle _ aRectangle!layoutRectangleIfDefined	"If the receiver already has a layout rectangle, return it, else return nil.  Do not trigger a computation.  6/12/96 sw"	^ layoutRectangle!maybeAddLayoutRectTo: aList	"If the receiver's layout rectangle is already determined, add it to aList.  6/10/96 sw	7/18/96 sw: allow extra space beneath, so that name and top halo of guy below don't clash"		layoutRectangle ~~ nil ifTrue:		[aList add: (layoutRectangle origin corner:			(layoutRectangle corner + (0 @ 8)))]!plausibleLayoutRectangleFor: obj	"obj is one of the receiver's subparts, which does not yet have real estate assigned to it.  Come up with something plausible, by searching for an available area that might be just the right size.  6/10/96 sw	7/18/96 sw: let new method plausibleLayoutRectangleFor:usingExtent: do the real work"	^ self plausibleLayoutRectangleFor: obj usingExtent: obj defaultExtent!plausibleLayoutRectangleFor: obj usingExtent: itsExtent	"obj is one of the receiver's subparts, which does not yet have real estate assigned to it.  Come up with something plausible, by searching for an available area that might be just the right size.  6/10/96 sw	7/18/96 sw: this variant gets the default extent passed in"	| sibs sibRects itsWidth itsHeight availableArea possX possY possRect |	sibs _ obj residesInContents		ifTrue:			[self contentsBackToFront]		ifFalse:			[self workingsBackToFront].	sibRects _ OrderedCollection new.	(sibs copyWithout: obj) do: [:aSib | aSib maybeAddLayoutRectTo: sibRects].	itsWidth _ itsExtent x + 16.	itsHeight _ itsExtent y + 12.	availableArea _ self windowBounds extent.	1 to: (((availableArea y max: 40) // itsHeight) max: 1) do:		[:yInd |			possY _ 10 + ((yInd - 1) * itsHeight). 			1 to: (((availableArea x max: 40) // itsWidth) max: 1) do:				[:xInd | possX _ 10 + ((xInd - 1) * itsWidth).				possRect _ possX @ possY extent: itsExtent.				(availableArea >= possRect corner) ifTrue:					[sibRects detect:						[:aRect | aRect intersects: possRect] ifNone:							["Eureka, or maybe Yreka!!"							^ possRect]]]].	^ 10@10 extent: itsExtent  "Ultimate copout"!screenRect	"Answer the screen rectangle occupied by the receiver.  Old and flawed, probably not used anywhere except by Obj.flash, which itself should probably go.  This technique doesn't have a view object to go on, so it has to search for it among the ScheduledControllers -- slow and ugly.  6/12/96 sw"	| aController |	^ (aController _ self parentsOwnWindowController) ~~ nil		ifTrue:			[self screenRectIn: aController view]		ifFalse:			[nil]!screenRectIn: aView	"Answer the receiver's screen rectangle, given that its parent is aView's model.  6/12/96 sw"	^ self layoutRectangle translateBy: aView insetDisplayBox origin!setDefaultLayoutRectangle	"Set the receiver's default layout rectangle to some plausible size.  6/10/96 sw"	layoutRectangle _ objectContainedIn plausibleLayoutRectangleFor: self!setDefaultWindowBounds	"Choose a likely window place for the receiver's window.  6/10/96 sw"	windowBounds _ SqueakSupport plausibleWindowRectangleFor: self defaultWindowExtent!setExtentToMatchCostume	"Reset the receiver's extent to match that of its costume if approrpiate.  6/12/96 sw"	| newExtent |	newExtent _ self currentCostume desiredExtentFor: self.	canvas _ nil.	self invalidateCanvas.	layoutRectangle _ self layoutRectangle origin extent: newExtent!suggestDefaultExtent: anExtent	"Create a method in the receiver's class that will produce the indicated extent.  6/10/96 sw"	self class compile:'defaultExtent	^ ', anExtent printString!suggestDefaultWindow: anExtent	"Create a method in the receiver's class that will produce the indicated window extent.  6/10/96 sw"	self class compile:'defaultWindowExtent	^ ', anExtent printString!windowBounds	"Return the bounds to be used for a window opened on the receiver.  6/12/96 sw"	windowBounds == nil ifTrue: [self setDefaultWindowBounds].	^ windowBounds!windowBounds: bounds	"Smash the specified bounds into the receiver's windowBounds inst var.  6/12/96 sw"	windowBounds _ bounds! !!Obj methodsFor: 'workings'!uniqueWorkingsKeyLike: aString	"Return a key similar to aString which is not currently in use as a workings key of the receiver.  5/30/96 sw	8/11/96 sw: call a new generic Utility to do the work."	^ Utilities keyLike: aString satisfying:		[:aKey | (self workingsDictionary includesKey: aKey) not]!workingsAtKey: aKey	"Answer the object stored at aKey in the receiver's workings, or nil if none.  6/12/96 sw"	^ self workingsDictionary at: aKey ifAbsent: [nil]!workingsBackToFront	"Answer the receiver's workings in back-to-front order.  6/12/96 sw"	workingsBackToFront == nil		ifTrue:			[workingsBackToFront _ OrderedCollection new].	^ workingsBackToFront!workingsDictionary	"Answer the receiver's workingsDictionary, creating it if necesary.  5/30/96 sw"	workingsDictionary == nil ifTrue: [workingsDictionary _ FastDictionary new].	^ workingsDictionary!workingsDo: aBlock	"Evaluate aBlock for each of the receiver's workings subparts, in back-to-front order.  3/8/96 sw"	self workingsBackToFront do:		[:anObject | aBlock value: anObject]! !!Obj methodsFor: 'unclassified'!addDefaultMouseUpScript	"Add a mouse-up script to the receiver.  7/15/96 sw"	self class compile: 'mouseUpAt: aPoint in: aView	self beep'.!allScripts	"Answer all scripts inside the workings of the receiver.  8/13/96 sw"	self assureWorkingsReflectScripts.	^ self workingsBackToFront copy select:		[:anObject | anObject isKindOf: Script]!browseObjClassForSelector: aSelector	"Open up a class browser on the receiver, so that its instance-specific methods can be viewed and edited.  If aSelector is not nil, make it the initial selection.	 8/5/96 sw: launch an ObjBrowser, and tell it the actual class name."	| index each newBrowser aClass |	aClass _ self class.	newBrowser _ ObjBrowser new.	newBrowser actualClassName: aClass name.	newBrowser systemCategoryListIndex:		(index _ SystemOrganization numberOfCategoryOfElement: aClass name).	newBrowser classListIndex: ((SystemOrganization listAtCategoryNumber: index)			findFirst: [:each | each == aClass name]).	newBrowser metaClassIndicated: false.	newBrowser messageCategoryListIndex: 1.	aSelector ~~ nil ifTrue:		[Browser postOpenSuggestion: 			(Array with: aClass with: aSelector)].	BrowserView openBrowserView: (BrowserView instanceBrowserViewOn: newBrowser) label: self name!canSetContentsTextually	"Answer whether the receiver has contents type subject to textual specification.  6/12/96 sw"	^ true!canShowContents	"Answer whether the receiver can show its contents in a window -- only Folders can for now.  6/12/96 sw"	^ false!canvas	"Return a form belonging to the receiver, on which user code, and subparts, can draw.  5/16/96 sw"	canvas == nil ifTrue:		[canvas _ MaskedForm extent: self layoutRectangle extent depth: 8].	^ canvas!chooseAnimatedPictureFor: aCostume	"Put up a menu to allow the user to select a picture for the receiver, and stash it in the receiver's costume details relating to aCostume.  8/8/96 sw"	| names reply |	names _ SqueakSupport animatedPictureNames.	reply _ (SelectionMenu labelList: names selections: names) startUpWithCaption: 'Choose a Picture'.	reply ~~ nil ifTrue:		[self setParameter: reply forKey: #PictureName.		self setParameter: 1 forKey: #AnimationStage]!collides: overOrUnder with: anotherObject in: aSqueakView	"Dispatched automatically (under certain circumstances) when two objects collide in an active simulation.  The first argument will be #over if the receiver is over the other, else it will be #under.  The intent here is that objects wishing to use this service will reimplement this method.  8/5/96 sw"!currentNumericValue	^ 50!defaultNameStem	"For use when launching a blank new object -- provide the stem (to be followed by numeric suffix if necessary) to be used as a basis for the object's name.  6/12/96 sw"	| typeString prefix |	typeString _ self type asString.	prefix _ typeString first isVowel		ifTrue:			['an']		ifFalse:			['a'].	^ prefix, typeString!drawCurrentElementOf: anObject on: aCanvas	"Acting as a 'one-bin' costume for anObject, draw its current element on a canvas.  If it does not have an current element, then draw a box instead.  6/1/96 sw	7/14/96 sw: call renderFillingParentCanvas:"	| currentElement |	currentElement _ self currentElementFor: anObject.	currentElement == nil		ifTrue:			[aCanvas fillWithColor: #red]		ifFalse:			[currentElement renderFillingParentCanvas: aCanvas]!flagAt: aSymbol	"Answer the value of the receiver's flag keyed by aSymbol.  Assumes flags exist -- check first with flagsExist.  7/25/96 sw"	^ flags at: aSymbol ifAbsent: [nil]!flagAt: aSymbol ifAbsent: aBlock	"Answer the value of the receiver's flag keyed by aSymbol, but if no such flag is define for the receiver, evaluate aBlock.  8/11/96 sw"	^ flags at: aSymbol ifAbsent: [aBlock value]!flags	"Reserved for future use, to stash information on an object's choices, including:		show contents/workings		show names/don't		show halos/don't		marked or not		locked or not.	The idea is that this info will be bit-packed into flags.  6/12/96 sw"	^ flags!flagsExist	^ flags~~ nil!hasAliasIn: aList	"Answer whether an alias to the receiver is to be found in aList.  8/13/96 sw"	^ (aList detect: [:anElement |		((anElement isKindOf: Alias) and:			[anElement refersTo: self])] ifNone: [nil])		~~ nil!ifFlagExists: aFlagName thenDo: aBlockForFlag	| flagValue |	self flagsExist ifTrue:		[flagValue _ self flagAt: aFlagName ifAbsent: [^ self].		aBlockForFlag value: flagValue]!initialize	"Object initializion: for now, just get the canvasValid flag initialized. 6/12/96 sw"	canvasValid _ false!isExtant	"Answer if the receiver is still extant.  7/13/96 sw"	^ objectContainedIn ~~ #purgatory!maximumValue	^ 100!minimumValue	^ 0!overrides: aSelector	"Answer whether the receiver overrides the given selector. 7/8/96 sw"	^ self class includesSelector: aSelector !parentsOwnWindowController	"Answer the top controller object that represents the open form of the receiver's parent, or nil if none. 5/6/96 sw"	^ ScheduledControllers controllerWhoseModelSatisfies:		[:aModel | aModel == objectContainedIn]!printOn: aStream	"For debugging: answer a string to represent the receiver.  6/12/96 sw"	aStream nextPutAll: '<', self name, '>'!recognizeCharactersIn: aView	self beep!renderFillingParentCanvas: enclosingCanvas	"Render the receiver onto the parent canvas.  7/14/96 sw"	self canvasValid ifFalse:		[self canvas clear.		self currentCostume display: self onCanvas: canvas.		"canvasValid _ true"].  "Return to this later..."	canvas displayOn: enclosingCanvas at: 0 @ 0 clippingBox: enclosingCanvas boundingBox!renderOnCanvas: enclosingCanvas	"Render the receiver on the provided canvas.  5/20/96 sw"	self canvasValid ifFalse:		[self canvas clear.		self currentCostume display: self onCanvas: canvas.		self flag: #scottPrivate.		"canvasValid _ true"].  "Return to this later..."	canvas displayOn: enclosingCanvas at: self layoutRectangle origin clippingBox: self layoutRectangle!setContentsFromString: aString	"Parse aString as a Smalltalk expression, and assuming one gets a good evaluation, set the receiver's contents to that value, unless there's a problem.   6/12/96 sw"	| aValue |	aValue _ Compiler new evaluate: aString in: nil to: nil notifying: nil ifFail: [^ self inform: 'oops, syntax error'].	self setContentsFromValue: aValue!setContentsFromValue: aValue	"Set the receiver's contents to the given value.  6/12/96 sw"	contents _ aValue!setFlag: aSymbol toValue: aValue	flags == nil ifTrue: [flags _ Dictionary new].	flags at: aSymbol put: aValue!storeWindowStateFrom: aSqueakView	"The receiver's window is about to go away or be redirected; stash relevant parameters in the receiver so that when it is reopened, the same parameters can be restored.  7/25/96 sw"	| bgName |	flags _ Dictionary new.	flags at: #showingNames put: aSqueakView showingNames.	flags at: #showingHalos put: aSqueakView showingHalos.	flags at: #showingContents put: aSqueakView showingContents.	flags at: #frozen put: aSqueakView frozen.	(bgName _ aSqueakView backgroundPaintingName) == nil ifFalse:		[flags at: #backgroundPaintingName put: bgName].	self flag: #scottPrivate.	"Would like to store Pen parms here for restoration, but the Pen itself doesn't hold on to the damned things!!	self hasPenDefined ifTrue:		[aPen _ self pen.		flags at: #penState put: aPen penState]"! !!Obj methodsFor: 'disk I/O'!comeFullyUpOnReload	"Normally this read-in object is exactly what we want to store. 7/26/96 tk"	"For all scripts in workings, compile into the unique class"	| pp |	objectContainedIn class == PathFromHome ifTrue: [		pp _ objectContainedIn copy.		pp removeFirst.	" 'Home' "		objectContainedIn _ Home resolvePath: pp].	currentCostume class == PathFromHome ifTrue: [		pp _ currentCostume copy.		pp removeFirst.	" 'Home' "		currentCostume _ Home resolvePath: pp].	self installScripts.	"Beware of scripts in workings of objects that do not have their own unique class."	^ self!containYourSubparts	"Fix up the objectContainedIn pointer in each of my contents.  7/30/96 tk"	self allSubparts do: [:each | each objectContainedIn: self].	"Assume each is an Obj.  Folders will throw in workings too."!ioType	"Return which of several categories this object is.  Effects how written on the disk.  7/29/96 tk"	"By getting here, we are an Obj.  Others are #System"	"(self isKindOf: Costume) ifTrue: [^#Costume]."	(self class category asString = 'HyperSqueak-UserObjects') ifTrue: [^#User].	^ #Obj!pathOrObj: object	"Find out whether object is in the entire set of object being written out.  If so and object isExtant, return object.  Return nil if not extant.  Return a Path if object is outside the tree that is being written.  User-defined costumes are handled specially.  8/8/96 tk"	object isExtant ifFalse: [^ nil].	^ IncomingObjects recent pathOrObj: object!storeDataOn: byteStream	"Write myself out on the ReferenceStream.  If I am a sole instance of a unique User class, use my generic class instead.  Don't write the parent pointer, objectContainedIn.  8/9/96 tk"	"See SqueakView.saveToDisk for who to write out a file of objects.See IncomingObjects.aComment for how to read the file back in again."	| cntInstVars cntIndexedVars class |	"(self isKindOf: Folder) ifTrue: [self halt].		debug"	class _ (self ioType = #User) ifTrue: [self class superclass]				ifFalse: [self class].	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	cntIndexedVars > 0 ifTrue: [		self error: 'not prepared to read variable Obj instances'].	byteStream		beginInstance: class			"Must be a standard subclass of Obj, i.e. Folder"		size: cntInstVars "+ cntIndexedVars".	1 to: cntInstVars do: [:i | 		(#(2 7 9) includes: i) "objectContainedIn, currentCostume, canvas"			ifTrue: [i = 9 				ifTrue: [byteStream nextPut: nil] "don't write the canvas"				ifFalse: [byteStream nextPut: 					(self pathOrObj: (self instVarAt: i))]]					ifFalse: [byteStream nextPut: (self instVarAt: i)]].	"1 to: cntIndexedVars do:		[:i | byteStream nextPut: (self basicAt: i)]."	(self parameters includesKey: #PictureName) ifTrue: [		IncomingObjects recent animation: #PictureName in: self].	(self parameters includesKey: #BackgroundPaintingName) ifTrue: [		IncomingObjects recent animation: #BackgroundPaintingName in: self].! !!Obj class methodsFor: 'class initialization'!cleanup	"Housekeeping: throw away all user objects, thus leaving the HyperSqueak stuff in its primordial state.  Also removes class removals from the current change set, thus clearing out all memory of the one-instance-per-class Obj classes that came and went.  5/20/96 sw	7/18/96 sw: clobber ObjectToPaste."	self removeAllUserObjects.	Home _ nil.	ObjectToPaste _ nil.	self initialize.	Smalltalk changes flushClassRemoves!freshStart	"Get a wholly fresh start -- throw away all old Obj guys, etc.  Very drastic.  6/12/96 sw	 7/9/96 sw: call assureInitialized"	self cleanup.	self assureInitialized!initialize	"Initialize the receiver's class variables.  6/11/96 sw"	"Obj initialize"	Border _ 1.	ClassNameIndex _ 0.	Home _ nil.	ObjectHaloWidth _ 10!initializeRoot	"Allocate the Home folder, as part of a general fresh start.  6/12/96 sw	 7/9/96 sw: put a symbol in there momentarily to avoid infinite recursion	 7/13/96 sw: use newUserInstance"	Home _ #abuilding.	Home _ Folder newUserInstance.	Home setFlag: #showingNames toValue: true.	Home setFlag: #showingHalos toValue: false.! !!Obj class methodsFor: 'costume library'!addStandardCostumeLibraryToHome	"Add a costume-library object to the Home object.  5/20/96 sw	 5/29/96 sw: added a couple further costumes.	 6/23/96 sw: rotations and animations	 7/9/96 sw: slider	 7/13/96 sw: use newUserInstance	 7/18/96 sw: comment out animations for the moment	 9/5/96 tk: add TextCostume"	|  costumeLibrary |	costumeLibrary _ Folder newUserInstance.	Home addToContents: costumeLibrary atKey: 'Costume Library'.	costumeLibrary suggestDefaultWindow: 360 @ 160.	costumeLibrary setFlag: #showingNames toValue: true.	costumeLibrary setFlag: #showingHalos toValue: false.	costumeLibrary addToContents: ShowWorkingsCostume new atKey: 'Workings'.	costumeLibrary addToContents: ShowContentsCostume new atKey: 'Contents'.	costumeLibrary addToContents: AnimationCostume new atKey: 'Picture'.	costumeLibrary addToContents: NameCostume new atKey: 'Name'.	costumeLibrary addToContents: ShowOneElementCostume new atKey: 'Element'.	costumeLibrary addToContents: BoxCostume new atKey: 'Box'.	costumeLibrary addToContents: SliderCostume new atKey: 'Slider'.	costumeLibrary addToContents: StringCostume new atKey: 'Contents String'.	costumeLibrary addToContents: TextCostume new atKey: 'Text'.	costumeLibrary assumePictureCostumeNamed: 'Folder'.	costumeLibrary contentsBackToFront do:		[:aCostume | aCostume assumePictureCostumeNamed: 'Dancer']!costumeLibrary	"Answer the current costume library, which lives on the Home card.  6/10/96 sw"	^ Home contentsAtKey: 'Costume Library'!standardCostumeNames	"Return a list of the standard costume names in the system.  6/10/96 sw"	^ self costumeLibrary contentsDictionary keys asSortedCollection! !!Obj class methodsFor: 'miscellaneous'!assureInitialized	"if Home is not present, allocate and initialize it, and get the costume library initialized at the same time.  If Home is already there, then do nothing.  7/9/96 sw"	"Obj assureInitialized"	Home == nil ifTrue:		[self initializeRoot.		self addStandardCostumeLibraryToHome]!browseSqueakClasses	"Browse the system category named 'Squeak'.  5/15/96 sw	 5/29/96 sw: modified to keep pace with changed category name	6/27/96 sw: now that there are multiple HyperSqueak categories, put up a list of them and let the user choose	7/13/96 sw: label tells which category"	"Obj browseSqueakClasses"	| newBrowser catList squeakList chosenCategory |	newBrowser _ Browser new.	catList _ newBrowser systemCategoryList.	squeakList _ catList select:		[:sym | sym prefixEqual: 'HyperSqueak'].	chosenCategory _ (SelectionMenu selections: squeakList) startUp.	chosenCategory == nil ifTrue: [chosenCategory _ 'HyperSqueak-Obj' asSymbol].	newBrowser systemCategoryListIndex: (catList indexOf: chosenCategory).	BrowserView openSystemCategoryBrowser: newBrowser label: chosenCategory editString: nil!homeObject	"Answer the Home object of the system.  6/28/96 sw"	^ Home!objectToPaste	"Return an object to paste.  7/18/96 sw"	^ ObjectToPaste == nil		ifTrue:			[nil]		ifFalse:			[ObjectToPaste clonedInstance]! !!Obj class methodsFor: 'pilot example'!addBlueBoxTo: exampleWindow	"part of the pilot example, factored out so the pilotExample method doesn't get too long to compile.  6/10/96 sw	 7/13/96 sw: use newUserInstance"	| anObj |	anObj _ NumberObj newUserInstance.	anObj layoutRectangle: (270@10 extent: 80@50).	anObj useStandardCostumeNamed: 'Box'.	anObj class compile: 'mouseUpAt: aPoint in: aView	Transcript cr; show: ''Ouch!! Stop that!!''' classified: 'mouse handling'.	anObj velocity: 4 @ 8.	exampleWindow addToContents: anObj atKey: 'Blue Box'.!addNephewsTo: anObj	"For the pilot example, add the three nephews to anObj.  This method is factored out to here because the method from whence it came got too many literals to compile.  6/10/96 sw	7/13/96 sw: use newUserInstance"	| objChild grandChild |	objChild _ self officialClass newUserInstance.	objChild layoutRectangle: (5 @ 10 extent: 50 @ 40).	"objChild windowBounds: (5 @ 40 extent: 100 @ 80)."	objChild velocity: (-2 @ -4).	objChild useStandardCostumeNamed: 'Workings'.	objChild class compile: 'borderWidth	^ 2' classified: 'display'.	anObj addToContents: objChild atKey: 'Huey'.	grandChild _ StringObj newUserInstance.	grandChild layoutRectangle: (5 @ 10 extent: 12 @ 12).	grandChild velocity: (1 @ 1).	objChild addToWorkings: grandChild atKey: 'A'.	grandChild _ StringObj newUserInstance.	grandChild layoutRectangle: (5 @ 30 extent: 12 @ 12).	grandChild velocity: (2 @ -3).	objChild addToWorkings: grandChild atKey: 'B'.	objChild _ BooleanObj newUserInstance.	objChild layoutRectangle: (5 @ 40 extent: 40 @ 15).	objChild velocity: (3 @ 8).	anObj addToContents: objChild atKey: 'Louie'.	objChild _ NumberObj newUserInstance.	objChild layoutRectangle: (5 @ 70 extent: 42 @ 15).	objChild velocity: (2 @ -3).	anObj addToContents: objChild atKey: 'Dewey'.!pilotExample	"The pilot example used for developing and testing and demonstrating the salient features of the prototype.  6/2/96 sw	7/10/96 sw: don't reinitialize the world each time, and call openInOwnWindowTellingView: rather than separately allocating and initializing the view.	7/13/96 sw: use newUserInstance	7/15/96 sw: call referTo: to set the referent of the Alias"	"Obj pilotExample"	|  anObj objChild  exampleWindow nephs ship |	exampleWindow _ Folder newUserInstance.	Home addToContents: exampleWindow atKey: 'Squeak!!'.	exampleWindow assumePictureCostumeNamed: 'Folder'.	exampleWindow windowBounds: (40 @ 20 extent: 380 @ 300).	self addBlueBoxTo: exampleWindow. "Factored out because method got too complex to compile"	nephs _ Folder newUserInstance.	"nephs suggestDefaultExtent: 140 @ 150."	nephs velocity: 1@2.	exampleWindow addToContents: nephs atKey: 'Nephews'.	nephs setDefaultCostume; setExtentToMatchCostume.	self addNephewsTo: nephs.  "Factored out because method got too complex to compile"	anObj _ TextObj newUserInstance.	anObj suggestDefaultExtent: 140 @ 70.	exampleWindow addToContents: anObj atKey: 'Goodnight Moon'.	anObj contents: (Paragraph withText: (Text fromString: 'In the great greenroom, there was a telephone, and a redballoon...')).	anObj _ Alias newUserInstance.  "create an alias object"	exampleWindow addToContents: anObj atKey: 'Huey alias'.	anObj useStandardCostumeNamed: 'Picture'.	anObj setParameter: 'Dancer' forKey: #PictureName.	anObj setExtentToMatchCostume.	anObj referTo: (nephs contentsAtKey: 'Huey').	exampleWindow addToContents: (ship _ self shipObjectForPilotExample) atKey: 'Ship'.	ship  setExtentToMatchCostume.	anObj _ TextObj newUserInstance.	anObj layoutRectangle: (5 @ 150 extent: 142 @ 70).	anObj contents: (Paragraph withText: (Text fromString: 'Hi!!  I''m an object thatlives in the WORKINGSof the my parent.')).	exampleWindow addToWorkings: anObj atKey: 'Read Me'.	exampleWindow openInOwnWindowTellingView:		[:aView | aView label: '* Squeak!! *'.		aView showNames: true]!shipObjectForPilotExample	"As part of the pilot example, create a ship object with swift motion.  6/10/96 sw	7/13/96 sw: use newUserInstance"	| anObj |	anObj _ Obj newUserInstance.	anObj velocity: 10 @ 6.	anObj useStandardCostumeNamed: 'Picture'.	anObj setParameter: 'Ship' forKey: #PictureName.	^ anObj! !!Obj class methodsFor: 'compilation'!acceptsLoggingOfCompilation	"Answer whether the receiver should have its code logged.  7/7/96 sw	7/12/96 sw obey a preference"	^ Preferences logUserScripts or: [self category ~~ 'HyperSqueak-UserObjects' asSymbol]!addSelector: selector withMethod: compiledMethod 	"Add the message selector with the corresponding compiled method to the receiver's method dictionary.  6/22/96 sw	 7/12/96 sw: still not quite satisfactory, but use wantsChangeSetLogging flag to determine whether to deal with the script-object establishment"	super addSelector: selector withMethod: compiledMethod.	self wantsChangeSetLogging ifFalse:		[self loneInstance establishScriptForSelector: selector]!loneInstance	"Answer the lone instance of the receiver, or nil if none.  6/22/96 sw"	^ self someInstance		!removeSelector: aSelector	"Remove the given selector from the receiver's method dictionary, and also get rid of the corresponding Script object in the receiver's workings.  6/22/96 sw	7/12/96 sw: use wantsChangeSetLogging as the flag to determine whether to remove the corresponding script object from the workings"	| result inst |	result _ super removeSelector: aSelector.	(result == nil or:		[self wantsChangeSetLogging]) ifTrue: [^ result].	(inst _ self loneInstance) == nil ifFalse:		[inst removeSelectorFromWorkings: aSelector].	!sharedPools	"Override for User objects that allow direct named access to objects in their parent's contents and workings.  (siblings) 9/11/96 tk"| mine |self category == nil ifTrue: [^ super sharedPools].^ (self category asString = 'HyperSqueak-UserObjects') 	ifTrue: [(mine _ self loneInstance) == nil 		ifTrue: [super sharedPools]		ifFalse: [mine createScope]]	ifFalse: [super sharedPools].!wantsChangeSetLogging	"Answer whether code submitted for the receiver should be remembered by the changeSet mechanism.  7/12/96 sw"	^ self category ~~ 'HyperSqueak-UserObjects' asSymbol! !!Obj class methodsFor: 'user objects'!allInstDo: aBlock	"Find all objects of my kind (in many uniqueSubclasses) and make them do the block.  7/9/96 tk"	self allSubclassesDo: [:cls |		cls allInstancesDo: [:inst |			aBlock value: inst]].	self flag: #noteToTed	"Note that this formulation does aBlock for every instance of every Obj subclass, whether it be a user instance or part of the generic world.  However, it may well be that there are no generic instances not part of the beneath-Home containment hierarchy, so maybe it's not sweat.  7/10/96 sw" !chooseUniqueClassName	"Select a class name to use for a new class.  The intent is that this is an internal name of no great interest to the user -- we would interact with the user on a totally different plane.  3/11/96 sw" 	ClassNameIndex _ ClassNameIndex + 1.	^ (self name, (ClassNameIndex printString)) asSymbol!copyMethodDictionaryFrom: donorClass	"Copy the method dictionary of the donor class over to the receiver.  6/12/96 sw	7/15/96 sw: also copy organization at this time"	methodDict _ donorClass copyOfMethodDictionary.	organization _ donorClass organization copy.!copyOfMethodDictionary	"Return a copy of the receiver's method dictionary.  6/12/96 sw"	^ methodDict copy!instanceOfUniqueClass	"Create a class for the receiver, and answer an instance of it.  3/11/96 sw	 6/23/96 sw changed category name	 7/9/96 sw: call assureInitialized"	| aName aClass |	(self category asString = 'HyperSqueak-UserObjects') ifTrue: [		"Oops!! I am a user class"		^ superclass instanceOfUniqueClass].	self assureInitialized.	aName _ self chooseUniqueClassName.	aClass _ self subclass: aName instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'HyperSqueak-UserObjects'.	^ aClass new !new	"Allocate a new instance of the receiver and get its early initialization done.  6/12/96 sw"	^ super new initialize!newUserInstance	"Answer an instance of an appropriate class to serve as a user object in the containment hierarchy.  7/13/96 sw"	^ self instanceOfUniqueClass!officialClass	"What class am I?  It must be above my user class.  8/14/96 tk"	(self category asString = 'HyperSqueak-UserObjects')		ifTrue: ["Oops!! I am a user class"			^ superclass officialClass]		ifFalse: [^ self].!readDataFrom: aDataStream size: anInteger	"Create an object based on the contents of aDataStream, which was generated by the object's storeDataOn: method.  Works for both straight instances of a class (Script) and instances that need a UniqueClass.  7/30/96 tk"	| anObject cntInstVars cntIndexedVars |	cntInstVars _ self instSize.	anObject _ self isVariable		ifTrue:  [cntIndexedVars _ anInteger - cntInstVars.				self error: 'Obj classes are not variable'.				self basicNew: "newUserInstance:" cntIndexedVars]		ifFalse: [cntIndexedVars _ 0.				 self newUserInstance].	"May create unique class"	aDataStream beginReference: anObject.	1 to: cntInstVars do:		[:i | anObject instVarAt: i put: aDataStream next]."	1 to: cntIndexedVars do:		[:i | anObject basicAt: i put: aDataStream next].	"	^ anObject!removeAllUserObjects	"Removes all user-defined Obj classes from the system.  Don't do this lightly!!  3/11/96 sw"	"Obj removeAllUserObjects"	self withAllSubclasses do:		[:aClass | aClass name asString endsWithDigit ifTrue:			[aClass removeFromSystem]]! !!ObjBrowser methodsFor: 'as yet unclassified'!actualClassName: aName	"Set the actual class name associated with this browser to aName, expected to be a Symbol.  8/5/96 sw"	actualClassName _ aName!browserWindowActivated	"Called whenever a browser window is reactivated.  8/5/96 sw"	self synchronizeIndices!synchronizeIndices	"In an attempt to circumvent difficulties that arise with the comings and goings of classe in user-objects category, this method tries to keep the receiver's indices up to date.  Assuming it works okay, it still will only keep things okay if it's called at the right times...  8/5/96 sw"	systemCategoryListIndex _ SystemOrganization numberOfCategoryOfElement: actualClassName.	classListIndex _ (SystemOrganization listAtCategoryNumber: systemCategoryListIndex)			findFirst: [:each | each == actualClassName].! !!Object methodsFor: 'translation support'!var: varSymbol declareC: declString	"For translation only; noop when running in Smalltalk."! !ObjectMemory comment:'This class describes a 32-bit direct-pointer object memory for Smalltalk.  The model is very simple in principle:  a pointer is either a SmallInteger or a 32-bit direct object pointer.SmallIntegers are tagged with a low-order bit equal to 1, and an immediate 31-bit 2s-complement signed value in the rest of the word.All object pointers point to a header, which may be followed by a number of data fields.  This object memory achieves considerable compactness by using a variable header size (the one complexity of the design).  The format of the 0th header word is as follows:	3 bits	reserved for gc (mark, old, dirty)	12 bits	object hash (for HashSets)	5 bits	compact class index	4 bits	object format	6 bits	object size in 32-bit words	2 bits	header type (0: 3-word, 1: 2-word, 2: forbidden, 3: 1-word)If a class is in the compact class table, then this is the only header information needed.  If it is not, then it will have another header word at offset -4 bytes with its class in the high 30 bits, and the header type repeated in its low 2 bits.  It the objects size is greater than 255 bytes, then it will have yet another header word at offset -8 bytes with its full word size in the high 30 bits and its header type repeated in the low two bits.The object format field provides the remaining information as given in the formatOf: method (including isPointers, isVariable, isBytes, and the low 2 size bits of byte-sized objects).This implementation includes incremental (2-generation) and full garbage collection, each with compaction and rectification of direct pointers.  It also supports a bulk-become (exchange object identity) feature that allows many objects to be becomed at once, as when all instances of a class must be grown or shrunk.'!!ObjectMemory methodsFor: 'initialization'!adjustAllOopsBy: bytesToShift	"Adjust all oop references by the given number of bytes. This is done just after reading in an image when the new base address of the object heap is different from the base address in the image."	| oop last |	bytesToShift = 0 ifTrue: [ ^ nil ].	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifFalse: [			self adjustFieldsAndClassOf: oop by: bytesToShift. 		].		last _ oop.		oop _ self objectAfter: oop.	].!adjustFieldsAndClassOf: oop by: offsetBytes	"Adjust all pointers in this object by the given offset."	| fieldAddr fieldOop classHeader newClassOop |	fieldAddr _ oop + (self lastPointerOf: oop).	[fieldAddr > oop] whileTrue: [		fieldOop _ self longAt: fieldAddr.		(self isIntegerObject: fieldOop) ifFalse: [			self longAt: fieldAddr put: (fieldOop + offsetBytes).		].		fieldAddr _ fieldAddr - 4.	].	(self headerType: oop) ~= HeaderTypeShort ifTrue: [		"adjust class header if not a compact class"		classHeader _ self longAt: (oop - 4).		newClassOop _			(classHeader bitAnd: AllButTypeMask) + offsetBytes.		self longAt: (oop - 4) put: (newClassOop bitOr: (classHeader bitAnd: TypeMask)).	].!initializeMemoryFirstFree: firstFree 	"Initialize endOfMemory to the top of oop storage space, reserving some space for forwarding blocks, and create the freeBlock from which space is allocated. Also create a fake free chunk at endOfMemory to act as a sentinal for memory scans."	"Note: The amount of space reserved for forwarding blocks should be chosen to ensure that incremental compactions can usually be done in a single pass. However, there should be enough forwarding blocks so a full compaction can be done in a reasonable number of passes, say ten. (A full compaction requires N object-moving passes, where N = number of non-garbage objects / number of forwarding blocks)."	| fwdBlockBytes |	"reserve space for forwarding blocks"	fwdBlockBytes _ MinimumForwardTableBytes.	(memoryLimit - fwdBlockBytes) >= (firstFree + BaseHeaderSize) ifFalse: [		"reserve enough space for a minimal free block of BaseHeaderSize bytes"		fwdBlockBytes _ memoryLimit - (firstFree + BaseHeaderSize).	].	"set endOfMemory and initialize freeBlock"	endOfMemory _ memoryLimit - fwdBlockBytes.	freeBlock _ firstFree.	self setSizeOfFree: freeBlock to: (endOfMemory - firstFree).  "bytes available for oops"	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	checkAssertions ifTrue: [		((freeBlock < endOfMemory) and: [endOfMemory < memoryLimit])			ifFalse: [ self error: 'error in free space computation' ].			(self oopFromChunk: endOfMemory) = endOfMemory			ifFalse: [ self error: 'header format must have changed' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'free block not properly initialized' ].	].!initializeObjectMemory: bytesToShift	"Initialize object memory variables at startup time. Assume endOfMemory is initially set (by the image-reading code) to the end of the last object in the image. Initialization redefines endOfMemory to be the end of the object allocation area based on the total available memory, but reserving some space for forwarding blocks."	"Assume: image reader initializes the following variables:		memory		endOfMemory		memoryLimit		specialObjectsOop		lastHash	"	checkAssertions _ false.  "set this early to allow assertions in initialization code to use it"	"set the start of the young object space"	youngStart _ endOfMemory.	self initializeMemoryFirstFree: endOfMemory.		"initializes endOfMemory, freeBlock"	"image may be at a different address; adjust oops for new location"	self adjustAllOopsBy: bytesToShift.	specialObjectsOop _ specialObjectsOop + bytesToShift.	"heavily used special objects"	nilObj	_ self splObj: NilObject.	falseObj	_ self splObj: FalseObject.	trueObj	_ self splObj: TrueObject.	rootTableCount _ 0.	child _ 0.	field _ 0.	parentField _ 0.	freeLargeContexts _ NilContext.	freeSmallContexts _ NilContext.	allocationCount _ 0.	lowSpaceThreshold _ 0.	signalLowSpace _ false.	compStart _ 0.	compEnd _ 0.	fwdTableNext _ 0.	fwdTableLast _ 0.	remapBufferCount _ 0.! !!ObjectMemory methodsFor: 'interpreter access'!fetchByte: byteIndex ofObject: objectPointer	^ self byteAt: objectPointer + BaseHeaderSize + byteIndex!fetchClassOf: oop	| ccIndex |	(self isIntegerObject: oop)		ifTrue: [ ^ self splObj: ClassInteger ].	ccIndex _ (((self baseHeader: oop) >> 12) bitAnd: 16r1F) - 1.	ccIndex < 0		ifTrue: [ ^ (self classHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [			"look up compact class"			^ self fetchPointer: ccIndex				ofObject: (self fetchPointer: CompactClasses ofObject: specialObjectsOop)		].!fetchPointer: fieldIndex ofObject: objectPointer	^ self longAt: objectPointer + BaseHeaderSize + (fieldIndex*4)!fetchWord: wordIndex ofObject: objectPointer	^ self longAt: objectPointer + BaseHeaderSize + (wordIndex*4)!fetchWordLengthOf: objectPointer	| sz |	sz _ self sizeBitsOf: objectPointer.	^ (sz - BaseHeaderSize) // 4!instantiateClass: classPointer indexableSize: size	| hash header1 header2 cClass byteSize format inc binc header3 hdrSize fillWord newObj |	checkAssertions ifTrue: [		size < 0 ifTrue: [ self error: 'cannot have a negative indexable field count' ].	].	hash _ self newObjectHash.	header1 _ self formatOfClass: classPointer. "Low 2 bits are 0"	header1 _ header1 bitOr: ((hash << 17) bitAnd: 16r1FFE0000).	header2 _ classPointer.	header3 _ 0.	cClass _ header1 bitAnd: 16r1F000. "compact class field from format word"	byteSize _ header1 bitAnd: 16rFC. "size in bytes -- low 2 bits are 0"	format _ (header1 >> 8) bitAnd: 16rF.	format < 8 ifTrue: [		"Bitmaps and Arrays"		inc _ size * 4.	] ifFalse: [		"Strings and Methods"		inc _ (size + 3) bitAnd: 16r1FFFFFFC. "round up"		binc _ 3 - ((size + 3) bitAnd: 3). "odd bytes"		"low bits of byte size go in format field"		header1 _ header1 bitOr: (binc << 8).	].	(byteSize + inc) > 255 ifTrue: [		"requires size header word"		header3 _ byteSize + inc.		header1 _ header1 - byteSize.	] ifFalse: [		header1 _ header1 + inc.	].	byteSize _ byteSize + inc.	header3 > 0 ifTrue: [		"requires full header"		hdrSize _ 3.	] ifFalse: [		cClass = 0			ifTrue: [ hdrSize _ 2 ]			ifFalse: [ hdrSize _ 1 ].	].	format < 4  "if pointers, fill with nil oop"		ifTrue: [ fillWord _ nilObj ]		ifFalse: [ fillWord _ 0 ].	newObj _ self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 fill: fillWord.	^ newObj!instantiateSmallClass: classPointer sizeInBytes: sizeInBytes fill: fillValue	"This version of instantiateClass assumes that the total object size is under 256 bytes, the limit for objects with only one or two header words. Note that the size is specified in bytes and should include four bytes for the base header word."	| hash header1 header2 hdrSize |	hash _ self newObjectHash.	header1 _ ((hash << 17) bitAnd: 16r1FFE0000) bitOr:			   (self formatOfClass: classPointer).	header1 _ header1 + (sizeInBytes - (header1 bitAnd: 16rFC)).	header2 _ classPointer.	(header1 bitAnd: 16r1F000) = 0 "is compact class field from format word zero?"		ifTrue: [ hdrSize _ 2 ]		ifFalse: [ hdrSize _ 1 ].	^ self allocate: sizeInBytes headerSize: hdrSize h1: header1 h2: header2 h3: 0 fill: fillValue!integerObjectOf: value	value < 0		ifTrue: [^ ((16r80000000 + value) << 1) + 1]		ifFalse: [^ (value << 1) + 1]!integerValueOf: objectPointer	"Translator produces 'objectPointer >> 1'"	((objectPointer bitAnd: 16r80000000) ~= 0)		ifTrue: ["negative"				^ ((objectPointer bitAnd: 16r7FFFFFFF) >> 1)					- 16r3FFFFFFF - 1  "Faster than -16r40000000 (a LgInt)"]		ifFalse: ["positive"				^ objectPointer >> 1]!isIntegerObject: objectPointer	^(objectPointer bitAnd: 1) = 1!isIntegerValue: valueWord 	^ valueWord >= 16r-40000000 and: [valueWord < 16r40000000]!nilObject  "For access from BitBlt module"	^ nilObj!popRemappableOop	"Pop and return the possibly remapped object from the remap buffer."	| oop |	oop _ remapBuffer at: remapBufferCount.	remapBufferCount _ remapBufferCount - 1.	^ oop!pushRemappableOop: oop	"Record the given object in a the remap buffer. Objects in this buffer are remapped when a compaction occurs. This facility is used by the interpreter to ensure that objects in temporary variables are properly remapped."	remapBuffer at: (remapBufferCount _ remapBufferCount + 1) put: oop.!signExtend16: int16	"Convert a signed 16-bit integer into a signed 32-bit integer value.  The integer bit is not added here."	(int16 bitAnd: 16r8000) = 0		ifTrue: [^ int16]		ifFalse: [^ int16 - 16r10000].!splObj: index	"Return one of the objects in the SpecialObjectsArray"	^ self fetchPointer: index ofObject: specialObjectsOop!storeByte: byteIndex ofObject: objectPointer withValue: valueByte	^ self byteAt: objectPointer + BaseHeaderSize + byteIndex		put: valueByte!storePointer: fieldIndex ofObject: objectPointer withValue: valuePointer	"Note must check here for stores of young objects into old ones."	(objectPointer < youngStart) ifTrue: [		self possibleRootStoreInto: objectPointer value: valuePointer.	].	^ self longAt: objectPointer + BaseHeaderSize + (fieldIndex*4)		put: valuePointer!storePointerUnchecked: wordIndex ofObject: objectPointer withValue: valuePointer	"Like storePointer:ofObject:withValue:, but the caller guarantees that the object being stored into is a young object or already marked as a root."	^ self longAt: objectPointer + BaseHeaderSize + (wordIndex*4)			  put: valuePointer!storeWord: wordIndex ofObject: objectPointer withValue: valueWord	^ self longAt: objectPointer + BaseHeaderSize + (wordIndex*4)		put: valueWord! !!ObjectMemory methodsFor: 'memory access'!checkAddress: byteAddress	"Keep this method around for debugging the C code."	byteAddress < (self startOfMemory) ifTrue: [		self error: 'bad address: negative'.	].	byteAddress >= memoryLimit ifTrue: [		self error: 'bad address: past end of heap'.	].!checkedByteAt: byteAddress	"Assumes zero-based array indexing."	self checkAddress: byteAddress.	^ self byteAt: byteAddress!checkedByteAt: byteAddress put: byte	"Assumes zero-based array indexing."	self checkAddress: byteAddress.	self byteAt: byteAddress put: byte.!checkedLongAt: byteAddress	"Assumes zero-based array indexing. For testing in Smalltalk, this method should be overridden in a subclass."	self checkAddress: byteAddress.	self checkAddress: byteAddress + 3.	^ self longAt: byteAddress!checkedLongAt: byteAddress put: a32BitInteger	"Assumes zero-based array indexing. For testing in Smalltalk, this method should be overridden in a subclass."	self checkAddress: byteAddress.	self checkAddress: byteAddress + 3.	self longAt: byteAddress put: a32BitInteger.! !!ObjectMemory methodsFor: 'header access'!baseHeader: oop	^ self longAt: oop!classHeader: oop	^ self longAt: oop - 4!formatOf: oop"       0      no fields        1      fixed fields only (possibly containing pointers)        2      indexable fields only (possibly containing pointers)        3      both fixed and indexable fields (possibly containing pointers)         4      unused  -- may use for contexts (size = stackPointer for scanning purposes)        5      unused        6      indexable word fields only (no pointers)        7      unused     8-11      indexable byte fields only (no pointers) (low 2 bits are low 2 bits of size)   12-15     compiled methods:                   # of literal oops specified in method header,                   followed by indexable bytes (same interpretation of low 2 bits as above)"	^ ((self baseHeader: oop) >> 8) bitAnd: 16rF!hashBitsOf: oop	^ ((self baseHeader: oop) >> 17) bitAnd: 16rFFF!headerType: oop	^ (self longAt: oop) bitAnd: TypeMask!isBytes: oop	"Answer true if the argument contains indexable bytes. See comment in formatOf:"	"Note: Includes CompiledMethods."	^ (self formatOf: oop)  >= 8!isFreeObject: oop	^ (self headerType: oop) = HeaderTypeFree!isPointers: oop	"Answer true if the argument has only fields that can hold oops. See comment in formatOf:"	^ (self formatOf: oop) <= 4!isWords: oop	"Answer true if the argument contains only indexable words (no oops). See comment in formatOf:"	^ (self formatOf: oop) = 6!isWordsOrBytes: oop	"Answer true if the contains only indexable words or bytes (no oops). See comment in formatOf:"	"Note: Excludes CompiledMethods."	| fmt |	fmt _ self formatOf: oop.	^ fmt = 6 or: [(fmt >= 8) and: [fmt <= 11]]!newObjectHash	"Answer a new pseudo random number for use as an indentity hash."	lastHash _ 13849 + (27181 * lastHash) bitAnd: 65535.	^ lastHash bitAnd: 16rFFF!rightType: headerWord	"Computer the correct header type for an object based on the size and compact class fields of the given base header word, rather than its type bits. This is used during marking, when the header type bits are used to record the state of tracing."	(headerWord bitAnd: 16rFC) = 0  "zero size field in header word"		ifTrue: [ ^ HeaderTypeSizeAndClass ]		ifFalse: [			(headerWord bitAnd: 16r1F000) = 0  "zero compact class field  in header word"				ifTrue: [ ^ HeaderTypeClass ]				ifFalse: [ ^ HeaderTypeShort ]].!setSizeOfFree: chunk to: byteSize	"Set the header of the given chunk to make it be a free chunk of the given size."	self longAt: chunk put: ((byteSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).!sizeBitsOf: oop	"Answer the number of bytes in the given object, including its base header, rounded up to an integral number of words."	"Note: byte indexable objects need to have low bits subtracted from this size."	| header |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: 16rFC ].!sizeBitsOfSafe: oop	"Compute the size of the given object from the cc and size fields in its header. This works even if its type bits are not correct."	| header type |	header _ self baseHeader: oop.	type _ self rightType: header.	type = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: 16rFC ].!sizeHeader: oop	^ self longAt: oop - 8!sizeOfFree: oop	"Return the size of the given chunk in bytes. Argument MUST be a free chunk."	^ (self longAt: oop) bitAnd: FreeSizeMask! !!ObjectMemory methodsFor: 'object enumeration'!accessibleObjectAfter: oop	"Return the accessible object following the given object or free chunk in the heap. Return nil when heap is exhausted."	| obj |	obj _ self objectAfter: oop.	[obj < endOfMemory] whileTrue: [		(self isFreeObject: obj) ifFalse: [ ^obj ].		obj _ self objectAfter: obj.	].	^ nil!firstAccessibleObject	"Return the first accessible object in the heap."	| obj |	obj _ self firstObject.	[obj < endOfMemory] whileTrue: [		(self isFreeObject: obj) ifFalse: [ ^obj ].		obj _ self objectAfter: obj.	].	self error: 'heap is empty'!firstObject	"Return the first object or free chunk in the heap."	^ self oopFromChunk: self startOfMemory!initialInstanceOf: classPointer	"Support for instance enumeration. Return the first instance of the given class, or nilObj if it has no instances."	| thisObj thisClass |	thisObj _ self firstAccessibleObject.	[thisObj = nil] whileFalse: [		thisClass _ self fetchClassOf: thisObj.		thisClass = classPointer ifTrue: [ ^thisObj ].		thisObj _ self accessibleObjectAfter: thisObj.	].	^nilObj!instanceAfter: objectPointer	"Support for instance enumeration. Return the next instance of the class of the given object, or nilObj if the enumeration is complete."	| classPointer thisObj thisClass |	classPointer _ (self fetchClassOf: objectPointer).	thisObj _ self accessibleObjectAfter: objectPointer.	[thisObj = nil] whileFalse: [		thisClass _ self fetchClassOf: thisObj.		thisClass = classPointer ifTrue: [ ^thisObj ].		thisObj _ self accessibleObjectAfter: thisObj.	].	^nilObj!lastPointerOf: objectPointer	"Return the byte offset of the last pointer field of the given object. Works with CompiledMethods, as well as ordinary objects. Can be used even when the type bits are not correct."	| fmt sz methodHeader |	fmt _ self formatOf: objectPointer.	fmt < 4 ifTrue: [		sz _ self sizeBitsOfSafe: objectPointer.		^ sz - BaseHeaderSize  "all pointers"	].	fmt < 12 ifTrue: [ ^0 ].  "no pointers"	"CompiledMethod: contains both pointers and bytes:"	methodHeader _ self longAt: objectPointer + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize!objectAfter: oop	"Return the object or free chunk immediately following the given object or free chunk in memory. Return endOfMemory when enumeration is complete."	| sz |	checkAssertions ifTrue: [		oop >= endOfMemory ifTrue: [ self error: 'no objects after the end of memory' ].	].	(self isFreeObject: oop)		ifTrue: [ sz _ self sizeOfFree: oop ]		ifFalse: [ sz _ self sizeBitsOf: oop ].	^ self oopFromChunk: (oop + sz)!startOfMemory	"Return the start of object memory."	^ self cCode: '(int) memory'! !!ObjectMemory methodsFor: 'oop/chunk conversion'!chunkFromOop: oop	"Compute the chunk of this oop by subtracting its extra header bytes."	^ oop - (self extraHeaderBytes: oop)!extraHeaderBytes: oopOrChunk	"Return the number of extra bytes used by the given object's header."	"Warning: This method should not be used during marking, when the header type bits of an object may be incorrect."	| type |	type _ self headerType: oopOrChunk.	type > 1 ifTrue: [^ 0].  "Free(2) or 1-word header(3) most common"	type = 1 ifTrue: [^ 4].	type = 0 ifTrue: [^ 8].  "unneccess test for clarity only"!oopFromChunk: chunk	"Compute the oop of this chunk by adding its extra header bytes."	^ chunk + (self extraHeaderBytes: chunk)! !!ObjectMemory methodsFor: 'allocation'!allocate: byteSize headerSize: hdrSize h1: baseHeader h2: classOop h3: extendedSize fill: fillWord	"Allocate a new object of the given size and number of header words. (Note: byteSize already includes space for the base header word.) Initialize the header fields of the new object and fill the remainder of the object with the given value."	| newObj remappedClassOop end i |	"remap classOop in case GC happens during allocation"	hdrSize > 1 ifTrue: [ self pushRemappableOop: classOop ].  	newObj _ self allocateChunk: byteSize + ((hdrSize - 1) * 4).	hdrSize > 1 ifTrue: [ remappedClassOop _ self popRemappableOop ].	hdrSize = 3 ifTrue: [		self longAt: newObj      put: (extendedSize bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 4 put: (remappedClassOop bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 8 put: (baseHeader bitOr: HeaderTypeSizeAndClass).		newObj _ newObj + 8.	].	hdrSize = 2 ifTrue: [		self longAt: newObj      put: (remappedClassOop bitOr: HeaderTypeClass).		self longAt: newObj + 4 put: (baseHeader bitOr: HeaderTypeClass).		newObj _ newObj + 4.	].	hdrSize = 1 ifTrue: [		self longAt: newObj put: (baseHeader bitOr: HeaderTypeShort).	].	"clear new object"	end _ newObj + byteSize.	i _ newObj + 4.	[i < end] whileTrue: [		self longAt: i put: fillWord.		i _ i + 4.	].	checkAssertions ifTrue: [		self okayOop: newObj.		self oopHasOkayClass: newObj.		(self objectAfter: newObj) = freeBlock			ifFalse: [ self error: 'allocate bug: did not set header of new oop correctly' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'allocate bug: did not set header of freeBlock correctly' ].	].	^ newObj!allocateChunk: byteSize 	"Allocate a chunk of the given size. Sender must be sure that the requested size includes enough space for the header word(s)."	"Details: To limit the time per incremental GC, do one every so many allocations."	| enoughSpace newFreeSize newChunk |	allocationCount >= AllocationsBetweenGCs ifTrue: [		"do an incremental GC every so many allocations to keep pauses short"		self incrementalGC.	].	enoughSpace _ self sufficientSpaceToAllocate: byteSize.	enoughSpace ifFalse: [		"signal that space is running low, put proceed with allocation if possible"		signalLowSpace _ true.		interruptCheckCounter _ 0.	].	(self sizeOfFree: freeBlock) < (byteSize + BaseHeaderSize) ifTrue: [		self error: 'out of memory'.	].	"if we get here, there is enough space for allocation to succeed"	newFreeSize _ (self sizeOfFree: freeBlock) - byteSize.	newChunk _ freeBlock.	freeBlock _ freeBlock + byteSize.	"Assume: client will initialize object header of free chunk, so following is not needed:"	"self setSizeOfFree: newChunk to: byteSize."	self setSizeOfFree: freeBlock to: newFreeSize.	allocationCount _ allocationCount + 1.	^ newChunk!allocateOrRecycleContext: smallContextWanted	"Return a recycled context or a newly allocated one if none is available for recycling. The argument indicates that a small context is wanted."	| cntxt |	smallContextWanted ifTrue: [		freeSmallContexts ~= NilContext ifTrue: [			cntxt _ freeSmallContexts.			freeSmallContexts _ self fetchPointer: 0 ofObject: cntxt.		] ifFalse: [			cntxt _ self instantiateSmallClass: (self splObj: ClassMethodContext)								 sizeInBytes: SmallContextSize										 fill: nilObj.		].	] ifFalse: [		freeLargeContexts ~= NilContext ifTrue: [			cntxt _ freeLargeContexts.			freeLargeContexts _ self fetchPointer: 0 ofObject: cntxt.		] ifFalse: [			cntxt _ self instantiateSmallClass: (self splObj: ClassMethodContext)								sizeInBytes: LargeContextSize										fill: nilObj.		].	].	^ cntxt!recycleContextIfPossible: contextOop	"If possible, save the given context on a list of free contexts to be recycled."	"Note: The context is not marked free, so it can be reused with minimal fuss. It's fields are nil-ed out to avoid confusion when debugging. It is probably best to clear the recycled context lists before garbage collecting."	| sz |	"only recycle young contexts (which should be most of them)"	contextOop >= youngStart ifFalse: [ ^ nil ].	sz _ self sizeBitsOf: contextOop.  "in bytes"	sz = SmallContextSize ifTrue: [		self storePointerUnchecked: 0 ofObject: contextOop withValue: freeSmallContexts.		freeSmallContexts _ contextOop.		] ifFalse: [		self storePointerUnchecked: 0 ofObject: contextOop withValue: freeLargeContexts.		freeLargeContexts _ contextOop.		].!sufficientSpaceAfterGC: minFree	"Return true if there is enough free space after doing a garbage collection. If not, signal that space is low."	self incrementalGC.  "try to recover some space"	(self sizeOfFree: freeBlock) < minFree ifTrue: [		signalLowSpace ifTrue: [ ^ false ].  "give up; problem is already noted"		self fullGC.  "try harder"		"for stability, require more free space after doing an expensive full GC"		(self sizeOfFree: freeBlock) < (minFree + 15000) ifTrue: [ ^ false ].  "still not enough"	].	^ true!sufficientSpaceToAllocate: bytes	"Return true if there is enough space to allocate the given number of bytes, perhaps after doing a garbage collection."	| minFree |	minFree _ lowSpaceThreshold + bytes + BaseHeaderSize.	"check for low-space"	(self sizeOfFree: freeBlock) >= minFree ifTrue: [		^ true.	] ifFalse: [		^ self sufficientSpaceAfterGC: minFree.	].! !!ObjectMemory methodsFor: 'garbage collection'!beRootIfOld: oop	"Record that the given oop in the old object area may point to an object in the young area."	| header |	((oop < youngStart) and: [(self isIntegerObject: oop) not]) ifTrue: [		"oop is in the old object area"		header _ self longAt: oop.		(header bitAnd: RootBit) = 0 ifTrue: [			"record oop as root only if not already recorded"			rootTableCount < RootTableSize ifTrue: [				"record root only if there is room in the roots table"				rootTableCount _ rootTableCount + 1.				rootTable at: rootTableCount put: oop.				self longAt: oop put: (header bitOr: RootBit).			].		].	].!clearRootsTable	"Clear the root bits of the current roots, then empty the roots table."	"Caution: This should only be done when the young object space is empty."	| i oop |	"reset the roots table (after this, all objects are old so there are no roots)"	1 to: rootTableCount do: [ :i |		"clear root bits of current root table entries"		oop _ rootTable at: i.		self longAt: oop put: ((self longAt: oop) bitAnd: AllButRootBit).		rootTable at: i put: 0.	].	rootTableCount _ 0.!fullCompaction	"Move all accessible objects down to leave one big free chunk at the end of memory."	"Assume: Incremental GC has just been done to maximimize forwarding table space."	"need not move objects below the first free chunk"	compStart _ self lowestFreeAfter: (self startOfMemory).	compStart = freeBlock ifTrue: [		"memory is already compact; only free chunk is at the end"		^ self initializeMemoryFirstFree: freeBlock	].	"work up through memory until all free space is at the end"	[compStart < freeBlock] whileTrue: [		"free chunk returned by incCompBody becomes start of next compaction"		compStart _ self incCompBody.  "bubble of free space moves up each time"	].!fullGC	"Do a mark/sweep garbage collection of the entire object memory. Free inaccessible objects but do not move them."	self clearRootsTable.	youngStart _ self startOfMemory.  "process all of memory"	self markPhase.	self sweepPhase.	self fullCompaction.	allocationCount _ 0.	youngStart _ freeBlock.  "reset the young object boundary"	self postGCAction.!incrementalCompaction	"Move objects down to make one big free chunk. Compact the last N objects (where N = number of forwarding table entries) of the young object area."	"Assume: compStart was set during the sweep phase"	compStart = freeBlock ifTrue: [		"Note: If compStart = freeBlock then either the young space is already compact		 or there are enough forwarding table entries to do a one-pass incr. compaction."		self initializeMemoryFirstFree: freeBlock.	] ifFalse: [		self incCompBody.	].!incrementalGC	"Do a mark/sweep garbage collection of just the young object area of object memory (i.e., objects above youngStart), using the root table to identify objects containing pointers to young objects from the old object area."	| survivorCount |	rootTableCount >= RootTableSize ifTrue: [		"root table overflow; cannot do an incremental GC (this should be very rare)"		^ self fullGC	].	"incremental GC and compaction"	self markPhase.	survivorCount _ self sweepPhase.	self incrementalCompaction.	allocationCount _ 0.	survivorCount > 2000 ifTrue: [		"move up the young space boundary if there are too many survivors;		 this limits the number of objects that must be processed on future		 incremental GC's"		self clearRootsTable.		youngStart _ freeBlock.  "reset the young object boundary"	].	self postGCAction.!lowestFreeAfter: chunk	"Return the first free block after the given chunk in memory."	| oop oopHeader oopHeaderType oopSize |	oop _ self oopFromChunk: chunk.	[oop < endOfMemory] whileTrue: [		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeFree)			ifTrue: [ ^ oop ]			ifFalse: [				oopHeaderType = HeaderTypeSizeAndClass					ifTrue: [ oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]					ifFalse: [ oopSize _ oopHeader bitAnd: 16rFC ].			].		oop _ self oopFromChunk: (oop + oopSize).	].	self error: 'expected to find at least one free object'.!possibleRootStoreInto: oop value: valueObj	"Called when storing the given value object into the given old object. If valueObj is young, record the fact that oldObj is now a root for incremental garbage collection."	"Warning: No young objects should be recorded as roots."	| header |	((valueObj >= youngStart) and:	 [(self isIntegerObject: valueObj) not]) ifTrue: [		header _ self longAt: oop.		(header bitAnd: RootBit) = 0 ifTrue: [			"record oop as root only if not already recorded"			rootTableCount < RootTableSize ifTrue: [				"record root only if there is room in the roots table"				rootTableCount _ rootTableCount + 1.				rootTable at: rootTableCount put: oop.				self longAt: oop put: (header bitOr: RootBit).			].		].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep'!aComment	"The mark phase is based on a pointer reversing traversal. This is a little tricky because the class, which is needed by the traversal, may be in either the header (as a compact class index) or in the word above the header. See memo 'Revised object format'.	Compact classes are marked and traced separately.	How do you know that you are returning from having marked a class? Parent pointer has 10 in low bits.Here are the states an object may be in, followed by what to do next in brackets []:  Start Object: parentField is set, [obj _ child]:	obj is pointed at by a field in parent that is being traced now. obj is marked.		[(parent goes up to the next field) field addr _ obj. go to Upward]	obj is pointed at by a field in parent that is being traced now. obj is unmarked. obj has no pointers.		[put 10 into low bits of header. field addr _ obj. go to Start Field (to process class word)]	obj is pointed at by a field in parent that is being traced now. obj is unmarked. obj has pointers.		[put 10 into low bits of header. point to last field. go to Start Field]  Start Field: 	Field ends in 10. It is the header. Short Class is not 0.		[Set low bits to correct value. (have parent pointer) go to Upward]	Field ends in 10. It is the header. Short Class is 0.		[child _ word above header. low bits of child _ 01. class word _ parentField. parentField _ loc of class word. go to Start Obj]	Field is Integer.		[point one word up, go to Start Field]	Field is oop.		[child _ field. field _ parentField. parentField _ loc of field. go to Start Obj]  Upward [restore low bits of header (at field addr)]:	parentField is 3. (bits 11, int 1).		[done!!]	parentField ends in 00.		[child _ field addr. field addr _ parentField. parentField _ field addr contents.		field addr contents _ child (addr of prev object. its oop). field addr - 4. go to Start Field]	parentField ends in 01. Were tracing the class.		[child _ field addr. field addr _ parentField (loc of class word). parentField _ field addr contents.		field addr contents _ child (addr of prev object. its oop). field addr + 4 (header). go to Upward]"!markAndTrace: oop	"Mark all objects reachable from the given one. Trace from the given object even if it is old or already marked. Mark it only if it is a young object."	"Tracer state variables:		child		object being examined		field		next field of child to examine		parentField	field where child was stored in its referencing object"	| header lastFieldOffset action |	"record tracing status in object's header"	header _ self longAt: oop.	header _ (header bitAnd: AllButTypeMask) bitOr: HeaderTypeGC.	oop >= youngStart ifTrue: [ header _ header bitOr: MarkBit ].  "mark only if young"	self longAt: oop put: header.	"initialize the tracer state machine"	parentField _ GCTopMarker.	child _ oop.	lastFieldOffset _ self lastPointerOf: oop.	field _ oop + lastFieldOffset.	action _ StartField.	"run the tracer state machine until all objects reachable from oop are marked"	[action = Done] whileFalse: [		action = StartField	ifTrue: [ action _ self startField ].		action = StartObj		ifTrue: [ action _ self startObj ].		action = Upward		ifTrue: [ action _ self upward ].	].!markPhase	"Mark phase of the mark and sweep garbage collector. Set the mark bits of all reachable objects. Free chunks are untouched by this process."	"Assume: All non-free objects are initially unmarked. Root objects were unmarked when they were made roots. (Make sure this stays true!!!!)."	| i oop |	"clear the recycled context lists"	freeSmallContexts _ NilContext.	freeLargeContexts _ NilContext.	"trace the interpreter's objects, including the active stack and special objects array"	self markAndTraceInterpreterOops.	"trace the roots"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		(self isIntegerObject: oop) ifFalse: [ self markAndTrace: oop ].	].!startField	"Examine and possibly trace the next field of the object being traced. See comment in markAndTrace for explanation of tracer state variables."	| typeBits childType |	child _ self longAt: field.	typeBits _ child bitAnd: TypeMask.	(typeBits bitAnd: 1) = 1 ifTrue: [		"field contains a SmallInteger; skip it"		field _ field - 4.		^ StartField	].	typeBits = 0 ifTrue: [		"normal oop, go down"		self longAt: field put: parentField.		parentField _ field.		^ StartObj	].	typeBits = 2 ifTrue: [		"reached the header; do we need to process the class word?"		(child bitAnd: 16r1F000) ~= 0 ifTrue: [			"object's class is compact; we're done"			"restore the header type bits"			child _ child bitAnd: AllButTypeMask.			childType _ self rightType: child.			self longAt: field put: (child bitOr: childType).			^ Upward		] ifFalse: [			"object has a full class word; process that class"			child _ self longAt: (field - 4).  "class word"			child _ child bitAnd: AllButTypeMask.  "clear type bits"			self longAt: (field - 4) put: parentField.			parentField _ (field - 4) bitOr: 1.  "point at class word; mark as working on the class."			^ StartObj		].	].!startObj	"Start tracing the object 'child' and answer the next action. The object may be anywhere in the middle of being swept itself. See comment in markAndTrace for explanation of tracer state variables."	| oop header lastFieldOffset |	oop _ child.	oop < youngStart ifTrue: [		"old object; skip it"		 field _ oop.		^ Upward	].	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [		"unmarked; mark and trace"		header _ header bitAnd: AllButTypeMask.		header _ (header bitOr: MarkBit) bitOr: HeaderTypeGC.		self longAt: oop put: header.		lastFieldOffset _ self lastPointerOf: oop.		field _ oop + lastFieldOffset.		^ StartField	"trace its fields and class"	] ifFalse: [		"already marked; skip it"		field _ oop.		^ Upward	].!sweepPhase	"Sweep memory from youngStart through the end of memory. Free all inaccessible objects and coalesce adjacent free chunks. Clear the mark bits of accessible objects. Compute the starting point for the first pass of incremental compaction (compStart). Return the number of surviving objects."	"Details: Each time a non-free object is encountered, decrement the number of available forward table entries. If all entries are spoken for (i.e., entriesAvailable reaches zero), set compStart to the last free chunk before that object or, if there is no free chunk before the given object, the first free chunk after it. Thus, at the end of the sweep phase, compStart through compEnd spans the highest collection of non-free objects that can be accomodated by the forwarding table. This information is used by the first pass of incremental compaction to ensure that space is initially freed at the end of memory. Note that there should always be at least one free chunk--the one at the end of the heap."	| entriesAvailable survivors freeChunk oop oopHeader oopHeaderType oopSize freeChunkSize |	entriesAvailable _ self fwdTableInit.	survivors _ 0.	freeChunk _ nil.	compStart _ nil.  "will be updated later"	oop _ self oopFromChunk: youngStart.	[oop < endOfMemory] whileTrue: [		"get oop's header, header type, and size"		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeFree)			ifTrue: [ oopSize _ oopHeader bitAnd: FreeSizeMask ]			ifFalse: [				oopHeaderType = HeaderTypeSizeAndClass					ifTrue: [ oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]					ifFalse: [ oopSize _ oopHeader bitAnd: 16rFC ].			].		(oopHeader bitAnd: MarkBit) = 0 ifTrue: [			"object is not marked; free it"			freeChunk ~= nil ifTrue: [				"enlarge current free chunk to include this oop"				freeChunkSize _ freeChunkSize + oopSize + (self extraHeaderBytes: oop).			] ifFalse: [				"start a new free chunk"				freeChunk _ oop - (self extraHeaderBytes: oop).  "chunk may start 4 or 8 bytes before oop"				freeChunkSize _ oopSize + (oop - freeChunk).  "adjust size for possible extra header bytes"				compStart = nil ifTrue: [					compStart _ freeChunk.				].			].		] ifFalse: [			"object is marked; clear its mark bit and possibly adjust the compaction start"			self longAt: oop put: (oopHeader bitAnd: AllButMarkBit).			entriesAvailable > 0 ifTrue: [				entriesAvailable _ entriesAvailable - 1.			] ifFalse: [				"start compaction at the last free chunk before this object"				compStart _ freeChunk.			].			freeChunk ~= nil ifTrue: [				"record the size of the last free chunk"				self longAt: freeChunk					    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).			].			freeChunk _ nil.			survivors _ survivors + 1.		].		oop _ self oopFromChunk: (oop + oopSize).  "get next oop"	].	freeChunk ~= nil ifTrue: [		"record size of final free chunk"		self longAt: freeChunk			    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).	].	oop = endOfMemory		ifFalse: [ self error: 'sweep failed to find exact end of memory' ].	compStart = nil		ifTrue: [ self error: 'expected to find at least one free object' ].	^ survivors!upward	"Return from marking an object below. Incoming:		field = oop we just worked on, needs to be put away		parentField = where to put it in our object	NOTE: Type field of object below has already been restored!!!!!!"	| type header |	(parentField bitAnd: 1) = 1 ifTrue: [		parentField = GCTopMarker ifTrue: [			"top of the chain"			header _ (self longAt: field) bitAnd: AllButTypeMask.			type _ self rightType: header.			self longAt: field put: header + type.  "install type on class oop"			^ Done		] ifFalse: [			"was working on the extended class word"			child _ field.	"oop of class"			field _ parentField - 1.  "class word, ** clear the low bit **"			parentField _ self longAt: field.			header _ self longAt: field+4.  "base header word"			type _ self rightType: header.			self longAt: field put: child + type.  "install type on class oop"			field _ field + 4.  "point at header"			"restore type bits"			header _ header bitAnd: AllButTypeMask.			self longAt: field put: (header + type).			^ Upward		].	] ifFalse: [		"normal"		child _ field.  "who we worked on below"		field _ parentField.  "where to put it"		parentField _ self longAt: field.		self longAt: field put: child.		field _ field - 4.  "point at header"		^ StartField	].! !!ObjectMemory methodsFor: 'gc -- compaction'!beRootWhileForwarding: oop	"Record that the given oop in the old object area points to an object in the young area when oop may be forwarded. Like beRoot:"	"Warning: No young objects should be recorded as roots. Callers are responsible for ensuring this constraint is not violated."	| header forwarding fwdBlock newHeader |	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		forwarding _ true.		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	] ifFalse: [		forwarding _ false.	].	(header bitAnd: RootBit) = 0 ifTrue: [		"record oop as root only if not already recorded"		rootTableCount < RootTableSize ifTrue: [			"record root only if there is room in the roots table"			rootTableCount _ rootTableCount + 1.			rootTable at: rootTableCount put: oop.			newHeader _ header bitOr: RootBit.			forwarding				ifTrue: [ self longAt: (fwdBlock + 4) put: newHeader ]				ifFalse: [ self longAt: oop put: newHeader ].		].	].!fwdBlockGet	"Return the address of a two-word forwarding block or nil if no more entries are available."	fwdTableNext _ fwdTableNext + 8.	fwdTableNext <= fwdTableLast		ifTrue: [ ^ fwdTableNext ]		ifFalse: [ ^ nil ].  "no more forwarding blocks available"!fwdBlockValidate: addr	"Raise an error if the given address is not a valid forward table entry."	(( addr > endOfMemory) and:	 [(addr <= fwdTableNext) and:	 [(addr bitAnd: 3) = 0]])		ifFalse: [ self error: 'invalid fwd table entry' ].!fwdTableInit	"Set the limits for a table of two-word forwarding blocks above the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used for compaction of memory and become-ing objects. Returns the number of forwarding blocks available."	"set endOfMemory to just after a minimum-sized free block"	self setSizeOfFree: freeBlock to: BaseHeaderSize.	endOfMemory _ freeBlock + BaseHeaderSize.	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	"use all memory free between freeBlock and memoryLimit for forwarding table"	fwdTableNext _ endOfMemory + BaseHeaderSize.	fwdTableLast _ memoryLimit - 8.  "last forwarding table entry"	(checkAssertions and: [(fwdTableLast bitAnd: MarkBit) ~= 0]) ifTrue: [		"Note: Address bits must not interfere with the mark bit in header of		 an object, which shows that the object is forwarded."		self error: 'fwd table must be in low half of the 32-bit address space'.	].	"return the number of forwarding blocks available"	^ (fwdTableLast - fwdTableNext) // 8  "round down"!incCompBody	"Move objects to consolidate free space into one big chunk. Return the newly created free chunk."	| bytesFreed |	"reserve memory for forwarding table"	self fwdTableInit.	"assign new oop locations, reverse their headers, and initialize forwarding blocks"	bytesFreed _ self incCompMakeFwd.	"update pointers to point at new oops"	self mapPointersInObjectsFrom: youngStart to: endOfMemory.	"move the objects and restore their original headers; return the new free chunk"	^ self incCompMove: bytesFreed!incCompMakeFwd	"Create and initialize forwarding blocks for all non-free objects following compStart. If the supply of forwarding blocks is exhausted, set compEnd to the first chunk above the area to be compacted; otherwise, set it to endOfMemory. Return the number of bytes to be freed."	| bytesFreed oop fwdBlock newOop |	bytesFreed _ 0.	oop _ self oopFromChunk: compStart.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifTrue: [			bytesFreed _ bytesFreed + (self sizeOfFree: oop).		] ifFalse: [			"create a forwarding block for oop"			fwdBlock _ self fwdBlockGet.			fwdBlock = nil ifTrue: [				"stop; we have used all available forwarding blocks"				compEnd _ self chunkFromOop: oop.				^ bytesFreed			].			newOop _ oop - bytesFreed.			self initForwardBlock: fwdBlock mapping: oop to: newOop.		].		oop _ self objectAfterWhileForwarding: oop.	].	compEnd _ endOfMemory.	^ bytesFreed!incCompMove: bytesFreed	"Move all non-free objects between compStart and compEnd to their new locations, restoring their headers in the process. Create a new free block at the end of memory. Return the newly created free chunk."	"Note: The free block used by the allocator always must be the last free block in memory. It may take several compaction passes to make all free space bubble up to the end of memory."	| oop next fwdBlock newOop header bytesToMove firstWord lastWord w newFreeChunk sz |	newOop _ nil.	oop _ self oopFromChunk: compStart.	[oop < compEnd] whileTrue: [		next _ self objectAfterWhileForwarding: oop.		(self isFreeObject: oop) ifFalse: [			"a moving object; unwind its forwarding block"			fwdBlock _ (self longAt: oop) bitAnd: AllButMarkBitAndTypeMask.			checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].			newOop _ self longAt: fwdBlock.			header _ self longAt: fwdBlock + 4.			self longAt: oop put: header.  "restore the original header"			bytesToMove _ oop - newOop.			"move the oop (including any extra header words)"			sz _ self sizeBitsOf: oop.			firstWord _ oop - (self extraHeaderBytes: oop).			lastWord _ (oop + sz) - BaseHeaderSize.			firstWord to: lastWord by: 4 do: [ :w |				self longAt: (w - bytesToMove) put: (self longAt: w).			].		].		oop _ next.	].	newOop = nil ifTrue: [		"no objects moved"		oop _ self oopFromChunk: compStart.		((self isFreeObject: oop) and: [(self objectAfter: oop) = (self oopFromChunk: compEnd)])			ifTrue: [ newFreeChunk _ oop ]			ifFalse: [ newFreeChunk _ freeBlock ].	] ifFalse: [		"initialize the newly freed memory chunk"		"newOop is the last object moved; free chunk starts right after it"		newFreeChunk _ newOop + (self sizeBitsOf: newOop).		self setSizeOfFree: newFreeChunk to: bytesFreed.	].	checkAssertions ifTrue: [		(self objectAfter: newFreeChunk) = (self oopFromChunk: compEnd)			ifFalse: [ self error: 'problem creating free chunk after compaction' ].	].	(self objectAfter: newFreeChunk) = endOfMemory ifTrue: [		self initializeMemoryFirstFree: newFreeChunk.	] ifFalse: [		"newFreeChunk is not at end of memory; re-install freeBlock"		self initializeMemoryFirstFree: freeBlock.	].	^ newFreeChunk!initForwardBlock: fwdBlock mapping: oop to: newOop	"Initialize the given forwarding block to map oop to newOop, and replace oop's header with a pointer to the fowarding block."	"Details: The mark bit is used to indicate that an oop is forwarded. When an oop is forwarded, its header (minus the mark bit) contains the address of its forwarding block. The first word of the forwarding block is the new oop; the second word is the oop's orginal header. The type bits of the forwarding header are the same as those of the original header."	| originalHeader originalHeaderType |	originalHeader _ self longAt: oop.	checkAssertions ifTrue: [		fwdBlock = nil			ifTrue: [ self error: 'ran out of forwarding blocks in become' ].		(originalHeader bitAnd: MarkBit) ~= 0			ifTrue: [ self error: 'object already has a forwarding table entry' ].	].	originalHeaderType _ originalHeader bitAnd: TypeMask.	self longAt: fwdBlock put: newOop.	self longAt: fwdBlock + 4 put: originalHeader.	self longAt: oop put: (fwdBlock bitOr: (MarkBit bitOr: originalHeaderType)).!isObjectForwarded: oop	"Return true if the given object has a forwarding table entry during a compaction or become operation."	^ (oop bitAnd: 1) = 0 "(isIntegerObject: oop) not" and:	   [ ((self longAt: oop) bitAnd: MarkBit) ~= 0 ]!lastPointerWhileForwarding: oop	"The given object may have its header word in a forwarding block. Find the offset of the last pointer in the object in spite of this obstacle."	| header fwdBlock fmt size methodHeader |	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		"oop is forwarded; get its real header from its forwarding table entry"		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	].	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 4 ifTrue: [		"do sizeBitsOf: using the header we obtained"		(header bitAnd: TypeMask) = HeaderTypeSizeAndClass			ifTrue: [ size _ (self sizeHeader: oop) bitAnd: 16rFFFFFFC ]			ifFalse: [ size _ header bitAnd: 16rFC ].		^ size - BaseHeaderSize	].	fmt < 12 ifTrue: [ ^ 0 ].  "no pointers"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize!mapPointersInObjectsFrom: memStart to: memEnd	"Use the forwarding table to update the pointers of all non-free objects in the given range of memory. Also remap pointers in root objects which may contains pointers into the given memory range."	| i oop |	"update interpreter variables"	self mapInterpreterOops.	"update pointers in root objects"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		((oop < memStart) or: [oop >= memEnd]) ifTrue: [			"Note: must not remap the fields of any object twice!!"			"remap this oop only if not in the memory range covered below"			self remapFieldsAndClassOf: oop.		].	].	"update pointers in the given memory range"	oop _ self oopFromChunk: memStart.	[oop < memEnd] whileTrue: [		(self isFreeObject: oop) ifFalse: [			self remapFieldsAndClassOf: oop.		].		oop _ self objectAfterWhileForwarding: oop.	].!objectAfterWhileForwarding: oop	"Return the oop of the object after the given oop when the actual header of the oop may be in the forwarding table."	| header fwdBlock realHeader sz |	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [ ^ self objectAfter: oop ].  "oop not forwarded"	"Assume: mark bit cannot be set on a free chunk, so if we get here,	 oop is not free and it has a forwarding table entry"	fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.	checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].	realHeader _ self longAt: fwdBlock + 4.	"following code is like sizeBitsOf:"	(realHeader bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: 16rFFFFFFC ]		ifFalse: [ sz _ realHeader bitAnd: 16rFC ].	^ self oopFromChunk: (oop + sz)!remap: oop	"Map the given oop to its new value during a compaction or become: operation. If it has no forwarding table entry, return the oop itself."	| fwdBlock |	(self isObjectForwarded: oop) ifTrue: [		"get the new value for oop from its forwarding block"		fwdBlock _ (self longAt: oop) bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		^ self longAt: fwdBlock	].	^ oop!remapClassOf: oop	"Update the class of the given object, if necessary, using its forwarding table entry."	"Note: Compact classes need not be remapped since the compact class field is just an index into the compact class table. The header type bits show if this object has a compact class; we needn't look up the oop's real header."	| classHeader classOop fwdBlock newClassOop newClassHeader |	(self headerType: oop) = HeaderTypeShort ifTrue: [ ^nil ].  "compact classes needn't be mapped"	classHeader _ self longAt: (oop - 4).	classOop _ classHeader bitAnd: AllButTypeMask.	(self isObjectForwarded: classOop) ifTrue: [		fwdBlock _ (self longAt: classOop) bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		newClassOop _ self longAt: fwdBlock.		newClassHeader _ newClassOop bitOr: (classHeader bitAnd: TypeMask).		self longAt: (oop - 4) put: newClassHeader.		"The following ensures that become: into an old object's class makes it a root.		  It does nothing during either incremental or full compaction because		  oop will never be < youngStart."		((oop < youngStart) and: [newClassOop >= youngStart])			ifTrue: [ self beRootWhileForwarding: oop ].	].!remapFieldsAndClassOf: oop	"Replace all forwarded pointers in this object with their new oops, using the forwarding table. Remap its class as well, if necessary."	"Note: The given oop may be forwarded itself, which means that its real header is in its forwarding table entry."	| fieldOffset fieldOop fwdBlock newOop |	fieldOffset _ self lastPointerWhileForwarding: oop.	[fieldOffset >= BaseHeaderSize] whileTrue: [		fieldOop _ self longAt: (oop + fieldOffset).		(self isObjectForwarded: fieldOop) ifTrue: [			"update this oop from its forwarding block"			fwdBlock _ (self longAt: fieldOop) bitAnd: AllButMarkBitAndTypeMask.			checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].			newOop _ self longAt: fwdBlock.			self longAt: (oop + fieldOffset) put: newOop.			"The following ensures that become: into old object makes it a root.			  It does nothing during either incremental or full compaction because			  oop will never be < youngStart."			((oop < youngStart) and: [newOop >= youngStart])				ifTrue: [ self beRootWhileForwarding: oop ].		].		fieldOffset _ fieldOffset - 4.	].	self remapClassOf: oop.! !!ObjectMemory methodsFor: 'become'!allYoung: array1 and: array2	"Return true if all the oops in both arrays, and the arrays themselves, are in the young object space."	| fieldOffset |	array1 < youngStart ifTrue: [ ^ false ].	array2 < youngStart ifTrue: [ ^ false ].	fieldOffset _ self lastPointerOf: array1.  "same size as array2"	[fieldOffset >= BaseHeaderSize] whileTrue: [		(self longAt: array1 + fieldOffset) < youngStart ifTrue: [ ^ false ].		(self longAt: array2 + fieldOffset) < youngStart ifTrue: [ ^ false ].		fieldOffset _ fieldOffset - 4.	].	^ true!become: array1 with: array2	"All references to each object in array1 are swapped with all references to the corresponding object in array2. That is, all pointers to one object are replaced with with pointers to the other. The arguments must be arrays of the same length. Returns true if the primitive succeeds."	"Implementation: Uses forwarding blocks to update references as done in compaction."	(self fetchClassOf: array1) = (self splObj: ClassArray) ifFalse: [ ^ false ].	(self fetchClassOf: array2) = (self splObj: ClassArray) ifFalse: [ ^ false ].	(self lastPointerOf: array1) = (self lastPointerOf: array2) ifFalse: [ ^ false ].	(self containOnlyOops: array1 and: array2) ifFalse: [ ^ false ].	(self prepareForwardingTableForBecoming: array1 with: array2) ifFalse: [		^ false  "fail; not enough space for forwarding table"	].	(self allYoung: array1 and: array2) ifTrue: [		"sweep only the young objects plus the roots"		self mapPointersInObjectsFrom: youngStart to: endOfMemory.	] ifFalse: [		"sweep all objects"		self mapPointersInObjectsFrom: (self startOfMemory) to: endOfMemory.	].	self restoreHeadersAfterBecoming: array1 with: array2.	self initializeMemoryFirstFree: freeBlock.  "re-initialize memory used for forwarding table"	^ true  "success"!containOnlyOops: array1 and: array2	"Return true if neither array contains a small integer. You can't become: integers!!"	| fieldOffset |	fieldOffset _ self lastPointerOf: array1.  "same size as array2"	[fieldOffset >= BaseHeaderSize] whileTrue: [		(self isIntegerObject: (self longAt: array1 + fieldOffset)) ifTrue: [ ^ false ].		(self isIntegerObject: (self longAt: array2 + fieldOffset)) ifTrue: [ ^ false ].		fieldOffset _ fieldOffset - 4.	].	^ true!exchangeHashBits: oop1 with: oop2	| hdr1 hdr2 |	hdr1 _ self longAt: oop1.	hdr2 _ self longAt: oop2.	self longAt: oop1 put:		((hdr1 bitAnd: AllButHashBits) bitOr: (hdr2 bitAnd: HashBits)).	self longAt: oop2 put:		((hdr2 bitAnd: AllButHashBits) bitOr: (hdr1 bitAnd: HashBits)).!prepareForwardingTableForBecoming: array1 with: array2	"Ensure that there are enough forwarding blocks to accomodate this become, then prepare forwarding blocks for the pointer swap. Return true if successful."	"Details: Doing a GC might generate enough space for forwarding blocks if we're short. However, this is an uncommon enough case that it is better handled by primitive fail code at the Smalltalk level."	| entriesNeeded entriesAvailable fieldOffset oop1 oop2 fwdBlock |	entriesNeeded _ 2 * ((self lastPointerOf: array1) // 4).  "need enough entries for both directions"	entriesAvailable _ self fwdTableInit.	entriesAvailable < entriesNeeded ifTrue: [		self initializeMemoryFirstFree: freeBlock.  "re-initialize the free block"		^ false	].	fieldOffset _ self lastPointerOf: array1.	[fieldOffset >= BaseHeaderSize] whileTrue: [		oop1 _ self longAt: array1 + fieldOffset.		oop2 _ self longAt: array2 + fieldOffset.		fwdBlock _ self fwdBlockGet.		self initForwardBlock: fwdBlock mapping: oop1 to: oop2.		fwdBlock _ self fwdBlockGet.		self initForwardBlock: fwdBlock mapping: oop2 to: oop1.		fieldOffset _ fieldOffset - 4.	].	^ true!restoreHeaderOf: oop	"Restore the original header of the given oop from its forwarding block."	| fwdHeader fwdBlock |	fwdHeader _ self longAt: oop.	fwdBlock _ fwdHeader bitAnd: AllButMarkBitAndTypeMask.	checkAssertions ifTrue: [		(fwdHeader bitAnd: MarkBit) = 0 ifTrue: [			self error: 'attempting to restore the header of an object that has no forwarding block'.		].		self fwdBlockValidate: fwdBlock.	].	self longAt: oop put: (self longAt: fwdBlock + 4).  "restore orginal header"!restoreHeadersAfterBecoming: list1 with: list2	"Restore the headers of all oops in both lists. Exchange their hash bits so becoming objects in identity sets and dictionaries doesn't change their hash value."	| fieldOffset oop1 oop2 |	fieldOffset _ self lastPointerOf: list1.	[fieldOffset >= BaseHeaderSize] whileTrue: [		oop1 _ self longAt: list1 + fieldOffset.		oop2 _ self longAt: list2 + fieldOffset.		self restoreHeaderOf: oop1.		self restoreHeaderOf: oop2.		self exchangeHashBits: oop1 with: oop2.		fieldOffset _ fieldOffset - 4.	].! !!ObjectMemory class methodsFor: 'initialization'!initialize	"ObjectMemory initialize"	self initializeSpecialObjectIndices.	self initializeObjectHeaderConstants.	LargeContextSize _ 156.	SmallContextSize _ 76.	NilContext _ 1.  "the oop for the integer 0; used to mark the end of context lists"	AllocationsBetweenGCs _ 4000.  "do incremental GC after this many allocations"	MinimumForwardTableBytes _ 16000.  "bytes reserved for forwarding table (8 bytes/entry)"	RemapBufferSize _ 25.	RootTableSize _ 1000.  "number of root table entries (4 bytes/entry)"	"tracer actions"	StartField _ 1.	StartObj _ 2.	Upward _ 3.	Done _ 4.!initializeObjectHeaderConstants	BaseHeaderSize _ 4.	"masks for type field"	TypeMask _ 3.	AllButTypeMask _ 16rFFFFFFFF - TypeMask.	"type field values"	HeaderTypeSizeAndClass _ 0.	HeaderTypeClass _ 1.	HeaderTypeFree _ 2.	HeaderTypeShort _ 3.	"type field values used during the mark phase of GC"	HeaderTypeGC _ 2.	GCTopMarker _ 3.  "neither an oop, nor an oop+1, this value signals that we have crawled back up to the top of the marking phase."	"mask for a free chunk size"	FreeSizeMask _ 16r1FFFFFFC.	"base header word bit fields"	HashBits _ 16r1FFE0000.	AllButHashBits _ 16rFFFFFFFF - HashBits.	HashBitsOffset _ 17.	"masks for root and mark bits"	MarkBit _ 16r80000000.	RootBit _ 16r40000000.	AllButMarkBit _ 16rFFFFFFFF - MarkBit.	AllButRootBit _ 16rFFFFFFFF - RootBit.	AllButMarkBitAndTypeMask _ AllButTypeMask - MarkBit.!initializeSpecialObjectIndices	"Initialize indices into specialObjects array."	NilObject _ 0.	FalseObject _ 1.	TrueObject _ 2.	SchedulerAssociation _ 3.	ClassBitmap _ 4.	ClassInteger _ 5.	ClassString _ 6.	ClassArray _ 7.	"SmalltalkDictionary _ 8."  "Do not delete!!"	ClassFloat _ 9.	ClassMethodContext _ 10.	ClassBlockContext _ 11.	ClassPoint _ 12.	ClassLargePositiveInteger _ 13.	TheDisplay _ 14.	ClassMessage _ 15.	ClassCompiledMethod _ 16.	TheLowSpaceSemaphore _ 17.	ClassSemaphore _ 18.	ClassCharacter _ 19.	SelectorDoesNotUnderstand _ 20.	SelectorCannotReturn _ 21.	TheInputSemaphore _ 22.	SpecialSelectors _ 23.	CharacterTable _ 24.	SelectorMustBeBoolean _ 25.	ClassByteArray _ 26.	ClassProcess _ 27.	CompactClasses _ 28.	TheTimerSemaphore _ 29.	TheInterruptSemaphore _ 30.! !!ObjectMemory class methodsFor: 'translation'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'extraHdrBytes'		declareC: 'int extraHdrBytes[4] = {8, 4, 0, 0}'.	aCCodeGenerator var: 'memory'		declareC: 'unsigned char *memory'.	aCCodeGenerator var: 'remapBuffer'		declareC: 'int remapBuffer[', (RemapBufferSize + 1) printString, ']'.	aCCodeGenerator var: 'rootTable'		declareC: 'int rootTable[', (RootTableSize + 1) printString, ']'.! !!PaintBox methodsFor: 'access'!color	^ color!rectangle	^ rectangle! !!PaintBox methodsFor: 'display'!display	Display fill: rectangle fillColor: color.	color = Color white ifTrue:		[rectangle display: Color gray]!highlight	(rectangle insetBy: (-2 @ -2)) display: Color black!unHighlight	(rectangle insetBy: (-2 @ -2)) display: Color white! !!PaintBox methodsFor: 'initialization'!color: aColor rectangle: aRectangle	color _ aColor.	rectangle _ aRectangle! !!PaintBox methodsFor: 'accessing'!color: anObject	color _ anObject! !!PaintPalette methodsFor: 'access'!paletteOrigin	"Answer the initial origin at which to attempt to position the palette.  8/14/96 sw"	^ (paintWindow hostView insetDisplayBox perform: self offsetRegistrationCorner) + self savedOffset! !!PaintPalette methodsFor: 'display'!currentNibBox	|  currentNibSize currentlyRounded |	currentlyRounded _ paintWindow currentNibRounded.	currentNibSize _ paintWindow currentNibSize.	^ nibs detect: [:aNibBox | aNibBox nibSize = currentNibSize and: [aNibBox isRound == currentlyRounded]] ifNone: [nil]!display 	paletteBorder displayOn: Display. 	self displayColors.	self displayNibs.	self displayControlBoxes!displayColors	| currentColor currentColorBox |	currentColorBox _ paintWindow currentColorBox.	colors do: [:aColorBox |		aColorBox display.		aColorBox == currentColorBox ifTrue:			[aColorBox highlight]]!displayControlBoxes	(HaloIcons at: 'OKButton') displayAt: okayBox origin.	(HaloIcons at: 'CancelButton') displayAt: cancelBox origin.	Display fill: dragBox fillColor: Color blue.	Display border: menuBox width: 4!displayNibs	|  currentNibSize currentNibRounded |	currentNibSize _ paintWindow currentNibSize.	currentNibRounded _ paintWindow currentNibRounded.	nibs do: [:aNibBox |		aNibBox display.		(aNibBox nibSize = currentNibSize and:			[aNibBox isRound = currentNibRounded]) ifTrue:			[aNibBox highlight]]!nibChipWidth	^ 5!paintChipWidth	^ 10!restoreBitsBehindPalette	bitsBehindPalette displayOn: Display at: paletteBorder origin.! !!PaintPalette methodsFor: 'termination'!exitFormalities	self notePositionPreference.	self restoreBitsBehindPalette.	self preservePaintPotChoices! !!PaintPalette methodsFor: 'initialization'!cancelButtonDimensions	^ (HaloIcons at: 'CancelButton') boundingBox extent!currentPaintPotColors	SavedColors == nil ifTrue:		[SavedColors _ self standardColors].	^ SavedColors!initializeVerticalFrom: aPaintWindow	| aRect aBox canvasRectangle displayBB lrRect index aColor colorsPerRow count delta paletteOrigin |	paintWindow _ aPaintWindow.	colorsPerRow _ 5.	colors _ OrderedCollection new.	nibs _ OrderedCollection new.	paletteOrigin _ self paletteOrigin.	aRect _ (paletteOrigin + (12 @ 22)) extent: 10@10.	(1 to: (count _ self currentPaintPotColors size + (colorsPerRow - 1)) // colorsPerRow) do:		[:row |			lrRect _ aRect deepCopy.			1 to: colorsPerRow do:				[:column |					index _ (colorsPerRow * (row - 1)) + column.					index <= count ifTrue:						[aColor _ self currentPaintPotColors at: index.						aBox _ PaintBox new color:  aColor rectangle: lrRect.						colors add: aBox..						lrRect _ lrRect deepCopy moveBy: ((self paintChipWidth + 6) @ 0)]].				aRect _ aRect deepCopy moveBy: (0 @ (self paintChipWidth + 6))].				aRect _ aRect deepCopy moveBy: (8 @ 6).	self standardNibWidths do:		[:i |			aBox _ NibBox new color: Color darkGray nibSize: i rectangle: aRect rounded: false.			nibs add: aBox.			lrRect _ aRect deepCopy moveBy: (45 @ 0).			aBox _ NibBox new color: Color darkGray nibSize: i rectangle: lrRect rounded: true.			nibs add: aBox.			delta _ (((self nibChipWidth + (2 * i))) min: self maxVerticalNibDelta) max: self minVerticalNibDelta.			aRect _ aRect deepCopy moveBy: (0 @ delta)].	nibs do: [:aNib | aNib adjustBoxToMatchNibSize].	okayBox _ ((paletteOrigin x + 6) @ (aRect bottom + 10)) extent: self okButtonDimensions.	cancelBox _ (okayBox bottomLeft + (4 @ 4)) extent: self cancelButtonDimensions.	paletteRect _ (paletteOrigin + (4@4)) corner: (cancelBox corner + (8@8)).	paletteBorder _ Quadrangle region: (paletteOrigin corner: (paletteRect corner + (4@4))) borderWidth: 4 borderColor: Color blue insideColor: Color white.	dragBox _ paletteRect deepCopy extent: paletteRect extent x @ 6.	menuBox _ okayBox origin + (8 @ -30) extent: (60 @ 20).	((displayBB _ Display boundingBox) contains: paletteBorder)		ifFalse:			[aBox _ paletteBorder deepCopy forcedWithin: displayBB.			self setNewOrigin: (aBox origin + (4@4))].	bitsBehindPalette _ Form fromDisplay: paletteBorder!maxVerticalNibDelta	^ 36!minVerticalNibDelta	^ 8!okButtonDimensions	^ (HaloIcons at: 'OKButton') boundingBox extent!preservePaintPotChoices	SavedColors _ colors collect: [:aColorBox | aColorBox color]!restoreStandardPaletteColors	SavedColors _ self standardColors.	colors with: SavedColors do:		[:aPaintBox :aColor |			aPaintBox color: aColor].	self display!setNewOrigin: newOrigin	"Reposition the receiver such that its origin is at newOrigin.  8/8/96 sw"	| delta |	delta _ newOrigin - paletteBorder origin.	paletteRect moveBy: delta.	paletteBorder moveBy: delta.	colors do:		[:aColor | aColor rectangle moveBy: delta].	nibs do:		[:aNib | aNib rectangle moveBy: delta].	okayBox moveBy: delta.	cancelBox moveBy: delta.	dragBox moveBy: delta.	menuBox moveBy: delta!standardColors	^ (Color names copyWithout: #veryDarkGray) collect:		[:s | Color perform: s]!standardNibWidths	"As specified by Alan Kay, 8/96"	^ #(1 2 3 4 8 15 22 30)! !!PaintPalette methodsFor: 'mouse handling'!dragPaletteFrom: aPoint	"Drag the palette, given that the mouse went down at aPoint.  9/20/96 sw"	| aForm offset aLoc savedBits |	aForm _ Form fromDisplay: paletteBorder.	offset _ aPoint - paletteBorder topLeft.	"self restoreBitsBehindPalette."	savedBits _ aForm follow: [aLoc _ Sensor cursorPoint - offset]		while:	[Sensor anyButtonPressed] bitsBehind: bitsBehindPalette startingLoc: paletteBorder topLeft.	bitsBehindPalette _ savedBits.	self setNewOrigin: aLoc; display	!mouseDownAt: aPoint	"Check to see if mouse is down in the palette.  Return		true if mouse was down and we should continue.		false if mouse was NOT down in the palette.		#okay if user clicked in okay box.		#cancel if user clicked in cancel box"	| aBox newColor |	(paletteBorder containsPoint: aPoint) ifFalse: [^ false].	((dragBox containsPoint: aPoint) or:			[(paletteRect containsPoint: aPoint) not])		ifTrue:			[self dragPaletteFrom: aPoint.			^ true].	(menuBox containsPoint: aPoint)		ifTrue:			[self mouseDownInMenuBoxAt: aPoint.			^ true].	(okayBox containsPoint: aPoint) ifTrue: 		[Utilities awaitMouseUpIn: okayBox repeating: [] ifSucceed: 					[^ #okay].		^ true].	(cancelBox containsPoint: aPoint) ifTrue: 		[Utilities awaitMouseUpIn: cancelBox repeating: [] ifSucceed: 					[^ #cancel].		^ true].	(aBox _ colors detect: [:aPaintBox | aPaintBox rectangle containsPoint: aPoint] ifNone: [nil]) == nil		ifFalse:			[aBox == paintWindow currentColorBox				ifTrue:					["lazy double-click: rearm the palette"					Sensor waitNoButton.					aBox color: (newColor _ Color fromUser); display.					paintWindow currentColorBox: aBox.					paintWindow currentColor: newColor.					^ true].			paintWindow currentColorBox unHighlight.			paintWindow currentColorBox: aBox.			paintWindow currentColor: aBox color.			aBox highlight]		ifTrue:			[(aBox _ nibs detect: [:aNibBox | aNibBox rectangle containsPoint: aPoint] ifNone: [nil]) == nil				ifFalse:					[self currentNibBox unHighlight.					paintWindow currentNibSize: aBox nibSize round: aBox isRound.					self currentNibBox highlight]].	Sensor waitNoButton.	^ true!mouseDownInMenuBoxAt: aPoint	| aMenu reply |	aMenu _ SelectionMenu labels:		'paint another framecancel this frameset registration pointset center of rotationfillrevert to standard palette colors'	lines: #()	selections: #(paintAnotherFrame cancelThisFrame setRegistrationPoint setCenterOfRotation areaFill restoreStandardPaletteColors).	reply _ aMenu startUp.	reply == nil ifTrue: [^ self].	paintWindow perform: reply.	false ifTrue:   "This just for the help of Senders feature"		[self paintAnotherFrame; cancelThisFrame; setRegistrationPoint; setCenterOfRotation; fillCompletelyWithColor; restoreStandardPaletteColors; thisSpaceForRent]! !!PaintPalette methodsFor: 'positioning'!notePositionPreference	"Try to be smart about what the user intended when she repositioned the receiver, and store the results of this labor in the two class variables, SavedOffset and OffsetRegistrationCorner.  Example:  If the user left the palette with its top-left corner 10 pixels to the right of, and 5 pixels below, the top-right corner of the window being painted in, then we would store SavedOffset _ (10 @ 2) and OffsetRegistration _ #topRight.	This is obviously niggly stuff, and this method provides a place in which to put all the clever heuristics to make this all happen.  For the moment, we do all the offsets just from the top-right corner of the window"	paletteBorder center x > paintWindow canvasRectangle center x		ifTrue:			[SavedOffset _ paletteBorder topLeft - paintWindow canvasRectangle topRight.			OffsetRegistrationCorner _ #topRight]		ifFalse:			[SavedOffset _ paletteBorder topLeft - paintWindow canvasRectangle topLeft.			OffsetRegistrationCorner _ #topLeft]!offsetRegistrationCorner	OffsetRegistrationCorner == nil ifTrue:		[OffsetRegistrationCorner _ #topRight].	^ OffsetRegistrationCorner!savedOffset	SavedOffset == nil ifTrue:		[SavedOffset _ 20 @ 20].	^ SavedOffset! !!PaintPalette methodsFor: 'accessing'!colors	^ colors! !!PaintPalette class methodsFor: 'as yet unclassified'!initialize	"PaintPalette initialize"	SavedColors _ self new standardColors.	RoundedNibDots _ self new standardNibWidths collect:		[:n | Form dotOfSize: n] ! !!PaintWindow methodsFor: 'initialization'!dimTheWindow	Display fill: canvasRectangle rule: 1 fillColor: 		(Bitmap with: 16rFF00FF with: 16rFF00FF00)!initialColor	^ self currentColorBox color!initializeFor: aHostView	hostView _ aHostView.	canvasRectangle _ hostView canvas boundingBox.	self initializePalette!initialNibSize	^ 4! !!PaintWindow methodsFor: 'menu commands'!areaFill	"Fill the painting area entirely with the color chosen"		| interiorPoint bwForm |	Cursor crossHair showWhile:			[interiorPoint _ Sensor waitButton.	Cursor execute showWhile:		[bwForm _ pen2 destForm shapeFill: self currentColor interiorPoint: interiorPoint.		pen3 destForm fillShape: bwForm fillColor: self currentColor]]!cancelThisFrame	self notYetImplemented!fillCompletelyWithColor	"Fill the painting area entirely with the color chosen"		pen2 destForm fillWithColor: self currentColor.	(Quadrangle region: canvasRectangle borderWidth: 1 borderColor: self currentColor insideColor: self currentColor) displayOn: Display.	bMin _ canvasRectangle topLeft.	bMax _ canvasRectangle bottomRight	!paintAnotherFrame	self notYetImplemented!restoreStandardPaletteColors	palette restoreStandardPaletteColors!setCenterOfRotation	self notYetImplemented!setRegistrationPoint	self notYetImplemented! !!PaintWindow methodsFor: 'access'!canvasRectangle	^ canvasRectangle!currentColor	^ currentColor!currentColor: aColor	currentColor _ aColor.	self eachPenDo: [:aPen | aPen color: currentColor]!currentColorBox	currentColorBox == nil ifTrue:		[currentColorBox _ palette colors detect: [:aColorBox | aColorBox color = currentColor] ifNone: [palette colors at: 9]].	^ currentColorBox!currentColorBox: aColorBox	currentColorBox _ aColorBox.	currentColor _ aColorBox color.	self eachPenDo: [:aPen | aPen color: currentColor]!currentNibRounded	^ currentNibRounded == true!currentNibSize	^ currentNibSize!currentNibSize: aNibSize round: aBoolean	currentNibSize _ aNibSize.	currentNibRounded _ aBoolean.	self eachPenDo:		[:aPen | aBoolean			ifTrue:				[aPen roundNib: aNibSize]			ifFalse:				[aPen defaultNib: aNibSize].		aPen color: currentColor]!hostView	^ hostView! !!PaintWindow methodsFor: 'private'!eachPenDo: aBlock	"aBlock value: pen1."	aBlock value: pen2.	aBlock value: pen3!getPainting	^ self getPaintingStartingWith: nil at: nil!getPaintingStartingWith: initialForm at: aRectangle	|  mousePoint  stopRect outerRectangle mouseInPalette |	canvasRectangle _ hostView insetDisplayBox.	outerRectangle _ canvasRectangle insetBy: (-4@-4).	savedBits _ Form fromDisplay: outerRectangle.  "so screen can be restored after painting"	formWithFullPainting _ Form extent: canvasRectangle corner depth: 8.	self dimTheWindow.	initialForm ~~ nil ifTrue:		[formWithFullPainting copy: (aRectangle translateBy: canvasRectangle origin) from: 0@0 in: initialForm theForm rule: Form over.		Display copy: (aRectangle translateBy: canvasRectangle origin) from: 0@0 in: initialForm theForm rule: Form over].	currentColor  _ self initialColor.	currentNibSize _ self initialNibSize. 	pen2 _ Pen newOnForm: formWithFullPainting.	pen3 _ Pen new.	self eachPenDo: [:aPen | aPen defaultNib: currentNibSize.					aPen color: currentColor].	palette display.	[Sensor anyButtonPressed] whileTrue: []. "Wait until mouse is clear "	[true] whileTrue:	[Sensor redButtonPressed ifTrue:		[mouseInPalette _ palette mouseDownAt: (mousePoint _ Sensor mousePoint).		((mouseInPalette == #okay) or: [mouseInPalette == #cancel]) ifTrue:  "This is the only exit!!"			[palette exitFormalities.			^ mouseInPalette "caller will grab the painting and bounds from my inst vars"].		mouseInPalette ifFalse:			[(canvasRectangle containsPoint: mousePoint)				ifFalse:					[Sensor waitNoButton]				ifTrue:					[self layDownPaintStartingAt: mousePoint]]]]!layDownPaintStartingAt: initialMousePoint	|  mousePoint |	mousePoint _ initialMousePoint.	bMin == nil ifTrue: [bMin _ mousePoint - (currentNibSize@currentNibSize + (1@1))].	bMax == nil ifTrue: [bMax _ mousePoint + (currentNibSize@currentNibSize + (1@1))].	pen2 place: mousePoint. pen3 place: mousePoint.	[Sensor redButtonPressed] whileTrue:		[mousePoint _ Sensor mousePoint.		(canvasRectangle containsPoint: mousePoint)			ifTrue:				[self eachPenDo: [:aPen | aPen goto: mousePoint].				bMin _ (mousePoint - (currentNibSize@currentNibSize + (1@1))) min: bMin.				bMax _ (mousePoint + (currentNibSize@currentNibSize + (1@1))) max: bMax]			ifFalse:				[Sensor waitNoButton]]! !!PaintWindow methodsFor: 'palette'!displayPalette	palette display!initializePalette	"Call only after canvasRectangle is initialized"	palette _ PaintPalette new initializeVerticalFrom: self! !!PaintWindow methodsFor: 'public interface'!backgroundFromUser	self getPainting == #cancel ifTrue: [^ nil].	(bMin == nil or: [bMax == nil]) ifTrue: [^ nil].	^ MaskedForm from: formWithFullPainting box: canvasRectangle!getRepaintedBackgroundStartingWith: startingForm	"Obtain a revised background painting from the user, given that the point of departure is startingForm, to be displayed in aRectangle."	| aBox aForm |	(self getPaintingStartingWith: startingForm at: canvasRectangle) = #cancel ifTrue: [^ nil].	(bMin == nil or: [bMax == nil]) ifTrue: [^ nil].	^ MaskedForm from: formWithFullPainting box: canvasRectangle!getRepaintingStaringWith: startingForm at: aRectangle	"Obtain a revised painting from the user, given that the point of departure is startingForm, to be displayed at aRectangle."	| aBox aForm |	(self getPaintingStartingWith: startingForm at: aRectangle) = #cancel ifTrue: [^ nil].	(bMin == nil or: [bMax == nil]) ifTrue: [^ nil].	aBox _ formWithFullPainting innerPixelRectFor: formWithFullPainting peripheralColor orNot: true.	aForm _ MaskedForm from: formWithFullPainting box: aBox.	^ Array with: aForm with: aBox!singleImageFromUser	"Let the user paint a single image, and return an array consisting of the form and its bounding box.  8/13/96 sw"	| aForm aBox |	self getPainting == #cancel ifTrue: [^ nil].	(bMin == nil or: [bMax == nil]) ifTrue: [^ nil].	aBox _ formWithFullPainting innerPixelRectFor: formWithFullPainting peripheralColor orNot: true.	aForm _ MaskedForm from: formWithFullPainting box: aBox.	^ Array with: aForm with: aBox! !!PaintWindow methodsFor: 'notes'!notes	"Singleton costumes.Registration points"! !!PathFromHome methodsFor: 'as yet unclassified'!comeFullyUpOnReload	"Normally, return self.  But if I am a path to a System object, return the true object from SqueakSupport.sysLibrary.  If was not there, install it now.  8/14/96 tk"	| theName |	self first = 'System' ifFalse: [^ self].	"a Normal path"	theName _ self last.	(SqueakSupport sysLibrary includesKey: theName) ifFalse: [			self halt: 'non-standard system object'.	"OK to proceed"			object == nil ifTrue: [^ self error: 'missing standard object'].			SqueakSupport sysLibrary at: theName put: object.			SqueakSupport sysLibrary at: object put: theName.].	^ SqueakSupport sysLibrary at: theName	"may be old one, not one we read in"!object	^ object!object: obj	object _ obj! !!PopUpMenu class methodsFor: 'instance creation'!labels: aString lines: anArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray."	^self new		labels: aString		font: (TextStyle default fontAt: 1)		lines: anArray! !!PositionableStream methodsFor: 'fileIn/Out'!nextChunk	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator _ $!!.	out _ WriteStream on: (String new: 1000).	self skipSeparators.	[(ch _ self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents! !!Preferences class methodsFor: 'hard-coded prefs'!startCollisionDetection	"Execute this to set the system to start collision detection"	"Preferences startLoggingUserScripts"	Preferences class compile:'collisionDetection	"Set to true if you want collision detection to take place automatically in HyperSqueak"	^ true' classified: 'HyperSqueak'!startLoggingUserScripts	"Execute this to set the system to start logging user scripts to the changes log.  7/18/96 sw"	"Preferences startLoggingUserScripts"	Preferences class compile:'logUserScripts	"Set to true if you want user scripts logged; later, we will maybe have a better way to specify this, or do something better altogether"	^ true' classified: 'HyperSqueak'!stopCollisionDetection	"Execute this to set the system to stop collision detection"	"Preferences startLoggingUserScripts"	Preferences class compile:'collisionDetection	"Set to true if you want automatic collision detection to take place"	^ false' classified: 'HyperSqueak'!stopLoggingUserScripts	"Execute this to set the system to stop logging user scripts to the changes log.  7/18/96 sw"	"Preferences stopLoggingUserScripts"	Preferences class compile:'logUserScripts	"Set to true if you want user scripts logged; later, we will maybe have a better way to specify this, or do something better altogether"	^ false' classified: 'HyperSqueak'! !!Preferences class methodsFor: 'HyperSqueak'!collisionDetection	"Set to true if you want automatic collision detection to take place"	^ false! !!ReturnNode methodsFor: 'C translation'!asTranslatorNode	^TReturnNode new setExpression: expr asTranslatorNode! !!Script methodsFor: 'as yet unclassified'!browseObjClass	"Open up a class browser on the receiver, so that its instance-specific methods can be viewed and edited.  6/11/96 sw	 6/29/96 sw: use browseObjClassForSelector:"	self beep!clonedInstance	"Answer a new Obj that starts out life with the same set of methods as the receiver has. 7/15/96 sw: don't copy the method dictionary in this case, or you'll be sorry!!"	| anInstance |	anInstance _ self class officialClass newUserInstance.	anInstance copyStateFrom: self.	^ anInstance!mouseUpAt: aPoint in: aView	"The mouse came up in the receiver; for now, open up a code browser on the parent.  6/29/96 sw"	aView relinquishControl.	objectContainedIn browseObjClassForSelector: self name asSymbol!storeDataOn: byteStream	"Make sure the scripts are up to date (and with comments) before writing them.  9/5/96 tk"		self flag: #noteToScott.  "Scott, The contents of scripts is not getting set to the commented script, even when logging is on.  I can't figure out why.  I had to redo it here.  I also fear that script objects might not keep up to date, and might not get created at all if they are never looked at.  We need them in order to file out correctly.  9/5/96 tk"	self contents: (objectContainedIn class sourceCodeAt: self name asSymbol).		"Still some danger that script object was not created"	^ super storeDataOn: byteStream!type	"Answer the receiver's formal type. 7/12/96 sw"	^ #Script! !!Script class methodsFor: 'as yet unclassified'!newUserInstance	"Answer an instance of an appropriate class to serve as a user object in the containment hierarchy.  7/13/96 sw"	^ self new! !!SequenceableCollection methodsFor: 'accessing'!indexOf: anElement startingAt: start ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	start to: self size do:		[:i | (self at: i) = anElement ifTrue: [^ i]].	^ exceptionBlock value! !!SequentialSound methodsFor: 'sound generation'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex pan: pan	"Play a collection of sounds in sequence."	"PluckedSound chromaticScale play"	| finalIndex i snd remaining count |	currentIndex = 0 ifTrue: [ ^ self ].  "already done"	finalIndex _ (startIndex + n) - 1.	i _ startIndex.	[i <= finalIndex] whileTrue: [		snd _ (sounds at: currentIndex).		[(remaining _ snd samplesRemaining) <= 0] whileTrue: [			"find next undone sound"			currentIndex < sounds size ifTrue: [				currentIndex _ currentIndex + 1.				snd _ (sounds at: currentIndex).			] ifFalse: [				currentIndex _ 0.				^ self  "no more sounds"			].		].		count _ (finalIndex - i) + 1.		remaining < count ifTrue: [ count _ remaining ].		snd mixSampleCount: count into: aSoundBuffer startingAt: i pan: pan.		i _ i + count.	].! !ShowContentsCostume comment:'A costume that shows the contents of an object'!!ShowContentsCostume methodsFor: 'everything'!couldBeWornBy: anObject	"Let the object decide if this kind of costume is suitable.  9/20/96 sw"	^ anObject isKindOf: Folder!defaultFrameDrawingParameter	^ true!display: anObject onCanvas: aCanvas	"Acting as a costume for anObject, show it on the given canvas.  6/12/96 sw"	anObject displayContentsOnCanvas: aCanvas!revealsContentsFor: anObject	"Answer whether the receiver reveals nested subparts on the contents side.  6/12/96 sw"	^ anObject isKindOf: Folder! !ShowOneElementCostume comment:'A costume that shows only one element of an object''s contents.  6/7/96 sw'!!ShowOneElementCostume methodsFor: 'menu'!chooseCostumeDetailsFor: anObject in: aView	"Lets the user do one-element-costume - specific things, rolodex-like.  Just beginning.  6/12/96 sw"	| reply |	reply _ (SelectionMenu labels: 'nextprevious' selections: #(nextElement previousElement)) startUp.	reply == #nextElement ifTrue:		[anObject advanceElementFor: self forward: true wrapping: true].	reply == #previousElment ifTrue:		[anObject advanceElementFor: self forward: false wrapping: true].! !!ShowOneElementCostume methodsFor: 'display'!couldBeWornBy: anObject	"Element costumes only wearable by Folder objects.  9/20/96 sw"	^ anObject isKindOf: Folder!display: anObject onCanvas: aCanvas	"Display the current element of the receiver on the given canvas.  6/12/96 sw"	self drawCurrentElementOf: anObject on: aCanvas!revealsContentsFor: anObject	"Answer whether the receiver reveals nested subparts on the contents side.  6/13/96 sw"	^ anObject isKindOf: Folder! !!ShowWorkingsCostume methodsFor: 'everytyhing'!defaultFrameDrawingParameter	^ true!display: anObject onCanvas: aCanvas	"Display an object's workings on the given canvas.  6/12/96 sw"	anObject displayWorkingsOnCanvas: aCanvas!revealsWorkingsFor: anObject	"Answer whether the receiver serves to reveal nested workings subparts.   6/12/96 sw"	^ true! !!SliderCostume methodsFor: 'as yet unclassified'!couldBeWornBy: anObject	"Sliders can only be worn by NumberObjects.  9/20/96 sw"	^ anObject isKindOf: NumberObj!display: anObject onCanvas: aCanvas	"Display the receiver on the canvas.  7/13/96 sw"	| currValue minValue maxValue aBox prop tinyRect denom colorToUse |	minValue _ anObject minimumValue.	maxValue _ anObject maximumValue.	denom _ maxValue - minValue.	currValue _ anObject currentNumericValue.	colorToUse _		denom <= 0			ifTrue:				[#black]			ifFalse:				[currValue > maxValue					ifTrue:						[#red]					ifFalse:						[currValue < minValue							ifTrue:								[#blue]							ifFalse:								[#lightMagenta]]].	aCanvas fillWithColor: (Color perform: colorToUse).	colorToUse == #lightMagenta ifFalse: [^ self].	aBox _ aCanvas boundingBox insetBy: (0 @ BarThickness //2).	prop _ (currValue - minValue) / denom.	tinyRect _ 0 @ ((1 - prop) * aBox height) extent: (aBox width @ BarThickness).	aCanvas  fill: tinyRect rule: Form over fillColor: Color black!mouseDownInCostumeFor: anObject at: aPoint in: aView	"The mouse has gone down in the interior of anObject at the given point in the given view, and the receiver is currently serving as that object's costume.  7/10/96 sw"		| aRectangle base minValue maxValue yValue valueRepresented delta |	aRectangle _ anObject layoutRectangle.	base _ aRectangle bottom.	minValue _ anObject minimumValue.	maxValue _ anObject maximumValue.	delta _ aView insetDisplayBox origin.	[Sensor anyButtonPressed] whileTrue:		[yValue _  ((Sensor cursorPoint - delta) adhereTo: aRectangle) y.		valueRepresented _ minValue + ((base - yValue)/aRectangle height) * (maxValue - minValue).		anObject contents: valueRepresented.		aView displayInterior]! !!SliderCostume class methodsFor: 'as yet unclassified'!initialize	"SliderCostume initialize"	BarThickness _ 6! !SqueakController comment:'The controller companioned to a SqueakView'!!SqueakController methodsFor: 'control'!close	"Close the receiver's window.  Intercepted here so that the window state can be stashed.  7/26/96 sw"	model storeWindowStateFrom: view.	super close!controlLoop	"Intercept the main control loop to assure the view is up to date.  May be redundant here?!!  6/12/96 sw"	view displayInterior.	super controlLoop!happyToInitiateRecognizerWith: aString	"Answer whether, if aString is obtained from an initial plunge into the character recognizer, it is a good enough start that we should really launch a fresh Text object.  9/18/96 sw"	^ (#('' ' ' '''' 'tab' 'cr' 'bs' ',' '.' '|' '-' '/' '\') includes: aString) not!open	"Open up a window on the receiver's model.  7/12/96 sw.	9/18/96 tk: give it size before make turtleTrailForm"	model openingIn: view.	view haloView controller updateHaloColors.	view resizeInitially.	"OK to do this twice?  Need for turtleTrailForm"	model allSubparts do:		[:anObject | anObject hasPenDefined			ifTrue:				[anObject pen setDestForm: view turtleTrailForm]].	super open!yellowButtonActivity	"Handle mouse downs in the window.  6/12/96 sw"	| aPoint aHaloObject drawingBox aRecognizer aString aTextObj |	drawingBox _ view insetDisplayBox.	aPoint _ Sensor cursorPoint - view insetDisplayBox origin.	(aHaloObject _ view haloObject) ~~ nil ifTrue:		[(aHaloObject haloRectangle containsPoint: aPoint)			ifTrue:				[^ (aHaloObject layoutRectangle containsPoint: aPoint)					ifTrue:						[aHaloObject catchMouseDownAt: aPoint in: view]					ifFalse:						[aHaloObject mouseDownInHaloAt: aPoint in: view]]			ifFalse:				[view abandonHaloObject]].	view visibleObjectsInOrder reverseDo:		[:anObj | (anObj layoutRectangle containsPoint: aPoint)			ifTrue: [^ anObj catchMouseDownAt: aPoint in: view]].	"Not over anything -- launch the Recognizer"	Cursor marker showWhile:		[aRecognizer _ CharRecog new.		aString _ ''.		aRecognizer recognizeAndDispatch:				[:str | aString _ str]			ifUnrecognized:				[:features | Cursor normal show.  view displayInterior.  ^ self]			until:				[aString size == 1 or: [(drawingBox containsPoint: Sensor cursorPoint) not]]]. 	(self happyToInitiateRecognizerWith: aString)		ifTrue:			[aTextObj _ TextObj newUserInstance.			model addNewObject: aTextObj butDoNotDisplayYetIn: view.			aTextObj contentsString: aString.			aTextObj layoutRectangle: (aPoint extent: aTextObj layoutRectangle extent).			aTextObj invalidateCanvas.			(drawingBox containsPoint: Sensor cursorPoint) ifTrue:				[aTextObj startUpRecognizerIn: view]]		ifFalse:			[Cursor normal show.			view displayInterior].! !!SqueakController methodsFor: 'menu'!browseObjClass	"Open a browser on the window's model.  6/12/96 sw"	view relinquishControl.	model browseObjClass!findContainer	"Pop up a menu listing the receiver and all of its ancestors; if the user chooses one of these, then open (if necessary) and activate the window that represents the specified ancestor.  5/16/96 sw	 7/17/96 sw: reversed order"	| objectList current menuList reply |	objectList _ OrderedCollection with: model.	current _ model.	[(current _ current objectContainedIn) ~~ nil]		whileTrue:			[objectList addFirst: current].	menuList _ objectList collect: [:o | o name].	reply _ (SelectionMenu labelList: menuList selections: objectList) startUpWithCaption: 'Containers...'.	(reply ~~ nil and: [reply ~~ model]) ifTrue:		[view displayDeEmphasized.		view relinquishControl.		reply openInOwnWindow]!inspectModel	"Inspect the receiver's model, after taking down the window halo.  6/12/96 sw"	view relinquishControl.	model inspect!redrawWindow	"Debugging: cause the window to be redisplayed.  6/12/96 sw"	view uncacheBits; display! !!SqueakController class methodsFor: 'as yet unclassified'!dragLaunch: aComponent image: image  offset: cursorOffset 	| topView notPasting offset potentialController origin border |	self flag: #scottPrivate.	topView _ ScheduledControllers activeController view.	notPasting _ true.	Cursor blank show.	image		follow: 			[Sensor cursorPoint - offset + cursorOffset.			potentialController _ ScheduledControllers potentialController.			(potentialController isKindOf: SqueakController)				ifTrue: [topView = potentialController view						ifTrue: 							[origin _ potentialController view insetDisplayBox origin]						ifFalse: [origin]]				ifFalse: [origin]]		while: [Sensor anyButtonPressed				& (topView ~= potentialController view				& ((potentialController isKindOf: SqueakController) not))].	Sensor anyButtonPressed		ifTrue: [topView switchWindows: potentialController						pasting: notPasting].	LaunchPoint _ origin - border.	^ origin + offset!objectToLaunch: anObject	"Establish anObject as the donor of the object to launch, as part of interwindow drag business.  6/17/96 sw"	ObjectToLaunch _ anObject!switchWindows 	"Check to see if the user clicked down in another window.  If not, just  return.  If so, see if the click window is a suitable receptor for interwindow drag.  6/17/96 sw - just starting."	| nextController |	self flag: #scottPrivate.  "beginning with some code lifted from Fabrik..."	nextController _ ScheduledControllers nextActiveController.	nextController isNil ifTrue: [^ self].	nextController == self ifTrue: [^ self].	"User clicked in another window"	(nextController isKindOf: SqueakController)		ifFalse: 			["cancel operation"			nextController view flash.			self objectToLaunch: nil.			Sensor waitNoButton.			^ nil].	ScheduledControllers unschedule: nextController.	ScheduledControllers scheduleActive: nextController! !!SqueakGraphic methodsFor: 'access'!frameCount	^ frames size!frameNumber: aNumber	frames size == 0 ifTrue: [self halt: 'no frames'.  ^ nil].	^ frames at: (aNumber min: frames size)!numberOfRotations	^ rotationCount! !!SqueakGraphic methodsFor: 'initialization'!addGraphicFrame: aFrame	frames == nil ifTrue: [frames _ OrderedCollection new].	frames add: aFrame!primaryImage	^ frames first primaryImage!singleFrame: aGraphicFrame	"Initialize the receiver to be a single-frame grapheme, possibly rotated"	frames _ OrderedCollection with: aGraphicFrame.	rotationCount _ aGraphicFrame rotationCount! !SqueakHaloController comment:'The controller companioned to a SqueakHaloView.  The job of this controller, primarily, is to maintain and manage the window halo.'!!SqueakHaloController methodsFor: 'control'!controlInitialize	"Set up the halo rectangles and show them.  2/19/96 sw"	| yellowBar scrollRect box |	box _ view apparentDisplayBox.	leftHalo region: (0 @ 0 extent: HaloWidth @ box height).	leftHalo _ leftHalo align: leftHalo topRight with: box topLeft.	savedLeftForm isNil ifTrue: [savedLeftForm _ Form fromDisplay: leftHalo].	leftHalo view: view superView.	rightHalo region: (0 @ 0 extent: HaloWidth @ box height).	rightHalo _ rightHalo align: rightHalo topLeft with: box topRight.	savedRightForm isNil ifTrue: [savedRightForm _ Form fromDisplay: rightHalo].	rightHalo view: view superView.	bottomHalo region: (0 @ 0 extent:  (box width + (2 * HaloWidth)) @ HaloWidth).	bottomHalo _ bottomHalo align: bottomHalo topLeft with: leftHalo bottomLeft.	savedBottomForm isNil ifTrue: [savedBottomForm _ Form fromDisplay: bottomHalo].	bottomHalo view: view superView.	self displayHalo!controlTerminate	"The mouse has exitted from the window + halo area.  Take down the window halos and restore the bits that were behind them.  6/12/96 sw"	super controlTerminate.	view superView abandonHaloObject; displayInterior.	savedLeftForm notNil 			ifTrue: 			[savedLeftForm displayOn: Display at: leftHalo topLeft.			savedLeftForm _ nil].	savedRightForm notNil 			ifTrue: 			[savedRightForm displayOn: Display at: rightHalo topLeft.			savedRightForm _ nil].	savedBottomForm notNil 			ifTrue: 			[savedBottomForm displayOn: Display at: bottomHalo topLeft.			savedBottomForm _ nil].!controlToNextLevel	"Main control sequence.  If mouse down, dispatch either to the interior or the halo.	 6/9/96 sw"	| aSqueakView |	aSqueakView _ view superView.	Sensor anyButtonPressed ifTrue:		[self viewHasCursor			ifFalse:  "Must be in window halo"				[self bottomHaloContainsCursor ifTrue:					[^ self mouseDownInBottomHalo].				self leftHaloContainsCursor ifTrue:					[^ self mouseDownInLeftHalo].				self rightHaloContainsCursor ifTrue:					[^ self mouseDownInRightHalo]].		^ aSqueakView controller yellowButtonActivity].	aSqueakView establishHaloObject.	sensor keyboardPressed ifTrue:		[aSqueakView processKeystroke: sensor keyboard].	aSqueakView frozen ifFalse:		[model tickIn: aSqueakView.		aSqueakView displayInterior]!fullArea	"Return the rectangle representing the receiver's inset display box, augmented by the surrounding halos.  6/6/96 sw"	| fullArea |	cachedFullArea ~~ nil ifTrue:		[^ cachedFullArea].	fullArea _ view insetDisplayBox.	fullArea _ fullArea merge: bottomHalo.	fullArea _ fullArea merge: leftHalo.	fullArea _ fullArea merge: rightHalo.	cachedFullArea _ fullArea.	^ cachedFullArea!invalidateCachedFullArea	"The window bounds have changed, so clobber the area cache.  6/12/96 sw"	cachedFullArea _ nil!isControlActive 	"Answer whether the cursor is within the bounds of the receiver's interior augmented by its halo.  6/6/96 sw"	| fullArea |	Sensor blueButtonPressed ifTrue: [^ false].	view isNil ifTrue: [^ false].	^ self fullArea containsPoint: sensor cursorPoint!mouseDownInBottomHalo	"The mouse went down in the bottom halo, so pass control on to it.  6/12/96 sw"	bottomHalo mouseDown!mouseDownInLeftHalo	"The mouse went down in the left halo, so pass control on to it.  6/12/96 sw"	^ leftHalo mouseDown!mouseDownInRightHalo	"The mouse went down in the right halo, so pass control on to it.  6/12/96 sw"	^ rightHalo mouseDown! !!SqueakHaloController methodsFor: 'halo'!bottomHalo	"Answer the receiver's bottomHalo object. 6/12/96 sw"	^ bottomHalo!bottomHaloContainsCursor	"Answer whether the cursor is anywhere within the bottom halo.  6/12/96 sw"	^ bottomHalo ~~ nil and:			[bottomHalo containsPoint: sensor cursorPoint]!displayHalo	"Display the window halo.  6/12/96 sw"	leftHalo display.	rightHalo display.	bottomHalo display!leftHalo	"Answer the receiver's leftHalo object. 6/12/96 sw"	^ leftHalo!leftHaloContainsCursor	"Answer whether the cursor is anywhere within the left halo.  6/12/96 sw"	^ leftHalo notNil and:			[leftHalo containsPoint: sensor cursorPoint]!rightHalo	"Answer the receiver's rightHalo object. 6/12/96 sw"	^ rightHalo!rightHaloContainsCursor	"Answer whether the cursor is anywhere within the left halo.  6/12/96 sw"	^ rightHalo notNil and:			[rightHalo containsPoint: sensor cursorPoint]!updateAndDisplayHalo	"Change the colors of the window halo strips to reflect current state, and display the halo"	self updateHaloColors.	self displayHalo!updateHaloColors	"Change the colors of the window halo strips to reflect current state.  6/12/96 sw	 7/17/96 sw: separate out the displaying of halos from here"	| colorToUse |	colorToUse _ view superView frozen		ifTrue:			[Color red]		ifFalse:			[Color green].	bottomHalo insideColor: colorToUse.	colorToUse _ view superView showingHalos				ifTrue:			[Color yellow]		ifFalse:			[Color lightGray].	leftHalo insideColor: colorToUse.	rightHalo insideColor: colorToUse! !!SqueakHaloController methodsFor: 'initialization'!flamingoIconMenu	"Answer an icon menu for launching new objects.  7/17/96 sw"	^ (HaloIcon new view: view offset: (3@4) form: (HaloIcons at: 'NewObjects') menu: self flamingoMenu) caption: 'Add new...'!flamingoMenu	"Answer the flamingo menu for the window halo.  7/29/96 sw"	FlamingoMenu == nil ifTrue: [self class initializeFlamingoMenu].	^ FlamingoMenu!gorillaIconMenu	"Answer the 'general menu' icon for the window halo.  9/20/96 sw"	^ HaloIcon new view: view offset: (1@122) form: (HaloIcons at: 'Door3') menu: self gorillaMenu!gorillaMenu	"Answer the gorilla menu for the window halo.  7/29/96 sw"	GorillaMenu == nil ifTrue: [self class initializeGorillaMenu].	^ GorillaMenu!initialize	"Initialize the window halo.  6/12/96 sw"	sensor _ InputSensor default.	self initializeLeftHalo.	self initializeBottomHalo.	self initializeRightHalo!initializeBottomHalo	"Create and initialize the structures that will constitute the bottom halo in the window.  9/20/96 sw new icons"	| anIcon |	bottomHalo _ HaloStrip new initializeFor: view.	bottomHalo insideColor: Color green.	bottomHalo borderWidthLeft: 2 right: 2 top: 0 bottom: 2.	anIcon _ HaloToggleIcon new view: view offset: (4@0) form: (HaloIcons at: 'Stop') menu: nil.	anIcon actionBlock:		[:aView | aView toggleRunFreeze.		aView haloView controller updateAndDisplayHalo].	anIcon stateBlock: [:aView | aView frozen not] formIfFalse: (HaloIcons at: 'Stop').	bottomHalo addIcon: anIcon.	anIcon _ HaloButtonIcon new view: view offset: 46@2 form: (HaloIcons at: 'steps') menu: nil.	anIcon actionBlock: [:aView | ].	anIcon mouseDownBlock: [:aView | aView stepSimulation].	bottomHalo addIcon: anIcon.	anIcon _ HaloIcon new view: view offset: 84@8 form: (HaloIcons at: 'Bug') menu: (SelectionMenu labels: 'inspect objinspect SqueakViewTell SqueakView...' selections: #(inspectModel inspectView messageToView)).	bottomHalo addIcon: anIcon.	anIcon _ HaloToggleIcon new view: view offset: 137@2 form: (HaloIcons at: 'LeftArrow') menu: nil.	anIcon actionBlock: [:aView | aView goPrevious].	anIcon stateBlock: [:aView | true] formIfFalse: (HaloIcons at: 'LeftArrow').	bottomHalo addIcon: anIcon.	anIcon _ HaloToggleIcon new view: view offset: 176@2 form: (HaloIcons at: 'RightArrow') menu: nil.	anIcon actionBlock: [:aView | aView goNext ].	anIcon stateBlock: [:aView | true] formIfFalse: nil.	bottomHalo addIcon: anIcon.	anIcon _ self gorillaIconMenu.	anIcon offset: 216 @ 1.	bottomHalo addIcon: anIcon!initializeLeftHalo	"Create and initialize the structures that will constitute the left-side halo in the window.  6/12/96 sw"	| anIcon |	leftHalo _ HaloStrip new initializeFor: view.	leftHalo insideColor: Color yellow.	leftHalo borderWidthLeft:  2 right: 0 top: 2 bottom: 2.	anIcon _ HaloToggleIcon new view: view offset: (10@6) form: (HaloIcons at: 'ShowHalos') menu: (SelectionMenu labels: 'show haloshide halos' selections: #(showHalos hideHalos)).	anIcon actionBlock: [:aView | aView toggleShowingHalos].	anIcon stateBlock: [:aView | aView showingHalos] formIfFalse: (HaloIcons at: 'ShowNoHalos').	leftHalo addIcon: anIcon.	anIcon _ HaloToggleIcon new view: view offset: (10@38) form: (HaloIcons at: 'ShowNames') menu: (SelectionMenu labels: 'show nameshide names' selections: #(showNames hideNames)).	anIcon actionBlock: [:aView | aView toggleShowingNames; displayInterior].	anIcon stateBlock: [:aView | aView showingNames] formIfFalse: (HaloIcons at: 'ShowNoNames').	leftHalo addIcon: anIcon.	anIcon _ HaloToggleIcon new view: view offset: (10@70) form: (HaloIcons at: 'Workings closed') menu: (SelectionMenu labels: 'show contentsshow workings' selections: #(showContents showWorkings)).	anIcon actionBlock: [:aView | aView toggleShowingContents; displayInterior].	anIcon stateBlock: [:aView | aView showingContents] formIfFalse: (HaloIcons at: 'Workings open').	leftHalo addIcon: anIcon.!initializeRightHalo	"Create and initialize the structures that will constitute the right-side halo in the window.   9/20/96 sw"	| anIcon |	rightHalo _ HaloStrip new initializeFor: view.	rightHalo insideColor: Color yellow.	rightHalo borderWidthLeft: 0 right: 2 top: 2 bottom: 2.	rightHalo addIcon: self flamingoIconMenu.  "Toy-box --add-new-object menu"	anIcon _ HaloToggleIcon new view: view offset: 1 @ 46 form: (HaloIcons at: 'Brush3') menu: nil.	anIcon actionBlock: [:aView | aView addNewPainting].	anIcon stateBlock: [:aView | true] formIfFalse: (HaloIcons at: 'Brush3').	anIcon wantsRefresh: false.	rightHalo addIcon: anIcon.	anIcon _ HaloIcon new view: view offset: (4@88) form: (HaloIcons at: 'stack3') menu: nil.	anIcon mouseHandlingBlock: [:aView | aView controller findContainer].	rightHalo addIcon: anIcon! !!SqueakHaloController class methodsFor: 'class initialization'!initialize	"SqueakHaloController initialize"	HaloWidth _ 40.	self initializeFlamingoMenu.	self initializeGorillaMenu!initializeFlamingoMenu	"Answer an icon menu for launching new objects. 7/29/96 sw"	FlamingoMenu _ SelectionMenu labels: 'foldernumberstringbooleantextbuttonturtleobjectpainting' lines: #() selections: #(addNewFolder addNewNumber addNewString addNewBoolean addNewText addNewButton addNewTurtle addNewObject addNewPainting)!initializeGorillaMenu	"Initialize the Gorilla Menu, which (in the early HyperSqueak prototype) holds misellaneous general window-wide items. 8/13/96 sw: added scripts for contents."	"SqueakHaloController initializeGorillaMenu"	GorillaMenu _ SelectionMenu labels: 'save to disk...load from disk...add new cardpaste object from clipboardround up straysremove all objectsclear turtle trailsall pens downall pens upchoose background painting...paint new backgroundrepaint this backgroundview the picture libraryset window size...'	lines: #(2 4 6 9 12 13) selections: #(saveToDisk loadFromDisk newCard pasteObject roundUpStrays removeAllVisibleObjects clearTurtleTrailForm allPensDown allPensUp setBackgroundPicture paintNewBackground  repaintBackground   viewPictureLibrary chooseWindowSize)" browseObjClass scriptsForContents addPictureFromGIFImports"!windowHaloWidth	"Answer the standard, system-wide halo-width parameter, telling how wide all window halos should be.  7/13/96 sw"	^ HaloWidth! !SqueakHaloView comment:'The view companioned to a SqueakHaloController.  In this case, just about all the functionality is in the controller.'!!SqueakHaloView methodsFor: 'initialization'!defaultControllerClass	^ SqueakHaloController! !SqueakSupport comment:'A support class, maintaining the picture library and providing a large number of utilities, all on the class side'!!SqueakSupport class methodsFor: 'scott stuff'!editHyperSqueakMenuStrings	"Let the user edit the HyperSqueak menu strings. 7/13/96 sw"	StringHolderView open: HyperSqueakMenuStrings label: 'HyperSqueak Menu'!initializeHyperSqueakMenu	"Initialize the data structure that feeds the HyperSqueak screen menu"	HyperSqueakMenuStrings _ StringHolder new contents: 'SqueakSupport explainDemoSqueakSupport explainHalo------------------------------------------------SqueakSupport newFolderSqueakSupport openHomeObj pilotExampleObj cleanupFastObj lettersExample------------------------------------------------Browser newOnCategory: ''HyperSqueak-Obj''Browser newOnCategory: ''HyperSqueak-Costumes''Browser newOnCategory: ''HyperSqueak-Support''Browser newOnCategory: ''HyperSqueak-Painting''------------------------------------------------SqueakSupport openSqueakExpressionsWindowSqueakSupport toDoWindowSqueakSupport appleHillListSqueakSupport inspectPictureLibrarySqueakSupport inspectHaloIcons-------------------------------------------------CharRecog saveRecognizerDictionaryTo: ''Recognizer Dictionary''Preferences startLoggingUserScriptsPreferences stopLoggingUserScripts'"SqueakSupport initializeHyperSqueakMenu"!miscellaneousExpressions"SqueakSupport standardPictureLibrary keysDo:[:aKey | SqueakSupport standardPictureLibrary at: aKey put:	(MaskedForm transparentBorder: (SqueakSupport standardPictureLibrary at: aKey) theForm)]#('ToyBox w/ Sunburst.icon''ToyBox.icon''Mickey without name.icon''Mickey with name.icon''Mickey san Halo.icon''Mickey with Halo.icon') do:	[:aName | HaloIcons at: (aName copyUpTo: $.) put:		(MaskedForm newFromFileNamed: aName)](ChangeSorter gatherChangeSets collect: [:chs | chs name]) asSortedArrayChangeSorter gatherChangeSets collect: [:set | set name] #() do: [:chSetName |	SystemChanges assimilateAllChangesFoundIn: (ChangeSorter changeSetNamed: aName)].do: [:aName |	Smalltalk changes forgetAllChangesFoundIn: (ChangeSorter changeSetNamed: aName)].SqueakSupport removeSqueakClasseesFromChanges."!offerHyperSqueakMenu	"Offer up the HyperSqueak menu.  If the user chooses one, then evaluate it  8/5/96 sw"	"SqueakSupport offerHyperSqueakMenu"	| reply result aMenu index normalItemCount strings |	Preferences programmerMode ifFalse:		[^ self offerEndUserHyperSqueakMenu].	(HyperSqueakMenuStrings == nil or: [HyperSqueakMenuStrings isKindOf: Array])		ifTrue:			[self initializeHyperSqueakMenu].	strings _ HyperSqueakMenuStrings contents.	normalItemCount _ strings lineCount.	aMenu _ PopUpMenu labels: (strings, 'edit this menu') lines: (Array with: normalItemCount).	index _ aMenu startUp.	index == 0 ifTrue: [^ self].	reply _ aMenu labelString lineNumber: index.	reply size == 0 ifTrue: [^ self].	index > normalItemCount ifTrue:		[^ self editHyperSqueakMenuStrings].	Utilities evaluate: reply in: nil to: nil!parameterKeysAssigned	self flag: #noteToTed	"Here are the parameter keys assigned 7/18/96 sw after the shift to a costume dictionary indexed by symbols rather than costume objects...	AnimationPicture	AnimationStage	RotationName	CurrentElement	BoxColor	PictureName"!scottsDoIts	"Obj pilotExample.Obj cleanup.Obj browseSqueakClasses.SqueakSupport openSqueakExpressionsWindow.SqueakSupport toDoWindow.Obj openHome.Sensor keyboardCursor normal showSmalltalk recover: 5000Smalltalk sendersOf: #hotSmalltalk sendersOf: #hottestUtilities emergencyCollapseCharRecog reinitializeCharacterDictionaryScreenController installScottsScreenMenuScreenController revertToStandardMenus"!tempFileInList"FastDictionaryFix??'BBCountbitsEtc-di.cs''BBAlphaPaint.cs''BBSim-rgbDiff-improv.st''NewBBFunctions-di''Gif depth fix' 'RobustChangeLog' 'RemoveOldColorStuff-di''GradientFills-di''JoystickSupport' 'RoundBrushes-di''DirectoryFix''ColorBitEditor-di' 'PageTurning-di.cs''CharRecFix' 'FindFormShape-di''ColorBitEditor-di''FormShapeSupplement-sw''FixImageInspector-di''FormShapeSupplement-sw'Ted's HSno user superclassHS text r/w 2Fonts"!toDoWindow	UnsavableWorkspace labeled: 'To Do' containing: (self class firstCommentAt: #toDoWindow)"When an object gets cut, find and discard all windows whose models are descendents of it.Registration PointsOn goTo, etc., stash the bg parmsFlesh out turtle geometry functions.More 'retrieval' functions, plus an example.Animation costumesInterWindow drag//Parts Bin"	"SqueakSupport toDoWindow"! !!SqueakSupport class methodsFor: 'development support'!globalsOfClass: aClass	"Utility: answer a list of all globals whose values are of the given class.  6/12/96 sw"	^ (Smalltalk keys select: [:aKey | (Smalltalk at: aKey) isKindOf: aClass]) asSortedArray	"SqueakSupport globalsOfClass: MaskedForm"!initialize	"Initialize the support features -- at the moment, sets the picture library back to its (temporary) initial state.  5/20/96 sw	6/23/96 sw: initialize the new subdivided picture libraries	8/5/96 sw: transition to 3 libraries completed"	AnimationLibrary _ Dictionary new.	"SqueakSupport initialize"!openSqueakExpressionsWindow	"Open a window with some useful HyperSqueak expressions in it.  6/12/96 sw"	"SqueakSupport openSqueakExpressionsWindow"	UnsavableWorkspace labeled: 'Useful HyperSqueak Expressions' containing: self usefulStuffContents!putShipIntoPictureLibrary	"SqueakSupport putShipIntoPictureLibrary"	| aGraphicFrame rotatedShipArray |	rotatedShipArray _ (0 to: 350 by: 10) asArray collect:		[:aHeading | MaskedForm makeShip: 1 hd: aHeading].	aGraphicFrame _ GraphicFrame new initializeWithRotations: rotatedShipArray.	AnimationLibrary at: 'Ship' put: (SqueakGraphic new singleFrame: aGraphicFrame)!reversedFormSetFrom: anArray	"Fudge:  transform an array of counterclockwise rotations into one that goes clockwise.  6/12/96 sw"	| a s |	self flag: #noteToTed.  "Used to transform your counterclockwise rotation arrays to clockwise ones. "	a _ anArray copy.	s _ anArray size.	2 to: s do:		[:i | a at: i put: (anArray at: (s - i + 2))].	^ a"SqueakSupport reversedFormSetFrom: #(1 2 3 4 5)"!usefulStuffContents	^ self class firstCommentAt: #usefulStuffContents"Obj pilotExample.  ""a fresh start""Obj cleanup.         ""discards all old HyperSqueak objects""Obj openHome.Obj browseSqueakClasses.Smalltalk at: #TempPict put: (GIFReadWriter imageFrom: (FileStream oldFileNamed: 'kimya.gif')).SqueakSupport addLibraryForm: TempPict atKey: 'Kimya' rotated: false.SqueakSupport explainDemo.HaloIcons at: 'Hand' put:  (MaskedForm transparentBorder: (GIFReadWriter imageFrom: (FileStream oldFileNamed: 'hand.gif'))).SqueakSupport paintingFromUserIn: (50@50 extent: 400@300).SqueakSupport pictureNames.Utilities showFormsDictAcrossTopOfScreen: HaloIcons.SqueakSupport deletePictureNamed: 'test2'.SqueakSupport showRotationsForPicture: 'Ship'.(FileStream oldFileNamed: 'FileInChangeSet.cs') fileIn.(FileStream oldFileNamed: 'Icon filenames') edit.ChangeList browseFile: 'Gif.cs'ChangeList browseRecent: 10000"! !!SqueakSupport class methodsFor: 'end-user help'!explainCollisionDetection	UnsavableWorkspace labeled: 'Collision detection' containing: (self class firstCommentAt: #explainCollisionDetection)."To use collision detection, you need to have the 'collisionDetection' preference set to true.  You can do this by choosing 'Start collision detection' from the HyperSqueak menu.  (When you don't need it, be sure to choose 'Stop collision detection', or else you'll find that many things run far too slowly.)When collision detection is armed, and when the active Squeak window is running (window halo green at bottom), then whenever two objects collide, each of them is sent a message informing them of the fact.  These messages are..	lowerObject collides: #under with: upperObject in: aView&	upperObject collides: #over with: lowerObject in: aViewBy providing script for method collides:with:in: for an object, you can take appropriate actions upon collision.  The 'aView' argument is provided so that, for example, if you need to have the window refreshed after you do something in your script, you can achieve that by calling 'aView displayInterior'"	"SqueakSupport explainCollisionDetection"!explainDemo	"Open a window giving demo explanation.  7/25/96 sw"	"SqueakSupport explainDemo"	UnsavableWorkspace labeled: 'HyperSqueak - 23 August 1996' containing: self helpWindowContents!explainHalo	"Open a window giving halo explanation.  8/5/96 sw"	"SqueakSupport explainHalo"	UnsavableWorkspace labeled: 'The Window Halo' containing: self haloHelpContents!haloHelpContents	^self class firstCommentAt: #haloHelpContents"Icons in the control strip surrounding a window, in counterclockwise order from top left:  Green halo around face: halos showing.  Red halo around face: halos not showing.  Green line under face: names showing.  Red line under face: names not showing.  Screwdriver = show workings; Open folder = show contents  Stop sign - run or freeze the simulation  Footprints - single step.  Can lean on this.  Bug - debugging menus  Left arrow - go to preceding sibling  Right arrow - go to subsequent sibling  Doorway - miscellaneous menu  Stack of books - walk hierarchy (like cmd-click-on-title-bar)  Paint Brush - create a new painting  Toy Box - launch new object"	"Gives the contents of a help window for the demo.  8/23/96 swSqueakSupport resetHelpWindowContents.SqueakSupport explainDemo"!helpWindowContents	HelpWindowContents ~~ nil ifTrue: [^ HelpWindowContents].	^ HelpWindowContents _ self class firstCommentAt: #helpWindowContents"If halos are showing, mouse-over an object to see its halo The horizontal bar above the object is for dragging:    ** Just drag to move the object    ** Option-drag to copy the object    ** Control-drag to tear off an alias Click on either vertical halo bar to get object's menu.Methods for objects to override   mouseUpAt: aPoint in: aSqueakView   userDisplayOn: aCanvas   runIn: aViewMethods for scripts to call   openReusingWindow: aSqueakView   openReusingWindow: aSqueakView visualEffect: anEffect   advanceElementFor: aFolder forward: forwardBoolean wrapping: wrappingBoolean visualEffect: anEffectVisual effects available are...	Fade      FineFade      HorizontalFade  FineHorizontalFade     Squares  VerticalFade   ZoomIn           ZoomOut."	"Gives the contents of a help window for the demo.  6/12/96 swSqueakSupport resetHelpWindowContents.SqueakSupport explainDemo"!helpWindowContents: c	"Set the help window contents, stored in a class variable, as indicated.  6/12/96 sw"	HelpWindowContents _ c!newFolder	"Open a window on a new folder, plunked down in the home card.  7/13/96 sw"	"SqueakSupport newFolder"	| it |	Obj assureInitialized.	it _ Folder newUserInstance setDefaultCostume.	Obj homeObject addToContents: it atKey: 'Untitled'.	it setExtentToMatchCostume; openInOwnWindow!newStack	"Create enough new stuff that the fundamentals of a new 'stack' are present.  8/13/96 sw"	"SqueakSupport newStack"	| aStack aCard |	Obj assureInitialized.	aStack _ Folder newUserInstance setDefaultCostume.	Obj homeObject addToContents: aStack atKey: 'Stack 1'.	aStack setExtentToMatchCostume.	aCard _ Folder newUserInstance setDefaultCostume.	aStack addToContents: aCard atKey: aStack name,  ' Card 1'.	aCard  setExtentToMatchCostume.	aCard openInOwnWindow!offerEndUserHyperSqueakMenu	"Put up a menu intended for users rather than the system developers.  8/12/96 sw"	| aMenu reply |	aMenu _ SelectionMenu labels:'Open the Home stackMake a new FolderMake a new StackTed''s "Wandering Letters" ExampleExplain HyperSqueakExplain the HaloExplain collision detectionView the Picture LibraryStart logging user scriptsStop logging user scriptsStart doing collision detectionStop doing collision detectionWrite recognizer dictionary to diskRead recognizer dictionary from disk'	lines: #(4 7 8 10 12) 	selections: #(openHome newFolder newStack runWanderingLetters explainDemo explainHalo explainCollisionDetection inspectPictureLibrary startLoggingUserScripts stopLoggingUserScripts startCollisionDetection stopCollisionDetection writeRecognizerDictionary readRecognizerDictionary).		reply _ aMenu startUp.	reply == nil ifFalse:		[self perform: reply]!openHome	"Open a window on the Home card."	"SqueakSupport openHome"	Obj assureInitialized.	Obj homeObject openInOwnWindowTellingView:		[:aView | aView showNames: true.			aView showHalos: false.			aView frozen: true.			aView showContents: true]!readRecognizerDictionary	CharRecog readRecognizerDictionaryFrom: 'RecognizerDictionary'!resetHelpWindowContents	"The HelpWindowContents are cached in a class variable, with the real intention, not yet realized, that they be DisplayText that can have style changes.  If the method defining the contents changes, this needs to be called.  6/12/96 sw"	"SqueakSupport resetHelpWindowContents"	HelpWindowContents _ nil!runWanderingLetters	"Run Ted Kaehler's 'Wandering Letters' example"	FastObj lettersExample!startCollisionDetection	Preferences startCollisionDetection!startLoggingUserScripts	Preferences startLoggingUserScripts!stopCollisionDetection	Preferences stopCollisionDetection!stopLoggingUserScripts	Preferences stopLoggingUserScripts!writeRecognizerDictionary	CharRecog saveRecognizerDictionaryTo: 'RecognizerDictionary'! !!SqueakSupport class methodsFor: 'misc utilities'!colorFromUser	"Present the user with a list of color options, and return the chosen color number, or nil if user did not choose.  6/6/96 sw.	7/8/96 sw: new interface for obtaining color list."	| colors index |	colors _ Color allColorsForDepth: 8.	index _ (PopUpMenu labelArray: colors lines: #(7)) startUp.	^ index == 0		ifTrue: [nil]		ifFalse: [colors at: index]"SqueakSupport colorFromUser"!plausibleWindowRectangleFor: itsExtent	"anExtent is the extent desired for a new window.  Search the user's screen space for a slot in which such an extent could conceivably go.  Take into consideration currently-open Squeak windows only.  6/10/96 sw	7/13/96 sw: factor the window halo width into the equation, rather than using a hard-coded constant for the horizontal setback from left margin"	| cont sibRects itsWidth itsHeight availableArea possY possX possRect setback |	cont _ ScheduledControllers scheduledControllers select:		[:c | c isKindOf: SqueakController].	sibRects _ cont collect: [:c | c view windowBox].	setback _ SqueakHaloController windowHaloWidth.	itsWidth _ itsExtent x + 20.	itsHeight _ itsExtent y + 20.	availableArea _ Display boundingBox extent.	1 to: ((((availableArea y - 40) max: 40) // itsHeight) max: 1) do:		[:yInd |			possY _ 20 + ((yInd - 1) * itsHeight). 			1 to: ((((availableArea x - 40) max: 40) // itsWidth) max: 1) do:				[:xInd | possX _ setback + ((xInd - 1) * itsWidth).				possRect _ possX @ possY extent: itsExtent.				sibRects detect:					[:aRect | aRect intersects: possRect] ifNone:						["Eureka, or maybe Yreka!!"						^ possRect]]].	^ setback @ setback extent: itsExtent!visualEffectDictionary	"Answer the visual effect dictionary, initializing it if necessary.  7/25/96 sw"	VisualEffectDictionary == nil ifTrue:		[VisualEffectDictionary _ Dictionary new.		#(fadeImageCoarse:at: fadeImageFine:at: fadeImageHor:at: fadeImageHorFine:at: fadeImageSquares:at: fadeImageVert:at: zoomInTo:at: zoomOutTo:at:) with:		#('Fade'                 'FineFade'         'HorizontalFade'    'FineHorizontalFade''Squares'               'VerticalFade'     'ZoomIn'       'ZoomOut')	do:		[:a :b | VisualEffectDictionary at: b asLowercase put: a]].	^ VisualEffectDictionary	"SqueakSupport visualEffectDictionary"!visualEffectSelectorFor: aSymbol	"Map symbols that the user is expected to use to selectors to send to forms.  The visual effect dictionary is indexed by lower-case strings.  Note that the result of <symbol> asLowerCase is of type String.  7/26/96 sw"	^ self visualEffectDictionary at: aSymbol asLowercase ifAbsent: [nil] ! !!SqueakSupport class methodsFor: 'painting'!getPaintingIn: aView	^ (PaintWindow new initializeFor: aView) singleImageFromUser!rerotatePictureNamed: aPictureName	| aGraphic aCount anImage regPoint rotCenter |	aGraphic _ self animationLibrary at: aPictureName ifAbsent: [^ self inform: 'not found'].	aCount _ self rotationCountFromUser.	aCount == nil ifTrue: [^ self inform: 'rotation change abandoned!!'].	anImage _ aGraphic primaryImage.	regPoint _ anImage boundingBox center.	rotCenter _ regPoint.	self  addPicture: anImage atKey: aPictureName rotated: aCount registrationPoint: regPoint centerOfRotation: rotCenter!rotationCountFromUser	"Prompt the user user for how many rotations are desired for a graphic.  7/29/96 sw"	| reply |	reply _ (SelectionMenu labels: 'don''t rotate248121618facing right & facing left' lines: #(1) selections: #(1 2 4 8 12 16 18 99)) startUpWithCaption: 'How many rotations?'.	^ reply! !!SqueakSupport class methodsFor: 'picture library'!addLibraryForm: aForm atKey: aKey rotated: f	"Add the given form to the picture library, at the given key, rotating in a number of steps given by frame.  8/11/96 sw"		^ self addPicture: aForm atKey: aKey rotated: f registrationPoint: nil centerOfRotation: nil!addNewPicture: aForm	"Add the given form to the animation library, choosing an unused key and starting out its life unrotated"		|  aGraphicFrame aSqueakGraphic |	aGraphicFrame _ GraphicFrame new.	aGraphicFrame initializeForSingleFrame: aForm rotated: 1 registrationPoint: aForm boundingBox center centerOfRotation: aForm boundingBox center.	aSqueakGraphic _ SqueakGraphic new.	aSqueakGraphic singleFrame: aGraphicFrame.	AnimationLibrary at: self unusedPictureName put: aSqueakGraphic.	^ aSqueakGraphic!addPicture: aForm atKey: aKey rotated: f registrationPoint: regPoint centerOfRotation: rotCenter	"Add the given form to the animation library, at the given key, rotating in a number of steps given by frame.  8/8/96 sw	 8/14/96 sw return the SqueakGraphic object"		| entry frames aGraphicFrame aSqueakGraphic |	frames _ f.	frames == true ifTrue: [frames _ 12].	frames == false ifTrue: [frames _ 0].	aGraphicFrame _ GraphicFrame new.	aGraphicFrame initializeForSingleFrame: aForm rotated: frames registrationPoint: regPoint centerOfRotation: rotCenter.	aSqueakGraphic _ SqueakGraphic new.	aSqueakGraphic singleFrame: aGraphicFrame.	AnimationLibrary at: aKey put: aSqueakGraphic.	^ aSqueakGraphic!animatedPictureNames	"Return a list of names of animated pictures in the library. 8/8/96 sw"	^ (AnimationLibrary keys select:		[:aKey | (aKey endsWith: '-bg') not]) asSortedArray!animationLibrary	"Answer the system's animation picture library. 6/23/96 sw"	^ AnimationLibrary!animationNamed: pictName frameNumber: frameNumber rotatedBy: degrees	"Return a picture from the library, keyed by pictName, and rotated, if possible, by the number of degrees.  8/9/96 sw"	| aSqueakGraphic cIndex count sweep entry |	aSqueakGraphic _ AnimationLibrary at: pictName ifAbsent:  [^ nil].	entry _ aSqueakGraphic frameNumber: frameNumber.	(count _ entry imageCount) == 1 ifTrue: [^ entry imageNumber: 1].	sweep _ 360 / count.	cIndex _ (((degrees + (sweep//2)) rem: 360)//sweep) + 1.	^ entry imageNumber: cIndex!animationNamed: pictName rotatedBy: degrees	"Return a picture from the library, keyed by pictName, and rotated, if possible, by the number of degrees.  8/9/96 sw"	| entry cIndex count sweep |	entry _ AnimationLibrary at: pictName ifAbsent:  [^ nil].	(count _ entry frameCount) == 1 ifTrue: [^ entry frameNumber: 1].	sweep _ 360 // count.	cIndex _ (((degrees + (sweep//2)) rem: 360)//sweep) + 1.	^ entry frameNumber: cIndex!animationNames	"Return a list of names of animations in the library. 7/29/96 sw"	^ AnimationLibrary keys asSortedArray!deleteAnimationNamed: pictName	"Remove the picture of the given name from the animation picture library. 7/29/96 sw"	(AnimationLibrary includesKey: pictName)		ifTrue:			[AnimationLibrary removeKey: pictName]		ifFalse:			[self inform: 'Not found.']!hasAnimationNamed: aName	"Answer whether the animation picture library has a picture with the given name.  7/29/96 sw"	^ AnimationLibrary includesKey: aName!importPicture: anImage withKey: aKey	| aList rotations |	(self animationLibrary includesKey: aKey) ifTrue:		[^ self inform: 'Sorry, there is *already* a picture named ', aKey, ' in the picture library.'].	rotations _ (aKey endsWith: '-bg')		ifTrue:			[1]		ifFalse:			[SqueakSupport rotationCountFromUser].	rotations == nil ifTrue: [^ self inform: 'abandoned!!'].	self addLibraryForm: anImage atKey: aKey rotated: rotations.	self inform: 'Okay, picture "', aKey, '" added to the picture library'!inspectAnimations	"Open up a window on the animated picture library.  7/24/96 sw"	self animationLibrary inspectAnimationsWithLabel: 'Picture Library'!inspectHaloIcons	"Open up a window on the system's halo icons.  6/28/96 sw"	HaloIcons inspectFormsWithLabel: 'Halo Icons'	"SqueakSupport inspectHaloIcons"!inspectPictureLibrary	"Open up a window on the picture library. 8/11/96 sw"	self animationLibrary inspectAnimationsWithLabel: 'Picture Library'!libraryGraphicAtKey: aKey	^ self animationLibrary at: aKey ifAbsent: [nil]!pictureFormerlyNamed: oldName nowKnownAs: newName	self pictureRenamingHistory at: oldName put: newName!pictureRenamingHistory	PictureRenamingHistory == nil ifTrue: [PictureRenamingHistory _ Dictionary new].	^ PictureRenamingHistory!renamePictureNamed: picName toBe: newName	| aPicture |	picName = newName ifTrue: [^ false].	aPicture _ self animationLibrary at: picName ifAbsent: [nil].	aPicture == nil ifTrue: [self halt: 'old picture, infuriatingly, not found'].	(AnimationLibrary includesKey: newName) ifTrue:		[self inform: 'Sorry, that name is already taken'.		^ false].	AnimationLibrary removeKey: picName.	AnimationLibrary at: newName put: aPicture.	self pictureFormerlyNamed: picName nowKnownAs: newName.	^ true!replacePictureNamed: picName  withGraphicFrom: aForm	"Replace the entry keyed by picName with a new Graphic obtained from aForm.  8/21/96 sw"		|  aGraphicFrame aSqueakGraphic |	aGraphicFrame _ GraphicFrame new.	aGraphicFrame initializeForSingleFrame: aForm rotated: 1 registrationPoint: aForm boundingBox center centerOfRotation: aForm boundingBox center.	aSqueakGraphic _ SqueakGraphic new.	aSqueakGraphic singleFrame: aGraphicFrame.	AnimationLibrary at: picName put: aSqueakGraphic.	^ aSqueakGraphic!unusedPictureName	| trialName |	CurrentPictureNumber == nil ifTrue: [CurrentPictureNumber _ 0].	CurrentPictureNumber _ CurrentPictureNumber + 1.	trialName _ 'Pic', CurrentPictureNumber printString.	^ (self animationLibrary includesKey: trialName)		ifFalse:			[trialName]		ifTrue:			[self unusedPictureName]! !!SqueakSupport class methodsFor: 'system building'!createMakeFile	"Write the make file that will trigger a system build.  6/12/96 sw	 6/27/96 sw: oops, disable, not enable, logging!!	 7/8/96 sw: dispense with logging concerns	 7/8/96 sw: more wrangling with picture libs	 7/18/96 sw: trying to deal frontally with picture libs and background painting library	 8/5/96 sw: use Ref stream to read some things in; and avoid halts and warnings on the other side by using various subtrafuges"	"SqueakSupport createMakeFile" 	|  stream names |	stream _ (FileStream fileNamed: 'HyperSqueak-Make.st').	stream nextPutAll:'	|  squeakSupport |	ChangeSorter newChangesFromFile: ''HyperSqueak-Generic.cs''.'.	self squeakCategories do:		[:catName | 			stream cr; tab; nextPutAll: 'ChangeSorter newChangesFromFile: '''.			stream nextPutAll: catName.			stream nextPutAll: '.st''.'].	stream cr; tab; nextPutAll: 'squeakSupport _ Smalltalk at: #SqueakSupport.'.	stream cr; tab; nextPutAll: '#(readAnimationLibraryFromDisk readHaloIconsFromDisk finalSystemBuildingSteps) do:		[:sel | squeakSupport perform: sel]'.	stream close!createSqueakBuildFiles	"Create the build files which will allow for a fresh version of HyperSqueak to be built.  6/10/96 sw	In order for this to work right, the current change set needs to have in it all the non-Squeak changes that need to be brought forward to the next version.  It can have Squeak stuff in it as well -- no problem, since Squeak changes will be removed before it is filed out.  6/12/96 sw	8/12/96 sw: revised graphics strategy"	"SqueakSupport createSqueakBuildFiles"	Obj cleanup. 	self squeakCategories do:		[:cat | SystemOrganization fileOutCategory: cat].	self removeSqueakClassesFromChanges.	(FileStream fileNamed: 'HyperSqueak-Generic.cs') fileOutChanges.	self writeAnimationLibraryToDisk.	self writeHaloIconsToDisk.	self createMakeFile!finalSystemBuildingSteps	"Invoked by the make process, to get all the do-its not automatically triggered by class initialize statements executed.  6/10/96 sw"	self putShipIntoPictureLibrary!readAnimationLibraryFromDisk	"8/5/96 sw"	"SqueakSupport readAnimationLibraryFromDisk"	| aRefStream |	aRefStream _ ReferenceStream fileNamed: 'AnimationLibrary'.	AnimationLibrary _ aRefStream next.	aRefStream close!readHaloIconsFromDisk	"Read the halo icons from a disk-based reference-stream file. 8/20/96 sw"	"SqueakSupport readHaloIconsFromDisk"	| aRefStream |	aRefStream _ ReferenceStream fileNamed: 'HaloIcons'.	Smalltalk at: #HaloIcons put: aRefStream next.	aRefStream close!removeSqueakClassesFromChanges	"Cleanse the current ChangeSet of all changes relating to classes in the Squeak categories.  6/10/96 sw"	"SqueakSupport removeSqueakClassesFromChanges"	self squeakCategories do:		[:cat |			(SystemOrganization superclassOrder: cat)				do: [:class | class removeFromChanges]]!squeakCategories	"Answer a list of system categories that comprise the standard Squeak system. 8/11/96 sw"	^ #('HyperSqueak-Obj' 'HyperSqueak-Costumes' 'HyperSqueak-Support' 'HyperSqueak-Painting')!stuffForGatheringGenericChanges"| currChSet |currChSet _ Smalltalk changes.# ( 'GenericChanges' 'CollisionDetection' 'Obj Browser' 'MondayMisc' '6AugOne' '7AugOne' '7AugTwo' 'Painting' '8AugOne' '8AugFixes' '8AugTwo' 'FolderOfAliases'  'Stack Help' '9AugOne' '9AugTwo' 'RecognizerInText' 'LayoutRectFix' '9AugThree' '11AugOne' '11AugTwo' '11AugThree' '11AugFour' '6to11AugCombined' '12AugOne' '12AugReprise' '12AugLateOne' 'ObjSaveTK' 'SWSaveAmendments' '12AugLateTwo' '12AugLateThree' '12AugLateFour' 'TedMondayLate' ) do:	[:aName | currChSet assimilateAllChangesFoundIn: (ChangeSorter changeSetNamed: aName)]"!writeAnimationLibraryToDisk	"8/5/96 sw"	"SqueakSupport writeAnimationLibraryToDisk"	| aRefStream |	aRefStream _ ReferenceStream fileNamed: 'AnimationLibrary'.	aRefStream nextPut: AnimationLibrary.	aRefStream close!writeHaloIconsToDisk	"8/11/96 sw"	"SqueakSupport writeHaloIconsToDisk"	| aRefStream |	aRefStream _ ReferenceStream fileNamed: 'HaloIcons'.	aRefStream nextPut: HaloIcons.	aRefStream close! !!SqueakSupport class methodsFor: 'background painting'!addPainting: aForm atKeyLike: aString	"Find a key that is similar to aString, and add the supplied background painting to the library at that key; return the key.  8/11/96 sw"	| aKey |	aKey _ Utilities keyLike: aString withTrailing: '-bg' satisfying:		[:key | (AnimationLibrary includesKey: key) not].	self addPicture: aForm atKey: aKey rotated: false registrationPoint: aForm boundingBox center centerOfRotation: aForm boundingBox center.	^ aKey !backgroundPaintingNamed: aName	"Answer the background painting of the given name.  7/17/96 sw"	| aGraphic |	aGraphic _ self animationLibrary at: aName ifAbsent: [^ nil].	^ aGraphic primaryImage!backgroundPaintingNames	"Answer the names of available window-background paintings.  7/17/96 sw"	^( self animationLibrary keys select:		[:aKey | aKey endsWith: '-bg']) asSortedArray! !!SqueakSupport class methodsFor: 'sys library'!aComment	"The SysLibrary keeps all non-Obj objects that squeak fileOuts might expect to find as the fileIn.  TestStyles, items in Smalltalk, etc (classes are handled differently).  These objects are pointed to directly by objects that are being filed out.  8/13/96 tk	There are two kinds it items.  (1) Objects that come with every System.  	Names of these appear in the set, SysObjectNames.	Name -> value appears in SysLibrary dictinoary.	Objects a of this kind are never filed out.	A PathFromHome to one of these is filedOut when an Obj that points 		to it is filed out.	User changes to these object are not recorded in fileOuts 	User must rename the object to make changes stick.(2) Objects that the user added.	Names of these are not in SysObjectNames.	Name -> value appears in SysLibrary dictinoary.	Whenever a user files out an Obj that uses one of these, both the 		PathFromHome and the object are filed out.  	User changes to these object are recorded in fileOuts.	When filing in, if an object of the same name is in SysLibrary, the		old one, not the incoming one, is used.One tricky thing:  SysLibrary has two entries for each object.  (symbol -> object) and (object -> symbol).  The latter is to be able to find out quickly if this object is a system object.	For user defined objects, PathFromHome has an object field.  The object is stored in each path that is created.  When the first path comes in, it installs the object in SysLibrary, and following paths find it there.  If already in SysLibrary, use the one in the library."!initSysLib	"Put the standard things in the System Library.  8/13/96 tk""*** Note that any object installed here cannot point to itself from within itself.  Will read back in wrong.  See ReferenceStream.internalize: ***"	"SqueakSupport initSysLib"| ts font nn |SysObjectNames _ Set new.SysLibrary == nil ifTrue: [SysLibrary _ Dictionary new].	"preserve custom guys"TextConstants do: [:style | 	style class == TextStyle ifTrue: [		style fontArray do: [:font |			nn _ font name asSymbol.			SysObjectNames add: nn.			SysLibrary at: nn put: font.			SysLibrary at: font put: nn]]].			"Invert, so can find the name being used."SysObjectNames add: #Display.SysLibrary at: #Display put: Display.SysLibrary at: Display put: #Display.!preReleaseFileOut: bool	"Set whether we are allowed to write objects whose names appear in SysObjectNames.  Should normally be false.  8/19/96 tk"	PreReleaseFileOut _ bool!sysLibrary	^ SysLibrary!sysRef: anObject	"Send out a path or the real object?  See complex story below.  8/14/96 tk"	| key path hisName |	PreReleaseFileOut ifTrue: [^ anObject].		"There is no way to file out objects listed in SysObjectNames		because they are blocked!!  They are supposed to BE in the 		receiving system.   However, to prepare a release, we DO need to		file them out."	hisName _ SysLibrary at: anObject ifAbsent: [		"User forgot to put it in SysLibrary"		self halt: 'Proceed if ', anObject printString,			' really has custom fonts, etc.'.			"Tell Ted if you get this message" 		key _ anObject class name, anObject hash printString.		SysLibrary at: key put: anObject.		SysLibrary at: anObject put: key.		key].	"continue"	path _ PathFromHome with: 'System' with: hisName.	(SysObjectNames includes: hisName) ifTrue: [^ path].	path object: anObject.	"Write out non-standard object.  OK if written many times, ReferenceStream will catch them and only write one." 	^ path! !SqueakView comment:'A StandardSystemView subclass whose instances serve as top view for Squeak windows.  This serves to mediate between the old mvc windowing system and its attendant control structures, and the new, mvc-free, Squeak stuff inside the windows.'!!SqueakView methodsFor: 'access'!canvas	canvas == nil		ifTrue:			[canvas _ Form extent: ((self insetDisplayBox extent)  - (2@2)) depth: 8].	^ canvas!frozen	^ frozen == true!frozen: frozenFlag	frozen _ frozenFlag!haloView	^ self subViews first!mouseDownObject	^ mouseDownObject!mouseDownObject: anObject	mouseDownObject _ anObject!relinquishControl	"Some user request has led to a need to activate some other window, so make certain that the screen gets right for the current window while the getting is good.  5/15/96 sw"	mouseDownObject _ nil.	haloObject _ nil.	self haloView controller controlTerminate.	controller controlTerminate!showContents: aBoolean	showingContents _ (aBoolean == true).	self invalidateVisibleObjectCache!showHalos: aBoolean	"Set the showHalos flag as indicated.  56/6/96 sw"	showingHalos _ (aBoolean == true)!showingContents	showingContents == nil ifTrue:		[showingContents _ model canShowContents].	^ showingContents!showingNames	^ showingNames == true!showNames: aBoolean	"Set the showNames flag as indicated.  5/21/96 sw"	showingNames _ (aBoolean == true)!turtleTrailForm	"Answer the receiver's turtleTrailForm, creating it if necessary.  7/17/96 sw"	turtleTrailForm == nil ifTrue:		[turtleTrailForm _ Form extent: (self insetDisplayBox extent - (2@2)) depth: 8].	^ turtleTrailForm! !!SqueakView methodsFor: 'adding new objects'!addNewBoolean	model addNewObjectOfClass: #BooleanObj in: self!addNewButton	"Add a button object.  7/15/96 sw"	model addNewButtonIn: self!addNewFolder	model addNewObjectOfClass: #Folder in: self!addNewNumber	model addNewObjectOfClass: #NumberObj in: self!addNewObject	model addNewObjectIn: self!addNewPainting	"At user menu request, add a new vanilla object to the receiver, to be painted by the user.  6/28/96 sw"	model addNewPaintingIn: self!addNewString	model addNewObjectOfClass: #StringObj in: self!addNewText	model addNewObjectOfClass: #TextObj in: self!addNewTurtle	"Add a turtle object.  7/17/96 sw"	model addNewTurtleIn: self! !!SqueakView methodsFor: 'display'!allVisibleObjects	"Return a list of objects and subobjects currently visible in the receiver.  6/3/96 sw"	| aList |	visibleObjectCache ~~ nil ifTrue:		[^ visibleObjectCache].	aList _ OrderedCollection new.	self visibleObjectsInOrder do:		[:anObj | anObj addObjectsVisibleIn: self to: aList].	visibleObjectCache _ aList.	^ aList	 !applyVisualEffect: effectSelector	"Apply the visual effect given by effectSelector, which must have only an otherImage and topLeft parameter.  7/25/96 sw"	| tempForm anOffset |	tempForm _ Form extent: self canvas extent depth: 8.	anOffset _ self insetDisplayBox origin.	self displayInteriorExcept: nil showHalo: false onto: tempForm at: 0@0.	Display perform: effectSelector withArguments:		(Array with: tempForm with: anOffset)!backgroundPaintingName	^ backgroundPaintingName!backgroundPaintingName: aString	backgroundPaintingName _ aString.	model setParameter: aString forKey: #BackgroundPaintingName.	self backgroundPainting: (SqueakSupport backgroundPaintingNamed: aString)!displayInterior	"Display the interior of the receiver.  This is the bridge between the MVC world outside, and our new world inside.  5/20/96 sw	 6/22/96 sw main functionality devolved to a more general method."	^ self displayInteriorExcept: nil showHalo: true!displayInteriorExcept: noShowObject showHalo: showHalo	"Display the interior of the receiver.  This is the bridge between the MVC world outside, and our new world inside.  5/20/96 sw	 5/29/96 sw: don't draw if collapsed	 5/30/96 sw: obey contents/workings mode	 6/6/96 sw: display object halo of halo-object	 6/17/96 sw: display backgroundPainting	6/22/96 sw: add the noShowObject and the showHalo boolean	7/17/96 sw: turtle trail form	7/25/96 sw: call variant with a receiverForm argument"	self displayInteriorExcept: noShowObject showHalo: showHalo onto: Display!displayInteriorExcept: noShowObject showHalo: showHalo onto: receiverForm	"Display the interior of the receiver.  This is the bridge between the MVC world outside, and our new world inside.  7/25/96 sw: this variant has a receiverForm argument."	self displayInteriorExcept: noShowObject showHalo: showHalo onto: Display at: self insetDisplayBox origin!displayInteriorExcept: noShowObject showHalo: showHalo onto: receiverForm at: anOrigin	"Display the interior of the receiver.  This is the bridge between the MVC world outside, and our new world inside.  7/25/96 sw: this variant has receiverForm and anOrigin arguments"	self isCollapsed ifTrue: [^ self].	self uncacheBits.	canvas == nil		ifTrue:			[self canvas "creates it"]		ifFalse:			[canvas clear].	backgroundPainting == nil ifFalse:		[backgroundPainting displayOn: canvas at: 0@0 rule: Form over].	turtleTrailForm == nil ifFalse:		[turtleTrailForm displayOn: canvas at: 0@0 rule: Form under].	self showingContents		ifTrue:			[model displayContentsOnWindowCanvas: canvas except: noShowObject]		ifFalse:			[model displayWorkingsOnWindowCanvas: canvas except: noShowObject].	self showingNames ifTrue:		[model displayNamesOnWindowCanvas: canvas except: noShowObject in: self].	(showHalo and: [haloObject ~~ nil]) ifTrue:		[haloObject displayHaloIn: self].	canvas displayOn: receiverForm at: anOrigin!displaySubViews	"This is how MVC informs the top view to show its nested views recursively.  For our post-mvc world, we pass on control to displayInterior.  5/20/96 sw"	self displayInterior!invalidateVisibleObjectCache	visibleObjectCache _ nil!visibleObjectsInOrder	"Return a list of the subparts currently being shown.  5/30/96 sw	 7/12/96 sw: use contentsBackToFront"	^ self showingContents		ifTrue:			[model contentsBackToFront]		ifFalse:			[model workingsBackToFront]! !!SqueakView methodsFor: 'initialization'!acceptNewModel: anObject	"Change the receiver such that its model is now anObject.  7/12/96 sw.	8/5/96 sw: try to get label redisplayed	8/8/96 sw: call super, not self, relabel:"	model storeWindowStateFrom: self.	self model: anObject.	controller model: anObject.	self haloView model: anObject.	self haloView controller model: anObject.	canvas _ mouseDownObject _ visibleObjectCache _ executingObjectCache _ haloObject _ backgroundPainting _ turtleTrailForm _ layoutRectCache _ nil.	anObject canShowContents ifFalse: [self showContents: false].	super relabel: anObject name!defaultControllerClass	^ SqueakController!initialize	"Initialize the receiver.  6/10/96 sw"	super initialize.	frozen _ false.	mouseDownObject _ nil.	showingHalos _ true.	showingNames _ false.	minimumSize _ 120 @ 60! !!SqueakView methodsFor: 'frame'!adjustTurtleTrailForm	"The receiver's size has changed; adjust the turtleTrailForm accordingly, if indicated.  7/17/96 sw"	| newBox tempForm |	newBox _ 0@0 extent: self insetDisplayBox extent - (2@2).	turtleTrailForm == nil ifFalse:		[tempForm _ turtleTrailForm deepCopy.		turtleTrailForm setExtent: newBox extent depth: tempForm depth.		turtleTrailForm copy: newBox from: 0 @0 in: tempForm rule: Form over].	self visibleObjectsInOrder do:		[:anObject | anObject noteNewWindowBounds: newBox].	"What about not-currently visible guys?  What about guys NESTED?!!  Should full window or inset amount be used?"	!initialFrame	^ model windowBounds!moved	"The user has moved the receiver; take note.  6/10/96 sw	 7/15/96 sw: don't fail if collapsed"	model windowBounds: self displayBox.	self isCollapsed ifFalse:		[self haloView controller invalidateCachedFullArea]!reframeTo: newFrame	"Reframe receiver to aRectangle, adjusted to the minimum and maximum sizes.  DO NOT alter scaling.  Created in an atttempt to defeat mvc scaling upon resize; borrowed in part from work Dan did for Fabrik long ago in his 'mvc wars' effort.  5/13/96 sw	5/17/96 sw: merged in Dan's reframeTo: of 5/8/96; could not succeed in calling super.	6/10/96 sw: tell model of the change	6/15/96 sw: bug fix: avoid having window edge northward on each resize!!	6/23/96 sw: bug fix: don't have the STORED version of the window bounds edge northward"	| oldBox portRect |	self uncacheBits.	oldBox _ self windowBox.	portRect _ newFrame topLeft + (0@labelFrame height)				corner: newFrame corner.	self window: (newFrame translateBy: window topLeft - newFrame topLeft) viewport: portRect.	self setLabelRegion.	(oldBox areasOutside: self windowBox) do:		[:rect | ScheduledControllers restore: rect].	canvas _ nil.	self adjustTurtleTrailForm.	model windowBounds: portRect.	self haloView controller invalidateCachedFullArea.	self displayEmphasized!resizeTo: aRectangle	"Resize receiver to aRectangle, adjusted to the minimum and	maximum sizes.  DO NOT alter scaling.  Created in an atttempt to defeat mvc scaling upon resize; borrowed in part from work Dan did for Fabrik long ago in his 'mvc wars' effort.  5/13/96 sw	6/10/96 sw: tell the model the new window bounds so it can stash them in its state"	| newFrame |	window == nil ifTrue: [^ super resizeTo: aRectangle].	newFrame _ aRectangle deepCopy.	self window: (newFrame translateBy: window topLeft - newFrame topLeft)		viewport: newFrame.	model windowBounds: aRectangle.	canvas _ nil.	self adjustTurtleTrailForm! !!SqueakView methodsFor: 'object halo'!abandonHaloObject	haloObject _ nil!establishHaloObject	| currentHaloObject |	self showingHalos ifFalse: [^ self].	currentHaloObject _ haloObject.	haloObject _ self objectWithHalo.	haloObject ~~ currentHaloObject ifTrue: [self displayInterior]!haloObject	^ haloObject!objectWithHalo	"Determine which object, if any, currently has the halo.  If the receiver currently has a halo object, then leave it as such if the mouse is either over it or over its halo.  6/6/96 sw"	| p  |	p _ Sensor cursorPoint - self insetDisplayBox origin.	haloObject ~~ nil ifTrue:		[(haloObject haloRectangle containsPoint: p)			ifTrue:				[^ haloObject]].	self visibleObjectsInOrder reverseDo:		[:anObj | (anObj layoutRectangle containsPoint: p)			ifTrue: [^ anObj]].	^ nil!showingHalos	^ showingHalos! !!SqueakView methodsFor: 'menu cmnds - graphics'!addPictureFromGIFImports	| aList reply rotations |	aList _ Smalltalk gifImports keys asSortedArray.	aList size == 0 ifTrue: [^ self inform: 'Nothing found in GIFImports'].	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply == nil ifTrue: [^ self].	(SqueakSupport animationLibrary includesKey: reply) ifTrue:		[^ self inform: 'Sorry, there is *already* a picture named ', reply, ' in the standard picture library.'].	rotations _ (reply endsWith: '-bg')		ifTrue:			[1]		ifFalse:			[SqueakSupport rotationCountFromUser].	rotations == nil ifTrue:		[^ self inform: 'abandoned!!'].	SqueakSupport addLibraryForm: (Smalltalk gifImports at: reply) atKey: reply rotated: rotations.	self inform: 'Okay, picture "', reply, '" added to the picture library'!animationLibraryMenu	self inform: 'Not yet available'!backgroundPainting: aPainting	"Set the receiver's background painting"	backgroundPainting _ aPainting	!cacheBitsAsTwoTone	"Overridden so that full-color bitmap cache will result, though at some expense..."	^ false!chooseBackgroundColor	"Uniform color for open folder window.  Use existing backgroundPainting stuff.  9/13/96 tk"	| aPainting itsName color |	color _ Color fromUser.	aPainting _ InfiniteForm with: color.	itsName _ FillInTheBlank request: 'Name this color'.	itsName size = 0 ifTrue: [^ self].	itsName _ SqueakSupport addPainting: aPainting atKeyLike: itsName.	self backgroundPaintingName: itsName!paint	"At user request, put up a painting window, let the user create a painting, and when the user is done, prompt her for a name, and save the painting in the picture library. 8/7/96 sw	 8/13/96 sw: return, as the third element of the return array, the bounding box of the obtained painting"	"SqueakView new paint"	| pair aSqueakGraphic picName |	pair _ SqueakSupport getPaintingIn: self.	pair == nil ifTrue: [self uncacheBits; display. ^ nil].	aSqueakGraphic _ SqueakSupport addNewPicture: pair first.	picName _ SqueakSupport animationLibrary keyAtValue: aSqueakGraphic.	^ Array with: picName with: false with: pair last!paintNewBackground	| aPainting aPaintWindow itsName |	aPaintWindow _ PaintWindow new initializeFor: self.	aPainting _ aPaintWindow backgroundFromUser.	aPainting == nil ifTrue: [^ self].	itsName _ SqueakSupport addPainting: aPainting atKeyLike: model name.	self backgroundPaintingName: itsName!pictureLibraryMenu	"Lets the user to manipulate the picture library"	"SqueakView new paint"	| aMenu reply |	aMenu _ SelectionMenu labelList: 			#('add picture from GIFImports...'		   'delete picture...'		   'view pictures library..')		lines: #()		selections:			#(addPictureFromGIFImports				deleteStandardPicture				viewPictureLibrary).	reply _ aMenu startUp.	reply == nil ifFalse:		[self perform: reply]!repaintBackground	| aPainting aPaintWindow |	backgroundPainting == nil ifTrue: [^ self beep].	aPaintWindow _ PaintWindow new initializeFor: self.	(aPainting _ aPaintWindow getRepaintedBackgroundStartingWith: backgroundPainting) == #cancel ifTrue: [^ nil].	aPainting == nil ifTrue: [^ self].	SqueakSupport replacePictureNamed: self backgroundPaintingName withGraphicFrom: aPainting.	self backgroundPaintingName: self backgroundPaintingName "gets the new graphic installed".	self displayInterior!rotationLibraryMenu	"Lets the user to manipulate the rotated picture library"	| aMenu reply |	aMenu _ SelectionMenu labelList: 			#('add rotation from GIFImports...'		   'delete rotated picture...'		   'view rotation library..')		lines: #()		selections:			#(addRotationFromGIFImports				deleteRotatedPicture				viewRotationLibrary).	reply _ aMenu startUp.	reply == nil ifFalse:		[self perform: reply]!setBackgroundPicture	"Choose a background picture for the window.  7/17/96 sw"	| aList result |	aList _ SqueakSupport backgroundPaintingNames.	aList size == 0 ifTrue:		[^ self inform: 'Sorry, no background paintings available at this time'].	aList _ aList copyWith: #none.	result _ (SelectionMenu labelList: aList lines: (Array with: aList size - 1) selections: aList) startUpWithCaption: 'Choose a painting'.	result == #none ifTrue:		[self backgroundPaintingName: nil.		^ self].	result == nil ifFalse:		[self backgroundPaintingName: result]	!viewPictureLibrary	SqueakSupport inspectAnimations! !!SqueakView methodsFor: 'transition'!advanceElementFor: aFolder forward: forwardBoolean wrapping: wrappingBoolean transitionSelector: transitionSelector	"advance the 'current element' for aFolder by one, forward or backward depending on forwardBoolean, allowing wrap-around or not as indicated by wrappingBoolean, and applying transitionSelector for the transition.  8/5/96 sw"	| itsCostume tempForm  |	((itsCostume _ aFolder currentCostume) isKindOf: ShowOneElementCostume) ifFalse: [^ self].	aFolder advanceElementFor: itsCostume forward: forwardBoolean wrapping: wrappingBoolean.	tempForm _ Form extent:  self canvas extent depth: 8.	aFolder renderOnCanvas: tempForm.	Display perform: transitionSelector withArguments:		(Array with: tempForm with: (self insetDisplayBox origin)).	self displayInterior!advanceElementFor: aFolder forward: forwardBoolean wrapping: wrappingBoolean visualEffect: visualEffectName	"advance the 'current element' for aFolder by one, forward or backward depending on forwardBoolean, allowing wrap-around or not as indicated by wrappingBoolean, and applying visualEffectName for the transition.  8/5/96 sw"	| itsCostume tempForm  transitionSelector |	((itsCostume _ aFolder currentCostume) isKindOf: ShowOneElementCostume) ifFalse: [^ self].	transitionSelector _ SqueakSupport visualEffectSelectorFor: visualEffectName.	aFolder advanceElementFor: itsCostume forward: forwardBoolean wrapping: wrappingBoolean.	tempForm _ Form extent:  self canvas extent depth: 8.	aFolder renderOnCanvas: tempForm.	Display perform: transitionSelector withArguments:		(Array with: tempForm with: (self insetDisplayBox origin)).	self displayInterior! !!SqueakView methodsFor: 'menu commands'!allPensDown	"Put all objects' pens down.  7/24/96 sw"	self visibleObjectsInOrder do:		[:anObject | 			anObject penDownIn: self].	self  displayInterior!allPensUp	"Put all objects' pens down.  7/24/96 sw"	self visibleObjectsInOrder do:		[:anObject | 			anObject penUpIn: self].	self  displayInterior!browseObjClass	controller browseObjClass!chooseWindowSize	"Let the user specify a window size, and honor her bidding.  8/17/96 sw"	| reply |	reply _ (SelectionMenu labels: '640 x 480full screenshirnk to fit'	selections: #(resizeTo640x480 resizeToFullScreen shrinkToFit)) startUp.	reply == nil ifFalse:		[self perform: reply]!clearTurtleTrailForm	"Reset the turtle trail layer.  7/17/96 sw	 7/26/96 sw: forced redisplay"	turtleTrailForm ~~ nil ifTrue: 		[turtleTrailForm clear.		self displayInterior]!findContainer	controller findContainer!freezeSimulation	self frozen: true.	self haloView controller updateAndDisplayHalo!goNext	"If possible, navigate to the next element of the receiver's model.  7/25/96 sw"	| newModel |	(model == Obj homeObject or: [model residesInContents not])		ifTrue:			[^ self beep].	newModel _ model objectContainedIn elementAfter: model wrapping: true.	newModel == model		ifFalse:			[newModel openReusingWindow: self]		ifTrue:			[self flash]!goPrevious	"If possible, navigate to the previous element of the receiver's container's model.  7/25/96 sw"	| newModel |	(model == Obj homeObject or: [model residesInContents not])		ifTrue:			[^ self beep].	newModel _ model objectContainedIn elementBefore: model wrapping: true.	newModel == model		ifFalse:			[newModel openReusingWindow: self]		ifTrue:			[self flash]!hideHalos	self showHalos: false!hideNames	self showNames: false!loadFromDisk	"temporarily, just use file-list browser"	self relinquishControl.	FileList open!messageToView	"Debugging:  get a Smalltalk expression from the user, which will be evaluated in the context of the receiver, with the receiver as the block argument.  8/5/96 sw"	| aString blockSource aBlock |	aString _ FillInTheBlank request: '[:aView | ...]' initialAnswer: 'aView canvas clear'.	aString size == 0 ifTrue: [^ self].	blockSource _ '[:aView | ', aString, ']'.	aBlock _ Compiler evaluate: blockSource. 	aBlock value: self!newCard	"Replace the current window contents with a new 'card' derived from the existing one.  8/8/96 sw"	| newInst |	self showingContents ifFalse:		[^ self inform: 'New Card is only operative whenyou are looking at the contentsof a Folder.'].	newInst _ model copyObjectIn: nil offsetBy: (30 @ 10).  "absurdly arbitrary offset"	newInst openReusingWindow: self.	self uncacheBits; displayEmphasized!pasteObject	"If there's a previously-copied object waiting to be pasted, paste it.  7/18/96 sw"	| anObject |	(anObject _ Obj objectToPaste) == nil		ifTrue: [^ self inform: 'No object ever copied, sorry.'].	model pasteClonedObject: anObject in: self		!relabel: aString 	"Check that aString is a suitable new name for the receiver's model, and if it is, then apply the name.  Does not yet propagate to closed form of the receiver.  7/12/96 sw"	model == Obj homeObject ifTrue:		[^ self inform: 'Sorry, you can''t rename Home'].	(model couldBeNamed: aString) ifFalse:		[self inform: 'Sorry -- that name is already taken'.		^ self].	model assumeNewName: aString.	super relabel: aString!removeAllVisibleObjects	"Remove all the objects currently visible in the window.  7/12/96 sw"	| objs |	self visibleObjectsInOrder copy do:		[:anObject | 			model removeSubpart: anObject.].	self invalidateVisibleObjectCache; displayInterior!resizeTo640x480	| aWidth sizeLimit |	self relinquishControl..	aWidth _ SqueakHaloController windowHaloWidth.	sizeLimit _ DisplayScreen actualScreenSize.	self reframeTo: (Rectangle origin: (aWidth@2) extent: ((640 min: sizeLimit x)- (2 * aWidth) @ ((480 min: sizeLimit y) - aWidth))).	ScheduledControllers searchForActiveController!resizeToFullScreen	| aWidth |	self relinquishControl..	aWidth _ SqueakHaloController windowHaloWidth.	self reframeTo: (Rectangle origin: (aWidth@2) extent: (DisplayScreen actualScreenSize - ((2 * aWidth) @ aWidth))).	ScheduledControllers searchForActiveController!roundUpStrays	"Bring any objects that may have strayed beyond the boundary of the window back into view.  7/8/96 sw	8/14/96 sw: provide inset so that halo will be always be accessible"	| viewRectangle |	viewRectangle _ (0 @ 0 extent: self insetDisplayBox extent) insetBy: 4@4.	self visibleObjectsInOrder do:		[:anObject | anObject beVisibleIn: viewRectangle].	self displayInterior!runSimulation	self frozen: false.	self haloView controller updateAndDisplayHalo!saveToDisk	"Save the receiver's model to disk.  7/26/96 sw""Done so far: 1) Instance variables that hold direct pointers to Objs contained by me, store either an object reference (if in tree being written) or a Path (if outside).  Paths are resolved when the object comes back in.  This applies to objectContainedIn, currentCostume, and an Alias' contents.2) User Unique classes not written.  Name of superclass instead.  Reader creates a new unique class, different secret name, and then installs script methods in it.3) Pens go out in their entirety.8/16/96 tk"	| aFileName itsContainer aStream manager sz bytes |	"Check that Obj has not changed its order"	(Obj allInstVarNames at: 2) = 'objectContainedIn' ifFalse: [		self error: 'Please update constant 2 in Obj.storeDataOn:'].	(Obj allInstVarNames at: 7) = 'currentCostume' ifFalse: [		self error: 'Please update constant 7 in Obj.storeDataOn:'].	(Obj allInstVarNames at: 9) = 'canvas' ifFalse: [		self error: 'Please update constant 9 in Obj.storeDataOn:'].	(Alias allInstVarNames at: 5) = 'contents' ifFalse: [		self error: 'Please update constant 5 in Alias.storeDataOn:'].	model objectContainedIn == #purgatory ifTrue: [^ self beep].	aFileName _ model name asFileName.	aFileName _ FillInTheBlank request: 'File name?' initialAnswer: aFileName.	aFileName size == 0 ifTrue: [^ self beep].	SqueakSupport preReleaseFileOut: false.	"normal"	manager _ IncomingObjects new.	manager install: model.	sz _ manager objects growSize.	aStream _ ReferenceStream newFileNamed: aFileName.	aStream nextPut: ReferenceStream versionCode;		nextPut: manager instVarInfo;		nextPut: manager.	bytes _ aStream close.	sz = manager objects growSize ifFalse: [		self error: 'FileOut failed.  Too many custom costumes.'].		"See IncomingObjects.install:"	Transcript cr; show: 'Successfully saved to ', aFileName, ' with length ', bytes printString.!scriptsForContents	"See to it that in the contents of the receiver there are aliases to all the scripts that live inside all contents elements.  8/13/96 sw"	| startingContents anAlias |	self showingContents ifFalse: [^ self beep].	(startingContents _ model contents copy) do:		[:anObject |			anObject allScripts do:				[:aScript | (aScript hasAliasIn: startingContents)					ifFalse:						[anAlias _ Alias newUserInstance.						anAlias referTo: aScript.						anAlias useStandardCostumeNamed: 'Contents String'.						model addToContents: anAlias atKey: (aScript name, ' in ', anObject name)]]].	self displayInterior!showContents	model canShowContents ifFalse: [^ self inform: 'No!!'].	self showContents: true!showHalos	self showHalos: true!showNames	self showNames: true!showWorkings	self showContents: false!shrinkToFit	| aWidth |	true ifTrue: [^ self notYetImplemented].	self relinquishControl..	aWidth _ SqueakHaloController windowHaloWidth.	self reframeTo: (Rectangle origin: (aWidth@2) extent: (DisplayScreen actualScreenSize - ((2 * aWidth) @ aWidth))).	ScheduledControllers searchForActiveController!stepSimulation	"Advance the simulation one step -- requested from window halo.  6/7/96 sw"	self frozen ifFalse: [self freezeSimulation].	model tickIn: self.	self displayInterior!toggleRunFreeze	self frozen: self frozen not!toggleShowingContents	"If suitable, flip contents/workings mode flag.  6/10/96 sw"	model canShowContents ifFalse: [^ self beep].	showingContents _ showingContents not.	self invalidateVisibleObjectCache.	self applyVisualEffect: Form randomTransitionSelector!toggleShowingHalos	self showHalos: self showingHalos not.	self haloView controller updateAndDisplayHalo!toggleShowingNames	self showNames: self showingNames not! !!SqueakView methodsFor: 'unclassified'!dispatchCollisionInfo	"Check to see if any visible subparts have collided, and if so, dispatch info to them.  8/5/96 sw"	| objects count firstObject firstBox secondObject |	Preferences collisionDetection ifFalse: [^ self].	self showingContents ifFalse: [^ self].	objects _ self visibleObjectsInOrder.  "back to front"	1 to: ((count _ objects size) - 1) do:		[:firstIndex | 			firstObject _ (objects at: firstIndex).			firstBox _ firstObject layoutRectangle.			firstIndex + 1 to: count do:				[:secondIndex |					(firstBox intersects: ((secondObject _ (objects at: secondIndex))layoutRectangle))						ifTrue:							[firstObject collides: #under with: secondObject in: self.							secondObject collides: #over with: firstObject in: self]]]!processKeystroke: aCharacter	(aCharacter == Character backspace)		ifTrue:			[(haloObject == nil or:				[haloObject isKindOf: TextObj]) ifFalse:					[haloObject cutObjectIn: self.					self abandonHaloObject; displayInterior]]! !!StandardFileStream methodsFor: 'read, write, position'!next	"Read the next object from the file. 2/12/96 sw"	| count |	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.	count = 1		ifTrue: [ ^ buffer1 at: 1 ]		ifFalse: [ ^ nil ].! !!StandardSystemView methodsFor: 'label access'!label: aString 	"Set aString to be the receiver's label."	aString == nil		ifTrue:			[labelText _ nil.			labelFrame region: (0 @ 0 extent: 0 @ 0)]		ifFalse:			[labelText _ (Text string: aString emphasis: 5) asParagraph.			insetDisplayBox == nil ifTrue: [^ self].  "wait for further initialization"			self setLabelRegion]! !!StrikeFont methodsFor: 'accessing'!edit: character        "(TextStyle default fontAt: 1) edit: $_"        | charForm smallRect tempRect scaleFactor |        charForm _ self characterFormAt: character.        charForm displayAt: 0@0.        smallRect _ charForm boundingBox.        tempRect _ BitEditor locateMagnifiedView: charForm                                                scale: (scaleFactor _ 8@8).        BitEditor                openScreenViewOnForm: charForm                at: smallRect topLeft                magnifiedAt: tempRect topLeft                scale: scaleFactor.        self characterFormAt: character put: (Form fromDisplay: smallRect)! !!StringCostume methodsFor: 'everything'!chooseCostumeDetailsFor: anObject in: aView	"If the object is a string object, turn on the character recognizer.  7/17/96 sw"	(anObject isKindOf: StringObj)		ifTrue:			[anObject recognizeCharactersIn: aView]		ifFalse:			[self beep]!couldBeWornBy: anObject	"Element costumes only wearable by Folder objects.  9/20/96 sw"	^ anObject couldWearStringCostume!desiredExtentFor: anObject	"Answer the extent need for the receiver to serve as a costume for anObject.  6/10/96 sw"	| aString borderWidth |	borderWidth _ (anObject parameterFor: #StringBorderWidth ifAbsent: [1]).	borderWidth _ (borderWidth + 1) * 2.	"space, two sides"	aString _ anObject contentsString.	^ aString asDisplayText boundingBox extent + (borderWidth@borderWidth)!display: anObject onCanvas: aCanvas	"Display the object's contents string.  6/7/96 sw	Have a border with color.  9/6/96 tk"	| b |	(anObject parameterFor: #StringBorder ifAbsent: [false]) ifTrue:		[self drawFrame: anObject on: aCanvas].	"If make border thicker, clip the text.  User must resize or call setExtentToMatchCostume."	b _ anObject parameterFor: #StringBorderWidth ifAbsent: [1].	b _ b + 1.	"space"	anObject contentsString asDisplayText displayOn: aCanvas basicForm 		at: (b@b) 		clippingBox: (aCanvas boundingBox insetBy: b@b)		rule: Form over		fillColor: nil.	(anObject parameterFor: #StringOpaque ifAbsent: [true])		ifTrue: ["opaque paper"			aCanvas setForm: aCanvas basicForm 				transparentColor: nil]		ifFalse: ["transparent around the text"			aCanvas setForm: aCanvas basicForm 				transparentColor: Color white]. !drawFrame: anObject on: aCanvas	"Draw a frame around the user's layout rectangle.  6/6/96 sw	Get info from parameters, colored border.  9/6/96 tk"	|  aQuadrangle |	aQuadrangle _ Quadrangle extent: anObject layoutRectangle extent 		color: Color white 		borderWidth: 			(anObject parameterFor: #StringBorderWidth ifAbsent: [1]) 		borderColor: 			(anObject parameterFor: #StringBorderColor 				ifAbsent: [Color black]).  	aQuadrangle displayOn: aCanvas! !!StringObj methodsFor: 'as yet unclassified'!pasteTextIntoObject	"Make the text on the clipboard become the contents of the receiver.  5/29/96 sw	9/12/96 tk: go through setContentsFromValue: so store into 'actsOn' will be seen"	| toPaste |	(toPaste _ ParagraphEditor clipboardContents) size > 0		ifTrue:			[self setContentsFromValue: toPaste asParagraph text string]!recognizeCharactersIn: aView	"Recognize hand-written characters and add them to the receiver.  Invokes Alan's character recognizer.  7/16/96 sw"	| aRecognizer box |	Cursor marker showWhile:		[aRecognizer _ CharRecog new.		box _ aView insetDisplayBox.		aRecognizer recognizeAndDispatch:			[:char | char == Character backspace				ifTrue:					[self simulatedBackspace]				ifFalse:					[self simulatedKeystroke: char]]		until:			[(box containsPoint: Sensor cursorPoint) not]].	aView displayInterior!setContentsFromString: aString	"Set the receiver's contents from aString.  7/16/96 sw"	self setContentsFromValue: aString!setContentsFromValue: aValue	"Set the receiver's contents to the given value.  6/12/96 sw	9/12/96 tk: check if we are the 'actsOn' object in workings."	contents _ aValue.	self name = 'actsOn' ifTrue: [objectContainedIn installScripts]!setDefaultContents	"For a newly-launched object, set its contents to a default value, if appropriate.  6/2/96 sw" 	contents _ 'Frog and Toad are Friends'!simulatedBackspace	contents size > 0 ifTrue:		[contents _ contents copyFrom: 1 to: contents size - 1]!simulatedKeystroke: char	contents _ self contents, char!supplementaryObjectMenu	"Answer a supplementary menu to be invoked from the object halo.    For string objects, we add the recognizer invocation, though it's hard to get at while remaining in the window, and it's momentarily redundant with the costume-details item.  7/17/96 sw"	^ SelectionMenu labelList: #('recognizer'			'reframe'			'set contents...'			'paste text into me'			'inspect me'			'redisplay')		selections: #(recognizeCharactersIn: reframeIn:  setContentsIn: pasteTextIntoObject inspect redisplayIn:)!type	"Answer the receiver's formal type.  6/12/96 sw"	^ #String! !!SystemDictionary methodsFor: 'memory space'!printSpaceAnalysis	"Smalltalk garbageCollect; printSpaceAnalysis"	"Note: this all needs to be updated for 32-bit direct pointers"	| f name space words scale count |	f _ FileStream newFileNamed: 'STspace.text'.	f timeStamp.	self allClassesDo:		[:cl | name _ cl name.		Sensor redButtonPressed ifTrue: [Transcript cr; show: name].		space _ cl == Character ifTrue: [#(0 0)] ifFalse: [cl space].		count _ cl instanceCount.		f print: name; tab;			print: space first; tab;			print: space last; tab;			print: count; tab.		words _ (cl instSize+2)*count.		cl isVariable ifTrue:				[scale _ cl isBytes ifTrue: [2] ifFalse: [1].				cl allInstancesDo: [:x | words _ words + (x size//scale)]].		f print: words; cr].	f close! !!SystemDictionary methodsFor: 'image, changes name'!sourcesName	"Answer the sources file name used in this Smalltalk release."	^ self vmPath, 'SqueakV1.sources'! !!SystemDictionary methodsFor: 'sources, change log'!version	"Answer the version of this release."	^ 'Squeak 1.1 of September 21, 1996'! !!SystemDictionary methodsFor: 'miscellaneous'!removeHyperSqueakFromSystem	"Remove all the HyperSqueak classes and related junk from the system. 9/20/96 sw	Added a couple of removals 9/22/96 di "	| hsSupport aClass |	(hsSupport _ self hyperSqueakSupportClass) == nil		ifTrue:			[^ self inform: 'HyperSqueak is already gone!!'].	hsSupport squeakCategories do:		[:aCategoryName | SystemOrganization removeSystemCategory: aCategoryName].	#(AnimationInspectController AnimationInspectView FastDictionary) do:		[:className | (aClass _ self at: className ifAbsent: [nil]) == nil ifFalse:			[aClass removeFromSystem]].	self at: #HaloIcons put: nil.	ScreenController revertToStandardMenus.	InspectorView class removeSelector: #buildAnimationView:.	InspectorView class removeSelector: #animationDictionaryInspector:.	Dictionary removeSelector: #inspectAnimationsWithLabel:.! !!TAssignmentNode methodsFor: 'all'!bindVariablesIn: aDictionary	variable _ variable bindVariablesIn: aDictionary.	expression _ expression bindVariablesIn: aDictionary.!copyTree	^self class new		setVariable: variable copyTree		expression: expression copyTree!emitCCodeOn: aStream level: level generator: aCodeGen	variable emitCCodeOn: aStream level: level generator: aCodeGen.	aStream nextPutAll: ' = '.	expression emitCCodeOn: aStream level: level generator: aCodeGen.!expression	^expression!inlineMethodsUsing: aDictionary	variable inlineMethodsUsing: aDictionary.	expression inlineMethodsUsing: aDictionary.!isAssignment	^true!nodesDo: aBlock	variable nodesDo: aBlock.	expression nodesDo: aBlock.	aBlock value: self.!printOn: aStream level: level	variable printOn: aStream level: level.	aStream nextPutAll: ' _ '.	expression printOn: aStream level: level + 2.!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		variable _ variable replaceNodesIn: aDictionary.		expression _ expression replaceNodesIn: aDictionary.		self]!setVariable: varNode expression: expressionNode	variable _ varNode.	expression _ expressionNode.!variable	^variable! !!TCaseStmtNode methodsFor: 'all'!bindVariablesIn: aDictionary	expression _ expression bindVariablesIn: aDictionary.	cases _ cases collect: [ :c | c bindVariablesIn: aDictionary ].!cases	^cases!copyTree	^self class new		setExpression: expression copyTree		firsts: firsts copy		lasts: lasts copy		cases: (cases collect: [ :case | case copyTree ])!customizeCase: caseParseTree forVar: varName from: firstIndex to: lastIndex	"Return a collection of copies of the given parse tree, each of which has the value of the case index substituted for the given variable."	| newCases dict newCase |	newCases _ OrderedCollection new.	firstIndex to: lastIndex do: [ :caseIndex |		dict _ Dictionary new.		dict at: varName put: (TConstantNode new setValue: caseIndex).		newCase _ caseParseTree copyTree bindVariablesIn: dict.		newCases addLast: newCase.	].	^ newCases!customizeShortCasesForDispatchVar: varName	"Make customized versions of a short bytecode methods, substituting a constant having the case index value for the given variable. This produces better code for short bytecodes such as instance variable pushes that encode the index of the instance variable in the bytecode."	| newFirsts newLasts newCases l f case sel expanded |	newFirsts _ OrderedCollection new.	newLasts _ OrderedCollection new.	newCases _ OrderedCollection new.	1 to: cases size do: [ :i |		l _ lasts at: i.		f _ firsts at: i.		case _ cases at: i.		expanded _ false.		(l - f) > 1 ifTrue: [  "case code covers multiple cases"			case nodeCount < 100 ifTrue: [				newFirsts addAll: (f to: l) asArray.				newLasts addAll: (f to: l) asArray.				newCases addAll: (self customizeCase: case forVar: varName from: f to: l).				expanded _ true.			].		].		expanded ifFalse: [			newFirsts addLast: f.			newLasts addLast: l.			newCases addLast: case.		].	].	firsts _ newFirsts asArray.	lasts _ newLasts asArray.	cases _ newCases asArray.!emitCCodeOn: aStream level: level generator: aCodeGen	| indent |	indent _ (String new: level) collect: [ :ch | Character tab ].	aStream nextPutAll: 'switch ('.	expression emitCCodeOn: aStream level: level generator: aCodeGen.	aStream nextPutAll: ') {'; cr.	1 to: cases size do: [ :i |		(firsts at: i) to: (lasts at: i) do: [ :caseIndex |			aStream nextPutAll: indent, 'case ', caseIndex printString, ':'; cr.		].		(cases at: i) emitCCodeOn: aStream level: level + 1 generator: aCodeGen.		aStream nextPutAll: indent; tab; nextPutAll: 'break;'.		aStream cr.	].	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!expression	^expression!inlineMethodsUsing: aDictionary	expression inlineMethodsUsing: aDictionary.	cases do: [ :c | c inlineMethodsUsing: aDictionary ].!isCaseStmt	^true!nodesDo: aBlock	expression nodesDo: aBlock.	cases do: [ :c | c nodesDo: aBlock ].	aBlock value: self.!printOn: aStream level: level	aStream crtab: level.	aStream nextPutAll: 'select '.	expression printOn: aStream level: level.	aStream nextPutAll: ' in'.	1 to: cases size do: [ :i |		(firsts at: i) to: (lasts at: i) do: [ :caseIndex |			aStream crtab: level.			aStream nextPutAll: 'case ', caseIndex printString, ':'.		].		aStream crtab: level + 1.		(cases at: i) printOn: aStream level: level + 1.	].	aStream crtab: level.	aStream nextPutAll: 'end select'.!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		expression _ expression replaceNodesIn: aDictionary.		cases _ cases collect: [ :c | c replaceNodesIn: aDictionary ].		self]!setExpression: aNode firsts: firstsList lasts: lastsList cases: caseList	expression _ aNode.	firsts _ firstsList.	lasts _ lastsList.	cases _ caseList.!setExpression: aNode selectors: selectorList	"Initialize the node from the given set of selectors."	"Note: Each case is a statement list with containing one statement, a send to self of a selector from the given selector list. Having statement list nodes makes inlining easier later."	| selfNode stmt lastSel firstInRun sel |	expression _ aNode.	selfNode _ TVariableNode new setName: 'self'.	firsts _ OrderedCollection new: 400.	lasts _ OrderedCollection new: 400.	cases _ OrderedCollection new: 400.	lastSel _ selectorList first.	firstInRun _ 0.	1 to: selectorList size do: [ :i |		sel _ selectorList at: i.		sel ~= lastSel ifTrue: [			firsts add: firstInRun.			lasts add: i - 2.			stmt _ TSendNode new setSelector: lastSel receiver: selfNode arguments: #().			cases add: (TStmtListNode new setArguments: #() statements: (Array with: stmt)).			lastSel _ sel.			firstInRun _ i - 1.		].	].	firsts add: firstInRun.	lasts add: selectorList size - 1.	stmt _ TSendNode new setSelector: lastSel receiver: selfNode arguments: #().	cases add: (TStmtListNode new setArguments: #() statements: (Array with: stmt)).! !!TConstantNode methodsFor: 'all'!copyTree	^self class new		setValue: value!emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C literal."	aStream nextPutAll: (aCodeGen cLiteralFor: value).!isConstant	^true!isLeaf	^true!printOn: aStream level: level	value storeOn: aStream.!setValue: anObject	value _ anObject.!value	^value! !!TestCClass1 methodsFor: 'all'!arg1: a arg2: b	"CCodeGenerator new initialize addClass: TestCClass1"	| i j k |	self var: #i declareC: 'char *i'.	i _ 'abc'.	j _ 2.	k _ 3.!ifTests	true ifTrue: [		self print: 'true case'	].	true ifFalse: [		self print: 'false case'	].	true ifTrue: [		self print: 'true case'	] ifFalse: [		self print: 'false case'	].	true ifFalse: [		self print: 'false case'	] ifTrue: [		self print: 'true case'	].!loopTests	|  v i |	v _ 0.	[v < 10] whileTrue: [ self printNum: v.  v _ v + 1 ].	self print: ''.	[v < 1] whileFalse: [ self printNum: v.  v _ v - 1 ].	self print: ''.	1 to: 10 do: [ :i | self printNum: i ].	self print: ''.	1 to: 10 by: 2 do: [ :i | self printNum: i ].	self print: ''.!method1	"(CCodeGenerator new initialize addClass: TestCClass1) codeString"	x & y ifTrue: [		x _ 10.		y _ 20.	].	y _ nil + 3.	x = nil ifTrue: [ x _ 18 ].	^nil!method2	self method1; method8: 0; setX: 10 Y: 20.!method3	x > 0 ifTrue: [ ^x ] ifFalse: [ ^y ].!method4	x _ 0.	y _ 0.	[x < 100] whileTrue: [		y _ y + x.		x _ x + 1.	].	^y!method5	x & y.	x | y.	x and: [y].	x or: [y].	x not.	x + y.	x - y.	x * y.	x // y.	x \\ y.	x min: y.	x max: y.	x bitAnd: y.	x bitOr: y.	x bitXor: y.	x bitInvert32.	x bitShift: y.	x >> y.	x << y.	x < y.	x <= y.	x = y.	x >= y.	x > y.	x ~= y.	x == y.	x isNil.	x notNil.	[x > y] whileTrue: [ x _ x + 1 ].	[x > y] whileFalse: [ x _ x + 1 ].	x > y ifTrue: [ x _ x - 1 ].	x > y ifFalse: [ x _ x + 1 ].	x > y ifTrue: [ x _ x - 1] ifFalse: [ x _ x + 1 ].	x > y ifFalse: [ x _ x + 1] ifTrue: [ x _ x - 1 ].	x at: 3.	x at: 3 put: y.	self integerValueOf: 5.	self integerObjectOf: 3 + 5.	x preDecrement.	y preIncrement > 0 ifTrue: [ x _ x + 1 ].!method6	self dispatchOn: x in: #(f1 f2 f3 f4 f5).!method8: arg	| a |	self returnTypeC: 'float'.	self var: #a    declareC: 'float a = 0'.	self var: #arg declareC: 'float arg'.	self cCode: 'a = arg * 3.14159'.	^a!print: val	self cCode: 'printf("%d\n", val)'.!printNum: i	self cCode: 'printf("%d ", i)'.!setX: newX Y: newY	x _ newX min: newY.	y _ newY.! !!TestCClass2 methodsFor: 'all'!atAllPut	| i |	i _ VectSize.	[i > 0] whileTrue: [		vect at: i put: 5.		i _ i - 1.	].	(vect at: 1) ~= 5 ifTrue: [ self error: 'AtAllPutBenchmark' ].!error: s	"Print an error message and exit."	self print: 'Error in %s\n' f: s.	self exit: -1.!incrementAll	| oldVal i |	oldVal _ vect at: 1.	i _ VectSize.	[i > 0] whileTrue: [		vect at: i put: ((vect at: i) + 1).		i _ i - 1.	].	(vect at: 1) ~= (oldVal + 1) ifTrue: [ self error: 'IncrementAllBenchmark' ].!initialize	VectSize _ 10000.	vect _ Array new: VectSize.!main	| startTicks ticks |	self printf: 'atAllPut: '.	startTicks _ self clock.	self atAllPut.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'incrementAll: '.	self incrementAll.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'nestedWhileLoop: '.	self nestedWhileLoop.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sieve: '.	self sieve.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sumAll: '.	self sumAll.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sumFromTo: '.	self sumFromTo.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.!nestedWhileLoop	| sum i j |	sum _ 0.	i _ 1000.	[i > 0] whileTrue: [		j _ 100.		[j > 0] whileTrue: [			sum _ sum + 1.			j _ j - 1.		].		i _ i - 1.	].	sum ~= 100000 ifTrue: [ self error: 'NestedWhileBenchmark' ].!sieve	| flagsSize flags primeCount i k |	flagsSize _ 8190.	flags _ Array new: flagsSize.	i _ flagsSize.	[i > 0] whileTrue: [		flags at: i put: true.		i _ i - 1.	].	primeCount _ 0.	i _ 2.	[i <= flagsSize] whileTrue: [		(flags at: i) ifTrue: [			primeCount _ primeCount + 1. "i is a prime"			k _ i + i.			[k <= flagsSize] whileTrue: [				flags at: k put: false. "k is not a prime; it is a multiple of i"				k _ k + i.			].		].		i _ i + 1.	].	primeCount ~= 1027 ifTrue: [ self error: 'SieveBenchmark' ].!sumAll	| elementVal sum i |	elementVal _ vect at: 1.	sum _ 0.	i _ VectSize.	[i > 0] whileTrue: [		sum _ sum + (vect at: i).		i _ i - 1.	].	sum ~= (VectSize * elementVal) ifTrue: [ self error: 'SumAllBenchmark' ].!sumFromTo	| sum i j |	i _ 10.	[i > 0] whileTrue: [		sum _ 0.		j _ 10000.		[j > 0] whileTrue: [			sum _ sum + j.			j _ j - 1.		].		i _ i - 1.	].	sum ~= 50005000 ifTrue: [ self error: 'SumFromToBenchmark' ].! !!TestCClass2 class methodsFor: 'testing'!test	"TestCClass2 test"	"(CCodeGenerator new initialize addClass: TestCClass2) codeString"	| bm |	bm _ self new initialize.	Transcript show: 'atAllPut: '.	Transcript show: (Time millisecondsToRun: [bm atAllPut]) printString; cr.	Transcript show: 'incrementAll: '.	Transcript show: (Time millisecondsToRun: [bm incrementAll]) printString; cr.	Transcript show: 'nestedWhileLoop: '.	Transcript show: (Time millisecondsToRun: [bm nestedWhileLoop]) printString; cr.	Transcript show: 'sieve: '.	Transcript show: (Time millisecondsToRun: [bm sieve]) printString; cr.	Transcript show: 'sumAll: '.	Transcript show: (Time millisecondsToRun: [bm sumAll]) printString; cr.	Transcript show: 'sumFromTo: '.	Transcript show: (Time millisecondsToRun: [bm sumFromTo]) printString; cr.! !!TestCClass3 methodsFor: 'all'!dispatchOn: anInteger in: selectorArray	"Simulate a case statement via selector table lookup. The given integer must be between 0 and (selectorArray size - 1), inclusive. Send the selector at (anInteger + 1) in selectorArray to the receiver. For speed, no extra range test is done, since it is done by the at: operation."	"Note: Delete this method from the generated code."	"assert: (anInteger >= 0) | (anInteger < selectorArray size)"	self perform: (selectorArray at: (anInteger + 1)).!f1	| local r |	local _ self functionWithLabel: 1.	r _ 7.	self print: 'f1'.!f2	| local i |	local _ 2.	i _ self functionWithLabel: -2.	i > 0 ifTrue: [ ^ -1 ].	self print: 'f2'.!f3	self print: 'f3'.!f4	self print: 'f4'.!f5	self print: 'f5'.!functionWithLabel: arg	arg > 0 ifTrue: [ ^1 ] ifFalse: [ ^-1 ].!main	"TestCClass3 new main"	"(CCodeGenerator new initialize addClass: TestCClass3) codeString"	| i |	0 to: 9 do: [ :i |		self dispatchOn: i in: #(f1 f2 f2 f3 f3 f3 f4 f4 f5 f2).	].!print: s	self var: #s declareC: 'char *s'.	self cCode: 'printf("%s", s)'.! !!Text class methodsFor: 'class initialization'!initDefaultFontsAndStyle	"This provides the system with 10 and 12 'point' serif and sans-serif font 	families."	| defaultFontArray |		defaultFontArray _ Array new: 12.	defaultFontArray at: 1 put: (StrikeFont fromStrike: 'FontA10').	defaultFontArray at: 2 put:		"(StrikeFont fromStrike: 'FontA10b')."		((defaultFontArray at: 1) emphasized: 1 named: 'FontA10b').	defaultFontArray at: 3 put:		"(StrikeFont fromStrike: 'FontA10i')."		((defaultFontArray at: 1) emphasized: 2 named: 'FontA10i').	defaultFontArray at: 4 put: (StrikeFont fromStrike: 'FontA12').	defaultFontArray at: 5 put:		"(StrikeFont fromStrike: 'FontA12b')."		((defaultFontArray at: 4) emphasized: 1 named: 'FontA12b').	defaultFontArray at: 6 put:		"(StrikeFont fromStrike: 'FontA12i')."		((defaultFontArray at: 4) emphasized: 2 named: 'FontA12i').	defaultFontArray at: 7 put: (StrikeFont fromStrike: 'FontB10').	defaultFontArray at: 8 put:		"(StrikeFont fromStrike: 'FontB10b')."		((defaultFontArray at: 7) emphasized: 1 named: 'FontB10b').	defaultFontArray at: 9 put:		"(StrikeFont fromStrike: 'FontB10i')."		((defaultFontArray at: 7) emphasized: 2 named: 'FontB10i').	defaultFontArray at: 10 put: (StrikeFont fromStrike: 'FontB12').	defaultFontArray at: 11 put:		"(StrikeFont fromStrike: 'FontB12b')."		((defaultFontArray at: 10) emphasized: 1 named: 'FontB12b').	defaultFontArray at: 12 put:		"(StrikeFont fromStrike: 'FontB12i')."		((defaultFontArray at: 10) emphasized: 2 named: 'FontB12i').	TextConstants at: #DefaultTextStyle put:		(TextStyle fontArray: defaultFontArray).		"Text initDefaultFontsAndStyle."! !!TextCostume methodsFor: 'everything'!couldBeWornBy: anObject	"TextCostumes can only be worn by TextObjects.  9/20/96 sw"	^ anObject holdsText!display: anObject onCanvas: aCanvas	"Display the object's contents text. 8/13/96 sw	All text display methods brought over to TextCostume  9/5/96 tk"	self displayContents: anObject onCanvas: aCanvas.!displayContents: aTextObj1 onCanvas: aCanvas	"Render the receiver's contents on the indicated canvas.  5/29/96 sw.	 6/6/96 sw: call drawFrameOn:	 8/11/96 sw: let the object decide if it wants a frame drawn	 7/28/96 sw: call self canvas, not grab canvas, so that it won't fail on option-drag (copy)	 9/5/96 tk: moved to TextCostume, send object as arg"	| b aTextObj |	aTextObj _ (aTextObj1 isKindOf: Alias) 		ifTrue: [aTextObj1 contents] ifFalse: [aTextObj1].	"aTextObj suppressDisplay == true ifTrue: [^ self].  		who uses suppressDisplay?  If used, must be defined for all Objs"	(aTextObj parameterFor: #TextBorder ifAbsent: [false]) ifTrue:		[self drawFrame: aTextObj on: aCanvas].	aTextObj contents offset: aCanvas offset.	"aTextObj contents displayOn: aCanvas form at: 2@2."	b _ aTextObj parameterFor: #TextBorderWidth ifAbsent: [2].	b _ b + 1.	"space"	aTextObj contents displayOn: aCanvas basicForm at: (b@b) 		clippingBox: (aCanvas boundingBox insetBy: b@b)		rule: Form over		fillColor: nil.	(aTextObj parameterFor: #TextOpaque ifAbsent: [true])		ifTrue: ["opaque paper"			aCanvas setForm: aCanvas basicForm 				transparentColor: nil]		ifFalse: ["transparent around the text"			aCanvas setForm: aCanvas basicForm 				transparentColor: Color white]. !drawFrame: anObject on: aCanvas	"Draw a frame around the user's layout rectangle.  6/6/96 sw"	|  aQuadrangle |	aQuadrangle _ Quadrangle extent: anObject layoutRectangle extent 		color: Color white 		borderWidth: 			(anObject parameterFor: #TextBorderWidth ifAbsent: [2]) 		borderColor: 			(anObject parameterFor: #TextBorderColor ifAbsent: [Color black]).  	aQuadrangle displayOn: aCanvas! !TextObj comment:'The beginnings of a text-bearing Obj, though very crude at this point.  The instance variables prevTextFrame and nextTextFrame are intended to support the idea of a series of text frames linked together, all jointly fed from a galley of text, though not much implementation stands behind this at the moment.  6/2/96 sw'!!TextObj methodsFor: 'access'!acceptNewContents: anObject andRedisplayIn: aView	self contents: anObject stringRepresentation asParagraph.	self invalidateCanvas.	aView displayInterior!couldWearStringCostume	"For now, contents are a paragraph, so the contents-string costume is inappropriate.  9/20/96 sw"	^ false!holdsText	"Answer whether the receiver holds text.  In our case it's true.  6/7/96 sw"	^ true!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  5/27/96 sw	Use only names of Fonts of the Style of this paragraph  9/6/96 tk"	| aList reply new |	aList _ contents textStyle fontNames.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[new _ Text string: contents string 			emphasis: (aList indexOf: reply).		contents replaceFrom: 1			to: contents string size			with: new			displaying: false.		self invalidateCanvas].!suppressDisplay	^ suppressDisplay!type	"Answer the receiver's formal type.  6/12/96 sw"	^ #Text! !!TextObj methodsFor: 'display'!borderWidth	"Return the border width to be used in displaying.  Use the parameters if any.  8/22/96 tk"	(currentCostume isKindOf: TextCostume) ifFalse: [		self error: 'Each costume should have its own'].	^ self parameterFor: #TextBorderWidth ifAbsent: [2]!composeAll	"Something has changed: bounding box, border width, font, leading, margin, etc.  Recompute my layout.  Callable by user scripts.  9/6/96 tk"	| b |	b _ self parameterFor: #TextBorderWidth ifAbsent: [2].	b _ b + 1.	"space"	contents compositionRectangle: 		(self layoutRectangle insetBy: b@b).	"contents composeAll.	included in above"	self invalidateCanvas.!displayContentsOnCanvas: aCanvas	"Render the receiver's contents on the indicated canvas.  5/29/96 sw.	 6/6/96 sw: call drawFrameOn:	 8/11/96 sw: let the object decide if it wants a frame drawn"	self wantsFrameDrawn ifTrue:		[self drawFrameOn: aCanvas].	self displayTextualContentsOnCanvas: aCanvas!displayTextualContentsOnCanvas: aCanvas	"Render the receiver's textual contents on the indicated canvas.  6/1/96 sw	 7/28/96 sw: call self canvas, not grab canvas, so that it won't fail on option-drag (copy)"	self halt.	"Does anyone else call this?"	suppressDisplay == true ifTrue: [^ self].	self contents offset: aCanvas offset.	self contents displayOn: aCanvas form at: 2@2."If transparent around the text, do this	self canvas setForm: self canvas theForm transparentColor: Color white.""If opaque paper, do this instead:"	self canvas mask fillWithColor: Color black.!invalidateCanvas	"Text must remeasure -- border or alignment or size may have changed.  9/13/96 tk"	| b |	b _ self parameterFor: #TextBorderWidth ifAbsent: [2].	b _ b + 1.	"space"	contents compositionRectangle: (layoutRectangle insetBy: b@b).		"forces composeAll"	super invalidateCanvas!renderOnCanvas: enclosingCanvas	"Render the receiver on the provided canvas.  5/20/96 sw"	"copied down from obj, with the canvasValid thing set"	self canvasValid ifFalse:		[self canvas clear.		self currentCostume display: self onCanvas: canvas.		canvasValid _ true].	canvas displayOn: enclosingCanvas at: self layoutRectangle origin clippingBox: self layoutRectangle!setDefaultCostume	"Set up an initial costume for the receiver, if desired.  7/15/96 sw	9/5/96 tk: TextCostume"	currentCostume _ self costumeNamed: 'Text'!userDisplayOn: aDisplayMedium	"By default, we do the standard textual display.  6/7/96 sw"	self displayContentsOnCanvas: aDisplayMedium!wantsFrameDrawn	"Answer whether the receiver wants a frame drawn around it.  8/96 sw.	Use object's parameters.  9/5/96 tk	9/20/96 sw: don't drop into an error if it's not wearing a text costume!!"	(currentCostume isKindOf: TextCostume) ifFalse:		[^ false].	^ self parameterFor: #TextBorder ifAbsent: [false]! !!TextObj methodsFor: 'initialization'!clonedInstance	| inst |	inst _ super clonedInstance.	inst invalidateCanvas.	^ inst!contentsString: aString	"Set the receiver to hold a paragraph for the given string" 	self contents: (Paragraph withText: (Text fromString: aString))!defaultExtent	"Answer the default extent for the receiver's manifestation in a window.  At this point quite arbitrary.  6/7/96 sw"	^ 100 @ 30!editTextIn: aView	"Fire up a text editor in my layoutRectangle of aView.  May not be the best expression of intent, but seems to work reasonably 7/28/96 di"	| newView screenRect |	screenRect _ (layoutRectangle insetBy: 2@2)				translateBy: aView insetDisplayBox topLeft.	newView _ DisplayTextView new model: contents.	newView window: (0@0 extent: screenRect extent) viewport: screenRect.	contents wrappingBox: screenRect clippingBox: screenRect.	contents display.	newView controller changeParagraph: contents.	newView controller startUp.	self invalidateCanvas!pasteTextIntoObject	"Make the text on the clipboard become the contents of the receiver.  6/28/96 sw"	| toPaste |	(toPaste _ ParagraphEditor clipboardContents) size > 0		ifTrue:			[contents _ toPaste asParagraph.			canvasValid _ false]!setDefaultContents	"For a newly-launched object, set its contents to a default value, if appropriate.  6/2/96 sw" 	self contentsString: 'Hello, World'!startUpRecognizerIn: aView	"Fire up a text editor in my layoutRectangle of aView.  May not be the best expression of intent, but seems to work reasonably 7/28/96 di"	| newView screenRect |	screenRect _ (layoutRectangle insetBy: 2@2)				translateBy: aView insetDisplayBox topLeft.	newView _ DisplayTextView new model: contents.	newView window: (0@0 extent: screenRect extent) viewport: screenRect.	contents wrappingBox: screenRect clippingBox: screenRect.	contents display.	newView controller changeParagraph: contents.	newView controller controlInitialize;  selectAt: 2; recognizeCharactersWhileMouseIn: aView insetDisplayBox; controlTerminate.			self invalidateCanvas! !!TextObj methodsFor: 'mouse'!mouseUpAt: aPoint in: aView	"The mouse came up in the receiver; for now, edit the text with a PeragraphEditor.  6/28/96 di	 8/5/96 sw: only edit in place if showing the textual contents currently	9/5/96 tk change to TextCostume"	(self currentCostume isKindOf: TextCostume) ifFalse: [^ self beep].	self editTextIn: aView! !!TGoToNode methodsFor: 'all'!copyTree	^self class new setLabel: label!emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C goto statement."	aStream nextPutAll: 'goto '.	aStream nextPutAll: label.!isGoTo	^true!label	^label!printOn: aStream level: level	aStream nextPutAll: 'goto '.	aStream nextPutAll: label.!setLabel: aString	label _ aString.! !!TLabeledCommentNode methodsFor: 'all'!copyTree	^self class new		setLabel: label		comment: comment!emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C comment with optional label."	self printOptionalLabelOn: aStream.	aStream nextPutAll: '/* '.	aStream nextPutAll: comment.	aStream nextPutAll: ' */'.!isComment	"Answer true if the receiver is just a comment (i.e., it has no label)."	^label = nil!isLabel	^true!isLeaf	^true!label	^label!printOn: aStream level: level	self printOptionalLabelOn: aStream.	aStream nextPut: $".	aStream nextPutAll: comment.	aStream nextPut: $".!printOptionalLabelOn: aStream	label ~= nil ifTrue: [		self unindentOneTab: aStream.		aStream nextPutAll: label.		aStream nextPut: $:.		aStream tab.		].!setComment: commentString	label _ nil.	comment _ commentString.!setLabel: labelString	label _ labelString.!setLabel: labelString comment: commentString	label _ labelString.	comment _ commentString.!unindentOneTab: aStream	"Remove the last tab from the given stream if possible."	(aStream isKindOf: ReadWriteStream) ifFalse: [ ^self ].	aStream position > 0 ifTrue: [		aStream position: aStream position - 1.		"restore stream position if previous char was not a tab"		aStream peek = Character tab ifFalse: [ aStream next ].	].! !!TMethod methodsFor: 'initialization'!setSelector: sel args: argList locals: localList block: aBlockNode	"Initialize this method using the given information."	selector _ sel.	returnType _ 'int'. 	 "assume return type is int for now"	args _ argList asOrderedCollection collect: [ :arg | arg key ].	locals _ localList asOrderedCollection collect: [ :arg | arg key ].	declarations _ Dictionary new.	parseTree _ aBlockNode asTranslatorNode.	labels _ OrderedCollection new.	complete _ false.		"set to true when all possible inlining has been done"	self removeFinalSelfReturn.	self recordDeclarations.!setSelector: sel returnType: retType args: argList locals: localList declarations: decls parseTree: aNode labels: labelList complete: completeFlag	"Initialize this method using the given information. Used for copying."	selector _ sel.	returnType _ retType.	args _ argList.	locals _ localList.	declarations _ decls.	parseTree _ aNode.	labels _ labelList.	complete _ completeFlag.! !!TMethod methodsFor: 'accessing'!args	"The arguments of this method."	^args!declarations	"The type declaration dictionary of this method."	^declarations!isComplete	"A method is 'complete' if it does not contain any more inline-able calls."	^complete!labels	^labels!locals	"The local variables of this method."	^locals!parseTree	"The parse tree of this method."	^parseTree!parseTree: aNode	"Set the parse tree of this method."	parseTree _ aNode.!returnType	"The type of the values returned by this method. This string will be used in the C declaration of this function."	^returnType!selector	"The Smalltalk selector of this method."	^selector!selector: newSelector	selector _ newSelector.!statements	parseTree isStmtList		ifFalse: [ self error: 'expected method parse tree to be a TStmtListNode' ].	((parseTree args = nil) or: [parseTree args isEmpty])		ifFalse: [ self error: 'expected method parse tree to have no args' ].	^parseTree statements! !!TMethod methodsFor: 'primitive compilation'!argConversionExprFor: varName stackIndex: stackIndex	"Return the parse tree for an expression that fetches and converts the primitive argument at the given stack offset."	| expr decl meth |	expr _ '(self longAt: stackPointer - ( ', stackIndex printString, ' * 4))'.	(declarations includesKey: varName) ifTrue: [  "array"		decl _ declarations at: varName.		(decl includes: $*) ifTrue: [			expr _ varName, ' _ self arrayValueOf: ', expr.		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			expr _ varName, ' _ self floatValueOf: ', expr.		].	] ifFalse: [  "undeclared variables are taken to be integer"		expr _ varName, ' _ self checkedIntegerValueOf: ', expr.	].	meth _ (Compiler new parse: 'temp ', expr in: Object notifying: nil) asTMethodFromClass: Object.	^ meth statements!checkSuccessExpr	"Return the parse tree for an expression aborts the primitive if the successFlag is not true."	| expr meth |	expr _ 'successFlag ifFalse: [ ^ nil ]'.	meth _ (Compiler new parse: 'temp ', expr in: Object notifying: nil) asTMethodFromClass: Object.	^ meth statements!covertToZeroBasedArrayReferences	"Replace the index expression in at: and at:put: messages to (<expr> - 1), since C uses zero-based array indexing."	| oldIndexExpr newIndexExpr |	parseTree nodesDo: [ :n |		(n isSend and: [(n selector = #at:) or: [ n selector = #at:put: ]]) ifTrue: [			oldIndexExpr _ n args first.			oldIndexExpr isConstant ifTrue: [				"index expression is a constant: decrement the constant now"				newIndexExpr _ TConstantNode new setValue: (n args first value - 1).			] ifFalse: [				"index expression is complex: build an expression to decrement result at runtime"				newIndexExpr _ TSendNode new					setSelector: #-					receiver: oldIndexExpr					arguments: (Array with: (TConstantNode new setValue: 1)).			].			n args at: 1 put: newIndexExpr.		].	].!fetchRcvrExpr	"Return the parse tree for an expression that fetches the receiver from the stack."	| expr meth |	expr _ 'rcvr _ self longAt: stackPointer - (', args size printString, ' * 4)'.	meth _ (Compiler new parse: 'temp ', expr in: Object notifying: nil) asTMethodFromClass: Object.	^ meth statements!instVarGetExprFor: varName offset: instIndex	"Return the parse tree for an expression that fetches and converts the value of the instance variable at the given offset."	| decl expr meth |	(declarations includesKey: varName) ifTrue: [		decl _ declarations at: varName.		(decl includes: $*) ifTrue: [  "array"			expr _ varName, ' _ self fetchArray: ', instIndex printString, ' ofObject: rcvr'.		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			expr _ varName, ' _ self fetchFloat: ', instIndex printString, ' ofObject: rcvr'.		].	] ifFalse: [  "undeclared variables are taken to be integer"		expr _ varName, ' _ self fetchInteger: ', instIndex printString, ' ofObject: rcvr'.	].	meth _ (Compiler new parse: 'temp ', expr in: Object notifying: nil) asTMethodFromClass: Object.	^ meth statements!instVarPutExprFor: varName offset: instIndex	"Return the parse tree for an expression that saves the value of the integer instance variable at the given offset."	| expr meth |	(declarations includesKey: varName) ifTrue: [		self error: 'a primitive method can only modify integer instance variables'.	].	expr _ 'self storeInteger: ', instIndex printString, ' ofObject: rcvr withValue: ', varName.	meth _ (Compiler new parse: 'temp ', expr in: Object notifying: nil) asTMethodFromClass: Object.	^ meth statements!popArgsExpr	"Return the parse tree for an expression that removes the primitive arguments from the stack."	| expr meth |	expr _ 'self pop: ', args size printString.	meth _ (Compiler new parse: 'temp ', expr in: Object notifying: nil) asTMethodFromClass: Object.	^ meth statements!preparePrimitiveInClass: aClass	"Add a prolog and postlog to a primitive method. The prolog copies any instance variables referenced by this primitive method into local variables. The postlog copies values of assigned-to variables back into the instance. The names of the new locals are added to the local variables list.The declarations dictionary defines the types of any non-integer variables (locals, arguments, or instance variables). In particular, it may specify the types:	int *		-- an array of 32-bit values (e.g., a BitMap)	short *		-- an array of 16-bit values (e.g., a SoundBuffer)	char *		-- an array of unsigned bytes (e.g., a String)	double		-- a double precision floating point number (e.g., 3.14159)Undeclared variables are taken to be integers and will be converted from Smalltalk to C ints.""Current restrictions:	o method must not contain explicit returns	o method must not contain message sends	o method must not allocate objects	o method must not manipulate raw oops	o method cannot access class variables	o compiled primitives can only return self"	| prolog postlog instVarsUsed varsAssignedTo instVarList varName |	prolog _ OrderedCollection new.	postlog _ OrderedCollection new.	instVarsUsed _ self freeVariableReferences asSet.	varsAssignedTo _ self variablesAssignedTo asSet.	instVarList _ aClass allInstVarNames.	"add receiver fetch to prolog"	prolog addAll: self fetchRcvrExpr.	"add arg conversions to prolog"	1 to: args size do: [ :argIndex |		varName _ args at: argIndex.		prolog addAll: (self argConversionExprFor: varName stackIndex: args size - argIndex).	].	"add instance variable fetches to prolog and instance variable stores to postlog"	1 to: instVarList size do: [ :varIndex |		varName _ instVarList at: varIndex.		(instVarsUsed includes: varName) ifTrue: [			locals add: varName.			prolog addAll: (self instVarGetExprFor: varName offset: varIndex - 1).			(varsAssignedTo includes: varName) ifTrue: [				postlog addAll: (self instVarPutExprFor: varName offset: varIndex - 1).			].		].	].	prolog addAll: self checkSuccessExpr.	postlog addAll: self popArgsExpr.	locals addAllFirst: args.	locals addFirst: 'rcvr'.	args _ args class new.	locals asSet size = locals size		ifFalse: [ self error: 'local name conflicts with instance variable name' ].	self hasReturn		ifTrue: [ self error: 'returns in primitive methods are not yet supported' ].	selector _ 'prim', aClass name, selector.	parseTree setStatements: prolog, parseTree statements, postlog.	self covertToZeroBasedArrayReferences.! !!TMethod methodsFor: 'transformations'!bindClassVariablesIn: constantDictionary	"Class variables are used as constants. This method replaces all references to class variables in the body of this method with the corresponding constant looked up in the class pool dictionary of the source class. The source class class variables should be initialized before this method is called."	parseTree _ parseTree bindVariablesIn: constantDictionary.!buildCaseStmt: aSendNode	"Build a case statement node for the given send of dispatchOn:in:."	"Note: the first argument is the variable to be dispatched on. The second argument is a constant node holding an array of unary selectors, which will be turned into sends to self."	((aSendNode args size = 2) and:	 [aSendNode args last isConstant and:	 [aSendNode args last value class = Array]]) ifFalse: [		self error: 'wrong node structure for a case statement'.	].	^TCaseStmtNode new		setExpression: aSendNode args first		selectors: aSendNode args last value!prepareMethodIn: aCodeGen	"Record sends of builtin operators and replace sends of the special selector dispatchOn:in: with case statement nodes."	"Note: Only replaces top-level sends of dispatchOn:in:. Case statements must be top-level statements; they cannot appear in expressions."	| stmts stmt |	parseTree nodesDo: [ :node |		node isSend ifTrue: [			"record sends of builtin operators"			(aCodeGen builtin: node selector) ifTrue: [ node isBuiltinOperator: true ].		].		node isStmtList ifTrue: [			"replace dispatchOn:in: with case statement node"			stmts _ node statements.			1 to: stmts size do: [ :i |				stmt _ stmts at: i.				(stmt isSend and: [stmt selector = #dispatchOn:in:]) ifTrue: [					stmts at: i put: (self buildCaseStmt: stmt).				].			].		].	].!recordDeclarations	"Record C type declarations of the forms		self returnTypeC: 'float'.		self var: #foo declareC: 'float foo'	 and remove the declarations from the method body."	| newStatements isDeclaration |	newStatements _ OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		isDeclaration _ false.		stmt isSend ifTrue: [			stmt selector = #var:declareC: ifTrue: [				isDeclaration _ true.				declarations at: stmt args first value asString put: stmt args last value.			].			stmt selector = #returnTypeC: ifTrue: [				isDeclaration _ true.				returnType _ stmt args last value.			].		].		isDeclaration ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.!removeFinalSelfReturn	"The Smalltalk parser automatically adds the statement '^self' to the end of methods without explicit returns. This method removes such statements, since the generated code has no notion of 'self' anyway."	| stmtList lastStmt |	stmtList _ parseTree statements asOrderedCollection.	lastStmt _ stmtList last.	((lastStmt isReturn) and:	 [(lastStmt expression isVariable) and:	 [lastStmt expression name = 'self']]) ifTrue: [		stmtList removeLast.		parseTree setStatements: stmtList.	].! !!TMethod methodsFor: 'utilities'!allCalls	"Answer a collection of selectors for the messages sent by this method."	^parseTree allCalls!copy	"Make a deep copy of this TMethod."	^self class basicNew		setSelector: selector		returnType: returnType		args: args copy		locals: locals copy		declarations: declarations copy		parseTree: parseTree copyTree		labels: labels copy		complete: complete!freeVariableReferences	"Answer a collection of variables referenced this method, excluding locals, arguments, and pseudovariables."	| refs |	refs _ Set new.	parseTree nodesDo: [ :node |		node isVariable ifTrue: [ refs add: node name asString ].	].	args do: [ :var | refs remove: var asString ifAbsent: [] ].	locals do: [ :var | refs remove: var asString ifAbsent: [] ].	#('self' 'nil' 'true' 'false') do: [ :var | refs remove: var ifAbsent: [] ].	^ refs asSortedCollection!hasNoCCode	"Answer true if the receiver does not use inlined C or C declarations, which are not currently renamed properly by the the inliner."	declarations isEmpty ifFalse: [ ^ false ].	parseTree nodesDo: [ :node |		node isSend ifTrue: [			node selector = #cCode: ifTrue: [ ^ false ].		].	].	^ true!nodeCount	"Answer the number of nodes in this method's parseTree (a rough measure of its size)."	| cnt |	cnt _ 0.	parseTree nodesDo: [ :n | cnt _ cnt + 1 ].	^cnt!variablesAssignedTo	"Answer a collection of variables assigned to by this method."	| refs |	refs _ Set new.	parseTree nodesDo: [ :node |		node isAssignment ifTrue: [ refs add: node variable name ].	].	^ refs! !!TMethod methodsFor: 'inlining'!argAssignmentsFor: meth args: argList in: aCodeGen	"Return a collection of assignment nodes that assign the given argument expressions to the formal parameter variables of the given method."	"Optimization: If the actual parameters are either constants or local variables in the target method (the receiver), substitute them directly into the body of meth. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."	| stmtList substitutionDict |	stmtList _ OrderedCollection new: 16.	substitutionDict _ Dictionary new.	meth args with: argList do: [ :argName :exprNode |		(self isSubstitutableNode: exprNode intoMethod: meth in: aCodeGen) ifTrue: [			substitutionDict at: argName asSymbol put: exprNode.			locals remove: argName.		] ifFalse: [			stmtList add: (TAssignmentNode new				setVariable: (TVariableNode new setName: argName)				expression: exprNode copyTree).		].	].	meth parseTree: (meth parseTree bindVariablesIn: substitutionDict).	^stmtList!checkForCompleteness: stmtLists in: aCodeGen	"Set the complete flag if none of the given statement list nodes contains further candidates for inlining."	complete _ true.	stmtLists do: [ :stmtList |		stmtList statements do: [ :node |			(self inlineableSend: node in: aCodeGen) ifTrue: [				complete _ false.  "more inlining to do"				^self			].		].	].	parseTree nodesDo: [ :n |		(self inlineableFunctionCall: n in: aCodeGen) ifTrue: [			complete _ false.  "more inlining to do"			^self		].	].!exitVar: exitVar label: exitLabel	"Replace each return statement in this method with an assignment to the exit variable followed by a goto to the given label. Return true if a goto was generated."	"Optimization: If exitVar is nil, the return value of the inlined method is not being used, so don't add the assignment statement."	| newStmts labelUsed |	labelUsed _ false.	parseTree nodesDo: [ :node |		node isStmtList ifTrue: [			newStmts _ OrderedCollection new: 100.			node statements do: [ :stmt |				(stmt isReturn) ifTrue: [					exitVar = nil ifTrue: [						stmt expression isLeaf ifFalse: [							"evaluate return expression even though value isn't used"							newStmts add: stmt expression.						].					] ifFalse: [						"assign return expression to exit variable"						newStmts add:							(TAssignmentNode new								setVariable: (TVariableNode new setName: exitVar)								expression: stmt expression).					].					(stmt == parseTree statements last) ifFalse: [						"generate a goto (this return is NOT the last statement in the method)"						newStmts add: (TGoToNode new setLabel: exitLabel).						labelUsed _ true.					].				] ifFalse: [					newStmts addLast: stmt.				].			].			node setStatements: newStmts asArray.		].	].	^labelUsed!inlineableFunctionCall: aNode in: aCodeGen	"Answer true if the given send node is a call to a 'functional' method--a method whose body is a single return statement of some expression and whose actual parameters can all be directly substituted."	| m |	aNode isSend ifFalse: [ ^false ].	m _ aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"	((m ~= nil) and: [m isFunctional and: [aCodeGen mayInline: m selector]]) ifTrue: [		aNode args do: [ :a | (self isSubstitutableNode: a intoMethod: m in: aCodeGen) ifFalse: [ ^false ]].		^true	] ifFalse: [		^false	].!inlineableSend: aNode in: aCodeGen	"Answer true if the given send node is a call to a method that can be inlined."	| m |	aNode isSend ifFalse: [ ^false ].	m _ aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"	^(m ~= nil) and: [m isComplete and: [aCodeGen mayInline: m selector]]!inlineCaseStatementBranchesIn: aCodeGen localizingVars: varsList	| stmt sel meth newStatements tempMe maxTemp usedVars v exitLabel |	maxTemp _ 0.	parseTree nodesDo: [ :n |		n isCaseStmt ifTrue: [			n cases do: [ :stmtNode |				stmt _ stmtNode statements first.				stmt isSend ifTrue: [					sel _ stmt selector.					meth _ aCodeGen methodNamed: sel.					((meth ~= nil) and:					 [meth hasNoCCode and:					 [meth args size = 0]]) ifTrue: [						meth _ meth copy.						maxTemp _ maxTemp max: (meth renameVarsForCaseStmt).						meth hasReturn ifTrue: [							exitLabel _ self unusedLabelForInliningInto: self.							meth exitVar: nil label: exitLabel.							labels add: exitLabel.						] ifFalse: [ exitLabel _ nil ].						meth renameLabelsForInliningInto: self.						meth labels do: [ :label | labels add: label ].						newStatements _ stmtNode statements asOrderedCollection.						newStatements removeFirst.						exitLabel ~= nil ifTrue: [							newStatements addFirst:								(TLabeledCommentNode new									setLabel: exitLabel comment: 'end case').						].						newStatements addAllFirst: meth statements.						newStatements addFirst:							(TLabeledCommentNode new setComment: meth selector).						stmtNode setStatements: newStatements.					].				].			].		].	].	usedVars _ (locals, args) asSet.	1 to: maxTemp do: [ :i |		v _ ('t', i printString).		(usedVars includes: v) ifTrue: [ self error: 'temp variable name conflicts with an existing local or arg' ].		locals addLast: v.	].	"make local versions of the given globals"	varsList do: [ :v |		(usedVars includes: v) ifFalse: [ locals addFirst: v asString ].	].!inlineCodeOrNilForStatement: aNode in: aCodeGen	"If the given statement node can be inlined, answer the statements that replace it. Otherwise, answer nil."	| stmts |	aNode isReturn ifTrue: [		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [			stmts _ self inlineSend: aNode expression				directReturn: true exitVar: nil in: aCodeGen.			^stmts		].	].	aNode isAssignment ifTrue: [		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [			^self inlineSend: aNode expression				directReturn: false exitVar: aNode variable name in: aCodeGen		].	].	aNode isSend ifTrue: [		(self inlineableSend: aNode in: aCodeGen) ifTrue: [			^self inlineSend: aNode				directReturn: false exitVar: nil in: aCodeGen		].	].	^nil!inlineFunctionCall: aSendNode in: aCodeGen	"Answer the body of the called function, substituting the actual parameters for the formal argument variables in the method body."	"Assume caller has established that:		1. the method arguments are all substitutable nodes, and		2. the method to be inlined contains no additional embedded returns."	| sel meth substitutionDict |	sel _ aSendNode selector.	meth _ (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	substitutionDict _ Dictionary new.	meth args with: aSendNode args do: [ :argName :exprNode |		substitutionDict at: argName asSymbol put: exprNode.		locals remove: argName.	].	meth parseTree bindVariablesIn: substitutionDict.	^meth statements first expression!inlineSend: aSendNode directReturn: directReturn exitVar: exitVar in: aCodeGen	"Answer a collection of statments to replace the given send. directReturn indicates that the send is the expression of a return statement, so returns can be left in the body of the inlined method. If exitVar is nil, the value returned by the send is not used; thus, returns need not assign to the output variable."	| sel meth exitLabel labelUsed inlineStmts |	sel _ aSendNode selector.	meth _ (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	meth hasReturn ifTrue: [		directReturn ifTrue: [			"propagate the return type, if necessary"			returnType = meth returnType ifFalse: [ self halt ].  "caller's return type should be declared by user"			returnType _ meth returnType.		] ifFalse: [			exitLabel _ self unusedLabelForInliningInto: self.			labelUsed _ meth exitVar: exitVar label: exitLabel.			labelUsed				ifTrue: [ labels add: exitLabel ]				ifFalse: [ exitLabel _ nil ].		].		"propagate type info if necessary"		((exitVar ~= nil) and: [meth returnType ~= 'int']) ifTrue: [			declarations at: exitVar put: meth returnType, ' ', exitVar.		].	].	inlineStmts _ OrderedCollection new: 100.	inlineStmts add: (TLabeledCommentNode new setComment: 'begin ', sel).	inlineStmts addAll:		(self argAssignmentsFor: meth args: aSendNode args in: aCodeGen).	inlineStmts addAll: meth statements.  "method body"	(directReturn and: [meth endsWithReturn not]) ifTrue: [		inlineStmts add: (TReturnNode new setExpression: (TVariableNode new setName: 'nil')).	].	exitLabel ~= nil ifTrue: [		inlineStmts add:			(TLabeledCommentNode new				setLabel: exitLabel comment: 'end ', meth selector).	].	^inlineStmts!isFunctional	"Answer true if the receiver is a functional method. That is, if it consists of a single return statement of an expression that contains no other returns."	(parseTree statements size = 1 and:	 [parseTree statements last isReturn]) ifFalse: [ ^false ].	parseTree statements last expression nodesDo: [ :n | n isReturn ifTrue: [ ^false ]].	^true!isSubstitutableNode: aNode	"Answer true if the given parameter node is either a constant, a local variable, or a formal parameter of the receiver. Such parameter nodes may be substituted directly into the body of the method during inlining. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."	aNode isConstant ifTrue: [ ^true ].	^aNode isVariable and:		[(locals includes: aNode name) or:		[args includes: aNode name]]!isSubstitutableNode: aNode intoMethod: targetMeth in: aCodeGen	"Answer true if the given parameter node is either a constant, a local variable, or a formal parameter of the receiver. Such parameter nodes may be substituted directly into the body of the method during inlining. Note that global variables cannot be subsituted into methods with possible side effects (i.e., methods that may assign to global variables) because the inlined method might depend on having the value of the global variable captured when it is passed in as an argument."	| var |	aNode isConstant ifTrue: [ ^ true ].	aNode isVariable ifTrue: [		var _ aNode name.		((locals includes: var) or: [args includes: var]) ifTrue: [ ^ true ].		(#(self true false nil) includes: var) ifTrue: [ ^ true ].		(targetMeth maySubstituteGlobal: var in: aCodeGen) ifTrue: [ ^ true ].	].	"scan expression tree; must contain only constants, builtin ops, and inlineable vars"	aNode nodesDo: [ :node |		node isSend ifTrue: [			node isBuiltinOperator ifFalse: [ ^false ].		].		node isVariable ifTrue: [			var _ node name.			((locals includes: var) or:			 [(args includes: var) or:			 [(#(self true false nil) includes: var) or:			 [targetMeth maySubstituteGlobal: var in: aCodeGen]]]) ifFalse: [ ^ false ].		].		(node isConstant or: [node isVariable or: [node isSend]]) ifFalse: [ ^false ].	].	^ true!statementsListsForInlining	"Answer a collection of statement list nodes that are candidates for inlining. Currently, we cannot inline into the argument blocks of and: and or: messages."	| stmtLists |	stmtLists _ OrderedCollection new: 10.	parseTree nodesDo: [ :node | 		node isStmtList ifTrue: [ stmtLists add: node ].	].	parseTree nodesDo: [ :node | 		node isSend ifTrue: [			((node selector = #and:) or: [node selector = #or:]) ifTrue: [				"Note: the PP 2.3 compiler produces two arg nodes for these selectors"				stmtLists remove: node args first ifAbsent: [].				stmtLists remove: node args last ifAbsent: [].			].			((node selector = #ifTrue:) or: [node selector = #ifFalse:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			((node selector = #ifTrue:ifFalse:) or: [node selector = #ifFalse:ifTrue:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			((node selector = #whileFalse:) or: [node selector = #whileTrue:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			(node selector = #to:do) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: [].			].			(node selector = #to:do) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: [].				stmtLists remove: (node args at: 2) ifAbsent: [].			].		].		node isCaseStmt ifTrue: [			"don't inline cases"			node cases do: [: case | stmtLists remove: case ifAbsent: [] ].		].	].	^stmtLists!tryToInlineMethodsIn: aCodeGen	"Expand any (complete) inline methods called by this method. Set the complete bit when all inlining has been done. Return true if something was inlined."	| stmtLists didSomething newStatements inlinedStmts sendsToInline |	didSomething _ false.	sendsToInline _ Dictionary new.	parseTree nodesDo: [ :n |		(self inlineableFunctionCall: n in: aCodeGen) ifTrue: [			sendsToInline at: n put: (self inlineFunctionCall: n in: aCodeGen).		].	].	sendsToInline isEmpty ifFalse: [		didSomething _ true.		parseTree _ parseTree replaceNodesIn: sendsToInline.	].	didSomething ifTrue: [		possibleSideEffectsCache _ nil.		^didSomething	].	stmtLists _ self statementsListsForInlining.	stmtLists do: [ :stmtList | 		newStatements _ OrderedCollection new: 100.		stmtList statements do: [ :stmt |			inlinedStmts _ self inlineCodeOrNilForStatement: stmt in: aCodeGen.			(inlinedStmts = nil) ifTrue: [				newStatements addLast: stmt.			] ifFalse: [				didSomething _ true.				newStatements addAllLast: inlinedStmts.			].		].		stmtList setStatements: newStatements asArray.	].	didSomething ifTrue: [		possibleSideEffectsCache _ nil.		^didSomething	].	complete ifFalse: [		self checkForCompleteness: stmtLists in: aCodeGen.		complete ifTrue: [ didSomething _ true ].  "marking a method complete is progress"	].	^didSomething!unusedLabelForInliningInto: targetMethod	| usedLabels |	usedLabels _ labels asSet.	usedLabels addAll: targetMethod labels.	^self unusedNamePrefixedBy: 'l' avoiding: usedLabels! !!TMethod methodsFor: 'inlining support'!addVarsDeclarationsAndLabelsOf: methodToBeInlined	"Prepare to inline the body of the given method into the receiver by making the args and locals of the argument to the receiver be locals of the receiver. Record any type declarations for these variables. Record labels. Assumes that the variables have already be renamed to avoid name clashes."	methodToBeInlined args, methodToBeInlined locals do: [ :v |		(locals includes: v) ifFalse: [ locals addLast: v ].	].	methodToBeInlined declarations associationsDo: [ :assoc |		declarations add: assoc.	].	methodToBeInlined labels do: [ :label |		labels add: label.	].!computePossibleSideEffectsIn: aCodeGen	"Answer true if this method may have side effects. It has side effects if it assigns to a global variable. It may have side effects if it calls a non-built-in method."	parseTree nodesDo: [ :node |		node isSend ifTrue: [			node isBuiltinOperator ifFalse: [ ^true ].		].	].	^ false!endsWithReturn	"Answer true if the last statement of this method is a return."	^ parseTree statements last isReturn!hasReturn	"Answer true if this method contains a return statement."	parseTree nodesDo: [ :n | n isReturn ifTrue: [ ^ true ]].	^ false!maySubstituteGlobal: globalVar in: aCodeGen	"Answer true if this method does or may have side effects on the given global variable."	possibleSideEffectsCache = nil ifTrue: [		"see if this calls any other method and record the result"		possibleSideEffectsCache _ self computePossibleSideEffectsIn: aCodeGen.	].	possibleSideEffectsCache ifTrue: [ ^ false ].	parseTree nodesDo: [ :node |		node isAssignment ifTrue: [			node variable name = globalVar ifTrue: [ ^ false ].		].	].	"if we get here, receiver calls no other method	 and does not itself assign to the given global variable"	^ true!renameLabelsForInliningInto: destMethod	"Rename any labels that would clash with those of the destination method."	| destLabels usedLabels labelMap newLabelName |	destLabels _ destMethod labels asSet.	usedLabels _ destLabels copy.  "usedLabels keeps track of labels in use"	usedLabels addAll: labels.	labelMap _ Dictionary new.	self labels do: [ :l |		(destLabels includes: l) ifTrue: [			newLabelName _ self unusedNamePrefixedBy: 'l' avoiding: usedLabels.			labelMap at: l put: newLabelName.		].	].	self renameLabelsUsing: labelMap.!renameLabelsUsing: aDictionary	"Rename all labels according to the old->new mappings of the given dictionary."	labels _ labels collect: [ :label |		(aDictionary includesKey: label) ifTrue: [ aDictionary at: label ] ifFalse: [ label ].	].	parseTree nodesDo: [ :node |		(node isGoTo and: [aDictionary includesKey: node label]) ifTrue: [			node setLabel: (aDictionary at: node label).		].		(node isLabel and: [aDictionary includesKey: node label]) ifTrue: [			node setLabel: (aDictionary at: node label).		].	].!renameVariablesUsing: aDictionary	"Rename all variables according to old->new mappings of the given dictionary."	| newDecls |	"map args and locals"	args _ args collect: [ :arg |		(aDictionary includesKey: arg) ifTrue: [ aDictionary at: arg ] ifFalse: [ arg ].	].	locals _ locals collect: [ :v |		(aDictionary includesKey: v) ifTrue: [ aDictionary at: v ] ifFalse: [ v ].	].	"map declarations"	newDecls _ declarations species new.	declarations associationsDo: [ :assoc |		(aDictionary includesKey: assoc key)			ifTrue: [ newDecls at: (aDictionary at: assoc key) put: assoc value ]			ifFalse: [ newDecls add: assoc ].	].	declarations _ newDecls.	"map variable names in parse tree"	parseTree nodesDo: [ :node |		(node isVariable and:		 [aDictionary includesKey: node name]) ifTrue: [			node setName: (aDictionary at: node name).		].		(node isStmtList and: [node args size > 0]) ifTrue: [			node setArguments:				(node args collect: [ :arg |					(aDictionary includesKey: arg)						ifTrue: [ aDictionary at: arg ]						ifFalse: [ arg ].				]).		].	].!renameVarsForCaseStmt	"Rename the arguments and locals of this method with names like t1, t2, t3, etc. Return the number of variable names assigned. This is done to allow registers to be shared among the cases."	| i varMap |	i _ 1.	varMap _ Dictionary new.	args, locals do: [ :v |		varMap at: v put: ('t', i printString) asSymbol.		i _ i + 1.	].	self renameVariablesUsing: varMap.	^ i - 1!renameVarsForInliningInto: destMethod in: aCodeGen	"Rename any variables that would clash with those of the destination method."	| destVars usedVars varMap newVarName |	destVars _ aCodeGen globalsAsSet copy.	destVars addAll: destMethod locals.	destVars addAll: destMethod args.	usedVars _ destVars copy.  "keeps track of names in use"	usedVars addAll: args; addAll: locals.	varMap _ Dictionary new.	args, locals do: [ :v |		(destVars includes: v) ifTrue: [			newVarName _ self unusedNamePrefixedBy: v avoiding: usedVars.			varMap at: v put: newVarName.		].	].	self renameVariablesUsing: varMap.!unusedNamePrefixedBy: aString avoiding: usedNames	"Choose a unique variable or label name with the given string as a prefix, avoiding the names in the given collection. The selected name is added to usedNames."	| n newVarName |	n _ 1.	newVarName _ aString, n printString.	[usedNames includes: newVarName] whileTrue: [		n _ n + 1.		newVarName _ aString, n printString.	].	usedNames add: newVarName.	^ newVarName! !!TMethod methodsFor: 'C code generation'!emitCCodeOn: aStream generator: aCodeGen	"Emit C code for this method onto the given stream. All calls to inlined methods should already have been expanded."	self emitCHeaderOn: aStream generator: aCodeGen.	parseTree emitCCodeOn: aStream level: 1 generator: aCodeGen.	aStream nextPutAll: '}'; cr.!emitCFunctionPrototype: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	| arg |	aStream nextPutAll: returnType; space.	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	args isEmpty ifTrue: [ aStream nextPutAll: 'void' ].	1 to: args size do: [ :i |		arg _ args at: i.		(declarations includesKey: arg) ifTrue: [			aStream nextPutAll: (declarations at: arg).		] ifFalse: [			aStream nextPutAll: 'int ', (args at: i).		].		i < args size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.!emitCHeaderOn: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	aStream cr.	self emitCFunctionPrototype: aStream generator: aCodeGen.	aStream nextPutAll: ' {'; cr.	locals do: [ :var |		aStream nextPutAll: '    '.		aStream nextPutAll: (declarations at: var ifAbsent: [ 'int ', var]), ';'; cr.	].	locals isEmpty ifFalse: [ aStream cr ].! !!TMethod methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'TMethod(', selector, ')'.! !!TParseNode methodsFor: 'all'!allCalls	"Answer a collection of selectors for the messages sent in this parse tree."	| calls |	calls _ Set new: 100.	self nodesDo: [ :node |		node isSend ifTrue: [ calls add: node selector ].	].	^calls!bindVariablesIn: aDictionary	^self!hasExplicitReturn	self nodesDo: [ :node |		node isReturn ifTrue: [ ^true ].	].	^false!inlineMethodsUsing: aDictionary	self!isAssignment	^false!isCaseStmt	^false!isComment	^false!isConstant	^false!isGoTo	^false!isLabel	^false!isLeaf	"Answer true if the receiver is a variable or a constant node."	^false!isReturn	^false!isSend	^false!isStmtList	^false!isVariable	^false!nodeCount	"Answer the number of nodes in this parseTree (a rough measure of its size)."	| cnt |	cnt _ 0.	self nodesDo: [ :n | cnt _ cnt + 1 ].	^cnt!nodesDo: aBlock	aBlock value: self.!printOn: aStream 	"Append a description of the receiver onto the given stream."	self printOn: aStream level: 0.!printOn: aStream level: anInteger 	"Typically overridden. If control actually gets here, avoid recursion loop by sending to super."	super printOn: aStream.!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [self]! !!TReturnNode methodsFor: 'all'!bindVariablesIn: aDictionary	expression _ expression bindVariablesIn: aDictionary.!copyTree	^self class new		setExpression: expression copyTree!emitCCodeOn: aStream level: level generator: aCodeGen	aStream nextPutAll: 'return '.	expression emitCCodeOn: aStream level: level generator: aCodeGen.!expression	^expression!inlineMethodsUsing: aDictionary	expression _ expression inlineMethodsUsing: aDictionary.!isReturn	^true!nodesDo: aBlock	expression nodesDo: aBlock.	aBlock value: self.!printOn: aStream level: level	aStream nextPut: $^.	expression printOn: aStream level: level.!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		expression _ expression replaceNodesIn: aDictionary.		self]!setExpression: aNode	expression _ aNode.! !!TSendNode methodsFor: 'all'!args	^arguments!bindVariablesIn: aDictionary	receiver _ receiver bindVariablesIn: aDictionary.	arguments _ arguments collect: [ :a | a bindVariablesIn: aDictionary ].!copyTree	^self class new		setSelector: selector		receiver: receiver copyTree		arguments: (arguments collect: [ :arg | arg copyTree ])		isBuiltInOp: isBuiltinOperator!emitCCodeOn: aStream level: level generator: aCodeGen	"If the selector is a built-in construct, translate it and return"	(aCodeGen emitBuiltinConstructFor: self on: aStream level: level) ifTrue: [ ^self ].	"Translate this message send into a C function call."	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	(receiver isVariable and:	 [(receiver name = 'self') or: [receiver name = 'interpreterProxy']]) ifFalse: [		"self is omitted from the arguments list of the generated call"		"Note: special case for translated BitBltSimulator--also omit		 the receiver if this is a send to the variable 'interpreterProxy'"		receiver emitCCodeOn: aStream level: level generator: aCodeGen.		arguments isEmpty ifFalse: [ aStream nextPutAll: ', ' ].	].	1 to: arguments size do: [ :i |		(arguments at: i) emitCCodeOn: aStream level: level generator: aCodeGen.		i < arguments size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.!inlineMethodsUsing: aDictionary	arguments _ arguments collect: [ :arg |		arg inlineMethodsUsing: aDictionary.	].	"xxx inline this message if it is in the dictionary xxx"!isBuiltinOperator	^ isBuiltinOperator!isBuiltinOperator: builtinFlag	isBuiltinOperator _ builtinFlag.!isSend	^true!nodesDo: aBlock	receiver nodesDo: aBlock.	arguments do: [ :arg | arg nodesDo: aBlock ].	aBlock value: self.!printOn: aStream level: level	| keywords |	receiver printOn: aStream level: level.	arguments size = 0 ifTrue: [		aStream space; nextPutAll: selector.		^self	].	keywords _ selector keywords.	1 to: keywords size do: [ :i |		aStream space.		aStream nextPutAll: (keywords at: i); space.		(arguments at: i) printOn: aStream level: level + 1.	].!receiver	^receiver!receiver: aNode	receiver _ aNode.!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		receiver _ receiver replaceNodesIn: aDictionary.		arguments _ arguments collect: [ :a | a replaceNodesIn: aDictionary ].		self]!selector	^selector!setSelector: aSymbol receiver: rcvrNode arguments: argList	selector _ aSymbol.	receiver _ rcvrNode.	arguments _ argList asArray.	isBuiltinOperator _ false.!setSelector: aSymbol receiver: rcvrNode arguments: argList isBuiltInOp: builtinFlag	selector _ aSymbol.	receiver _ rcvrNode.	arguments _ argList asArray.	isBuiltinOperator _ builtinFlag.! !!TStmtListNode methodsFor: 'all'!args	^arguments!bindVariablesIn: aDictionary	statements _ statements collect: [ :s | s bindVariablesIn: aDictionary ].!copyTree	^self class new		setArguments: arguments copy		statements: (statements collect: [ :s | s copyTree ])!emitCCodeOn: aStream level: level generator: aCodeGen	statements do: [ :s |		level timesRepeat: [ aStream tab ].		s emitCCodeOn: aStream level: level generator: aCodeGen.		((self endsWithCloseBracket: aStream) or: [s isComment]) ifFalse: [ aStream nextPut: $; ].		aStream cr.	].!endsWithCloseBracket: aStream	"Answer true if the given stream ends in with $} character."	| ch pos |	(pos _ aStream position) > 0 ifTrue: [		aStream position: pos - 1.		ch _ aStream next.		aStream position: pos.	].	^ ch = $}" *** There's something wrong with File positioning.  If you execute the following code, it will print '(hello));;' , but it will give an error if you remove the line the says	f position: f position. | f c p1 p2 p3 | f _ FileStream fileNamed: 'test'.f nextPutAll: '(hello))'.f position: (p1 _ f position)-1.p2 _ f position.c _ f next.p3 _ f position.f position: f position.f nextPut: $;; nextPut: $;.f close.(FileStream fileNamed: 'test') contentsOfEntireFile"!inlineMethodsUsing: aDictionary	statements do: [ :s | s inlineMethodsUsing: aDictionary ].!isStmtList	^true!nodesDo: aBlock	statements do: [ :s | s nodesDo: aBlock ].		aBlock value: self.!printOn: aStream level: level	aStream nextPut: $[.	arguments size > 0 ifTrue: [		arguments do: [ :arg | aStream nextPutAll: ' :', arg ].		aStream nextPutAll: ' | '.	].	self printStatementsOn: aStream level: level.	aStream nextPut: $].!printStatementsOn: aStream level: level	statements size > 1 ifTrue: [ aStream crtab: level + 1 ].	1 to: statements size do: [ :i |		(statements at: i) printOn: aStream level: level.		i = statements size ifTrue: [			(statements size > 1) ifTrue: [				aStream crtab: level.			].		] ifFalse: [			aStream nextPut: $.; crtab: level + 1.		].	].!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		statements _ statements collect: [ :s | s replaceNodesIn: aDictionary ].		self]!setArguments: argList	arguments _ argList.!setArguments: argList statements: statementList	"Initialize this method using the given information."	arguments _ argList.	statements _ statementList.!setStatements: stmtList	statements _ stmtList asOrderedCollection.!statements	^statements! !!TVariableNode methodsFor: 'all'!bindVariablesIn: aDictionary	| newNode |	newNode _ aDictionary at: name asSymbol ifAbsent: [ ^self ].	^newNode copyTree!copyTree	^self class new setName: name!emitCCodeOn: aStream level: level generator: aCodeGen	name = 'nil'		ifTrue: [ aStream nextPutAll: (aCodeGen cLiteralFor: nil) ]		ifFalse: [ aStream nextPutAll: name ].!isLeaf	^true!isVariable	^true!name	^name!printOn: aStream level: level	aStream nextPutAll: name.!setName: aString	name _ aString.! !!UpdateInitializer class methodsFor: 'as yet unclassified'!initialize	"Some initializations to be performed at file-in time.  7/25/96 sw"	self flag: #scottPrivate! !!VariableNode methodsFor: 'C translation'!asTranslatorNode	^TVariableNode new setName: name! !!WarpBlt class methodsFor: 'as yet unclassified'!test1   "Display restoreAfter: [WarpBlt test1]"	"Demonstrates variable to scale and rotate"	| warp pts r1 p0 p ext |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (WarpBlt toForm: Display)		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext)]!test3   "Display restoreAfter: [WarpBlt test3]"         "The Squeak Release Mandala - 9/23/96 di"         "Move the mouse near the center of the square.        Up and down affects shrink/grow        Left and right affect rotation angle"        | warp pts p0 p box map |        box _ 100@100 extent: 300@300.        map _ (1 to: 256) as: Bitmap.        warp _ (WarpBlt toForm: Display)                clipRect: box;                sourceForm: Display;                colorMap: map;                combinationRule: Form over.        p0 _ box center.        [Sensor anyButtonPressed] whileFalse:                [p _ Sensor cursorPoint.                pts _ (box insetBy: p y - p0 y) corners                        collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].                warp copyQuad: pts toRect: box]! !!WaveTableSound methodsFor: 'sound generation'!doControl	decayRate ~= 1.0 ifTrue: [		amplitude _ (decayRate * amplitude asFloat) truncated.	].! !	Smalltalk condenseChanges.!----SNAPSHOT----(23 September 1996 8:36:00 pm )!----SNAPSHOT----(23 September 1996 8:37:25 pm )!!NibBox methodsFor: 'accessing' priorSource: 412761 inFile: 2!roundedNibDots	RoundedNibDots == nil ifTrue:		[self class initializeNibDots].	^ RoundedNibDots! !----QUIT----(23 September 1996 8:46:53 pm )!TextStyle default!Paragraph allInstancesDo: [:p | p composeAll]!Paragraph allInstancesDo: [:p | p updateCompositionHeight]!!TextStyle methodsFor: 'private' priorSource: 1831617 inFile: 1!newFontArray: anArray	"Currently there is no supporting protocol for changing these arrays. If an editor wishes to implement margin setting, then a copy of the default should be stored with these instance variables.  	8/20/96 tk, Make size depend on first font."	fontArray _ anArray.	lineGrid _ (anArray at: 1) lineGrid + 2.	"For whole family"	baseline _ (anArray at: 1) ascent + 1.	alignment _ 0.	firstIndent _ 0.	restIndent _ 0.	rightIndent _ 0.	tabsArray _ DefaultTabsArray.	marginTabsArray _ DefaultMarginTabsArray! !TextStyle allInstancesDo: [:p | p newFontArray: p fontArray]!TextStyle default fontAt: 1!----SNAPSHOT----(24 September 1996 10:21:44 am )!| ascii extraWidth char leftX characterForm |ascii _ $. asciiValue.extraWidth _ 1.		char _ Character value: ascii.		leftX _ xTable at: ascii + 1.		characterForm _ Form extent: 			((self widthOf: char) + extraWidth) @ self height.		characterForm 			copy: (characterForm boundingBox extendBy: 				(0-extraWidth@0))			from: leftX@0 in: glyphs rule: Form over.		self characterFormAt: char put: characterForm.!self edit: $.!self edit: $.!| ascii extraWidth char leftX characterForm |ascii _ $: asciiValue.extraWidth _ 1.		char _ Character value: ascii.		leftX _ xTable at: ascii + 1.		characterForm _ Form extent: 			((self widthOf: char) + extraWidth) @ self height.		characterForm 			copy: (characterForm boundingBox extendBy: 				(0-extraWidth@0))			from: leftX@0 in: glyphs rule: Form over.		self characterFormAt: char put: characterForm.!self edit: $:!self edit: $;!----SNAPSHOT----(24 September 1996 10:26:23 am )!TextStyle default fontAt: 4!TextStyle default fontAt: 4!| ascii extraWidth char leftX characterForm |ascii _ $. asciiValue.extraWidth _ 1.		char _ Character value: ascii.		leftX _ xTable at: ascii + 1.		characterForm _ Form extent: 			((self widthOf: char) + extraWidth) @ self height.		characterForm 			copy: (characterForm boundingBox extendBy: 				(0-extraWidth@0))			from: leftX@0 in: glyphs rule: Form over.		self characterFormAt: char put: characterForm.!self edit: $.!| ascii extraWidth char leftX characterForm |ascii _ $: asciiValue.extraWidth _ 1.		char _ Character value: ascii.		leftX _ xTable at: ascii + 1.		characterForm _ Form extent: 			((self widthOf: char) + extraWidth) @ self height.		characterForm 			copy: (characterForm boundingBox extendBy: 				(0-extraWidth@0))			from: leftX@0 in: glyphs rule: Form over.		self characterFormAt: char put: characterForm.!self edit: $:!self edit: $;!----SNAPSHOT----(24 September 1996 10:28:44 am )!TextStyle default fontAt: 2 put:			((TextStyle default fontArray at: 1) deepCopy emphasized: 0 named: 'NewYork10b').!| ss | ss _ (TextStyle default fontAt: 2 ) glyphs.		ss copyBits: ss boundingBox from: ss at: (1@0)			clippingBox: ss boundingBox rule: Form under fillColor: nil.!TextStyle default fontAt: 5 put:			((TextStyle default fontArray at: 4) deepCopy emphasized: 0 named: 'NewYork12b').!| ss | ss _ (TextStyle default fontAt: 5 ) glyphs.		ss copyBits: ss boundingBox from: ss at: (1@0)			clippingBox: ss boundingBox rule: Form under fillColor: nil.!TextStyle default fontAt: 3 put:			((TextStyle default fontArray at: 1) emphasized: 2 named: 'NewYork 10i').!TextStyle default fontAt: 6 put:			((TextStyle default fontArray at: 4) emphasized: 2 named: 'NewYork 12i').!----SNAPSHOT----(24 September 1996 10:32:39 am )!SysObjectNames!----SNAPSHOT----(24 September 1996 10:35:21 am )!	AbstractSound bachFugue play.!	Display restoreAfter: [WarpBlt test1]!	Display restoreAfter: [WarpBlt test3].!	Display restoreAfter: [WarpBlt test1]!----QUIT----(24 September 1996 10:40:48 am )!'From Squeak 1.1 of September 21, 1996 on 25 September 1996 at 4:18:42 pm'!!WarpBlt class methodsFor: 'as yet unclassified' priorSource: 751084 inFile: 2!test3   "Display restoreAfter: [WarpBlt test3]"	"The Squeak Release Mandala - 9/23/96 di"	"Move the mouse near the center of the square.	Up and down affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box map d t |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	"Make a color map that steps through the color space"	map _ (Display depth > 8		ifTrue: ["RGB is a bit messy..."				d _ Display depth = 16 ifTrue: [5] ifFalse: [8].				(1 to: 512) collect: [:i | t _ i bitAnd: 511.					((t bitAnd: 16r7) bitShift: d-3)					+ ((t bitAnd: 16r38) bitShift: d-3*2)					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]		ifFalse: ["otherwise simple"				1 to: (1 bitShift: Display depth)])			as: Bitmap.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		colorMap: map;		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) corners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !'From Squeak 1.1 of September 21, 1996 on 25 September 1996 at 5:30:00 pm'!!Obj methodsFor: 'adding subparts'!addDraggedObject: newObj inView: aView rect: aRect name: aName	"Add a new newObj, which has been brought in via interwindow drag.  9/25/96 sw"	aView showingContents		ifFalse:			[self addToWorkings: newObj atKey: (self uniqueWorkingsKeyLike: aName)]		ifTrue:			[self addToContents: newObj atKey: (self uniqueContentsKeyLike: aName)].	newObj setNewLayoutRectangleFrom: aRect in: aView.	newObj matchPenTo: aView.	newObj synchronizePenWithPosition.	aView invalidateVisibleObjectCache.	aView displayInterior! !!Obj methodsFor: 'menu cmds' priorSource: 447498 inFile: 2!dragIn: aView	"Drag the receiver within the view until mouse comes up.	9/25/96 sw: interwindow-drag-possibility case moved to separate method, and the *default* becomes to allow interwindow drag."	| newRect |	aView mouseDownObject: self.	Sensor leftShiftDown		ifFalse:			[^ self interwindowDragFrom: aView].	newRect _ self dragFrom: aView confined: true.	self setNewLayoutRectangleFrom: newRect in: aView! !!Obj methodsFor: 'menu cmds'!interwindowDragFrom: oldView	"Drag the receiver, not confining the drag to the original window.  If the user lets go within the original window, then treat it as a reposition of the receiver, but if not, treat it as a request for an interwindow drag, and do all the right things.  9/25/96 sw"	| newRect aBox newController newView aName |	newRect _ self dragFrom: oldView confined: false.	self flag: #hot.  "Probably should test final mouse position, rather then for view overlap"	(newRect intersects: (aBox _ oldView insetDisplayBox))		ifTrue:			[newRect _ newRect translatedToBeWithin: oldView confinementRectangle.			^ self setNewLayoutRectangleFrom: newRect in: oldView]		ifFalse:			[newController _ 				ScheduledControllers  controllerSatisfying:					[:aController | (aController isKindOf: SqueakController)						and: [aController viewHasCursor]].			((newController == nil) or:					[((newView _ newController view) canAccept: self) not])				ifTrue: "back out..."					[^ oldView mouseDownObject: nil; displayInterior]].	"Now we need to move the receiver OUT OF its old container and into its new container, and get the new container's window activated"	aName _ self name.	self cutObjectIn: oldView.	newView model addDraggedObject: self inView: newView rect: newRect name: aName.	Cursor normal show.	oldView relinquishControl.	ScheduledControllers unschedule: newController.	ScheduledControllers scheduleActive: newController! !!Obj methodsFor: 'menu cmds'!setNewLayoutRectangleFrom: newRect in: aView	"Following a dragging episode, set the receiver's layout rectangle by converting newRect from screen coordinates to window coordinates.  Clean up and get the display right.  9/25/96 sw"	| aRect |	aRect _ newRect translatedToBeWithin: aView confinementRectangle.	self layoutRectangle: (aRect translateBy: aView insetDisplayBox origin negated).	self synchronizePenWithPosition.	aView mouseDownObject: nil.	aView displayInterior! !!Obj methodsFor: 'mouse handling' priorSource: 456765 inFile: 2!catchMouseDownAt: aPoint in: aView	"The mouse went down at the given point, which fell upon the receiver.  This method is generic and not intended to be overridden.  If no special generic processing is indicated, it defers to the user-overridable mouseDownAt:in:.  5/11/96 sw	5/13/96 sw: drag if control key down	7/9/96 sw: dubious: for a vanilla object that doesn't override mouseDownAt:in:, treat the mouse down as a drag request.  At Alan's request, but doubtful...	7/10/96 sw: give the current costume first crack at processing	7/10/96 sw: remove the control key thing -- want to remap it to make-alias	7/12/96 sw: check for mouseUp override, not mouseDown -- for the moment anyway"	| result |	(false "Sensor controlKeyPressed" or: [self type == #Object and:		[(self overrides: #mouseUpAt:in:) not]]) ifTrue:			[^ self dragGestureIn: aView].	Sensor leftShiftDown ifTrue:		[^ self offerObjectMenuIn: aView].	^ self currentCostume mouseDownInCostumeFor: self at: aPoint in: aView! !!Obj methodsFor: 'mouse handling'!dragGestureIn: aView	"The user made a gesture indicating a wish to drag, drag-copy, or drag-alias the receiver in aView.  9/25/96 sw"	| relPoint anObj |	anObj _ Sensor optionKeyPressed		ifTrue:			[self copyObjectIn: aView offsetBy: (0@0)]		ifFalse:			[Sensor controlKeyPressed				ifTrue:					[self makeAliasForObjectIn: aView offsetBy: (0@0)]				ifFalse:					[self]].		^ Cursor move showWhile: [anObj dragIn: aView]! !!Obj methodsFor: 'mouse handling' priorSource: 458693 inFile: 2!mouseDownInDragBarAt: aPoint in: aView	"The mouse went down at the given point, in the receiver's top halo.  9/25/96 sw"	^ self dragGestureIn: aView! !!Obj methodsFor: 'turtle'!matchPenTo: aSqueakView	"The receiver has deposited into aSqueakView; if it has a Pen, make sure that pen now knows its new dest form.  9/25/96 sw"	pen == nil ifFalse:		[pen setDestForm: aSqueakView turtleTrailForm]! !!Obj class methodsFor: 'miscellaneous'!objectHaloWidth	"Answer the standard width of the Object halo.  Class-side access is provided so it can be called by non-Obj-descendent objects.  9/25/96 sw"	^ ObjectHaloWidth! !!SqueakView methodsFor: 'unclassified'!canAccept: anObject	"Answer whether the receiver is prepared to accept anObject as an element.  Ultimately, perhaps, locked objects, PartsBins, etc., may now be in a receptive mood, but for now we mostly just let it happen.  9/25/96 sw"	((model == anObject) | (model amContainedIn: anObject)) ifTrue: [self beep.  ^ false].	^ true! !!SqueakView methodsFor: 'unclassified'!confinementRectangle	"Answer the rectangle  into which objects need to be confined, if there is to remain room for the object halo.  9/25/96 sw"	| aWidth |	aWidth _ Obj objectHaloWidth.	^ self insetDisplayBox insetBy: (aWidth @ aWidth)! !'From Squeak 1.1 of September 21, 1996 on 25 September 1996 at 5:33:15 pm'!!Alias methodsFor: 'everything' priorSource: 3592 inFile: 2!mimicCostumeOf: anotherObject	"Just view the other guy?  Alias to text not wear a text costume.  9/13/96 tk.	9/25/96 sw: for the non-text-costume case, let this function in the intended way"	(anotherObject currentCostume isKindOf: TextCostume)		ifFalse:			[^ super mimicCostumeOf: anotherObject].	currentCostume _  self useStandardCostumeNamed: 'Contents'.	(anotherObject costumes includes: currentCostume)		ifTrue:			[self costumes add: currentCostume]	! !'From Squeak 1.1 of September 21, 1996 on 27 September 1996 at 5:06:57 pm'!!Obj class methodsFor: 'pilot example' priorSource: 500846 inFile: 2!addNephewsTo: anObj	"For the pilot example, add the three nephews to anObj.  This method is factored out to here because the method from whence it came got too many literals to compile.  6/10/96 sw	7/13/96 sw: use newUserInstance	9/27/96 sw make Huey a Folder"	| objChild grandChild |	objChild _ Folder newUserInstance.	objChild layoutRectangle: (5 @ 10 extent: 50 @ 40).	"objChild windowBounds: (5 @ 40 extent: 100 @ 80)."	objChild velocity: (-2 @ -4).	objChild useStandardCostumeNamed: 'Contents'.	objChild class compile: 'borderWidth	^ 2' classified: 'display'.	anObj addToContents: objChild atKey: 'Huey'.	grandChild _ StringObj newUserInstance.	grandChild layoutRectangle: (5 @ 10 extent: 12 @ 12).	grandChild velocity: (1 @ 1).	objChild addToContents: grandChild atKey: 'A'.	grandChild _ StringObj newUserInstance.	grandChild layoutRectangle: (5 @ 30 extent: 12 @ 12).	grandChild velocity: (2 @ -3).	objChild addToContents: grandChild atKey: 'B'.	objChild _ BooleanObj newUserInstance.	objChild layoutRectangle: (5 @ 40 extent: 40 @ 15).	objChild velocity: (3 @ 8).	anObj addToContents: objChild atKey: 'Louie'.	objChild _ NumberObj newUserInstance.	objChild layoutRectangle: (5 @ 70 extent: 42 @ 15).	objChild velocity: (2 @ -3).	anObj addToContents: objChild atKey: 'Dewey'.! !!Obj class methodsFor: 'pilot example' priorSource: 502146 inFile: 2!pilotExample	"The pilot example used for developing and testing and demonstrating the salient features of the prototype.  6/2/96 sw	7/10/96 sw: don't reinitialize the world each time, and call openInOwnWindowTellingView: rather than separately allocating and initializing the view.	7/13/96 sw: use newUserInstance	7/15/96 sw: call referTo: to set the referent of the Alias"	"Obj pilotExample"	|  anObj objChild  exampleWindow nephs ship |	exampleWindow _ Folder newUserInstance.	Home addToContents: exampleWindow atKey: 'Squeak!!'.	exampleWindow assumePictureCostumeNamed: 'Folder'.	exampleWindow windowBounds: (40 @ 20 extent: 380 @ 300).	self addBlueBoxTo: exampleWindow. "Factored out because method got too complex to compile"	nephs _ Folder newUserInstance.	"nephs suggestDefaultExtent: 140 @ 150."	nephs velocity: 1@2.	exampleWindow addToContents: nephs atKey: 'Nephews'.	nephs setDefaultCostume; setExtentToMatchCostume.	self addNephewsTo: nephs.  "Factored out because method got too complex to compile"	anObj _ TextObj newUserInstance.	anObj suggestDefaultExtent: 140 @ 70.	exampleWindow addToContents: anObj atKey: 'Goodnight Moon'.	anObj contents: (Paragraph withText: (Text fromString: 'In the great greenroom, there was a telephone, and a redballoon...')).	anObj setDefaultCostume.	anObj _ Alias newUserInstance.  "create an alias object"	exampleWindow addToContents: anObj atKey: 'Huey alias'.	anObj useStandardCostumeNamed: 'Picture'.	anObj setParameter: 'Dancer' forKey: #PictureName.	anObj setExtentToMatchCostume.	anObj referTo: (nephs contentsAtKey: 'Huey').	exampleWindow addToContents: (ship _ self shipObjectForPilotExample) atKey: 'Ship'.	ship  setExtentToMatchCostume.	anObj _ TextObj newUserInstance.	anObj layoutRectangle: (5 @ 150 extent: 142 @ 70).	anObj contents: (Paragraph withText: (Text fromString: 'Hi!!  I''m an object thatlives in the WORKINGSof the my parent.')).	exampleWindow addToWorkings: anObj atKey: 'Read Me'.	exampleWindow openInOwnWindowTellingView:		[:aView | aView label: '* Squeak!! *'.		aView showNames: true]! !'From Squeak 1.1 of September 21, 1996 on 29 September 1996 at 9:57:01 pm'!SqueakController class removeSelector: #dragLaunch:image:offset:!SqueakController class removeSelector: #dragLaunch:image:offset:!SqueakController class removeSelector: #switchWindows!SqueakController class removeSelector: #switchWindows!SqueakController class removeSelector: #objectToLaunch:!SqueakController class removeSelector: #objectToLaunch:!StandardSystemController subclass: #SqueakController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HyperSqueak-Support'!'From Squeak 1.1 of September 21, 1996 on 29 September 1996 at 10:31:29 pm'!!Obj methodsFor: 'adding subparts' priorSource: 439791 inFile: 2!addNewTurtleIn: aView	"Invoked from menu: add a turtle.  7/17/96 sw	 9/28/96 sw: call displayInterior after the launch, so that the turtle will be visible even if the window is frozen."	| anObject aPen |	anObject _ Obj newUserInstance.	anObject currentCostume: (anObject costumeNamed: 'Picture').	anObject setParameter: 'Ship' forKey: #PictureName.	self addNewObject: anObject butDoNotDisplayYetIn: aView.	anObject assurePenExistsIn: aView.	aPen _ anObject pen.	aPen defaultNib: 4 atRandom.	anObject setWhimsicalVelocity.	anObject setExtentToMatchCostume.	aPen fillColor: (Color perform:		(#(blue red green black magenta cyan) at: 6 atRandom)).	anObject penDown.	aView displayInterior! !!Costume methodsFor: 'everything' priorSource: 103653 inFile: 2!revealsContentsFor: anObject	"Answer whether the receiver reveals nested subparts on the contents side.  Here so no one gets left out.  9/5/96 tk	9/29/96 Undid the damage!!"	^ false"	^ anObject isKindOf: Folder"! !'From Squeak 1.1 of September 21, 1996 on 26 September 1996 at 11:18:16 am'!!SystemDictionary methodsFor: 'retrieving'!pointersTo: anObject	"Find all occurrences in the system of pointers to the argument anObject."	"(Smalltalk pointersTo: Browser) inspect."	^ self pointersTo: anObject except: #()! !!SystemDictionary methodsFor: 'retrieving'!pointersTo: anObject except: objectsToExclude	"Find all occurrences in the system of pointers to the argument anObject. Remove objects in the exclusion list from the results."	| results anObj |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	results _ OrderedCollection new: 1000.	"allObjectsDo: is expanded inline to keep spurious	 method and block contexts out of the results"	anObj _ self someObject.	[0 == anObj] whileFalse: [		(anObj pointsTo: anObject) ifTrue: [			"exclude the results collector and contexts in call chain"			((anObj ~~ results collector) and:			 [(anObj ~~ thisContext) and:			 [(anObj ~~ thisContext sender) and:			 [anObj ~~ thisContext sender sender]]])				 ifTrue: [ results add: anObj ].		].		anObj _ anObj nextObject.	].	objectsToExclude do: [ :obj | results removeAllSuchThat: [ :el | el == obj]].	^ results asArray! !!SystemDictionary methodsFor: 'retrieving'!pointersToItem: index of: anArray	"Find all occurrences in the system of pointers to the given element of the given array. This is useful for tracing up a pointer chain from an inspector on the results of a previous call of pointersTo:. To find out who points to the second element of the results, one would evaluate:	Smalltalk pointersToItem: 2 of: selfin the inspector."	^ self pointersTo: (anArray at: index) except: (Array with: anArray)! !SystemDictionary removeSelector: #pointersTo:do:!SystemDictionary removeSelector: #pointersTo:do:!SystemDictionary removeSelector: #collectPointersTo:!SystemDictionary removeSelector: #collectPointersTo:!'From Squeak 1.1 of September 21, 1996 on 27 September 1996 at 5:06:51 pm'!!Object methodsFor: 'testing'!name	"Answer a name for the receiver.  This is used generically in the title of certain inspectors, such as the referred-to inspector, and specificially by various subsystems.  By default, we let the object just print itself out..  9/27/96 sw"	^ self printString! !!InspectListController methodsFor: 'menu messages'!objectReferencesToSelection	"Open a list inspector on all the objects that point to the thevalue of the selected instance variable, if any.  9/27/96 sw"	model selectionIndex == 0 ifTrue: [^ view flash].	self controlTerminate.	Smalltalk browseAllObjectReferencesTo: model selection ifNone: [:obj | view flash]! !!InspectListController class methodsFor: 'class initialization' priorSource: 938069 inFile: 1!initialize	"Initialize the menu associated with the upper-left pane of an Inspector.  1/25/96 sw: added references and browse items	 9/27/96 sw: added object refs"	InspectListYellowButtonMenu _ PopUpMenu labels: 'inspectmethod refs to this inst varobjects pointing to this valuebrowse fullbrowse class'	lines: #(1 3).	InspectListYellowButtonMessages _ 		#(inspectSelection referencesToSelection objectReferencesToSelection browseFull browseClass )	"InspectListController initialize"! !!DictionaryListController class methodsFor: 'class initialization' priorSource: 654147 inFile: 1!initialize	DictionaryListYellowButtonMenu _		PopUpMenu labels:'inspectreferencesobjects pointing to this valueadd keyremove'		lines: #( 3 ).	DictionaryListYellowButtonMessages _		#(inspectSelection selectionReferences objectReferencesToSelection addEntry removeSelection )	"DictionaryListController initialize"! !!ParagraphEditor methodsFor: 'menu messages' priorSource: 1298868 inFile: 1!specialMenuItems	"Refer to comment under #presentSpecialMenu.  4/29/96 sw.	 9/27/96 sw: added objectsReferencingIt,"	^ #(	'Transcript cr; show: ''testing'''			'view superView model inspect'			'view superView model browseObjClass'			'view display'			'self inspect'			'view backgroundColor: Color fromUser'			'view topView inspect'			'self compareToClipboard'			'view insideColor: Form white'			'self objectsReferencingIt'		) ! !!StringHolderController methodsFor: 'menu messages'!objectsReferencingIt	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  9/27/96 sw"	| result |	self controlTerminate.	(((result _ self evaluateSelection) isKindOf: FakeClassPool) or:		[result == #failedDoit])			ifFalse:				[Smalltalk browseAllObjectReferencesTo: result					ifNone: [:obj | view flash.  self controlInitialize]]! !!SystemDictionary methodsFor: 'browsing'!browseAllObjectReferencesTo: anObject ifNone: aBlock	"If there are any objects that point to anObject, then put up list inspector on them; if there are none, then evaluate aBlock, which should be a one-arg block which will be sent anObject.  9/27/96 sw"	| aList |	(aList _ Smalltalk pointersTo: anObject) size > 0		ifFalse: [^ aBlock value: anObject].	InspectorView open: (InspectorView inspector:		(OrderedCollectionInspector inspect: aList)) withLabel: 'Objects that refer to ', anObject name, ' [', aList size printString, ']'! !InspectListController initialize!DictionaryListController initialize!'From Squeak 1.1 of September 21, 1996 on 29 September 1996 at 4:16:37 pm'!Object subclass: #PopUpMenu	instanceVariableNames: 'labelString font lineArray frame form marker selection '	classVariableNames: 'CacheMenuForms '	poolDictionaries: ''	category: 'Interface-Menus'!!PopUpMenu methodsFor: 'displaying' priorSource: 1422939 inFile: 1!displayAt: aPoint withCaption: captionOrNil during: aBlock 	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."	| delta savedArea captionView captionSave outerFrame captionText tFrame frameSaveLoc |	frame _ frame align: marker leftCenter with: aPoint + (2@0).	outerFrame _ frame.	captionOrNil notNil ifTrue:		[captionText _ DisplayText				text: captionOrNil asText				textStyle: (TextStyle default copy alignment: 2).		tFrame _ captionText boundingBox insetBy: -2.		outerFrame _ frame merge: (tFrame align: tFrame bottomCenter					with: frame topCenter + (0@2))].	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	frame moveBy: delta.	captionOrNil notNil ifTrue:		[captionView _ DisplayTextView new model: captionText.		captionView align: captionView boundingBox bottomCenter					with: frame topCenter + (0@2).		captionView insideColor: Display white.		captionView borderWidth: 2.		captionSave _ Form fromDisplay: captionView displayBox.		captionView unlock; display; release].	marker _ marker align: marker leftCenter with: aPoint + delta +  (2@0).	savedArea _ Form fromDisplay: frame.	self menuForm displayOn: Display at: (frameSaveLoc _ frame topLeft).	selection ~= 0 ifTrue: [Display reverse: marker].	aBlock value.	savedArea displayOn: Display at: frameSaveLoc.	captionOrNil notNil ifTrue:		[captionSave displayOn: Display at: captionView displayBox topLeft]! !!PopUpMenu methodsFor: 'marker adjustment' priorSource: 1425929 inFile: 1!scrollIntoView: cursorLoc	| dy |	dy _ 0.	cursorLoc y < 0 ifTrue: [dy _ font height].	cursorLoc y > Display height ifTrue: [dy _ font height negated].	dy = 0 ifTrue: [^ 0@0].	self markerOff.	frame moveBy: 0@dy.	marker moveBy: 0@dy.	self menuForm displayOn: Display at: frame topLeft.	^ 0@dy! !!PopUpMenu methodsFor: 'private'!computeForm	"Compute and answer a Form to be displayed for this menu."	| borderInset paraForm menuForm |	borderInset _ 2@2.	paraForm _ self computeLabelParagraph asForm.	menuForm _ Form extent: paraForm extent + (borderInset * 2).	menuForm fillBlack.	paraForm displayOn: menuForm at: borderInset.	lineArray == nil ifFalse: [		lineArray do: [ :line |			menuForm fillBlack:				(0 @ ((line * font height) + borderInset y) extent: (menuForm width @ 1)).		].	].	^ menuForm! !!PopUpMenu methodsFor: 'private'!computeLabelParagraph	"Answer a Paragraph containing this menu's labels, one per line and centered."	| style |	style _ TextStyle fontArray: (Array with: font).	style alignment: 2.  "centered"	style gridForFont: 1 withLead: 0.	^ Paragraph withText: labelString asText style: style! !!PopUpMenu methodsFor: 'private' priorSource: 1427015 inFile: 1!labels: aString font: aFont lines: anArray	| style inside |	labelString _ aString.	font _ aFont.	lineArray _ anArray.	frame _ Quadrangle new.	frame region: self menuForm boundingBox.	frame borderWidth: 2.	inside _ frame inside.	marker _ inside topLeft extent: (inside width @ self computeLabelParagraph lineGrid).	selection _ 1.! !!PopUpMenu methodsFor: 'private'!menuForm	"Answer a Form to be displayed for this menu."	"Details: On slower systems, cache the menu Form for speed."	CacheMenuForms ifTrue: [		form == nil ifTrue: [ form _ self computeForm ].		^ form	] ifFalse: [		^ self computeForm	].! !!PopUpMenu methodsFor: 'private' priorSource: 1427949 inFile: 1!rescan	"Cause my form to be recomputed after a font change."	labelString == nil		ifFalse: [ self labels: labelString font: font lines: lineArray ].	form _ nil.	"PopUpMenu withAllSubclasses do: [ :menuClass |		menuClass allInstancesDo: [ :m | m rescan ]]"! !!PopUpMenu class methodsFor: 'class initialization'!initialize	"Change CacheMenuForms to true to get faster popup menus on slower systems."	"CacheMenuForms _ true"	CacheMenuForms _ false.! !PopUpMenu initialize!PopUpMenu withAllSubclasses do:	[ :menuClass | menuClass allInstancesDo: [ :m | m rescan ]]!'From Squeak 1.1 of September 21, 1996 on 29 September 1996 at 4:22:38 pm'!!Array2D methodsFor: 'access' priorSource: 31432 inFile: 1!atCol: i put: list    "Put in a whole column.     hold first index constant"    list size = self height ifFalse: [self error: 'wrong size'].    list doWithIndex: [:value :j |        self at: i at: j put: value].! !!Array2D methodsFor: 'access' priorSource: 31759 inFile: 1!atRow: j put: list    "Put in a whole row.     hold second index constant"    list size = self width ifFalse: [self error: 'wrong size'].    list doWithIndex: [:value :i |        self at: i at: j put: value].! !!CCodeGenerator methodsFor: 'inlining' priorSource: 73621 inFile: 2!methodStatsString	"Return a string describing the size, # of locals, and # of senders of each method. Note methods that have inline C code or C declarations."	| methodsWithCCode sizesOf callsOf hasCCode nodeCount senderCount sel s calls registers |	methodsWithCCode _ Set new: methods size.	sizesOf _ Dictionary new: methods size * 2.  "selector -> nodeCount"	callsOf _ Dictionary new: methods size * 2.  "selector -> senderCount"	"For each method, scan its parse tree once to:		1. determine if the method contains C code or declarations		2. determine how many nodes it has		3. increment the sender counts of the methods it calls		4. determine if it includes any C declarations or code"	methods do: [ :m |		(translationDict includesKey: m selector) ifTrue: [			hasCCode _ true.		] ifFalse: [			hasCCode _ m declarations size > 0.			nodeCount _ 0.			m parseTree nodesDo: [ :node |				node isSend ifTrue: [					sel _ node selector.					sel = #cCode: ifTrue: [ hasCCode _ true ].					senderCount _ callsOf at: sel ifAbsent: [ 0 ].					callsOf at: sel put: senderCount + 1.				].				nodeCount _ nodeCount + 1.			].		].		hasCCode ifTrue: [ methodsWithCCode add: m selector ].		sizesOf at: m selector put: nodeCount.	].	s _ WriteStream on: (String new: 5000).	methods keys asSortedCollection do: [ :sel |		m _ methods at: sel.		registers _ m locals size + m args size.		calls _ callsOf at: sel ifAbsent: [0].		registers > 11 ifTrue: [			s nextPutAll: sel; tab.			s nextPutAll: (sizesOf at: sel) printString; tab.			s nextPutAll: calls printString; tab.			s nextPutAll: registers printString; tab.			(methodsWithCCode includes: sel) ifTrue: [ s nextPutAll: 'CCode' ].		s cr.		].	].	^ s contents! !!DiskProxyQ methodsFor: 'as yet unclassified' priorSource: 661141 inFile: 1!xxxQMessage: aMessage    "Enqueue aMessage on the queue of messages that I will send the newly-created     object at internalization time.     IMPLEMENTATION: My instance variable messageQueue holds either nil or an Array        of objects to sendTo: the object I'm internalizing to (generally of class        Message or Symbol). -- 11/9/92 jhm     12/1/92 jhm: Remove the 1-element-array optimization."    messageQueue _ messageQueue == nil        ifTrue:  [Array with: aMessage]        ifFalse: [messageQueue, aMessage]! !!DiskProxyQ class methodsFor: 'imported from V' priorSource: 664714 inFile: 1!readDataFrom: aDataStream size: anInteger    "Create an object based on the contents of aDataStream, which was       generated by the objects storeDataOn: method. Answer it.     NOTE: This implementation for DiskProxyQ deals with a subtle issue in reading a        network of objects. Recursively reading the a DiskProxyQs parts will        internalize them (comeFullyUpOnReload), possibly sending messages to the        nascent DiskProxyQ. I.e. the incomplete object receives (and enqueues)        messages!! When we read the DiskProxyQs message queue, we must combine        it with the accumulated queue.     ASSUMES: Rather than hard-wire the index of the inst var messageQueue, we        assume that any non-nil inst var has an Array to be concatenated with the        filed value.     NOTE: This method must match its corresponding storeDataOn:       method. Also, it must send beginReference: after instantiating       the new object but before reading any objects from aDataStream       that might reference it. -- 12/1/92 jhm"    | anObject cntInstVars cntIndexedVars nextValue var |    cntInstVars _ self instSize.    anObject _ self isVariable        ifTrue:  [cntIndexedVars _ anInteger - cntInstVars.                 self basicNew: cntIndexedVars]        ifFalse: [cntIndexedVars _ 0.                 self basicNew].    aDataStream beginReference: anObject.    "Read in the instance vars, but dont just overwrite vars that get contents     before we get there due to recursive work in aDataStream next."    1 to: cntInstVars do: [:i |        nextValue _ aDataStream next.        (var _ anObject instVarAt: i) == nil            ifTrue:     "the normal case"                [anObject instVarAt: i put: nextValue]            ifFalse:    "Oops!! Recover: Concatenate nextValue and var Arrays."                [nextValue == nil                    ifFalse: [anObject instVarAt: i put: (nextValue, var)]]].    "Read in the indexed vars."    1 to: cntIndexedVars do:        [:i | anObject basicAt: i put: aDataStream next].    ^ anObject! !!DisplayText class methodsFor: 'examples' priorSource: 701069 inFile: 1!example	"Continually prints two lines of text wherever you point with the cursor 	and press any mouse button.  Terminate by pressing any key on the 	keyboard."	| t |	t _ 'this is a line of characters andthis is the second line.' asDisplayText.	t _ t alignedTo: #center.	[Sensor anyButtonPressed]		whileFalse:			[t displayOn: Display at: Sensor cursorPoint]	"DisplayText example."! !!FileStream methodsFor: 'file status' priorSource: 765959 inFile: 1!close	"Set the receiver's file status to closed."	closed		ifFalse: 			[self writing 				ifTrue: [(rwmode bitAnd: Shorten) = Shorten							ifTrue: [self shorten]							ifFalse: [self flush]].			closed _ true.			readLimit _ writeLimit _ 0.			self file close].! !!FormEditor methodsFor: 'editing tools' priorSource: 869044 inFile: 1!fileOutForm	"Ask the user for a file name and then save the current source form 	(form) under that name. Does not change the tool."	| outName |	outName _ self promptRequest: 'type a name for saving the source Form . . . '.	FileDirectory convertName: outName to: [ :vol :name |		(vol isLegalFileName: name)			ifTrue: [(vol includesKey: name) 					ifTrue: [(self confirm: 									'Okay to write over old file?')								ifTrue: [form writeOn: outName]]					ifFalse: [form writeOn: outName]]].	tool _ previousTool! !!InputSensor methodsFor: 'joystick' priorSource: 922016 inFile: 1!joystickOn: index	^ (((self primReadJoystick: index) bitShift: -27) bitAnd: 1) ~= 0	! !!SystemBuilder class methodsFor: 'system building' priorSource: 1751018 inFile: 1!finalSystemBuildingSteps	"The final steps after all the file-ins, before we can call the system built.  1/18/96 sw"	Symbol rehash.     " Reclaim unused symbols"	self showInTranscript: '** System Built **'.	BuildingSystem _ false.! !!SystemBuilder class methodsFor: 'system building' priorSource: 1752000 inFile: 1!initializeAfterSystemBuild	"Reinitialize needs to be called manually after filing in the kernel because other support classes need to have been filed in before it can run successfully.  This method copied over from old macPal stuff, 1/27/96 sw, to serve as a template, but the real work needs to be done still."	Text initTextConstants.		"Rebuild snapshot lists"	self showInTranscript: '** SystemBuilder reinitialize  **'.	"self initMenus"! !!SystemDictionary methodsFor: 'special objects'!isSpecialSelector: aSymbol	"Answer true if the given selector is one of the special selectors. Sends of special selectors are encoded encoded directly in the bytecode set to save literal space in compiled methods."	1 to: self specialSelectorSize do: [ :i | 		(self specialSelectorAt: i) == aSymbol ifTrue: [ ^true ].	].	^ false! !Object removeSelector: #saveOnFile!Object removeSelector: #saveOnFile!Controller removeSelector: #yellowButtonPushed!Controller removeSelector: #yellowButtonPushed!Debugger removeSelector: #browseSendersOf!Debugger removeSelector: #browseSendersOf!ListController removeSelector: #mmarkerDelta!ListController removeSelector: #mmarkerDelta!SystemBuilder class removeSelector: #removeMacAppClassesFromSystem!SystemBuilder class removeSelector: #removeMacAppClassesFromSystem!SystemDictionary removeSelector: #newWorld!SystemDictionary removeSelector: #newWorld!'From Squeak 1.1 of September 21, 1996 on 29 September 1996 at 4:16:45 pm'!ParseNode removeSelector: #moveVariableToFarLeft:!ParseNode removeSelector: #moveVariableToFarLeft:!ParseNode removeSelector: #collectVariables!ParseNode removeSelector: #collectVariables!ParseNode removeSelector: #match:using:!ParseNode removeSelector: #match:using:!ParseNode removeSelector: #copyReplacingVariables:!ParseNode removeSelector: #copyReplacingVariables:!ParseNode removeSelector: #allVariables!ParseNode removeSelector: #allVariables!AssignmentNode removeSelector: #specificMatch:using:!AssignmentNode removeSelector: #specificMatch:using:!AssignmentNode removeSelector: #copyReplacingVariables:!AssignmentNode removeSelector: #copyReplacingVariables:!AssignmentNode removeSelector: #collectVariables!AssignmentNode removeSelector: #collectVariables!BlockNode removeSelector: #specificMatch:using:!BlockNode removeSelector: #specificMatch:using:!BlockNode removeSelector: #copyReplacingVariables:!BlockNode removeSelector: #copyReplacingVariables:!BlockNode removeSelector: #collectVariables!BlockNode removeSelector: #collectVariables!CascadeNode removeSelector: #specificMatch:using:!CascadeNode removeSelector: #specificMatch:using:!CascadeNode removeSelector: #copyReplacingVariables:!CascadeNode removeSelector: #copyReplacingVariables:!CascadeNode removeSelector: #collectVariables!CascadeNode removeSelector: #collectVariables!LiteralNode removeSelector: #specificMatch:using:!LiteralNode removeSelector: #specificMatch:using:!LiteralNode removeSelector: #copyReplacingVariables:!LiteralNode removeSelector: #copyReplacingVariables:!LiteralNode removeSelector: #collectVariables!LiteralNode removeSelector: #collectVariables!MessageNode removeSelector: #specificMatch:using:!MessageNode removeSelector: #specificMatch:using:!MessageNode removeSelector: #copyReplacingVariables:!MessageNode removeSelector: #copyReplacingVariables:!MessageNode removeSelector: #collectVariables!MessageNode removeSelector: #collectVariables!MethodNode removeSelector: #specificMatch:using:!MethodNode removeSelector: #specificMatch:using:!MethodNode removeSelector: #block!MethodNode removeSelector: #block!MethodNode removeSelector: #copyReplacingVariables:!MethodNode removeSelector: #copyReplacingVariables:!MethodNode removeSelector: #collectVariables!MethodNode removeSelector: #collectVariables!ReturnNode removeSelector: #specificMatch:using:!ReturnNode removeSelector: #specificMatch:using:!ReturnNode removeSelector: #expr!ReturnNode removeSelector: #expr!ReturnNode removeSelector: #copyReplacingVariables:!ReturnNode removeSelector: #copyReplacingVariables:!ReturnNode removeSelector: #collectVariables!ReturnNode removeSelector: #collectVariables!SelectorNode removeSelector: #specificMatch:using:!SelectorNode removeSelector: #specificMatch:using:!SelectorNode removeSelector: #copyReplacingVariables:!SelectorNode removeSelector: #copyReplacingVariables:!VariableNode removeSelector: #moveVariableToFarLeft:!VariableNode removeSelector: #moveVariableToFarLeft:!VariableNode removeSelector: #match:using:!VariableNode removeSelector: #match:using:!VariableNode removeSelector: #copyReplacingVariables:!VariableNode removeSelector: #copyReplacingVariables:!VariableNode removeSelector: #collectVariables!VariableNode removeSelector: #collectVariables!'From Squeak 1.1 of September 21, 1996 on 30 September 1996 at 5:06:17 pm'!!DisplayScanner methodsFor: 'private' priorSource: 689743 inFile: 1!checkEmphasis	"convert mask to color 6/18/96 tk.	9/30/96 tk: use foreColor."	| emphasis sourceRect y foreColor |	(emphasis _ font emphasis) = 0 ifTrue: [^self].	colorMap == nil ifFalse: [		foreColor _ Bitmap with: (colorMap at: 2)].		"Should really have the paragraph here to ask for foreColor"	emphasis >= 8 ifTrue:  "struck out"		[destForm			fill: ((runX @ (lineY + textStyle baseline-3)) extent: (destX - runX) @ 1)			rule: combinationRule fillColor: foreColor.	"color already converted to a Bitmap"		emphasis _ emphasis - 8].	emphasis >= 4 ifTrue:  "underlined"		[destForm			fill: ((runX @ (lineY + textStyle baseline)) extent: (destX - runX) @ 1)			rule: combinationRule fillColor: foreColor.		emphasis _ emphasis - 4].	emphasis >= 2 ifTrue:  "itallic"		[y _ lineY + textStyle lineGrid - 4.		[y > lineY] whileTrue:			[sourceRect _ runX @ lineY extent: (destX - runX - 1) @ (y - lineY).			destForm				copyBits: sourceRect from: destForm at: (runX+1) @ lineY				clippingBox: sourceRect rule: Form over fillColor: nil.			y _ y - 4].		emphasis _ emphasis - 2].	emphasis >= 1 ifTrue:  "bold face"		[sourceRect _ runX @ lineY extent: (destX - runX - 1) @ textStyle lineGrid.		destForm			copyBits: sourceRect from: destForm at: (runX+1) @ lineY			clippingBox: sourceRect rule: 25 fillColor: nil]			"Just a patch till we get color text, which will allow synthetic bolding"! !!Form methodsFor: 'pattern' priorSource: 805402 inFile: 1!colorAt: aPoint	"Return the Color in the pixel at coordinate aPoint.  6/20/96 tk"	^ Color 		colorFromPixelValue: 			((BitBlt bitPeekerFromForm: self) pixelAt: aPoint)		depth: depth! !!Paragraph methodsFor: 'private' priorSource: 1260624 inFile: 1!compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint	compositionRectangle _ compositionRect copy.	text _ aText.	textStyle _ aTextStyle.	rule _ DefaultRule.	mask _ nil.		"was DefaultMask 9/30/96 tk"	marginTabsLevel _ 0.	destinationForm _ Display.	offset _ aPoint.	^self composeAll! !!Paragraph class methodsFor: 'examples' priorSource: 1269499 inFile: 1!example	"This simple example illustrates how to display a few lines of text on the screen at the current cursor point.  	Fixed. 9/30/96 tk"	| para point |	point _ Sensor waitButton.	para _ 'This is the first line of charactersand this is the second line.' asParagraph.	para displayOn: Display at: point.	"Paragraph example"! !'From Squeak 1.1 of September 21, 1996 on 3 October 1996 at 3:59:51 pm'!BitBlt subclass: #WarpBlt	instanceVariableNames: 'p1x p1y p1z p2x p2y p2z p3x p3y p3z p4x p4y p4z cellSize sourceRGBmap '	classVariableNames: 'SourceMapCache DestMapCache '	poolDictionaries: ''	category: 'Graphics-Support'!!Form methodsFor: 'pattern' priorSource: 793120 inFile: 2!colorAt: aPoint	"Return the Color in the pixel at coordinate aPoint.  6/20/96 tk"	^ Color colorFromPixelValue: 			((BitBlt bitPeekerFromForm: self) pixelAt: aPoint)		depth: depth! !!WarpBlt methodsFor: 'setup'!cellSize: s	cellSize _ s.	cellSize = 1 ifTrue: [^ self].	cellSize > 3 ifTrue:		[(self confirm:'Do you really want to averagemore than 3x3 pixels?') ifFalse: [self halt]].	(destForm depth < 16 and: [colorMap == nil])		ifTrue: [self setDestMap: 3]! !!WarpBlt methodsFor: 'setup'!rgbValues	"RGB forms (depth 16 and 32) don't need a source map"	sourceForm depth >= 16 ifTrue: [^ nil].	"All other forms, for now, are assumed to use our	standard color map, so all warps will share it."	SourceMapCache == nil ifTrue:		[SourceMapCache _ "Compute once and save around"			(Color indexedColors collect: [:c | c pixelValueForDepth: 32])					as: Bitmap].	^ SourceMapCache	"Special applications such as external GIF images might want to	supply their own RGB map by directly calling, eg,		self warpBitsSmoothing: cellSize sourceMap: specialRGBmap"! !!WarpBlt methodsFor: 'setup'!setDestMap: bitsPerColor	"Establish a destination color map to convert from pixel-averaged	RGB values to (presumably non-RGB) destination pixel values"	| mask |	DestMapCache size = (1 bitShift: bitsPerColor*3) ifTrue:		["Just use the last one if same bits per color"		colorMap _ DestMapCache.		^ self].	mask _ (1 bitShift: bitsPerColor) - 1.	colorMap _ Bitmap new: (1 bitShift: bitsPerColor*3).	0 to: colorMap size - 1 do:		[:i | colorMap at: i+1 put:			((Color red: ((i bitShift: 0 - (bitsPerColor*2)) bitAnd: mask)				green: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)				blue: ((i bitShift: 0) bitAnd: mask)				range: mask)			pixelValueForDepth: destForm depth)].	"Cache for possible reuse"	DestMapCache _ colorMap! !!WarpBlt methodsFor: 'smoothing'!mixPix: pix sourceMap: sourceMap destMap: destMap	"Average the pixels in array pix to produce a destination pixel.	First average the RGB values either from the pixels directly,	or as supplied in the sourceMap.  Then return either the resulting	RGB value directly, or use it to index the destination color map." 	| r g b rgb nPix bitsPerColor d |	nPix _ pix size.	r _ 0. g _ 0. b _ 0.	1 to: nPix do:		[:i |   "Sum R, G, B values for each pixel"		rgb _ sourceForm depth <= 8				ifTrue: [sourceMap at: (pix at: i) + 1]				ifFalse: [sourceForm depth = 32						ifTrue: [pix at: i]						ifFalse: [BitBltSimulation new								rgbMap: (pix at: i) from: 5 to: 8]].		r _ r + ((rgb bitShift: -16) bitAnd: 16rFF).		g _ g + ((rgb bitShift: -8) bitAnd: 16rFF).		b _ b + ((rgb bitShift: 0) bitAnd: 16rFF)].	destMap == nil		ifTrue: [bitsPerColor _ 3.  "just in case eg depth <= 8 and no map"				destForm depth = 16 ifTrue: [bitsPerColor _ 5].				destForm depth = 32 ifTrue: [bitsPerColor _ 8]]		ifFalse: [destMap size = 512 ifTrue: [bitsPerColor _ 3].				destMap size = 4096 ifTrue: [bitsPerColor _ 4].				destMap size = 32768 ifTrue: [bitsPerColor _ 5]].	d _ bitsPerColor - 8.	rgb _ ((r // nPix bitShift: d) bitShift: bitsPerColor*2)		+ ((g // nPix bitShift: d) bitShift: bitsPerColor)		+ ((b // nPix bitShift: d) bitShift: 0).	destMap == nil		ifTrue: [^ rgb]		ifFalse: [^ destMap at: rgb+1]! !!WarpBlt methodsFor: 'primitives' priorSource: 1906929 inFile: 1!warpBits	^ self warpBitsSmoothing: cellSize sourceMap: self rgbValues! !!WarpBlt methodsFor: 'primitives'!warpBitsSmoothing: n sourceMap: sourceMap	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPt1 d picker poker pix |	<primitive: 147>	fixedPt1 _ 16384.  "1.0 in fixed-pt representation"	n > 1 ifTrue:		[(destForm depth < 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFail].		pix _ Array new: n*n].	d _ height-1 max: 1.	deltaP12 _ (p2x - p1x) @ (p2y - p1y) // d.	deltaP43 _ (p3x - p4x) @ (p3y - p4y) // d.	pA _ p1x@p1y.	pB _ p4x@p4y.	d _ width-1 max: 1.	picker _ BitBlt bitPeekerFromForm: sourceForm.	poker _ BitBlt bitPokerToForm: destForm.	destY to: destY+height-1 do:		[:y |		deltaPAB _ pB - pA // d.		sp _ pA - (deltaPAB + deltaP12 * (n-1) // (n*2)).		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[poker pixelAt: x@y put: (picker pixelAt: sp // fixedPt1)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPt1)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp _ sp + deltaPAB].		pA _ pA + deltaP12.		pB _ pB + deltaP43]! !!WarpBlt class methodsFor: 'initialization'!toForm: destinationForm	"Default cell size is 1 (no pixel smoothing)"	^ (super toForm: destinationForm) cellSize: 1! !!WarpBlt class methodsFor: 'examples' priorSource: 750214 inFile: 2!test1   "Display restoreAfter: [WarpBlt test1]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p ext |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext)]! !!WarpBlt class methodsFor: 'examples'!test12   "Display restoreAfter: [WarpBlt test12]"	"Just like test1, but comparing smooth to non-smooth warps"	| warp pts r1 p0 p ext warp2 |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display) cellSize: 2;		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	warp2 _ (self toForm: Display)		clipRect: ((0@0 extent: r1 extent*5) translateBy: 200@0);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translateBy: 200@0).		]! !!WarpBlt class methodsFor: 'examples' priorSource: 756519 inFile: 2!test3   "Display restoreAfter: [WarpBlt test3]"	"The Squeak Release Mandala - 9/23/96 di"	"Move the mouse near the center of the square.	Up and down affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box map d t |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	"Make a color map that steps through the color space"	map _ (Display depth > 8		ifTrue: ["RGB is a bit messy..."				d _ Display depth = 16 ifTrue: [5] ifFalse: [8].				(1 to: 512) collect: [:i | t _ i bitAnd: 511.					((t bitAnd: 16r7) bitShift: d-3)					+ ((t bitAnd: 16r38) bitShift: d-3*2)					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]		ifFalse: ["otherwise simple"				1 to: (1 bitShift: Display depth)])			as: Bitmap.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		colorMap: map;		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) corners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !WarpBlt removeSelector: #warpBits:!WarpBlt removeSelector: #warpBits:!'From Squeak 1.1 of September 21, 1996 on 3 October 1996 at 3:59:55 pm'!Object subclass: #BitBltSimulation	instanceVariableNames: 'destForm sourceForm halftoneForm combinationRule destX destY width height sourceX sourceY clipX clipY clipWidth clipHeight sourceBits sourceRaster sourcePixSize destBits destRaster destPixSize pixPerWord bitCount skew mask1 mask2 preload nWords hDir vDir sourceIndex sourceDelta destIndex destDelta sx sy dx dy bbW bbH srcWidth srcHeight halftoneHeight noSource noHalftone halftoneBase colorMap cmBitsPerColor srcBitIndex scanStart scanStop scanString scanRightX scanStopArray scanDisplayFlag scanXTable stopCode bitBltOop affectedL affectedR affectedT affectedB interpreterProxy '	classVariableNames: 'BBClipWidthIndex FixedPt1 BBSourceXIndex FormDepthIndex BBWarpBase BBClipHeightIndex BBRuleIndex BBSourceFormIndex BBDestFormIndex AllOnes FormBitsIndex FormWidthIndex EndOfRun BBDestYIndex FormHeightIndex BBClipYIndex BBWidthIndex BBClipXIndex BBSourceYIndex BBHalftoneFormIndex BBDestXIndex BinaryPoint BBHeightIndex CrossedX BBXTableIndex BBColorMapIndex RuleTable BBLastIndex '	poolDictionaries: ''	category: 'Squeak Interpreter'!!BitBltSimulation methodsFor: 'interpreter interface' priorSource: 14835 inFile: 2!loadBitBltFrom: bbObj	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!!"	| destBitsSize destWidth destHeight sourceBitsSize sourcePixPerWord cmSize halftoneBits |	bitBltOop _ bbObj.	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.	(interpreterProxy failed		or: [combinationRule < 0 or: [combinationRule > 26]])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.	noSource _ self ignoreSourceOrHalftone: sourceForm.	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bitBltOop.		((interpreterProxy isPointers: destForm) and: [(interpreterProxy lengthOf: destForm) >= 4])			ifFalse: [^ false].		destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.		destBitsSize _ interpreterProxy byteLengthOf: destBits.		destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.		destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.		(destWidth >= 0 and: [destHeight >= 0])			ifFalse: [^ false].		destPixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.		pixPerWord _ 32 // destPixSize.		destRaster _ destWidth + (pixPerWord-1) // pixPerWord.		((interpreterProxy isWordsOrBytes: destBits)			and: [destBitsSize = (destRaster * destHeight * 4)])			ifFalse: [^ false].		destX _ interpreterProxy fetchInteger: BBDestXIndex ofObject: bitBltOop.	destY _ interpreterProxy fetchInteger: BBDestYIndex ofObject: bitBltOop.	width _ interpreterProxy fetchInteger: BBWidthIndex ofObject: bitBltOop.	height _ interpreterProxy fetchInteger: BBHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	noSource ifTrue:		[sourceX _ sourceY _ 0]		ifFalse: 		[((interpreterProxy isPointers: sourceForm) and: [(interpreterProxy lengthOf: sourceForm) >= 4])			ifFalse: [^ false].		sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.		sourceBitsSize _ interpreterProxy byteLengthOf: sourceBits.		srcWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: sourceForm.		srcHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: sourceForm.		(srcWidth >= 0 and: [srcHeight >= 0])			ifFalse: [^ false].		sourcePixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.		sourcePixPerWord _ 32 // sourcePixSize.		sourceRaster _ srcWidth + (sourcePixPerWord-1) // sourcePixPerWord.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourceRaster * srcHeight * 4)])			ifFalse: [^ false].		colorMap _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.		"ColorMap, if not nil, must be longWords, and 		2^N long, where N = sourcePixSize for 1, 2, 4, 8 bits, 		or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits."		colorMap = interpreterProxy nilObject ifFalse:			[(interpreterProxy isWords: colorMap)			ifTrue:			[cmSize _ interpreterProxy lengthOf: colorMap.			cmBitsPerColor _ 0.			cmSize = 512 ifTrue: [cmBitsPerColor _ 3].			cmSize = 4096 ifTrue: [cmBitsPerColor _ 4].			cmSize = 32768 ifTrue: [cmBitsPerColor _ 5].			interpreterProxy primIndex ~= 147 ifTrue:				["WarpBlt has different checks on the color map"				sourcePixSize <= 8				ifTrue: [cmSize = (1 << sourcePixSize) ifFalse: [^ false] ]				ifFalse: [cmBitsPerColor = 0 ifTrue: [^ false] ]]			]			ifFalse: [^ false]].		sourceX _ interpreterProxy fetchInteger: BBSourceXIndex ofObject: bitBltOop.		sourceY _ interpreterProxy fetchInteger: BBSourceYIndex ofObject: bitBltOop].	noHalftone ifFalse: 		[((interpreterProxy isPointers: halftoneForm) and: [(interpreterProxy lengthOf: halftoneForm) >= 4])		ifTrue:		["Old-style 32xN monochrome halftone Forms"		halftoneBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: halftoneForm.		halftoneHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: halftoneForm.		(interpreterProxy isWords: halftoneBits)			ifFalse: [noHalftone _ true]]		ifFalse:		["New spec accepts, basically, a word array"		((interpreterProxy isPointers: halftoneForm) not			and: [interpreterProxy isWords: halftoneForm])			ifFalse: [^ false].		halftoneBits _ halftoneForm.		halftoneHeight _ interpreterProxy lengthOf: halftoneBits].	halftoneBase _ halftoneBits + 4].	clipX _ interpreterProxy fetchInteger: BBClipXIndex ofObject: bitBltOop.	clipY _ interpreterProxy fetchInteger: BBClipYIndex ofObject: bitBltOop.	clipWidth _ interpreterProxy fetchInteger: BBClipWidthIndex ofObject: bitBltOop.	clipHeight _ interpreterProxy fetchInteger: BBClipHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].	^ true! !!BitBltSimulation methodsFor: 'setup' priorSource: 28842 inFile: 2!warpBits	| ns |	ns _ noSource.  noSource _ true.		self clipRange.  "noSource suppresses sourceRect clipping"		noSource _ ns.	(noSource or: [bbW <= 0 or: [bbH <= 0]]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil]. 	self destMaskAndPointerInit.	self warpLoop. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW.				affectedR _ dx].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH.				affectedB _ dy]! !!BitBltSimulation methodsFor: 'inner loop' priorSource: 37702 inFile: 2!warpLoop	| skewWord halftoneWord mergeWord i word destMask startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy	  xDelta yDelta pBx pBy d smoothingCount sourceMapOop |	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation." 	(interpreterProxy fetchWordLengthOf: bitBltOop) >= (BBWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	d _ height-1.  d<=0 ifTrue: [d _ 1].	pAx _ interpreterProxy fetchInteger: BBWarpBase ofObject: bitBltOop.	pAy _ interpreterProxy fetchInteger: BBWarpBase+1 ofObject: bitBltOop.	deltaP12x _ (interpreterProxy fetchInteger: BBWarpBase+3 ofObject: bitBltOop) - pAx // d.	deltaP12y _ (interpreterProxy fetchInteger: BBWarpBase+4 ofObject: bitBltOop) - pAy // d.	pBx _ interpreterProxy fetchInteger: BBWarpBase+9 ofObject: bitBltOop.	pBy _ interpreterProxy fetchInteger: BBWarpBase+10 ofObject: bitBltOop.	deltaP43x _ (interpreterProxy fetchInteger: BBWarpBase+6 ofObject: bitBltOop) - pBx // d.	deltaP43y _ (interpreterProxy fetchInteger: BBWarpBase+7 ofObject: bitBltOop) - pBy // d.	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"	interpreterProxy argCount = 2		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.				sourceMapOop _ interpreterProxy stackValue: 0.				sourceMapOop = interpreterProxy nilObject				ifTrue: [destPixSize < 16 ifTrue:					["color map is required to smooth non-RGB dest"					^ interpreterProxy primitiveFail]]				ifFalse: [(interpreterProxy fetchWordLengthOf: sourceMapOop)							< (1 << sourcePixSize) ifTrue:					["sourceMap must be long enough for sourcePixSize"					^ interpreterProxy primitiveFail]]]		ifFalse: [smoothingCount _ 1.				sourceMapOop _ interpreterProxy nilObject].	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	d _ width-1.  d<=0 ifTrue: [d _ 1]. 	1 to: bbH do: "here is the vertical loop"		[ :i |		sx _ pAx.		sy _ pAy.		xDelta _ pBx - pAx // d.		yDelta _ pBy - pAy // d. 		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self warpSourcePixels: bbW									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self warpSourcePixels: startBits									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]. 		"Here is the horizontal loop..."		1 to: nWords do: "here is the inner horizontal loop"			[ :word |			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]]				ifFalse:				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop].		].	pAx _ pAx + deltaP12x.	pAy _ pAy + deltaP12y.	pBx _ pBx + deltaP43x.	pBy _ pBy + deltaP43y.	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'pixel mapping' priorSource: 54685 inFile: 2!rgbMap: sourcePixel from: nBitsIn to: nBitsOut	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."	| mask d srcPix destPix |	(d _ nBitsOut - nBitsIn) > 0		ifTrue:			["Expand to more bits by zero-fill"			mask _ (1 << nBitsIn) - 1.  "Transfer mask"			srcPix _ sourcePixel << d.			mask _ mask << d.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix << d.			^ destPix + (srcPix bitAnd: mask)				 	+ (srcPix << d bitAnd: mask << nBitsOut)]		ifFalse:			["Compress to fewer bits by truncation"			d = 0 ifTrue: [^ sourcePixel].			d _ nBitsIn - nBitsOut.			mask _ (1 << nBitsOut) - 1.  "Transfer mask"			srcPix _ sourcePixel >> d.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix >> d.			^ destPix + (srcPix bitAnd: mask)					+ (srcPix >> d bitAnd: mask << nBitsOut)]! !!BitBltSimulation methodsFor: 'pixel mapping'!smoothPix: n atXf: xf yf: yf dxh: dxh dyh: dyh dxv: dxv dyv: dyv	pixPerWord: srcPixPerWord pixelMask: sourcePixMask	sourceMap: sourceMap	| sourcePix i j r g b x y rgb bitsPerColor d nPix |	r _ g _ b _ 0.  "Separate r, g, b components"	nPix _ n*n.	x _ xf - (dxh + dxv * (n-1) // (n*2)).	y _ yf - (dyh + dyv * (n-1) // (n*2)).	0 to: n-1 do:		[:i |		0 to: n-1 do:			[:j |			sourcePix _ (self sourcePixAtX: x + (dxh*i//n) + (dxv*j//n)  >> BinaryPoint									y: y + (dyh*i//n) + (dyv*j//n)  >> BinaryPoint									pixPerWord: srcPixPerWord)									bitAnd: sourcePixMask.			sourcePixSize < 16				ifTrue: ["Get 24-bit RGB values from sourcemap table"						rgb _ (interpreterProxy fetchWord: sourcePix ofObject: sourceMap) bitAnd: 16rFFFFFF]				ifFalse: ["Already in RGB format"						sourcePixSize = 32						ifTrue: [rgb _ sourcePix bitAnd: 16rFFFFFF]						ifFalse: ["Note could be faster"								rgb _ self rgbMap: sourcePix from: 5 to: 8]].			r _ r + ((rgb >> 16) bitAnd: 16rFF).			g _ g + ((rgb >> 8) bitAnd: 16rFF).			b _ b + (rgb bitAnd: 16rFF).			].		].	colorMap ~= interpreterProxy nilObject		ifTrue: [bitsPerColor _ cmBitsPerColor]		ifFalse: [destPixSize = 16 ifTrue: [bitsPerColor _ 5].				destPixSize = 32 ifTrue: [bitsPerColor _ 8]].	d _ 8 - bitsPerColor.	rgb _ ((r // nPix >> d) << (bitsPerColor*2))		+ ((g // nPix >> d) << bitsPerColor)		+ ((b // nPix >> d)).	colorMap ~= interpreterProxy nilObject		ifTrue: [^ interpreterProxy fetchWord: rgb ofObject: colorMap]		ifFalse: [^ rgb]! !!BitBltSimulation methodsFor: 'pixel mapping'!sourcePixAtX: x y: y pixPerWord: srcPixPerWord	| sourceWord |	sourceIndex _ (sourceBits + 4) + (y * sourceRaster + (x // srcPixPerWord) *4).	sourceWord _ interpreterProxy longAt: sourceIndex.	^ sourceWord >> ((32-sourcePixSize) - (x\\srcPixPerWord*sourcePixSize))! !!BitBltSimulation methodsFor: 'pixel mapping'!warpSourcePixels: nPix xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	smoothing: smoothingCount sourceMap: sourceMapOop	"Pick nPix pixels using these x- and y-incs, and map color if necess."	| destWord sourcePix i sourcePixMask destPixMask x y srcPixPerWord destPix |	sourcePixMask _ (1 << sourcePixSize) - 1.	srcPixPerWord _ 32 // sourcePixSize.	destPixMask _ (1 << destPixSize) - 1.	destWord _ 0.	1 to: nPix do:		[:i |		x _ sx >> BinaryPoint.		y _ sy >> BinaryPoint.		((x >= 0 and: [x < srcWidth])			and:  [y >= 0 and: [y < srcHeight]])		ifTrue:			[smoothingCount > 1			ifTrue:			[destPix _ (self smoothPix: smoothingCount atXf: sx yf: sy				dxh: xDeltah dyh: yDeltah dxv: xDeltav dyv: yDeltav				pixPerWord: srcPixPerWord pixelMask: sourcePixMask				sourceMap: sourceMapOop)					bitAnd: destPixMask]			ifFalse:			[sourcePix _ (self sourcePixAtX: x y: y pixPerWord: srcPixPerWord)						bitAnd: sourcePixMask.			colorMap = interpreterProxy nilObject				ifTrue:				[destPixSize = sourcePixSize				ifTrue:					[destPix _ sourcePix]				ifFalse:					[sourcePixSize >= 16 ifTrue:						["Map between RGB pixels"						sourcePixSize = 16							ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]							ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]					ifFalse: [destPix _ sourcePix bitAnd: destPixMask]]]			ifFalse:				[sourcePixSize >= 16 ifTrue:					["RGB pixels first get reduced to cmBitsPerColor"					sourcePixSize = 16						ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]						ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor]].				"Then look up sourcePix in colorMap"				destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask]]]		ifFalse: [destPix _ 0].		destWord _ (destWord << destPixSize) bitOr: destPix.		sx _ sx + xDeltah.		sy _ sy + yDeltah.		].	^ destWord! !!BitBltSimulation class methodsFor: 'initialization' priorSource: 57470 inFile: 2!initialize	"BitBltSimulation initialize" 	"Mask constants"	AllOnes _ 16rFFFFFFFF.	BinaryPoint _ 14.	FixedPt1 _ 1 << BinaryPoint.  "Value of 1.0 in Warp's fixed-point representation" 	"Indices into stopConditions for scanning"	EndOfRun _ 257.	CrossedX _ 258. 	"Form fields"	FormBitsIndex _ 0.	FormWidthIndex _ 1.	FormHeightIndex _ 2.	FormDepthIndex _ 3. 	"BitBlt fields"	BBDestFormIndex _ 0.	BBSourceFormIndex _ 1.	BBHalftoneFormIndex _ 2.	BBRuleIndex _ 3.	BBDestXIndex _ 4.	BBDestYIndex _ 5.	BBWidthIndex _ 6.	BBHeightIndex _ 7.	BBSourceXIndex _ 8.	BBSourceYIndex _ 9.	BBClipXIndex _ 10.	BBClipYIndex _ 11.	BBClipWidthIndex _ 12.	BBClipHeightIndex _ 13.	BBColorMapIndex _ 14.	BBWarpBase _ 15.	BBLastIndex _ 15.	BBXTableIndex _ 16.! !!CCodeGenerator methodsFor: 'inlining' priorSource: 70393 inFile: 2!doInlining	"Inline the bodies of all methods that are suitable for inlining."	"Interpreter translate: 'InterpTest.c' doInlining: true"	| progress pass |	self collectInlineList.	self doInline: #(		sourcePixAtX:y:pixPerWord:		sendSelectorToClass:		internalSendSelector:argumentCount:		stObject:at:		stObject:at:put:		sufficientSpaceToInstantiate:indexableSize:.		sufficientSpaceToAllocate:.		booleanCheat:		findNewMethodInClass:		objectAfter:		objectAfterWhileForwarding:		remapFieldsAndClassOf:		lastPointerWhileForwarding:		lastPointerOf:		initForwardBlock:mapping:to:		extraHeaderBytes:		allocate:headerSize:h1:h2:h3:fill:		allocateOrRecycleContext:		recycleContextIfPossible:		fetchClassOf:		subscript:with:		lengthOf:		subscript:with:storing:		merge:with:		rgbMap:from:to:		extendedStoreBytecode		returnToActiveContext:		fetchContextRegisters		storeContextRegisters		transfer:fromIndex:ofObject:toIndex:ofObject:	).	self doNotInline: #(		externalSendSelector:argumentCount:		returnValue:to:		rgbAdd:with:  "complex BitBlt functions"		rgbSub:with:		rgbDiff:with:		tallyIntoMap:		pixPaint:with:		pixMask:with:		alphaBlend:with:		lowestFreeAfter:		sufficientSpaceAfterGC:		instantiateClass:indexableSize:		loadScannerFrom:start:stop:string:rightX:stopArray:displayFlag:		beRootIfOld:		checkForInterrupts		activateNewMethod		commonSelectorPrimitive:		fullGC		incrementalGC		markPhase		sweepPhase		incCompBody		fwdTableInit		mapPointersInObjectsFrom:to:		remap:		incCompMove		synchronousSignal:		resume:		initializeObjectMemory:		copyLoop		copyLoopNoSource		copyLoopPixMap.		accessibleObjectAfter:		executeNewMethod:		fetchInteger:ofObject:		fetchWordLengthOf:		possibleRootStoreInto:value:	).	self flag: #jhm.	self doNotInline: Interpreter primitiveTable.	progress _ true.	pass _ 0.	[progress] whileTrue: [		"repeatedly attempt to inline methods until no further progress is made"		progress _ false.		'Inlining pass #' , (pass _ pass+1) printString , '...'			displayProgressAt: Sensor cursorPoint			from: 0 to: methods size			during: [:bar |				methods doWithIndex:					[ :m :i | bar value: i.					(m tryToInlineMethodsIn: self)						ifTrue: [ progress _ true ]]].	].	self inlineDispatchesInMethodNamed: #interpret		localizingVars: #(currentBytecode localIP localSP).	self removeMethodsReferingToGlobals: #(currentBytecode localIP localSP)		except: #interpret.! !!Interpreter methodsFor: 'message sending'!argCount	^ argumentCount! !!Interpreter methodsFor: 'primitive support'!primIndex	^ primitiveIndex! !!Interpreter methodsFor: 'I/O primitives' priorSource: 240551 inFile: 2!primitiveWarpBits	"Invoke the warpBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackValue: self argCount.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self warpBits.		self targetForm = (self splObj: TheDisplay) ifTrue: [self showDisplayBits].	].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveTimesTwoPower	"Use Smalltalk's native function (tho could just fail)"	| rcvr arg |	arg _ self popInteger.	rcvr _ self popFloat.	successFlag		ifTrue: [ self pushFloat: (rcvr timesTwoPower: arg) ]		ifFalse: [ self unPop: 2 ].! !BitBltSimulation removeSelector: #warpSourcePixels:xDelta:yDelta:!BitBltSimulation removeSelector: #warpSourcePixels:xDelta:yDelta:!BitBltSimulation initialize!'From Squeak 1.1 of September 21, 1996 on 9 October 1996 at 11:00:34 pm'!!Scanner methodsFor: 'multi-character scans'!xColon		"Allow := for assignment by converting to #_ "	aheadChar = $= ifTrue:		[self step.		tokenType _ #leftArrow.		self step.		^ token _ #_].	"Otherwise, just do what normal scan of colon would do"	tokenType _ #colon.	^ token _ self step asSymbol! !!Scanner methodsFor: 'multi-character scans' priorSource: 1525269 inFile: 1!xLetter	"Form a word or keyword."	| type |	buffer reset.	[(type _ typeTable at: hereChar asciiValue) == #xLetter or: [type == #xDigit]]		whileTrue:			["open code step for speed"			buffer nextPut: hereChar.			hereChar _ aheadChar.			source atEnd				ifTrue: [aheadChar _ 30 asCharacter "doit"]				ifFalse: [aheadChar _ source next]].	(type == #colon or: [type = #xColon and: [aheadChar ~= $=]])		ifTrue: 			[buffer nextPut: self step.			tokenType _ #keyword]		ifFalse: 			[tokenType _ #word].	token _ buffer contents! !!Scanner class methodsFor: 'class initialization' priorSource: 1527225 inFile: 1!initialize	| newTable |	newTable _ Array new: 256 withAll: #xBinary. "default"	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"	newTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.	newTable atAll: ($A asciiValue to: $Z asciiValue) put: #xLetter.	newTable atAll: ($a asciiValue to: $z asciiValue) put: #xLetter.	newTable at: 30 put: #doIt.	newTable at: $" asciiValue put: #xDoubleQuote.	newTable at: $# asciiValue put: #xLitQuote.	newTable at: $$ asciiValue put: #xDollar.	newTable at: $' asciiValue put: #xSingleQuote.	newTable at: $: asciiValue put: #xColon.	newTable at: $( asciiValue put: #leftParenthesis.	newTable at: $) asciiValue put: #rightParenthesis.	newTable at: $. asciiValue put: #period.	newTable at: $; asciiValue put: #semicolon.	newTable at: $[ asciiValue put: #leftBracket.	newTable at: $] asciiValue put: #rightBracket.	newTable at: ${ asciiValue put: #leftBrace.	newTable at: $} asciiValue put: #rightBrace.	newTable at: $^ asciiValue put: #upArrow.	newTable at: $_ asciiValue put: #leftArrow.	newTable at: $| asciiValue put: #verticalBar.	TypeTable _ newTable "bon voyage!!"	"Scanner initialize"! !!Scanner class methodsFor: 'testing' priorSource: 1528526 inFile: 1!isLiteralSymbol: aSymbol 	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type |	i _ aSymbol size.	i = 0 ifTrue: [^false].	ascii _ (aSymbol at: 1) asciiValue.	"TypeTable should have been origined at 0 rather than 1 ..."	ascii = 0 ifTrue: [^false].	type _ TypeTable at: ascii.	(type == #xColon or: [type == #verticalBar])		ifTrue: [^i = 1].	type == #xBinary		ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^false].					(TypeTable at: ascii) == #xBinary ifFalse: [^false].					i _ i - 1].			^true].	type == #xLetter		ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^false].					type _ TypeTable at: ascii.					(type == #xLetter or: [type == #xDigit or: [type == #colon]])						ifFalse: [^false].					i _ i - 1].			^true].	^false! !Scanner initialize!'From Squeak 1.1 of September 21, 1996 on 9 October 1996 at 11:12:20 pm'!Form class instanceVariableNames: ''!!Metaclass methodsFor: 'fileIn/Out' priorSource: 1136994 inFile: 1!definition 	"Refer to the comment in ClassDescription|definition."	| aStream names |	aStream _ WriteStream on: (String new: 300).	self printOn: aStream.	names _ self instVarNames.	names isEmpty ifTrue: [^  aStream contents].	aStream nextPutAll: '	instanceVariableNames: '''.	1 to: names size do: [:i | aStream nextPutAll: (names at: i); space].	aStream nextPut: $'.	^ aStream contents! !'From Squeak 1.1 of September 21, 1996 on 13 October 1996 at 11:09:32 am'!Number variableWordSubclass: #Float	instanceVariableNames: ''	classVariableNames: 'ExpPCoefficients TanCoefficients SinCoefficients LnCoefficients ExpQCoefficients Epsilon E Sqrt2 MaxVal Pi Ln2 Halfpi Fourthpi RadiansPerDegree Twopi MaxValLn MinVal '	poolDictionaries: ''	category: 'Numeric-Numbers'!!Float methodsFor: 'arithmetic' priorSource: 781866 inFile: 1!abs	"This is faster than using Number abs."	self < 0.0		ifTrue: [^ 0.0 - self]		ifFalse: [^ self]! !!Float methodsFor: 'mathematical functions' priorSource: 782314 inFile: 1!arcTan	"Answer the angle in radians."	| theta term y eps i |	self = 1.0 ifTrue: [^Fourthpi].	self = -1.0 ifTrue: [^Fourthpi negated].	self * self > 1.0		ifTrue: 			[theta _ Halfpi.			y _ -1.0 / (self * self).			term _ -1.0 / self abs]		ifFalse: 			[theta _ 0.0.			y _ 0.0 - (self * self).			term _ self abs].	i _ 1.	eps _ Pi * Epsilon.	eps _ eps * eps.	[(term * term) > eps] whileTrue: [		theta _ theta + term.		term _ term * y * i / (i + 2) asFloat.		i _ i + 2.0		].	^self sign asFloat * theta! !!Float methodsFor: 'mathematical functions' priorSource: 783107 inFile: 1!exp	"Taylor series"	|  base correction fract div delta |	"check the special cases"	self < 0.0 ifTrue: [ ^ (self negated exp) reciprocal ].	self = 0.0 ifTrue: [ ^ 1 ].	self abs > MaxValLn ifTrue: [self error: 'exp overflow'].	"get first approximation by raising e to integer power."	base _ E raisedToInteger: (self truncated).	"sometimes, that's good enough."	self = (self truncated) ifTrue: [ ^ base ].	"now compute the correction with a short Taylor series."	"fract will be 0..1, so correction will be 1..E"	"in the worst case, convergance time is logarithmic with 1/Epsilon"	fract _ self fractionPart.	correction _ 1.0 + fract.	delta _ fract * fract / 2.0.	div _ 2.0.	[ delta > Epsilon ] whileTrue: [		correction _ correction + delta.		div _ div + 1.0.		delta _ delta * fract / div		].	correction _ correction + delta.	^ (base * correction)! !!Float methodsFor: 'mathematical functions' priorSource: 783918 inFile: 1!ln	| expt n mant x pow div sum delta eps |	self <= 0.0		ifTrue: [self error: 'ln not valid for ' , self printString]		ifFalse:  [			"get rough est. from binary exponent."			expt _ self exponent.			n _ Ln2 * expt.			mant _ self timesTwoPower: 0 - expt.			"get fine correction from mantinssa in taylor series."			"mant is in the range 0..2"			x _ mant - 1.0.			div _ 1.0.			sum _ delta _ pow _ x.			x _ x negated.			eps _ Epsilon * (n abs + 1.0).			"we unroll the loop to avoid use of abs"			[delta > eps] whileTrue: [				"pass one: delta is pos."				div _ div + 1.0.				pow _ pow * x.				delta _ pow / div.				sum _ sum + delta.				"pass two: delta is neg."				div _ div + 1.0.				pow _ pow * x.				delta _ pow / div.				sum _ sum + delta.				].			^(n + sum)]	"2.718284 ln 1.0"! !!Float methodsFor: 'mathematical functions' priorSource: 784433 inFile: 1!sin	"Answer the sine of the receiver in radians."	"Taylor series"	| sum i delta self2 |		"normalize to 0<=self<=(Pi/2)"	self < 0.0 ifTrue: [^(0.0 - ((0.0 - self) sin))].	self > Twopi ifTrue: [^(self \\ Twopi) sin].	self > Pi ifTrue: [^(0.0 - (self - Pi) sin)].	self > Halfpi ifTrue: [^(Pi - self) sin].	sum _ delta _ self.	self2 _ 0.0 - (self * self).	i _ 2.0.	"unroll to avoid use of abs"	[delta > Epsilon] whileTrue: [		"once"		delta _ (delta * self2) / (i * (i+1.0)).		i _ i + 2.0.		sum _ sum + delta.		"twice"		delta _ (delta * self2) / (i * (i+1.0)).		i _ i + 2.0.		sum _ sum + delta		].	^sum! !!Float methodsFor: 'mathematical functions' priorSource: 784820 inFile: 1!sqrt	"Answer the square root of the receiver."	"Newton-Raphson"	| guess delta eps exp|	self <= 0.0 ifTrue: [self = 0.0			ifTrue: [^0.0]			ifFalse: [^self error: 'sqrt invalid for x < 0']].	"copy and halve the exponent for first guess"	exp _ self exponent // 2.	guess _ self timesTwoPower: (0 - exp).	"get eps value"	eps _ guess * Epsilon.	eps _ eps * eps.	delta _ (self - (guess*guess))/(guess*2.0).	[(delta * delta) > eps] whileTrue: [		guess _ guess + delta.		delta _ (self - (guess*guess))/(guess*2.0)		].	^guess! !!Float methodsFor: 'mathematical functions' priorSource: 785170 inFile: 1!tan	"Answer the ratio of the sine to cosine of the receiver in radians."	"normalize to 0<=self<=(Pi/4)"	self < 0.0 ifTrue: [^ self negated tan negated].	self > Pi ifTrue: [^ (self \\ Pi) tan].	self > Halfpi ifTrue: [^ (Pi - self) tan negated].	self > Fourthpi ifTrue: [^ 1.0 / (Halfpi - self) tan].	^ self sin / self cos! !!Float methodsFor: 'truncation and round off' priorSource: 788098 inFile: 1!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value. Essential. See Object documentation 	whatIsAPrimitive. "	<primitive: 51>	^ (self quo: 16383.0) * 16383 + (self rem: 16383.0) truncated! !!Float methodsFor: 'printing' priorSource: 790721 inFile: 1!hex  "If ya really want to know..."	| word nibble |	^ String streamContents:		[:strm |		1 to: 2 do:			[:i | word _ self at: i.			1 to: 8 do: 				[:s | nibble _ (word bitShift: -8+s*4) bitAnd: 16rF.				strm nextPut: ('0123456789ABCDEF' at: nibble+1)]]]"(-2.0 to: 2.0) collect: [:f | f hex]"! !!Float methodsFor: 'printing' priorSource: 791010 inFile: 1!printOn: aStream base: base	"Estimate significant figures and handle sign." 	| digitCount |	digitCount _ 2r1.0e52 floorLog: base asFloat.  "IEEE double -- 52 bits"	self > 0.0		ifTrue: [self absPrintOn: aStream base: base digitCount: digitCount]		ifFalse: [self = 0.0 ifTrue: [^ aStream nextPutAll: '0.0'].				aStream nextPutAll: '-'.				self negated absPrintOn: aStream base: base digitCount: digitCount]! !!Float methodsFor: 'private' priorSource: 793208 inFile: 1!timesTwoPower: anInteger 	"Primitive. Answer with the receiver mulitplied by 2.0 raised to the	power of the argument. Optional. See Object documentation whatIsAPrimitive."	<primitive: 54>	anInteger < -29 ifTrue: [ ^ self * (2.0 raisedToInteger: anInteger) ].	anInteger < 0 ifTrue: [ ^ self / (1 bitShift: (0 - anInteger) ) asFloat].	anInteger < 30 ifTrue: [^ self * (1 bitShift: anInteger) asFloat].	^ self * (2.0 raisedToInteger: anInteger)! !!Float class methodsFor: 'class initialization' priorSource: 793595 inFile: 1!initialize		"Float initialize. Float pi" 	"Constants from Computer Approximations, pp. 182-183:		Pi = 3.14159265358979323846264338327950288 		Pi/2 = 1.57079632679489661923132169163975144 		Pi/4 = 0.78539816339744830961566084581987572 		Pi*2 = 6.28318530717958647692528676655900576 		Pi/180 = 0.01745329251994329576923690768488612 		2.0 ln = 0.69314718055994530941723212145817657 		2.0 sqrt = 1.41421356237309504880168872420969808"	Pi _ 3.14159265358979323846264338327950288.	Halfpi _ Pi / 2.0.	Fourthpi _ Pi / 4.0.	Twopi _ Pi * 2.0.	RadiansPerDegree _ Pi / 180.0.	Ln2 _ 0.69314718055994530941723212145817657.	Sqrt2 _ 1.41421356237309504880168872420969808.	E _ 2.718281828459045235360287471353.	Epsilon _ 0.000000000001.  "Defines precision of mathematical functions"	MaxVal _ 1e306.	MinVal _ 1e-306.	MaxValLn _ 704.! !!Float class methodsFor: 'constants'!e	"Answer the constant, E."	^E! !!Integer class methodsFor: 'initialization' priorSource: 984668 inFile: 1!initialize  "Integer initialize"	"Table of sins values for integer degree angles"	SinArray _ (0 to: 90) collect: [:x | x asFloat degreesToRadians sin].! !Number variableWordSubclass: #Float	instanceVariableNames: ''	classVariableNames: 'Epsilon E Sqrt2 MaxVal Pi Ln2 Halfpi Fourthpi RadiansPerDegree Twopi MaxValLn MinVal '	poolDictionaries: ''	category: 'Numeric-Numbers'!Float initialize!Integer initialize!'From Squeak 1.1 of September 21, 1996 on 13 October 1996 at 11:38:38 am'!!BitBltSimulation methodsFor: 'pixel mapping' priorSource: 815068 inFile: 2!smoothPix: n atXf: xf yf: yf dxh: dxh dyh: dyh dxv: dxv dyv: dyv	pixPerWord: srcPixPerWord pixelMask: sourcePixMask	sourceMap: sourceMap	| sourcePix i j r g b x y rgb bitsPerColor d nPix |	r _ g _ b _ 0.  "Separate r, g, b components"	nPix _ n*n.	x _ xf - (dxh + dxv * (n-1) // 2).	y _ yf - (dyh + dyv * (n-1) // 2).	0 to: n-1 do:		[:i |		0 to: n-1 do:			[:j |			sourcePix _ (self sourcePixAtX: x + (dxh*i) + (dxv*j)  >> BinaryPoint									y: y + (dyh*i) + (dyv*j)  >> BinaryPoint									pixPerWord: srcPixPerWord)									bitAnd: sourcePixMask.			sourcePixSize < 16				ifTrue: ["Get 24-bit RGB values from sourcemap table"						rgb _ (interpreterProxy fetchWord: sourcePix ofObject: sourceMap) bitAnd: 16rFFFFFF]				ifFalse: ["Already in RGB format"						sourcePixSize = 32						ifTrue: [rgb _ sourcePix bitAnd: 16rFFFFFF]						ifFalse: ["Note could be faster"								rgb _ self rgbMap: sourcePix from: 5 to: 8]].			r _ r + ((rgb >> 16) bitAnd: 16rFF).			g _ g + ((rgb >> 8) bitAnd: 16rFF).			b _ b + (rgb bitAnd: 16rFF).			].		].	colorMap ~= interpreterProxy nilObject		ifTrue: [bitsPerColor _ cmBitsPerColor]		ifFalse: [destPixSize = 16 ifTrue: [bitsPerColor _ 5].				destPixSize = 32 ifTrue: [bitsPerColor _ 8]].	d _ 8 - bitsPerColor.	rgb _ ((r // nPix >> d) << (bitsPerColor*2))		+ ((g // nPix >> d) << bitsPerColor)		+ ((b // nPix >> d)).	colorMap ~= interpreterProxy nilObject		ifTrue: [^ interpreterProxy fetchWord: rgb ofObject: colorMap]		ifFalse: [^ rgb]! !!BitBltSimulation methodsFor: 'pixel mapping' priorSource: 816646 inFile: 2!sourcePixAtX: x y: y pixPerWord: srcPixPerWord	| sourceWord index |	(x < 0 or: [x >= srcWidth]) ifTrue: [^ 0].	(y < 0 or: [y >= srcHeight]) ifTrue: [^ 0].	index _ (y * sourceRaster + (x // srcPixPerWord) *4).												"4 = BaseHeaderSize"	sourceWord _ interpreterProxy longAt: sourceBits + 4 + index.	^ sourceWord >> ((32-sourcePixSize) - (x\\srcPixPerWord*sourcePixSize))! !!BitBltSimulation methodsFor: 'pixel mapping' priorSource: 816964 inFile: 2!warpSourcePixels: nPix xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	smoothing: n sourceMap: sourceMapOop	"Pick nPix pixels using these x- and y-incs, and map color if necess."	| destWord sourcePix i sourcePixMask destPixMask srcPixPerWord destPix |	sourcePixMask _ (1 << sourcePixSize) - 1.	srcPixPerWord _ 32 // sourcePixSize.	destPixMask _ (1 << destPixSize) - 1.	destWord _ 0.	1 to: nPix do:		[:i |		n > 1		ifTrue:			["Average n pixels and compute dest pixel from color map"			destPix _ (self smoothPix: n atXf: sx yf: sy				dxh: xDeltah//n dyh: yDeltah//n dxv: xDeltav//n dyv: yDeltav//n				pixPerWord: srcPixPerWord pixelMask: sourcePixMask				sourceMap: sourceMapOop)					bitAnd: destPixMask]		ifFalse:			["No smoothing -- just pick pixel and map if difft depths or color map supplied"			sourcePix _ (self sourcePixAtX: sx >> BinaryPoint									y: sy >> BinaryPoint									pixPerWord: srcPixPerWord)						bitAnd: sourcePixMask.			colorMap = interpreterProxy nilObject				ifTrue:				[destPixSize = sourcePixSize				ifTrue:					[destPix _ sourcePix]				ifFalse:					[sourcePixSize >= 16 ifTrue:						["Map between RGB pixels"						sourcePixSize = 16							ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]							ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]					ifFalse: [destPix _ sourcePix bitAnd: destPixMask]]]			ifFalse:				[sourcePixSize >= 16 ifTrue:					["RGB pixels first get reduced to cmBitsPerColor"					sourcePixSize = 16						ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]						ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor]].				"Then look up sourcePix in colorMap"				destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask]].		destWord _ (destWord << destPixSize) bitOr: destPix.		sx _ sx + xDeltah.		sy _ sy + yDeltah.		].	^ destWord! !!Interpreter methodsFor: 'array and stream primitives' priorSource: 211318 inFile: 2!primitiveStringReplace"<array> primReplaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>"	| array start stop replacement repStart arrayInstSize repInstSize fmt repi i | 	array _ self stackValue: 4.	start _ self stackIntegerValue: 3.	stop _ self stackIntegerValue: 2.	replacement _ self stackValue: 1.	repStart _ self stackIntegerValue: 0.	(self isIntegerObject: replacement) "can happen in LgInt copy"		ifTrue: [^ self primitiveFail].	arrayInstSize _ self fixedFieldsOf: array.	repInstSize _ self fixedFieldsOf: replacement.	self success: start >= 1.	self success: start <= stop.	self success: (stop + arrayInstSize <= (self lengthOf: array)).	self success: repStart >= 1.	self success: (stop - start + repStart + repInstSize <= (self lengthOf: replacement)).	fmt _ self formatOf: array.	fmt < 8  "Array formats (without byteSize bits) must be same"		ifTrue: [self success: fmt = (self formatOf: replacement)]		ifFalse: [self success: (fmt bitAnd: 16rC) = ((self formatOf: replacement) bitAnd: 16rC)].	successFlag ifFalse: [^ self primitiveFail].	repi _ repStart + repInstSize - 1.   " - 1 for 0-based access"	start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do:		[:i | 		fmt < 4 ifTrue:			["pointer type objects"			self storePointer: i ofObject: array withValue:				(self fetchPointer: repi ofObject: replacement)]		ifFalse:			[fmt < 8 ifTrue:				["long-word type objects"				self storeWord: i ofObject: array withValue:				(self fetchWord: repi ofObject: replacement)]			ifFalse: 				["byte-type objects"				self storeByte: i ofObject: array withValue:				(self fetchByte: repi ofObject: replacement)]].		repi _ repi + 1].	self pop: 4.! !'From Squeak 1.1 of September 21, 1996 on 13 October 1996 at 11:43:30 am'!!Form methodsFor: 'scaling, rotation' priorSource: 813338 inFile: 1!magnify: aRectangle by: scale 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	^ self magnify: aRectangle by: scale smoothing: 1"Dynamic test...[Sensor anyButtonPressed] whileFalse:	[(Display magnify: (Sensor cursorPoint extent: 31@41) by: 5@3) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:	[cp _ Sensor cursorPoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent) display]]"! !!Form methodsFor: 'scaling, rotation'!magnify: aRectangle by: scale smoothing: cellSize	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	| newForm |	newForm _ Form extent: (aRectangle extent * scale) truncated depth: depth.	(WarpBlt toForm: newForm)		sourceForm: self;		cellSize: cellSize;		combinationRule: 3;		copyQuad: aRectangle asQuad toRect: newForm boundingBox.	^ newForm"Dynamic test...[Sensor anyButtonPressed] whileFalse:	[(Display magnify: (Sensor cursorPoint extent: 131@81) by: 0.5 smoothing: 2) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:	[cp _ Sensor cursorPoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent smoothing: 2) display]]"! !!Form methodsFor: 'scaling, rotation' priorSource: 821658 inFile: 1!rotateBy: deg	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	^ self rotateBy: deg smoothing: 1" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5)) display].f display"! !!Form methodsFor: 'scaling, rotation' priorSource: 823321 inFile: 1!rotateBy: deg rotationCenter: aPoint	"Rotate the receiver by the indicated number of degrees.  This variant gets a rotation center, but in fact ignores the thing -- awaiting someone's doing the right thing.   8/9/96 sw	Note that rotationCenter should now be easy to include in the offset of the resulting form -- see <Point> rotateBy: angle about: center.  Could be even faster by sharing the sin, cos inside rotateBy:.  This should really be reversed so that this becomes the workhorse, and rotateBy: calls this with rotationCenter: self boundingBox center.  And while we're at it, why not include scaling?  9/19/96 di "	^ self rotateBy: deg smoothing: 1! !!Form methodsFor: 'scaling, rotation'!rotateBy: deg smoothing: cellSize	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	| side rot warp r1 pts p p0 center |	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.	rot _ Form extent: side@side depth: self depth.	center _ rot extent // 2.	"Now compute the sin and cos constants for the rotation angle." 	warp _ (WarpBlt toForm: rot)		sourceForm: self;		cellSize: cellSize;		combinationRule: Form over.	r1 _ rot boundingBox align: center with: self boundingBox center.	pts _ r1 asQuad collect:		[:pt | p _ pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5) smoothing: 2) display].f display"! !Form removeSelector: #spread:from:by:direction:!Form removeSelector: 'spread:from:by:direction:' asSymbol!'From Squeak 1.1 of September 21, 1996 on 13 October 1996 at 11:54:38 am'!!Color class methodsFor: 'class initialization'!shutDown	ColorChart _ nil! !!SystemDictionary methodsFor: 'snapshot and quit' priorSource: 1791272 inFile: 1!processShutDownList	"Call the shutDown method on each object that needs to gracefully shut itself down before a snapshot."	SoundPlayer shutDown.	Smalltalk shutDown.	Delay shutDown.	Color shutDown.	ControlManager shutDown.	DisplayScreen shutDown.! !'From Squeak 1.1 of September 21, 1996 on 13 October 1996 at 1:33:50 pm'!MouseMenuController subclass: #StandardSystemController	instanceVariableNames: 'status '	classVariableNames: 'VBorderCursor ScheduledBlueButtonMessages ScheduledBlueButtonMenu HBorderCursor '	poolDictionaries: ''	category: 'Interface-Support'!!Object methodsFor: 'user interface' priorSource: 1195726 inFile: 1!basicInspect	"Create and schedule an Inspector in which the user can examine the 	receiver's variables. This method should not be overriden."	Inspector openOn: self withEvalPane: false! !!Object methodsFor: 'user interface' priorSource: 1196633 inFile: 1!inspect	"Create and schedule an Inspector in which the user can examine the 	receiver's variables."	Inspector openOn: self withEvalPane: true! !!Object methodsFor: 'user interface' priorSource: 1196820 inFile: 1!inspectWithLabel: aLabel	Inspector openOn: self withEvalPane: true withLabel: aLabel! !!ChangeSorter methodsFor: 'creation' priorSource: 264864 inFile: 1!open  "ChangeSorter new open"	| topView |	self initialize.	topView _ StandardSystemView new.	topView model: self.	topView label: self label.	topView minimumSize: 360@360.	self openView: topView offsetBy: 0@0.	topView controller open		"Let the show begin"! !!ChangeSorter methodsFor: 'creation' priorSource: 265090 inFile: 1!openView: topView	"Create change sorter on one changeSet only.  Two of these in a DualChangeSorter."	| classView messageView codeView |	buttonView _ SwitchView new.	buttonView model: self controller: TriggerController new.	buttonView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.	buttonView selector: #whatPolarity.	buttonView controller selector: #cngSetActivity.	buttonView window: (0 @ 0 extent: 360 @ 20).	buttonView label: myChangeSet name asParagraph.	classView _ GeneralListView new.	classView controllerClass: GeneralListController.	classView model: classList.	classView window: (0 @ 0 extent: 180 @ 160).	classView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	classView controller yellowButtonMenu: ClassMenu 		yellowButtonMessages: ClassSelectors.	classList controller: classView controller.	messageView _ GeneralListView new.	messageView controllerClass: GeneralListController.	messageView model: messageList.	messageView window: (0 @ 0 extent: 180 @ 160).	messageView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	messageView controller yellowButtonMenu: MsgListMenu 		yellowButtonMessages: MsgListSelectors.	messageList controller: messageView controller.	codeView _ BrowserCodeView new.	codeView model: self.	codeView window: (0 @ 0 extent: 360 @ 180).	codeView borderWidthLeft: 2 right: 2 top: 0 bottom: 2.	topView addSubView: buttonView.	topView addSubView: classView below: buttonView.	topView addSubView: messageView toRightOf: classView.	topView addSubView: codeView below: classView."	classView 		align: classView viewport topLeft 			with: buttonView viewport bottomLeft.	messageView 		align: messageView viewport topLeft 			with: classView viewport topRight.	codeView 		align: codeView viewport topLeft 			with: classView viewport bottomLeft."! !!ChangeSorter methodsFor: 'creation'!openView: topView offsetBy: offset	"Create change sorter on one changeSet with 0@0.	Two of these in a DualChangeSorter, right one is offset by 360@0."	| classView messageView codeView |	buttonView _ SwitchView new.	buttonView model: self controller: TriggerController new.	buttonView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.	buttonView selector: #whatPolarity.	buttonView controller selector: #cngSetActivity.	buttonView window: ((0 @ 0 extent: 360 @ 20) translateBy: offset).	buttonView label: myChangeSet name asParagraph.	classView _ GeneralListView new.	classView controllerClass: GeneralListController.	classView model: classList.	classView window: (0 @ 0 extent: 180 @ 160).	classView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	classView controller yellowButtonMenu: ClassMenu 		yellowButtonMessages: ClassSelectors.	classList controller: classView controller.	messageView _ GeneralListView new.	messageView controllerClass: GeneralListController.	messageView model: messageList.	messageView window: (0 @ 0 extent: 180 @ 160).	messageView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	messageView controller yellowButtonMenu: MsgListMenu 		yellowButtonMessages: MsgListSelectors.	messageList controller: messageView controller.	codeView _ BrowserCodeView new.	codeView model: self.	codeView window: (0 @ 0 extent: 360 @ 180).	codeView borderWidthLeft: 2 right: 2 top: 0 bottom: 2.	topView addSubView: buttonView.	topView addSubView: classView below: buttonView.	topView addSubView: messageView toRightOf: classView.	topView addSubView: codeView below: classView.! !!DebuggerView class methodsFor: 'instance creation' priorSource: 608826 inFile: 1!debugger: aDebugger 	"Answer a DebuggerView whose model is aDebugger. It consists of three 	subviews, a ContextStackView (the ContextStackListView and 	ContextStackCodeView), an InspectView of aDebugger's variables, and an 	InspectView of the variables of the currently selected method context."	| topView stackListView stackCodeView rcvrVarView rcvrValView ctxtVarView ctxtValView |	aDebugger expandStack.	topView _ self new model: aDebugger.	stackListView _ ContextStackListView new model: aDebugger.		stackListView window: (0 @ 0 extent: 150 @ 50).		stackListView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.		topView addSubView: stackListView.	stackCodeView _ ContextStackCodeView new model: aDebugger.		stackCodeView controller: ContextStackCodeController new.		stackCodeView window: (0 @ 0 extent: 150 @ 75).		stackCodeView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.		topView addSubView: stackCodeView below: stackListView.	rcvrVarView _ InspectListView new model: aDebugger receiverInspector.		rcvrVarView window: (0 @ 0 extent: 25 @ 50).		rcvrVarView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.		topView addSubView: rcvrVarView below: stackCodeView.	rcvrValView _ InspectCodeView new model: aDebugger receiverInspector.		rcvrValView window: (0 @ 0 extent: 50 @ 50).		rcvrValView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.		topView addSubView: rcvrValView toRightOf: rcvrVarView.	ctxtVarView _ InspectListView new model: aDebugger contextVariablesInspector.		ctxtVarView window: (0 @ 0 extent: 25 @ 50).		ctxtVarView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.		topView addSubView: ctxtVarView toRightOf: rcvrValView.	ctxtValView _ InspectCodeView new model: aDebugger contextVariablesInspector.		ctxtValView window: (0 @ 0 extent: 50 @ 50).		ctxtValView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.		topView addSubView: ctxtValView toRightOf: ctxtVarView.	^ topView! !!Dictionary methodsFor: 'user interface' priorSource: 649081 inFile: 1!inspect	"Open a DictionaryInspector on the receiver.  N.B.: this is	an inspector without trash, since InspectorTrash doesn't do the	obvious thing right now.  Use basicInspect to get a normal	(less useful) type of inspector."	DictionaryInspector openOn: self withEvalPane: false! !!Dictionary methodsFor: 'user interface' priorSource: 107155 inFile: 2!inspectAnimationsWithLabel: aLabel	"Open a Animation Dictionary inspector on the receiver, with the given label.  6/28/96 sw"	^ DictionaryInspector openOn: self withEvalPane: false		withLabel: aLabel		valueViewClass: AnimationInspectView! !!Dictionary methodsFor: 'user interface' priorSource: 649411 inFile: 1!inspectFormsWithLabel: aLabel	"Open a Form Dictionary inspector on the receiver, with the given label.  6/28/96 sw"	^ DictionaryInspector openOn: self withEvalPane: false		withLabel: aLabel		valueViewClass: FormInspectView! !!Dictionary methodsFor: 'user interface' priorSource: 649648 inFile: 1!inspectWithLabel: aLabel	"Open a DictionaryInspector on the receiver.  N.B.: this is	an inspector without trash, since InspectorTrash doesn't do the	obvious thing right now.  Use basicInspect to get a normal	(less useful) type of inspector."	DictionaryInspector openOn: self withEvalPane: false withLabel: aLabel! !!DualChangeSorter methodsFor: 'everything' priorSource: 708543 inFile: 1!openView: topView	"Create views of dual side-by-side change sorter views""	| leftView rightView |	leftView _ View new.	leftView model: leftCngSorter.	leftView window: (0 @ 0 extent: 360 @ 360).	leftView borderWidthLeft: 0 right: 0 top: 0 bottom: 0."	leftCngSorter openView: topView offsetBy: 0@0."	rightView _ View new.	rightView model: rightCngSorter.	rightView window: (0 @ 0 extent: 360 @ 360).	rightView borderWidthLeft: 0 right: 0 top: 0 bottom: 0."	rightCngSorter openView: topView offsetBy: 360@0."	topView addSubView: leftView.	topView addSubView: rightView toRightOf: leftView."! !!Inspector methodsFor: 'accessing'!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  5/22/96 sw"	^ 250 @ 200! !!Inspector class methodsFor: 'instance creation'!openOn: anObject withEvalPane: withEval 	"Create and schedule an instance of me on the model, anInspector. "	^ self openOn: anObject withEvalPane: withEval withLabel: anObject class name! !!Inspector class methodsFor: 'instance creation'!openOn: anObject withEvalPane: withEval withLabel: label	^ self openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: InspectCodeView! !!Inspector class methodsFor: 'instance creation'!openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	| topView inspector listView valueView evalView |	inspector _ self inspect: anObject.	topView _ StandardSystemView new model: inspector.	listView _ InspectListView new model: inspector.		(inspector isMemberOf: DictionaryInspector)			ifTrue: [listView controller: DictionaryListController new].		listView window: (0 @ 0 extent: 40 @ 40).		listView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.		topView addSubView: listView.	valueView _ valueViewClass new model: inspector.		valueView window: (0 @ 0 extent: 75 @ 40).		valueView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.		topView addSubView: valueView toRightOf: listView.withEval ifTrue:	[evalView _ StringHolderView new					model: (InspectorTrash for: inspector object).		evalView window: (0 @ 0 extent: 115 @ 20).		evalView borderWidthLeft: 2 right: 2 top: 0 bottom: 2.		topView addSubView: evalView below: listView].	topView label: label.	topView minimumSize: 180 @ 120.	topView controller open! !!OrderedCollection methodsFor: 'accessing' priorSource: 1222825 inFile: 1!inspect	"Open an OrderedCollectionInspector on the receiver.	Use basicInspect to get a normal type of inspector."	OrderedCollectionInspector openOn: self withEvalPane: true! !!Rectangle methodsFor: 'rectangle functions'!bordersOn: her along: herSide 	(herSide = #right and: [self left = her right])	| (herSide = #left and: [self right = her left])		ifTrue:		[^ (self top max: her top) <= (self bottom min: her bottom)].	(herSide = #bottom and: [self top = her bottom])	| (herSide = #top and: [self bottom = her top])		ifTrue:		[^ (self left max: her left) <= (self right min: her right)].	^ false! !!Rectangle methodsFor: 'rectangle functions' priorSource: 1482876 inFile: 1!withBottom: y 	"Return a copy of me with a different bottom y"	^ origin x @ origin y corner: corner x @ y! !!Rectangle methodsFor: 'rectangle functions' priorSource: 1482984 inFile: 1!withLeft: x 	"Return a copy of me with a different left x"	^ x @ origin y corner: corner x @ corner y! !!Rectangle methodsFor: 'rectangle functions' priorSource: 1483087 inFile: 1!withRight: x 	"Return a copy of me with a different right x"	^ origin x @ origin y corner: x @ corner y! !!Rectangle methodsFor: 'rectangle functions'!withSide: side setTo: value  "return a copy with side set to value"	^ self perform: (#(withLeft: withRight: withTop: withBottom: )							at: (#(left right top bottom) indexOf: side))		with: value! !!Rectangle methodsFor: 'rectangle functions' priorSource: 1483192 inFile: 1!withTop: y 	"Return a copy of me with a different top y"	^ origin x @ y corner: corner x @ corner y! !!ScrollController methodsFor: 'control defaults' priorSource: 1545689 inFile: 1!isControlActive 	view isNil ifTrue: [^ false].	^ (view insetDisplayBox merge: scrollBar inside)		containsPoint: sensor cursorPoint! !!StandardSystemController methodsFor: 'control defaults' priorSource: 1630523 inFile: 1!controlActivity	self checkForReframe.	^ super controlActivity! !!StandardSystemController methodsFor: 'borders'!adjustPaneBorders 	| side sub newRect outerFrame |	outerFrame _ view displayBox.	side = #none.	VBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue: [sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withLeft: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				side = #right ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withRight: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]].	HBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue: [sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withTop: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				side = #bottom ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withBottom: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]]! !!StandardSystemController methodsFor: 'borders'!adjustWindowBorders 	| side |	VBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue:			[sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].				side = #right ifTrue:					[view newFrame: [:f | f withRight: sensor cursorPoint x]]]]].	HBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue:			[sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[view newFrame: [:f | f withTop: sensor cursorPoint y]].				side = #bottom ifTrue:					[view newFrame: [:f | f withBottom: sensor cursorPoint y]].		]]]! !!StandardSystemController methodsFor: 'borders'!adjustWindowCorners 	| box cornerBox p clicked |	box _ view windowBox.	clicked _ false.	#(topLeft topRight bottomRight bottomLeft)		with: #(topLeft: topRight: bottomRight: bottomLeft:)		do: [:readCorner :writeCorner |			cornerBox _ (box perform: readCorner) - (8@8) extent: 16@16.			(cornerBox containsPoint: (p _ sensor cursorPoint))				& (box containsPoint: p) not				ifTrue: 				[(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (p _ sensor cursorPoint))						& (box containsPoint: p) not						and: [(clicked _ sensor anyButtonPressed) not]]						whileTrue.				clicked ifTrue:					[view newFrame:						[:f | f copy perform: writeCorner with: sensor cursorPoint]]]]].	^ clicked! !!StandardSystemController methodsFor: 'borders' priorSource: 1636349 inFile: 1!checkForReframe	view isCollapsed ifTrue: [^ self].	self adjustWindowCorners.	self cursorOnBorder ifFalse: [^ self].	((view insetDisplayBox insetBy: 2@2) containsPoint: sensor cursorPoint)		ifFalse: [^ self adjustWindowBorders].	(view subviewWithLongestSide: [:s | ] near: sensor cursorPoint) == nil		ifFalse: [^ self adjustPaneBorders].! !!StandardSystemController methodsFor: 'borders'!cursorOnBorder 	| cp i box |	view isCollapsed ifTrue: [^ false].	cp _ sensor cursorPoint.	((view labelDisplayBox insetBy: (0@2 corner: 0@-2)) containsPoint: cp)		ifTrue: [^ false].	(i _ view subViews findFirst: [:v | v displayBox containsPoint: cp]) = 0		ifTrue: [box _ view windowBox]		ifFalse: [box _ (view subViews at: i) insetDisplayBox].	^ ((box insetBy: 3) containsPoint: cp) not		and: [(box expandBy: 4) containsPoint: cp]! !!StandardSystemController class methodsFor: 'class initialization' priorSource: 1637561 inFile: 1!initialize 	ScheduledBlueButtonMenu _ PopUpMenu labels: 'editrelabel\move\reframe\collapseprint\close' lines: #(1 5 ).	ScheduledBlueButtonMessages _ #(editView label move expand collapse macPaint close ).	VBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010010000100000		2r1010110000110000		2r1011111111111000		2r1010110000110000		2r1010010000100000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000)			offset: 0@0.	HBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1111111111111111		2r0000000000000000		2r1111111111111111		2r0000000100000000		2r0000001110000000		2r0000011111000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000011111000000		2r0000001110000000		2r0000000100000000		2r0000000000000000		2r0000000000000000		2r0000000000000000)			offset: 0@0.	"StandardSystemController initialize.	ScheduledControllers scheduledControllers		do: [:c | (c isKindOf: ScreenController)			ifFalse: [c initializeBlueButtonMenu]]"! !!SystemDictionary methodsFor: 'miscellaneous' priorSource: 681688 inFile: 2!removeHyperSqueakFromSystem	"Remove all the HyperSqueak classes and related junk from the system. 9/20/96 sw	Added a couple of removals 9/22/96 di "	| hsSupport aClass |	(hsSupport _ self hyperSqueakSupportClass) == nil		ifTrue:			[^ self inform: 'HyperSqueak is already gone!!'].	hsSupport squeakCategories do:		[:aCategoryName | SystemOrganization removeSystemCategory: aCategoryName].	#(AnimationInspectController AnimationInspectView FastDictionary) do:		[:className | (aClass _ self at: className ifAbsent: [nil]) == nil ifFalse:			[aClass removeFromSystem]].	self at: #HaloIcons put: nil.	ScreenController revertToStandardMenus.! !!View methodsFor: 'testing'!bordersOn: otherView along: herSide 	| myBox herBox |	myBox _ self displayBox.	herBox _ otherView displayBox.	(herSide = #right and: [myBox left = herBox right])	| (herSide = #left and: [myBox right = herBox left])		ifTrue:		[^ (myBox top max: herBox top) <= (myBox bottom min: herBox bottom)].	(herSide = #bottom and: [myBox top = herBox bottom])	| (herSide = #top and: [myBox bottom = herBox top])		ifTrue:		[^ (myBox left max: herBox left) <= (myBox right min: herBox right)].	^ false! !!View methodsFor: 'testing' priorSource: 1872058 inFile: 1!containsPoint: aPoint	"Answer whether aPoint is within the receiver's display box. It is sent to 	a View's subViews by View|subViewAt: in order to determine which 	subView contains the cursor point (so that, for example, control can be 	pass down to that subView's controller)."	^ self insetDisplayBox containsPoint: aPoint! !!View methodsFor: 'miscellaneous'!stretchFrame: newFrameBlock startingWith: startFrame 	"Track the outline of a newFrame as long as mouse drags it.	Maintain max and min constraints throughout the drag"	| frame newFrame click |	frame _ startFrame origin extent: ((startFrame extent min: self maximumSize)											max: self minimumSize).	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	click _ false.	[click and: [Sensor noButtonPressed]] whileFalse: 		[Processor yield.		click _ click | Sensor anyButtonPressed.		newFrame _ newFrameBlock value: frame.		newFrame extent: ((newFrame extent min: self maximumSize)											max: self minimumSize).		newFrame = frame ifFalse:			[Display border: frame width: 2 rule: Form reverse fillColor: Color gray.			Display border: newFrame width: 2 rule: Form reverse fillColor: Color gray.			frame _ newFrame]].	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	^ frame! !!StandardSystemView methodsFor: 'framing'!newDisplayBoxFor: subView adjoining: newRect along: side 	side = #left ifTrue: [^ subView displayBox withRight: newRect left].	side = #right ifTrue: [^ subView displayBox withLeft: newRect right].	side = #top ifTrue: [^ subView displayBox withBottom: newRect top].	side = #bottom ifTrue: [^ subView displayBox withTop: newRect bottom].! !!StandardSystemView methodsFor: 'framing'!reframePanesAdjoining: subView along: side to: aDisplayBox 	| newBox minDim delta newRect |	newRect _ aDisplayBox.	"First check that this won't make any pane smaller than 8 screen dots"	minDim _ ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])		collect: [:sub | self newDisplayBoxFor: sub adjoining: newRect along: side])			inject: 999 into: [:minDim :rect | (minDim min: rect width) min: rect height].	"If so, amend newRect as required"	minDim < 8 ifTrue:		[delta _ minDim - 8.		newRect _ newRect withSide: side setTo: 				((newRect perform: side) > (subView displayBox perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	subViews do:		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:			[newBox _ self newDisplayBoxFor: sub adjoining: newRect along: side.			sub window: sub window viewport:				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].	"And adjust the growing pane itself"	subView window: subView window viewport:			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.	"Finally force a recomposition of the whole window"	self window: self window viewport: self viewport.	self uncacheBits; displayEmphasized! !!StandardSystemView methodsFor: 'private'!subviewWithLongestSide: sideBlock near: aPoint 	| region subs max rect side len theSub theSide |	region _ aPoint - (4@4) corner: aPoint + (4@4).	subs _ subViews select: [:sub | sub insetDisplayBox intersects: region].	subs isEmpty ifTrue: [sideBlock value: #none.  ^ nil].	max _ 0.	subs do:		[:sub | rect _ sub insetDisplayBox.		side _ rect sideNearestTo: aPoint.		len _ (side = #left) | (side = #right)			ifTrue: [rect height]			ifFalse: [rect width].		len > max ifTrue: [max _ len.  theSub _ sub.  theSide _ side]].	sideBlock value: theSide.	^ theSub! !DebuggerView class removeSelector: #proceedValueLeftSize!DebuggerView class removeSelector: #proceedValueLeftSize!DebuggerView class removeSelector: #buildContextStackView:!DebuggerView class removeSelector: 'buildContextStackView:' asSymbol!DebuggerView class removeSelector: #contextStackLeftSize!DebuggerView class removeSelector: #contextStackLeftSize!DebuggerView class removeSelector: #contextVariablesRightSize!DebuggerView class removeSelector: #contextVariablesRightSize!DebuggerView class removeSelector: #buildContextVariablesView:!DebuggerView class removeSelector: 'buildContextVariablesView:' asSymbol!DebuggerView class removeSelector: #contextVariablesLeftSize!DebuggerView class removeSelector: #contextVariablesLeftSize!DebuggerView class removeSelector: #proceedValueRightSize!DebuggerView class removeSelector: #proceedValueRightSize!DebuggerView class removeSelector: #contextStackRightSize!DebuggerView class removeSelector: #contextStackRightSize!DebuggerView class removeSelector: #receiverVariablesLeftSize!DebuggerView class removeSelector: #receiverVariablesLeftSize!DebuggerView class removeSelector: #receiverVariablesRightSize!DebuggerView class removeSelector: #receiverVariablesRightSize!DebuggerView class removeSelector: #buildReceiverVariablesView:!DebuggerView class removeSelector: 'buildReceiverVariablesView:' asSymbol!StandardSystemController initialize!'From Squeak 1.1 of September 21, 1996 on 14 October 1996 at 10:31:41 pm'!!SystemCategoryListController methodsFor: 'menu messages' priorSource: 1754338 inFile: 1!findClass	"modified 4/29/96 sw so that if only 1 class matches the user-supplied string, or if the user-supplied string exactly matches a class name, then the pop-up menu is bypassed"	| pattern foundClass classNames index reply |	self controlTerminate.	model okToChange ifFalse: [^ self classNotFound].	reply _ FillInTheBlank request: 'Class Name?'.	reply isEmpty ifTrue: [^ self classNotFound].	pattern _ reply asLowercase.	classNames _ Smalltalk classNames asArray					select: [:n | pattern match: n].	classNames isEmpty ifTrue: [^ self classNotFound].	index _ classNames size == 1		ifTrue:	[1]		ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].	index = 0 ifTrue: [^ self classNotFound].	foundClass _ Smalltalk at: (classNames at: index). 	model systemCategoryListIndex: (model systemCategoryList indexOf: foundClass category).	model classListIndex: (model classList indexOf: foundClass name). 	self controlInitialize! !'From Squeak 1.1 of September 21, 1996 on 15 October 1996 at 3:32:18 pm'!!StrikeFont methodsFor: 'file in/out'!displayChar: ascii form: charForm	"Convenience utility used during conversion of BitFont files"	| m bigForm |	Display fillBlack: (0@0 extent: 20@14).	ascii printString displayAt: 0@2.	charForm width > 0 ifTrue:		[m _ 5.		bigForm _ charForm magnify: charForm boundingBox by: m@m.		Display border: ((bigForm boundingBox expandBy: m) translateBy: 50@2) width: m.		bigForm displayAt: 50@2.		Display fillBlack: ((50@2)+((m*charForm width)@0) extent: 1@(m*self height))].! !!StrikeFont methodsFor: 'file in/out' priorSource: 1664840 inFile: 1!newFromStrike: fileName	"Build an instance from the strike font file name. The '.strike' extension	is optional."	| strike startName raster16 |	name _ fileName copyUpTo: $..	"assumes extension (if any) is '.strike'".	strike _ FileStream oldFileNamed: name, '.strike.'.	strike binary.	strike readOnly.		"strip off direcory name if any"	startName _ name size.	[startName > 0 and: [((name at: startName) ~= $>) & ((name at: startName) ~= $])]]		whileTrue: [startName _ startName - 1].	name _ name copyFrom: startName+1 to: name size.	type			_		strike nextWord16.		"type is ignored now -- simplest												assumed.  Kept here to make												writing and consistency more												straightforward."	minAscii		_		strike nextWord16.	maxAscii		_		strike nextWord16.	maxWidth		_		strike nextWord16.	strikeLength	_		strike nextWord16.	ascent			_		strike nextWord16.	descent			_		strike nextWord16.	"xOffset			_"		strike nextWord16. 		raster16			_		strike nextWord16.		superscript		_		ascent - descent // 3.		subscript		_		descent - ascent // 3.		emphasis		_		0.	glyphs			_	Form extent: (raster16 * 16) @ (self height)  							offset: 0@0.		glyphs bits fromByteStream: strike.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: strike nextWord16].	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	strike close.	"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	1 to: (minAscii - 1) do:		[:index | stopConditions at: index put: #characterNotInFont].	(maxAscii + 3) to: stopConditions size do:		[:index | stopConditions at: index put: #characterNotInFont]! !!StrikeFont methodsFor: 'file in/out'!readFromBitFont: fileName	"This builds a StrikeFont instance by reading the data file format	produced by BitFont, a widely available font conversion utility	written by Peter DiCamillo at Brown University"	"StrikeFont new readFromBitFont: 'Palatino10.BF' "	| f fLength lastAscii charLine width ascii charForm line missingForm tempGlyphs s nn iRect ptSize |	f _ FileStream readOnlyFileNamed: fileName.	name _ self restOfLine: 'Font name = ' from: f.	ascent _ (self restOfLine: 'Ascent = ' from: f) asNumber.	descent _ (self restOfLine: 'Descent = ' from: f) asNumber.	maxWidth _ (self restOfLine: 'Maximum width = ' from: f) asNumber.	ptSize _ (self restOfLine: 'Font size = ' from: f) asNumber. "Ignored for now"	minAscii _ 999.	maxAscii _ 0.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ 0.	type _ 0.  "ignored for now"	tempGlyphs _ Form extent: (maxWidth*257) @ self height.	xTable _ (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	self restOfLine: 'Extent information for entire font' from: f.	"Parse the foloowing line (including mispelling!!)"	"Image rectange: left = -2, right = 8, bottom = -2, top = 7"	s _ ReadStream on: (self restOfLine: 'Image rect' from: f).	s upTo: $:.	nn _ (1 to: 4) collect:		[:i | s upTo: $=; skipSeparators. Number readFrom: (s upTo: $,)].	iRect _ Rectangle left: (nn at: 1) right: (nn at: 2)				top: (nn at: 3) bottom: (nn at: 4).		"Read character forms and blt into tempGlyphs"	lastAscii _ -1.	[charLine _ self restOfLine: 'Character: ' from: f.	charLine == nil ifFalse:		[width_ (self restOfLine: 'Width (final pen position) = ' from: f) asNumber.		charLine = 'Missing character' ifTrue: [ascii _ 256].		('x''*' match: charLine) ifTrue:			[ascii _ Number readFrom: (charLine copyFrom: 3 to: 4) base: 16].		charForm _ Form extent: width@self height.		('*[all blank]' match: charLine) ifFalse:			[self restOfLine: '  +' from: f.			1 to: self height do:				[:y | line _ f upTo: Character cr.				4 to: line size+iRect left-1 do:					[:x | (line at: x-iRect left)=$* ifTrue: [charForm pixelValueAt: (x-4)@(y-1) put: 1]]]]].	charLine == nil]		whileFalse:			[self displayChar: ascii form: charForm.			ascii = 256				ifTrue: [missingForm _ charForm deepCopy]				ifFalse:				[minAscii _ minAscii min: ascii.				maxAscii _ maxAscii max: ascii.				lastAscii+1 to: ascii-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].				tempGlyphs copy: ((xTable at: ascii+1)@0										extent: charForm extent)							from: 0@0 in: charForm rule: Form over.				xTable at: ascii+2 put: (xTable at: ascii+1) + width.				lastAscii _ ascii]].	f close.	lastAscii+1 to: maxAscii+1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs _ Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable _ xTable copyFrom: 1 to: maxAscii+3.	"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	1 to: (minAscii - 1) do:		[:index | stopConditions at: index put: #characterNotInFont].	(maxAscii + 3) to: stopConditions size do:		[:index | stopConditions at: index put: #characterNotInFont]! !!StrikeFont methodsFor: 'file in/out'!readFromStrike2: fileName  "StrikeFont new readFromStrike2: 'Palatino14.sf2'"	"Build an instance from the strike font stored in strike2 format.	fileName is of the form: <optional path ending non-alpha><family name><pointSize>.strike2"	| file i ptSize |	('*.sf2' match: fileName) ifFalse: [self halt.  "likely incompatible"].	name _ fileName copyFrom: 1 to: fileName size - 8.	(i _ name findLast: [:c | (c isAlphaNumeric | (c = $ )) not]) > 0		ifTrue: [name _ name copyFrom: i+1 to: name size].	i _ name findLast: [:c | c isDigit not].  "Drop pointSize"	name _ name copyFrom: 1 to: i.	file _ FileStream readOnlyFileNamed: fileName.	file binary.	type _ file nextInt32.  type = 2 ifFalse: [file close. self halt "not strike2 format"].	minAscii _ file nextInt32.	maxAscii _ file nextInt32.	maxWidth _ file nextInt32.	ascent _ file nextInt32.	descent _ file nextInt32.	ptSize _ file nextInt32.  "Ignored for now"	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ file nextInt32.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: file nextInt32].	glyphs _ Form new readFrom: file.	file close.	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	1 to: (minAscii - 1) do:		[:index | stopConditions at: index put: #characterNotInFont].	(maxAscii + 3) to: stopConditions size do:		[:index | stopConditions at: index put: #characterNotInFont]! !!StrikeFont methodsFor: 'file in/out'!restOfLine: leadString from: file	"Utility method to assist reading of BitFont data files"	| line |	[line _ file upTo: Character cr.	line size < leadString size or: [leadString ~= (line copyFrom: 1 to: leadString size)]]	whileTrue: [file atEnd ifTrue: [^ nil]].	^ line copyFrom: leadString size+1 to: line size! !!StrikeFont methodsFor: 'file in/out'!writeAsStrike2	"Write me onto a file in strike2 format.	fileName is of the form: <family name><pointSize>.sf2"	| file |	file _ FileStream fileNamed: name , self height printString , '.sf2'.	file binary.	file nextInt32Put: 2.	file nextInt32Put: minAscii.	file nextInt32Put: maxAscii.	file nextInt32Put: maxWidth.	file nextInt32Put: ascent.	file nextInt32Put: descent.	file nextInt32Put: self height.  "should be pointSize"	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		file nextInt32Put: emphasis.	(minAscii + 1 to: maxAscii + 3) do:		[:index | file nextInt32Put: (xTable at: index)].	glyphs writeOn: file.	file close.! !'From Squeak 1.1 of September 21, 1996 on 15 October 1996 at 10:32:09 pm'!!BitBltSimulation methodsFor: 'inner loop'!deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments.	Takes care to deal with 0...N meaning pixels 0 through N-1"	| delta |  "assume n >= 1"	delta _ x2 - x1.	delta > 0 ifTrue: [^ delta - 1 // n]  "Shrink by 1 so never hit pix N"		ifFalse: [delta = 0 ifTrue: [^ 0]			ifFalse: [^ delta + 2 // n]]  "Same for neg delta, but shrink										by 2 because start is offset by 1"! !!BitBltSimulation methodsFor: 'inner loop' priorSource: 810095 inFile: 2!warpLoop	| skewWord halftoneWord mergeWord i word destMask startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy	  xDelta yDelta pBx pBy smoothingCount sourceMapOop nSteps |	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation." 	(interpreterProxy fetchWordLengthOf: bitBltOop) >= (BBWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	pAx _ interpreterProxy fetchInteger: BBWarpBase ofObject: bitBltOop.	deltaP12x _ self deltaFrom: pAx			to: (interpreterProxy fetchInteger: BBWarpBase+3 ofObject: bitBltOop)			nSteps: nSteps.	deltaP12x < 0 ifTrue: [pAx _ pAx - 1].	pAy _ interpreterProxy fetchInteger: BBWarpBase+1 ofObject: bitBltOop.	deltaP12y _ self deltaFrom: pAy			to: (interpreterProxy fetchInteger: BBWarpBase+4 ofObject: bitBltOop)			nSteps: nSteps.	deltaP12y < 0 ifTrue: [pAy _ pAy - 1].	pBx _ interpreterProxy fetchInteger: BBWarpBase+9 ofObject: bitBltOop.	deltaP43x _ self deltaFrom: pBx			to: (interpreterProxy fetchInteger: BBWarpBase+6 ofObject: bitBltOop)			nSteps: nSteps.	deltaP43x < 0 ifTrue: [pBx _ pBx - 1].	pBy _ interpreterProxy fetchInteger: BBWarpBase+10 ofObject: bitBltOop.	deltaP43y _ self deltaFrom: pBy			to: (interpreterProxy fetchInteger: BBWarpBase+7 ofObject: bitBltOop)			nSteps: nSteps.	deltaP43y < 0 ifTrue: [pBy _ pBy - 1].	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"	interpreterProxy argCount = 2		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.				sourceMapOop _ interpreterProxy stackValue: 0.				sourceMapOop = interpreterProxy nilObject				ifTrue: [destPixSize < 16 ifTrue:					["color map is required to smooth non-RGB dest"					^ interpreterProxy primitiveFail]]				ifFalse: [(interpreterProxy fetchWordLengthOf: sourceMapOop)							< (1 << sourcePixSize) ifTrue:					["sourceMap must be long enough for sourcePixSize"					^ interpreterProxy primitiveFail]]]		ifFalse: [smoothingCount _ 1.				sourceMapOop _ interpreterProxy nilObject].	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1]. 	1 to: bbH do: "here is the vertical loop"		[ :i |		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps. 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pAx - 1].		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps. 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pAy - 1].		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self warpSourcePixels: bbW									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self warpSourcePixels: startBits									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]. 		"Here is the horizontal loop..."		1 to: nWords do: "here is the inner horizontal loop"			[ :word |			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]]				ifFalse:				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop].		].	pAx _ pAx + deltaP12x.	pAy _ pAy + deltaP12y.	pBx _ pBx + deltaP43x.	pBy _ pBy + deltaP43y.	destIndex _ destIndex + destDelta]! !!Form methodsFor: 'filling' priorSource: 794469 inFile: 2!colorAt: aPoint	"Return the Color in the pixel at coordinate aPoint.  6/20/96 tk"	^ Color 		colorFromPixelValue: 			((BitBlt bitPeekerFromForm: self) pixelAt: aPoint)		depth: depth! !!Form methodsFor: 'scaling, rotation' priorSource: 817358 inFile: 1!flipBy: direction centerAt: aPoint	"Return a copy of the receiver flipped either #vertical or #horizontal."	| newForm quad |	newForm _ Form extent: self extent depth: depth.	quad _ self boundingBox corners.	quad _ (direction = #vertical ifTrue: [#(2 1 4 3)] ifFalse: [#(4 3 2 1)])		collect: [:i | quad at: i].	(WarpBlt toForm: newForm)		sourceForm: self;		combinationRule: 3;		copyQuad: quad toRect: newForm boundingBox.	newForm offset: (self offset flipBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))			flipBy: #vertical centerAt: 0@0) display]"! !!Form methodsFor: 'scaling, rotation' priorSource: 842000 inFile: 2!magnify: aRectangle by: scale smoothing: cellSize	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	| newForm |	newForm _ Form extent: (aRectangle extent * scale) truncated depth: depth.	(WarpBlt toForm: newForm)		sourceForm: self;		cellSize: cellSize;		combinationRule: 3;		copyQuad: aRectangle corners toRect: newForm boundingBox.	^ newForm"Dynamic test...[Sensor anyButtonPressed] whileFalse:	[(Display magnify: (Sensor cursorPoint extent: 131@81) by: 0.5 smoothing: 2) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:	[cp _ Sensor cursorPoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent smoothing: 2) display]]"! !!Form methodsFor: 'scaling, rotation' priorSource: 822675 inFile: 1!rotateBy: direction centerAt: aPoint	"Return a copy of the receiver rotated either #right or #left"	| newForm warp quad |	newForm _ Form extent: height@width depth: depth.	quad _ self boundingBox corners.	quad _ (direction = #left ifTrue: [0 to: 3] ifFalse: [2 to: 5])		collect: [:i | quad atWrap: i].	(WarpBlt toForm: newForm)		sourceForm: self;		combinationRule: 3;		copyQuad: quad toRect: newForm boundingBox.	newForm offset: (self offset rotateBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: #left centerAt: 0@0) display]"! !!Form methodsFor: 'scaling, rotation' priorSource: 844068 inFile: 2!rotateBy: deg smoothing: cellSize	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	| side rot warp r1 pts p p0 center |	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.	rot _ Form extent: side@side depth: self depth.	center _ rot extent // 2.	"Now compute the sin and cos constants for the rotation angle." 	warp _ (WarpBlt toForm: rot)		sourceForm: self;		cellSize: cellSize;		combinationRule: Form over.	r1 _ rot boundingBox align: center with: self boundingBox center.	pts _ r1 corners collect:		[:pt | p _ pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5) smoothing: 2) display].f display"! !!WarpBlt methodsFor: 'primitives'!deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments.	Takes care to deal with 0...N meaning pixels 0 through N-1"	| delta |  "assume n >= 1"	delta _ x2 - x1.	delta > 0 ifTrue: [^ delta - 1 quo: n]  "Shrink by 1 so never hit pix N"		ifFalse: [delta = 0 ifTrue: [^ 0]			ifFalse: [^ delta + 2 quo: n]]  "Same for neg delta, but shrink										by 2 because start is offset by 1"! !!WarpBlt methodsFor: 'primitives'!startFrom: x1 to: x2	"Utility routine for computing Warp increments.	Takes care to deal with 0...N meaning pixels 0 through N-1"	x2 >= x1		ifTrue: [^ x1]		ifFalse: [^ x1 - 1]  "If delta is neg, then start in pix N-1"! !!WarpBlt methodsFor: 'primitives' priorSource: 797938 inFile: 2!warpBitsSmoothing: n sourceMap: sourceMap	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix |	<primitive: 147>	(width < 1) | (height < 1) ifTrue: [^ self].	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"	n > 1 ifTrue:		[(destForm depth < 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFail].		pix _ Array new: n*n].	deltaP12 _ (self deltaFrom: p1x to: p2x nSteps: (height-1 max: 1))			@ (self deltaFrom: p1y to: p2y nSteps: (height-1 max: 1)).	deltaP43 _ (self deltaFrom: p4x to: p3x nSteps: (height-1 max: 1))			@ (self deltaFrom: p4y to: p3y nSteps: (height-1 max: 1)).	pA _ (self startFrom: p1x to: p2x) @ (self startFrom: p1y to: p2y).	pB _ (self startFrom: p4x to: p3x) @ (self startFrom: p4y to: p3y).	picker _ BitBlt bitPeekerFromForm: sourceForm.	poker _ BitBlt bitPokerToForm: destForm.	destY to: destY+height-1 do:		[:y |		deltaPAB _ (self deltaFrom: pA x to: pB x nSteps: (width-1 max: 1))				@ (self deltaFrom: pA y to: pB y nSteps: (width-1 max: 1)).		sp _ (self startFrom: pA x to: pB x) @ (self startFrom: pA y to: pB y).		n > 1 ifTrue: [sp _ sp - (deltaPAB + deltaP12 * (n-1) // (n*2))].		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[Transcript cr; print: sp // fixedPtOne asPoint.				poker pixelAt: x@y						put: (picker pixelAt: sp // fixedPtOne asPoint)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPtOne asPoint)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp _ sp + deltaPAB].		pA _ pA + deltaP12.		pB _ pB + deltaP43]! !Rectangle removeSelector: #asQuad!Rectangle removeSelector: #asQuad!'From Squeak 1.1 of September 21, 1996 on 16 October 1996 at 10:44:11 am'!!Integer methodsFor: 'testing'!benchFib  "Handy send-heavy benchmark"	"(result // seconds to run) = approx calls per second"	" | r t | t _ Time millisecondsToRun: [r _ 26 benchFib].			r//t*1000 "	"138000 on a Mac 8100/100"	^ self < 2		ifTrue: [1] 		ifFalse: [(self-1) benchFib + (self-2) benchFib + 1]! !!Integer methodsFor: 'testing' priorSource: 963645 inFile: 1!benchmark  "Handy bytecode-heavy benchmark"	"(500000 // time to run) = approx bytecodes per second"	"5000000 // (Time millisecondsToRun: [10 benchmark]) * 1000"	"3059000 on a Mac 8100/100"    | size flags i prime k count iter |    size _ 8190.    1 to: self do:        [:iter |        count _ 0.        flags _ (Array new: size) atAllPut: true.        1 to: size do:            [:i | (flags at: i) ifTrue:                [prime _ i+1.                k _ i + prime.                [k <= size] whileTrue:                    [flags at: k put: false.                    k _ k + prime].                count _ count + 1]]].    ^ count! !!WarpBlt class methodsFor: 'as yet unclassified' priorSource: 801523 inFile: 2!test3   "Display restoreAfter: [WarpBlt test3]"	"The Squeak Release Mandala - 9/23/96 di"	"Move the mouse near the center of the square.	Up and down affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box map d t |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	"Make a color map that steps through the color space"	map _ (Display depth > 8		ifTrue: ["RGB is a bit messy..."				d _ Display depth = 16 ifTrue: [5] ifFalse: [8].				(1 to: 512) collect: [:i | t _ i bitAnd: 511.					((t bitAnd: 16r7) bitShift: d-3)					+ ((t bitAnd: 16r38) bitShift: d-3*2)					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]		ifFalse: ["otherwise simple"				1 to: (1 bitShift: Display depth)])			as: Bitmap.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		colorMap: map;		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) corners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !'From Squeak 1.1 of September 21, 1996 on 17 October 1996 at 9:00:42 am'!!StrikeFont methodsFor: 'character shapes'!characterForm: char pixelValueAt: pt put: val	| f |	f _ self characterFormAt: char.	f pixelAt: pt put: val.	self characterFormAt: char put: val! !!StrikeFont methodsFor: 'character shapes' priorSource: 1658579 inFile: 1!characterFormAt: character 	"Answer a Form copied out of the glyphs for the argument, character."	| ascii leftX rightX characterForm |	ascii _ character asciiValue.	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	characterForm _ Form extent: (rightX-leftX) @ self height.	characterForm copy: characterForm boundingBox		from: leftX@0 in: glyphs rule: Form over.	^ characterForm! !!StrikeFont methodsFor: 'character shapes' priorSource: 1658979 inFile: 1!characterFormAt: character put: characterForm	"Copy characterForm over the glyph for the argument, character."	| ascii leftX rightX widthDif newGlyphs |	ascii _ character asciiValue.	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	widthDif _ characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue:		["Make new glyphs with more or less space for this char"		newGlyphs _ Form extent: (glyphs width + widthDif) @ glyphs height.		newGlyphs copy: (0@0 corner: leftX@glyphs height)			from: 0@0 in: glyphs rule: Form over.		newGlyphs copy: ((rightX+widthDif)@0 corner: newGlyphs width@glyphs height)			from: rightX@0 in: glyphs rule: Form over.		glyphs _ newGlyphs.		"adjust further entries on xTable"		ascii+2 to: xTable size			do: [:i | xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 corner: rightX @ self height)		from: 0@0 in: characterForm rule: Form over"| f |  f _ TextStyle default fontAt: 1.f characterFormAt: $  put: (Form extent: (f widthOf: $ )+10@f height)"! !!StrikeFont methodsFor: 'character shapes'!widen: char by: delta	| oldForm newForm |	oldForm _ self characterFormAt: char.	newForm _ Form extent: oldForm extent + (delta@0).	oldForm displayOn: newForm.	self characterFormAt: char put: newForm! !!TextStyle methodsFor: 'fonts and font indexes'!propagateFontChanges  "TextStyle default propagateFontChanges"	"Assumes fontArray is to be in sets of 3 emphases"	| f g |	(1 to: fontArray size by: 3) do:		[:i | f _ fontArray at: i.		fontArray at: i+2 put: (f emphasized: 2 named: f name , 'i').		fontArray at: i+1 put: (f deepCopy emphasized: 0 named: f name , 'b').  "Copy the glyphs"		g _ (fontArray at: i+1) glyphs.		g copyBits: g boundingBox from: g at: (1@0)			clippingBox: g boundingBox rule: Form under fillColor: nil]! !"This file is a commented Squeak executable file.  You may read it to understand what all the associated source files are.Then, if all the other files are in the same directory as the image, you may file it in, or execute it from a window, to recreate the changes between Squeak version 1.1 and version 1.13""Fix the WarpBlt Mandala so that it works in all color depths"(FileStream readOnlyFileNamed: 'WarpBlt class-test3(b).st') fileIn."Add interwindow drag to HyperSqueak"(FileStream readOnlyFileNamed: 'InterwindowDrag.cs') fileIn."Fix a few bugs in HyperSqueak"(FileStream readOnlyFileNamed: 'AliasAppearance.cs') fileIn.(FileStream readOnlyFileNamed: 'PilotExampleFix.cs') fileIn.(FileStream readOnlyFileNamed: 'RemoveDragVestiges.cs') fileIn.(FileStream readOnlyFileNamed: 'RevealsCostumeFix.cs') fileIn."Fast enumeration of all pointers to a given object"(FileStream readOnlyFileNamed: 'FasterPointersTo.cs') fileIn.(FileStream readOnlyFileNamed: 'ObjectReferenceUI.cs') fileIn."Save space by not caching menu bits (somewhat slower)"(FileStream readOnlyFileNamed: 'NonCachingMenus.cs') fileIn."Sundry unrelated cleanups"(FileStream readOnlyFileNamed: 'JohnsCleanup1.cs') fileIn."Remove a passel of unused compiler methods"(FileStream readOnlyFileNamed: 'JohnsCleanup2.cs') fileIn."Small changes to text display"(FileStream readOnlyFileNamed: 'Emphasis fixes-tk.cs') fileIn."Add sub-sampling to WarpBlt"(FileStream readOnlyFileNamed: 'Warp2-di.cs') fileIn.(FileStream readOnlyFileNamed: 'Warp2VM-di.cs') fileIn."Support optional := assignment syntax"(FileStream readOnlyFileNamed: 'ColonEqual-di.cs') fileIn."Eliminate uses of metaclass instance variables in Squeak"(FileStream readOnlyFileNamed: 'NoClassInstVars-di.cs') fileIn."Improve precision of Float math functions"(FileStream readOnlyFileNamed: 'BetterFloats-di.cs') fileIn."Tweak WarpBlt and fix bug in primitiveStringReplace"(FileStream readOnlyFileNamed: 'VMchanges-di.cs') fileIn."Reorganize Form and add smoothing to rotation and scaling"(FileStream readOnlyFileNamed: 'FormChanges-di.cs') fileIn."Release a large cached bitmap to save space"(FileStream readOnlyFileNamed: 'ZapColorChart-di.cs') fileIn."Support drag of window and pane borders"(FileStream readOnlyFileNamed: 'PaneBorders-di.cs') fileIn."Allow patterns like *form in browser find-class command"(FileStream readOnlyFileNamed: 'FixFindAgain-di.st') fileIn."Support input of BitFont files, also StrikeFont fileOut/fileIn"(FileStream readOnlyFileNamed: 'FontIO-di.cs') fileIn."Fix WarpBlt so integral magnify and rotate are accurate"(FileStream readOnlyFileNamed: 'PreciseWarp-di.cs') fileIn."Two handy banchmarks with results for Mac 8100/100"(FileStream readOnlyFileNamed: 'benchmarks-di.cs') fileIn."Handy routines for tweaking the fonts"(FileStream readOnlyFileNamed: 'Font Tweaks-di.cs') fileIn."Tweak them:"'[]''!!' do: [:c |	(TextStyle default fontAt: 1) widen: c by: 2.	(TextStyle default fontAt: 4) widen: c by: 2]!'():;.,' do: [:c |	(TextStyle default fontAt: 1) widen: c by: 1.	(TextStyle default fontAt: 4) widen: c by: 1]!TextStyle default propagateFontChanges!PopUpMenu withAllSubclasses do:	[:menuClass | menuClass allInstancesDo: [ :m | m rescan ]]!Smalltalk removeEmptyMessageCategories!Undeclared!Object classPool at: #DependentsFields!Smalltalk reclaimDependents!Object classPool at: #DependentsFields!----SNAPSHOT----(17 October 1996 3:05:27 pm )!	Display restoreAfter: [WarpBlt test3].!3+4!!SystemDictionary methodsFor: 'sources, change log' priorSource: 681552 inFile: 2!version	"Answer the version of this release."	^ 'Squeak 1.13 of October 17, 1996'! !----QUIT----(17 October 1996 3:35:04 pm )!	Display restoreAfter: [WarpBlt test12]!	Display restoreAfter: [WarpBlt test3].!!WarpBlt class methodsFor: 'examples'!test4   "Display restoreAfter: [WarpBlt test4]"	"The Squeak Release Mandala - 9/23/96 di"	"Move the mouse near the center of the square.	Up and down affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box map d t |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		cellSize: 2;		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) corners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !Display restoreAfter: [WarpBlt test4]!----QUIT----(18 October 1996 2:02:34 pm )!	Display restoreAfter: [WarpBlt test1]!'From Squeak 1.13 of October 17, 1996 on 24 October 1996 at 5:46:15 pm'!!RealEstateAgent class methodsFor: 'as yet unclassified'!assignCollapsePointFor: aSSView	"Offer up a location along the left edge of the screen for a collapsed SSView.	Make sure it doesn't overlap any other collapsed frames.	10/24/96 di"	| grid extent allOthers y putativeFrame free |	grid _ 24.  "should be mult of 8, since manual move is gridded by 8"	extent _ aSSView labelDisplayBox extent.	allOthers _ ScheduledControllers scheduledWindowControllers				collect: [:aController | aController view collapsedFrame]				thenSelect: [:rect | rect notNil].	y _ 0.	[(y _ y + grid) < (Display height - extent y)]		whileTrue:		[putativeFrame _ 0@y extent: extent.		free _ true.		allOthers do: [:w | free _ free & (w intersects: putativeFrame) not].		free ifTrue: [^ putativeFrame topLeft]].	"If all else fails..."	^ 0 @ 0! !!RealEstateAgent class methodsFor: 'as yet unclassified' priorSource: 1470967 inFile: 1!standardPositions	"Return a list of standard window positions -- this may have one, two, or four of them, depending on the size and shape of the display screen.  5/22/96 sw"	| anArea aList  midX midY |	anArea _ Display usableArea.	midX _ ScrollBarSetback +   ((anArea width - ScrollBarSetback)  // 2).	midY _ ScreenTopSetback + ((anArea height - ScreenTopSetback) // 2).	aList _ OrderedCollection with: (ScrollBarSetback @ ScreenTopSetback).	self windowColumnsDesired > 1		ifTrue:			[aList add: (midX @ ScreenTopSetback)].	self windowRowsDesired > 1		ifTrue:			[aList add: (ScrollBarSetback @ (midY+ScreenTopSetback)).			self windowColumnsDesired > 1 ifTrue:				[aList add: (midX @ (midY+ScreenTopSetback))]].	^ aList! !!RealEstateAgent class methodsFor: 'as yet unclassified' priorSource: 1472216 inFile: 1!strictlyStaggeredInitialFrameFor: aStandardSystemView	"This method implements a staggered window placement policy that I like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible.	10/24/96 di"	| allowedArea grid initialFrame allWindows cornerSel corner delta putativeCorner free maxLevel |	maxLevel _ 3.  "This gives, eg, 4 staggerings at each corner"	allowedArea _ ScrollBarSetback @ ScreenTopSetback					corner: Display usableArea bottomRight.	grid _ allowedArea area > 50000 ifTrue: [40] ifFalse: [20].	initialFrame _ 0@0 extent: ((aStandardSystemView initialExtent								min: (allowedArea insetBy: grid * (maxLevel+1)) extent)							min: 600@400).	allWindows _ ScheduledControllers scheduledWindowControllers				collect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.			corner _ allowedArea perform: cornerSel.			delta _ (maxLevel-level*grid) @ (level*grid).			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner _ corner + delta.			free _ true.			allWindows do:				[:w |				free _ free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 squishedWithin: allowedArea]]].	"If all else fails..."	^ (ScrollBarSetback @ ScreenTopSetback extent: initialFrame extent)		squishedWithin: allowedArea! !!ScreenController methodsFor: 'menu messages'!changeWindowPolicy	Preferences setPreference: #reverseWindowStagger		toValue: (Preferences valueOfFlag: #reverseWindowStagger) not! !!ScreenController methodsFor: 'menu messages' priorSource: 1533027 inFile: 1!fastWindows	StandardSystemView cachingBits		ifTrue: [StandardSystemView dontCacheBits]		ifFalse: [StandardSystemView doCacheBits]! !!ScreenController methodsFor: 'nested menus' priorSource: 1540038 inFile: 1!windowMenu	"Answer a menu for windows-related items.  10/24/96 sw"	^ SelectionMenu labelList:		#(	'find window...'			'find changed windows...'			'collapse all windows'			'expand all windows'			'close unchanged windows') ,			(Array with: (StandardSystemView cachingBits							ifTrue: ['dont save bits (compact)']							ifFalse: ['save bits (fast)'])				with: ((Preferences valueOfFlag: #reverseWindowStagger)							ifTrue: ['tile windows']							ifFalse: ['stagger windows']))		lines: #(2 4 5)		selections: #(findWindow indicateWindowsWithUnacceptedInput collapseAll expandAll closeUnchangedWindows fastWindows changeWindowPolicy)"ScreenController new windowMenu startUp"! !!ScreenController class methodsFor: 'class initialization' priorSource: 1541409 inFile: 1!initialize	"Initialize the screen menus.  Call this method to reset everything back to nil, so that the various menu retrieval methods will duly reinitialize them.  7/24/96 sw"	"ScreenController initialize"	ChangesMenu _ HelpMenu _ TopScreenMenu _ OpenMenu _ WindowMenu _ ProjectScreenMenu _ nil.	Smalltalk hyperSqueakPresent ifTrue: [self installScottsScreenMenu]! !!StandardSystemController methodsFor: 'menu messages' priorSource: 1632744 inFile: 1!collapse	"Get the receiver's view to change to a collapsed view on the screen."	view collapseToPoint: view chooseCollapsePoint! !!StandardSystemController methodsFor: 'menu messages'!reframe	^ view reframeTo: view getFrame! !!StandardSystemController class methodsFor: 'class initialization' priorSource: 862512 inFile: 2!initialize	"Set up the menus for standard windows.  	 6/6/96 sw: added fullScreen"	self flag: #noteToDan."1.  note that I added a fullScreen command.2.  the old macPaint command appears to be broken.  We should presumably fix it or discard it.3.  the frame command seems no longer to allow you to reframe an open window, and of course its functionality has now been overtaken by the drag-corners stuff.4.  move and label and collapse and close are all redundant with title-bar controls.With the above in mind, I've for the moment removed macPaint and frame, but kept the four redundant commands to use in those cases where owing to some bug you can't see a window's title bar.  6/10/96 sw"	ScheduledBlueButtonMenu _ PopUpMenu labels: 'labelcolor...moveframefull screencollapseclose'"macPaint"	lines: #(2 6).	ScheduledBlueButtonMessages _ #(label chooseColor move reframe fullScreen collapse close "macPaint")."StandardSystemController initialize.ScheduledControllers scheduledWindowControllers		do: [:c | c initializeBlueButtonMenu]"	VBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010010000100000		2r1010110000110000		2r1011111111111000		2r1010110000110000		2r1010010000100000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000)			offset: 0@0.	HBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1111111111111111		2r0000000000000000		2r1111111111111111		2r0000000100000000		2r0000001110000000		2r0000011111000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000011111000000		2r0000001110000000		2r0000000100000000		2r0000000000000000		2r0000000000000000		2r0000000000000000)			offset: 0@0.! !!StandardSystemView methodsFor: 'framing' priorSource: 1643659 inFile: 1!chooseCollapsePoint	"Answer the point at which to place the collapsed window."	| pt labelForm beenDown offset |	labelForm _ Form fromDisplay: self labelDisplayBox.	self uncacheBits.	self erase.	beenDown _ Sensor anyButtonPressed.	self isCollapsed ifTrue:		[offset _ self labelDisplayBox topLeft - self growBoxFrame topLeft.		labelForm follow: [pt _ (Sensor cursorPoint + offset max: 0@0) truncateTo: 8]				while: [Sensor anyButtonPressed							ifTrue: [beenDown _ true]							ifFalse: [beenDown not]].		^ pt].	collapsedViewport isNil ifTrue:		[^ RealEstateAgent assignCollapsePointFor: self].	labelForm slideFrom: self labelDisplayBox origin			to: (pt _ collapsedViewport topLeft) nSteps: 10.	^ pt! !!StandardSystemView methodsFor: 'framing'!collapsedFrame	"Answer the rectangle occupied by this window when collapsed."	^ collapsedViewport  "NOTE may be nil"! !!StandardSystemView methodsFor: 'framing'!collapseToPoint: collapsePoint	self collapse.	self align: self displayBox topLeft with: collapsePoint.	collapsedViewport _ self viewport.	self displayEmphasized! !!StandardSystemView methodsFor: 'framing'!expandedFrame	"Answer the rectangle occupied by this window when expanded."	^ expandedViewport  "NOTE may be nil"! !!StandardSystemView class methodsFor: 'class initialization'!cachingBits	^ CacheBits! !ScreenController initialize!StandardSystemController initialize!ScheduledControllers scheduledWindowControllers		do: [:c | c initializeBlueButtonMenu]!'From Squeak 1.13 of October 17, 1996 on 24 October 1996 at 11:47:53 pm'!!ParagraphEditor methodsFor: 'typing/selecting keys'!crWithIndent: characterStream 	"Replace the current text selection with CR followed by as many tabs	as on the current line (+/- bracket count) -- initiated by Shift-Return."	| char s i tabCount |	sensor keyboard.		"flush character"	s _ paragraph string.	i _ stopBlock stringIndex.	tabCount _ 0.	[(i _ i-1) > 0 and: [(char _ s at: i) ~= Character cr]]		whileTrue:  "Count tabs and brackets (but not a leading bracket)"		[(char = Character tab and: [(s at: i+1) ~= $[]) ifTrue: [tabCount _ tabCount + 1].		char = $[ ifTrue: [tabCount _ tabCount + 1].		char = $] ifTrue: [tabCount _ tabCount - 1]].	characterStream crtab: tabCount.  "Now inject CR with tabCount tabs"	^ false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!forwardDelete: characterStream 	"Delete forward over the next character."	| char startIndex stopIndex |	char _ Sensor keyboard.	self closeTypeIn.	startIndex _ startBlock stringIndex.	stopIndex _ stopBlock stringIndex.	startIndex = stopIndex		ifTrue: ["Null selection - delete forward"				self selectFrom: startIndex to: startIndex.				self replaceSelectionWith: self nullText]		ifFalse: ["Just zap existing selection"				self replaceSelectionWith: self nullText].	self selectFrom: startIndex to: startIndex-1.	^true! !!ParagraphEditor class methodsFor: 'class initialization' priorSource: 1342823 inFile: 1!initialize	"Initialize the keyboard shortcut maps and the shared buffers	for copying text across views and managing again and undo.	6/18/96 sw: call initializeTextEditorMenus	other times: marked change to trigger reinit"	"ParagraphEditor initialize"	CurrentSelection _ UndoSelection _ FindText _ ChangeText _ Text new.	UndoMessage _ Message selector: #halt.	self initializeCmdKeyShortcuts.	self initializeShiftCmdKeyShortcuts.	self initializeTextEditorMenus! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' priorSource: 1344571 inFile: 1!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key shortcut table."	"ParagraphEditor initialize"	| cmdMap cmds |	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 8 + 1) put: #backspace:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"cmd-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	'0123456789'	do: [ :char | cmdMap at: (char asciiValue + 1) put: #changeEmphasis: ].	'([{''"<'		do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose: ].	cmdMap at: ($, asciiValue + 1) put: #shiftEnclose:.	cmds _ #(		$a	selectAll:		$b	browseIt:		$c	copySelection:		$d	doIt:		$e	exchange:		$f	find:		$g	findAgain:		$h	setSearchString:		$i	inspectIt:		$j	doAgainOnce:		$k  offerFontMenu:		$l	cancel:		$m	implementorsOfIt:		$n	sendersOfIt:		$o	spawnIt:		$p	printIt:		$q	querySymbol:		$r	recognizer:		$s	save:		$t	tempCommand:		$u	align:		$v	paste:		$w	backWord:		$x	cut:		$y	swapChars:		$z	undo:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).	].	CmdActions _ cmdMap.! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' priorSource: 1345676 inFile: 1!initializeShiftCmdKeyShortcuts	"Initialize the shift-command-key (or control-key) shortcut table."	| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	cmdMap at: (27 + 1) put: #shiftEnclose:.	"ctrl-["	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	cmds _ #(		$a	argAdvance:		$b	browseItHere:		$c	compareToClipboard:		$d	duplicate:		$f	displayIfFalse:		$j	doAgainMany:		$k	changeStyle:		$n	referencesToIt:		$r	indent:		$l	outdent:		$s	search:		$t	displayIfTrue:		$w	methodNamesContainingIt:		$v	pasteInitials:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1)			put: (cmds at: i + 1).		cmdMap at: (((cmds at: i) asciiValue - 96) + 1)	put: (cmds at: i + 1).	].	ShiftCmdActions _ cmdMap.! !ParagraphEditor initialize!'From Squeak 1.13 of October 17, 1996 on 25 October 1996 at 12:06:20 am'!!Float methodsFor: 'mathematical functions' priorSource: 827850 inFile: 2!arcTan        "Answer the angle in radians."        "Newton-Raphson"        | theta eps step sint cost |       self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].        "first guess"        theta _ (self * Halfpi) / (self + 1.0).        "iterate"        eps _ Halfpi * Epsilon.        step _ theta.        [ (step*step)>eps ]		whileTrue:                [sint _ theta sin.                cost _ theta cos.                step _ (sint*cost) - (self*cost*cost).                theta _ theta - step].        ^ theta! !'From Squeak 1.13 of October 17, 1996 on 25 October 1996 at 4:28:33 pm'!!StandardSystemView methodsFor: 'initialize-release' priorSource: 1639488 inFile: 1!initialize 	"Refer to the comment in View|initialize."	super initialize.	labelFrame _ Quadrangle new.	labelFrame region: (Rectangle origin: 0 @ 0 extent: 50 @ self labelHeight).	labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	self label: nil.	isLabelComplemented _ false.	minimumSize _ 50 @ 50.	maximumSize _ Display extent.	collapsedViewport _ nil.	expandedViewport _ nil.	bitsValid _ false.! !!StandardSystemView methodsFor: 'label access' priorSource: 1641397 inFile: 1!label	"Answer the string that appears in the receiver's label."	labelText isNil		ifTrue: [^ 'Untitled' copy]		ifFalse: [^ labelText asString]! !!StandardSystemView methodsFor: 'label access' priorSource: 675261 inFile: 2!label: aString 	"Set aString to be the receiver's label."	labelText _ (Text string: ((aString == nil or: [aString isEmpty])								ifTrue: ['Untitled' copy]								ifFalse: [aString])					emphasis: 5) asParagraph.	insetDisplayBox == nil ifTrue: [^ self].  "wait for further initialization"	self setLabelRegion! !!StandardSystemView methodsFor: 'label access' priorSource: 1642071 inFile: 1!labelDisplayBox	"Answer the rectangle that borders the visible parts of the receiver's label 	on the display screen."	^ labelFrame region		align: labelFrame topLeft		with: self windowOrigin! !!StandardSystemView methodsFor: 'label access'!labelFrame	^labelFrame! !!StandardSystemView methodsFor: 'label access'!labelHeight	^ 19! !!StandardSystemView methodsFor: 'label access'!labelOffset	^ 0 @ (self labelHeight-2)! !!StandardSystemView methodsFor: 'label access' priorSource: 1642344 inFile: 1!labelTextRegion	labelText == nil ifTrue: [^ self labelDisplayBox center extent: 0@0].	^ (labelText boundingBox			align: labelText boundingBox center			with: self labelDisplayBox center)		intersect: (self labelDisplayBox insetBy: 35@0)! !!StandardSystemView methodsFor: 'label access' priorSource: 1649247 inFile: 1!setLabelRegion	"Always follows view width"	| labelRect |	labelRect _ 0 @ 0 extent: self displayBox width @ self labelHeight.	labelFrame region: labelRect.	^ labelRect! !!StandardSystemView methodsFor: 'framing' priorSource: 1644356 inFile: 1!chooseFrame	"Answer a new frame, depending on whether the view is currently 	collapsed or not."	| labelForm f |	self isCollapsed & expandedViewport notNil		ifTrue:			[labelForm _ bitsValid				ifTrue: [windowBits]				ifFalse: [Form fromDisplay: self labelDisplayBox].			bitsValid _ false.			self erase.			labelForm slideFrom: self labelDisplayBox origin					to: expandedViewport origin-self labelOffset					nSteps: 10.			^ expandedViewport]		ifFalse:			[f _ self getFrame.			bitsValid _ false.			self erase.			^ f topLeft + self labelOffset extent: f extent]! !!StandardSystemView methodsFor: 'framing' priorSource: 1645479 inFile: 1!collapse	"If the receiver is not already collapsed, change its view to be that of its 	label only."	self isCollapsed ifFalse:			[expandedViewport _ self viewport.			savedSubViews _ subViews.			self resetSubViews.			labelText isNil ifTrue: [self label: nil.  bitsValid _ false.].			self window: (self inverseDisplayTransform:					((self labelDisplayBox topLeft extent: (labelText extent x + 70) @ self labelHeight)						 intersect: self labelDisplayBox)).			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2]! !!StandardSystemView methodsFor: 'framing' priorSource: 1646178 inFile: 1!expand	"If the receiver is collapsed, change its view to be that of all of its 	subviews, not its label alone. "	| newFrame |	self isCollapsed		ifTrue:			[newFrame _ self chooseFrame.			collapsedViewport _ self viewport.			subViews _ savedSubViews.			self window: self defaultWindow.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 0.			savedSubViews _ nil.			self resizeTo: newFrame.			self displayDeEmphasized]! !!StandardSystemView methodsFor: 'framing' priorSource: 1647983 inFile: 1!reframeTo: newFrame	"Reframe the receiver to the given screen rectangle.  1/26/96 sw	Repaint difference after the change.  5/8/96 di"	| oldBox newBox portRect |	self uncacheBits.	oldBox _ self windowBox.	portRect _ newFrame topLeft + self labelOffset				corner: newFrame corner.	self window: self window viewport: portRect.	self setLabelRegion.	newBox _ self windowBox.	(oldBox areasOutside: newBox) do:		[:rect | ScheduledControllers restore: rect].	self displayEmphasized! !!StandardSystemView methodsFor: 'framing' priorSource: 1648476 inFile: 1!resize	"Determine the rectangular area for the receiver, adjusted to the 	minimum and maximum sizes."	| f |	f _ self getFrame.	self resizeTo: (f topLeft + self labelOffset extent: f extent)! !!StandardSystemView methodsFor: 'framing'!windowOrigin	^ self isCollapsed		ifTrue: [self displayBox topLeft]		ifFalse: [self displayBox topLeft - self labelOffset]! !!StandardSystemView methodsFor: 'displaying' priorSource: 1650803 inFile: 1!displayDeEmphasized	"Display this view with emphasis off.	If windowBits is not nil, then simply BLT"	bitsValid		ifTrue: [self lock.				windowBits displayAt: self windowOrigin]		ifFalse: [super display.				CacheBits ifTrue: [self cacheBitsAsIs]]! !!StandardSystemView methodsFor: 'displaying' priorSource: 1651924 inFile: 1!displayLabelText	"The label goes in the center of the window"	| labelRect |	labelText foregroundColor: self foregroundColor			backgroundColor: self labelColor.	labelRect _ self labelTextRegion.	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect			rule: labelText rule fillColor: labelText fillColor! !!StandardSystemView methodsFor: 'displaying' priorSource: 1652130 inFile: 1!displayOn: aPort	bitsValid ifFalse: [^ self].	windowBits displayOnPort: aPort at: self windowOrigin! !!StandardSystemView methodsFor: 'displaying' priorSource: 1653404 inFile: 1!displayView	"Refer to the comment in View|displayView. "	self displayBox width = labelFrame width ifFalse:		["recompute label width when window changes size"		self setLabelRegion].	(labelFrame align: labelFrame topLeft with: self windowOrigin)		insideColor: self labelColor;		displayOn: Display.	self displayLabelText! !!SqueakView methodsFor: 'frame' priorSource: 656783 inFile: 2!reframeTo: newFrame	"Reframe receiver to aRectangle, adjusted to the minimum and maximum sizes.  DO NOT alter scaling.  Created in an atttempt to defeat mvc scaling upon resize; borrowed in part from work Dan did for Fabrik long ago in his 'mvc wars' effort.  5/13/96 sw	5/17/96 sw: merged in Dan's reframeTo: of 5/8/96; could not succeed in calling super.	6/10/96 sw: tell model of the change	6/15/96 sw: bug fix: avoid having window edge northward on each resize!!	6/23/96 sw: bug fix: don't have the STORED version of the window bounds edge northward"	| oldBox portRect |	self uncacheBits.	oldBox _ self windowBox.	portRect _ newFrame topLeft + self labelOffset				corner: newFrame corner.	self window: (newFrame translateBy: window topLeft - newFrame topLeft) viewport: portRect.	self setLabelRegion.	(oldBox areasOutside: self windowBox) do:		[:rect | ScheduledControllers restore: rect].	canvas _ nil.	self adjustTurtleTrailForm.	model windowBounds: portRect.	self haloView controller invalidateCachedFullArea.	self displayEmphasized! !'From Squeak 1.13 of October 17, 1996 on 25 October 1996 at 5:13:57 pm'!!BitEditor methodsFor: 'control defaults' priorSource: 102571 inFile: 1!redButtonActivity	| formPoint displayPoint |	model depth = 1 ifTrue:		["If this is just a black&white form, then set the color to be		the opposite of what it was where the mouse was clicked"		formPoint _ (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.		color _ 1-(view workingForm pixelValueAt: formPoint).		squareForm fillColor: (color=1 ifTrue: [Color black] ifFalse: [Color white])].	[sensor redButtonPressed]	  whileTrue: 		[formPoint _ (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.		displayPoint _ view displayTransform: formPoint.		squareForm 			displayOn: Display			at: displayPoint 			clippingBox: view insetDisplayBox 			rule: Form over			fillColor: nil.		view changeValueAt: formPoint put: color]! !!BitEditor class methodsFor: 'private' priorSource: 111316 inFile: 1!locateMagnifiedView: aForm scale: scaleFactor	"Answer a rectangle at the location where the scaled view of the form,	aForm, should be displayed."	^ Rectangle originFromUser: (aForm extent * scaleFactor + (0@50)).	! !!StrikeFont methodsFor: 'character shapes'!alter: char formBlock: formBlock	self characterFormAt: char 		put: (formBlock value: (self characterFormAt: char))! !!StrikeFont methodsFor: 'character shapes' priorSource: 675631 inFile: 2!edit: character		"(TextStyle default fontAt: 1) edit: $_"	"Open a Bit Editor on the given character.  Note that you must do an accept	(in the option menu of the bit editor) if you want this work.	Accepted edits will not take effect in the font until you leave or close the bit editor.	Also note that unaccepted edits will be lost when you leave or close."	| charForm smallRect editRect scaleFactor bitEditor savedForm r |	charForm _ self characterFormAt: character.	editRect _ BitEditor locateMagnifiedView: charForm	                                        scale: (scaleFactor _ 8@8).	bitEditor _ BitEditor bitEdit: charForm at: editRect topLeft			scale: scaleFactor remoteView: nil.	bitEditor controller blueButtonMenu: nil blueButtonMessages: nil.	savedForm _ Form fromDisplay: (r _ bitEditor displayBox expandBy: (0@23 corner: 0@0)).	bitEditor controller startUp.	bitEditor release.	savedForm displayOn: Display at: r topLeft.	self characterFormAt: character put: charForm! !!StrikeFont methodsFor: 'character shapes' priorSource: 895899 inFile: 2!widen: char by: delta	| newForm |	^ self alter: char formBlock:  "Make a new form, wider or narrower..."		[:charForm | newForm _ Form extent: charForm extent + (delta@0).		charForm displayOn: newForm.  "Copy this image into it"		newForm]    "and substitute it in the font"! !1 to: 4 by: 3 do:  "In both base fonts..."	[:i | '()[].:' do:  "Alter these characters..."		[:c |		(TextStyle default fontAt: i) alter: c formBlock:			[:f |   "By sliding them over 1 pixel"			f displayOn: f at: 1@0.			f fillWhite: (0@0 extent: 1@ f height)]]]!"Propagate changes to derived fonts..."TextStyle default propagateFontChanges!'From Squeak 1.13 of October 17, 1996 on 26 October 1996 at 9:43:28 am'!!StandardSystemController methodsFor: 'borders' priorSource: 860769 inFile: 2!adjustWindowCorners 	| box cornerBox p clicked |	box _ view windowBox.	clicked _ false.	#(topLeft topRight bottomRight bottomLeft)		with: #(topLeft: topRight: bottomRight: bottomLeft:)		do: [:readCorner :writeCorner |			cornerBox _ ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (p _ sensor cursorPoint))						and: [(clicked _ sensor anyButtonPressed) not]]						whileTrue.				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | f copy perform: writeCorner with: sensor cursorPoint]]]]].	^ clicked! !'From Squeak 1.13 of October 17, 1996 on 26 October 1996 at 4:28:46 pm'!!RealEstateAgent class methodsFor: 'as yet unclassified' priorSource: 903149 inFile: 2!strictlyStaggeredInitialFrameFor: aStandardSystemView	"This method implements a staggered window placement policy that I like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible.	10/24/96 di"	| allowedArea grid initialFrame allWindows cornerSel corner delta putativeCorner free maxLevel |	allowedArea _ ScrollBarSetback @ ScreenTopSetback					corner: Display usableArea bottomRight.	"Number to be staggered at each corner (less on small screens)"	maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame _ 0@0 extent: ((aStandardSystemView initialExtent							min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400).	allWindows _ ScheduledControllers scheduledWindowControllers				collect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.			corner _ allowedArea perform: cornerSel.			"The extra grid//2 in delta helps to keep title tabs distinct"			delta _ (maxLevel-level*grid+(grid//2)) @ (level*grid).			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner _ corner + delta.			free _ true.			allWindows do:				[:w |				free _ free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 squishedWithin: allowedArea]]].	"If all else fails..."	^ (ScrollBarSetback @ ScreenTopSetback extent: initialFrame extent)		squishedWithin: allowedArea! !'From Squeak 1.13 of October 17, 1996 on 26 October 1996 at 9:15:11 pm'!!StandardSystemView methodsFor: 'framing' priorSource: 918648 inFile: 2!collapse	"If the receiver is not already collapsed, change its view to be that of its 	label only."	self isCollapsed ifFalse:			[expandedViewport _ self viewport.			savedSubViews _ subViews.			self resetSubViews.			labelText isNil ifTrue: [self label: nil.  bitsValid _ false.].			self window: (self inverseDisplayTransform:					((self labelDisplayBox topLeft extent: (labelText extent x + 70) @ self labelHeight)						 intersect: self labelDisplayBox))]! !!StandardSystemView methodsFor: 'framing' priorSource: 919251 inFile: 2!expand	"If the receiver is collapsed, change its view to be that of all of its 	subviews, not its label alone. "	| newFrame |	self isCollapsed		ifTrue:			[newFrame _ self chooseFrame.			collapsedViewport _ self viewport.			subViews _ savedSubViews.			self window: self defaultWindow.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews _ nil.			self resizeTo: newFrame.			self displayDeEmphasized]! !'From Squeak 1.13 of October 17, 1996 on 27 October 1996 at 1:03:24 am'!Browser subclass: #HierarchyBrowser	instanceVariableNames: 'classList '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Browser'!!Behavior methodsFor: 'accessing class hierarchy'!allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level 	"Walk the tree of subclasses, giving the class and its level"	| subclassNames subclass |	classAndLevelBlock value: self value: level.	self == Class ifTrue:  [^ self].  "Don't visit all the metaclasses"	"Visit subclasses in alphabetical order"	subclassNames _ SortedCollection new.	self subclassesDo: [:subC | subclassNames add: subC name].	subclassNames do:		[:name | (Smalltalk at: name)			allSubclassesWithLevelDo: classAndLevelBlock			startingLevel: level+1]! !!Browser methodsFor: 'system category functions'!browseAllClasses	"Create and schedule a new browser on all classes alphabetically."	| newBrowser view |	newBrowser _ HierarchyBrowser new initAlphabeticListing.	BrowserView openBrowserView: (BrowserView systemCategoryBrowser: newBrowser editString: nil)		label: 'All Classes Alphabetically'! !!Browser methodsFor: 'class list'!selectClass: classNotMeta	self classListIndex: (self classList findFirst: [:each | each == classNotMeta name])! !!Browser methodsFor: 'class functions' priorSource: 161157 inFile: 1!hierarchy	"Create and schedule a new class hierarchy browser on the currently selected class or meta."	| newBrowser view |	classListIndex = 0 ifTrue: [^ self].	newBrowser _ HierarchyBrowser new initHierarchyForClass: self selectedClass meta: metaClassIndicated.	view _ BrowserView systemCategoryBrowser: newBrowser editString: nil.	Browser postOpenSuggestion: (Array with: self selectedClassOrMetaClass with: self selectedMessageName).	BrowserView openBrowserView: view		label: self selectedClassName , ' hierarchy'! !!Browser methodsFor: 'message functions'!methodHierarchy 	"Create and schedule a message set browser on all implementors of the 	currently selected message selector. Do nothing if no message is selected."	| sel list tab stab |	messageListIndex = 0 ifTrue: [^ self].	sel _ self selectedMessageName.	list _ OrderedCollection new.	tab _ ''.	self selectedClassOrMetaClass allSuperclasses reverseDo:		[:cl |		(cl includesSelector: sel) ifTrue:			[list addLast: tab , cl name, ' ', sel].		tab _ tab , '  '].	self selectedClassOrMetaClass allSubclassesWithLevelDo:		[:cl :level |		(cl includesSelector: sel) ifTrue:			[stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].			list addLast: tab , stab , cl name, ' ', sel]]	 	startingLevel: 0.	Smalltalk browseMessageList: list		name: 'Inheritance of ' , self selectedMessageName! !!HierarchyBrowser methodsFor: 'initialization'!classList	^ classList! !!HierarchyBrowser methodsFor: 'initialization'!classListIndex: newIndex	"Cause system organization to reflect appropriate category"	| newClassName |	newIndex ~= 0 ifTrue:		[newClassName _ (classList at: newIndex) copyWithout: $ .		systemCategoryListIndex _			systemOrganizer numberOfCategoryOfElement: newClassName.		self changed: #systemCategorySelectionChanged].	^ super classListIndex: newIndex! !!HierarchyBrowser methodsFor: 'initialization'!initAlphabeticListing	| tab stab index |	self systemOrganizer: SystemOrganization.	metaClassIndicated _ false.	classList _ Smalltalk classNames.! !!HierarchyBrowser methodsFor: 'initialization'!initHierarchyForClass: theClass meta: meta	| tab stab index |	self systemOrganizer: SystemOrganization.	metaClassIndicated _ meta.	classList _ OrderedCollection new.	tab _ ''.	theClass allSuperclasses reverseDo: 		[:aClass | 		classList add: tab , aClass name.		tab _ tab , '  '].	index _ classList size + 1.	theClass allSubclassesWithLevelDo:		[:aClass :level |		stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].		classList add: tab , stab , aClass name]	 	startingLevel: 0.	self classListIndex: index! !!HierarchyBrowser methodsFor: 'initialization'!selectClass: classNotMeta	| name |	name _ classNotMeta name.	self classListIndex: (self classList findFirst:			[:each | (each endsWith: name)					and: [each size = name size							or: [(each at: each size - name size) isSeparator]]])! !!HierarchyBrowser methodsFor: 'initialization'!selectedClassName	^ (super selectedClassName copyWithout: $ ) asSymbol! !!MessageListController methodsFor: 'menu messages'!methodHierarchy	"Create and schedule a message browser on the hierarchical implementors."	self controlTerminate.	model methodHierarchy.	self controlInitialize! !!MessageListController methodsFor: 'menu messages' priorSource: 1080102 inFile: 1!shiftedYellowButtonMenu	"Answer the menu to be put up when shift key is down.  1/26/96 sw"	^ PopUpMenu labels: 'browse fullbrowse inheritancebrowse methodimplementors of sent messagesinspect instancesinspect subinstancesremove from browsermore...' lines: #(4 6)! !!MessageListController methodsFor: 'menu messages' priorSource: 1080357 inFile: 1!shiftedYellowButtonMessages	"Answer the messages corresponding to the shifted-yellow-button menu, to be put up when shift key is down.  1/26/96 sw.  Adjustments, 2/5/96 sw"	^ #(browseFull methodHierarchy browse allImplementorsOf inspectInstances inspectSubInstances removeMessageFromBrowser unshiftedYellowButtonActivity)! !!MessageListView methodsFor: 'updating' priorSource: 1082489 inFile: 1!displayView 	"Refer to the comment in View|displayView."	| aClass sel index baseClass |	Browser postOpenSuggestion == nil ifFalse: [		"Set the class and message"		aClass _ Browser postOpenSuggestion first.		sel _ Browser postOpenSuggestion last.		Browser postOpenSuggestion: nil.		baseClass _ aClass theNonMetaClass.		index _ SystemOrganization numberOfCategoryOfElement: baseClass name.		model metaClassIndicated: aClass isMeta.		model systemCategoryListIndex: index.		model metaClassIndicated: aClass isMeta.		model selectClass: baseClass.		sel notNil ifTrue: [			index _ aClass organization numberOfCategoryOfElement: sel.			model messageCategoryListIndex: index.			model messageListIndex: 				((aClass organization listAtCategoryNumber: index) indexOf: sel)			].		^ self topView deEmphasize.   "a redisplay has already been done"		].	super displayView.! !!SystemCategoryListController methodsFor: 'menu messages'!browseAllClasses	"Create and schedule a browser on all classes alphabetically."	self controlTerminate.	model browseAllClasses.	self controlInitialize! !!SystemCategoryListController methodsFor: 'menu messages' priorSource: 870327 inFile: 2!findClass	"modified 4/29/96 sw so that if only 1 class matches the user-supplied string, or if the user-supplied string exactly matches a class name, then the pop-up menu is bypassed"	| pattern foundClass classNames index reply |	self controlTerminate.	model okToChange ifFalse: [^ self classNotFound].	reply _ FillInTheBlank request: 'Class Name?'.	reply isEmpty ifTrue: [^ self classNotFound].	pattern _ reply asLowercase.	classNames _ Smalltalk classNames asArray					select: [:n | pattern match: n].	classNames isEmpty ifTrue: [^ self classNotFound].	index _ classNames size == 1		ifTrue:	[1]		ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].	index = 0 ifTrue: [^ self classNotFound].	foundClass _ Smalltalk at: (classNames at: index). 	model systemCategoryListIndex: (model systemCategoryList indexOf: foundClass category).	model selectClass: foundClass. 	self controlInitialize! !!SystemCategoryListController class methodsFor: 'class initialization' priorSource: 1756668 inFile: 1!initialize	"SystemCategoryListController initialize"	SystemCategoryListYellowButtonMenu _ 		PopUpMenu 			labels:'find class...browse allbrowseprintOutfileOutreorganizeupdateadd item...rename...remove' 			lines: #(3 5 7).	SystemCategoryListYellowButtonMessages _		#(findClass browseAllClasses browse		printOut fileOut		edit update		add rename remove )	"	SystemCategoryListController initialize.	SystemCategoryListController allInstancesDo:		[:x | x initializeYellowButtonMenu]	"! !SystemCategoryListController initialize!SystemCategoryListController allInstancesDo:		[:x | x initializeYellowButtonMenu]!'From Squeak 1.13 of October 17, 1996 on 28 October 1996 at 12:46:22 pm'!CharacterScanner subclass: #DisplayScanner	instanceVariableNames: 'lineY runX emphasis foregroundColor '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!Object subclass: #TextAttribute	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!TextAttribute subclass: #TextAction	instanceVariableNames: 'evalString '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!TextAttribute subclass: #TextColor	instanceVariableNames: 'color '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!TextAttribute subclass: #TextEmphasis	instanceVariableNames: 'emphasisCode setMode '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!TextAttribute subclass: #TextFontChange	instanceVariableNames: 'fontNumber '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!TextAttribute subclass: #TextLinkToImplementors	instanceVariableNames: 'selector '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!WriteStream subclass: #TextStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!CharacterScanner methodsFor: 'private'!addEmphasis: ignored	"Overridden in DisplayScanner"! !!CharacterScanner methodsFor: 'private' priorSource: 304156 inFile: 1!setFont	"Set the font and other emphasis."	(text attributesAt: lastIndex) do: 		[:att | att emphasizeScanner: self]! !!CharacterScanner methodsFor: 'private'!setFont: fontNumber	"Set the font and the stop conditions for the font."	| newFont |	newFont _ textStyle fontAt: fontNumber.	font == newFont ifTrue: [^ self].  "no need to reinitialize"	font _ newFont.	spaceWidth _ font widthOf: Space. 	sourceForm _ font glyphs.	xTable _ font xTable.	height _ font height.	stopConditions _ font stopConditions.	stopConditions at: Space asciiValue + 1 put: #space.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX! !!CharacterScanner methodsFor: 'private'!textColor: ignored	"Overridden in DisplayScanner"! !!DisplayScanner methodsFor: 'scanning' priorSource: 685319 inFile: 1!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle 	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done lineGrid lineIndex stopCondition leftInRun fore back |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	destForm depth > 1 ifTrue:		["Set up color map for display in color"		foregroundColor _ aParagraph foregroundColor.		fore _ foregroundColor bitPatternForDepth: destForm depth.		back _ aParagraph backgroundColor bitPatternForDepth: destForm depth.		self colorMap: (Bitmap with: back first with: fore first)].	rightMargin _ aParagraph rightMarginForDisplay.	lineGrid _ textStyle lineGrid.	lineY _ destY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		runX _ destX _ leftMargin _ 			aParagraph leftMarginForDisplayForLine: lineIndex.		line _ aParagraph lines at: lineIndex.		lastIndex _ line first.		leftInRun<= 0 			ifTrue:				[self setStopConditions.				"also sets the font"				leftInRun _ text runLengthFor: line first].		runLength _ leftInRun.		destY _ lineY + (textStyle baseline - font ascent).		"fontAscent delta"		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ 					self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		lineY _ lineY + lineGrid]! !!DisplayScanner methodsFor: 'private'!addEmphasis: emphasisCode	"Set the bold-ital-under-strike emphasis."	emphasis _ emphasis bitOr: emphasisCode! !!DisplayScanner methodsFor: 'private' priorSource: 791655 inFile: 2!checkEmphasis	"convert mask to color 6/18/96 tk.	9/30/96 tk: use foreColor."	| emph sourceRect y |	(emph _ font emphasis bitOr: emphasis) = 0 ifTrue: [^ self].	(emph bitAnd: 8) > 0 ifTrue:  "struck out"		[destForm			fill: ((runX @ (lineY + textStyle baseline-3)) extent: (destX - runX) @ 1)			rule: combinationRule fillColor: foregroundColor].	(emph bitAnd: 4) > 0 ifTrue:  "underlined"		[destForm			fill: ((runX @ (lineY + textStyle baseline)) extent: (destX - runX) @ 1)			rule: combinationRule fillColor: foregroundColor].	(emph bitAnd: 2) > 0 ifTrue:  "italic"		[y _ lineY + textStyle lineGrid - 4.		[y > lineY] whileTrue:			[sourceRect _ runX @ lineY extent: (destX - runX - 1) @ (y - lineY).			destForm				copyBits: sourceRect from: destForm at: (runX+1) @ lineY				clippingBox: sourceRect rule: Form over fillColor: nil.			y _ y - 4]].	(emph bitAnd: 1) > 0 ifTrue:  "bold face"		[sourceRect _ runX @ lineY extent: (destX - runX - 1) @ textStyle lineGrid.		destForm			copyBits: sourceRect from: destForm at: (runX+1) @ lineY			clippingBox: sourceRect rule: Form under fillColor: nil]! !!DisplayScanner methodsFor: 'private'!setFont 	emphasis _ 0.	self textColor: foregroundColor.	^ super setFont! !!DisplayScanner methodsFor: 'private'!textColor: textColor	colorMap == nil ifTrue: [^ self].	colorMap at: 2 put: ((foregroundColor bitPatternForDepth: destForm depth) at: 1)! !!Paragraph methodsFor: 'selecting'!clickAt: clickPoint for: model 	"Give sensitive text a chance to fire"	"NOTE: Should highight on mouseDown, then abort if drag, else act on mouseUp.	This will require first asking, eg, wantToActOnClick, and then using	Utilities awaitMouseUpIn: box, where box is determined by range of attribute."	| startBlock action |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex) 		do: [:att | (att actOnClickFor: model) ifTrue: [action _ true]].	^ action! !!ParagraphEditor methodsFor: 'sensor access' priorSource: 1277795 inFile: 1!processRedButton	"The user pressed a red mouse button, meaning create a new text 	selection. Highlighting the selection is carried out by the paragraph 	itself. Double clicking causes a selection of the area between the nearest 	enclosing delimitors."	| previousStartBlock previousStopBlock selectionBlocks tempBlock clickPoint oldDelta oldInterval |	clickPoint _ sensor cursorPoint.	(view containsPoint: clickPoint) ifFalse: [^ self].	(paragraph clickAt: clickPoint for: nil) ifTrue: [^ self].	oldInterval _ startBlock stringIndex to: stopBlock stringIndex - 1.	previousStartBlock _ startBlock.	previousStopBlock _ stopBlock.	oldDelta _ paragraph scrollDelta.	sensor leftShiftDown		ifFalse:			[self deselect.			self closeTypeIn.			selectionBlocks _ paragraph mouseSelect: clickPoint]		ifTrue:			[selectionBlocks _ paragraph extendSelectionAt: startBlock endBlock: stopBlock.			self closeTypeIn].	selectionShowing _ true.	startBlock _ selectionBlocks at: 1.	stopBlock _ selectionBlocks at: 2.	startBlock > stopBlock		ifTrue: 			[tempBlock _ startBlock.			startBlock _ stopBlock.			stopBlock _ tempBlock].	(startBlock = stopBlock 		and: [previousStartBlock = startBlock and: [previousStopBlock = stopBlock]])		ifTrue: [self selectWord].	oldDelta ~= paragraph scrollDelta "case of autoscroll"			ifTrue: [self updateMarker].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval]! !!ParagraphEditor methodsFor: 'editing keys' priorSource: 1300865 inFile: 1!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to accept 	characters with the change in emphasis. Emphasis change amounts to a 	font change.  Keeps typeahead."	| keyCode attribute oldAttributes index |		 "control 0-9 -> 0-9"	keyCode _ 0 max: (CtrlDigits indexOf: sensor keyboard asciiValue)-1.	oldAttributes _ paragraph text attributesAt: startBlock stringIndex.	(keyCode between: 1 and: 4) ifTrue:		[attribute _ TextFontChange fontNumber: keyCode].	keyCode = 5 ifTrue:  "ScheduledControllers activeController view flash"		[index _ (PopUpMenu labels: (PopUpMenu labelsFromArray: #(black magenta red yellow green blue active)) lines: #(6)) startUp.		index = 0 ifTrue: [^ true].		attribute _ index = 7		ifTrue: [TextAction evalString: self selection asString]		ifFalse: [TextColor new color: (#(black magenta red yellow green blue cyan) at: index)]].	(keyCode between: 6 and: 9) ifTrue:		[attribute _ TextEmphasis perform:					(#(bold italic underlined struckOut) at: keyCode - 5).		oldAttributes do:			[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	(keyCode = 0) ifTrue:		[attribute _ TextEmphasis normal].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream.			emphasisHere _ Text addAttribute: attribute toArray:					oldAttributes.			^ true].	self replaceSelectionWith: (self selection addAttribute: attribute).	^ true! !!RunArray methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self class name.	aStream nextPutAll: ' runs: '.	runs printOn: aStream.	aStream nextPutAll: ' values: '.	values printOn: aStream.! !!RunArray methodsFor: 'private'!mapValues: mapBlock	"NOTE: only meaningful to an entire set of runs"	values _ values collect: [:val | mapBlock value: val]! !!Text methodsFor: 'emphasis'!addAttribute: att 	^ self addAttribute: att from: 1 to: self size! !!Text methodsFor: 'emphasis'!addAttribute: att from: start to: stop 	"Set the attribute for characters in the interval start to stop."	runs _  runs copyReplaceFrom: start to: stop			with: ((runs copyFrom: start to: stop)				mapValues:				[:attributes | Text addAttribute: att toArray: attributes])! !!Text methodsFor: 'emphasis' priorSource: 1807129 inFile: 1!allBold 	"Force this whole text to be bold."	string size = 0 ifTrue: [^self].	self makeBoldFrom: 1 to: string size! !!Text methodsFor: 'emphasis'!aNewmakeBoldFrom: start to: stop	^ self addAttribute: TextEmphasis bold from: start to: stop! !!Text methodsFor: 'emphasis'!attributesAt: characterIndex 	"Answer the code for characters in the run beginning at characterIndex."	| attributes |	self size = 0		ifTrue: [^ Array with: (TextFontChange new fontNumber: 1)].  "null text tolerates access"	attributes _ runs at: characterIndex.	attributes isNumber		ifTrue: [^ Array with: (TextFontChange new fontNumber: attributes)].  "backward compat"	^ attributes	! !!Text methodsFor: 'emphasis'!fontNumberAt: characterIndex 	"Answer the fontNumber for characters in the run beginning at characterIndex."	| attributes fontNumber |	self size = 0 ifTrue: [^1].	"null text tolerates access"	attributes _ runs at: characterIndex.	attributes isNumber ifTrue: [^ attributes].  "Backward compatibility"	fontNumber _ 1.	attributes do: [:att | (att isMemberOf: TextFontChange) ifTrue: [fontNumber _ att fontNumber]].	^ fontNumber	! !!Text methodsFor: 'private'!becomeModern	"Text allInstancesDo: [:txt | txt becomeModern]" 	runs mapValues:	[:val | val isNumber		 ifTrue: [val = 0 ifTrue: [Array new]					ifFalse: [val\\3=0							ifTrue: [Array with: (TextFontChange fontNumber: val//3+1)]							ifFalse: [Array with: (TextFontChange fontNumber: val//3+1)										with: (TextEmphasis perform: (#(bold italic) at: val\\3))]]]		ifFalse: [val]]! !!Text methodsFor: 'private'!checkModern	"Text allInstancesDo: [:txt | txt checkModern]" 	runs values do: [:val | val isNumber ifTrue: [self halt]]! !!Text class methodsFor: 'class initialization'!newAttributes	"Call this from everywhere there is compatibility code,	so we can later find it all to remove."	^ false! !!Text class methodsFor: 'instance creation'!streamContents: blockWithArg 	| stream |	stream _ TextStream on: (self new: 400).	blockWithArg value: stream.	^ stream contents! !!Text class methodsFor: 'instance creation'!string: aString attributes: atts	"Answer an instance of me whose characters are those of the argument, 	aString. atts is an array of TextAttributes."	^self string: aString runs: (RunArray new: aString size withAll: atts)! !!Text class methodsFor: 'instance creation'!string: aString font: aFont 	"Answer an instance of me whose characters are those of aString.	Use aFont for style, assuming it can be found in the default TextStyle."	^ self string: aString emphasis:		(TextStyle default indexOfFont: aFont)! !!Text class methodsFor: 'private'!addAttribute: att toArray: others 	"Add a new text attribute to an existing set"	| oldEmph |	^ Array streamContents:		[:strm | others do:			[:other | other isNumber				ifTrue: [oldEmph _ TextFontChange new fontNumber: other.						(att dominates: oldEmph) ifFalse: [strm nextPut: oldEmph]]				ifFalse: [(att dominates: other) ifFalse: [strm nextPut: other]]].		att set ifTrue: [strm nextPut: att]]! !!TextAction class methodsFor: 'as yet unclassified'!evalString: str	^ self new evalString: str! !!TextAttribute methodsFor: 'as yet unclassified'!actOnClickFor: model	"Subclasses may override to provide, eg, hot-spot actions"	^ false! !!TextAttribute methodsFor: 'as yet unclassified'!dominates: another	"Subclasses may override condense multiple attributes"	^ false! !!TextAttribute methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Subclasses may override to set, eg, font, color, etc"! !!TextAttribute methodsFor: 'as yet unclassified'!oldEmphasisCode: default	"Allows running thorugh possibly multiple attributes	and getting the emphasis out of any that has an emphasis (font number)"	^ default! !!TextAttribute methodsFor: 'as yet unclassified'!set	"Respond true to include this attribute (as opposed to, eg, a bold	emphasizer that is clearing the property"	^ true! !!TextAction methodsFor: 'as yet unclassified'!actOnClickFor: anObject	"Note: evalString gets evaluated IN THE CONTEXT OF anObject	 -- meaning that self and all instVars are accessible"	Compiler evaluate: evalString for: anObject logged: false.	^ true! !!TextAction methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: #cyan! !!TextAction methodsFor: 'as yet unclassified'!evalString: str	evalString _ str! !!TextColor methodsFor: 'as yet unclassified'!= other 	^ (other isMemberOf: self class) 		and: [other color = color]! !!TextColor methodsFor: 'as yet unclassified'!color	^ color! !!TextColor methodsFor: 'as yet unclassified'!color: aColor	color _ aColor! !!TextColor methodsFor: 'as yet unclassified'!dominates: other	^ other isMemberOf: self class! !!TextColor methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: color! !!TextColor methodsFor: 'as yet unclassified'!printOn: strm	super printOn: strm.	strm nextPutAll: ' code: '; print: color! !!TextEmphasis methodsFor: 'as yet unclassified'!= other 	^ (other isMemberOf: self class) 		and: [other emphasisCode = emphasisCode]! !!TextEmphasis methodsFor: 'as yet unclassified'!dominates: other	(emphasisCode = 0 and: [other isMemberOf: TextAction]) ifTrue: [^ true].	^ (other isMemberOf: self class)		and: [emphasisCode = 0			or: [emphasisCode = other emphasisCode]]! !!TextEmphasis methodsFor: 'as yet unclassified'!emphasisCode	^ emphasisCode! !!TextEmphasis methodsFor: 'as yet unclassified'!emphasisCode: int	emphasisCode _ int.	setMode _ true! !!TextEmphasis methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the emphasist for text display"	scanner addEmphasis: emphasisCode! !!TextEmphasis methodsFor: 'as yet unclassified'!printOn: strm	super printOn: strm.	strm nextPutAll: ' code: '; print: emphasisCode! !!TextEmphasis methodsFor: 'as yet unclassified'!set	^ setMode and: [emphasisCode ~= 0]! !!TextEmphasis methodsFor: 'as yet unclassified'!turnOff	setMode _ false! !!TextEmphasis class methodsFor: 'as yet unclassified'!bold	^ self new emphasisCode: 1! !!TextEmphasis class methodsFor: 'as yet unclassified'!italic	^ self new emphasisCode: 2! !!TextEmphasis class methodsFor: 'as yet unclassified'!normal	^ self new emphasisCode: 0! !!TextEmphasis class methodsFor: 'as yet unclassified'!struckOut	^ self new emphasisCode: 8! !!TextEmphasis class methodsFor: 'as yet unclassified'!underlined	^ self new emphasisCode: 4! !!TextFontChange methodsFor: 'as yet unclassified'!= other 	^ (other isMemberOf: self class) 		and: [other fontNumber = fontNumber]! !!TextFontChange methodsFor: 'as yet unclassified'!dominates: other	^ other isMemberOf: self class! !!TextFontChange methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the font for text display"	scanner setFont: fontNumber! !!TextFontChange methodsFor: 'as yet unclassified'!fontNumber	^ fontNumber! !!TextFontChange methodsFor: 'as yet unclassified'!fontNumber: int	fontNumber _ int! !!TextFontChange methodsFor: 'as yet unclassified'!oldEmphasisCode: default	^ fontNumber! !!TextFontChange methodsFor: 'as yet unclassified'!printOn: strm	super printOn: strm.	strm nextPutAll: ' font: '; print: fontNumber! !!TextFontChange class methodsFor: 'as yet unclassified'!fontNumber: n	^ self new fontNumber: n! !!TextLinkToImplementors methodsFor: 'as yet unclassified'!actOnClickFor: modelIgnored	Smalltalk browseAllImplementorsOf: selector.	^ true! !!TextLinkToImplementors methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: #red! !!TextLinkToImplementors methodsFor: 'as yet unclassified'!selector: sel	selector _ sel! !!TextLinkToImplementors class methodsFor: 'as yet unclassified'!of: selector	^ self new selector: selector! !!WriteStream methodsFor: 'private'!withAttribute: att do: strmBlock 	"No-op here is overriden in TextStream for font emphasis"	^ strmBlock value! !!TextStream methodsFor: 'as yet unclassified'!applyAttribute: att beginningAt: startPos	collection addAttribute: att from: startPos to: self position! !!TextStream methodsFor: 'as yet unclassified'!nextPutAll: aCollection 	"Optimized access to get around Text at:Put: overhead"	| n |	n _ aCollection size.	((aCollection isMemberOf: String) not or: [position + n > writeLimit])		ifTrue: [^ super nextPutAll: aCollection].	collection string		replaceFrom: position+1		to: position + n		with: aCollection		startingAt: 1.	position _ position + n! !!TextStream methodsFor: 'as yet unclassified'!withAttribute: att do: strmBlock	| pos1 val |	pos1 _ self position.	val _ strmBlock value.	collection addAttribute: att from: pos1+1 to: self position.	^ val! !Text class removeSelector: #string:fontName:!Text class removeSelector: 'string:fontName:' asSymbol!'From Squeak 1.13 of October 17, 1996 on 28 October 1996 at 3:09:13 pm'!!CompositionScanner methodsFor: 'stop conditions' priorSource: 486932 inFile: 1!crossedX	"There is a word that has fallen across the right edge of the composition 	rectangle. This signals the need for wrapping which is done to the last 	space that was encountered, as recorded by the space stop condition."	line stop: spaceIndex.	spaceCount > 1			ifTrue:	["The common case. First back off the space at which we wrap."				spaceCount _ spaceCount - 1.				spaceIndex _ spaceIndex - 1.				["Check to see if any spaces preceding the one at which we wrap.					Double space after a period, most likely."				(spaceCount > 1 and: [(text at: spaceIndex) = Space])]					whileTrue:						[spaceCount _ spaceCount - 1.						"Account for backing over a run which might							change width of space."						font _ textStyle fontAt:								(text fontNumberAt: spaceIndex).						spaceIndex _ spaceIndex - 1.						spaceX _ spaceX - (font widthOf: Space)].						line paddingWidth: rightMargin - spaceX.						line internalSpaces: spaceCount]		ifFalse:	[spaceCount = 1					ifTrue:	["wrap at space, but no internal spaces"							line internalSpaces: 0.							line paddingWidth: rightMargin - spaceX]					ifFalse:	["Neither internal nor trailing spaces, almost never happen,								she says confidently."							lastIndex _ lastIndex - 1.							[destX <= rightMargin]							whileFalse:								[destX _ destX - (font widthOf:													(text at: lastIndex)).										"bug --doesn't account for backing over										 run and changing actual width of										characters. Also doesn't account for										backing over a tab.  Happens only										when no spaces in line, presumably rare."								lastIndex _ lastIndex - 1].							spaceX _ destX.							line paddingWidth: rightMargin - destX.							lastIndex < line first								ifTrue:	[line stop: line first]								ifFalse:	[line stop: lastIndex]]].	^true! !!DisplayScanner methodsFor: 'private' priorSource: 943522 inFile: 2!checkEmphasis	"convert mask to color 6/18/96 tk.  9/30/96 tk: use foreColor.	NOTE synthetic bold and italic dont really work right in color.	bold tries to OR a copy over by 1 bit which is nonsense in color	itallic tries to slide strips over which is nonsense if there is any background"	| emph sourceRect y |	(emph _ font emphasis bitOr: emphasis) = 0 ifTrue: [^ self].	(emph bitAnd: 8) > 0 ifTrue:  "struck out"		[destForm			fill: ((runX @ (lineY + textStyle baseline-3)) extent: (destX - runX) @ 1)			rule: combinationRule fillColor: foregroundColor].	(emph bitAnd: 4) > 0 ifTrue:  "underlined"		[destForm			fill: ((runX @ (lineY + textStyle baseline)) extent: (destX - runX) @ 1)			rule: combinationRule fillColor: foregroundColor].	(emph bitAnd: 2) > 0 ifTrue:  "italic"		[y _ lineY + textStyle lineGrid - 4.		[y > lineY] whileTrue:			[sourceRect _ runX @ lineY extent: (destX - runX - 1) @ (y - lineY).			destForm				copyBits: sourceRect from: destForm at: (runX+1) @ lineY				clippingBox: sourceRect rule: Form over fillColor: nil.			y _ y - 4]].	(emph bitAnd: 1) > 0 ifTrue:  "bold face"		[sourceRect _ runX @ lineY extent: (destX - runX - 1) @ textStyle lineGrid.		destForm			copyBits: sourceRect from: destForm at: (runX+1) @ lineY			clippingBox: sourceRect rule: Form under fillColor: nil]! !!DisplayScanner methodsFor: 'private' priorSource: 944796 inFile: 2!textColor: textColor	colorMap == nil ifTrue: [^ self].	colorMap at: 2 put:		(((textColor == nil ifTrue: [foregroundColor] ifFalse: [textColor])			 bitPatternForDepth: destForm depth) at: 1)! !!Paragraph methodsFor: 'utilities' priorSource: 1259517 inFile: 1!gridWithLead: leadInteger 	"Set the line grid of the receiver's style for displaying text to the height 	of the first font in the receiver's style + the argument, leadInteger."	textStyle 		gridForFont: (text fontNumberAt: 1)		withLead: leadInteger		"assumes only one font referred to by runs"! !!ParagraphEditor methodsFor: 'editing keys' priorSource: 947106 inFile: 2!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to accept 	characters with the change in emphasis. Emphasis change amounts to a 	font change.  Keeps typeahead."	| keyCode attribute oldAttributes index |		 "control 0-9 -> 0-9"	keyCode _ 0 max: (sensor keyboard asciiValue - $0 asciiValue).	oldAttributes _ paragraph text attributesAt: startBlock stringIndex.	(keyCode between: 1 and: 6) ifTrue:		[attribute _ TextFontChange fontNumber: keyCode].	keyCode = 7 ifTrue:		[index _ (PopUpMenu labelArray: #(black magenta red yellow green blue active)							lines: #(6)) startUp.		index = 0 ifTrue: [^ true].		attribute _ index = 7		ifTrue: [TextAction evalString: self selection asString]		ifFalse: [TextColor color: (Color perform: (#(black magenta red yellow green blue cyan) at: index))]].	(keyCode between: 8 and: 9) ifTrue:		[attribute _ TextEmphasis perform:					(#(bold italic underlined struckOut) at: keyCode - 5).		oldAttributes do:			[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	(keyCode = 0) ifTrue:		[attribute _ TextEmphasis normal].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream.			emphasisHere _ Text addAttribute: attribute toArray:					oldAttributes.			^ true].	self replaceSelectionWith: (self selection addAttribute: attribute).	^ true! !!StrikeFont methodsFor: 'accessing'!setGlyphs: newGlyphs	"Replace the glyphs form.  Used to make a synthetic bold or italic font quickly."	glyphs _ newGlyphs! !!Text methodsFor: 'emphasis' priorSource: 1807445 inFile: 1!emphasizeFrom: start to: stop with: emphasis	"Set the emphasis for characters in the interval start to stop."	runs _ 		runs			copyReplaceFrom: start			to: stop			with: (RunArray new: stop - start + 1 withAll: 					(Array with: (TextFontChange new fontNumber: emphasis)))! !!Text methodsFor: 'emphasis' priorSource: 1807673 inFile: 1!makeBoldFrom: start to: stop	"Should just use (TextEmphasis bold) but synthetic bold doesnt work right now."	^ self addAttribute: (TextFontChange new fontNumber: 2) from: start to: stop! !!Text methodsFor: 'private' priorSource: 950593 inFile: 2!becomeModern	"Text allInstancesDo: [:txt | txt becomeModern]" 	runs mapValues:	[:val | val isNumber		 ifTrue: [val = 0 ifTrue: [Array new]					ifFalse: [Array with: (TextFontChange fontNumber: val)]]		ifFalse: [val]]! !!Text class methodsFor: 'instance creation' priorSource: 1814075 inFile: 1!string: aString emphasis: code	"Answer an instance of me whose characters are those of the argument, 	aString. Use the font whose index into the default TextStyle font array is 	code."	code isNumber ifTrue:		[^ self string: aString runs: (RunArray new: aString size withAll: 			(Array with: (TextFontChange new fontNumber: code)))].	^ self string: aString attributes: code! !!TextAction methodsFor: 'as yet unclassified' priorSource: 953712 inFile: 2!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: Color cyan! !!TextColor class methodsFor: 'as yet unclassified'!color: aColor	^ self new color: aColor! !!TextStyle methodsFor: 'fonts and font indexes' priorSource: 896155 inFile: 2!propagateFontChanges  "TextStyle default propagateFontChanges"	"Assumes fontArray is to be in sets of 3 emphases"	| f g ff r |	(1 to: fontArray size by: 3) do:		[:i |		f _ fontArray at: i.		fontArray at: i+1 put: (ff _ f emphasized: 0 named: f name , 'b').			"Make a bold set of glyphs with same widths"			g _ ff glyphs deepCopy.			g copyBits: g boundingBox from: g at: (1@0)				clippingBox: g boundingBox rule: Form under fillColor: nil.			ff setGlyphs: g.		fontArray at: i+2 put: (ff _ f emphasized: 0 named: f name , 'i').			"Make an italic set of glyphs with same widths"			g _ ff glyphs deepCopy.			r _ 0 @ ff ascent extent: g boundingBox extent.			g copyBits: r from: g at: r topLeft - (1@0)				clippingBox: r rule: Form over fillColor: nil.			r _ 0 @ 0 extent: g width @ ff ascent - 4.			g copyBits: r from: g at: r topLeft + (1@0)				clippingBox: r rule: Form over fillColor: nil.			ff setGlyphs: g.		]! !Text removeSelector: #aNewmakeBoldFrom:to:!Text removeSelector: 'aNewmakeBoldFrom:to:' asSymbol!Text class removeSelector: #newAttributes!Text class removeSelector: #newAttributes!Text allInstancesDo: [:txt | txt becomeModern]!TextStyle default propagateFontChanges!'From Squeak 1.13 of October 17, 1996 on 28 October 1996 at 6:48:37 pm'!!BrowserCodeController methodsFor: 'menu messages' priorSource: 182609 inFile: 1!format	"Reformat the contents of the receiver's view, formatted, if the view is unlocked. "	| selectedClass aCompiler newText locked |	locked _ model isLocked.	model messageListIndex = 0 | locked ifTrue: [^view flash].	selectedClass _ model selectedClassOrMetaClass.	Cursor execute showWhile: 		[aCompiler _ selectedClass compilerClass new.		self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		newText _ aCompiler			format: model contents			in: selectedClass			notifying: self.		newText == nil ifFalse: 			[self replaceSelectionWith:				(newText asText makeSelectorBoldIn: selectedClass).			self selectAt: 1]].	locked ifFalse: [self unlockModel] ! !!Compiler methodsFor: 'public access' priorSource: 480693 inFile: 1!format: textOrStream in: aClass notifying: aRequestor	"Compile a parse tree from the argument, textOrStream. Answer a string 	containing the original code, formatted nicely.	If the leftShift key is pressed, then decorate the resulting text with	color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode _ self format: sourceStream noPattern: false ifFail: [^nil].	Sensor leftShiftDown		ifTrue: [^ aNode decompileText]		ifFalse: [^ aNode decompileString]! !!ParseNode methodsFor: 'printing' priorSource: 1351814 inFile: 1!printCommentOn: aStream indent: indent 	| thisComment |	comment == nil ifTrue: [^self].	"Show comments in green"	aStream withAttribute: (TextColor color: Color blue) do: 	[1 to: comment size do: 		[:index | 		index > 1 ifTrue: [aStream crtab: indent].		aStream nextPut: $".		thisComment _ comment at: index.		self printSingleComment: thisComment			on: aStream			indent: indent.		aStream nextPut: $"]].	comment _ nil! !!MessageNode methodsFor: 'printing' priorSource: 1105531 inFile: 1!printKeywords: key arguments: args on: aStream indent: level 	| keywords part prev arg indent thisKey |	args size = 0 		ifTrue: [aStream space.				aStream withAttribute: (TextLinkToImplementors of: key)					do: [aStream nextPutAll: key].				^ self].	keywords _ key keywords.	prev _ receiver.	1 to: args size do:		[:part | arg _ args at: part.		thisKey _ keywords at: part.		(prev isMemberOf: BlockNode)		 | ((prev isMemberOf: MessageNode) and: [prev precedence >= 3])		 | ((arg isMemberOf: BlockNode) and: [arg isComplex and: [thisKey ~= #do:]])		 | (args size > 2)		 | (key = #ifTrue:ifFalse:)			ifTrue: [aStream crtab: level+1. indent _ 1] "newline after big args"			ifFalse: [aStream space. indent _ 0].		aStream withAttribute: (TextLinkToImplementors of: key) do: 			[aStream nextPutAll: thisKey].  aStream space.		arg  printOn: aStream indent: level + 1 + indent			 precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence]).		prev _ arg]! !!MethodNode methodsFor: 'converting' priorSource: 1147574 inFile: 1!decompileString 	"Answer a string description of the parse tree whose root is the receiver."	^ String streamContents: [:strm | self printOn: strm]! !!MethodNode methodsFor: 'converting'!decompileText 	"Answer a string description of the parse tree whose root is the receiver."	^ Text streamContents: [:strm | self printOn: strm]! !!MethodNode methodsFor: 'printing' priorSource: 1147811 inFile: 1!printOn: aStream 	| s args |	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[args _ ReadStream on: arguments.			self selector keywords do: 				[:s | 				aStream nextPutAll: s; space.				aStream withAttribute: (TextColor color: Color green)					do: [aStream nextPutAll: args next key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '| '.			aStream withAttribute: (TextColor color: Color green)				do: [temporaries do: 					[:temp | 					aStream nextPutAll: temp key.					aStream space]].			aStream nextPut: $|].	primitive > 0 ifTrue:			[aStream crtab: 1.			self printPrimitiveOn: aStream].	aStream crtab: 1.	^block printStatementsOn: aStream indent: 1! !!TextLinkToImplementors methodsFor: 'as yet unclassified' priorSource: 957098 inFile: 2!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: Color red! !!VariableNode methodsFor: 'printing' priorSource: 1866246 inFile: 1!printOn: aStream indent: level 	self isTemp ifTrue:		[^ aStream withAttribute: (TextColor color: Color blue)					do: [aStream nextPutAll: name]].	aStream nextPutAll: name! !BrowserCodeController removeSelector: #miniFormat!BrowserCodeController removeSelector: #miniFormat!'From Squeak 1.13 of October 17, 1996 on 28 October 1996 at 7:24:46 pm'!!Object methodsFor: 'dependents access' priorSource: 1182425 inFile: 1!addDependent: anObject	"Make the given object one of the receiver's dependents."	| dependents |	dependents _ self dependents.	dependents do: [:o | o == anObject ifTrue: [^ self]].  "anObject is already a dependent"	DependentsFields at: self put: (dependents copyWith: anObject).! !!Object methodsFor: 'dependents access' priorSource: 1200825 inFile: 1!breakDependents	"Remove all of the receiver's dependents."	DependentsFields removeKey: self ifAbsent: [].! !!Object methodsFor: 'dependents access' priorSource: 1182602 inFile: 1!dependents	"Answer a collection of objects that are 'dependent' on the receiver;	 that is, all objects that should be notified if the receiver changes."	(DependentsFields includesKey: self)		ifTrue: [^ DependentsFields at: self]		ifFalse: [^ #()].! !!Object methodsFor: 'dependents access' priorSource: 1183126 inFile: 1!removeDependent: anObject	"Remove the given object as one of the receiver's dependents."	| dependents newDependents |	dependents _ self dependents.	newDependents _ dependents select: [ :d | (d == anObject) not].	newDependents isEmpty		ifTrue: [DependentsFields removeKey: self ifAbsent: []]		ifFalse: [DependentsFields at: self put: newDependents].! !!Model methodsFor: 'dependents' priorSource: 1152605 inFile: 1!addDependent: anObject	"Make the given object one of the receiver's dependents."	dependents == nil		ifTrue: [dependents _ Array with: anObject]		ifFalse: [			"done if anObject is already a dependent"			dependents do: [:o | o == anObject ifTrue: [^ self]].			"otherwise, add it"			dependents _ dependents copyWith: anObject].! !!Model methodsFor: 'dependents' priorSource: 1152966 inFile: 1!breakDependents	"Remove all of the receiver's dependents."	dependents _ nil.! !!Model methodsFor: 'dependents' priorSource: 1153051 inFile: 1!dependents	"Answer a collection of objects that are 'dependent' on the receiver;	 that is, all objects that should be notified if the receiver changes."	dependents == nil ifTrue: [^ #()].	^ dependents! !!Model methodsFor: 'dependents'!removeDependent: anObject	"Remove the given object as one of the receiver's dependents."	| newDependents |	newDependents _ dependents select: [ :d | (d == anObject) not].	newDependents isEmpty		ifTrue: [dependents _ nil]		ifFalse: [dependents _ newDependents].! !!UndefinedObject methodsFor: 'dependents access' priorSource: 1844138 inFile: 1!addDependent: ignored 	"Refer to the comment in Object|dependents."	self error: 'Nil should not have dependents'! !Object removeSelector: #setDependents!Object removeSelector: #setDependents!Debugger removeSelector: #removeDependent:!Debugger removeSelector: 'removeDependent:' asSymbol!Project removeSelector: #removeDependent:!Project removeSelector: 'removeDependent:' asSymbol!Switch removeSelector: #removeDependent:!Switch removeSelector: 'removeDependent:' asSymbol!"Convert all existing dependents lists to the new style."| dList |Model allSubInstances do: [ :m |	dList _ m dependents.	m breakDependents.	dList do: [ :d | m addDependent: d].].Smalltalk reclaimDependents.!'From Squeak 1.13 of October 17, 1996 on 28 October 1996 at 7:29:13 pm'!!CRFillInTheBlankController methodsFor: 'sensor access' priorSource: 541180 inFile: 1!dispatchOnCharacter: char with: typeAheadStream	"Accept and terminate the interation if the user hits a CR or the enter key."	(char = Character cr) | (char = Character enter)		ifTrue:			[sensor keyboard.  "gobble the character"			self accept.			^ true]		ifFalse:			[^ super dispatchOnCharacter: char with: typeAheadStream].! !'From Squeak 1.13 of October 17, 1996 on 28 October 1996 at 7:25:35 pm'!!InspectListController methodsFor: 'menu messages' priorSource: 772028 inFile: 2!objectReferencesToSelection	"Open a list inspector on all the objects that point to the value of the selected instance variable, if any.  9/27/96 sw"	model selectionIndex == 0 ifTrue: [^ view flash].	self controlTerminate.	Smalltalk		browseAllObjectReferencesTo: model selection		except: (Array with: model object)		ifNone: [:obj | view topView flash].! !!StringHolderController methodsFor: 'menu messages' priorSource: 773935 inFile: 2!objectsReferencingIt	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  9/27/96 sw"	| result |	self controlTerminate.	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or:	 [result == #failedDoit]) ifFalse: [		Smalltalk			browseAllObjectReferencesTo: result			except: #()			ifNone: [:obj | view topView flash. self controlInitialize]].! !!SystemDictionary methodsFor: 'browsing'!browseAllObjectReferencesTo: anObject except: objectsToExclude ifNone: aBlock	"Bring up a list inspector on the objects that point to anObject. If there are none, then evaluate aBlock on anObject.  9/27/96 sw"	| aList shortName |	aList _ Smalltalk pointersTo: anObject except: objectsToExclude.	aList size > 0 ifFalse: [^ aBlock value: anObject].	shortName _ anObject name.	shortName size > 12 ifTrue: [		shortName _ (shortName truncateTo: 12), '...'.	].	InspectorView		open: (InspectorView inspector: (OrderedCollectionInspector inspect: aList))		withLabel: 'Objects pointing to ', shortName.! !!SystemDictionary methodsFor: 'retrieving' priorSource: 769963 inFile: 2!pointersTo: anObject except: objectsToExclude	"Find all occurrences in the system of pointers to the argument anObject. Remove objects in the exclusion list from the results."	| results anObj |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	results _ OrderedCollection new: 1000.	"allObjectsDo: is expanded inline to keep spurious	 method and block contexts out of the results"	anObj _ self someObject.	[0 == anObj] whileFalse: [		(anObj pointsTo: anObject) ifTrue: [			"exclude the results collector and contexts in call chain"			((anObj ~~ results collector) and:			 [(anObj ~~ objectsToExclude) and:			 [(anObj ~~ thisContext) and:			 [(anObj ~~ thisContext sender) and:			 [anObj ~~ thisContext sender sender]]]])				 ifTrue: [ results add: anObj ].		].		anObj _ anObj nextObject.	].	objectsToExclude do: [ :obj | results removeAllSuchThat: [ :el | el == obj]].	^ results asArray! !SystemDictionary removeSelector: #browseAllObjectReferencesTo:ifNone:!SystemDictionary removeSelector: 'browseAllObjectReferencesTo:ifNone:' asSymbol!'From Squeak 1.13 of October 17, 1996 on 28 October 1996 at 7:33:05 pm'!!SmallInteger methodsFor: 'printing' priorSource: 1596608 inFile: 1!printOn: aStream base: b	"Refer to the comment in Integer|printOn:base:."	"SmallInteger maxVal printStringBase: 2"	| digitsInReverse x i |	self < 0 ifTrue: [		aStream nextPut: $-.		^ self negated printOn: aStream base: b.	].	b = 10 ifFalse: [aStream print: b; nextPut: $r].	digitsInReverse _ Array new: 32.	x _ self.	i _ 0.	[x >= b] whileTrue: [		digitsInReverse at: (i _ i + 1) put: x \\ b.		x _ x // b.	].	digitsInReverse at: (i _ i + 1) put: x.	[i > 0] whileTrue: [		aStream nextPut: (Character digitValue: (digitsInReverse at: i)).		i _ i - 1.	].! !!Time class methodsFor: 'instance creation' priorSource: 1835334 inFile: 1!fromSeconds: secondCount 	"Answer an instance of me that is secondCount number of seconds since midnight."	| secondsInHour hours secs |	secs _ secondCount asInteger.	hours _ secs // 3600.	secondsInHour _ secs \\ 3600.	^self new hours: hours			   minutes: secondsInHour // 60			   seconds: secondsInHour \\ 60! !'From Squeak 1.13 of October 17, 1996 on 28 October 1996 at 10:06:19 pm'!Boolean removeSelector: #forRom!Boolean removeSelector: #forRom!Controller class removeSelector: #hasEditingMenu!Controller class removeSelector: #hasEditingMenu!ControlManager removeSelector: #topmostInactiveTextController!ControlManager removeSelector: #topmostInactiveTextController!ControlManager removeSelector: #potentialController!ControlManager removeSelector: #potentialController!MouseMenuController removeSelector: #cmdKeyActivity!MouseMenuController removeSelector: #cmdKeyActivity!String removeSelector: #forRom!String removeSelector: #forRom!View class removeSelector: #identityTransformation!View class removeSelector: #identityTransformation!"This is an executable file.  If it is in the same folder as your image, along with all the other files called out below, you may simply fileIn this file, and it will in turn fileIn all the others.  If these files are in some other folder that you are browsing with the file list, you can instead use the fileList fileIn capability to file in the various files, in the order specified below.""Define a new 'staggered' window placement policy.  The goal is to distribute windows around the edges of the screen, but staggered in such a way that the outside corner of every window is always visible.  Try it, you'll like it.  Use the screen menu window...stagger choice."(FileStream readOnlyFileNamed: 'WindowPlacement-di.cs') fileIn."Define ctrl-Return as CR followed by the same number of tabs as the line above, (adjusted by number of brackets). Also define Shift-backspace as forward delete-char [not currently undoable]."(FileStream readOnlyFileNamed: 'KbdShortcuts-di.cs') fileIn."A fix to arcTan that makes it more accurate and also a lot faster for certain angles"(FileStream readOnlyFileNamed: 'ArcTanFix-db.cs') fileIn."A fairly major change that cures preexisting problems where long titles forced windows to be too big.  In the process the discrepancy between the height of title bars on collapsed and expanded windows is removed."(FileStream readOnlyFileNamed: 'WindowTitleFix-di.cs') fileIn."Fixes a couple of problems with the StrikeFont edit: hack.  Read the method comment before using it, though"(FileStream readOnlyFileNamed: 'FontEditFix-di.cs') fileIn."Tweaks the 1.13 font so that a few characters are better centered in their frames.  Looks better and easier to select, too."(FileStream readOnlyFileNamed: 'FontTweak-di.doit') fileIn."Makes it easier to access the window drag-corner feature."(FileStream readOnlyFileNamed: 'BorderEditTweak-di.cs') fileIn."Two post-release tweaks to earlier fileIns above."(FileStream readOnlyFileNamed: 'WindowPlacementTweak-di.cs') fileIn.(FileStream readOnlyFileNamed: 'TitleTweak-di.cs') fileIn."Adds the ability to browse classes and methods in their inheritance hierarchy.  Also a 'browse all' feature that gives you all classes alphabetically (and shows you what category they are in, too)."(FileStream readOnlyFileNamed: 'BrowseHierarchy-di.cs') fileIn."These two fileIns change the representation of Text emphasis.  As a result, in-line color changes are supported, as well as text ranges that execute abitrary code when you click on them (now why would you want to do that?).  Command keys 0-9 have different meanings."(FileStream readOnlyFileNamed: 'NewTextPhase1-di.cs') fileIn.(FileStream readOnlyFileNamed: 'NewTextPhase2-di.cs') fileIn."A silly demonstration of the new Text features.  If you select the browser code 'format' command with the shift key down, it shows message names in red and temps in green.  Illustrates the use of a TextStream to build emphasized text sequentially.  Note that if you click on a message name, it immediately shows you all implementations of that message.  Note that color is not normally preserved when you leave a window (See StandardSystemView cacheBitsAsTwoTone), so click in the title bar to redisplay."(FileStream readOnlyFileNamed: 'ColorFormatDemo-di.cs') fileIn."Five files roughly described by their names"(FileStream readOnlyFileNamed: 'DependentsImprovements.st') fileIn.(FileStream readOnlyFileNamed: 'FillInBlankFix.st') fileIn.(FileStream readOnlyFileNamed: 'ObjectReferencesFixes.st') fileIn.(FileStream readOnlyFileNamed: 'JohnCleanups3.st') fileIn.(FileStream readOnlyFileNamed: 'JohnCleanups4.st') fileIn.!----QUIT----(5 November 1996 9:48:38 pm )!'From Squeak 1.13 of October 17, 1996 on 31 October 1996 at 7:50:51 am'!!ClassOrganizer methodsFor: 'method dictionary' priorSource: 388560 inFile: 1!addCategory: catString before: nextCategory	"Add a new category named heading.	If default category exists and is empty, remove it.	If nextCategory is nil, then add the new one at the end,	otherwise, insert it before nextCategory."	| index newCategory |	newCategory _ catString asSymbol.	(categoryArray indexOf: newCategory) > 0		ifTrue: [^self].	"heading already exists, so done"	index _ categoryArray indexOf: nextCategory		ifAbsent: [categoryArray size + 1].	categoryArray _ categoryArray		copyReplaceFrom: index		to: index-1		with: (Array with: newCategory).	categoryStops _ categoryStops		copyReplaceFrom: index		to: index-1		with: (Array with: (index = 1				ifTrue: [0]				ifFalse: [categoryStops at: index-1])).	"remove empty default category"	(newCategory ~= Default			and: [(self listAtCategoryNamed: Default) isEmpty])		ifTrue: [self removeCategory: Default]! !!SystemCategoryListController methodsFor: 'menu messages' priorSource: 937069 inFile: 2!findClass	"modified 4/29/96 sw so that if only 1 class matches the user-supplied string, or if the user-supplied string exactly matches a class name, then the pop-up menu is bypassed"	| pattern foundClass classNames index reply |	self controlTerminate.	model okToChange ifFalse: [^ self classNotFound].	pattern _ (reply _ FillInTheBlank request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self classNotFound].	(Smalltalk hasClassNamed: reply)		ifTrue:			[foundClass _ Smalltalk at: reply asSymbol]		ifFalse: 			[classNames _ Smalltalk classNames asArray select: 				[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].			classNames isEmpty ifTrue: [^ self classNotFound].			index _ classNames size == 1				ifTrue:	[1]				ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].			index = 0 ifTrue: [^ self classNotFound].			foundClass _ Smalltalk at: (classNames at: index)]. 	model systemCategoryListIndex: (model systemCategoryList indexOf: foundClass category).	model classListIndex: (model classList indexOf: foundClass name). 	self controlInitialize! !'From Squeak 1.13 of October 17, 1996 on 4 November 1996 at 10:52:15 pm'!!Scanner class methodsFor: 'testing' priorSource: 825633 inFile: 2!isLiteralSymbol: aSymbol 	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type |	i _ aSymbol size.	i = 0 ifTrue: [^false].	ascii _ (aSymbol at: 1) asciiValue.	"TypeTable should have been origined at 0 rather than 1 ..."	ascii = 0 ifTrue: [^false].	type _ TypeTable at: ascii.	(type == #xColon or: [type == #verticalBar])		ifTrue: [^i = 1].	type == #xBinary		ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^false].					(TypeTable at: ascii) == #xBinary ifFalse: [^false].					i _ i - 1].			^true].	type == #xLetter		ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^false].					type _ TypeTable at: ascii.					(type == #xLetter or: [type == #xDigit or: [type == #xColon]])						ifFalse: [^false].					i _ i - 1].			^true].	^false! !'From Squeak 1.13 of October 17, 1996 on 2 November 1996 at 11:44:15 pm'!!StandardSystemController methodsFor: 'borders' priorSource: 861574 inFile: 2!checkForReframe	| cp |	view isCollapsed ifTrue: [^ self].	cp _ sensor cursorPoint.	((view closeBoxFrame expandBy: 2) containsPoint: cp)		| ((view growBoxFrame expandBy: 2) containsPoint: cp)		ifTrue: [^ self].  "Dont let reframe interfere with close/grow"	self adjustWindowCorners.	self cursorOnBorder ifFalse: [^ self].	((view insetDisplayBox insetBy: 2@2) containsPoint: cp)		ifFalse: [^ self adjustWindowBorders].	(view subviewWithLongestSide: [:s | ] near: cp) == nil		ifFalse: [^ self adjustPaneBorders].! !'From Squeak 1.13 of October 17, 1996 on 2 November 1996 at 10:03:55 pm'!!DebuggerView class methodsFor: 'instance creation' priorSource: 611454 inFile: 1!openNotifier: aDebugger contents: msgString label: label	"Create and schedule a simple view with a debugger which can be opened later."	| aStringHolderView topView displayPoint nLines |	self flag: #developmentNote.	Cursor normal show.	Sensor flushKeyboard.	aStringHolderView _ StringHolderView container:		(StringHolder new contents: msgString).	aStringHolderView controller: (NotifyStringHolderController debugger: aDebugger).	topView _ StandardSystemView new.	topView model: aStringHolderView model.	topView addSubView: aStringHolderView.	topView label: label.	nLines _ 1 + (msgString occurrencesOf: Character cr).	topView minimumSize: 350 @ (14*nLines + 6).	displayPoint _ 		ScheduledControllers activeController == nil			ifTrue: [Display boundingBox center]			ifFalse: [ScheduledControllers activeController view displayBox center].	topView controller openNoTerminateDisplayAt: displayPoint.	^ topView! !'From Squeak 1.13 of October 17, 1996 on 31 October 1996 at 3:30:08 pm'!!Form methodsFor: 'bordering'!border: rect width: borderWidth rule: rule fillColor: fillColor 	"Paint a border whose rectangular area is defined by rect. The 	width of the border of each side is borderWidth. Uses fillColor for 	drawing the border."	| blt |	blt _ (BitBlt toForm: self) combinationRule: rule; fillColor: fillColor.	blt sourceOrigin: 0@0.	blt destOrigin: rect origin.	blt width: rect width; height: borderWidth; copyBits.	blt destY: rect bottom-borderWidth; copyBits.	blt destOrigin: rect origin.	blt height: rect height; width: borderWidth; copyBits.	blt destX: rect right-borderWidth; copyBits.! !!Rectangle methodsFor: 'rectangle functions' priorSource: 1479523 inFile: 1!areasOutside: aRectangle	"Answer an Array of Rectangles comprising the parts of the receiver not 	intersecting aRectangle."	| areas yOrigin yCorner |	"Make sure the intersection is non-empty"	(origin <= aRectangle corner and: [aRectangle origin <= corner])		ifFalse: [^Array with: self].	areas _ OrderedCollection new.	aRectangle origin y > origin y		ifTrue: [areas addLast: (origin corner: corner x @ (yOrigin _ aRectangle origin y))]		ifFalse: [yOrigin _ origin y].	aRectangle corner y < corner y		ifTrue: [areas addLast: (origin x @ (yCorner _ aRectangle corner y) corner: corner)]		ifFalse: [yCorner _ corner y].	aRectangle origin x > origin x 		ifTrue: [areas addLast: (origin x @ yOrigin corner: aRectangle origin x @ yCorner)].	aRectangle corner x < corner x 		ifTrue: [areas addLast: (aRectangle corner x @ yOrigin corner: corner x @ yCorner)].	^areas! !'From Squeak 1.13 of October 17, 1996 on 31 October 1996 at 3:30:01 pm'!CharacterScanner subclass: #DisplayScanner	instanceVariableNames: 'lineY runX emphasis foregroundColor fillBlt lineHeight '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!!BitBlt methodsFor: 'accessing'!destX: x destY: y width: w height: h	"Combined init message saves 3 sends from DisplayScanner"	destX _ x.	destY _ y.	width _ w.	height _ h.! !!DisplayScanner methodsFor: 'scanning' priorSource: 941154 inFile: 2!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle 	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done lineIndex stopCondition leftInRun fore back |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.	destForm depth > 1 ifTrue:		["Set up color map for display in color"		foregroundColor _ aParagraph foregroundColor.		fore _ foregroundColor bitPatternForDepth: destForm depth.		back _ aParagraph backgroundColor bitPatternForDepth: destForm depth.		self colorMap: (Bitmap with: back first with: fore first)].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ destY _ aParagraph topAtLineIndex: linesInterval first.	lineHeight _ textStyle lineGrid.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		fillBlt destX: visibleRectangle left destY: lineY				width: leftMargin - visibleRectangle left height: lineHeight;			copyBits.		line _ aParagraph lines at: lineIndex.		lastIndex _ line first.		leftInRun<= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		runLength _ leftInRun.		destY _ lineY + (textStyle baseline - font ascent).  "fontAscent delta"		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		fillBlt destX: destX destY: lineY				width: visibleRectangle right-destX height: lineHeight;			copyBits.		lineY _ lineY + lineHeight]! !!DisplayScanner methodsFor: 'stop conditions' priorSource: 687567 inFile: 1!crossedX	"This condition will sometimes be reached 'legally' during display, when, 	for instance the space that caused the line to wrap actually extends over 	the right boundary. This character is allowed to display, even though it 	is technically outside or straddling the clipping ectangle since it is in 	the normal case not visible and is in any case appropriately clipped by 	the scanner."	self fillLeading.	^ true ! !!DisplayScanner methodsFor: 'stop conditions' priorSource: 688000 inFile: 1!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached. A check for any emphasis 	(underlining, for example) that may run the length of the run is done 	here before returning to displayLines: to do the next line."	| runLength |	self fillLeading.	lastIndex = line last ifTrue: [^true].	runX _ destX.	runLength _ text runLengthFor: (lastIndex _ lastIndex + 1).	(runStopIndex _ lastIndex + (runLength - 1)) > line last 		ifTrue: [runStopIndex _ line last].	self setStopConditions.	destY _ lineY + textStyle baseline - font ascent.  "ascent delta"	^false! !!DisplayScanner methodsFor: 'stop conditions' priorSource: 688707 inFile: 1!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	| oldX |	spaceCount _ spaceCount + 1.	oldX _ destX.	destX _ destX + spaceWidth + (line justifiedPadFor: spaceCount).	fillBlt destX: oldX destY: destY width: destX - oldX height: height; copyBits.	lastIndex _ lastIndex + 1.	^ false! !!DisplayScanner methodsFor: 'stop conditions' priorSource: 689338 inFile: 1!tab	| oldX |	oldX _ destX.	destX _ (textStyle alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	fillBlt destX: oldX destY: destY width: destX - oldX height: height;		copyBits.	lastIndex _ lastIndex + 1.	^ false! !!DisplayScanner methodsFor: 'private' priorSource: 943339 inFile: 2!addEmphasis: emphasisCode	"Set the bold-ital-under-strike emphasis."! !!DisplayScanner methodsFor: 'private'!fillLeading	"At the end of every run (really only needed when font size changes),	fill any extra leading above and below the font in the larger line height"	"Fill space above the font"	fillBlt destX: runX destY: lineY width: destX - runX height: destY - lineY;		copyBits.	"Fill space below the font"	fillBlt destY: (destY + height); height: (lineY + lineHeight) - (destY + height);		copyBits.! !!DisplayScanner methodsFor: 'private' priorSource: 944679 inFile: 2!setFont 	self textColor: foregroundColor.	^ super setFont! !!Paragraph methodsFor: 'private' priorSource: 1261154 inFile: 1!displayLines: linesInterval affectedRectangle: affectedRectangle	"This is the first level workhorse in the display portion of the TextForm routines.	It checks to see which lines in the interval are actually visible, has the	CharacterScanner display only those, clears out the areas in which display will	occur, and clears any space remaining in the visibleRectangle following the space	occupied by lastLine."	| lineGrid topY firstLineIndex lastLineIndex lastLineIndexBottom |	lineGrid _ textStyle lineGrid.	"Save some time by only displaying visible lines"	firstLineIndex _ self lineIndexOfTop: affectedRectangle top.	firstLineIndex < linesInterval first ifTrue: [firstLineIndex _ linesInterval first].	lastLineIndex _ self lineIndexOfTop: affectedRectangle bottom - 1.	lastLineIndex > linesInterval last 		ifTrue:			[linesInterval last > lastLine		 		ifTrue: [lastLineIndex _ lastLine]		  		ifFalse: [lastLineIndex _ linesInterval last]].	((Rectangle 		origin: affectedRectangle left @ (topY _ self topAtLineIndex: firstLineIndex) 		corner: affectedRectangle right @ 					(lastLineIndexBottom _ (self topAtLineIndex: lastLineIndex)					  + lineGrid))	  intersects: affectedRectangle)		ifTrue: [ " . . . (skip to clear-below if no lines displayed)"	DisplayScanner new	  displayLines: (firstLineIndex to: lastLineIndex)	  in: self clippedBy: affectedRectangle].	lastLineIndex = lastLine ifTrue: 		 [destinationForm  "Clear out white space below last line"		 	fill: (affectedRectangle left @ (lastLineIndexBottom max: affectedRectangle top)				corner: affectedRectangle bottomRight)		 	rule: rule fillColor: self backgroundColor]! !DisplayScanner removeSelector: #checkEmphasis!DisplayScanner removeSelector: #checkEmphasis!'From Squeak 1.13 of October 17, 1996 on 1 November 1996 at 10:15:23 am'!Color subclass: #NullColor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!BitBlt methodsFor: 'private' priorSource: 94632 inFile: 1!paintBits	"Perform the paint operation, which requires two calls to BitBlt."	| color oldMap saveRule |	sourceForm depth = 1 ifFalse: 		[^ self halt: 'paint operation is only defined for 1-bit deep sourceForms'].	saveRule _ combinationRule.	color _ halftoneForm.  halftoneForm _ nil.	oldMap _ colorMap.	"Map 1's to ALL ones, not just one"	self colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).	combinationRule _ Form erase.	self copyBits. 		"Erase the dest wherever the source is 1"	halftoneForm _ color.	combinationRule _ Form under.	self copyBits.	"then OR, with whatever color, into the hole"	colorMap _ oldMap.	combinationRule _ saveRule" | dot |dot _ Form dotOfSize: 32.((BitBlt destForm: Display		sourceForm: dot		fillColor: Color lightGray		combinationRule: Form paint		destOrigin: Sensor cursorPoint		sourceOrigin: 0@0		extent: dot extent		clipRect: Display boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF)) copyBits"! !!Color class methodsFor: 'instance creation'!none	^ NullColor red: 0 green: 0 blue: 0.! !!DisplayScanner methodsFor: 'scanning' priorSource: 991493 inFile: 2!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle 	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done lineIndex stopCondition leftInRun fore back |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.	destForm depth > 1 ifTrue:		["Set up color map for display in color"		foregroundColor _ aParagraph foregroundColor.		fore _ foregroundColor bitPatternForDepth: destForm depth.		back _ aParagraph backgroundColor bitPatternForDepth: destForm depth.		self colorMap: (Bitmap with: back first with: fore first)].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ destY _ aParagraph topAtLineIndex: linesInterval first.	lineHeight _ textStyle lineGrid.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		fillBlt destX: visibleRectangle left destY: lineY width: leftMargin - visibleRectangle left height: lineHeight; copyBits.		line _ aParagraph lines at: lineIndex.		lastIndex _ line first.		leftInRun<= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		runLength _ leftInRun.		destY _ lineY + (textStyle baseline - font ascent).  "fontAscent delta"		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits.		lineY _ lineY + lineHeight]! !!DisplayText methodsFor: 'converting' priorSource: 699488 inFile: 1!asParagraph	"Answer a Paragraph whose text and style are identical to that of the 	receiver."	| para |	para _ Paragraph withText: text style: textStyle.	para foregroundColor: foreColor backgroundColor: backColor.	backColor = Color none ifTrue: [para rule: Form paint].	^ para! !!DisplayText methodsFor: 'color' priorSource: 699876 inFile: 1!backgroundColor	backColor == nil ifTrue: [^ Color none].	^ backColor! !!DisplayText class methodsFor: 'examples' priorSource: 784713 inFile: 2!example	"Continually prints two lines of text wherever you point with the cursor 	and press any mouse button.  Terminate by pressing any key on the 	keyboard."	| tx |	tx _ 'this is a line of characters andthis is the second line.' asDisplayText.	tx foregroundColor: Color black backgroundColor: Color none.	tx _ tx alignedTo: #center.	[Sensor anyButtonPressed]		whileFalse:			[tx displayOn: Display at: Sensor cursorPoint]	"DisplayText example."! !!Form class methodsFor: 'mode constants' priorSource: 854493 inFile: 1!erase1bitShape	"Answer the integer denoting mode erase."	^ 26! !!Form class methodsFor: 'mode constants'!oldErase1bitShape	"Answer the integer denoting mode erase."	^ 17! !!Form class methodsFor: 'mode constants'!oldPaint	"Answer the integer denoting the 'paint' combination rule."	^16! !!Form class methodsFor: 'mode constants' priorSource: 854612 inFile: 1!paint	"Answer the integer denoting the 'paint' combination rule."	^25! !NullColor comment:'A NullColor represents a color to be used when no fill color is desired, as with the background of transparent text.  It will produce all zeroes in any color map entry initialized from it.  In combination with BitBlt paint mode (which does not store zeroes), this will result in transparency.  Note that when this approach is being used in RGB, true black will look the same as a null color, unless you put something in the alpha bits.'!NullColor comment:'A NullColor represents a color to be used when no fill color is desired, as with the background of transparent text.  It will produce all zeroes in any color map entry initialized from it.  In combination with BitBlt paint mode (which does not store zeroes), this will result in transparency.  Note that when this approach is being used in RGB, true black will look the same as a null color, unless you put something in the alpha bits.'!!NullColor methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'Color none'.! !!NullColor methodsFor: 'printing'!storeOn: aStream	aStream nextPutAll: 'Color none'.! !!NullColor methodsFor: 'conversions'!pixelWordForDepth: depth	"Answer bits that appear in a 32-bit word of a Bitmap of the given depth.	This is overridden to allow blts with transparency to work right	by specifying a null color for the background."	^ 0! !!NullColor methodsFor: 'private'!setRed: r green: g blue: b	rgb _ -1  "A fiction to avoid equality with Color black"! !!Paragraph methodsFor: 'accessing'!backgroundColor	backColor == nil ifTrue: [^ Color white].	^ backColor! !!Paragraph methodsFor: 'converting' priorSource: 1260163 inFile: 1!asForm	"Answer a Form made up of the bits that represent the receiver's 	displayable text."	| theForm |	((foreColor == nil or: [foreColor = Color black])		and: [backColor == nil or: [backColor = Color white]])		ifTrue: [theForm _ Form extent: compositionRectangle extent]		ifFalse: [theForm _ TwoToneForm extent: compositionRectangle extent.				theForm foregroundColor: (foreColor == nil ifTrue: [Color black]															ifFalse: [foreColor])						backgroundColor: (backColor == nil ifTrue: [Color white]															ifFalse: [backColor])].	self displayOn: theForm		at: 0 @ 0		clippingBox: theForm boundingBox		rule: Form over		fillColor: nil.	theForm offset: offset.	^ theForm! !!TwoToneForm methodsFor: 'as yet unclassified'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	aDisplayMedium copyBits: self boundingBox		from: self		at: aDisplayPoint + self offset		clippingBox: clipRectangle		rule: (ruleInteger = Form over ifTrue: [self paintRule] ifFalse: [ruleInteger])		fillColor: aForm! !!TwoToneForm methodsFor: 'as yet unclassified' priorSource: 1841890 inFile: 1!displayOnPort: port at: location	port colorMap: (self colorMapForDepth: port destForm depth);		copyForm: self to: location rule: self paintRule;		colorMap: nil! !!TwoToneForm methodsFor: 'as yet unclassified'!paintRule	backgroundColor = Color none		ifTrue: [^ Form paint]		ifFalse: [^ Form over]! !!View methodsFor: 'bordering' priorSource: 1895976 inFile: 1!backgroundColor	insideColor == nil ifFalse:		[(insideColor isMemberOf: Symbol) ifTrue:			[^ Color perform: insideColor].		^ insideColor].	superView == nil ifFalse: [^ superView backgroundColor].	^ Color none! !'From Squeak 1.13 of October 17, 1996 on 1 November 1996 at 3:14:13 pm'!!View methodsFor: 'bordering' priorSource: 1007659 inFile: 2!backgroundColor	insideColor == nil ifFalse:		[(insideColor isMemberOf: Symbol) ifTrue:			[^ Color perform: insideColor].		^ insideColor].	superView == nil ifFalse: [^ superView backgroundColor].	^ Color white! !'From Squeak 1.13 of October 17, 1996 on 2 November 1996 at 9:18:04 am'!ScrollController subclass: #ParagraphEditor	instanceVariableNames: 'paragraph startBlock stopBlock beginTypeInBlock emphasisHere initialText selectionShowing otherInterval '	classVariableNames: 'UndoInterval UndoSelection CurrentSelection Keyboard TextEditorYellowButtonMenu TextEditorYellowButtonMessages CmdActions UndoParagraph Undone UndoMessage ShiftCmdActions FindText ChangeText '	poolDictionaries: 'TextConstants '	category: 'Graphics-Editors'!Object subclass: #StrikeFont	instanceVariableNames: 'xTable glyphs name stopConditions type minAscii maxAscii maxWidth strikeLength ascent descent xOffset raster subscript superscript emphasis derivativeFonts '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!!CharacterScanner methodsFor: 'private'!installFont	"Install various parameters from the font."	spaceWidth _ font widthOf: Space. 	sourceForm _ font glyphs.	xTable _ font xTable.	height _ font height.	stopConditions _ font stopConditions.	stopConditions at: Space asciiValue + 1 put: #space.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX! !!CharacterScanner methodsFor: 'private' priorSource: 940227 inFile: 2!setFont	"Set the font and other emphasis."	self setFont: 1.	(text attributesAt: lastIndex) do: 		[:att | att emphasizeScanner: self].	self installFont.! !!CharacterScanner methodsFor: 'private' priorSource: 940390 inFile: 2!setFont: fontNumber	"Set the basal font from the textStyle."	font _ textStyle fontAt: fontNumber! !!DisplayScanner methodsFor: 'private' priorSource: 996532 inFile: 2!addEmphasis: emphasisCode	"Set the bold-ital-under-strike emphasis."	emphasis _ emphasis bitOr: emphasisCode! !!DisplayScanner methodsFor: 'private'!installFont 		"Use emphasis codes to select a properly emphasized version of the font"	font _ font emphasized: emphasis.	super installFont  "... and now install that font"! !!DisplayScanner methodsFor: 'private' priorSource: 997121 inFile: 2!setFont 	self textColor: foregroundColor.	emphasis _ 0.	super setFont.  "Sets font and emphasis bits"! !!Obj methodsFor: 'type' priorSource: 476411 inFile: 2!emphasisForName	"Plain text for all but Alias at present.  6/8/96 sw"	^ Array with: (TextFontChange fontNumber: 1)! !!Alias methodsFor: 'everything' priorSource: 3491 inFile: 2!emphasisForName	"Italics for Alias.   6/8/96 sw"	^ Array with: (TextFontChange fontNumber: 1)			with: TextEmphasis italic! !!ParagraphEditor methodsFor: 'editing keys' priorSource: 962536 inFile: 2!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to accept 	characters with the change in emphasis. Emphasis change amounts to a 	font change.  Keeps typeahead."	| keyCode attribute oldAttributes index |		 "control 0-9 -> 0-9"	keyCode _ 0 max: (sensor keyboard asciiValue - $0 asciiValue).	oldAttributes _ paragraph text attributesAt: startBlock stringIndex.	"Decipher keyCodes for Command 0-9..."	(keyCode between: 1 and: 4) ifTrue:		[attribute _ TextFontChange fontNumber: keyCode].	keyCode = 5 ifTrue:		[index _ (PopUpMenu labelArray: #(black magenta red yellow green blue active)							lines: #(6)) startUp.		index = 0 ifTrue: [^ true].		attribute _ index = 7		ifTrue: [TextAction evalString: self selection asString]		ifFalse: [TextColor color: (Color perform: (#(black magenta red yellow green blue cyan) at: index))]].	(keyCode between: 6 and: 9) ifTrue:		[attribute _ TextEmphasis perform:					(#(bold italic underlined struckOut) at: keyCode - 5).		oldAttributes do:			[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	(keyCode = 0) ifTrue:		[attribute _ TextEmphasis normal].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream.			emphasisHere _ Text addAttribute: attribute toArray:					oldAttributes.			^ true].	self replaceSelectionWith: (self selection addAttribute: attribute).	^ true! !!ParagraphEditor methodsFor: 'editing keys' priorSource: 1307387 inFile: 1!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  5/27/96 sw	Use only names of Fonts of this paragraph  8/19/96 tk"	| aList reply |	aList _ paragraph textStyle fontNames.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!ParagraphEditor methodsFor: 'typing support' priorSource: 1324106 inFile: 1!setEmphasisHere	emphasisHere _ paragraph text attributesAt: startBlock stringIndex! !!StandardSystemView methodsFor: 'label access' priorSource: 916511 inFile: 2!label: aString 	"Set aString to be the receiver's label."	labelText _ (Text string: ((aString == nil or: [aString isEmpty])								ifTrue: ['Untitled' copy]								ifFalse: [aString])					attributes: (Array with: (TextFontChange fontNumber: 2)										with: TextEmphasis bold)) asParagraph.	insetDisplayBox == nil ifTrue: [^ self].  "wait for further initialization"	self setLabelRegion! !!StrikeFont methodsFor: 'emphasis' priorSource: 1664315 inFile: 1!emphasized: code 	"Answer a copy of the receiver with emphasis set to include code."	| derivative addedEmphasis base g r |	code = 0 ifTrue: [^ self].	derivative _ derivativeFonts at: code.	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis _ 1 bitShift: code highBit - 1.	base _ self emphasized: code - addedEmphasis.	derivative _ base copy.	addedEmphasis = 1 ifTrue:		["Compute synthetic bold version of the font"		derivative _ base copy name: base name , 'B'.		"Make a bold set of glyphs with same widths by ORing 1 bit to the right			(requires at least 1 pixel of intercharacter space)"		g _ derivative glyphs deepCopy.		g copyBits: g boundingBox from: g at: (1@0)			clippingBox: g boundingBox rule: Form under fillColor: nil.		derivative setGlyphs: g].	addedEmphasis = 2 ifTrue:		["Compute synthetic italic version of the font"		derivative _ base copy name: base name , 'I'.		"Make an italic set of glyphs with same widths by skewing left and right			(may require more intercharacter space)"		g _ derivative glyphs deepCopy.		r _ 0 @ derivative ascent extent: g boundingBox extent.		g copyBits: r from: g at: r topLeft - (1@0)			clippingBox: r rule: Form over fillColor: nil.		r _ 0 @ 0 extent: g width @ derivative ascent - 4.		g copyBits: r from: g at: r topLeft + (1@0)			clippingBox: r rule: Form over fillColor: nil.		derivative setGlyphs: g].	addedEmphasis = 4 ifTrue:		["Compute underlined version of the font"		derivative _ base copy name: base name , 'U'.		g _ derivative glyphs deepCopy.		g fillBlack: (0 @ (derivative ascent+1) extent: g width @ 1).		derivative setGlyphs: g].	addedEmphasis = 8 ifTrue:		["Compute struck-out version of the font"		derivative _ base copy name: base name , 'Z'.		g _ derivative glyphs deepCopy.		g fillBlack: (0 @ (derivative ascent-3) extent: g width @ 1).		derivative setGlyphs: g].	derivative emphasis: code.	derivativeFonts at: code put: derivative.	^ derivative! !!StrikeFont methodsFor: 'emphasis' priorSource: 1664515 inFile: 1!emphasized: code named: aString	"Answer a copy of the receiver with emphasis set to code."	| copy |	copy _ self copy.	copy emphasis: code.	copy name: aString.	^ copy	"TextStyle default fontAt: 3		put: ((TextStyle default fontAt: 1) emphasized: 2 named: 'NewYork10i')"! !!StrikeFont methodsFor: 'emphasis'!reset	"Reset the cache of derivative emphasized fonts"	derivativeFonts _ Array new: 16! !!StrikeFont methodsFor: 'file in/out' priorSource: 871947 inFile: 2!newFromStrike: fileName	"Build an instance from the strike font file name. The '.strike' extension	is optional."	| strike startName raster16 |	name _ fileName copyUpTo: $..	"assumes extension (if any) is '.strike'".	strike _ FileStream oldFileNamed: name, '.strike.'.	strike binary.	strike readOnly.		"strip off direcory name if any"	startName _ name size.	[startName > 0 and: [((name at: startName) ~= $>) & ((name at: startName) ~= $])]]		whileTrue: [startName _ startName - 1].	name _ name copyFrom: startName+1 to: name size.	type			_		strike nextWord16.		"type is ignored now -- simplest												assumed.  Kept here to make												writing and consistency more												straightforward."	minAscii		_		strike nextWord16.	maxAscii		_		strike nextWord16.	maxWidth		_		strike nextWord16.	strikeLength	_		strike nextWord16.	ascent			_		strike nextWord16.	descent			_		strike nextWord16.	"xOffset			_"		strike nextWord16. 		raster16			_		strike nextWord16.		superscript		_		ascent - descent // 3.		subscript		_		descent - ascent // 3.		emphasis		_		0.	glyphs			_	Form extent: (raster16 * 16) @ (self height)  							offset: 0@0.		glyphs bits fromByteStream: strike.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: strike nextWord16].	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	strike close.	"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	1 to: (minAscii - 1) do:		[:index | stopConditions at: index put: #characterNotInFont].	(maxAscii + 3) to: stopConditions size do:		[:index | stopConditions at: index put: #characterNotInFont].	self reset! !!StrikeFont methodsFor: 'file in/out' priorSource: 873959 inFile: 2!readFromBitFont: fileName	"This builds a StrikeFont instance by reading the data file format	produced by BitFont, a widely available font conversion utility	written by Peter DiCamillo at Brown University"	"StrikeFont new readFromBitFont: 'Palatino10.BF' "	| f fLength lastAscii charLine width ascii charForm line missingForm tempGlyphs s nn iRect ptSize |	f _ FileStream readOnlyFileNamed: fileName.	name _ self restOfLine: 'Font name = ' from: f.	ascent _ (self restOfLine: 'Ascent = ' from: f) asNumber.	descent _ (self restOfLine: 'Descent = ' from: f) asNumber.	maxWidth _ (self restOfLine: 'Maximum width = ' from: f) asNumber.	ptSize _ (self restOfLine: 'Font size = ' from: f) asNumber. "Ignored for now"	minAscii _ 258.	maxAscii _ 0.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ 0.	type _ 0.  "ignored for now"	tempGlyphs _ Form extent: (maxWidth*257) @ self height.	xTable _ (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	self restOfLine: 'Extent information for entire font' from: f.	"Parse the foloowing line (including mispelling!!)"	"Image rectange: left = -2, right = 8, bottom = -2, top = 7"	s _ ReadStream on: (self restOfLine: 'Image rect' from: f).	s upTo: $:.	nn _ (1 to: 4) collect:		[:i | s upTo: $=; skipSeparators. Number readFrom: (s upTo: $,)].	iRect _ Rectangle left: (nn at: 1) right: (nn at: 2)				top: (nn at: 3) bottom: (nn at: 4).		"Read character forms and blt into tempGlyphs"	lastAscii _ -1.	[charLine _ self restOfLine: 'Character: ' from: f.	charLine == nil ifFalse:		[width_ (self restOfLine: 'Width (final pen position) = ' from: f) asNumber.		charLine = 'Missing character' ifTrue: [ascii _ 256].		('x''*' match: charLine) ifTrue:			[ascii _ Number readFrom: (charLine copyFrom: 3 to: 4) base: 16].		charForm _ Form extent: width@self height.		('*[all blank]' match: charLine) ifFalse:			[self restOfLine: '  +' from: f.			1 to: self height do:				[:y | line _ f upTo: Character cr.				4 to: line size+iRect left-1 do:					[:x | (line at: x-iRect left)=$* ifTrue: [charForm pixelValueAt: (x-4)@(y-1) put: 1]]]]].	charLine == nil]		whileFalse:			[self displayChar: ascii form: charForm.			ascii = 256				ifTrue: [missingForm _ charForm deepCopy]				ifFalse:				[minAscii _ minAscii min: ascii.				maxAscii _ maxAscii max: ascii.				lastAscii+1 to: ascii-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].				tempGlyphs copy: ((xTable at: ascii+1)@0										extent: charForm extent)							from: 0@0 in: charForm rule: Form over.				xTable at: ascii+2 put: (xTable at: ascii+1) + width.				lastAscii _ ascii]].	f close.	lastAscii+1 to: maxAscii+1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs _ Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable _ xTable copyFrom: 1 to: maxAscii+3.	"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	1 to: (minAscii - 1) do:		[:index | stopConditions at: index put: #characterNotInFont].	(maxAscii + 3) to: stopConditions size do:		[:index | stopConditions at: index put: #characterNotInFont].	self reset! !!StrikeFont methodsFor: 'file in/out' priorSource: 877464 inFile: 2!readFromStrike2: fileName  "StrikeFont new readFromStrike2: 'Palatino14.sf2'"	"Build an instance from the strike font stored in strike2 format.	fileName is of the form: <optional path ending non-alpha><family name><pointSize>.sf2"	| file i ptSize |	('*.sf2' match: fileName) ifFalse: [self halt.  "likely incompatible"].	name _ fileName copyUpTo: $. .  "Drop filename extension"	i _ name findLast: [:c | c isDigit not].  "Drop pointSize"	name _ name copyFrom: 1 to: i.	file _ FileStream readOnlyFileNamed: fileName.	file binary.	type _ file nextInt32.  type = 2 ifFalse: [file close. self halt "not strike2 format"].	minAscii _ file nextInt32.	maxAscii _ file nextInt32.	maxWidth _ file nextInt32.	ascent _ file nextInt32.	descent _ file nextInt32.	ptSize _ file nextInt32.  "Ignored for now"	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ file nextInt32.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: file nextInt32].	glyphs _ Form new readFrom: file.	file close.	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	1 to: (minAscii - 1) do:		[:index | stopConditions at: index put: #characterNotInFont].	(maxAscii + 3) to: stopConditions size do:		[:index | stopConditions at: index put: #characterNotInFont].	self reset! !!StrikeFont methodsFor: 'file in/out' priorSource: 879690 inFile: 2!writeAsStrike2	"Write me onto a file in strike2 format.	fileName is of the form: <family name><pointSize>.sf2"	| file |	file _ FileStream fileNamed: name , '.sf2'.	file binary.	file nextInt32Put: 2.	file nextInt32Put: minAscii.	file nextInt32Put: maxAscii.	file nextInt32Put: maxWidth.	file nextInt32Put: ascent.	file nextInt32Put: descent.	file nextInt32Put: self height.  "should be pointSize"	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		file nextInt32Put: emphasis.	(minAscii + 1 to: maxAscii + 3) do:		[:index | file nextInt32Put: (xTable at: index)].	glyphs writeOn: file.	file close.! !!StrikeFont class methodsFor: 'derivative font caching'!shutDown  "StrikeFont shutDown"	"Deallocate synthetically derived copies of base fonts to save space"	self allInstancesDo: [:sf | sf reset]! !!StrikeFont class methodsFor: 'instance creation' priorSource: 1672031 inFile: 1!fromStrike: fileName 	"Read a font from disk in the old ST-80 'strike' format.	Note: this is an old format; use strike2 format instead"	^self new newFromStrike: fileName! !!StrikeFont class methodsFor: 'examples' priorSource: 1672242 inFile: 1!example	"Displays a line of text on the display screen at the location of the cursor.	Example depends on the strike font file, 'TimesRoman10.strike'. existing."	(StrikeFont new readFromStrike2: 'NewYork12.sf2')		displayLine: 'A line of 12-pt text in New York style' at: Sensor cursorPoint	 	"StrikeFont example."! !!SystemDictionary methodsFor: 'snapshot and quit' priorSource: 845489 inFile: 2!processShutDownList	"Call the shutDown method on each object that needs to gracefully shut itself down before a snapshot."	SoundPlayer shutDown.	Smalltalk shutDown.	Delay shutDown.	Color shutDown.	ControlManager shutDown.	StrikeFont shutDown.	DisplayScreen shutDown.! !!Text methodsFor: 'emphasis' priorSource: 964518 inFile: 2!makeBoldFrom: start to: stop	^ self addAttribute: TextEmphasis bold from: start to: stop! !!Text methodsFor: 'private' priorSource: 964768 inFile: 2!becomeModern	"Text allInstancesDo: [:txt | txt becomeModern]" 	runs mapValues:	[:val | val isNumber		 ifTrue: [val = 0 ifTrue: [Array new]					ifFalse: [val\\3=0							ifTrue: [Array with: (TextFontChange fontNumber: val//3+1)]							ifFalse: [Array with: (TextFontChange fontNumber: val//3+1)										with: (TextEmphasis perform: (#(bold italic) at: val\\3))]]]		ifFalse: [val]]! !Text class comment:'A Text associates a set (Array actually) of TextAttributes with each character in its character string.  These attributes include mainly a font number and possibly some other emphasis.  Font numbers are interpreted relative to a TextStyle, which may be the default, or some other textStyle stored, along with the text, in a Paragraph.  Since most characters have the same attributes as their neighbors, the attributes are stored in a RunArray for efficiency.'!Text class comment:'A Text associates a set (Array actually) of TextAttributes with each character in its character string.  These attributes include mainly a font number and possibly some other emphasis.  Font numbers are interpreted relative to a TextStyle, which may be the default, or some other textStyle stored, along with the text, in a Paragraph.  Since most characters have the same attributes as their neighbors, the attributes are stored in a RunArray for efficiency.'!!Text class methodsFor: 'class initialization' priorSource: 1810460 inFile: 1!initialize		"Initialize constants shared by classes associated with text display."	TextConstants at: #CaretForm  		 		 put: (Cursor	extent: 16@16	fromArray: #(		2r00110000000		2r00110000000		2r01111000000		2r11111100000		2r11001100000		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 8@0).	self initTextConstants.	"Text initialize"! !!Text class methodsFor: 'instance creation' priorSource: 1813519 inFile: 1!fromString: aString 	"Answer an instance of me whose characters are those of the argument, 	aString."	^self string: aString attribute: (TextFontChange fontNumber: 1)! !!Text class methodsFor: 'instance creation'!string: aString attribute: att	"Answer an instance of me whose characters are aString.	att is a TextAttribute."	^self string: aString attributes: (Array with: att)! !!Text class methodsFor: 'instance creation' priorSource: 951534 inFile: 2!string: aString attributes: atts	"Answer an instance of me whose characters are those of the argument, 	aString. atts is an array of TextAttributes."	^self string: aString runs: (RunArray new: aString size withAll: atts)! !!TextObj methodsFor: 'access' priorSource: 699984 inFile: 2!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  5/27/96 sw	Use only names of Fonts of the Style of this paragraph  9/6/96 tk"	| aList reply new |	aList _ contents textStyle fontNames.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[new _ Text string: contents string 			attribute: (TextFontChange fontNumber: (aList indexOf: reply)).		contents replaceFrom: 1			to: contents string size			with: new			displaying: false.		self invalidateCanvas].! !!TextStyle methodsFor: 'private' priorSource: 752611 inFile: 2!newFontArray: anArray	"Currently there is no supporting protocol for changing these arrays. If an editor wishes to implement margin setting, then a copy of the default should be stored with these instance variables.  	8/20/96 tk, Make size depend on first font."	fontArray _ anArray.	lineGrid _ (anArray at: 1) lineGrid + 2.	"For whole family"	baseline _ (anArray at: 1) ascent + 1.	alignment _ 0.	firstIndent _ 0.	restIndent _ 0.	rightIndent _ 0.	tabsArray _ DefaultTabsArray.	marginTabsArray _ DefaultMarginTabsArray"TextStyle allInstancesDo: [:ts | ts newFontArray: TextStyle default fontArray]."! !!TextStyle class methodsFor: 'instance creation'!initDefaultFontsAndStyle	"This provides the system with 10 and 12-pt basal fonts.	Bold and italic versions will be automatically generated as needed"	| fontArray |		fontArray _ Array new: 2.	fontArray at: 1 put: (StrikeFont new readFromStrike2: 'NewYork10.sf2').	fontArray at: 2 put: (StrikeFont new readFromStrike2: 'NewYork12.sf2').	TextConstants at: #DefaultTextStyle put:		(TextStyle fontArray: fontArray).	"TextStyle initDefaultFontsAndStyle."! !!Utilities class methodsFor: 'support windows' priorSource: 1849246 inFile: 1!commandKeyMappings	^ self class firstCommentAt: #commandKeyMappings"Lower-case command keysa	Select allb	Browse itc	Copyd	Do ite	Exchangef	Findg	Find againh	Set Search Stringi	Inspect itj	Again oncek	Set fontl	Cancelm	Implementors of itn	Senders of ito	Spawnp	Print itq	Query symbolr	Recognizers	Save (i.e. accept)u	Alignv	Pastew	Delete preceding wordx	Cuty	Swap charactersz	UndoUpper-case command keys (Hold down Cmd & Shift, or Ctrl key)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateF	Insert 'ifFalse:'J	Again manyK	Set styleL	Outdent (move selection one tab-stop left)N	References to itR	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'W	Selectors containing itV	Paste author's initials<return>		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)esc			Select current type-inshift-delete	Forward delete character (not currently undo-able)[	Enclose within [ and ], or remove enclosing [ and ](	Enclose within ( and ), or remove enclosing ( and )   NB: use ctrl ({	Enclose within { and }, or remove enclosing { and }<	Enclose within < and >, or remove enclosing < and >'	Enclose within ' and ', or remove enclosing ' and '""	Enclose within "" and "", or remove enclosing "" and ""0	10 point font1	12 point font2	18 point font  (not in base image)3	24 point font  (not in base image)5	add color / make active	(nb: to remove the active quality of text, you must select	more than the active part and then use command-0)6	bold7	italic8	underline9	strike-out"	"Answer a string to be presented in a window at user request as a crib sheet for command-key mappings.  2/7/96 sw5/1/96 sw: modified so that the long string lives in a comment, hence doesn't take up memory.  Also, fixed up some of the actual text, and added help for parentheses-enclosing items and text-style controls.5/10/96 sw: added a bunch of changes at JM's suggestion8/11/96 sw: fixed the font sizes, added align & references to it, and help for cmd-shift-B11/2/96 di: added ctrl-return and shift-delete, and new assignments of cmd 0-9"! !Text removeSelector: #emphasisAt:!Text removeSelector: 'emphasisAt:' asSymbol!Text initialize!Text class removeSelector: #string:font:!Text class removeSelector: 'string:font:' asSymbol!Text class removeSelector: #initDefaultFontsAndStyle!Text class removeSelector: #initDefaultFontsAndStyle!TextStyle removeSelector: #propagateFontChanges!TextStyle removeSelector: #propagateFontChanges!StrikeFont shutDown!TextStyle default newFontArray:	(Array with: (TextStyle default fontAt: 1)			with: (TextStyle default fontAt: 4))!'From Squeak 1.13 of October 17, 1996 on 4 November 1996 at 7:04:07 pm'!!Text class methodsFor: 'class initialization' priorSource: 1027203 inFile: 2!initialize	"Text initialize"	"Initialize constants shared by classes associated with text display."	TextConstants at: #CaretForm put:				(Form extent: 16@5					fromArray: #(2r001100e26 2r001100e26 2r011110e26 2r111111e26 2r110011e26)					offset: -3@0).	self initTextConstants! !Text initialize!'From Squeak 1.13 of October 17, 1996 on 2 November 1996 at 11:24:47 pm'!!ChangeList methodsFor: 'menu actions'!promptForStartingPoint	| banners indices index |	banners _ OrderedCollection new.	indices _ OrderedCollection new.	changeList doWithIndex:		[:c :i | (c type = #doIt and: ['do it: ----*' match: (list at: i)])			ifTrue: [banners addLast: ((list at: i) copyFrom: 12 to: (list at: i) size).					indices addLast: i]].	index _ (SelectionMenu labelList: banners selections: indices)				startUpWithCaption: 'Browse as far back as...'.	index ==nil ifTrue: [^ false].	1 to: index-1 do: [:i | listSelections at: i put: true].	self removeSelections.	^ true! !!ChangeList class methodsFor: 'public access'!browseRecentFromMenu: charCount    "ChangeList browseRecentFromMenu: 50000"	"Opens a changeList on the end of the changes log file"	| changesFile changeList end |	changesFile _ (SourceFiles at: 2) readOnlyCopy.	end _ changesFile size.	Cursor read showWhile:		[changeList _ self new			scanFile: changesFile from: (0 max: end-charCount) to: end].	changesFile close.	changeList promptForStartingPoint ifFalse: [^ self].	self open: changeList name: 'Recent changes'! !!ScreenController methodsFor: 'menu messages' priorSource: 1530675 inFile: 1!browseRecentChanges	"Open a changelist browser on the tail end of the changes log"	ChangeList browseRecentFromMenu: 50000! !!ScreenController methodsFor: 'nested menus' priorSource: 1537317 inFile: 1!changesMenu	"Answer a menu for changes-related items.  2/4/96 sw	 5/8/96 sw: divided changelist options into two	 5/17/96 sw: added browse recent submissions"	ChangesMenu == nil ifTrue: 		[ChangesMenu _ SelectionMenu labelList:		#(	'file out changes'			'browse changed methods'			'browse recent submissions'			'post-snapshot change log'			'recent change log')		lines: #(1 3)		selections: #(fileOutChanges browseChangedMessages browseRecentSubmissions browsePostSnapshotChanges browseRecentChanges)].	^ ChangesMenu"ScreenController new changesMenu startUp"! !!ScreenController methodsFor: 'nested menus' priorSource: 1538486 inFile: 1!openMenu	"Answer a menu for open-related items.  2/4/96 sw	 5/10/96 sw: useful expressions moved to help menu"	OpenMenu == nil ifTrue:		[OpenMenu _ SelectionMenu labelList:		#(	'open browser'			'open workspace'			'open file list'			'open change sorter'			'open project'			'open transcript'			'open system workspace')		selections: #(openBrowser openWorkspace openFileList openChangeManager openProject openTranscript  openSystemWorkspace)].	^ OpenMenu"ScreenController new openMenu startUp"! !!ScreenController class methodsFor: 'class initialization' priorSource: 906103 inFile: 2!initialize	"Initialize the screen menus.  Call this method to reset everything back to nil, so that the various menu retrieval methods will duly reinitialize them.  7/24/96 sw" 	"ScreenController initialize"	ChangesMenu _ HelpMenu _ TopScreenMenu _ OpenMenu _ WindowMenu _ ProjectScreenMenu _ nil.	Smalltalk hyperSqueakPresent ifTrue: [self installScottsScreenMenu]! !ScreenController initialize!'From Squeak 1.13 of October 17, 1996 on 4 November 1996 at 4:32:38 pm'!!ChangeList class methodsFor: 'public access' priorSource: 237995 inFile: 1!browseRecentLog    "ChangeList browseRecentLog"	"Prompt with a menu of how far back to go"	| end changesFile banners positions pos chunk i |	changesFile _ (SourceFiles at: 2) readOnlyCopy.	banners _ OrderedCollection new.	positions _ OrderedCollection new.	end _ changesFile size.	pos _ Smalltalk lastQuitLogPosition.	[pos > 0 or: [banners size > 20]] whileTrue:		[changesFile position: pos.		chunk _ changesFile nextChunk.		i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos _ Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos _ 0]].	changesFile close.	pos _ (SelectionMenu labelList: banners reversed selections: positions reversed)				startUpWithCaption: 'Browse as far back as...'.	pos == nil ifTrue: [^ self].	self browseRecent: end-pos! !!ScreenController methodsFor: 'nested menus' priorSource: 1034978 inFile: 2!changesMenu	"Answer a menu for changes-related items.  2/4/96 sw	 5/8/96 sw: divided changelist options into two	 5/17/96 sw: added browse recent submissions"	ChangesMenu == nil ifTrue: 		[ChangesMenu _ SelectionMenu labelList:		#(	'file out changes'			'browse changed methods'			'browse recent submissions'			'recent change log')		lines: #(1 3)		selections: #(fileOutChanges browseChangedMessages browseRecentSubmissions browseRecentLog)].	^ ChangesMenu"ScreenController new changesMenu startUp"! !!ScreenController class methodsFor: 'class initialization' priorSource: 1036234 inFile: 2!initialize	"Initialize the screen menus.  Call this method to reset everything back to nil, so that the various menu retrieval methods will duly reinitialize them.  7/24/96 sw"	"ScreenController initialize"	ChangesMenu _ HelpMenu _ TopScreenMenu _ OpenMenu _ WindowMenu _ ProjectScreenMenu _ nil.	Smalltalk hyperSqueakPresent ifTrue: [self installScottsScreenMenu]! !!SystemDictionary methodsFor: 'snapshot and quit' priorSource: 1792904 inFile: 1!snapshot: save andQuit: quit	"Mark the changes file and close all files.  If save is true, save the current state of this Smalltalk in the image file.  If quit is true, then exit to the outer shell.  Note: latter part of this method runs when resuming a previously saved image. 	1/17/96 sw: ripped out the disk-library maintenance stuff	5/8/96 sw: report snapshot/quit to transcript as well as chgs log"	| resuming msg |	save & (SourceFiles at: 2) notNil ifTrue:		[msg _  (quit			ifTrue: ['----QUIT----']			ifFalse: ['----SNAPSHOT----'])			, Date dateAndTimeNow printString			, ( ' priorSource: ' , LastQuitLogPosition printString).		LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position.		self logChange: msg.		Transcript cr; show: msg].	self processShutDownList.	Cursor write show.	save ifTrue: [resuming _ self snapshotPrimitive]  "<-- PC frozen here on image file"		ifFalse: [resuming _ false].	quit & resuming not ifTrue: [self quitPrimitive].	Cursor normal show.	self processStartUpList.	! !ChangeList removeSelector: #promptForStartingPoint!ChangeList removeSelector: #promptForStartingPoint!ChangeList class removeSelector: #browseRecentFromMenu:!ChangeList class removeSelector: 'browseRecentFromMenu:' asSymbol!ScreenController removeSelector: #browsePostSnapshotChanges!ScreenController removeSelector: #browsePostSnapshotChanges!ScreenController removeSelector: #browseRecentChanges!ScreenController removeSelector: #browseRecentChanges!ScreenController initialize!'From Squeak 1.13 of October 17, 1996 on 3 November 1996 at 11:01:39 pm'!Object subclass: #StrikeFont	instanceVariableNames: 'xTable glyphs name stopConditions type minAscii maxAscii maxWidth strikeLength ascent descent xOffset raster subscript superscript emphasis derivativeFonts pointSize '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!!ExternalStream methodsFor: 'accessing'!nextInto: buffer 	"fill buffer from my collection"	(buffer isMemberOf: Bitmap) ifTrue:		[1 to: buffer size do:			[:index | buffer at: index put: (self nextNumber: 4)].		^ buffer].	1 to: buffer size do:		[:index | buffer at: index put: self next].	^ buffer! !!ExternalStream methodsFor: 'nonhomogeneous accessing' priorSource: 719605 inFile: 1!nextNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger."	| s |	s _ 0.	1 to: n do: 		[:i | s _ (s bitShift: 8) bitOr: self next].	^ s normalize! !!Form methodsFor: 'copying'!copy: sourceRectangle from: sourceForm to: destPt rule: rule	^ self copy: (destPt extent: sourceRectangle extent)		from: sourceRectangle topLeft in: sourceForm rule: rule! !!StrikeFont methodsFor: 'file in/out' priorSource: 1016297 inFile: 2!newFromStrike: fileName	"Build an instance from the strike font file name. The '.strike' extension	is optional."	| strike startName raster16 |	name _ fileName copyUpTo: $..	"assumes extension (if any) is '.strike'".	strike _ FileStream oldFileNamed: name, '.strike.'.	strike binary.	strike readOnly.		"strip off direcory name if any"	startName _ name size.	[startName > 0 and: [((name at: startName) ~= $>) & ((name at: startName) ~= $])]]		whileTrue: [startName _ startName - 1].	name _ name copyFrom: startName+1 to: name size.	type			_		strike nextWord16.		"type is ignored now -- simplest												assumed.  Kept here to make												writing and consistency more												straightforward."	minAscii		_		strike nextWord16.	maxAscii		_		strike nextWord16.	maxWidth		_		strike nextWord16.	strikeLength	_		strike nextWord16.	ascent			_		strike nextWord16.	descent			_		strike nextWord16.	"xOffset			_"		strike nextWord16. 		raster16			_		strike nextWord16.		superscript		_		ascent - descent // 3.		subscript		_		descent - ascent // 3.		emphasis		_		0.	glyphs			_	Form extent: (raster16 * 16) @ (self height)  							offset: 0@0.		glyphs bits fromByteStream: strike.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: strike nextWord16].	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	strike close.	self setStopConditions ! !!StrikeFont methodsFor: 'file in/out'!readBFHeaderFrom: f	name _ self restOfLine: 'Font name = ' from: f.	ascent _ (self restOfLine: 'Ascent = ' from: f) asNumber.	descent _ (self restOfLine: 'Descent = ' from: f) asNumber.	maxWidth _ (self restOfLine: 'Maximum width = ' from: f) asNumber.	pointSize _ (self restOfLine: 'Font size = ' from: f) asNumber.	name _ (name copyWithout: Character space) ,				(pointSize < 10					ifTrue: ['0' , pointSize printString]					ifFalse: [pointSize printString]).	minAscii _ 258.	maxAscii _ 0.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ 0.	type _ 0.  "ignored for now"! !!StrikeFont methodsFor: 'file in/out' priorSource: 1018352 inFile: 2!readFromBitFont: fileName	"This builds a StrikeFont instance by reading the data file format	produced by BitFont, a widely available font conversion utility	written by Peter DiCamillo at Brown University"	"StrikeFont new readFromBitFont: 'Palatino10.BF' "	| f fLength lastAscii charLine width ascii charForm line missingForm tempGlyphs s nn iRect ptSize |	f _ FileStream readOnlyFileNamed: fileName.	self readBFHeaderFrom: f.	tempGlyphs _ Form extent: (maxWidth*257) @ self height.	xTable _ (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	self restOfLine: 'Extent information for entire font' from: f.	"Parse the foloowing line (including mispelling!!)"	"Image rectange: left = -2, right = 8, bottom = -2, top = 7"	s _ ReadStream on: (self restOfLine: 'Image rect' from: f).	s upTo: $:.	nn _ (1 to: 4) collect:		[:i | s upTo: $=; skipSeparators. Number readFrom: (s upTo: $,)].	iRect _ Rectangle left: (nn at: 1) right: (nn at: 2)				top: (nn at: 3) bottom: (nn at: 4).		"Read character forms and blt into tempGlyphs"	lastAscii _ -1.	[charLine _ self restOfLine: 'Character: ' from: f.	charLine == nil ifFalse:		[width_ (self restOfLine: 'Width (final pen position) = ' from: f) asNumber.		charLine = 'Missing character' ifTrue: [ascii _ 256].		('x''*' match: charLine) ifTrue:			[ascii _ Number readFrom: (charLine copyFrom: 3 to: 4) base: 16].		charForm _ Form extent: width@self height.		('*[all blank]' match: charLine) ifFalse:			[self restOfLine: '  +' from: f.			1 to: self height do:				[:y | line _ f upTo: Character cr.				4 to: line size+iRect left-1 do:					[:x | (line at: x-iRect left)=$* ifTrue: [charForm pixelValueAt: (x-4)@(y-1) put: 1]]]]].	charLine == nil]		whileFalse:			[self displayChar: ascii form: charForm.			ascii = 256				ifTrue: [missingForm _ charForm deepCopy]				ifFalse:				[minAscii _ minAscii min: ascii.				maxAscii _ maxAscii max: ascii.				lastAscii+1 to: ascii-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].				tempGlyphs copy: ((xTable at: ascii+1)@0										extent: charForm extent)							from: 0@0 in: charForm rule: Form over.				xTable at: ascii+2 put: (xTable at: ascii+1) + width.				lastAscii _ ascii]].	f close.	lastAscii+1 to: maxAscii+1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs _ Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable _ xTable copyFrom: 1 to: maxAscii+3.	self setStopConditions! !!StrikeFont methodsFor: 'file in/out' priorSource: 1021900 inFile: 2!readFromStrike2: fileName  "StrikeFont new readFromStrike2: 'Palatino14.sf2'"	"Build an instance from the strike font stored in strike2 format.	fileName is of the form: <family name><pointSize>.sf2"	| file |	('*.sf2' match: fileName) ifFalse: [self halt.  "likely incompatible"].	name _ fileName copyUpTo: $. .  "Drop filename extension"	file _ FileStream readOnlyFileNamed: fileName.	file binary.	self readFromStrike2Stream: file! !!StrikeFont methodsFor: 'file in/out'!readFromStrike2Stream: file 	"Build an instance from the supplied binary stream on data in strike2 format"	type _ file nextInt32.  type = 2 ifFalse: [file close. self halt "not strike2 format"].	minAscii _ file nextInt32.	maxAscii _ file nextInt32.	maxWidth _ file nextInt32.	ascent _ file nextInt32.	descent _ file nextInt32.	pointSize _ file nextInt32.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ file nextInt32.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: file nextInt32].	glyphs _ Form new readFrom: file.	file close.	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	self setStopConditions! !!StrikeFont methodsFor: 'file in/out'!setStopConditions	"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	1 to: (minAscii - 1) do:		[:index | stopConditions at: index put: #characterNotInFont].	(maxAscii + 3) to: stopConditions size do:		[:index | stopConditions at: index put: #characterNotInFont].	self reset! !!StrikeFont methodsFor: 'file in/out' priorSource: 1023693 inFile: 2!writeAsStrike2	"Write me onto a file in strike2 format.	fileName is of the form: <family name><pointSize>.sf2"	| file |	file _ FileStream fileNamed: name , '.sf2'.	file binary.	file nextInt32Put: 2.	file nextInt32Put: minAscii.	file nextInt32Put: maxAscii.	file nextInt32Put: maxWidth.	file nextInt32Put: ascent.	file nextInt32Put: descent.	file nextInt32Put: pointSize.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		file nextInt32Put: emphasis.	(minAscii + 1 to: maxAscii + 3) do:		[:index | file nextInt32Put: (xTable at: index)].	glyphs writeOn: file.	file close.! !!StrikeFont class methodsFor: 'examples'!convertFontsNamed: familyName  " StrikeFont convertFontsNamed: 'NewYork' "	"This utility is for use after you have used BitFont to produce data files 	for the fonts you wish to use.  It will read the BitFont files and then 	write them out in strike2 (*.sf2) format which is much more compact,	and which can be read in again very quickly."	"For this utility to work as is, the BitFont data files must be named	'familyNN.BF', and must reside in the same directory as the image."	| f |	(FileDirectory default fileNamesMatching: familyName , '*.BF') do:		[:fname | Transcript cr; show: fname.		f _ StrikeFont new readFromBitFont: fname.		f writeAsStrike2]! !!StrikeFont class methodsFor: 'examples'!hackDefaultStyle		"StrikeFont hackDefaultStyle"	"Assumes that NewYork was created as a subclass with class methods	sizeNN defined following the comment in size:fromLiteral:"	TextStyle default newFontArray:		(Array with: NewYork size10				with: NewYork size12				with: NewYork size18				with: NewYork size24)	"Needless to say, an initialize method in such a fontSet class could invoke	this kind of setup at fileIn time, followed immediately by throwing the class	away, since it is wasted space after the fonts have been installed"! !!StrikeFont class methodsFor: 'examples'!size: pointSize fromLiteral: aString	"This method allows a font set to be captured as sourcecode in a subclass.	The string literals will presumably be created by printing, eg,		(FileStream readOnlyFileNamed: 'Palatino24.sf2') contentsOfEntireFile,		and then pasting into a browser after a heading like, eg,size24	^ self size: 24 fromLiteral:	'--unreadable binary data--'	See the method hackDefaultStyle to see how this can be used"	^ (StrikeFont new readFromStrike2Stream:		(ExternalStream on: aString asByteArray from: 1 to: aString size))		name: self name , (pointSize < 10 ifTrue: ['0' , pointSize printString]										ifFalse: [pointSize printString])! !'From Squeak 1.13 of October 17, 1996 on 5 November 1996 at 9:40:30 am'!StrikeFont subclass: #NewYork	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Support'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NewYork class!NewYork class comment:'A quick hack to allow fonts to be included in fileIns without too much trouble.'!NewYork class comment:'A quick hack to allow fonts to be included in fileIns without too much trouble.'!!NewYork class methodsFor: 'font creation'!size10		"(FileStream readOnlyFileNamed: 'NewYork10.sf2') contentsOfEntireFile"	^ self size: 10 fromLiteral: '             
   
                                         	   
                                                                      %   )   -   5   ;   D   L   P   U   Z   `   f   j   o   s   x   ~                                                                              $  .  6  <  C  I  Q  W  ]  e  m  w  }                                              	        "  &  .  6  @  F  N  S  W  Y  ]  b  c  k  s  y                                                      #  +  3  7  <  B  I  O  U  ]  d  k  r  {  ~                                                                         	           #  &  ''  -  5  <  EP                                                                                     h@    0                                    
                                                                                   @   H B@B  8                  (                 P!!  qpO   xww;9|=www    `            	"}q
(0(%R( D <JD          	@       ST!!  "( #Q$I("B1$Q"ER""$H  `              	%$                    	"@'' (      9  P         E @  	N 
($AP"A"1$Q"@B""@A 808t2;8<3  #8pc8""88(P@`|~   En    Gp       	`@  2A<I"q#QR$Q"0B"!!PAAA@"$I(BddIDQI 8$H"DQEfg$QEH
EV &  E            E@@<'' P"A	#QR''<B!!AP@!!*"/$"  #<y}""$QEH
9+T |  *!!E Ew F        B@  @" P"A"Q2$(B!!AP!!@""(pB$" 	  $H"DA""$QEH
+V  2A>>E    A$         D@!!   "@"!!	DQ$I"B$2$$DB H "$I("$$H8@PPBI $$H"DQE""$QEI
D(P    2EE ""E    @        F`!!  s!!  x''wsx 808y89@PC }N:tc8wws8>8    ~\9 *ww8n                      `                                            	                                                                                                                      x     p      @           @                                                  '! !!NewYork class methodsFor: 'font creation'!size12		"(FileStream readOnlyFileNamed: 'NewYork12.sf2') contentsOfEntireFile"	^ self size: 12 fromLiteral: '                                                         	   
                                                                      &   *   .   6   <   D   M   Q   V   [   a   g   k   p   t   z                                                                	      !!  %  *  2  9  E  N  V  ^  f  n  t  |                                                   ,  4  ;  C  K  Q  W  ]  e  m  y                                                  !!  (  ,  0  4  8  @  G  N  U  \  c  k  s  {                                                            	  
      !!  #  $  %  &  ''  (  /  6  >  ?  I  S  [  g  r  w                           I                                                                                                                                                                                                                                         T 	    `    @   @                                                     	        0                                 0                            	     d 
 (d@B                                              (Q   #|A   >?~<spw8w"@  $             4"($D
!!I  0 T  @   |   R 
         )$   dI@	"@  " "DB!!0c)$""                  XH@    `               	!!	"(HT$@DI                      E  N  !! A@$$@ <
 B!!0b	
	"!!* q$Y9gwww| HG8pDDX0`#0r(U (D@   (
P@  $w            U !! Bx$BB
$B!!(	
	!!U!!IFD"#&dNDD"""""D 
HH"D$$H"DH((iT |I"D@   (
PA    ""QD          @0 D !! "!!$ <~!!(R		!!U   (!!!!"""%DDHHP@""""	 "HA2PBDDD
(H	(  ? I)H@%  DPy   A"_D             @|!!!!?"` P$B!!%"R		@A U D(!!?"""&DDHHP8!!AT >
HF4h~DDD
(H	
  $ |P@H |PA  AQD            (@ @ !!" B P B!!%"2		 !! " BD(!! !!"%DDHHP!!AT  AHHH"D @DDD
(H	p(h  D
   "
P@H  PA    "_D            ( D$@HB$   DB!!""1!!@@" B  FD""$DDDD "D ADHH"D$$DDDH"DH (  D$@"$@H                0 Hw0A D@ @q>?p8q;rw@" "  qw.8aw| N:t0`GGG@ )  8  @%"Iq|                  	       @  <               @         0&                                  @                                                                        p                      0                               0 T                                                              0                                                                      @                                                                                    '! !!NewYork class methodsFor: 'font creation'!size18		"(FileStream readOnlyFileNamed: 'NewYork18.sf2') contentsOfEntireFile"	^ self size: 18 fromLiteral:'                                                                                                                                                "   .   :   J   Z   `   h   p   x                                            "  (  0  :  B  L  \  l  x                             (  6  B  L  X  f  t                                     ,  4  :  F  N  ^  j  t                              
  
    *  6  B  P  ^  l  v                                    $  .  8  D  P  \  h  p  x                                                    "  ,  ,  <  F  P  V  V  V  V  V  V  b  n  ~                            #  /  ?  PP                                                                                                                                                                                                                                                                                                                               0 0                                      1   `"                                                                     @0                                                                                                                                              A                 0                                                                                              @  ?`        yppp>xq<98!!        p                       @  @   H             8      B@>G<    00       @ @    `      ?     *	`     A?      c0 08 cff0 a!! P      0 `                     @ @0@ H  (
	  d @
$ 0# l   	 0cCf   00       @ @0    a @        I	 `T     !!  @C!!    @  8#0 88 0`$b0 b       p                         0`" `0  @D        $a l!!  	Q  ,F             0p@    !!   pp      @H	 ` 08     @  C`     @  8  0 8,, 0` `0 a 2          0   `          0             0`                                ` l!!  	  ,             0p     A        @h@ 08      >  `     @< L0  0 ,,,!!`0 `0 a 4  @   >xv7 `\\pp|q; 00 `0>xxxqq  xla      L60      00`0            x @ 0T    ?8 `  B L0  0 ,L&!!`0 `0 a @ @   c`309@`0300C`F 00 `01c1303`3000   >lc|    LAf9800   00`1<            <   0    | q  0 0 &L&!!`0`0 2@@0     C1a0a1ga00A09  `01C1afa1af00  2GOlf     f0`0"@   `?`              0    8> 0 <0 &#!!`0`0 2@0     1a0 `0ca00 0p  `0pp`fa1af00  2 cla9    A`; p80D    `1`                0 ?       $0 0 ##!!p`0 `0 2@`    1a0 `0ca 00    h`0ll`1af00  2 yaE   A  Y0   `0             0h 0     @    @ $0 0 #!! `0 ``0  `    31a 0 `0ca x00 p  h`0030``1af00  2 > laA   `0 1    `0        ?        	H0 0          $0!!!! 0` ``0  &    c1a 0`0ca 00w   80`1c1``1af00  2   laE    `  0 0   0pF                IH8          #0!!  0```  #    c1a0`0ca00w 80`@1c1`&	`1af00  2CC  la9   `  0F0D    0pF               *HL        c00  c `@ A C    gN`30``032" 0augYu1C103099  c  lc    1c `  x00"@0 0<@                 0     1 < p  @1pp`> A  9pyyp" >9cxxxx  >  ln|   >   	p00        @                                       <               0                                                          A                                                                                                    ?                           x                                                    0 0                             8  1      @                                                                                                                                                           @                                                         0                                                                                                                                                                                                                                                                                                                                                      '! !!NewYork class methodsFor: 'font creation'!size24		"(FileStream readOnlyFileNamed: 'NewYork24.sf2') contentsOfEntireFile"	^ self size: 24 fromLiteral:'                                                                                                                                                 *   :   H   Z   n   t   ~                                    &  6  F  V  f  l  r  |                      $  6  B  L  \  l                      4  D  T  `  h  v  ~                      
      *  2  J  Z  h  x                    
      $  0  0  D  X  f  t                        $  2  @  H  P  X  `  p  ~                        &  4  D  V  d  v                                                ,  4  4  4  4  4  4  B  P  b  r                  	  	  	  	  	&  	6  	J  	b	b                                                                                                                                                                                  8@                                                                                                                           @       @                                                                                           <                                                           	    G                                                                                                8                                @      @                                                                           @            0  0                                                       	                                                     8                                                                             !!     @      0                 ?~ ?00 0@                                       @  >                            D   ?        >                                     !! x   @$     01 ?1 `11         08`   0``0`C0 0A00 0   0    `                              8 @  8` 0`  P  @    (      P    
    D  3G `0      p                        
P        !! X A       `` @@ @  ```        `a   ```0````0A 0A 0 1   p                                      `  `a ```  	    D ""         D  !! ```      00                       D @           !!H	 A       `` ` @ 0  @`         `# A  ` 0`0`a0   0 0     0                                        0`!!` 0`                                           8`  `@`       p @               8       0D0@            @         `  `  p `  ``           `   0 0`0`a 0  b 00 0     0                                   @    0 `0 0`                                            `   ``         ``            ,        00"            @@        `  ` @| `  p`  @       `   0!!``a 0  b  00 0   39x x8px	~?|>}    ` `0!!` | | x	  p   ` p x`          0``        ,          A          @  $@   `     9 `     @  `    !!``` 0  4  `0 0   87|x70@    ` `!!`c8cc8c0````````  
` |`      #0`c        D @3        !!''         	    @   `     `   ` `a  @ !!`` 0  4 h `0 0   8p0a<88x0@   ` a!!`0`0`0`8888<80`0`````````  ` ` a`     #!!0 F0`     F `        @!!$$         @   @    ` 0  ``     `    #!!`1> 0   h 0 0   000!! 0`@   ` !!`0`0`000`0`````````   `00     Ap00`"@     F `         `A$$         p @`   @    `  `  31`  8<`0 `a  #!!pqf  0     0 0 0    80`@00`@ @   ` a!!` `  ` `1`1`0````````  2` `@#     C`8D       0     `A''         X 0     `    ` a`    @0f`0  `   C!!oc 0    , 000    0`00  0    ` `!!`  8  `1`0````````  2` p`a D      a0p      0    @0          L     @    `   ` `` ` `    ``  `  p C!!gc 0    , 000   0` 00 x  08  ?` `!!``6 ` `  `1`0````````  2` } v`a D          l b0`                 0            L$    @    `   `  `` `   @`  `  8 C`a 0 @ h F 0 0 0   0` 00 @  0  @`` ```1`1 `  `1`0````````  2`  `a D      d0  D              A ''           Lf    @    ` 0  `  `` `     @` `  @ 0` 0` 0 @ h F 0 0 0   0` `00 @ `  @`0 `!! 0``a`a `  `1`0````````  2` ` D          h0              "              Lf    @    `    `  ``` `     @`  @ 0` 0` 0 @ h  00 `0   800!! 00  	   @`0`!! 0`0800 0`0`````````  `0x `@#         0`                          Hf        ` @    `@ @@   @   q `  ```` ```a0 @ 0`  00 `0   x808a80     0`a ```01x18`0`0`pppp  `0  `00        70`D                ?           P$    0 0 1    00        `   08`   `0` 0`q 0  0`00 00   <`00 @ A   08` `0< ?x?xc0?`?`?`?`  ``   `a`        XC"@    3           y            `    0 0            `  ?  >~   8  ?  0`0 00# 9p?| @ A }  >  0p0pp  p~~~~>~  p @@@@  ~              ?  ?             H           @      @                                                                                     0  0                                                                                                                                                                        H              @       @             |                                                                        <                                                      @                                                                                                                      H                                                                              0                                                                                           @                                                                                                                         H                                                                               1                                                               >  |             p                                                                                                                                     p 0                                                                                                                                                                   `                                                                                                                                      ` 0       '! !'From Squeak 1.13 of October 17, 1996 on 4 November 1996 at 12:54:20 pm'!CharacterScanner subclass: #CompositionScanner	instanceVariableNames: 'spaceX spaceIndex lineHeight baseline '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!DisplayText subclass: #Paragraph	instanceVariableNames: 'clippingRectangle compositionRectangle destinationForm rule mask marginTabsLevel lines lastLine'	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Display Objects'!Paragraph subclass: #ListParagraph	instanceVariableNames: ''	classVariableNames: 'ListStyle '	poolDictionaries: ''	category: 'Graphics-Display Objects'!Object subclass: #PopUpMenu	instanceVariableNames: 'labelString font lineArray frame form marker selection '	classVariableNames: 'CacheMenuForms MenuStyle '	poolDictionaries: ''	category: 'Interface-Menus'!Interval subclass: #TextLineInterval	instanceVariableNames: 'internalSpaces paddingWidth lineHeight baseline '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!Object subclass: #TextStyle	instanceVariableNames: 'fontArray fontFamilySize lineGrid baseline alignment firstIndent restIndent rightIndent tabsArray marginTabsArray leading '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!!CompositionScanner methodsFor: 'scanning' priorSource: 485603 inFile: 1!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	spaceX _ destX _ leftMargin _ aParagraph leftMarginForCompositionForLine: lineIndex.	destY _ 0.	rightMargin _ aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex _ startIndex.	"scanning sets last index"	lineHeight _ baseline _ 0.  "will be increased by setFont:"	self setStopConditions.	"also sets font"	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ super				scanCharactersFrom: lastIndex				to: runStopIndex				in: text string				rightX: rightMargin				stopConditions: stopConditions				displaying: false.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!CompositionScanner methodsFor: 'scanning'!setFont: fontNumber	"Keep track of max height and ascent for auto lineheight"	super setFont: fontNumber.	lineHeight _ lineHeight max: font height.	baseline _ baseline max: font ascent.! !!DisplayScanner methodsFor: 'scanning' priorSource: 1000410 inFile: 2!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle 	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done lineIndex stopCondition leftInRun fore back |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.	destForm depth > 1 ifTrue:		["Set up color map for display in color"		foregroundColor _ aParagraph foregroundColor.		fore _ foregroundColor bitPatternForDepth: destForm depth.		back _ aParagraph backgroundColor bitPatternForDepth: destForm depth.		self colorMap: (Bitmap with: back first with: fore first)].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ destY _ aParagraph topAtLineIndex: linesInterval first.	lineHeight _ textStyle lineGrid.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt destX: visibleRectangle left destY: lineY width: leftMargin - visibleRectangle left height: lineHeight; copyBits.		lastIndex _ line first.		leftInRun<= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		runLength _ leftInRun.		destY _ lineY + (line baseline - font ascent).  "fontAscent delta"		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits.		lineY _ lineY + lineHeight]! !!ListParagraph class methodsFor: 'initialization'!initialize  "ListParagraph initialize"	"Allow different line spacing for lists"	ListStyle _ TextStyle default copy gridForFont: 1 withLead: 1.	self allInstancesDo: [:lp | lp fixup]! !!ListParagraph class methodsFor: 'instance creation' priorSource: 1023943 inFile: 1!withArray: anArray	"Convert an array of strings into a ListParagraph."	^ (super withText: Text new style: ListStyle) withArray: anArray! !!ListView methodsFor: 'initialize-release' priorSource: 1024672 inFile: 1!initialize 	"Refer to the comment in View|initialize."	super initialize.	topDelimiter _ '------------'.	bottomDelimiter _ '------------'.	isEmpty _ true.	self list: Array new! !!ListView methodsFor: 'list access' priorSource: 1024978 inFile: 1!list: anArray 	"Set the list of items the receiver displays to be anArray."	| arrayCopy i |	isEmpty _ anArray isEmpty.	arrayCopy _ Array new: (anArray size + 2).	arrayCopy at: 1 put: topDelimiter.	arrayCopy at: arrayCopy size put: bottomDelimiter.	i _ 2.	anArray do: [:el | arrayCopy at: i put: el. i _ i+1].	arrayCopy _ arrayCopy copyWithout: nil.	list _ ListParagraph withArray: arrayCopy.	selection _ 0.	self positionList! !!ListParagraph methodsFor: 'private'!fixup	"Fix up old Listparagraphs during text changes ** then remove"	textStyle _ ListStyle.	1 to: lastLine do:		[:i |	(lines at: i) lineHeight: textStyle lineGrid baseline: textStyle baseline].! !!ListParagraph methodsFor: 'private' priorSource: 1022640 inFile: 1!withArray: anArray 	"Modifies self to contain the list of strings in anArray"	| startOfLine endOfLine lineIndex aString item interval |	lines _ Array new: 20.	lastLine _ 0.	startOfLine _ 1.	endOfLine _ 1.	lineIndex _ 0.	anArray do: 		[:item | 		endOfLine _ startOfLine + item size.		"this computation allows for a cr after each line..."												"...but later we will adjust for no cr after last line"		lineIndex _ lineIndex + 1.		self lineAt: lineIndex put:			((TextLineInterval start: startOfLine stop: endOfLine				internalSpaces: 0 paddingWidth: 0)				lineHeight: textStyle lineGrid baseline: textStyle baseline).		startOfLine _ endOfLine + 1].	endOfLine _ endOfLine - 1.		"endOfLine is now the total size of the text"	self trimLinesTo: lineIndex.	aString _ String new: endOfLine.	anArray with: lines do: 		[:item :interval | 		aString			replaceFrom: interval first			to: interval last - 1			with: item			startingAt: 1.		interval last <= endOfLine ifTrue: [aString at: interval last put: Character cr]].	lineIndex > 0 ifTrue: [(lines at: lineIndex) stop: endOfLine].	"adjust for no cr after last line"	self text: aString asText.	self updateCompositionHeight! !!PopUpMenu methodsFor: 'displaying' priorSource: 775345 inFile: 2!displayAt: aPoint withCaption: captionOrNil during: aBlock	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."	| delta savedArea captionView captionSave outerFrame captionText tFrame frameSaveLoc |	frame _ frame align: marker leftCenter with: aPoint + (2@0).	outerFrame _ frame.	captionOrNil notNil ifTrue:		[captionText _ DisplayText				text: captionOrNil asText				textStyle: MenuStyle.		tFrame _ captionText boundingBox insetBy: -2.		outerFrame _ frame merge: (tFrame align: tFrame bottomCenter					with: frame topCenter + (0@2))].	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	frame moveBy: delta.	captionOrNil notNil ifTrue:		[captionView _ DisplayTextView new model: captionText.		captionView align: captionView boundingBox bottomCenter					with: frame topCenter + (0@2).		captionView insideColor: Display white.		captionView borderWidth: 2.		captionSave _ Form fromDisplay: captionView displayBox.		captionView unlock; display; release].	marker _ marker align: marker leftCenter with: aPoint + delta +  (2@0).	savedArea _ Form fromDisplay: frame.	self menuForm displayOn: Display at: (frameSaveLoc _ frame topLeft).	selection ~= 0 ifTrue: [Display reverse: marker].	aBlock value.	savedArea displayOn: Display at: frameSaveLoc.	captionOrNil notNil ifTrue:		[captionSave displayOn: Display at: captionView displayBox topLeft]! !!PopUpMenu methodsFor: 'private' priorSource: 777784 inFile: 2!computeLabelParagraph	"Answer a Paragraph containing this menu's labels, one per line and centered."	^ Paragraph withText: labelString asText style: MenuStyle! !!PopUpMenu class methodsFor: 'class initialization' priorSource: 779148 inFile: 2!initialize  "PopUpMenu initialize"	"Change CacheMenuForms to true to get faster popup menus on slower systems."	"CacheMenuForms _ true"	CacheMenuForms _ false.	(MenuStyle _ TextStyle default copy)		gridForFont: 1 withLead: 0;		alignment: 2! !!TextColor class methodsFor: 'as yet unclassified'!black	^ self new color: Color black! !!TextColor class methodsFor: 'as yet unclassified'!blue	^ self new color: Color blue! !!TextColor class methodsFor: 'as yet unclassified'!cyan	^ self new color: Color cyan! !!TextColor class methodsFor: 'as yet unclassified'!green	^ self new color: Color green! !!TextColor class methodsFor: 'as yet unclassified'!magenta	^ self new color: Color magenta! !!TextColor class methodsFor: 'as yet unclassified'!red	^ self new color: Color red! !!TextColor class methodsFor: 'as yet unclassified'!yellow	^ self new color: Color yellow! !!TextFontChange class methodsFor: 'as yet unclassified'!font1	^ self new fontNumber: 1! !!TextFontChange class methodsFor: 'as yet unclassified'!font2	^ self new fontNumber: 2! !!TextFontChange class methodsFor: 'as yet unclassified'!font3	^ self new fontNumber: 3! !!TextFontChange class methodsFor: 'as yet unclassified'!font4	^ self new fontNumber: 4! !!TextLineInterval methodsFor: 'accessing'!baseline	^ baseline! !!TextLineInterval methodsFor: 'accessing'!lineHeight	^ lineHeight! !!TextLineInterval methodsFor: 'private'!lineHeight: height baseline: ascent	lineHeight _ height.	baseline _ ascent! !!TextStyle methodsFor: 'accessing'!leading	"Leading (from typographers historical use of extra lead (type metal))	is the extra spacing above and beyond that needed just to accomodate	the various font heights in the set."	^ leading! !!TextStyle methodsFor: 'accessing'!leading: yDelta	leading _ yDelta! !!TextStyle methodsFor: 'private' priorSource: 1831007 inFile: 1!gridForFont: fontIndex withLead: leadInteger 	"Force whole style to suit one of its fonts. Assumes only one font referred	to by runs."	| font |	font _ self fontAt: fontIndex.	self lineGrid: font height + leadInteger.	self baseline: font ascent.	self leading: leadInteger! !!TextStyle methodsFor: 'private' priorSource: 1029037 inFile: 2!newFontArray: anArray	"Currently there is no supporting protocol for changing these arrays. If an editor wishes to implement margin setting, then a copy of the default should be stored with these instance variables.  	8/20/96 tk, Make size depend on first font."	fontArray _ anArray.	lineGrid _ (fontArray at: 1) height + leading.	"For whole family"	baseline _ (fontArray at: 1) ascent + leading.	alignment _ 0.	firstIndent _ 0.	restIndent _ 0.	rightIndent _ 0.	tabsArray _ DefaultTabsArray.	marginTabsArray _ DefaultMarginTabsArray"TextStyle allInstancesDo: [:ts | ts newFontArray: TextStyle default fontArray]."! !!TextStyle class methodsFor: 'instance creation'!initialize  "TextStyle initialize"	"Just for installing new text changes; then throw away"	TextStyle allInstancesDo: [:s | s leading: 2]! !!TextStyle class methodsFor: 'instance creation'!new	^ super new leading: 2! !TextStyle initialize!PopUpMenu initialize!ListParagraph initialize!Paragraph allInstancesDo: [:p | p composeAll]!ListParagraph allInstancesDo: [:p | p fixup]!PopUpMenu withAllSubclasses do:	[ :menuClass | menuClass allInstancesDo: [ :m | m rescan ]]!ListParagraph class removeSelector: #withArray:lineSpacing:!ListParagraph class removeSelector: #withArray:lineSpacing:!ListView removeSelector: #lineSpacing!ListView removeSelector: #lineSpacing!ListView removeSelector: #lineSpacing:!ListView removeSelector: #lineSpacing:!Paragraph removeSelector: #gridWithLead:!Paragraph removeSelector: #gridWithLead:!ListParagraph removeSelector: #fixup!ListParagraph removeSelector: #fixup!'From Squeak 1.13 of October 17, 1996 on 5 November 1996 at 2:03:25 am'!View subclass: #StandardSystemView	instanceVariableNames: 'labelFrame labelText isLabelComplemented savedSubViews minimumSize maximumSize collapsedViewport expandedViewport labelBits windowBits bitsValid '	classVariableNames: 'CacheBits LabelStyle '	poolDictionaries: ''	category: 'Interface-Support'!!CharacterBlockScanner methodsFor: 'private' priorSource: 298734 inFile: 1!buildCharacterBlockIn: aText	| lineIndex runLength lineStop done stopCondition |	"handle nullText"	(aText numberOfLines = 0 or: [text size = 0])		ifTrue:	[^CharacterBlock					stringIndex: 1	"like being off end of string"					character: nil					topLeft: ((aText leftMarginForDisplayForLine: 1) @								(aText compositionRectangle) top)					extent: (0 @ textStyle lineGrid)].	"find the line"	lineIndex _ aText lineIndexOfTop: characterPoint y.	destY _ (aText topAtLineIndex: lineIndex).	line _ aText lines at: lineIndex.	rightMargin _ aText rightMarginForDisplay.	(lineIndex = aText numberOfLines and:		[(destY + line lineHeight) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					characterPoint x: rightMargin]			ifFalse:	[characterPoint y < (aText compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint _								(aText compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[characterPoint x: rightMargin]].	destX _ leftMargin _ aText leftMarginForDisplayForLine: lineIndex.	nextLeftMargin_ aText leftMarginForDisplayForLine: lineIndex+1.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ (text runLengthFor: line first).	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex	"scanning for index"]		ifFalse:	[lineStop _ line last].	(runStopIndex _ lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex _ lineStop].	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0. done  _ false.	[done]	whileFalse:	[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions displaying: false.	"see setStopConditions for stopping conditions for character block 	operations."	lastCharacterExtent x: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition)		ifTrue:	[^CharacterBlock					stringIndex: lastIndex					character: lastCharacter					topLeft: characterPoint					extent: lastCharacterExtent]]! !!Paragraph methodsFor: 'accessing' priorSource: 1237665 inFile: 1!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY upOrDown moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	"find the starting and stopping lines"	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange _ aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle height: textStyle lineGrid * 8196.	"max Vector length"	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner _ CompositionScanner new in: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex _ (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine _ startLine - 1.							self lineAt: startLine put: newLine.							startIndex _ newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor.			self updateCompositionHeight.			^self]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine _ compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						upOrDown _ replacementRange < 0							ifTrue: [0] ifFalse: [1].							"get source and dest y's for moving the unchanged lines"						obsoleteY _ self topAtLineIndex: lastLineIndex + upOrDown									using: obsoleteLines and: obsoleteLastLine.						newY _ self topAtLineIndex: firstLineIndex + upOrDown.						stopLine _ firstLineIndex.						done _ true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex _ firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].		startIndex _ newLine last + 1.		firstLineIndex _ firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine _ firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle _				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine + 1) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: obsoleteY)						to: (self lineIndexOfTop: visibleRectangle top))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'private' priorSource: 1265125 inFile: 1!lineIndexOfTop: top 	"Answer the line index at a given top y."	| y line |	lastLine = 0 ifTrue: [^ 1].	y _ compositionRectangle top.	1 to: lastLine do:		[:i | line _ lines at: i.		(y _ y + line lineHeight) > top ifTrue: [^ i]].	^ lastLine! !!Paragraph methodsFor: 'private' priorSource: 1267724 inFile: 1!topAtLineIndex: lineIndex 	"Answer the top y of given line."	| y |	y _ compositionRectangle top.	lastLine = 0 ifTrue: [^ y].	1 to: (lineIndex-1 min: lastLine) do:		[:i | y _ y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private'!topAtLineIndex: lineIndex using: otherLines and: otherLastLine	"Answer the top y of given line."	| y |	y _ compositionRectangle top.	otherLastLine = 0 ifTrue: [^ y].	1 to: (lineIndex-1 min: otherLastLine) do:		[:i | y _ y + (otherLines at: i) lineHeight].	^ y! !!StandardSystemView methodsFor: 'label access' priorSource: 1013225 inFile: 2!label: aString 	"Set aString to be the receiver's label."	labelText _ Paragraph			withText: (Text string: ((aString == nil or: [aString isEmpty])								ifTrue: ['Untitled' copy]								ifFalse: [aString])							attributes: (Array with: (TextFontChange fontNumber: 2)											with: TextEmphasis bold))			style: LabelStyle.	insetDisplayBox == nil ifTrue: [^ self].  "wait for further initialization"	self setLabelRegion! !!StandardSystemView class methodsFor: 'class initialization' priorSource: 1655504 inFile: 1!initialize		"StandardSystemView initialize"	self doCacheBits.	(LabelStyle _ TextStyle default copy)		gridForFont: 2 withLead: 0! !StandardSystemView initialize!'From Squeak 1.13 of October 17, 1996 on 5 November 1996 at 10:19:29 am'!!DisplayScanner methodsFor: 'private' priorSource: 1010030 inFile: 2!addEmphasis: code	"Set the bold-ital-under-strike emphasis."	emphasis _ emphasis bitOr: code! !BitBlt subclass: #CharacterScanner	instanceVariableNames: 'lastIndex xTable stopConditions text textStyle leftMargin rightMargin font line runStopIndex spaceCount spaceWidth emphasisCode '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!!CharacterScanner methodsFor: 'private' priorSource: 940100 inFile: 2!addEmphasis: code	"Set the bold-ital-under-strike emphasis."	emphasisCode _ emphasisCode bitOr: code! !!CharacterScanner methodsFor: 'private' priorSource: 1009627 inFile: 2!setFont	"Set the font and other emphasis."	self setFont: 1.	emphasisCode _ 0.	(text attributesAt: lastIndex) do: 		[:att | att emphasizeScanner: self].	font _ font emphasized: emphasisCode.	"Install various parameters from the font."	spaceWidth _ font widthOf: Space. 	sourceForm _ font glyphs.  "Should only be needed in DisplayScanner"	height _ font height.			" ditto "	xTable _ font xTable.	stopConditions _ font stopConditions.	stopConditions at: Space asciiValue + 1 put: #space.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX! !!DisplayScanner methodsFor: 'scanning' priorSource: 1076157 inFile: 2!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle 	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done lineIndex stopCondition leftInRun fore back |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.	destForm depth > 1 ifTrue:		["Set up color map for display in color"		foregroundColor _ aParagraph foregroundColor.		fore _ foregroundColor bitPatternForDepth: destForm depth.		back _ aParagraph backgroundColor bitPatternForDepth: destForm depth.		self colorMap: (Bitmap with: back first with: fore first)].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	lineHeight _ textStyle lineGrid.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt destX: visibleRectangle left destY: lineY			width: leftMargin - visibleRectangle left height: lineHeight; copyBits.		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits.		lineY _ lineY + lineHeight]! !!DisplayScanner methodsFor: 'stop conditions' priorSource: 994599 inFile: 2!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	self fillLeading.  "Fill any leading above or below the font"	lastIndex = line last ifTrue: [^true].	runX _ destX.	runLength _ text runLengthFor: (lastIndex _ lastIndex + 1).	(runStopIndex _ lastIndex + (runLength - 1)) > line last 		ifTrue: [runStopIndex _ line last].	self setStopConditions.	^ false! !!DisplayScanner methodsFor: 'private' priorSource: 1010430 inFile: 2!setFont 	self textColor: foregroundColor.	super setFont.  "Sets font and emphasis bits"	destY _ lineY + line baseline - font ascent! !!ListParagraph class methodsFor: 'initialization' priorSource: 1078740 inFile: 2!initialize  "ListParagraph initialize"	"Allow different line spacing for lists"	ListStyle _ TextStyle default copy gridForFont: 1 withLead: 1! !CharacterScanner subclass: #DisplayScanner	instanceVariableNames: 'lineY runX foregroundColor fillBlt lineHeight '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!CharacterScanner removeSelector: #installFont!CharacterScanner removeSelector: #installFont!DisplayScanner removeSelector: #installFont!DisplayScanner removeSelector: #installFont!DisplayScanner removeSelector: #addEmphasis:!DisplayScanner removeSelector: #addEmphasis:!'From Squeak 1.13 of October 17, 1996 on 5 November 1996 at 5:09:56 pm'!!Paragraph methodsFor: 'selecting' priorSource: 1251347 inFile: 1!reverseFrom: characterBlock1 to: characterBlock2 	"Reverse area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline |	characterBlock1 = characterBlock2 ifTrue:		[lineNo _ self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline _ lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		^ CaretForm  "Use a caret to indicate null selection"				displayOn: destinationForm at: characterBlock1 topLeft + (0 @ baseline)				clippingBox: clippingRectangle				rule: (Display depth>8 ifTrue: [9 "not-reverse"]									ifFalse: [Form reverse])				fillColor: nil].	visibleRectangle _ 		(clippingRectangle intersect: compositionRectangle)			"intersect: destinationForm boundingBox" "not necessary".	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle _ 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle _ 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle _ 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle _ 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	self hiliteRect: initialRectangle.	self hiliteRect: interiorRectangle.	self hiliteRect: finalRectangle.! !'From Squeak 1.13 of October 17, 1996 on 5 November 1996 at 8:40:08 pm'!!BitBltSimulation methodsFor: 'setup' priorSource: 23471 inFile: 2!checkSourceOverlap	| t |	"check for possible overlap of source and destination"	(sourceForm = destForm and: [dy >= sy]) ifTrue:		[dy > sy ifTrue:			["have to start at bottom"			vDir _ -1.			sy _ sy + bbH.			dy _ dy + bbH]		ifFalse:			[dx > sx ifTrue:				["y's are equal, but x's are backward"				hDir _ -1.				sx _ sx + bbW.				"start at right"				dx _ dx + bbW.				"and fix up masks"				nWords > 1 ifTrue: 					[t _ mask1.					mask1 _ mask2.					mask2 _ t]]].		"Dest inits may be affected by this change"		destIndex _ (destBits + 4) + (dy * destRaster + (dx // pixPerWord) *4).		destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir))]! !!BitBltSimulation methodsFor: 'inner loop' priorSource: 880961 inFile: 2!warpLoop	| skewWord halftoneWord mergeWord i word destMask startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy	  xDelta yDelta pBx pBy smoothingCount sourceMapOop nSteps |	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation." 	(interpreterProxy fetchWordLengthOf: bitBltOop) >= (BBWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	pAx _ interpreterProxy fetchInteger: BBWarpBase ofObject: bitBltOop.	deltaP12x _ self deltaFrom: pAx			to: (interpreterProxy fetchInteger: BBWarpBase+3 ofObject: bitBltOop)			nSteps: nSteps.	deltaP12x < 0 ifTrue: [pAx _ pAx - 1].	pAy _ interpreterProxy fetchInteger: BBWarpBase+1 ofObject: bitBltOop.	deltaP12y _ self deltaFrom: pAy			to: (interpreterProxy fetchInteger: BBWarpBase+4 ofObject: bitBltOop)			nSteps: nSteps.	deltaP12y < 0 ifTrue: [pAy _ pAy - 1].	pBx _ interpreterProxy fetchInteger: BBWarpBase+9 ofObject: bitBltOop.	deltaP43x _ self deltaFrom: pBx			to: (interpreterProxy fetchInteger: BBWarpBase+6 ofObject: bitBltOop)			nSteps: nSteps.	deltaP43x < 0 ifTrue: [pBx _ pBx - 1].	pBy _ interpreterProxy fetchInteger: BBWarpBase+10 ofObject: bitBltOop.	deltaP43y _ self deltaFrom: pBy			to: (interpreterProxy fetchInteger: BBWarpBase+7 ofObject: bitBltOop)			nSteps: nSteps.	deltaP43y < 0 ifTrue: [pBy _ pBy - 1].	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"	interpreterProxy argCount = 2		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.				sourceMapOop _ interpreterProxy stackValue: 0.				sourceMapOop = interpreterProxy nilObject				ifTrue: [destPixSize < 16 ifTrue:					["color map is required to smooth non-RGB dest"					^ interpreterProxy primitiveFail]]				ifFalse: [(interpreterProxy fetchWordLengthOf: sourceMapOop)							< (1 << sourcePixSize) ifTrue:					["sourceMap must be long enough for sourcePixSize"					^ interpreterProxy primitiveFail]]]		ifFalse: [smoothingCount _ 1.				sourceMapOop _ interpreterProxy nilObject].	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1]. 	1 to: bbH do:		[ :i |		"here is the vertical loop..."		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps. 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pAx - 1].		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps. 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pAy - 1].		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self warpSourcePixels: bbW									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self warpSourcePixels: startBits									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]. 		1 to: nWords do:			[ :word |		"here is the inner horizontal loop..."			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]]				ifFalse:				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop].		].	pAx _ pAx + deltaP12x.	pAy _ pAy + deltaP12y.	pBx _ pBx + deltaP43x.	pBy _ pBy + deltaP43y.	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'pixel mapping' priorSource: 835415 inFile: 2!smoothPix: n atXf: xf yf: yf dxh: dxh dyh: dyh dxv: dxv dyv: dyv	pixPerWord: srcPixPerWord pixelMask: sourcePixMask	sourceMap: sourceMap	| sourcePix i j r g b x y rgb bitsPerColor d nPix |	r _ g _ b _ 0.  "Separate r, g, b components"	nPix _ n*n.	x _ xf.  y _ yf.	0 to: n-1 do:		[:i |		0 to: n-1 do:			[:j |			sourcePix _ (self sourcePixAtX: x + (dxh*i) + (dxv*j)  >> BinaryPoint									y: y + (dyh*i) + (dyv*j)  >> BinaryPoint									pixPerWord: srcPixPerWord)									bitAnd: sourcePixMask.			sourcePixSize < 16				ifTrue: ["Get 24-bit RGB values from sourcemap table"						rgb _ (interpreterProxy fetchWord: sourcePix ofObject: sourceMap) bitAnd: 16rFFFFFF]				ifFalse: ["Already in RGB format"						sourcePixSize = 32						ifTrue: [rgb _ sourcePix bitAnd: 16rFFFFFF]						ifFalse: ["Note could be faster"								rgb _ self rgbMap: sourcePix from: 5 to: 8]].			r _ r + ((rgb >> 16) bitAnd: 16rFF).			g _ g + ((rgb >> 8) bitAnd: 16rFF).			b _ b + (rgb bitAnd: 16rFF).			].		].	colorMap ~= interpreterProxy nilObject		ifTrue: [bitsPerColor _ cmBitsPerColor]		ifFalse: [destPixSize = 16 ifTrue: [bitsPerColor _ 5].				destPixSize = 32 ifTrue: [bitsPerColor _ 8]].	d _ 8 - bitsPerColor.	rgb _ ((r // nPix >> d) << (bitsPerColor*2))		+ ((g // nPix >> d) << bitsPerColor)		+ ((b // nPix >> d)).	colorMap ~= interpreterProxy nilObject		ifTrue: [^ interpreterProxy fetchWord: rgb ofObject: colorMap]		ifFalse: [^ rgb]! !!WarpBlt methodsFor: 'primitives' priorSource: 889850 inFile: 2!warpBitsSmoothing: n sourceMap: sourceMap	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix |	<primitive: 147>	(width < 1) | (height < 1) ifTrue: [^ self].	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"	n > 1 ifTrue:		[(destForm depth < 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFail].		pix _ Array new: n*n].	deltaP12 _ (self deltaFrom: p1x to: p2x nSteps: (height-1 max: 1))			@ (self deltaFrom: p1y to: p2y nSteps: (height-1 max: 1)).	deltaP43 _ (self deltaFrom: p4x to: p3x nSteps: (height-1 max: 1))			@ (self deltaFrom: p4y to: p3y nSteps: (height-1 max: 1)).	pA _ (self startFrom: p1x to: p2x) @ (self startFrom: p1y to: p2y).	pB _ (self startFrom: p4x to: p3x) @ (self startFrom: p4y to: p3y).	picker _ BitBlt bitPeekerFromForm: sourceForm.	poker _ BitBlt bitPokerToForm: destForm.	destY to: destY+height-1 do:		[:y |		deltaPAB _ (self deltaFrom: pA x to: pB x nSteps: (width-1 max: 1))				@ (self deltaFrom: pA y to: pB y nSteps: (width-1 max: 1)).		sp _ (self startFrom: pA x to: pB x) @ (self startFrom: pA y to: pB y).		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[Transcript cr; print: sp // fixedPtOne asPoint.				poker pixelAt: x@y						put: (picker pixelAt: sp // fixedPtOne asPoint)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPtOne asPoint)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp _ sp + deltaPAB].		pA _ pA + deltaP12.		pB _ pB + deltaP43]! !"This is an executable file.  If it is in the same folder as your image, along with all the other files called out below, you may simply fileIn this file, and it will in turn fileIn all the others.  If these files are in some other folder that you are browsing with the file list, you can instead use the fileList fileIn capability to file in the various files, in the order specified below.  Note: it is likely that some of these fileIns will crash if you have a Transcript open during the operation (since text display code is being modified).""Fixes an age-old bug that affected fileIns containing messages categorized as 'as yet unclassified', and also defines a simpler 'find class' option for the browser (you just type, eg, 'form', and it finds all the classes that have those letters in their names."(FileStream readOnlyFileNamed: 'TwoFixes-di.cs') fileIn."Four minor improvements..."(FileStream readOnlyFileNamed: 'ColonFix-di.st') fileIn.(FileStream readOnlyFileNamed: 'BetterCornerCtl-di.st') fileIn.(FileStream readOnlyFileNamed: 'DebuggerFlushKbd-di.st') fileIn.(FileStream readOnlyFileNamed: 'FasterBorders-di.cs') fileIn."Reworks text display so that it does not clear ahead.  No more flashes during type-in."(FileStream readOnlyFileNamed: 'NoFlashText-di.cs') fileIn."Defines NullColor, and reworks text display to support transparency.  There is an example in DisplayText class."(FileStream readOnlyFileNamed: 'TransparentText-di.cs') fileIn.(FileStream readOnlyFileNamed: 'TransparentFix-di.cs') fileIn."A complete overhaul of Text, so as to support arbitrary decorations as objects in the run codes.  In particular, enables color and active text"(FileStream readOnlyFileNamed: 'TextStyleMods-di.cs') fileIn.(FileStream readOnlyFileNamed: 'Text class-initialize.st') fileIn."A new overview to recent items in the changes log"(FileStream readOnlyFileNamed: 'ChangesChanges-di.cs') fileIn.(FileStream readOnlyFileNamed: 'ChangesChanges2-di.cs') fileIn."A bunch of improvements to StikeFont to better support file I/O, especially from BitFont.  Also defines a couple of methods that allow storing a whole font family as a subclass that can be filed in just like any other class.  The second file is just such a class."(FileStream readOnlyFileNamed: 'FontWork-di.cs') fileIn.(FileStream readOnlyFileNamed: 'NewYork.st') fileIn."An overhaul of Paragraph and TextScanners that introduces automatic line spacing, thus enabling greater facility to handle, eg, headings in text without the need to put them in separate paragraphs.  Existing paragraphs in your system may not feel this change (or at least not in a positive manner).  You may want to execute StrikeFont hackDefaultStyle, and read the command key summary in the screen-menu help choices."(FileStream readOnlyFileNamed: 'AutoLineHeight1-di.cs') fileIn.(FileStream readOnlyFileNamed: 'AutoLineHeight2-di.cs') fileIn.(FileStream readOnlyFileNamed: 'AutoLineHeight3-di.cs') fileIn.(FileStream readOnlyFileNamed: 'LineHeightTweaks-di.cs') fileIn."Two minor interpreter changes.  One fixes a long-standing off-by-1 bug that affected the exact bounds of a bitblt of a form onto itself, as in scrolling in positive x or y direction.  Also simplifies the alignment of sub-sampling coordinates when WarpBlt is doing smoothing.  Note:  these changes affect only the virtual machine specification, and will not take effect in your Squeak unless you rebuild or otherwise obtain an updated interpreter."(FileStream readOnlyFileNamed: 'BBandWarpFixes-di.cs') fileIn.!StrikeFont hackDefaultStyle.  "Installs fonts 1-4"!----QUIT----(5 November 1996 10:00:47 pm ) priorSource: 984133!----QUIT----(5 November 1996 10:12:43 pm ) priorSource: 1118930!'From Squeak 1.13 of October 17, 1996 on 4 November 1996 at 5:02:57 pm'!----QUIT----(5 November 1996 10:17:59 pm ) priorSource: 1118995!'From Squeak 1.13 of October 17, 1996 on 4 November 1996 at 5:02:57 pm'!Object subclass: #PopUpMenu	instanceVariableNames: 'labelString font lineArray frame form marker selection '	classVariableNames: 'CacheMenuForms MenuStyle'	poolDictionaries: ''	category: 'Interface-Menus'!!Object methodsFor: 'error handling' priorSource: 1190344 inFile: 1!confirm: queryString 	"Put up a yes/no menu with caption aString. Answer true if the response is yes, false if no. This is a modal question--the user must respond yes or no."	"nil confirm: 'Are you hungry?'"	^ SelectionMenu confirm: queryString! !!Class methodsFor: 'class name' priorSource: 324623 inFile: 1!rename: aString 	"The new name of the receiver is the argument, aString."	| newName |	newName _ aString asSymbol.	(Smalltalk includesKey: newName)		ifTrue: [^self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [^ SelectionMenu notify: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	Smalltalk renameClass: self as: newName.	name _ newName.	self comment: self comment.	self class comment: self class comment! !!FileModel methodsFor: 'accessing' priorSource: 757623 inFile: 1!put: aString 	| f |	(aString size >= 5 and:		[#('File ' '16r0 ') includes: (aString copyFrom: 1 to: 5)])		ifTrue: [(self confirm:'Abbreviated and hexadecimal file viewscannot be meaningfully saved at present.Is this REALLY what you want to do?')				ifFalse: [^ self]].	f _ FileStream newFileNamed: self fullName.	Cursor write showWhile: [f nextPutAll: aString; close].! !!MouseMenuController methodsFor: 'menu messages' priorSource: 1157569 inFile: 1!redButtonActivity	"Determine which item in the red button pop-up menu is selected. If one 	is selected, then send the corresponding message to the object designated 	as the menu message receiver."	| index |	redButtonMenu ~~ nil		ifTrue: 			[index _ redButtonMenu startUp.			index ~= 0 				ifTrue: [self menuMessageReceiver perform:							(redButtonMessages at: index)]]		ifFalse: [super controlActivity]! !!MouseMenuController methodsFor: 'menu messages' priorSource: 1157995 inFile: 1!shiftedYellowButtonActivity	"Present the alternate (shifted) menu and take action accordingly.  1/17/96 sw.	1/25/96 sw: let #shiftedYellowButtonActivity: do the work"	| index shiftMenu |	(shiftMenu _ self shiftedYellowButtonMenu) == nil ifTrue:		[^ super controlActivity].	self shiftedYellowButtonActivity: shiftMenu! !!MouseMenuController methodsFor: 'menu messages' priorSource: 1158321 inFile: 1!shiftedYellowButtonActivity: shiftMenu	"Present the alternate (shifted) menu and take action accordingly.  If we get here, shiftMenu is known to be non-nil.  1/26/96 sw"	| index  |	(index _ shiftMenu startUp) ~= 0		ifTrue:			[self menuMessageReceiver performMenuMessage: (self shiftedYellowButtonMessages at: index)]		ifFalse:			[super controlActivity]! !!MouseMenuController methodsFor: 'menu messages' priorSource: 1158696 inFile: 1!unshiftedYellowButtonActivity	"Put up the regular yellow-button menu and take action as appropriate.  1/24/96 sw"	| index  |	yellowButtonMenu ~~ nil		ifTrue: 			[index _ yellowButtonMenu startUp.			index ~= 0 				ifTrue: [self menuMessageReceiver performMenuMessage:							(yellowButtonMessages at: index)]]		ifFalse:			[super controlActivity]! !!Object class methodsFor: 'class initialization' priorSource: 1209063 inFile: 1!initializeOnceOnly 	"Refer to the comment in Class|initialize.  This is the initilaize message for Object class, but if called initialize, then all classes would inherit it as a class message, and clearly this is not the default desired."	self initializeDependentsFields.  "Note this will disconnect views!!"	self initializeErrorRecursion.	"Object initializeOnceOnly"! !!Interpreter class methodsFor: 'translation' priorSource: 282694 inFile: 2!patchInterp: fileName	"Interpreter patchInterp: 'Squeak VM PPC'"	"This will patch out the unneccesary range check (a compare	 and branch) in the inner interpreter dispatch loop."	"NOTE: You must edit in the Interpeter file name, and the	 number of instructions (delta) to count back to find the compare	 and branch that we want to get rid of."	| delta f code len remnant i |	delta _ 6.	f _ FileStream fileNamed: fileName.	f binary.	code _ Bitmap new: (len _ f size) // 4.	f nextInto: code.	remnant _ f next: len - (code size * 4).	i _ 0.	["Look for a BCTR instruction"	(i _ code indexOf: 16r4E800420 startingAt: i + 1 ifAbsent: [0]) > 0] whileTrue: [		"Look for a CMPLWI FF, 6 instrs back"	       ((code at: i - delta) bitAnd: 16rFFE0FFFF) = 16r280000FF ifTrue: [	       	"Copy dispatch instrs back over the compare"			SelectionMenu notify: 'Patching at ', i hex.			0 to: delta - 2 do: [ :j |				code at: (i - delta) + j put: (code at: (i - delta) + j + 2).			].		].	].	f position: 0; nextPutAll: code; nextPutAll: remnant.	f close.! !!ParagraphEditor methodsFor: 'menu messages' priorSource: 1293201 inFile: 1!methodSourceContainingIt	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).   EXTREMELY slow!!"	startBlock = stopBlock ifTrue: [view flash.  ^ self].	(self confirm: 'This will take a few minutes.Shall I proceed?') ifFalse: [^ self].	Smalltalk browseMethodsWithSourceString: self selection string! !!Parser methodsFor: 'error correction' priorSource: 1378339 inFile: 1!restart	"This SHOULD restart compilation, but since the parser	doesnt have access to the corrected text, we have to ask 	the user to restart.  Sigh."	SelectionMenu notify: 'I was able to make the correction,but I need you to re-accept -- thanks'.	self fail! !!Project methodsFor: 'release' priorSource: 1451956 inFile: 1!okToChange	^ self confirm:'Are you sure you have savedall changes that you care aboutin ', self name printString.! !!SelectionMenu methodsFor: 'basic control sequence'!invokeOn: targetObject	"Pop up this menu and return the result of sending to the target object	 the selector corresponding to the menu item selected by the user. Return	 nil if no item is selected."	| sel |	sel _ self startUp.	sel = nil ifFalse: [^ targetObject perform: sel].	^ nil"(SelectionMenu labels:'sincosneg' lines: #() selections: #(sin cos negated)) invokeOn: 0.7"! !!SelectionMenu methodsFor: 'marker management' priorSource: 1554223 inFile: 1!manageMarker	"Returns the selected item. If no selection, return nil."	super manageMarker.	(selection = 0 or: [selections = nil]) ifTrue: [^ nil].	^ selections at: selection! !!SelectionMenu class methodsFor: 'instance creation'!confirm: queryString 	"Put up a yes/no menu with caption queryString. Answer true if the response is yes, false if no. This is a modal question--the user must respond yes or no."	"SelectionMenu confirm: 'Are you hungry?'"	| menu choice |	menu _ self selections: #('yes' 'no').	[true] whileTrue: [		choice _ menu startUpWithCaption: queryString.		choice = 'yes' ifTrue: [^ true].		choice = 'no' ifTrue: [^ false]]! !!SelectionMenu class methodsFor: 'instance creation' priorSource: 1554957 inFile: 1!labels: aString lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray. Record the given array of selections	corresponding to the items in labelsArray."	^ (self labels: aString lines: linesArray) selections: selectionsArray! !!SelectionMenu class methodsFor: 'instance creation' priorSource: 1555143 inFile: 1!labels: aString selections: selectionsArray	"Answer an instance of me whose items are in aString, recording	 the given array of selections corresponding to the items in aString."	^ self labels: aString lines: #() selections: selectionsArray! !!SelectionMenu class methodsFor: 'instance creation' priorSource: 1555239 inFile: 1!selections: aList	"Answer an instance of me whose labels and selections are identical.  6/27/96 sw"	^ self labelList: aList lines: nil selections: aList! !!SystemDictionary methodsFor: 'housekeeping' priorSource: 1795400 inFile: 1!condenseSources		"Smalltalk condenseSources"	"Move all the changes onto a compacted sources file."	| f name oldChanges classCount dir |	dir _ FileDirectory default.	"Write all sources with fileIndex 1"	f _ FileStream newFileNamed: self sourcesName , '.temp'.	f header; timeStamp.'Condensing Sources File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class fileOutOn: f moveSource: true toFile: 1]].	f trailer; close.	"Make a new empty changes file"	self closeSourceFiles.	dir rename: self changesName		toBe: self changesName , '.old'.	(FileStream newFileNamed: self changesName)		header; timeStamp; close.	LastQuitLogPosition _ 0.	dir rename: self sourcesName		toBe: self sourcesName , '.old'.	dir rename: self sourcesName , '.temp'		toBe: self sourcesName.	self openSourceFiles.	SelectionMenu notify: 'Source files have been rewritten!!Check that all is well,and then save/quit.'! !!Utilities class methodsFor: 'user interface' priorSource: 1853171 inFile: 1!informUser: aString during: aBlock	"Put a message above (or below if insufficient room) the cursor.	 Like informUser:while:, but end when aBlock ends.  9/1/96 di"	(SelectionMenu labels: '') displayAt: Sensor cursorPoint		withCaption: aString during: [aBlock value]! !!Utilities class methodsFor: 'user interface' priorSource: 1853438 inFile: 1!informUser: aString while: aBlock	"Put a message above (or below if insufficient room) the cursor.	 1/22/96 sw"	"Utilities informUser: 'How do you do' while: [Sensor anyButtonPressed not]"	| cp  |	cp _ Sensor cursorPoint.	(SelectionMenu labels: '') displayAt: cp				withCaption: aString				during: [[aBlock value] whileTrue]! !!Utilities class methodsFor: 'recent method submissions' priorSource: 1860706 inFile: 1!browseRecentSubmissions	"Open up a browser on the most recent methods submitted in the image.  5/96 sw.	5/29/96 sw: fixed so the browser doesn't go all wonkie after you submit more code"	"Utilities browseRecentSubmissions"	| count |	(count _ self recentMethodSubmissions size) == 0 ifTrue:		[^ SelectionMenu notify: 'There are no recent submissions'].		Smalltalk browseMessageList: RecentSubmissions copy name: 'Recently submitted methods -- oldest first' autoSelect: nil ! !Object class removeSelector: #initializeConfirmMenu!Object class removeSelector: #initializeConfirmMenu!PopUpMenu removeSelector: #startUpYellowButton!PopUpMenu removeSelector: #startUpYellowButton!PopUpMenu removeSelector: #startUpBlueButton!PopUpMenu removeSelector: #startUpBlueButton!PopUpMenu removeSelector: #startUpRedButton!PopUpMenu removeSelector: #startUpRedButton!ListController subclass: #PluggableListController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableListView'!!PluggableListController methodsFor: 'all'!changeModelSelection: anInteger	"Let the view handle this."	view changeModelSelection: anInteger.! !!PluggableListController methodsFor: 'all'!controlActivity	"Overridden to handle keystrokes."	sensor keyboardPressed ifTrue: [view handleKeystroke: sensor keyboard].	super controlActivity.! !!PluggableListController methodsFor: 'all'!yellowButtonActivity	"Invoke the model's menu."	| menu |	menu _ view getMenu.	menu == nil ifFalse: [menu invokeOn: model].! !ListView subclass: #PluggableListView	instanceVariableNames: 'items getListSelector getSelectionSelector setSelectionSelector getMenuSelector keystrokeActionSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableListView'!!PluggableListView methodsFor: 'initialization'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'itemsList' holds the original list.	 The instance variable 'items' is a paragraph constructed from	 this list."	| s |	items _ arrayOfStrings.	isEmpty _ arrayOfStrings isEmpty.	s _ WriteStream on: Array new.	"add top and bottom delimiters"	s nextPut: topDelimiter.	arrayOfStrings do: [:item |		item == nil ifFalse: [s nextPut: item].	].	s nextPut: bottomDelimiter.	list _ ListParagraph		withArray: s contents		lineSpacing: lineSpacing.	selection _ self getCurrentSelectionIndex.	self positionList.! !!PluggableListView methodsFor: 'initialization'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self model: anObject.	getListSelector _ getListSel.	getSelectionSelector _ getSelectionSel.	setSelectionSelector _ setSelectionSel.	getMenuSelector _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	self borderWidth: 1.	self list: self getList.! !!PluggableListView methodsFor: 'model access'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setSelectionSelector ~~ nil ifTrue: [		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [items at: anInteger]).		model perform: setSelectionSelector with: item.		getSelectionSelector == nil ifFalse: [model perform: getSelectionSelector].	].! !!PluggableListView methodsFor: 'model access'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getSelectionSelector == nil ifTrue: [^ 0].	item _ model perform: getSelectionSelector.	^ items findFirst: [ :x | x = item]! !!PluggableListView methodsFor: 'model access'!getList 	"Answer the list to be displayed."	| lst |	getListSelector == nil ifTrue: [^ #()].	lst _ model perform: getListSelector.	lst == nil ifTrue: [^ #()].	^ lst! !!PluggableListView methodsFor: 'model access'!getMenu	"Answer the menu for this list view."	getMenuSelector == nil ifTrue: [^ nil].	^ model perform: getMenuSelector! !!PluggableListView methodsFor: 'model access'!handleKeystroke: aCharacter	"Answer the menu for this list view."	keystrokeActionSelector == nil ifTrue: [^ nil].	model perform: keystrokeActionSelector with: aCharacter.! !!PluggableListView methodsFor: 'controller access'!defaultControllerClass 	^ PluggableListController! !!PluggableListView methodsFor: 'updating'!update: aSymbol 	"Refer to the comment in View|update:."	| oldIndex newIndex |	aSymbol == getListSelector ifTrue: [		oldIndex _ self getCurrentSelectionIndex.		self list: self getList.		newIndex _ self getCurrentSelectionIndex.		(oldIndex > 0 and: [newIndex = 0]) ifTrue: [			"new list did not include the old selection; deselecting"			self changeModelSelection: newIndex].		self displayView.		self displaySelectionBox.		^self].	aSymbol == getSelectionSelector ifTrue: [		self moveSelectionBox: self getCurrentSelectionIndex.		^self].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableListView class!!PluggableListView class methodsFor: 'as yet unclassified'!aboutPluggability	"A pluggable list view gets its content from the model. This allows the same kind of view can be used in different situations, thus avoiding a proliferation of gratuitous view and controller classes. Selector usage is:		getListSel		fetch the list of items (strings) to be displayed		getSelectionSel	get the currently selected item		setSelectionSel	set the currently selected item (takes an argument)		getMenuSel		get the pane-specific (or 'yellow-button') menu		keyActionSel	process keystrokes typed to this view (takes an argument)	Any of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default, do-nothing behavior should be used. However, if getListSel is nil, the default behavior just provides an empty list, which makes for a rather dull list view!! (Such behavior can actually be useful during debugging.)	The model informs a pluggable view of changes by sending #changed: to itself with getListSel or getSelectionSel as a parameter. The view informs the model of selection changes by sending setSelectionSel to it with the newly selected item as a parameter, and invokes menu and keyboard actions on the model via getMenuSel and keyActionSel.	Pluggability allows a single model object to have pluggable list views on multiple aspects of itself. For example, an object representing one personal music library might be organized as a three-level hierarchy: the types of music, the titles within a given type, and the songs on a given title. Pluggability allows one to easily build a multipane browser for this object with separate list views for the music type, title, and song."! !!PluggableListView class methodsFor: 'as yet unclassified'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: nil		keystroke: nil! !!PluggableListView class methodsFor: 'as yet unclassified'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: nil! !!PluggableListView class methodsFor: 'as yet unclassified'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: keyActionSel! !Object subclass: #PluggableTest	instanceVariableNames: 'list1 selection1 list2 selection2 '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableListView'!!PluggableTest methodsFor: 'initialization'!initialize	list1 _ #('reggae' 'early' 'classical').	list2 _ #('marley' 'alpha blondy' 'burning spear' 'ziggy').! !!PluggableTest methodsFor: 'artist pane'!artist	^ selection2! !!PluggableTest methodsFor: 'artist pane'!artist: aString	selection2 _ aString.	self changed: #artist.! !!PluggableTest methodsFor: 'artist pane'!artistKeystroke: aCharacter	list2 do: [ :artist |		(artist first asLowercase = aCharacter asLowercase) ifTrue: [			self artist: artist]].! !!PluggableTest methodsFor: 'artist pane'!artists	selection1 = 'reggae' ifTrue: [^ list2].	selection1 = 'early' ifFalse: [^ #('ziggy' 'marley')].	^ #()! !!PluggableTest methodsFor: 'music type pane'!musicType	^ selection1! !!PluggableTest methodsFor: 'music type pane'!musicType: aString	selection1 _ aString.	self changed: #musicType.	self changed: #artists.! !!PluggableTest methodsFor: 'music type pane'!musicTypeKeystroke: aCharacter	list1 do: [ :type |		(type first asLowercase = aCharacter asLowercase) ifTrue: [			self musicType: type]].! !!PluggableTest methodsFor: 'music type pane'!musicTypeMenu	^ SelectionMenu		labels: 'reggae\grunge\flash' withCRs		lines: #(2)		selections: #(reggaeCmd grungeCmd flashCmd)! !!PluggableTest methodsFor: 'music type pane'!musicTypes	^ list1! !!PluggableTest methodsFor: 'menu commands'!flashCmd	Display reverse; reverse.! !!PluggableTest methodsFor: 'menu commands'!grungeCmd	SelectionMenu confirm:		'You mean, like those strange bands from Seattle?'! !!PluggableTest methodsFor: 'menu commands'!reggaeCmd	self musicType: 'reggae'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableTest class!!PluggableTest class methodsFor: 'as yet unclassified'!open	"PluggableTest open"	| model listView1 topView listView2 |	model _ self new initialize.	listView1 _		PluggableListView on: model			list: #musicTypes			selected: #musicType			changeSelected: #musicType:			menu: #musicTypeMenu			keystroke: #musicTypeKeystroke:.	listView2 _		PluggableListView on: model			list: #artists			selected: #artist			changeSelected: #artist:			menu: nil			keystroke: #artistKeystroke:.	topView _ StandardSystemView new		label: 'Pluggable Test';		minimumSize: 300@200;		borderWidth: 1;		addSubView: listView1;		addSubView: listView2 toRightOf: listView1.	topView controller open.! !'From Squeak 1.13 of October 17, 1996 on 4 November 1996 at 5:01:40 pm'!!Character methodsFor: 'converting' priorSource: 285070 inFile: 1!asLowercase	"If the receiver is uppercase, answer its matching lowercase Character."		(8r101 <= value and: [value <= 8r132])  "self isUppercase"		ifTrue: [^ Character value: value + 8r40]		ifFalse: [^ self]! !!Character class methodsFor: 'accessing untypeable characters'!linefeed	"Answer the Character representing a linefeed."	^self value: 10! !!ParagraphEditor methodsFor: 'menu messages' priorSource: 1283557 inFile: 1!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."	| s |	s _ Smalltalk clipboardText.	(s isEmpty or: [s = CurrentSelection string])		ifTrue: [^ CurrentSelection]		ifFalse: [^ s asText]! !!PositionableStream methodsFor: 'accessing'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| newStream el |	newStream _ WriteStream on: (collection species new: 100).	[(el _ self next) == nil] whileFalse: [ newStream nextPut: el ].	^ newStream contents! !!String methodsFor: 'Celeste'!includesSubstring: aString caseSensitive: caseSensitive		| first index i |	self isEmpty ifTrue: [^false].	caseSensitive ifTrue: [		first _ aString first.		1 to: self size - aString size + 1 do: [ :start |			(self at: start) = first ifTrue: [				i _ 1.				[(self at: start + i - 1) = (aString at: i)] whileTrue: [					i = aString size ifTrue: [^true].					i _ i + 1.				].			].		].	] ifFalse: [		first _ aString first asLowercase.		1 to: self size - aString size + 1 do: [ :start |			(self at: start) asLowercase = first ifTrue: [				i _ 1.				[(self at: start + i - 1) asLowercase =				 (aString at: i) asLowercase] whileTrue: [					i = aString size ifTrue: [^ true].					i _ i + 1.				].			].		].	].	^ false! !!String methodsFor: 'Celeste'!withCRs	"Return a copy of the receiver in which backslash (\) characters have been replaced with carriage returns."	^ self collect: [ :c | c = $\ ifTrue: [ Character cr ] ifFalse: [ c ]].! !!SystemDictionary methodsFor: 'miscellaneous' priorSource: 1799441 inFile: 1!clipboardText	"Get the current clipboard text. Return the empty string if the primitive fails."	<primitive: 141>	^ ''! !Character class removeSelector: #apple!Character class removeSelector: #apple!Character class removeSelector: #esc!Character class removeSelector: #esc!Character class removeSelector: #alphabet!Character class removeSelector: #alphabet!----QUIT----(5 November 1996 10:26:54 pm ) priorSource: 1119135!!Paragraph methodsFor: 'private' priorSource: 1268078 inFile: 1!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work."	compositionRectangle height: (self topAtLineIndex: lastLine+1).	(text size ~= 0 and: [(text at: text size) = CR])		ifTrue: [compositionRectangle 					height: compositionRectangle height + textStyle lineGrid]! !!Paragraph methodsFor: 'private' priorSource: 1142988 inFile: 2!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work."	compositionRectangle height: (self topAtLineIndex: lastLine+1).	(text size ~= 0 and: [(text at: text size) = CR])		ifTrue: [compositionRectangle 					height: compositionRectangle height + (lines at: lastLine) lineHeight]! !!CharacterBlockScanner methodsFor: 'stop conditions' priorSource: 292662 inFile: 1!cr	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY _ destY +  line lineHeight.				lastCharacter _ nil.				characterPoint _ 					Point						x: ((text at: lastIndex) = CR								ifTrue: [leftMargin]								ifFalse: [nextLeftMargin])						y: destY.				lastIndex _ lastIndex + 1.				lastCharacterExtent x: 0.				^ true].		lastCharacter _ CR.		characterPoint _ destX @ destY.		lastCharacterExtent x: rightMargin - destX.		^true! !!CharacterBlockScanner methodsFor: 'scanning' priorSource: 292026 inFile: 1!characterNotInFont	"This does not handle character selection nicely, i.e., illegal characters are a 	little tricky to select.  Since the end of a run or line is subverted here by actually	having the scanner scan a different string in order to manage the illegal 	character, things are not in an absolutely correct state for the character 	location code.  If this becomes too odious in use, logic will be added to accurately 	manage the situation."	lastCharacterExtent _ 		(font widthOf: (font maxAscii + 1) asCharacter) @ line lineHeight.	^super characterNotInFont! !!DisplayScanner methodsFor: 'scanning' priorSource: 1099580 inFile: 2!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle 	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done lineIndex stopCondition leftInRun fore back |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.	destForm depth > 1 ifTrue:		["Set up color map for display in color"		foregroundColor _ aParagraph foregroundColor.		fore _ foregroundColor bitPatternForDepth: destForm depth.		back _ aParagraph backgroundColor bitPatternForDepth: destForm depth.		self colorMap: (Bitmap with: back first with: fore first)].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt destX: visibleRectangle left destY: lineY			width: leftMargin - visibleRectangle left height: lineHeight; copyBits.		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits.		lineY _ lineY + lineHeight]! !!Metaclass methodsFor: 'fileIn/Out' priorSource: 826826 inFile: 2!definition 	"Refer to the comment in ClassDescription|definition."	| aStream names |	aStream _ WriteStream on: (String new: 300).	self printOn: aStream.	names _ self instVarNames."	names isEmpty ifTrue: [^  aStream contents]."	aStream nextPutAll: '	instanceVariableNames: '''.	1 to: names size do: [:i | aStream nextPutAll: (names at: i); space].	aStream nextPut: $'.	^ aStream contents! !!Paragraph methodsFor: 'private' priorSource: 1143369 inFile: 2!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work."	compositionRectangle height: textStyle lineGrid * lastLine.	(text size ~= 0 and: [(text at: text size) = CR])		ifTrue: [compositionRectangle 					height: compositionRectangle height + textStyle lineGrid]! !!Paragraph methodsFor: 'private' priorSource: 1148527 inFile: 2!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work." 	compositionRectangle height: (self topAtLineIndex: lastLine+1).	(text size ~= 0 and: [(text at: text size) = CR])		ifTrue: [compositionRectangle 					height: compositionRectangle height + (lines at: lastLine) lineHeight]! !!Paragraph methodsFor: 'private' priorSource: 1096749 inFile: 2!topAtLineIndex: lineIndex 	"Answer the top y of given line."	| y |	y _ compositionRectangle top.	lastLine = 0 ifTrue: [lineIndex > 0 ifTrue: [^ y + textStyle lineGrid]. ^ y].	1 to: (lineIndex-1 min: lastLine) do:		[:i | y _ y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private' priorSource: 1148904 inFile: 2!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work." 	compositionRectangle height:		(self topAtLineIndex: lastLine+1) - compositionRectangle top.	(text size ~= 0 and: [(text at: text size) = CR])		ifTrue: [compositionRectangle 					height: compositionRectangle height + (lines at: lastLine) lineHeight]! !!CharacterBlockScanner methodsFor: 'stop conditions' priorSource: 1143782 inFile: 2!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY _ destY +  line lineHeight.				lastCharacter _ nil.				characterPoint _ 					Point						x: ((text at: lastIndex) = CR								ifTrue: [leftMargin]								ifFalse: [nextLeftMargin])						y: destY.				lastIndex _ lastIndex + 1.				lastCharacterExtent x: 0.				^ true].		lastCharacter _ CR.		characterPoint _ destX @ destY.		lastCharacterExtent x: rightMargin - destX.		^true! !!CharacterBlockScanner methodsFor: 'scanning' priorSource: 1144836 inFile: 2!characterNotInFont 	"This does not handle character selection nicely, i.e., illegal characters are a 	little tricky to select.  Since the end of a run or line is subverted here by actually	having the scanner scan a different string in order to manage the illegal 	character, things are not in an absolutely correct state for the character 	location code.  If this becomes too odious in use, logic will be added to accurately 	manage the situation."	lastCharacterExtent _ 		(font widthOf: (font maxAscii + 1) asCharacter) @ line lineHeight.	^super characterNotInFont! !!DisplayScanner methodsFor: 'scanning' priorSource: 1145485 inFile: 2!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done lineIndex stopCondition leftInRun fore back |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.	destForm depth > 1 ifTrue:		["Set up color map for display in color"		foregroundColor _ aParagraph foregroundColor.		fore _ foregroundColor bitPatternForDepth: destForm depth.		back _ aParagraph backgroundColor bitPatternForDepth: destForm depth.		self colorMap: (Bitmap with: back first with: fore first)].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt destX: visibleRectangle left destY: lineY			width: leftMargin - visibleRectangle left height: lineHeight; copyBits.		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits.		lineY _ lineY + lineHeight]! !!Paragraph methodsFor: 'private'!bottomAtLineIndex: lineIndex 	"Answer the bottom y of given line."	| y |	y _ compositionRectangle top.	lastLine = 0 ifTrue: [^ y + textStyle lineGrid - 1].	1 to: (lineIndex min: lastLine) do:		[:i | y _ y + (lines at: i) lineHeight].	^ y - 1! !!Paragraph methodsFor: 'private' priorSource: 997249 inFile: 2!displayLines: linesInterval affectedRectangle: affectedRectangle	"This is the first level workhorse in the display portion of the TextForm routines.	It checks to see which lines in the interval are actually visible, has the	CharacterScanner display only those, clears out the areas in which display will	occur, and clears any space remaining in the visibleRectangle following the space	occupied by lastLine."	| lineGrid topY firstLineIndex lastLineIndex lastLineIndexBottom |	"Save some time by only displaying visible lines"	firstLineIndex _ self lineIndexOfTop: affectedRectangle top.	firstLineIndex < linesInterval first ifTrue: [firstLineIndex _ linesInterval first].	lastLineIndex _ self lineIndexOfTop: affectedRectangle bottom - 1.	lastLineIndex > linesInterval last ifTrue:			[linesInterval last > lastLine		 		ifTrue: [lastLineIndex _ lastLine]		  		ifFalse: [lastLineIndex _ linesInterval last]].	lastLineIndexBottom _ (self bottomAtLineIndex: lastLineIndex).	((Rectangle 		origin: affectedRectangle left @ (topY _ self topAtLineIndex: firstLineIndex) 		corner: affectedRectangle right @ lastLineIndexBottom)	  intersects: affectedRectangle)		ifTrue: [ " . . . (skip to clear-below if no lines displayed)"				DisplayScanner new					displayLines: (firstLineIndex to: lastLineIndex)					in: self clippedBy: affectedRectangle].	lastLineIndex = lastLine ifTrue: 		 [destinationForm  "Clear out white space below last line"		 	fill: (affectedRectangle left @ (lastLineIndexBottom max: affectedRectangle top)				corner: affectedRectangle bottomRight)		 	rule: rule fillColor: self backgroundColor]! !!Paragraph methodsFor: 'private' priorSource: 1149634 inFile: 2!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work." 	compositionRectangle height:		(self bottomAtLineIndex: lastLine) - compositionRectangle top.	(text size ~= 0 and: [(text at: text size) = CR])		ifTrue: [compositionRectangle 					height: compositionRectangle height + (lines at: lastLine) lineHeight]! !----QUIT----(6 November 1996 11:35:50 am ) priorSource: 1142856!'From Squeak 1.13 of October 17, 1996 on 5 November 1996 at 9:20:00 am'!!ParagraphEditor methodsFor: 'typing/selecting keys' priorSource: 911216 inFile: 2!forwardDelete: characterStream	"Delete forward over the next character.	11/4/96 tk  Make Undo work on the whole type-in, not just the onechar."	| char startIndex usel upara uinterval ind |	startIndex _ startBlock stringIndex.	startIndex = stopBlock stringIndex ifFalse: ["there was a selection"		"Just like regular Backspace -- delete the selection"		^ self backspace: characterStream].	"Null selection - do the delete forward"	beginTypeInBlock == nil	"no previous typing.  openTypeIn"		ifTrue: [self openTypeIn. UndoSelection _ self nullText].	uinterval _ UndoInterval deepCopy.	"umes _ UndoMessage deepCopy.	Set already by openTypeIn"	"usel _ UndoSelection deepCopy."	upara _ UndoParagraph deepCopy.	char _ Sensor keyboard.	self selectFrom: startIndex to: startIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph _ upara.  UndoInterval _ uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isKindOf: Text) ifTrue: [			usel _ UndoSelection.			ind _ startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !	Display restoreAfter: [WarpBlt test12]!Undeclared!----QUIT----(6 November 1996 12:29:35 pm ) priorSource: 1156700!'From Squeak 1.13 of October 17, 1996 on 7 November 1996 at 3:32:30 pm'!!ChangeList class methodsFor: 'public access' priorSource: 1036789 inFile: 2!browseRecentLog    "ChangeList browseRecentLog"	"Prompt with a menu of how far back to go"	| end changesFile banners positions pos chunk i |	changesFile _ (SourceFiles at: 2) readOnlyCopy.	banners _ OrderedCollection new.	positions _ OrderedCollection new.	end _ changesFile size.	pos _ Smalltalk lastQuitLogPosition.	[pos = 0 or: [banners size > 20]] whileFalse:		[changesFile position: pos.		chunk _ changesFile nextChunk.		i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos _ Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos _ 0]].	changesFile close.	pos _ (SelectionMenu labelList: banners reversed selections: positions reversed)				startUpWithCaption: 'Browse as far back as...'.	pos == nil ifTrue: [^ self].	self browseRecent: end-pos! !!CompositionScanner methodsFor: 'scanning' priorSource: 1074605 inFile: 2!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	spaceX _ destX _ leftMargin _ aParagraph leftMarginForCompositionForLine: lineIndex.	destY _ 0.	rightMargin _ aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex _ startIndex.	"scanning sets last index"	lineHeight _ textStyle lineGrid.  "may be increased by setFont:..."	baseline _ textStyle baseline.	self setStopConditions.	"also sets font"	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ super				scanCharactersFrom: lastIndex				to: runStopIndex				in: text string				rightX: rightMargin				stopConditions: stopConditions				displaying: false.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!Paragraph methodsFor: 'accessing' priorSource: 1089758 inFile: 2!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY upOrDown moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	"find the starting and stopping lines"	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange _ aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle height: textStyle lineGrid * 8196.	"max Vector length"	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner _ CompositionScanner new in: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex _ (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine _ startLine - 1.							self lineAt: startLine put: newLine.							startIndex _ newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor.			self updateCompositionHeight.			^self]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine _ compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						upOrDown _ replacementRange < 0							ifTrue: [0] ifFalse: [1].							"get source and dest y's for moving the unchanged lines"						obsoleteY _ self topAtLineIndex: lastLineIndex + upOrDown									using: obsoleteLines and: obsoleteLastLine.						newY _ self topAtLineIndex: firstLineIndex + upOrDown.						stopLine _ firstLineIndex.						done _ true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex _ firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].		startIndex _ newLine last + 1.		firstLineIndex _ firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine _ firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle _				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: obsoleteY)						to: (self lineIndexOfTop: visibleRectangle top))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'private' priorSource: 1154324 inFile: 2!bottomAtLineIndex: lineIndex 	"Answer the bottom y of given line."	| y |	y _ compositionRectangle top.	lastLine = 0 ifTrue: [^ y + textStyle lineGrid].	1 to: (lineIndex min: lastLine) do:		[:i | y _ y + (lines at: i) lineHeight].	^ y! !!ParagraphEditor methodsFor: 'editing keys' priorSource: 1010979 inFile: 2!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to accept 	characters with the change in emphasis. Emphasis change amounts to a 	font change.  Keeps typeahead."	| keyCode attribute oldAttributes index |		 "control 0..9 -> 0..9"	keyCode _ ('0123456789-=' indexOf: sensor keyboard ifAbsent: [1]) - 1.	oldAttributes _ paragraph text attributesAt: startBlock stringIndex.	"Decipher keyCodes for Command 0-9..."	(keyCode between: 1 and: 5) ifTrue:		[attribute _ TextFontChange fontNumber: keyCode].	keyCode = 6 ifTrue:		[index _ (PopUpMenu labelArray: #(black magenta red yellow green blue active)							lines: #(6)) startUp.		index = 0 ifTrue: [^ true].		attribute _ index = 7		ifTrue: [TextAction evalString: self selection asString]		ifFalse: [TextColor color: (Color perform: (#(black magenta red yellow green blue cyan) at: index))]].	(keyCode between: 7 and: 11) ifTrue:		[attribute _ TextEmphasis perform:					(#(bold italic narrow underlined struckOut) at: keyCode - 6).		oldAttributes do:			[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	(keyCode = 0) ifTrue:		[attribute _ TextEmphasis normal].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream.			emphasisHere _ Text addAttribute: attribute toArray:					oldAttributes.			^ true].	self replaceSelectionWith: (self selection addAttribute: attribute).	^ true! !!ParagraphEditor class methodsFor: 'class initialization' priorSource: 911839 inFile: 2!initialize	"Initialize the keyboard shortcut maps and the shared buffers	for copying text across views and managing again and undo.	6/18/96 sw: call initializeTextEditorMenus	other times: marked change to trigger reinit" 	"ParagraphEditor initialize"	CurrentSelection _ UndoSelection _ FindText _ ChangeText _ Text new.	UndoMessage _ Message selector: #halt.	self initializeCmdKeyShortcuts.	self initializeShiftCmdKeyShortcuts.	self initializeTextEditorMenus! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' priorSource: 912408 inFile: 2!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key shortcut table."	"ParagraphEditor initialize"	| cmdMap cmds |	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 8 + 1) put: #backspace:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"cmd-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	'0123456789-=' do: [ :char | cmdMap at: (char asciiValue + 1) put: #changeEmphasis: ].	'([{''"<'         do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose: ].	cmdMap at: ($, asciiValue + 1) put: #shiftEnclose:.	cmds _ #(		$a	selectAll:		$b	browseIt:		$c	copySelection:		$d	doIt:		$e	exchange:		$f	find:		$g	findAgain:		$h	setSearchString:		$i	inspectIt:		$j	doAgainOnce:		$k  offerFontMenu:		$l	cancel:		$m	implementorsOfIt:		$n	sendersOfIt:		$o	spawnIt:		$p	printIt:		$q	querySymbol:		$r	recognizer:		$s	save:		$t	tempCommand:		$u	align:		$v	paste:		$w	backWord:		$x	cut:		$y	swapChars:		$z	undo:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).	].	CmdActions _ cmdMap.! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' priorSource: 913666 inFile: 2!initializeShiftCmdKeyShortcuts	"Initialize the shift-command-key (or control-key) shortcut table."	| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	cmdMap at: (27 + 1) put: #shiftEnclose:.	"ctrl-["	cmds _ #(		$a	argAdvance:		$b	browseItHere:		$c	compareToClipboard:		$d	duplicate:		$f	displayIfFalse:		$j	doAgainMany:		$k	changeStyle:		$n	referencesToIt:		$r	indent:		$l	outdent:		$s	search:		$t	displayIfTrue:		$w	methodNamesContainingIt:		$v	pasteInitials:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1)			put: (cmds at: i + 1).		cmdMap at: (((cmds at: i) asciiValue - 96) + 1)	put: (cmds at: i + 1).	].	ShiftCmdActions _ cmdMap.! !!PopUpMenu methodsFor: 'private' priorSource: 778829 inFile: 2!rescan	"Cause my form to be recomputed after a font change."	labelString == nil ifTrue: [labelString _ 'NoText!!'].	self labels: labelString font: (MenuStyle fontAt: 1) lines: lineArray.	form _ nil.	"PopUpMenu withAllSubclasses do: [ :menuClass |		menuClass allInstancesDo: [ :m | m rescan ]]"! !!PopUpMenu class methodsFor: 'instance creation' priorSource: 589597 inFile: 2!labels: aString lines: anArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray."	^self new		labels: aString		font: (MenuStyle fontAt: 1)		lines: anArray! !!PopUpMenu class methodsFor: 'class initialization' priorSource: 1083285 inFile: 2!initialize  "PopUpMenu initialize"	"Change CacheMenuForms to true to get faster popup menus on slower systems."	"CacheMenuForms _ true"	CacheMenuForms _ false.	(MenuStyle _ TextStyle default copy)		gridForFont: 1 withLead: 0;		alignment: 2.	PopUpMenu withAllSubclasses do:		[:menuClass | menuClass allInstancesDo:			[:m | m rescan]]! !!StrikeFont methodsFor: 'emphasis'!bonk: glyphForm with: bonkForm	"Bonking means to run through the glyphs clearing out black pixels	between characters to prevent them from straying into an adjacent	character as a result of, eg, bolding or italicizing"	"Uses the bonkForm to erase at every character boundary in glyphs."	| bb offset |	offset _ bonkForm offset x.	bb _ BitBlt toForm: glyphForm.	bb sourceForm: bonkForm; sourceRect: bonkForm boundingBox;		combinationRule: Form erase; destY: 0.	1 to: xTable size-1 do: [:i | bb destX: (xTable at: i) + offset; copyBits].! !!StrikeFont methodsFor: 'emphasis' priorSource: 1013691 inFile: 2!emphasized: code 	"Answer a copy of the receiver with emphasis set to include code."	| derivative addedEmphasis base g r safeCode |	code = 0 ifTrue: [^ self].	derivative _ derivativeFonts at: (safeCode _ code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis _ 1 bitShift: safeCode highBit - 1.	base _ self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative _ (base copy name: base name , 'B') makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative _ (base copy name: base name , 'I') makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative _ (base copy name: base name , 'U') makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative _ (base copy name: base name , 'N') makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative _ (base copy name: base name , 'X') makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative! !!StrikeFont methodsFor: 'emphasis'!makeBoldGlyphs	"Make a bold set of glyphs with same widths by ORing 1 bit to the right		(requires at least 1 pixel of intercharacter space)"	| g |	g _ glyphs deepCopy.	self bonk: glyphs with: (Form extent: (1@self height) fillBlack).	g copyBits: g boundingBox from: g at: (1@0)		clippingBox: g boundingBox rule: Form under fillColor: nil.	glyphs _ g! !!StrikeFont methodsFor: 'emphasis'!makeCondensedGlyphs	"Make an underlined set of glyphs with same widths"	| g newXTable x x1 w |	g _ glyphs deepCopy.	newXTable _ Array new: xTable size.	newXTable at: 1 put: (x _ xTable at: 1).	1 to: xTable size-1 do:		[:i | x1 _ xTable at: i.  w _ (xTable at: i+1) - x1.		w > 1 ifTrue: [w _ w-1].  "Shrink every character wider than 1"		g copy: (x@0 extent: w@g height) from: x1@0 in: glyphs rule: Form over.		newXTable at: i+1 put: (x _ x + w)].	xTable _ newXTable.	glyphs _ g"(TextStyle default fontAt: 1) copy makeCondensedGlyphs	displayLine: 'The quick brown fox jumps over the lazy dog'	at: Sensor cursorPoint"! !!StrikeFont methodsFor: 'emphasis'!makeItalicGlyphs	"Make an italic set of glyphs with same widths by skewing left and right		(may require more intercharacter space)"	| g r bonkForm bc |	g _ glyphs deepCopy.	"BonkForm will have bits where slanted characters overlap their neighbors."	bonkForm _ Form extent: (self height//4+2) @ self height.	bc _ self descent//4 + 1.  "Bonker x-coord corresponding to char boundary."	bonkForm fill: (0 @ 0 corner: (bc+1) @ self ascent) fillColor: Color black.	4 to: self ascent-1 by: 4 do:		[:y | 		"Slide ascenders right..."		g copy: (1@0 extent: g width @ (self ascent - y))			from: 0@0 in: g rule: Form over.		bonkForm copy: (1@0 extent: bonkForm width @ (self ascent - y))			from: 0@0 in: bonkForm rule: Form over].	bonkForm fill: (0 @ 0 corner: (bc+1) @ self ascent) fillColor: Color white.	bonkForm fill: (bc @ self ascent corner: bonkForm extent) fillColor: Color black.	self ascent to: self height-1 by: 4 do:		[:y | 		"Slide descenders left..."		g copy: (0@y extent: g width @ g height)			from: 1@y in: g rule: Form over.		bonkForm copy: (0@0 extent: bonkForm width @ bonkForm height)			from: 1@0 in: bonkForm rule: Form over].	bonkForm fill: (bc @ self ascent corner: bonkForm extent) fillColor: Color white.	"Now use bonkForm to erase at every character boundary in glyphs."	bonkForm offset: (0-bc) @ 0.	self bonk: g with: bonkForm.	glyphs _ g! !!StrikeFont methodsFor: 'emphasis'!makeStruckOutGlyphs	"Make a struck-out set of glyphs with same widths"	| g |	g _ glyphs deepCopy.	g fillBlack: (0 @ (self ascent - (self ascent//3)) extent: g width @ 1).	glyphs _ g! !!StrikeFont methodsFor: 'emphasis'!makeUnderlinedGlyphs	"Make an underlined set of glyphs with same widths"	| g |	g _ glyphs deepCopy.	g fillBlack: (0 @ (self ascent+1) extent: g width @ 1).	glyphs _ g! !!StrikeFont methodsFor: 'emphasis' priorSource: 1016136 inFile: 2!reset	"Reset the cache of derivative emphasized fonts"	derivativeFonts _ Array new: 32! !!StrikeFont methodsFor: 'file in/out'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(' , self name , ')'! !!StrikeFont class methodsFor: 'examples' priorSource: 1050078 inFile: 2!hackDefaultStyle		"StrikeFont hackDefaultStyle"	"Assumes that Clairvaux was created as a subclass with class methods	sizeNN defined following the comment in size:fromLiteral:"	TextStyle default newFontArray:		(Array with: Clairvaux size12				with: Clairvaux size14				with: Clairvaux size18				with: Clairvaux size24				with: Clairvaux size10).	PopUpMenu initialize.	ListParagraph initialize.	StandardSystemView initialize.	"Needless to say, an initialize method in such a fontSet class could invoke	this kind of setup at fileIn time, followed immediately by throwing the class	away, since it is wasted space after the fonts have been installed"! !!SwitchView methodsFor: 'label access' priorSource: 1727680 inFile: 1!centerLabel	"Align the center of the label with the center of the receiver's window."	label == nil  ifFalse: 		[(label isKindOf: Paragraph)			ifTrue: ["Compensate for leading in default style"					label align: label boundingBox center + (0@1)							with: self getWindow center]			ifFalse: [label align: label boundingBox center 							with: self getWindow center]]! !!TextEmphasis class methodsFor: 'as yet unclassified'!narrow	^ self new emphasisCode: 8! !!TextEmphasis class methodsFor: 'as yet unclassified' priorSource: 955878 inFile: 2!struckOut	^ self new emphasisCode: 16! !!TextStyle methodsFor: 'private'!consolidate	"If this style includes any fonts that are also in the default style,	then replace them with references to the default ones.""	TextStyle allInstancesDo: [:s | s == TextStyle default ifFalse: [s consolidate]]"	| defFonts font |	defFonts _ TextStyle default fontArray.	1 to: fontArray size do:		[:i | font _ fontArray at: i.		1 to: defFonts size do:			[:j | (font name asUppercase copyWithout: $ )			= ((defFonts at: j) name asUppercase copyWithout: $ )			ifTrue: [fontArray at: i put: (defFonts at: j)]]]! !!Utilities class methodsFor: 'support windows' priorSource: 1030246 inFile: 2!commandKeyMappings	^ self class firstCommentAt: #commandKeyMappings"Lower-case command keysa	Select allb	Browse itc	Copyd	Do ite	Exchangef	Findg	Find againh	Set Search Stringi	Inspect itj	Again oncek	Set fontl	Cancelm	Implementors of itn	Senders of ito	Spawnp	Print itq	Query symbolr	Recognizers	Save (i.e. accept)u	Alignv	Pastew	Delete preceding wordx	Cuty	Swap charactersz	UndoUpper-case command keys (Hold down Cmd & Shift, or Ctrl key)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateF	Insert 'ifFalse:'J	Again manyK	Set styleL	Outdent (move selection one tab-stop left)N	References to itR	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'W	Selectors containing itV	Paste author's initials<return>		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)esc			Select current type-inshift-delete	Forward delete character (not currently undo-able)[	Enclose within [ and ], or remove enclosing [ and ](	Enclose within ( and ), or remove enclosing ( and )   NB: use ctrl ({	Enclose within { and }, or remove enclosing { and }<	Enclose within < and >, or remove enclosing < and >'	Enclose within ' and ', or remove enclosing ' and '""	Enclose within "" and "", or remove enclosing "" and ""1	10 point font2	12 point font3	18 point font  (not in base image)4	24 point font  (not in base image)5	8 point font  (not in base image)6	add color / make active	(nb: to remove the active quality of text, you must select	more than the active part and then use command-0)7	bold8	italic9	narrow0	plain text (resets all emphasis)-	underlined=	struck out"	"Answer a string to be presented in a window at user request as a crib sheet for command-key mappings.  2/7/96 sw5/1/96 sw: modified so that the long string lives in a comment, hence doesn't take up memory.  Also, fixed up some of the actual text, and added help for parentheses-enclosing items and text-style controls.5/10/96 sw: added a bunch of changes at JM's suggestion8/11/96 sw: fixed the font sizes, added align & references to it, and help for cmd-shift-B11/2/96 di: added ctrl-return and shift-delete, and new assignments of cmd 0-911/7/96 di: new assignments of cmd 0-9, with - and = "! !TextStyle default leading: 0!ParagraphEditor initialize!PopUpMenu initialize!ListParagraph initialize!StrikeFont removeSelector: #emphasized:named:!StrikeFont removeSelector: #emphasized:named:!TextFontChange removeSelector: #oldEmphasisCode:!TextFontChange removeSelector: #oldEmphasisCode:!!StrikeFont methodsFor: 'emphasis' priorSource: 1175601 inFile: 2!makeBoldGlyphs	"Make a bold set of glyphs with same widths by ORing 1 bit to the right		(requires at least 1 pixel of intercharacter space)"	| g bonkForm |	g _ glyphs deepCopy.	bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.	self bonk: g with: bonkForm.	g copyBits: g boundingBox from: g at: (1@0)		clippingBox: g boundingBox rule: Form under fillColor: nil.	glyphs _ g! !TextStyle default leading: 1!----QUIT----(7 November 1996 8:13:44 pm ) priorSource: 1158253!'From Squeak 1.13 of October 17, 1996 on 7 November 1996 at 11:07:14 am'!StrikeFont subclass: #Clairvaux	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Support'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Clairvaux class	instanceVariableNames: ''!!Clairvaux class methodsFor: 'as yet unclassified'!size09		"(FileStream readOnlyFileNamed: 'Clairvaux09.sf2') contentsOfEntireFile"	^ self size: 09 fromLiteral: '             
         	                    	                                       !!   #   %   ''   )   +   -   /   1   3   5   7   9   ;   =   ?   B   E   I   P   U   ]   e   h   l   p   v   |                                                                                            %  .  5  <  A  H  O  T  Z  a  h  q  w  }                                                                      !!  $  *  /  /  6  <  <  <  <  <  A  F  K  P  U  Z  ^  c  h  m  r  u  x  {  ~                                                            !!  ''  -  2  9  @  E  J  O  U  U  \  a  f  i  n  s  x  }                                                                                       &  +  0  6  ;  A  G  N  S  X  X  _  _  _  b  b  bb                 @                                                        @   Q  @ HP`                                    :                           b(   &g0  xgx9 %         	  PJR*" T  f?  &     , "h    f  s8pD            "D )2Rd!!)H H$e)$$CeY*"A(R	 @@         	  !!       @      B%
$~$"X  *   
RDP    @ qDL
            ?A   ID8IH `)$"(B$I"I
S9lv<  R1cc6g9vaijp"zs<QQ     ajA
D            b0S I9,>9&28BIT''Bp*A lJm$jm$*5 R	JRRIsR1)jP EO~"H"JPsd   @1a-
TJ(            ~QT  a%$"t,BIt$BP"*(B LK$J))	* 9sI(1RH-S  8"*sHRT(R?  RBQJ1
DYJ             (T@  $ %E#$$R	6DdYb(DP N		$K)$AEI  )JRI,9%
 &O"**PK`   !! p"Dq
eUJ            (b# ;s   ;qv8lH s-W8AI 9ss9qJRh    ?wjC9      #jds8D              B  D        @              (       H             @                H                                                        @  (                         F       ?                @               p                                                                                                        8                                                                               '! !!Clairvaux class methodsFor: 'as yet unclassified'!size10		"(FileStream readOnlyFileNamed: 'Clairvaux10.sf2') contentsOfEntireFile"	^ self size: 10 fromLiteral: '                	      
                 	                        !!   $   ''   ''   *   -   0   3   6   9   <   ?   B   E   H   K   N   Q   T   W   Z   ]   `   c   f   m   r   {                                                                                             %  ,  4  8  <  C  I  S  [  c  i  q  x  ~                                                          $  )  .  3  6  <  C  K  P  V  [  ^  a  d  j  j  j  r  y  y  y  y  y  ~                                                        
        "  *  2  =  @  E  K  T  \  d  i  o  u  |                                                      
        #  &  )  .  4  :  :  ;  <  =  >  ?  @  A  B  E  J  O  T  Y  ^  c  h  o  u  z                                                                                                                                                                                                           TSD     >}\q|s?w 0 00K          
R QSBbIB)?P 0 (       (Z     ` x8c               TUT  )2  $aI$dDD1H#"J")@ @@          @  BB C$` BDH,        P#P     %`cL6              A)*  $"3 `)" DE1PIA"B"HPH aL%hsGil}
!!1c1mqgy .P fa D}8 %	  QQN     `!!$?%IU              @4  $$RZ'',J8F*PIA"pBBH  IID42I$HFH JR)JRI&i(g*"@D	i%1EH$   $U a"H              @KD$p$BPR#  tDF*PNA<BCX A ^LI$)#&(
 9s{I$P0(B.	)"0aD	,%RJ$$D  }B@1"/%H              CQ   DxRDP $DE*PHA(BAPBD PGI$) ") JRBI$P0($C 
& D)	9JHHG    BQc?%H"H              E !! F	ZD`$DX$$DD$b$C XD(D DI$$)"IcH1ZkZI$YeY&i 1  	,@BD-
i!!0d     p"$"JU              ACB@9C  <}NuO<sp$ cl;?vqs;o{1n8i    }I(P;     #t
Ywx                @                   @     $       $     	         @     @            $                                                                                            C                                                                                                                                                               @                                              `                                '! !!Clairvaux class methodsFor: 'as yet unclassified'!size12		"(FileStream readOnlyFileNamed: 'Clairvaux12.sf2') contentsOfEntireFile"	^ self size: 12 fromLiteral: '                
                                                                                                                                         (   2   4   8   <   C   K   N   S   V   \   b   h   n   t   z                                                           
        $  0  :  C  J  S  \  c  k  u                                              	      $  +  1  7  <  @  G  O  Y  `  g  m  q  u  y                                                                $  +  2  8  9  ?  F  L  S  [  c  l  u                                                "  )  0  6  =  E  L  S  \  ]  ]  ]  ]  i  t  {                                                                    #  +  2  :  B  K  Q  W  W  a  a  a  e  e  ee       h   @                                                                                                                                                                            08"   ''q>#    |?~<gw `              $  i  D	DHA	     0   !!       "H        `         )TH$A   )# B)   "#!!"FADBaRH"I   @	           " d(K(I`* 
DB%[ A  D$(  !! $   1   BP(6     @$  @DG	%)     )DP$F  H% (  d("A  ADQ HH#(    @            "                    B   `@ B    @     DD v     @  DB%)      !!  HE<M" 00$($@ $AEQ HI!!( ,cG<c"ll6"&8p88s6l<C
i }1B An!! 2q@       EQ     E#7O |     PcLw" &G6D E$D.@ <GI HN!!UAD "29	B3#"f1$DE"" "D1EHf$HT*%1`#@	4f!!?T !!) f     >(!!)DQ(aGWH
.$(     PPR  iI 00EH|!!@ $AEE K K !!cAD "O	""$$Q!!D$D!! <x}B	$HPBg(  E $	JA B"DC   H aXJDaTRH
.$     P  @/  !!@  ADE H IB c!!  ""H	""$$Q dDP(" "DAB	$HPC#    $B	R $@B      P (JDGTO 	%)     P  !!"D   F "a!! ADb$DC00B@AH!!  &"	b""&FS!!$LPD)" L)&L39eHf2dTDB    }lD$
4f!!D1g       SE]TDD#TB*%)     {@ 
p   C|>~?p|N7Ng@A  <cg87ww3q6 D6" 86l88pf9`      9n8q  )	#9      0 !!v%9	;;       A  @                       @      
@                                                                      @                              @                                            @                                      @                                                                  @                                                                                                                                                  @                                                                                               `                                                                                                 '! !!Clairvaux class methodsFor: 'as yet unclassified'!size14		"(FileStream readOnlyFileNamed: 'Clairvaux14.sf2') contentsOfEntireFile"	^ self size: 14 fromLiteral: '                                                          $   (   ,   0   4   4   8   <   @   D   H   L   P   T   X   \   `   d   h   l   p   t   x   |                                                                      #  *  .  2  ;  D  M  T  `  l  u  ~                                    *  5  C  L  V  _  c  j  n  t  }                                      
        &  2  :  B  I  N  R  W  `  `  `  l  u  u  u  u  u  }                                              $  ,  3  4  ;  C  J  R  [  d  o  z                                      ''  ''  2  :  A  E  M  U  \  d  m  u  }                                                                  $  -  5  <  C  K  S  ^  f  m  v  ~                                                                                                                                                                                                                                                                    " `!! @   !!''     9qp>?wl 0  `               	 A  @ $        >                  `         $D               |                    ""@   "D$    a!!!!!!0BC4D"D	@                    0BA"@(HB)FAAY"C  00     < D           !!    $$ A6@      0H `A0Ap	0                 "@"   DJ"$H   !!
"	   H"8DD@"( 
           @       B"BDHEI D DA $   P8 D B )          @    $H v@      @ B QH                  @@   DB( FH "v
$  @$
,H D @b(               @      	                       KT   PH 00D  !! P    @   @       !! R@        bQ Q0	H                     B(`CDD$$@(

$H @C,@0  49877 81%$T   |(D!!`\w  A@@ @y          """ I E O                  		  BH	0  0<<@8&H @AE`  LL!!1"B	 !!bbbbbb&LBDdddddDDDA_ $   	00D:	H!!p'' A!!  @`     	       % SI } D@                  	[4   BH	 & 4$$A,	"H  p@E  D!!!!HP B!! !!      $PBBH(((($DDDAIe0 
bDfH!!  "@ @''    pa)RI E D@                  ?J  B|	@ ,?  @H&	#H  @E  D!!!!HPB	 ?~BH(((($DDDAk5   
2   DBH!!p !!!!  @       HB1HRQ0                  J   B	A        `H#!!L@   !!!!!!HQB
 @$$$$$$ @BH(((($DDDAL,	   |  DB H!!!!( B @ `       @  8BDRH                  
k   &B   @D#	!! 0!!H!!F @  32!!!!"B0D!! @ffffffXbBLLLLLDHC &      Md@DJ!!@Q  @   1        ` (!!LAI$H                   1  @$<    p9pGp|83|   vy311@D!!? <x9gccca|       8{8!!@  @ "       @ 8!!dG`|90                       @                                 0                   `                                                        @      @                      @             @                                                                      H                                  @                                                                                 @                                                                                               @                                                                                                                                                                                                                   0                                                                                                                                                                                                                                                                                                                                    '! !!Clairvaux class methodsFor: 'as yet unclassified'!size18		"(FileStream readOnlyFileNamed: 'Clairvaux18.sf2') contentsOfEntireFile"	^ self size: 18 fromLiteral: '                                    
               #   (   -   2   7   <   A   A   F   K   P   U   Z   _   d   i   n   s   x   }                                                               ''  0  9  B  K  T  ]  f  o  x  }                              &  -  ;  E  W  f  t  ~                      	        +  1  ;  E  M  W  `  g  q  |                                  $  -  3  8  >  I  I  I  X  d  d  d  d  d  n  w                                  	      ''  1  ;  E  N  O  X  b  k  u                        
      *  6  ?  M  \  f  o  y                                         %  /  @  I  R  W  \  e  o  y  y  z  {  |  }  ~                                        #  /  9  G  T  b  k  t  t                   3                       (    @                                                                                                                                                                                                                                 0                                         (    `                                                                  @                                       @                                                                                                                    p                                       |x0@    x0<x       `?>~<|??~}?@     8  p                    @@    @ "                    ~                        "3               p  `                           1  &@    pf''"     `< p`C0"0` 08@0@ha`Aa@d P     2 0`                    ($&   A
(2 @(	 @
 f     < @       8                   D3             0     b                        1 "B    C      F  0$0` p<ca(a`Ab@d      0 0  `                  a D    A L  D  Afa	  <!!     ` l       `           f@ @@          
0 80@bdH                       0 I" B @   !!0A  0   !!00` p4c	a ``2 d      0 0  `                !!0`                             0fbb	
l   l f b  0 l      `           f"            0 >0fdH                       0 I" d 0   !!0   0 AA0 0` 6c	a ``4    >|x3awxqs<  ``|>8<qp|f8BR
(T   @lb`l` `A                    0 k0f?I                       04@8     A0`3` $2 0` 2c	a `0   ca3807b9`ob11`(1  ``cc1d2aqaFc00fR
D  ?? `4`0`0p |""D  0                `0afc                        0 @88     A0# l0!!c  $> ` 3ca `1 f0   A218d01qc11@a  ``2AX,aa2 300fb(F   	 4a0`0H0``D"        b        p`f`H                        0 < ,0    0# l0`0   $2 0` 1ca`1 f     610h03`c0@ 0` 0,aa6`300~fR	    a `c0`0Xp``         b   8!!p,`f`H                        0 . F      0 l0A 	00` 1ca ` f     610p03`c0A  `~?aa6`300f    !!a~c0` `a     b  	@ bCp0`ca                         .D@   x00l0v    	00` 0ca `` )`    !!600x03`c 0(  `1C!! aa6`300    ?A  f c0`02  `"0           4   p aC80abI                        A.D    0`@l0   0  `	00` 0ca`` 9& 0   a60p0l03`c 10h(  `,3a aa6`3000 f`       <?  c08`04`A0D"           @4  @aC,0ddH                        A.D0   0Al1` 0   <00`0QCA``
 9# `$   a600f03`c10h#  `,3a aa&	`#00`  f@        #      ~c`0`0$` 0"D  &          4    @
`	&IDdH                       0 h`   b0#Fac       00`0p `  C `$   bc800c01q1P0A  0LSaL&	aaC1AeFP  f        #   u0`8LF `   #            @#k`fM                        0  0|8   d       ~~|0     <|x|xx8~g0  |?}g<x9c x f;               <0`@ `              `0#8>|~?                           (                                                 6                                   ` `                                             f                            `       `                                                                             (   0                                               b@                                 ` `                                             f                            `         `                                                                             (    `                                                                               ` `                                             0 f                           `         @                                                                                  @                                                                                    ` `                                                                              `                                                                                                                                                                                       ` `                                                                                                                                                                                                                                                                   |                                                                                                                           @                                                                                                                                                                                                                                                                                                                         '! !!Clairvaux class methodsFor: 'as yet unclassified'!size24		"(FileStream readOnlyFileNamed: 'Clairvaux24.sf2') contentsOfEntireFile"	^ self size: 24 fromLiteral: '                   	                                                                                                                                                       ''   3   H   [   `   h   p   }                                         &  ,  3  B  Q  `  l                        (  6  N  b  t                    #  3  :  F  M  W  g  o  {                          !!  /  =  J  V  a  i  x                                      &  2  >  J  V  a  m  y                            %  4  C  O  Q  ]  k  w                      +  >  J  X  f  v                      
      +  9  E  R  b  p  ~                        	  	
  	  	$  	2  	2  	4  	6  	8  	:  	<  	>  	@  	B  	J  	V  	b  	n  	z  	  	  	  	  	  	  	  	  	  
   
  
  
)  
7  
G  
X  
j  
v  
  
  
  

       	                                                                                                                                                              8                                                                                                                                                                                                                                                                                                                                                  d                                                                                                                                                             0                     !!   `      <||       ? ` ~ |          8     <                         0 L                                           ?             ?@      x  >       @    `                   	             |     p            >  a @      F `        @0  C `0 p p 0C 0   `P        |                            8  0       	    6             A                  0  C !!   D                         	                   x          ~0  a ?< `      000       @`  aC `0 p x  0C 0   `                                       @    6p  $0  $  D   ?`             !!   D                       B                  !!@   ? `f  a@T0 `      0`0       @a   !!`  `0  x h a  @0 0  `                                        8  P   @!!     B  B 0  > $`          `      E                      0C  "                 0      0`$  ` @1         !! 0,  10     b 0 0  `0@ xl a   0   `                                         8                                       0  G p$(     3 0   ` `@     F                      0  A                  8    <x0 $  ` 1  @     !!  , !!0      f 0 0  `0 l`f a   0   `                                         L                                         0   #	H     3 0    0@   L                                            >  `p~ `0 $  ` 2   @    A @L  0     F  0 0  `1  l`b a   0 	   `    ~x?<<8~?xx~>   L<||<<<<8>  0 9d     3 0   ` 0@@@`@t|@  0  a             G             c	 `02c `0?$0  ` 2   @      A LA `x0  ` ` @ 00  `2  f`c a  0 	    `    6`Ap7p0A0!!   0c0c0`F``pGp`` `0 $d    c 0   0?`  0? @             !!               `1"# 0`  ` t4x@       !! @80    00 `>  f`a a   0  `  0 `     0 88a00a    2 2 0118 8``  ?$d    c0@  `9HcEa   0             A             2b30 &0` $   `  >$ @     p 1 @\p     00  `?  c`` a  0  ` h ` `    `L0A@030 0@     0 0 100@q`` 1 0`?8f8    0f0   }`F " `                 p `@qq4b30 0` $   `  1 @      1 1    f 0 0 `1 c`` a   0   x  `    `0A003   0003 0`` 1 00?$s     1 <  ` 0`L&	 ` D@           A     ` `8b30 `0`  `	` @     0 1 1 0 ` `f 0 0 `0 a``b a   0  X  0 `    1`?003  #    001??03 0`` 1 0?8        2  `@t  D` (           "        <b3 `&0`$0  @ " `l @   ` 1 1  0    gf 0 0 `0` a``" a   0  X 0  @`    a`0 003 ~  0  1110 0 03 0`` 1 0? @       4  ` ?!!  B                      >b3 00`$    " `8 @      0 1 0     <f !!  0 `00 ```2 a  0 @8 0  @`    `0 ~`003 @  `   0303010 0 03 0`` 1 0        8     D0A  B (@               h     	 q7b3 0``$    " ` @     01 `      C !!@ 8 `0 ``` A  0 @ 0 0   `    `0 0080# @0    0303010 0 8#8``  1 ` |         @ 8 < `   D0 B Da                x        3"!!  0``$  ` D !!` @       !!         @AC  `0````
 c 0  0 0 F  `    `F8`0A8   ``0s0s0q88pA`  9 @            <f0       !! D0# A                  p    @   `	12a   0F`f  ` D  ?       @@         C  `0````1 0 @ 0 0 F `    0 0 ?X   `0#888!!!! 8 1`b  !!@8             N   !!  @9C A              0      ry @q0~  `0>`0  `    @x      x?| |         | `ax   0 `    }?????7 c  ==<|????? |x<y                       `|~0  @                          p p p<1 @0p<xx?>?       @                                                     `             8                     `             @           0                                                                                                                                                `                @                                                                                      `                                 `             `           0                                                                                                                                                 @                                                     `                                                  `                                  `                     0               0               (                                                                                                                                                                                                                              @                                                           0                                                                                                        0                                                                                                                                                                                                                     0                                                                    ?                                    `             8                                              @                                                                                                                                                @            0             0                                                                                                                                                                                                                                                                                                                           0                                                                                                                                                                                                                                                                                                                                                           `                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     '! !!Clairvaux class methodsFor: 'as yet unclassified'!size36		"(FileStream readOnlyFileNamed: 'Clairvaux36.sf2') contentsOfEntireFile"	^ self size: 36 fromLiteral: '             ''   "      $                    &   /   8   A   J   S   \   e   n   w   w                                                     $  /  ;  T  f                         2  D  V  h  z                    -  ?  ]  {              $  2  @  Z  o              +  C  a  ~                "  :  F  Y  m  }                    ;  S  g  |                  4  F  R  ]  ]  ]  `  `  ~                      	  	  	(  	:  	L  	^  	j  	v  	  	  	  	  	  	  	  
  
$  
9  
N  
c  
u  
x  
  
  
  
  
  
    )  P  \  n                0  H  Z  u                  (  3  H  ]  o                      (  =  ^  p                                  
    .  @  R  d  v                  1  I  ^  v                       0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      8                                                                          !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           !!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    `A      |               p            ?       ?    ?   ? 0      ~          0                                                                                                                                            ?      <                 x               ?                      `                                ?    ? ?                                        A    0     @           8 ?                     p    p `  8     <  0  8 p ? @ 0 `       H           8       xp                                                   @      `    @                                                          8 @            0      8                     @                             <                                                                                       A   !!8!!`   @            x`   @            x ?  8  8 @  p 0  8     <  0    8 @ @ 0`     @             8    @    xp                                           `              (    (        (    p@ @                                 x @             0    8  8                   @                           `` <                                                                                     A   !!a`              px   0           <   8    p    8     |  0     @ 0`    @     @       8   `@    0p                                         0    ?      @ D     D        D     @ "                              x @@                @  8                                               ``                             0    ?           x p `a`                                       A   !!a         0 98 !!  p               |    p@   8    |  0    @ 0 p                  8           p                                              C         1@ `8             A     8` < @8         a     @            `      8                                               pp    3                       p   ``     `     0 < 8 a`                                       A   !!a          p8 9     p               \    p     8       0   @   0 0  0                 8           p                                        `   @      `      1 `                       p  8   8  a     p           @    p  8                      8                          xx   a                      p   `@       `   a`                                         !!a              p8 9 p    p                   p     8  @    0 8  @   0 0   `                   8           p                                                                                                     p8  DP         p        @    8  8                     8                          xx                           p   `    ?      8  a`                                         !! a     <  @       p8 9 p    p     `   0          p     8     0 8      0 8  8 ` p0                  8           p                                                                                                       p  8'' < D`       p               8                     8                          00 0 `                        p   p   ??`    8  a`                                         !! 2      f  @      @p8  8 p p                p     8   `  0 8      0   0 p p            8    p | ?> >?         ?< @?  >  p  x bf D         p?    0    8          8 @ @                           1                   xp 8  xm0    8 ?a`                                         !!         @      @p8  8 p? 0p          0       p     8     0 8      0   0 q 8`  8         ?8 ? 8p   8p8 @808  8    08 888~   pp  p p  b&           p?  `      8 p8        8              8                 8    `                ?`p        8 a`                                         !!        @      p8  8  p@ 08          `   @   p     8   0 0 8       0  p 9 8@  p        p @`A8p0 8 @88 @8`8 8 p  p`p  0 p888   <pp !!p 8 8 bf           p       8 p8> x      ? p                             8                    ```p 0  `    8                                                  @      p8  8 @p p `   `     0  0     p     8    0 8  x     0 p `              8@p1   8p`  x8   8 p   8@  8@@  8889  x@ pp  p  8 c          8 p9      s   8  p8  8   8  p                                           0p0   `    \8                                                     @      p8  p p  8 `  0   0     p     8    0 8 0 >     0 p `             81  x ` | 8p  <  8     p  8   8@  80 c 88:@ < xpp  p 8 bF       8@q a   0 r     8  p8< 8    8  0p                                             q 0 p    8  a                                                     @      p8  p   8 `  x        0        8    `0 8 `     0 p              8 3  8 ` ` 8q    c 8    q    8   8@  8	p g 88< 0  8pp 0  p 8  b&           ?@q `     > `  p 8  p8l 8p     8  08 @      `               0           0        q `` 0   8  a                                          0 #          @      p8 p   8   x8        0     p     8    p0 8      0 8                 8 7  8 ` ` 8s     g 8   3 s    8    8    8 p g 888 p  8pp p  p 8@ f | 8      @ 8q `    0 <   p 8  p8  88p     8  `8   A                     `        p      p ``0p 0   8  a                                          0 !!   p           p8  80p   8  0        8     p     8    80 8        0 80                 8 7  8 ` ` 8v     g 8   3 >   @    8    8 p g 888# p  8pp p 08 0             8 q `         8  p8  88p     8   `8 A                              3 	 p  p 0``8 0      a                                          0 !!p 0  8     @      p8   0p   8          f      p  ~  8   8 0 8        0 80  3             ? 7  8 ` 8~     g 8  3    @   ??888C p  8pp p  p 0  8              8  q `       8  p88p    8  @ `   @               a      a    	 p 0 0    \                                           `0 !!8 0        @      p8   `p   8`   `     0  <      p    8   0 0 8      0 0 a 1   8           7  8 @ 8     g 8  3        888 p  8pp p  p 0 < x8             8  q `  `    8  p8?8p0   8 8                            3       A@  `  	 p0 0     @                                         `0 !! `8       @   p8   `p   8`              p    8    0  8      0 ` a a   p   @       8 7  8   8s    g 8  < a        8  8 p    888 p  8pp  p  p 0   <8                q `   0      8  p83 @8 8 p`    8     @                              @0 n `	 p ?00    a                                         !! `L        @      p8 8     8 `               p    p    8    0  8       0 ` a       @       8 7  8    8q    g 8   a   8     8@  8 p    888 p  8pp  p  p 0   8                 88  q `          8  p8 8 8@p    8  A                                 0 s  @ p ?0`  8 a`                                          ` !!  `      @      p8 p  p   8 `             p   p    8    0  8 p      0 ` 3              8 7  8    8p    g 8   a 3 p     80  80 p    888 p  8pp  p  p     8                 88  q''@          8  p? 8 8q   8    A                                  0 a  p 0   8 a`                                          !!        @      p8   p  8 `    `   0         8   p    8     0  8 8      0  3 p             8 7  8     8pp    g 8   a c      80  80 p    888 p  8pp  p  p     8                  p8  qC          8  8  p8 <8 9 q     8   @                                  0  a  p0   8 a`                                         !!        @       p8  p  8 `                 8   p    8  p      8      0  ?  8    F         8 ''  8    8p8    g 8        80  80 p    888 p  0pp  p       8               @  p8  ` p  8  p8 l8 : a     8                                      0  a9 p8!!`    8  a`                                         !!  p      @       p 8  p  8 `              ?   8   p    8  8      <       0     8    F         8 C 8    8p    gx      p  80  80 x   888 p   pp  8  8    8                   p8 C @              8  p8 8 < A     8                                     `  a  p 8p!!`    p  1a`                                       `    !!0          `  `@ 8 8  p 0 p   0              @    p p 0  8             `           F         8  x   |  8p     C     8 # 80  80<  #888  8 @p  !!     8                   8 A              `  8  p80 8     8 @ F      ```p                         0   0 a 1t  088!!p p    p x aa`                                           !!` x          @  8 @8 p   8   x              @     p 8 `  8      p       0 @         F        x      8p  @ 8  p ` p   Cx8x8px !!888@  	p&0	  "      8                   8 @              0  8  p8` |     8         8x                         ` ` 0 a par  p`pa8 8    p `<                                              ?            8 ? p     x                   p   8      p         `      F         8 8p  8  p ` 8  ??888?  ?0        8                  8 A                 8  p8  ''     8         ?                         @ 0 3  ?q  ?p       p `                                       `     p        p  `     x               ??   0  ?      ` ?          ? ?>?  |8?  p ` ?  ???   ? <       p                  ?             xx 8 3 C ?    8        ```                               `p  p 8   ? ???                                              !!                0                                                                                           s                                                    p                     8                            `                                                                                                                                              8                                                                   p                                                                                      !!                0                                                                                           c                                                     8                     8                             0                                                                                                                                              8                                                                    p                                                                                      !!                                                                                                             @                                                                          8                                                                                                                                                          C                    8                                                                    p                                                                                      !!                                            `                                                                                                                                        8                                                                                                                                                          C                    8                                                                    p                                                                                       !!                                                                                                               ?                                   ?                                    8                                                                                            `                                                            C                     8                                                                    p                                                                                                  @                                                                                                                                                                                  8                                                                                                 ?                                                            ~                     0                                                                    p                                                                                                   @                                                                                                                                                                                 8                                                                                                                                               0              |                      `                                                                    p                                                                                                                                                                                                                                        ?                                           8                                                                                                                                                              8                                                                                         p                                                                                                                                                                                                                                                                                        8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       8                  0                                                                                                                                                                                                                   0                                                                                                                                                                                                                                                                                                                                    p                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         '! !!Clairvaux class methodsFor: 'as yet unclassified'!size48		"(FileStream readOnlyFileNamed: 'Clairvaux48.sf2') contentsOfEntireFile"	^ self size: 48 fromLiteral: '             4   )      0                 &   2   >   J   V   b   n   z                                      
    "  .  :  F  R  ^  j  v              ,  6  F  V  p                  2  J  b  z                6  N  v             8  Z              :  ^  z          $  J  z              $  D  T  m              	  	-  	=  	Y  	i  	  	  	  	  

  
"  
8  
I  
g  
  
  
  
  
      )  G  G  G  o                    	  #  9  Q  i                  1  M  i                )  E  ]  y          1  A  Y  u            ;  [  {            ''  I  I  m                9  U  q                  =  U  m  {                            	  !!  9  Q  i                9  S  w                  5  5  ]  _  _  o  o  oo :      (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      p                                                          ?       @ `                 ?      p                             ?  ?                 `                   >                                                                         p   ?                                                                                                                                                  x                                               ?                  0               x                                            <                     8                                                      8           @0  `                                                 @8  ?   p p        p           @<   p      p  0                   p       p                                                                      `         @                                                                                        ?                             ?                       ?                                                                         0 x                                                           |                      p                                                     8     !!0@   @   `             8   <8     x<               0              @8  ` 8   p p               x    x    @<   p  0  ` p p ` p           @    p       p                                                                   `  ?   `    `      @                                                                           `     @                 `          @ <                       `                                                                        00 ` x                                                                               0                                                     8   ?` 0  @   `              ?         <                `             `  @8      p p           @   <    <     @<   8  0  ` p p ` p           `    p       p            8                                                   ` `  @   p    0                                                                                                                                           p                                                     w                00 ` 8                                                                             0                                                     8   @@? p  @   `              w    p                      p            0  @8      p p             @     A  @<   8  0 p   8  8           0    p       p            8                                                    `              @         !!             @  @                            @           @                      0        @                      8                                                     ?                00 `                                                                              0                                                     8   @ p  @   `                  p  8                    p      `          8       p p                   A  @<   8  ` p   8 8                  p       p            8                                                    `            @          @          
            @      @                        0                        x     p                                                                                                88 p                                                                               0                                                     8     A  p  @0  `                 p  p                    p      `        x  8       p p @      p           <  @   <     ` p                      p       p             8                                                    `                                                     @         ?    p                       x     p              8p                                                                                   << x                                                                                0                                                     8       p  @0            0      p                       p      p          <  8        p p       p     p    p  <      <      p     0                 p       p             8                                                    `                   0                                            p                         0     p                                                                 `                                <<  x 0        `                                                                      0                                                     8         p   `                     p                        p      p    `       8        p p       p     p    p  <      <      p     `    @              p       p              8                                                    `        0                        @@ `  @          ?        `     p    0                           p                                                                p             8                     0 `        `                                                                  p                                                     8    @@   p    `   `                    p                       p      8           8  8      p p      p    p    p  <      <      p     `   8 @              p       p              8                                                    `        p                        @      `              @        `     p                             @ p    	                                                            p             8                                                                                   ?                                                                          8    @@   8    `              `        p                      p      8           8  8      p p      p    p    p  <      <     8       p @              p       p              8                                                    `        p                                                                                   p                              p            0  0                                                  8             8                                                                                                                                                            8           `           @        0p      0       0        p      8           8  8      p p      p    p    p  <      <     8                      p       p              8                                                    `        p                                                                                    p                              p    !!                      p       `                            8             8                                                                                                                                                            8        8      `           @        0p  0 0            `    `                 8  8      p p      pp    p    p  <      <      8                  ? p p ?    8 x   ? ? ?? ? `        p                         p                               p    A                 `   8                                       8                                                                                           ?                                                      8     x   p      `                   `p  0 x`                                   8  8      p p       p8    p    p  <      <      8                    pp  ? ?   8     8 8 p8      `        p                    ?  ?  ? p 8 p 8    p  p                             p                                                            8     ?                         8 `                                                                                                                          8     8         `                   p <  ` <                         @        8  8      p p@      0p    p    p        <      8                   x q  p 8 @ @8   8   9 8 pp   0p    `       p      0 8 8 8 8      @  @  @ p 8 p 8   p  8                          8p          0    0                                       8     @                         `    x                                                                                                                     8      0       0                  8    p  p   `     0                           8 8      p p      0p    p    p        <                         < r `@p      8   : p 8 p    p 8    `       p     x `                  p 8 p 8   p                               8p                         !!                       0 0      8   @                            `                                                                                                                          8            0                 p  @p  8@  `         `         @          8 8      p      p `p    p    p      <                           t         8    < 8 8 q   x 8  0   `       p   @     <           p  x  x p 8 p 8   p      @                          8p                    A    #   x        @   `      8   @                                                                                                                                                      8     a     0                    p                         @         ? 8     p      p `p   p    p      <          |   8              x x0 !!      8     8  8 s   x  0    `       p   @                   p   <   < p 8 p 8   0  0                         @  p                   ?      `  <   `   0                  8    `                                                                                                                                                    8     xC p     0                   p      3                    @          8 8      p      8 p   p    p      <          x   p               p 8p        8     8 0 8 w       0    `       p                         p @  @  p 8 p 8    p  `                              pp         0    0            0  `   `@ ` ?      A      `     8   @  `                                       `                                                                                                  8     <   `8   0                < p     a ''    0         0                8 8      p pp     8 p    p    p        <         8                  p 8p  p      80     8 p 8 ~       `  8  ` `       p                         p        p 8 p 8    p  @                             p                    s       8 #   `          "     0  0     8   @  `                                                                             ?                                                      8     .  p8    0                     p     G           p `                 8  8   p p8     p p   p     p      <         8                p 8p  p      8`    8 8 p 8 |    0 `  p ` 0        p    ?           p        p 8 p 8    p      p                         p   @                 ;       8 <    a    0       @ `      8      c                                                                                                                                8     '' ? pp    0                     p    x  < 0                   p       8  8     p p     p 8   p @   p      <           8                p 8p  p      8    8 8 p 8 x          `        p p               p        p 8 p 8    p      8                        p                           8 `   a     0       @        8      `                                                                                                                                     8   #  p    0                     p      <  <                     p       8  8     p p      p    p   p       <    0       8                0 p 8p  p       ?    8 8 p 8 p         `      @ p p                   p        p 8 p 8    p                           p           0  0        8      8   a              `     8                                                                                                                                        8     !!  q   0                 8    p                             p       8  8     p p      p    p    p       <    0  0      8                ` p 8p  p     ?    8 8 p 8 p  ~        ` 0      p              p        p 8 p 8    p                                                   p      8        ``     "    `     8                                                                                          p                                                     8     !!  q0   0              p                   `             p       8  8     p p     p    p     p       <    p`  0      8                 p 8p  p       8    8 8 p 8 p   p        ` `     @ 8 p   0                    p        p 8 p 8    p                                 p                           8  # @    ``     A           8                                                                                         0                                                     0     !!  q `   0                                 0                   p       8  8     p p     p    p     p      <    p`  0      8  8              p 8p  p       8p    8 8 p 8 p   p0        `       8 p   `0 0 0 0                 p        p 8 p 8    p                             @  p                          8  <      `@        `      8                                              0                                            0                                                           !!  q p    `                     p                              p   p       8  8     p p      p    p     p      <    p`  0      8  p              p 8p  p        88    8 8 p 8 p   80  8  s     `        p   p p p p                 p        p 8 p 8    p  `                              p             8p              8  ` 8      0@     @   0  0     8                                                                                      0                                                           !!  q 9    `                     p        8                    p   p       8  8     p p p     p     p     `       <    8  ` n    8                p 8p  p        8    8 8 p 8 p    8`  8  s  8   `        p   p p p p                 p        p 8 p 8    p  p                               p                               0 !! 8      0        p  `     8                                    0         p                                         0                                                            !!  q      `                     p       p         `            p   `p      8  <     p p 8     p  v   `     @ p      <    8  ` n  0  8               p 0p  p   8      8    8 8 p 8 p   x 8`    s  p   `        8  p p p p                 p        p 8 p 8     p  8                               p  @                ''       ` .  8     0       p        8                                 """"    `         8                                         0                                                            !!  q      `                     p           0                8   @8       8       p p      p  >   @      8      <    9  ` n  0  8               p  p  p   p      8    8  8 x 8 p   8     >     `          p p p p                 p        p x p x                                      p              g         p  8            8 `      <                                  DDDD                                                      0                                                            !!  q    `                       p                           8       @  8       p p      p                      >  `  8   A            p @p !!          8     <  < x p  8     >    `          p p p p                p        p  p                                        p                         8         8               8 0 0                                                                                                0                                                        @  !!  q   `               0       p <                                   0   @8      p p      p                  0      >     8   A            p p !!p  p      8     : @  p  8	    0  >   `          p p p p            p x   x   p8 p8       |                               p                       p          8  x                                                                       0                                                                                                <   @@ !! 0 ` 3  `                   8  p x                    @             `   @8       p p     p                `      <     8   A  @          p 8 `p  8      8      9 8 p  0    0     `         0xxxx <          p < @ < @ 88#88#                                      p                                 < @| @                       0  ''  @                          p                                                           @                                                     <   @@ #      0        <   <       p  p    8    <                            @8   @   p p    ` p                         p  8   A  @         . p  xp ?     8 p    8 8 p  ` !!     `     `        `x<<<<\       p     8C8C                                    8 p 	                               x                        x G |                           p                                      ?                                                                         <         `?  0        <   < `       p 0      <                           @8      p p    ` p                     p  8   A  @          N p ?p      8 8    8~ 8 p       p       `         ? p      p        8 8    0                                 8 p                    |                                   x  ?                           `             0  `                                          ?                                                                @                 @       0                  @           ?    ? p `   ?   ?                           ~?      8< 8  ?     p   `      ? ?         ??                                                     x          ?                      0                              `              @                                                                                                                                   @                                                                                         p                                                                                                                               8    8                                                                                                                                                                                                                                                                                                          `                                                                                                                                                                                                                                                                  p                                                                                                                             8    8                         0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     p                             0                                                                                               8    8                         0                   `                                                                                                                                                                                                                                                                                                                                                                                                                            0                                                                                                      p                            p                                                                                                8    8                         `                   `                                                                                                                                                                                                                                                                                                                                                                                                                            `        0                                       0                                                        p                            0                                                                      `                          8    8                         `                   `                                                                                                                                                                                                                                                                                                                                                                                                                              `        `                                       `                                                        p                                                                                               `                          8    8                         `     `                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      `                                                                                                       `                          8    8                              0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         @                                                                                                      `                          8    8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                `                          8    8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  `                          8    8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 @                          8    8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             8    8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             8    8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              @                    8    8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     8    8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  '! !!Clairvaux class methodsFor: 'as yet unclassified'!size72		"(FileStream readOnlyFileNamed: 'Clairvaux72.sf2') contentsOfEntireFile"	^ self size: 72 fromLiteral: '             H   D      H              ''   9   K   ]   o                               #  5  G  Y  k  }                    1  F  [  [                  !!  !!  ?  ?  c  c                      ,  ,  ,  ,  ,  ,  h  h                  D  D              "  "  ^  ^                      )  )  J  J  n  n              "  "  K  K  r  r              	$  	$  	<  	<  	T  	T  	T  	T  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
B  
B  
f  
f  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
{  
  
  
  
  
                >  >  >  V  V  VV `      "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ?                                  ?  ?                                                                                                                                                                                                                     `                                   ~                               <                    ?                                                                                                       p                                                                                      <   0                                          ~   0               `               <                                                                                                     0 0           ?           p                                                                                       x                       @   0 ?                       ~   `        ?      0                <                                                                                                     p p                    p  p                                                                                      p x                   ?    @   `          0              ~           `      ?  0                  <                                                                                                                       p  p                                                                                      p                         @             `   `    0       ~                 `            <  |  8   <                                                                                                                       p  p                                                                                    p                          @               0    `      ~             0                <  |  8   <                    ?                                                                                                   p  p                                                                                    p                    ~   @                         ~       |      `               <  >  p   <                                                                                                                      p  p                                                                                    p                   8  >   @        x                ~       |                     <  >  p   <                                                                                                                      p  p                                                                                    p    `             0  p         <       x                ~       |                x     x       <                                                                                                                      p  p                                                                                0    p    0             0   `         <       <                 ~  0     |                x     x       <                                                                                                                      p  p                                                                                0    p    0             0   @         x       <                 ~  `     |  <               x     x     <                                                                                                             ?         p  p                                                                                0    p                  `   @         x       <                  ~       |  |               x     x     <                        |                                                                                  >        p  p                                                                                `    p                   `   @         x                          ~      8|  |               <          <                                                                                                          8        p  p                                                                                `    p         0            @                0                   ~       0|  |               <          <                                                                                                 ~ ~               p  p                                                                                 0   `         0            @                0                   ~       p|  |               <          <                                                                                                 < <               p                                                                                   0            0                         p                   ~     x  `|  |                 0       <                    ?                                                 p                                                                                 `  <         0                        `                  ~     x  |  |                 0       < ?           >                                                                  p                                                                                 `   <         0                         `                  ~ 0    <  |  |                 0       < ` >      ?      >       |   |                                                                                                                                    x         0                                           ~ `    < |  |                 0        <        `     8  >       0    |   |  8                                                                                                                                     x         0               0  ?                            ~      |  |                         <    0   x    p  >00 x  8    `    |   |  8                                                                                                                                                  0               `                            ~     |  |                     |    <   0  `  <      >` ` <  p        |   >  8                                                     p                                                                                                 0                                            ~       |  |                     |8    <   `           > x           |  >  p                                                     p                                                                                                0                                           ~       |  |        ?            >8    <      p       ? =    | 0     >   >  p                                                     p                                                                                                0                                            ~      |  |                   >p    <     p       ?      > `     > ;  >                                                       p                                                                                                 0                                            ~      |  |                   p    <      p       >              > ;                                                         p                                                                                                 0        0                                         |  |                        <       p>        >             > ;                                                        p                                                                                                 0        0                                        |  |         ?               <       p>     8   >             > ;                                                        p                                                                                                 0        `                                          |  |                        <        p>     p   >              q                                                       p                                                                                                 0        `                   x                       8 |  |                       <        p>        >              q                                                                                                                                     0              ?      `             <      |                        0 |  |                       <        p>        >              q                                                                                                                                      0              ?             x      <       |                        p` |  |                       <        p>        >                                                                                                                                                   `                0               <      x         >                ~      p` |  |                       <        p>        >                     ?                                           p                                                                                `                0                    x  |       >                ~     8 |  |                       <        p>        >         |           ?                                           p                                                                                `      <          0                    x  > 0    0                  ~     9 |  |                       <            >         ?                                                           p                                                                                   <          0                          0                  ~      |  |                <        <           >            x                                                       p  p                                                                                 x        0                                      ~      |  |                  <        < ?             >             x                                                       p  p                                                                               `     x        0                                     ~       |  |           ~       <        < `        0   |   >              x  8                                                     p  p                                                                               `             0                            `                 ~        |  |           >      x x        <         `   >   >           |   x  8                                                     p  p                                                                                            0                                             ~ ~       |  |           >      x8 px        <               >           >   <  p                                                     p  p                                                                                             0                                            ~ ?       |  |           >      x8 px        <             >              <  p                                                    p  p                                                                                      8       0                                           ~       |  |           >      x8 px        <              >             <                                                      p  p                                                                                     8       0                                           ~       |  |           >      <p 8        <               >                                                                     p  p                                                                                     8       0       0     @                              ~        |  |           >      <p 8        <               >              0                                                       p  p                                                                                      8       0       0     @                               ~        |  |          >      <p 8        <                >              0                                                       p  p                                                                                      8       0       `     @                              ~        |  |          >      <p 8        <              |  >              0   }                                                     p  p                                                                                       8       0       `     @                                ~         |  ~          >               <             >  >            0                                                        p  p                                                                                       8       0            `                       0         ~  ~       |  ?         <               <               >      <      0                                                            p                                                                                      8                    0  >                    `          ~  ?       |            8               <           >      x     7  `   ?                                               ?        p                                                                                     8                      |               |              ~        |        >    0                <           >            g  `   ?                                               ?                                                                                            < 8                             0      |               ~        |        |    `                <      0 ?     >      ~          >                                                                                                                                           < 8                      <     `      ~  ~       ~       ~        |                              <  |  ~  ` ` |     >       ? 1  8      >                                                                                                                                             x                        <           >  ?     ?    ~        |                      < 3 >  ?    >      >     ~  a p      <                                                                                                                                               x                        <          >           ~        |     ?      ?              < c        | >     ?          <                                                                                                                                                                             x       0    ?         ~         |                        <          > >                <                                                                                                                                                                               x            ?    ?    ?                <                     x                                                ?                                                                                                                                                     <                                                                                     <                                                            x                                                                                                                                                                                                        <                                                                                    <                                                            x                                                                                                                                                                                                        <                                                                                    <              8                                                                                                                                                                                                                                                       <                                                     <                               <              x                                                                                                                                                                                                                  0                                      8                                                     x                               <                                                                                                                                                                                                                               0                                      0                                                      0                              <                                                                                                                                                                                                                               `                                      `                                                      `                              <                                                                                                                                                                                                                                                                                                                                                       <                                                                                                                                                                                                                                                                                                                                                           <                                                                                                                                                                                                                                                                                                                                                              <                                                                                                                                                                                                                                                                                                                                                               <                                                                                                                                                                                                                                                                                                                                                                  <                                                                                                                                                                                                                                                                                                                                                                  <                                                                                                                                                                                                                                   0                                                                                                                                <                                                                                                                                                                                                                                   `                                                                                                                                <              |                                                                                                                                                                                                                                                                                                                                                   ?              >                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          <                                                                                                                                                                                                                                                                                                                                                                      <                                                                                                                                                                                                                                                                                                                                                                      x                                                                                                                                                                                                                                                                                                                                                                     x                                                                                                                                                                                                                                                                                                                                                                      x                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    '! !	Clairvaux size10		displayLine: 'A line of 12-pt text in New York style' at: 0@0!ParagraphEditor new clipboardTextPut:	(Text string: 'The quick brown fox jumps over the lazy dog.'		attribute: TextEmphasis bold)!TextFontChange subclass: #TextFontReference	instanceVariableNames: 'font '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!CompositionScanner methodsFor: 'scanning'!setActualFont: aFont	"Keep track of max height and ascent for auto lineheight"	super setActualFont: aFont.	lineHeight _ lineHeight max: font height.	baseline _ baseline max: font ascent.! !!CharacterScanner methodsFor: 'private'!setActualFont: aFont	"Set the basal font to an isolated font reference."	font _ aFont! !!TextFontReference methodsFor: 'no messages'!emphasizeScanner: scanner	"Set the actual font for text display"	scanner setActualFont: font! !!TextFontReference methodsFor: 'as yet unclassified'!toFont: aFont	font _ aFont! !----SNAPSHOT----(7 November 1996 8:37:52 pm ) priorSource: 1184008!!TextFontReference class methodsFor: 'no messages'!toFont: aFont	^ self new toFont: aFont! !----SNAPSHOT----(7 November 1996 8:38:46 pm ) priorSource: 1325730!ParagraphEditor new clipboardTextPut:	(Text string: 'The quick brown fox jumps over the lazy dog.'		attribute: (TextFontReference toFont: Clairvaux size10))!Smalltalk garbageCollect. StrikeFont instanceCount!Smalltalk garbageCollect. StrikeFont instanceCount!Smalltalk garbageCollect. StrikeFont instanceCount!Smalltalk garbageCollect. StrikeFont instanceCount!TextStyle default fontAt: 1!!StrikeFont methodsFor: 'emphasis' priorSource: 1174238 inFile: 2!emphasized: code 	"Answer a copy of the receiver with emphasis set to include code."	| derivative addedEmphasis base g r safeCode |	code = 0 ifTrue: [^ self].	(derivativeFonts == nil or: [derivativeFonts size = 0]) ifTrue: [^ self].	derivative _ derivativeFonts at: (safeCode _ code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis _ 1 bitShift: safeCode highBit - 1.	base _ self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative _ (base copy name: base name , 'B') makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative _ (base copy name: base name , 'I') makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative _ (base copy name: base name , 'U') makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative _ (base copy name: base name , 'N') makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative _ (base copy name: base name , 'X') makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative! !StrikeFont subclass: #FormSetFont	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Support'!!FormSetFont methodsFor: 'no messages'!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width |	type _ 2.	name _ 'aFormFont'.	minAscii _ asciiStart.	maxAscii _ minAscii + formArray size - 1.	ascent _ ascentVal.	subscript _ superscript _ emphasis _ 0.	height _ width _ 0.	maxWidth _ 0.	formArray do:		[:f | width _ width + f width.		maxWidth _ maxWidth max: f width.		height _ height max: f height + f offset y].	descent _ height - ascent.	pointSize _ height.	glyphs _ Form extent: width @ height depth: formArray first depth.	xTable _ Array new: formArray size + 1.	xTable at: 1 put: 0.	formArray doWithIndex:		[:f :i | xTable at: i+1 put: (xTable at: i) + f width].	self setStopConditions! !----QUIT----(7 November 1996 9:43:58 pm ) priorSource: 1325894!----SNAPSHOT----(8 November 1996 8:40:09 am ) priorSource: 1328715!!FormSetFont methodsFor: 'as yet unclassified' priorSource: 1328015 inFile: 2!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width |	type _ 2.	name _ 'aFormFont'.	minAscii _ asciiStart.	maxAscii _ minAscii + formArray size - 1.	ascent _ ascentVal.	subscript _ superscript _ emphasis _ 0.	height _ width _ 0.	maxWidth _ 0.	formArray do:		[:f | width _ width + f width.		maxWidth _ maxWidth max: f width.		height _ height max: f height + f offset y].	descent _ height - ascent.	pointSize _ height.	glyphs _ Form extent: width @ height depth: formArray first depth.	xTable _ Array new: formArray size + 1.	xTable at: 1 put: 0.	formArray doWithIndex:		[:f :i | xTable at: i+1 put: (xTable at: i) + f width].	self setStopConditions"ParagraphEditor new clipboardTextPut:	(Text string: 'AB'		attribute: (TextFontReference toFont: 			(FormSetFont new				fromFormArray: (Array with: Form fromUser										with: form fromUser)				asciiStart: $A asciiValue				ascent: 10)))"! !----SNAPSHOT----(8 November 1996 9:18:05 am ) priorSource: 1328780!CharacterScanner subclass: #DisplayScanner	instanceVariableNames: 'lineY runX foregroundColor backgroundColor lastSourceDepth fillBlt lineHeight '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!!DisplayScanner methodsFor: 'scanning' priorSource: 1151784 inFile: 2!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done lineIndex stopCondition leftInRun fore back |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.	destForm depth > 1 ifTrue:		["Set up color map for display in color"		foregroundColor _ aParagraph foregroundColor.		backgroundColor _ aParagraph backgroundColor.		fore _ foregroundColor bitPatternForDepth: destForm depth.		back _ backgroundColor bitPatternForDepth: destForm depth.		lastSourceDepth _ 1.		self colorMap: (Bitmap with: back first with: fore first)].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt destX: visibleRectangle left destY: lineY			width: leftMargin - visibleRectangle left height: lineHeight; copyBits.		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits.		lineY _ lineY + lineHeight]! !!FormSetFont methodsFor: 'as yet unclassified'!reset  "Ignored by FormSetFonts"! !----SNAPSHOT----(8 November 1996 9:57:46 am ) priorSource: 1329877!!DisplayScanner methodsFor: 'private' priorSource: 1102793 inFile: 2!setFont 	self textColor: foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this isnt right for RGB display, yet,			and it will need some caching for reasonable efficiency"		self colorMap: (sourceForm depth = 1			ifTrue:			[(Bitmap with: (backgroundColor bitPatternForDepth: destForm depth) first						with: (foregroundColor bitPatternForDepth: destForm depth) first)]			ifFalse:			[(Color indexedColors collect: [:c | c pixelValueForDepth: destForm depth])					as: Bitmap]).		lastSourceDepth _ sourceForm depth].	destY _ lineY + line baseline - font ascent! !!DisplayScanner methodsFor: 'scanning' priorSource: 1330258 inFile: 2!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done lineIndex stopCondition leftInRun fore back |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	foregroundColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.	destForm depth > 1 ifTrue:		["Set up color map for display in color"		fore _ foregroundColor bitPatternForDepth: destForm depth.		back _ backgroundColor bitPatternForDepth: destForm depth.		self colorMap: (Bitmap with: back first with: fore first).		lastSourceDepth _ 1].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt destX: visibleRectangle left destY: lineY			width: leftMargin - visibleRectangle left height: lineHeight; copyBits.		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits.		lineY _ lineY + lineHeight]! !----SNAPSHOT----(8 November 1996 10:10:24 am ) priorSource: 1332907!!DisplayScanner methodsFor: 'private' priorSource: 1102793 inFile: 2!setFont 	self textColor: foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this isnt right for RGB display, yet,			and it will need some caching for reasonable efficiency"		self colorMap: (sourceForm depth = 1			ifTrue:			[(Bitmap with: (backgroundColor bitPatternForDepth: destForm depth) first						with: (foregroundColor bitPatternForDepth: destForm depth) first)]			ifFalse:			[(Color indexedColors collect: [:c | c pixelValueForDepth: destForm depth])					as: Bitmap]).		lastSourceDepth _ sourceForm depth].	destY _ lineY + line baseline - font ascent! !ParagraphEditor new clipboardTextPut:	(Text string: 'AB'		attribute: (TextFontReference toFont: 			(FormSetFont new				fromFormArray: (Array with: Form fromUser										with: Form fromUser)				asciiStart: $A asciiValue				ascent: 10)))!!DisplayScanner methodsFor: 'private' priorSource: 1102793 inFile: 2!setFont 	self textColor: foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this isnt right for RGB display, yet,			and it will need some caching for reasonable efficiency"		self colorMap: (sourceForm depth = 1			ifTrue:			[(Bitmap with: (backgroundColor bitPatternForDepth: destForm depth) first						with: (foregroundColor bitPatternForDepth: destForm depth) first)]			ifFalse:			[(Color indexedColors collect: [:c | c pixelValueForDepth: destForm depth])					as: Bitmap]).		lastSourceDepth _ sourceForm depth].	destY _ lineY + line baseline - font ascent! !ParagraphEditor new clipboardTextPut:	(Text string: 'AB'		attribute: (TextFontReference toFont: 			(FormSetFont new				fromFormArray: (Array with: Form fromUser										with: Form fromUser)				asciiStart: $A asciiValue				ascent: 10)))!!FormSetFont methodsFor: 'as yet unclassified' priorSource: 1328929 inFile: 2!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width |	type _ 2.	name _ 'aFormFont'.	minAscii _ asciiStart.	maxAscii _ minAscii + formArray size - 1.	ascent _ ascentVal.	subscript _ superscript _ emphasis _ 0.	height _ width _ 0.	maxWidth _ 0.	formArray do:		[:f | width _ width + f width.		maxWidth _ maxWidth max: f width.		height _ height max: f height + f offset y].	descent _ height - ascent.	pointSize _ height.	glyphs _ Form extent: width @ height depth: formArray first depth.	xTable _ Array new: maxAscii + 2 withAll: 0.	formArray doWithIndex:		[:f :i | xTable at: minAscii + i+1 put: (xTable at: minAscii + i) + f width].	self setStopConditions"ParagraphEditor new clipboardTextPut:	(Text string: 'AB'		attribute: (TextFontReference toFont: 			(FormSetFont new				fromFormArray: (Array with: Form fromUser										with: form fromUser)				asciiStart: $A asciiValue				ascent: 10)))"! !----SNAPSHOT----(8 November 1996 11:47:20 am ) priorSource: 1336383!----SNAPSHOT----(8 November 1996 11:47:43 am ) priorSource: 1339523!ParagraphEditor new clipboardTextPut:	(Text string: 'AB'		attribute: (TextFontReference toFont: 			(FormSetFont new				fromFormArray: (Array with: Form fromUser										with: Form fromUser)				asciiStart: $A asciiValue				ascent: 10)))!!DisplayScanner methodsFor: 'private' priorSource: 1102793 inFile: 2!setFont 	self textColor: foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this isnt right for RGB display, yet,			and it will need some caching for reasonable efficiency"		self colorMap: (sourceForm depth = 1			ifTrue:			[(Bitmap with: (backgroundColor bitPatternForDepth: destForm depth) first						with: (foregroundColor bitPatternForDepth: destForm depth) first)]			ifFalse:			[(Color indexedColors collect: [:c | c pixelValueForDepth: destForm depth])					as: Bitmap]).		lastSourceDepth _ sourceForm depth].	destY _ lineY + line baseline - font ascent! !!StrikeFont methodsFor: 'accessing' priorSource: 1661914 inFile: 1!widthOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	| ascii |	ascii _ (aCharacter asciiValue min: maxAscii) max: minAscii.	^(xTable at: ascii + 2) - (xTable at: ascii + 1)! !!FormSetFont methodsFor: 'as yet unclassified' priorSource: 1338570 inFile: 2!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width |	type _ 2.	name _ 'aFormFont'.	minAscii _ asciiStart.	maxAscii _ minAscii + formArray size - 1.	ascent _ ascentVal.	subscript _ superscript _ emphasis _ 0.	height _ width _ 0.	maxWidth _ 0.	formArray do:		[:f | width _ width + f width.		maxWidth _ maxWidth max: f width.		height _ height max: f height + f offset y].	descent _ height - ascent.	pointSize _ height.	glyphs _ Form extent: width @ height depth: formArray first depth.	xTable _ Array new: maxAscii + 2 withAll: 0.	formArray doWithIndex:		[:f :i | f displayOn: glyphs at: 0@((xTable at: minAscii + i)).		xTable at: minAscii + i+1 put: (xTable at: minAscii + i) + f width].	self setStopConditions"ParagraphEditor new clipboardTextPut:	(Text string: 'AB'		attribute: (TextFontReference toFont: 			(FormSetFont new				fromFormArray: (Array with: Form fromUser										with: form fromUser)				asciiStart: $A asciiValue				ascent: 10)))"! !ParagraphEditor new clipboardTextPut:	(Text string: 'AB'		attribute: (TextFontReference toFont: 			(FormSetFont new				fromFormArray: (Array with: Form fromUser										with: Form fromUser)				asciiStart: $A asciiValue				ascent: 10)))!!FormSetFont methodsFor: 'as yet unclassified' priorSource: 1341045 inFile: 2!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width x |	type _ 2.	name _ 'aFormFont'.	minAscii _ asciiStart.	maxAscii _ minAscii + formArray size - 1.	ascent _ ascentVal.	subscript _ superscript _ emphasis _ 0.	height _ width _ 0.	maxWidth _ 0.	formArray do:		[:f | width _ width + f width.		maxWidth _ maxWidth max: f width.		height _ height max: f height + f offset y].	descent _ height - ascent.	pointSize _ height.	glyphs _ Form extent: width @ height depth: formArray first depth.	xTable _ Array new: maxAscii + 2 withAll: 0.	x _ 0.	formArray doWithIndex:		[:f :i | f displayOn: glyphs at: x@0.		xTable at: minAscii + i+1 put: (x _ x + f width)].	self setStopConditions"ParagraphEditor new clipboardTextPut:	(Text string: 'AB'		attribute: (TextFontReference toFont: 			(FormSetFont new				fromFormArray: (Array with: Form fromUser										with: form fromUser)				asciiStart: $A asciiValue				ascent: 10)))"! !ParagraphEditor new clipboardTextPut:	(Text string: 'AB'		attribute: (TextFontReference toFont: 			(FormSetFont new				fromFormArray: (Array with: Form fromUser										with: Form fromUser)				asciiStart: $A asciiValue				ascent: 10)))!!FormSetFont methodsFor: 'as yet unclassified' priorSource: 1342381 inFile: 2!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width x |	type _ 2.	name _ 'aFormFont'.	minAscii _ asciiStart.	maxAscii _ minAscii + formArray size - 1.	ascent _ ascentVal.	subscript _ superscript _ emphasis _ 0.	height _ width _ 0.	maxWidth _ 0.	formArray do:		[:f | width _ width + f width.		maxWidth _ maxWidth max: f width.		height _ height max: f height + f offset y].	descent _ height - ascent.	pointSize _ height.	glyphs _ Form extent: width @ height depth: formArray first depth.	xTable _ Array new: maxAscii + 2 withAll: 0.	x _ 0.	formArray doWithIndex:		[:f :i | f displayOn: glyphs at: x@0.		xTable at: minAscii + i+1 put: (x _ x + f width)].	self setStopConditions! !!FormSetFont class methodsFor: 'no messages'!example    "FormSetFont example1"	"Lets the user select a (small) area of the screen to represent the	character A, then copies 'A' to the clipboard with that as the letter form.	Thereafter, a paste operation will imbed that character in any text"	ParagraphEditor new clipboardTextPut:		(Text string: 'A'			attribute: (TextFontReference toFont: 				(FormSetFont new					fromFormArray: (Array with: Form fromUser)					asciiStart: $A asciiValue					ascent: 10)))! !!FormSetFont class methodsFor: 'as yet unclassified' priorSource: 1344458 inFile: 2!example    "FormSetFont example1"	"Lets the user select a (small) area of the screen to represent the	character A, then copies 'A' to the clipboard with that as the letter form.	Thereafter, a paste operation will imbed that character in any text.	See more explanation below this code."	| charForm |	charForm _ Form fromUser.	ParagraphEditor new clipboardTextPut:		(Text string: 'A'			attribute: (TextFontReference toFont: 				(FormSetFont new					fromFormArray: (Array with: charForm)					asciiStart: $A asciiValue					ascent: charForm height)))! !!FormSetFont class methodsFor: 'as yet unclassified'!copy: charForm toClipBoardAs: char ascent: ascent"	The S in the Squeak welcome window was installed by doing the following	in a workspace (where the value of, eg, charForm will persist through BitEdit...	f _ (TextStyle default fontAt: 4) characterFormAt: $S.	charForm _ Form extent: f extent depth: 8.	f displayOn: charForm	charForm bitEdit.	...Play around with the BitEditor, then accept and close...	FormSetFont copy: charForm toClipBoardAs: $S ascent: (TextStyle default fontAt: 4) ascent.	...Do a paste into the Welcome window"! !!FormSetFont class methodsFor: 'as yet unclassified' priorSource: 1345632 inFile: 2!copy: charForm toClipBoardAs: char ascent: ascent	ParagraphEditor new clipboardTextPut:		(Text string: char asString			attribute: (TextFontReference toFont: 				(FormSetFont new					fromFormArray: (Array with: charForm)					asciiStart: char asciiValue					ascent: ascent)))"	The S in the Squeak welcome window was installed by doing the following	in a workspace (where the value of, eg, charForm will persist through BitEdit...	f _ TextStyle default fontAt: 4.	oldS _ f characterFormAt: $S.	charForm _ Form extent: oldS extent depth: 8.	oldS displayOn: charForm	charForm bitEdit.	...Play around with the BitEditor, then accept and close...	FormSetFont copy: charForm toClipBoardAs: $S ascent: f ascent.	...Then do a paste into the Welcome window"! !!FormSetFont class methodsFor: 'as yet unclassified' priorSource: 1345016 inFile: 2!example    "FormSetFont example1"	"Lets the user select a (small) area of the screen to represent the	character A, then copies 'A' to the clipboard with that as the letter form.	Thereafter, a paste operation will imbed that character in any text."	| charForm |	charForm _ Form fromUser.	ParagraphEditor new clipboardTextPut:		(Text string: 'A'			attribute: (TextFontReference toFont: 				(FormSetFont new					fromFormArray: (Array with: charForm)					asciiStart: $A asciiValue					ascent: charForm height)))! !!FormSetFont class methodsFor: 'as yet unclassified' priorSource: 1347117 inFile: 2!example    "FormSetFont example1"	"Lets the user select a (small) area of the screen to represent the	character A, then copies 'A' to the clipboard with that as the letter form.	Thereafter, a paste operation will imbed that character in any text."	| charForm |	charForm _ Form fromUser.	self copy: charForm toClipBoardAs: $A ascent: charForm height! !FormSetFont class comment:'FormSetFonts are designed to capture individual images as character forms for imbedding in normal text.  While most often used to insert an isolated glyph in some text, the code is actually desinged to support an entire user-defined font'!FormSetFont class comment:'FormSetFonts are designed to capture individual images as character forms for imbedding in normal text.  While most often used to insert an isolated glyph in some text, the code is actually desinged to support an entire user-defined font'!FormSetFont class comment:'FormSetFonts are designed to capture individual images as character forms for imbedding in normal text.  While most often used to insert an isolated glyph in some text, the code is actually desinged to support an entire user-defined font.  The TextAttribute subclass TextFontReference is specifically designed for such in-line insertion of exceptional fonts in normal text.'!FormSetFont class comment:'FormSetFonts are designed to capture individual images as character forms for imbedding in normal text.  While most often used to insert an isolated glyph in some text, the code is actually desinged to support an entire user-defined font.  The TextAttribute subclass TextFontReference is specifically designed for such in-line insertion of exceptional fonts in normal text.'!!FormSetFont class methodsFor: 'examples' priorSource: 1346263 inFile: 2!copy: charForm toClipBoardAs: char ascent: ascent	ParagraphEditor new clipboardTextPut:		(Text string: char asString			attribute: (TextFontReference toFont: 				(FormSetFont new					fromFormArray: (Array with: charForm)					asciiStart: char asciiValue					ascent: ascent)))"	The S in the Squeak welcome window was installed by doing the following	in a workspace (where the value of, eg, charForm will persist through BitEdit...	f _ TextStyle default fontAt: 4.	oldS _ f characterFormAt: $S.	charForm _ Form extent: oldS extent depth: 8.	oldS displayOn: charForm.	charForm bitEdit.	...Play around with the BitEditor, then accept and close...	FormSetFont copy: charForm toClipBoardAs: $S ascent: f ascent.	...Then do a paste into the Welcome window"! !	FormSetFont copy: charForm toClipBoardAs: $S ascent: f ascent.!	FormSetFont copy: charForm toClipBoardAs: $S ascent: f ascent.!----SNAPSHOT----(8 November 1996 1:17:51 pm ) priorSource: 1339593!!DisplayScanner methodsFor: 'private' priorSource: 1339980 inFile: 2!setFont 	| map |	self textColor: foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this isnt right for RGB display, yet,			and it will need some caching for reasonable efficiency"		self colorMap: (sourceForm depth = 1			ifTrue:			[(Bitmap with: (backgroundColor bitPatternForDepth: destForm depth) first						with: (foregroundColor bitPatternForDepth: destForm depth) first)]			ifFalse:			[map _ (Color indexedColors collect: [:c | c pixelValueForDepth: destForm depth])					as: Bitmap.			map at: 1 put: (backgroundColor bitPatternForDepth: destForm depth).			map]).		lastSourceDepth _ sourceForm depth].	destY _ lineY + line baseline - font ascent! !!DisplayScanner methodsFor: 'private' priorSource: 1350546 inFile: 2!setFont 	| map |	self textColor: foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this isnt right for RGB display, yet,			and it will need some caching for reasonable efficiency"		self colorMap: (sourceForm depth = 1			ifTrue:			[(Bitmap with: (backgroundColor bitPatternForDepth: destForm depth) first						with: (foregroundColor bitPatternForDepth: destForm depth) first)]			ifFalse:			[map _ (Color indexedColors collect: [:c | c pixelValueForDepth: destForm depth])					as: Bitmap.			map at: 1 put: (backgroundColor bitPatternForDepth: destForm depth) first.			map]).		lastSourceDepth _ sourceForm depth].	destY _ lineY + line baseline - font ascent! !!Color class methodsFor: 'colors'!defaultColorMapForDepth: d	"Return a colorMap for the depth, suitable for use with BitBlt (ie a BitMap)"	| bitsPerColor colorMap mask |	d < 16 ifTrue: [^ (IndexedColors copyFrom: 1 to: (1 bitShift: d)) as: Bitmap].	"For RGB, generate the simplest (3 bits per color) version"	bitsPerColor _ 3.	colorMap _ Bitmap new: (1 bitShift: bitsPerColor*3).	mask _ (1 bitShift: bitsPerColor) - 1.	0 to: colorMap size - 1 do:		[:i | colorMap at: i+1 put:			((Color red: ((i bitShift: 0 - (bitsPerColor*2)) bitAnd: mask)				green: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)				blue: ((i bitShift: 0) bitAnd: mask)				range: mask)			pixelValueForDepth: d)].	colorMap! !----SNAPSHOT----(8 November 1996 1:37:52 pm ) priorSource: 1350406!FormSetFont example!!FormSetFont class methodsFor: 'examples' priorSource: 1347725 inFile: 2!example    "FormSetFont example"	"Lets the user select a (small) area of the screen to represent the	character A, then copies 'A' to the clipboard with that as the letter form.	Thereafter, a paste operation will imbed that character in any text."	| charForm |	charForm _ Form fromUser.	self copy: charForm toClipBoardAs: $A ascent: charForm height! !!Color class methodsFor: 'colors'!defaultColorMapFrom: sourceDepth to: destDepth	"Return a colorMap for the depth, suitable for use with BitBlt (ie a BitMap)"	| bitsPerColor colorMap mask |	sourceDepth < 16 ifTrue:		[^ ((IndexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))			collect: [:c | c pixelValueForDepth: destDepth]) as: Bitmap].	"For RGB, generate the simplest (3 bits per color) version"	bitsPerColor _ 3.	colorMap _ Bitmap new: (1 bitShift: bitsPerColor*3).	mask _ (1 bitShift: bitsPerColor) - 1.	0 to: colorMap size - 1 do:		[:i | colorMap at: i+1 put:			((Color red: ((i bitShift: 0 - (bitsPerColor*2)) bitAnd: mask)				green: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)				blue: ((i bitShift: 0) bitAnd: mask)				range: mask)			pixelValueForDepth: destDepth)].	colorMap! !!Color class methodsFor: 'colors' priorSource: 1353484 inFile: 2!defaultColorMapFrom: sourceDepth to: destDepth	"Return a colorMap for the depth, suitable for use with BitBlt (ie a BitMap)"	| bitsPerColor colorMap mask |	sourceDepth < 16 ifTrue:		[^ ((IndexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))			collect: [:c | c pixelValueForDepth: destDepth]) as: Bitmap].	"For RGB, generate the simplest (3 bits per color) version"	bitsPerColor _ 3.	colorMap _ Bitmap new: (1 bitShift: bitsPerColor*3).	mask _ (1 bitShift: bitsPerColor) - 1.	0 to: colorMap size - 1 do:		[:i | colorMap at: i+1 put:			((Color red: ((i bitShift: 0 - (bitsPerColor*2)) bitAnd: mask)				green: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)				blue: ((i bitShift: 0) bitAnd: mask)				range: mask)			pixelValueForDepth: destDepth)].	colorMap! !Color class removeSelector: #defaultColorMapForDepth:!!DisplayScanner methodsFor: 'private' priorSource: 1351413 inFile: 2!setFont 	| map |	self textColor: foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this isnt right for RGB display, yet,			and it will need some caching for reasonable efficiency"		self colorMap: (sourceForm depth = 1			ifTrue:			[(Bitmap with: (backgroundColor bitPatternForDepth: destForm depth) first						with: (foregroundColor bitPatternForDepth: destForm depth) first)]			ifFalse:			[map _ Color defaultColorMapFrom: sourceForm depth to: destForm depth.			map at: 1 put: (backgroundColor bitPatternForDepth: destForm depth).			map]).		lastSourceDepth _ sourceForm depth].	destY _ lineY + line baseline - font ascent! !!DisplayScanner methodsFor: 'private' priorSource: 1355233 inFile: 2!setFont 	| map |	self textColor: foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this isnt right for RGB display, yet,			and it will need some caching for reasonable efficiency"		self colorMap: (sourceForm depth = 1			ifTrue:			[(Bitmap with: (backgroundColor bitPatternForDepth: destForm depth) first						with: (foregroundColor bitPatternForDepth: destForm depth) first)]			ifFalse:			[map _ Color defaultColorMapFrom: sourceForm depth to: destForm depth.			map at: 1 put: (backgroundColor bitPatternForDepth: destForm depth) first.			map]).		lastSourceDepth _ sourceForm depth].	destY _ lineY + line baseline - font ascent! !----SNAPSHOT----(8 November 1996 1:48:12 pm ) priorSource: 1352926!Display newDepth: 16.!Display newDepth: 32.!Display newDepth: 4.!Display newDepth: 8.!'From Squeak 1.13 of October 17, 1996 on 1 November 1996 at 12:28:12 pm'!!Obj methodsFor: 'menu cmds' priorSource: 453221 inFile: 2!showScriptAliasesIn: aView	"Make sure that all of the receiver's scripts are represented byaliases visible in aView.  8/17/96 sw	11/1/96 sw: bug fix: get the list of objects to check correct"	| aModel anAlias modelList |	aModel _ aView model.	modelList _ aView visibleObjectsInOrder.	self allScripts do:		[:aScript | (aScript hasAliasIn: modelList)			ifFalse:				[anAlias _ Alias newUserInstance.				anAlias referTo: aScript.				anAlias useStandardCostumeNamed: 'ContentsString'.				aModel addNewObject: anAlias in: aViewname: (aScript name, ' in ', aModel name)]]! !!ObjBrowser methodsFor: 'as yet unclassified'!defineMessage: aString notifying: aController	"Compile the expressions in aString. Notify aController if a syntaxerror	occurs. Install the compiled method in the selected classclassified under	the currently selected message category name. Answer true if	compilation succeeds, false otherwise.	11/1/96 sw: copied down from generic Browser, then modified tohandle getting the HyperSqueak script object in synch."	| selectedMessageName selector category oldMessageList actualClass |	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	contents _ nil.	selector _		self selectedClassOrMetaClass				compile: aString				classified: (category _ selfselectedMessageCategoryName)				notifying: aController.	selector == nil ifTrue: [^ false].	contents _ aString copy.	selector ~~ selectedMessageName		ifTrue:			[category = ClassOrganizer nullCategory				ifTrue: [self changed: #classSelectionChanged.						selfmessageCategoryListIndex: 1].			self setClassOrganizer.  "In case organization notcached"			(oldMessageList includes: selector)				ifFalse: [self changed: #messageListChanged].			self messageListIndex: (self messageList indexOf:selector)].	(actualClass _ self selectedClass) wantsChangeSetLogging ifFalse:		[actualClass loneInstance establishScriptForSelector:selector].	^ true	! !Obj class removeSelector: #addSelector:withMethod:!Obj class removeSelector: 'addSelector:withMethod:' asSymbol!Object classPool at: #DependentsFields!Undeclared!!ScreenController methodsFor: 'nested menus' priorSource: 1539502 inFile: 1!topScreenMenu	"Answer the screen menu for the top project, from whence there is no relevance to the 'exit project' item.  7/24/96 sw"	TopScreenMenu == nil ifTrue:		[TopScreenMenu _ SelectionMenu labelList:		#(	'restore display'			'open...'			'changes...'			'window...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit...')		lines: #(1 6)		selections: #( restoreDisplay openMenu changesMenu windowMenu helpMenu commonRequests  snapshot saveAs snapshotAndQuit quit)].	^ TopScreenMenu"ScreenController new newScreenMenu startUp"! !----QUIT----(8 November 1996 2:11:31 pm ) priorSource: 1356846!Display newDepth: 8!!DisplayScanner methodsFor: 'private' priorSource: 1356072 inFile: 2!setFont 	| map |	self textColor: foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this may need some caching for reasonable efficiency"		map _ Color defaultColorMapFrom: sourceForm depth to: destForm depth.		map at: 1 put: (backgroundColor bitPatternForDepth: destForm depth) first.		self colorMap: map.		lastSourceDepth _ sourceForm depth].	sourceForm depth = 1 ifTrue:		[colorMap at: 2 put: (foregroundColor bitPatternForDepth: destForm depth) first].	destY _ lineY + line baseline - font ascent! !CharacterScanner subclass: #DisplayScanner	instanceVariableNames: 'lineY runX foregroundColor backgroundColor lastSourceDepth fillBlt lineHeight paragraph'	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!!DisplayScanner methodsFor: 'scanning' priorSource: 1333820 inFile: 2!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done lineIndex stopCondition leftInRun fore back |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	paragraph _ aParagraph.	foregroundColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.	destForm depth > 1 ifTrue:		["Set up color map for display in color"		fore _ foregroundColor bitPatternForDepth: destForm depth.		back _ backgroundColor bitPatternForDepth: destForm depth.		self colorMap: (Bitmap with: back first with: fore first).		lastSourceDepth _ 1].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt destX: visibleRectangle left destY: lineY			width: leftMargin - visibleRectangle left height: lineHeight; copyBits.		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits.		lineY _ lineY + lineHeight]! !!DisplayScanner methodsFor: 'private' priorSource: 1360110 inFile: 2!setFont 	| map |	self textColor: paragraph foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this may need some caching for reasonable efficiency"		map _ Color defaultColorMapFrom: sourceForm depth to: destForm depth.		map at: 1 put: (backgroundColor bitPatternForDepth: destForm depth) first.		self colorMap: map.		lastSourceDepth _ sourceForm depth].	sourceForm depth = 1 ifTrue:		[colorMap at: 2 put: (foregroundColor bitPatternForDepth: destForm depth) first].	destY _ lineY + line baseline - font ascent! !----SNAPSHOT----(8 November 1996 2:46:05 pm ) priorSource: 1359952!!DisplayScanner methodsFor: 'private' priorSource: 1363731 inFile: 2!setFont 	| map |	self textColor: paragraph foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this may need some caching for reasonable efficiency"		map _ Color defaultColorMapFrom: sourceForm depth to: destForm depth.		map at: 1 put: (backgroundColor bitPatternForDepth: destForm depth) first.		self colorMap: map.		lastSourceDepth _ sourceForm depth].	sourceForm depth = 1 ifTrue:		[colorMap == nil ifFalse:			[colorMap at: 2 put: ((foregroundColor bitPatternForDepth: destForm depth) at: 1)]].	destY _ lineY + line baseline - font ascent! !!DisplayScanner methodsFor: 'private' priorSource: 1364522 inFile: 2!setFont 	| map |	self textColor: paragraph foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this may need some caching for reasonable efficiency"		map _ Color defaultColorMapFrom: sourceForm depth to: destForm depth.		map at: 1 put: ((paragraph backgroundColor bitPatternForDepth: destForm depth) at: 1).		self colorMap: map.		lastSourceDepth _ sourceForm depth].	sourceForm depth = 1 ifTrue:		[colorMap == nil ifFalse:			[colorMap at: 2 put: ((foregroundColor bitPatternForDepth: destForm depth) at: 1)]].	destY _ lineY + line baseline - font ascent! !!DisplayScanner methodsFor: 'private' priorSource: 961895 inFile: 2!textColor: textColor	foregroundColor _ textColor! !----SNAPSHOT----(8 November 1996 2:54:28 pm ) priorSource: 1364382!!DisplayScanner methodsFor: 'scanning' priorSource: 1361072 inFile: 2!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done lineIndex stopCondition leftInRun fore back |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	paragraph _ aParagraph.	foregroundColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt destX: visibleRectangle left destY: lineY			width: leftMargin - visibleRectangle left height: lineHeight; copyBits.		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits.		lineY _ lineY + lineHeight]! !!DisplayScanner methodsFor: 'scanning' priorSource: 1366234 inFile: 2!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done lineIndex stopCondition leftInRun fore back |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	paragraph _ aParagraph.	foregroundColor _ aParagraph foregroundColor.	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt destX: visibleRectangle left destY: lineY			width: leftMargin - visibleRectangle left height: lineHeight; copyBits.		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits.		lineY _ lineY + lineHeight]! !!DisplayScanner methodsFor: 'private' priorSource: 1365276 inFile: 2!setFont 	| map |	foregroundColor _ paragraph foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this may need some caching for reasonable efficiency"		map _ Color defaultColorMapFrom: sourceForm depth to: destForm depth.		map at: 1 put: ((paragraph backgroundColor bitPatternForDepth: destForm depth) at: 1).		self colorMap: map.		lastSourceDepth _ sourceForm depth].	sourceForm depth = 1 ifTrue:		[colorMap == nil ifFalse:			[colorMap at: 2 put: ((foregroundColor bitPatternForDepth: destForm depth) at: 1)]].	destY _ lineY + line baseline - font ascent! !----SNAPSHOT----(8 November 1996 2:56:10 pm ) priorSource: 1366093!!DisplayScanner methodsFor: 'scanning' priorSource: 1368616 inFile: 2!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done lineIndex stopCondition leftInRun fore back |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	paragraph _ aParagraph.	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt destX: visibleRectangle left destY: lineY			width: leftMargin - visibleRectangle left height: lineHeight; copyBits.		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits.		lineY _ lineY + lineHeight]! !Display newDepth: 16!Display newDepth: 32!Display newDepth: 4!Display newDepth: 1!!DisplayScanner methodsFor: 'private' priorSource: 1370950 inFile: 2!setFont 	| map |	foregroundColor _ paragraph foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this may need some caching for reasonable efficiency"		map _ Color defaultColorMapFrom: sourceForm depth to: destForm depth.		map at: 1 put: ((paragraph backgroundColor bitPatternForDepth: destForm depth) at: 1).		self colorMap: map.		lastSourceDepth _ sourceForm depth].	sourceForm depth = 1 ifTrue:		[(colorMap == nil or: [destForm depth = 1]) ifFalse:			[colorMap at: 2 put: ((foregroundColor bitPatternForDepth: destForm depth) at: 1)]].	destY _ lineY + line baseline - font ascent! !Display newDepth: 8!----QUIT----(8 November 1996 3:04:00 pm ) priorSource: 1371647!!CharacterScanner methodsFor: 'scanning' priorSource: 302389 inFile: 1!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops displaying: display 	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable. If dextX would exceed rightX, then 	return stops at: 258. If displaying is true, then display the character. 	Advance destX by the width of the character. If stopIndex has been 	reached, then return stops at: 257. Fail under the same conditions that 	the Smalltalk code below would cause an error. Optional. See Object 	documentation whatIsAPrimitive."	| ascii nextDestX maxAscii |	<primitive: 103>	maxAscii _ xTable size-2.	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[ascii _ (sourceString at: lastIndex) asciiValue.			ascii > maxAscii ifTrue: [ascii _ maxAscii].			(stopConditions at: ascii + 1) == nil				ifFalse: [^stops at: ascii + 1].			sourceX _ xTable at: ascii + 1.			nextDestX _ destX + (width _ (xTable at: ascii + 2) - sourceX).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			display ifTrue: [self copyBits].			destX _ nextDestX.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!FormSetFont methodsFor: 'as yet unclassified' priorSource: 1343683 inFile: 2!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width x badChar |	type _ 2.	name _ 'aFormFont'.	minAscii _ asciiStart.	maxAscii _ minAscii + formArray size - 1.	ascent _ ascentVal.	subscript _ superscript _ emphasis _ 0.	height _ width _ 0.	maxWidth _ 0.	formArray do:		[:f | width _ width + f width.		maxWidth _ maxWidth max: f width.		height _ height max: f height + f offset y].	badChar _ (Form extent: 7@height) fillBlack.	width _ width + badChar width.	descent _ height - ascent.	pointSize _ height.	glyphs _ Form extent: width @ height depth: formArray first depth.	xTable _ Array new: maxAscii + 2 withAll: 0.	x _ 0.	formArray doWithIndex:		[:f :i | f displayOn: glyphs at: x@0.		xTable at: minAscii + i+1 put: (x _ x + f width)].	badChar displayOn: glyphs at: x.	xTable at: maxAscii + 3 put: x + f width.	self setStopConditions! !!FormSetFont methodsFor: 'as yet unclassified' priorSource: 1376597 inFile: 2!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width x badChar |	type _ 2.	name _ 'aFormFont'.	minAscii _ asciiStart.	maxAscii _ minAscii + formArray size - 1.	ascent _ ascentVal.	subscript _ superscript _ emphasis _ 0.	height _ width _ 0.	maxWidth _ 0.	formArray do:		[:f | width _ width + f width.		maxWidth _ maxWidth max: f width.		height _ height max: f height + f offset y].	badChar _ (Form extent: 7@height) fillBlack.	width _ width + badChar width.	descent _ height - ascent.	pointSize _ height.	glyphs _ Form extent: width @ height depth: formArray first depth.	xTable _ Array new: maxAscii + 3 withAll: 0.	x _ 0.	formArray doWithIndex:		[:f :i | f displayOn: glyphs at: x@0.		xTable at: minAscii + i+1 put: (x _ x + f width)].	badChar displayOn: glyphs at: x.	xTable at: maxAscii + 3 put: x + f width.	self setStopConditions! !FormSetFont example!((Form extent: 7@20) borderWidth: 1) display!!FormSetFont methodsFor: 'as yet unclassified' priorSource: 1377568 inFile: 2!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width x badChar |	type _ 2.	name _ 'aFormFont'.	minAscii _ asciiStart.	maxAscii _ minAscii + formArray size - 1.	ascent _ ascentVal.	subscript _ superscript _ emphasis _ 0.	height _ width _ 0.	maxWidth _ 0.	formArray do:		[:f | width _ width + f width.		maxWidth _ maxWidth max: f width.		height _ height max: f height + f offset y].	badChar _ (Form extent: 7@height) borderWidth: 1.	width _ width + badChar width.	descent _ height - ascent.	pointSize _ height.	glyphs _ Form extent: width @ height depth: formArray first depth.	xTable _ Array new: maxAscii + 3 withAll: 0.	x _ 0.	formArray doWithIndex:		[:f :i | f displayOn: glyphs at: x@0.		xTable at: minAscii + i+1 put: (x _ x + f width)].	badChar displayOn: glyphs at: x.	xTable at: maxAscii + 3 put: x + badChar width.	self setStopConditions! !FormSetFont example!FormSetFont example!!FormSetFont methodsFor: 'as yet unclassified' priorSource: 1378608 inFile: 2!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width x badChar |	type _ 2.	name _ 'aFormFont'.	minAscii _ asciiStart.	maxAscii _ minAscii + formArray size - 1.	ascent _ ascentVal.	subscript _ superscript _ emphasis _ 0.	height _ width _ 0.	maxWidth _ 0.	formArray do:		[:f | width _ width + f width.		maxWidth _ maxWidth max: f width.		height _ height max: f height + f offset y].	badChar _ (Form extent: 7@height) borderWidth: 1.	width _ width + badChar width.	descent _ height - ascent.	pointSize _ height.	glyphs _ Form extent: width @ height depth: formArray first depth.	xTable _ Array new: maxAscii + 3 withAll: 0.	x _ 0.	formArray doWithIndex:		[:f :i | f displayOn: glyphs at: x@0.		xTable at: minAscii + i+1 put: (x _ x + f width)].	badChar displayOn: glyphs at: x@0.	xTable at: maxAscii + 3 put: x + badChar width.	self setStopConditions! !FormSetFont example!(glyphs copy: ((TextStyle default fontAt: 4) characterFormAt: $S) boundingBox) display!FormSetFont copy: (glyphs copy: ((TextStyle default fontAt: 4) characterFormAt: $S) boundingBox)  toClipBoardAs: $S ascent: (TextStyle default fontAt: 4) ascent.!!CharacterScanner methodsFor: 'scanning' priorSource: 1375049 inFile: 2!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops displaying: display 	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable. If dextX would exceed rightX, then 	return stops at: 258. If displaying is true, then display the character. 	Advance destX by the width of the character. If stopIndex has been 	reached, then return stops at: 257. Fail under the same conditions that 	the Smalltalk code below would cause an error. Optional. See Object 	documentation whatIsAPrimitive."	| ascii nextDestX maxAscii |	<primitive: 103>	maxAscii _ xTable size-2.	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[ascii _ (sourceString at: lastIndex) asciiValue.			"ascii > maxAscii ifTrue: [ascii _ maxAscii]."			(stopConditions at: ascii + 1) == nil				ifFalse: [^stops at: ascii + 1].			sourceX _ xTable at: ascii + 1.			nextDestX _ destX + (width _ (xTable at: ascii + 2) - sourceX).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			display ifTrue: [self copyBits].			destX _ nextDestX.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !----SNAPSHOT----(8 November 1996 5:44:07 pm ) priorSource: 1374911!Smalltalk garbageCollect.  FormSetFont instanceCount!Smalltalk garbageCollect.  TextFontReference instanceCount!Smalltalk garbageCollect.  Paragraph instanceCount!Smalltalk garbageCollect.  Paragraph allInstances!----SNAPSHOT----(8 November 1996 5:54:31 pm ) priorSource: 1382357!Smalltalk garbageCollect.  StrikeFont instanceCount!SqueakSupport initSysLib!TextConstants!Smalltalk!SqueakSupport initSysLib!Smalltalk garbageCollect.  StrikeFont instanceCount!----QUIT----(8 November 1996 6:12:01 pm ) priorSource: 1382647!StrikeFont hackDefaultStyle!!Paragraph methodsFor: 'accessing' priorSource: 1160795 inFile: 2!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	"find the starting and stopping lines"	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange _ aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle height: textStyle lineGrid * 8196.	"max Vector length"	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner _ CompositionScanner new in: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex _ (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine _ startLine - 1.							self lineAt: startLine put: newLine.							startIndex _ newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor.			self updateCompositionHeight.			^self]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine _ compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY _ self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY _ self topAtLineIndex: firstLineIndex + 1.						stopLine _ firstLineIndex.						done _ true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex _ firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].		startIndex _ newLine last + 1.		firstLineIndex _ firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine _ firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle _				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !----QUIT----(10 November 1996 3:50:49 pm ) priorSource: 1382906!'From Squeak 1.1 of September 21, 1996 on 21 October 1996 at 12:52:42 am'!FileDirectory subclass: #UnixFileDirectory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!!BitBltSimulation methodsFor: 'inner loop' priorSource: 29544 inFile: 2!copyLoop 	| prevWord thisWord skewWord halftoneWord mergeWord hInc y i word unskew skewMask notSkewMask |	"This version of the inner loop assumes noSource = false."	hInc _ hDir*4.  "Byte delta"	"degenerate skew fixed for Sparc. 10/20/96 ikp"	skew == -32		ifTrue: [skew _ unskew _ skewMask _ 0]		ifFalse: [skew < 0			ifTrue:				[unskew _ skew+32.				skewMask _ AllOnes << (0-skew)]			ifFalse:				[skew == 0					ifTrue:						[unskew _ 0.						skewMask _ AllOnes]					ifFalse:						[unskew _ skew-32.						skewMask _ AllOnes >> skew]]].	notSkewMask _ skewMask bitInvert32.	noHalftone		ifTrue: [halftoneWord _ AllOnes.  halftoneHeight _ 0]		ifFalse: [halftoneWord _ interpreterProxy longAt: halftoneBase].	y _ dy.	1 to: bbH do: "here is the vertical loop"		[ :i |		halftoneHeight > 1 ifTrue:  "Otherwise, its always the same"			[halftoneWord _ interpreterProxy longAt:						(halftoneBase + (y \\ halftoneHeight * 4)).			y _ y + vDir].		preload ifTrue:			["load the 64-bit shifter"			prevWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc]			ifFalse:			[prevWord _ 0].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)								with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask1 bitAnd: mergeWord)					bitOr: (mask1 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc.		"This central horizontal loop requires no store masking"combinationRule = 3ifTrue: [2 to: nWords-1 do: "Special inner loop for STORE"			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			interpreterProxy longAt: destIndex put: (skewWord bitAnd: halftoneWord).			destIndex _ destIndex + hInc]] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)								with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + hInc]].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)								with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask2 bitAnd: mergeWord)					bitOr: (mask2 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]! !CCodeGenerator comment:'This class oversees the translation of a subset of Smalltalk to C, allowing the comforts of Smalltalk during development and the efficiency and portability of C for the resulting interpreter.  Executing	Interpreter translate: ''InterpTestInline.c'' doInlining: true.(with single quotes) will cause all the methods of Interpreter, ObjectMemory and BitBltSimulation to be translated to C, and stored in the named file.  This file together with the files emitted by InterpreterSupportCode (qv) should be adequate to produce a complete interpreter for the Macintosh environment.'!CCodeGenerator comment:'This class oversees the translation of a subset of Smalltalk to C, allowing the comforts of Smalltalk during development and the efficiency and portability of C for the resulting interpreter.  Executing	Interpreter translate: ''InterpTestInline.c'' doInlining: true.(with single quotes) will cause all the methods of Interpreter, ObjectMemory and BitBltSimulation to be translated to C, and stored in the named file.  This file together with the files emitted by InterpreterSupportCode (qv) should be adequate to produce a complete interpreter for the Macintosh environment.'!!CCodeGenerator methodsFor: 'C code generator' priorSource: 81801 inFile: 2!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: '*/'; cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr; cr.	aStream nextPutAll: '#define true 1'; cr.	aStream nextPutAll: '#define false 0'; cr.	"Note: Using 'null' because nil is predefined in Think C"	aStream nextPutAll: '#define null 0'; cr.	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)/* #define floatAt(i) (*((double *) (i))) *//* #define floatAtput(i, val) (*((double *) (i)) = val) */typedef union {  double value;  struct {    int first, second;  } words;} floatWords;double floatAt(int i){  floatWords conv;  conv.words.first= *((int *)i);  conv.words.second= *(((int *)i)+1);  return conv.value;}double floatAtput(int i, double val){  *((int *)i)= ((floatWords *)&val)->words.first;  *(((int *)i)+1)= ((floatWords *)&val)->words.second;  return val;}#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Imported Variables ***/extern int stackPointer;extern int successFlag;'.	aStream cr.! !!CCodeGenerator methodsFor: 'C code generator' priorSource: 82732 inFile: 2!emitCHeaderOn: aStream	"Write a C file header onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: '*/'; cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr; cr.	aStream nextPutAll: '#define true 1'; cr.	aStream nextPutAll: '#define false 0'; cr.	"Note: Using 'null' because nil is predefined in Think C"	aStream nextPutAll: '#define null 0'; cr.	aStream nextPutAll: '/* memory access macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)/* #define floatAt(i) (*((double *) (i))) *//* #define floatAtput(i, val) (*((double *) (i)) = val) */typedef union {  double value;  struct {    int first, second;  } words;} floatWords;double floatAt(int i){  floatWords conv;  conv.words.first= *((int *)i);  conv.words.second= *(((int *)i)+1);  return conv.value;}double floatAtput(int i, double val){  *((int *)i)= ((floatWords *)&val)->words.first;  *(((int *)i)+1)= ((floatWords *)&val)->words.second;  return val;}#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)int printCallStack(void);void error(char *s);void error(char *s) {	/* Print an error message and exit. */	static int printingStack = false;	printf("\n%s\n\n", s);	if (!!printingStack) {		/* flag prevents recursive error when trying to print a broken stack */		printingStack = true;		printCallStack();	}	exit(-1);}'.	aStream cr.! !!FileDirectory methodsFor: 'path name'!topDirectoryPath	"the path to the root of the filesystem. 10/20/96 ikp"	^''! !!FileDirectory methodsFor: 'file names'!topDirectoryName	"Answer the file list's name for the top (root) directory.	10/18/96 ikp"	^''! !!FileList methodsFor: 'initialization' priorSource: 741984 inFile: 1!directory: dir	"Set the path of the volume to be displayed."	sortMode == nil ifTrue: [sortMode _ #name].	self okToChange ifFalse: [^ self].	directory _ dir.	volList _ (Array with: directory topDirectoryName) , directory pathParts.	self changed: #relabel.	self changed: #list.	self newListAndPattern: (pattern == nil ifTrue: ['*']										ifFalse: [pattern]).! !!FileList methodsFor: 'list access' priorSource: 744133 inFile: 1!toggleListIndex: index	"Select the volume name in the receiver's list whose index is the argument."	| delim name |	volListIndex _ index.	delim _ directory pathNameDelimiter.	name _ volList at: index.	self directory: (FileDirectory newOnPath: 			(String streamContents: 					[:strm |						strm nextPutAll: directory topDirectoryPath.						2 to: index do:						[:i | strm nextPutAll: (volList at: i).						i < index ifTrue: [strm nextPut: delim]]])).! !!Interpreter methodsFor: 'float primitives' priorSource: 204749 inFile: 2!primitiveTimesTwoPower	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	arg _ self popInteger.	rcvr _ self popFloat.	successFlag		ifTrue: [ self pushFloat: (self cCode: 'ldexp(rcvr, arg)') ]		ifFalse: [ self unPop: 2 ].! !!MacFileDirectory methodsFor: 'name service'!topDirectoryName	"Answer the file list's name for the top (root) directory.	10/18/96 ikp"	^'Desk Top'! !!UnixFileDirectory methodsFor: 'name service'!topDirectoryName	"Answer the file list's name for the top (root) directory.	10/18/96 ikp"	^'/'! !!UnixFileDirectory methodsFor: 'name service'!topDirectoryPath	"Answer the path to the top (root) directory.	10/18/96 ikp"	^'/'! !!UnixFileDirectory methodsFor: 'file creation'!fileClass	^ StandardFileStream! !!UnixFileDirectory class methodsFor: 'initialization'!pathNameDelimiter	^ $/! !!UnixFileDirectory class methodsFor: 'initialization'!setMacFileNamed: fileName type: typeString creator: creatorString	"Mac specific; noop on other platforms."! !FileDirectory class removeSelector: #topDirectoryName!UnixFileDirectory class removeSelector: #topDirectoryName!----SNAPSHOT----(13 November 1996 7:51:47 pm ) priorSource: 1389660!----SAVEAS ----(13 November 1996 5:57:17 pm )!Display newDepth: 32!Display newDepth: 16!Display newDepth: 16!Display newDepth: 8!Display newDepth: 8!Display newDepth: 8!Display newDepth: 8!Display newDepth: 16!Display newDepth: 8!'From Squeak 1.13 of October 17, 1996 on 16 November 1996 at 7:53:48 pm'!!BitBltSimulation methodsFor: 'setup' priorSource: 1106917 inFile: 2!checkSourceOverlap	| t |	"check for possible overlap of source and destination"	(sourceForm = destForm and: [dy >= sy]) ifTrue:		[dy > sy ifTrue:			["have to start at bottom"			vDir _ -1.			sy _ sy + bbH - 1.			dy _ dy + bbH - 1]		ifFalse:			[dx > sx ifTrue:				["y's are equal, but x's are backward"				hDir _ -1.				sx _ sx + bbW - 1.				"start at right"				dx _ dx + bbW - 1.				"and fix up masks"				nWords > 1 ifTrue:					[t _ mask1.					mask1 _ mask2.					mask2 _ t]]].		"Dest inits may be affected by this change"		destIndex _ (destBits + 4) + (dy * destRaster + (dx //pixPerWord) *4).		destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir))]! !!BitBltSimulation methodsFor: 'setup' priorSource: 25070 inFile: 2!copyBits	self clipRange.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil].	self destMaskAndPointerInit.	bitCount _ 0.	noSource		ifTrue: [self copyLoopNoSource]		ifFalse: [self checkSourceOverlap.				(sourcePixSize ~= destPixSize					or: [colorMap ~= interpreterProxynilObject])					ifTrue: [self copyLoopPixMap]					ifFalse: [selfsourceSkewAndPointerInit.							self copyLoop]].	combinationRule = 22 ifTrue:		["zero width and height; return the count"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		interpreterProxy pop: 1.		^ interpreterProxy pushInteger: bitCount].	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !!BitBltSimulation methodsFor: 'setup' priorSource: 809460 inFile: 2!warpBits	| ns |	ns _ noSource.  noSource _ true.		self clipRange.  "noSource suppresses sourceRect clipping"		noSource _ ns.	(noSource or: [bbW <= 0 or: [bbH <= 0]]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil].	self destMaskAndPointerInit.	self warpLoop.	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !----SNAPSHOT----(18 November 1996 2:04:44 pm ) priorSource: 1400416!Time millisecondsToRun: [		Interpreter translate: 'InterpTestInline2.c' doInlining: true.		Smalltalk beep]!Display newDepth: 16!Display newDepth: 32!Display newDepth: 16!Display newDepth: 32!Display newDepth: 16!Display newDepth: 32!Float pi!----SNAPSHOT----(18 November 1996 2:52:17 pm ) priorSource: 1403202!----SNAPSHOT----(18 November 1996 2:52:42 pm ) priorSource: 1403532!