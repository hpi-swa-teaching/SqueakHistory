'From Squeak 1.3 of Jan 16, 1998 on 16 January 1998 at 5:55:27 pm'!Abstract class for timed events in a MIDI score.!!AbstractScoreEvent methodsFor: 'all' stamp: 'jm 12/31/97 11:46'!isNoteEvent	^ false! !!AbstractScoreEvent methodsFor: 'all' stamp: 'jm 12/31/97 11:46'!isTempoEvent	^ false! !!AbstractScoreEvent methodsFor: 'all' stamp: 'jm 12/31/97 11:43'!time	^ time! !!AbstractScoreEvent methodsFor: 'all' stamp: 'jm 12/31/97 11:43'!time: aNumber	time _ aNumber.! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 12/9/97 11:31'!duration: seconds	"Scale my envelopes to the given duration. Subclasses overriding this method should include a resend to super."	envelopes do: [:e | e duration: seconds].! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 12/17/97 07:21'!initialize	envelopes _ Array new.	mSecsSinceStart _ 0.	samplesUntilNextControl _ 0.	scaledVol _ (1.0 * ScaleFactor) rounded.	scaledVolIncr _ 0.	scaledVolLimit _ scaledVol.! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 12/19/97 08:33'!setLoudness: vol	envelopes do: [:e |		(e isKindOf: VolumeEnvelope) ifTrue: [e scale: vol]].! !!AbstractSound methodsFor: 'initialization'!setPitch: p dur: d loudness: l	self subclassResponsibility.! !!AbstractSound methodsFor: 'envelopes' stamp: 'jm 12/17/97 22:23'!addEnvelope: anEnvelope	"Add the given envelope to my envelopes list."	anEnvelope target: self.	envelopes _ envelopes copyWith: anEnvelope.! !!AbstractSound methodsFor: 'envelopes' stamp: 'jm 12/15/97 17:02'!envelopes	"Return my collection of envelopes."	^ envelopes! !!AbstractSound methodsFor: 'envelopes' stamp: 'jm 12/15/97 17:02'!removeEnvelope: anEnvelope	"Remove the given envelope from my envelopes list."	envelopes _ envelopes copyWithout: anEnvelope.! !!AbstractSound methodsFor: 'volume' stamp: 'jm 12/31/97 19:05'!adjustVolumeTo: vol overMSecs: mSecs	"Adjust the volume of this sound to the given volume, a number in the range [0.0..1.0], over the given number of milliseconds. The volume will be changed a little bit on each sample until the desired volume is reached."	scaledVolLimit _ (32768.0 * vol) truncated.	scaledVolLimit > ScaleFactor ifTrue: [scaledVolLimit _ ScaleFactor].	scaledVolLimit < 0 ifTrue: [scaledVolLimit _ 0].	mSecs = 0		ifTrue: [  "change immediately"			scaledVol _ scaledVolLimit.			scaledVolIncr _ 0]		ifFalse: [			scaledVolIncr _				((scaledVolLimit - scaledVol) * 1000) // (self samplingRate * mSecs)].! !!AbstractSound methodsFor: 'volume' stamp: 'jm 12/17/97 17:39'!initialVolume: vol	"Set the initial volume of this sound to the given volume, a number in the range [0.0..1.0]."	scaledVol _ (((vol asFloat min: 1.0) max: 0.0) * ScaleFactor) rounded.	scaledVolLimit _ scaledVol.	scaledVolIncr _ 0.! !!AbstractSound methodsFor: 'volume' stamp: 'jm 12/16/97 10:30'!volumeEnvelopeScaledTo: scalePoint	"Return a collection of values representing my volume envelope scaled by the given point. The scale point's x component is pixels/second and its y component is the number of pixels for full volume."	| env amp vScale cnt oldT newT totalCnt |	self error: 'not yet implemented'."old code:"	totalCnt _ "initialCount" 1000.	env _ Array new: (totalCnt * scalePoint x // self samplingRate min: 500).	amp _ scaledVol asFloat / ScaleFactor.	vScale _ scalePoint y asFloat / 1000.0.	cnt _ totalCnt.	oldT _ newT _ 0.  "Time in units of scale x per second"	[cnt > 0 and: [newT <= env size]] whileTrue:		[env atAll: (oldT+1 to: newT) put: (amp*vScale) asInteger.		oldT _ newT.		"amp _ amp * decayRate."		cnt _ cnt - samplesUntilNextControl.		newT _ totalCnt - cnt * scalePoint x // self samplingRate].	env atAll: ((oldT+1 min: env size) to: env size) put: (amp*vScale) asInteger.	^ env! !!AbstractSound methodsFor: 'playing' stamp: 'jm 11/23/97 10:56'!computeSamplesForSeconds: seconds	"Compute the samples of this sound without outputting them, and return the resulting buffer of samples."	| buf |	self reset.	buf _ SoundBuffer newStereoSampleCount: (self samplingRate * seconds) asInteger.	self playSampleCount: buf stereoSampleCount into: buf startingAt: 1 stereo: false.	^ buf! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/24/97 20:48'!pause	"Pause this sound. It can be resumed from this point, or reset and resumed to start from the beginning."	SoundPlayer pauseSound: self.! !!AbstractSound methodsFor: 'playing' stamp: 'jm 12/9/97 10:46'!playAndWaitUntilDone	"Play this sound to the sound ouput port in real time."	SoundPlayer playSound: self.	[self samplesRemaining > 0] whileTrue.! !!AbstractSound methodsFor: 'playing' stamp: 'jm 1/5/98 13:53'!playSampleCount: n into: aSoundBuffer startingAt: startIndex stereo: stereoFlag	"Mixes the next count samples of this sound into the given buffer starting at the given index, updating the receiver's control parameters at periodic intervals."	| fullVol samplesBetweenControlUpdates pastEnd i remainingSamples count |	fullVol _ AbstractSound scaleFactor.	samplesBetweenControlUpdates _ self samplingRate // self controlRate.	pastEnd _ startIndex + n.  "index just index of after last sample"	i _ startIndex.	[i < pastEnd] whileTrue: [		remainingSamples _ self samplesRemaining.		remainingSamples <= 0 ifTrue: [^ self].		count _ pastEnd - i.		samplesUntilNextControl < count ifTrue: [count _ samplesUntilNextControl].		remainingSamples < count ifTrue: [count _ remainingSamples].		self mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: fullVol rightVol: fullVol.		samplesUntilNextControl _ samplesUntilNextControl - count.		samplesUntilNextControl <= 0 ifTrue: [			self doControl.			samplesUntilNextControl _ samplesBetweenControlUpdates].		i _ i + count].! !!AbstractSound methodsFor: 'playing' stamp: 'jm 9/17/97 12:58'!playSilently	"Compute the samples of this sound without outputting them. Used for performance analysis."	| buf |	self reset.	buf _ SoundBuffer newStereoSampleCount: (self samplingRate // 10).	[self samplesRemaining > 0] whileTrue: [		buf primFill: 0.		self playSampleCount: buf stereoSampleCount into: buf startingAt: 1 stereo: true].! !!AbstractSound methodsFor: 'playing' stamp: 'jhm 10/15/97 15:13'!playSilentlyUntil: startTime	"Compute the samples of this sound without outputting them. Used to fast foward to a particular starting time. The start time is given in seconds."	| buf startSample nextSample samplesRemaining n |	self reset.	buf _ SoundBuffer newStereoSampleCount: (self samplingRate // 10).	startSample _ (startTime * self samplingRate) asInteger.	nextSample _ 1.	[self samplesRemaining > 0] whileTrue: [		nextSample >= startSample ifTrue: [^ self].		samplesRemaining _ startSample - nextSample.		samplesRemaining > buf stereoSampleCount			ifTrue: [n _ buf stereoSampleCount]			ifFalse: [n _ samplesRemaining].		self playSampleCount: n into: buf startingAt: 1 stereo: true.		nextSample _ nextSample + n].! !!AbstractSound methodsFor: 'playing' stamp: 'jm 9/13/97 19:46'!resumePlaying	"Pause this sound. It can be resumed from this point, or reset and resumed to start from the beginning."	SoundPlayer pauseSound: self.  "be sure it isn't already playing"	SoundPlayer resumePlaying: self.! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 12/17/97 07:22'!doControl	"Update the control parameters of this sound using its envelopes, if any."	"Note: This is only called at a small fraction of the sampling rate."	mSecsSinceStart _ mSecsSinceStart + (1000 // self controlRate).	envelopes == nil ifFalse: [		1 to: envelopes size do: [:i |			(envelopes at: i) updateTargetAt: mSecsSinceStart]].! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 11/24/97 16:00'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1. The leftVol and rightVol parameters determine the volume of the sound in each channel, where 0 is silence and 1000 is full volume."	self subclassResponsibility.! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 12/17/97 07:31'!reset	"Reset my internal state for a replay. Methods that override this method should do super reset."	mSecsSinceStart _ 0.	samplesUntilNextControl _ self samplingRate // self controlRate.	envelopes == nil ifFalse: [		1 to: envelopes size do: [:i |			(envelopes at: i) updateTargetAt: 0]].! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 12/17/97 17:57'!samplesRemaining	"Answer the number of samples remaining until the end of this sound. A sound with an indefinite ending time should answer some large integer such as 1000000."	^ 1000000! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 1/5/98 14:21'!storeSample: sample in: aSoundBuffer at: sliceIndex leftVol: leftVol rightVol: rightVol	"This method is provided for documentation. To gain 10% more speed when running sound generation in Smalltalk, this method is hand-inlined into all sound generation methods that use it."	| i s |		leftVol > 0 ifTrue: [			i _ (2 * sliceIndex) - 1.			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i _ 2 * sliceIndex.			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 12/17/97 17:57'!updateVolume	"Increment the volume envelope of this sound. To avoid clicks, the volume envelope must be interpolated at the sampling rate, rather than just at the control rate like other envelopes. At the control rate, the volume envelope computes the slope and next target volume volume for the current segment of the envelope (i.e., it sets the rate of change for the volume parameter). When that target volume is reached, incrementing is stopped until a new increment is set."	"This method is provided for documentation. To gain 10% more speed when running sound generation in Smalltalk, it is hand-inlined into all sound generation methods that use it."		scaledVolIncr ~= 0 ifTrue: [			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0]].! !!AbstractSound methodsFor: 'composition' stamp: 'jm 12/17/97 18:00'!delayedBy: seconds	"Return a composite sound consisting of a rest for the given amount of time followed by the receiver."	^ (RestSound dur: seconds), self! !!AbstractSound methodsFor: 'sampling rates' stamp: 'jm 12/15/97 14:15'!controlRate	"Answer the number of control changes per second."	^ 100! !!AbstractSound methodsFor: 'sampling rates' stamp: 'jm 12/17/97 18:00'!samplingRate	"Answer the sampling rate in samples per second."	^ SoundPlayer samplingRate! !!AbstractSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:15'!copy	"A sound should copy all of the state needed to play itself, allowing two copies of a sound to play at the same time. These semantics require a recursive copy but only down to the level of immutable data. For example, a SampledSound need not copy its sample buffer. Subclasses overriding this method should include a resend to super."	^ self clone copyEnvelopes! !!AbstractSound methodsFor: 'copying' stamp: 'jm 12/17/97 22:22'!copyEnvelopes	"Private!! Support for copying. Copy my envelopes."	envelopes _ envelopes collect: [:e | e copy target: self].! !!AbstractSound class methodsFor: 'class initialization' stamp: 'jm 1/5/98 14:10'!initialize	"AbstractSound initialize"	ScaleFactor _ 2 raisedTo: 15.	MaxScaledValue _ ((2 raisedTo: 31) // ScaleFactor) - 1.  "magnitude of largest scaled value in 32-bits"! !!AbstractSound class methodsFor: 'class initialization' stamp: 'jm 1/5/98 13:51'!scaleFactor	^ ScaleFactor! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 1/5/98 17:40'!default	"Return a default sound prototype for this class, with envelopes if appropriate. (This is in contrast to new, which returns a raw instance without envelopes.)"	^ self new! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 12/17/97 17:26'!dur: d	"Return a rest of the given duration."	^ self basicNew setDur: d! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 12/17/97 17:41'!namedNoteSequenceOn: aSound from: anArray	"Build a note sequence (i.e., a SequentialSound) from the given array using the given sound as the instrument. Elements are either (pitchName, duration, loudness) triples or (#rest duration) pairs."	| score |	score _ SequentialSound new.	anArray do: [:el |		el size = 3			ifTrue: [				score add: (					aSound copy						setPitch: (self pitchForName: (el at: 1))						dur: (el at: 2)						loudness: (el at: 3) / 1000.0)]			ifFalse: [				score add: (RestSound dur: (el at: 2))]].	^ score! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 12/17/97 17:26'!new	^ self basicNew initialize! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 12/17/97 17:41'!noteSequenceOn: aSound from: anArray	"Build a note sequence (i.e., a SequentialSound) from the given array using the given sound as the instrument. Elements are either (pitch, duration, loudness) triples or (#rest duration) pairs."	| score |	score _ SequentialSound new.	anArray do: [:el |		el size = 3			ifTrue: [				score add: (					aSound copy						setPitch: (el at: 1)						dur: (el at: 2)						loudness: (el at: 3) / 1000.0)]			ifFalse: [				score add: (RestSound dur: (el at: 2))]].	^ score! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 12/17/97 17:27'!pitch: p dur: d loudness: l	"Return a new sound object for a note with the given parameters."	^ self new setPitch: p dur: d loudness: l! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:35'!chromaticScale	"PluckedSound chromaticScale play"	^ self chromaticScaleOn: self default! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 12/17/97 17:00'!chromaticScaleOn: aSound	"PluckedSound chromaticScale play"	^ self namedNoteSequenceOn: aSound from: #(		(c4  	0.5 400)		(cs4  	0.5 400)  "s means sharp"		(d4  	0.5 400)		(eb4  	0.5 400)  "b means flat (it looks like a flat sign in music notation)"		(e4  	0.5 400)		(f4  	0.5 400)		('f#4'  	0.5 400)  "# also means sharp, but it must be quoted within an array literal"		(g4  	0.5 400)		(af4  	0.5 400)  "f also means flat"		(a4  	0.5 400)		(bb4  	0.5 400)		(b4  	0.5 400)		(c5  	2.0 400))! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:36'!hiMajorScale	"FMSound hiMajorScale play"	^ self hiMajorScaleOn: self default! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 12/17/97 16:59'!hiMajorScaleOn: aSound	"FMSound majorScale play"	^ self namedNoteSequenceOn: aSound from: #(		(c6 0.25 400)		(d6 0.25 400)		(e6 0.25 400)		(f6 0.25 400)		(g6 0.25 400)		(a6 0.25 400)		(b6 0.25 400)		(c7 0.25 400)		(d7 0.25 400)		(c7 0.25 400)		(b6 0.25 400)		(a6 0.25 400)		(g6 0.25 400)		(f6 0.25 400)		(e6 0.25 400)		(d6 0.25 400)		(c6 1.00 400))! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:36'!lowMajorScale	"PluckedSound lowMajorScale play"	^ self lowMajorScaleOn: self default! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 12/17/97 16:59'!lowMajorScaleOn: aSound	"PluckedSound lowMajorScale play"	^ self namedNoteSequenceOn: aSound from: #(		(c3 0.25 400)		(d3 0.25 400)		(e3 0.25 400)		(f3 0.25 400)		(g3 0.25 400)		(a3 0.25 400)		(b3 0.25 400)		(c4 0.25 400)		(d4 0.25 400)		(c4 0.25 400)		(b3 0.25 400)		(a3 0.25 400)		(g3 0.25 400)		(f3 0.25 400)		(e3 0.25 400)		(d3 0.25 400)		(c3 1.00 400))! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:34'!majorScale	"FMSound majorScale play"	^ self majorScaleOn: self default! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 12/17/97 17:01'!majorScaleOn: aSound	"FMSound majorScale play"	^ self namedNoteSequenceOn: aSound from: #(		(c5 0.25 400)		(d5 0.25 400)		(e5 0.25 400)		(f5 0.25 400)		(g5 0.25 400)		(a5 0.25 400)		(b5 0.25 400)		(c6 0.25 400)		(d6 0.25 400)		(c6 0.25 400)		(b5 0.25 400)		(a5 0.25 400)		(g5 0.25 400)		(f5 0.25 400)		(e5 0.25 400)		(d5 0.25 400)		(c5 1.00 400))! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:32'!scaleTest	"AbstractSound scaleTest play"	^ MixedSound new		add: FMSound majorScale pan: 0;		add: (PluckedSound lowMajorScale delayedBy: 0.5) pan: 1.0.! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 12/17/97 21:25'!testFMInteractively	"Experiment with different settings of the FM modulation and multiplier settings interactively by moving the mouse. The top-left corner of the screen is 0 for both parameters. Stop when the mouse is pressed."	"AbstractSound testFMInteractively"	| s mousePt lastVal status mod mult |	SoundPlayer startPlayerProcessBufferSize: 1100 rate: 11025 stereo: false.	s _ FMSound pitch: 440.0 dur: 200.0 loudness: 0.2.	SoundPlayer playSound: s.	lastVal _ nil.	[Sensor anyButtonPressed] whileFalse: [		mousePt _ Sensor cursorPoint.		mousePt ~= lastVal ifTrue: [			mod _ mousePt x asFloat / 20.0.			mult _ mousePt y asFloat / 20.0.			s modulation: mod multiplier: mult.			lastVal _ mousePt.			status _'mod: ', mod printString, 'mult: ', mult printString.			status asParagraph displayOn: Display at: 10@10]].	SoundPlayer shutDown.! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 1/5/98 17:38'!bachFugue	"Play a fugue by J. S. Bach using and instance of me as the sound for all four voices."	"PluckedSound bachFugue play"	^ self bachFugueOn: self default! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 1/5/98 18:27'!bachFugueOn: aSound	"Play a fugue by J. S. Bach using the given sound as the sound for all four voices."	"PluckedSound bachFugue play"	^ MixedSound new		add: (self bachFugueVoice1On: aSound) pan: 1.0;		add: (self bachFugueVoice2On: aSound) pan: 0.0;		add: (self bachFugueVoice3On: aSound) pan: 1.0;		add: (self bachFugueVoice4On: aSound) pan: 0.0.! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 12/17/97 16:51'!bachFugueVoice1On: aSound	"Voice one of a fugue by J. S. Bach."	^ self noteSequenceOn: aSound from: #(		(1047 0.15 268)		(988  0.15 268)		(1047 0.30 268)		(784  0.30 268)		(831  0.30 268)		(1047 0.15 268)		(988  0.15 268)		(1047 0.30 268)		(1175 0.30 268)		(784  0.30 268)		(1047 0.15 268)		(988  0.15 268)		(1047 0.30 268)		(1175 0.30 268)		(698  0.15 268)		(784  0.15 268)		(831  0.60 268)		(784  0.15 268)		(698  0.15 268)		(622  0.15 268)		(1047 0.15 268)		(988  0.15 268)		(880  0.15 268)		(784  0.15 268)		(698  0.15 268)		(622  0.15 268)		(587  0.15 268)		(523  0.30 268)		(1245 0.30 268)		(1175 0.30 268)		(1047 0.30 268)		(932  0.30 268)		(880  0.30 268)		(932  0.30 268)		(1047 0.30 268)		(740  0.30 268)		(784  0.30 268)		(880  0.30 268)		(740  0.30 268)		(784  0.60 268)		(rest 0.15)		(523  0.15 268)		(587  0.15 268)		(622  0.15 268)		(698  0.15 268)		(784  0.15 268)		(831  0.45 268)		(587  0.15 268)		(622  0.15 268)		(698  0.15 268)		(784  0.15 268)		(880  0.15 268)		(932  0.45 268)		(622  0.15 268)		(698  0.15 268)		(784  0.15 268)		(831  0.15 268)		(784  0.15 268)		(698  0.15 268)		(622  0.15 268)		(587  0.30 268)		(1047 0.15 268)		(988  0.15 268)		(1047 0.60 268)		(rest 0.9)		(1397 0.30 268)		(1245 0.30 268)		(1175 0.30 268)		(rest 0.3)		(831  0.30 268)		(784  0.30 268)		(698  0.30 268)		(784  0.30 268)		(698  0.15 268)		(622  0.15 268)		(698  0.30 268)		(587  0.30 268)		(784  0.60 268)		(rest 0.3)		(988  0.30 268)		(1047 0.30 268)		(1047 0.15 268)		(988  0.15 268)		(1047 0.30 268)		(784  0.30 268)		(831  0.60 268)		(rest 0.3)		(880  0.30 268)		(932  0.30 268)		(932  0.15 268)		(880  0.15 268)		(932  0.30 268)		(698  0.30 268)		(784  0.60 268)		(rest 0.3)		(784  0.30 268)		(831  0.30 268)		(831  0.30 268)		(784  0.30 268)		(698  0.30 268)		(rest 0.3)		(415  0.30 268)		(466  0.30 268)		(523  0.30 268)		(rest 0.3)		(415  0.15 268)		(392  0.15 268)		(415  0.30 268)		(349  0.30 268)		(466  0.30 268)		(523  0.30 268)		(466  0.30 268)		(415  0.30 268)		(466  0.30 268)		(392  0.30 268)		(349  0.30 268)		(311  0.30 268)		(349  0.30 268)		(554  0.30 268)		(523  0.30 268)		(466  0.30 268)		(523  0.30 268)		(415  0.30 268)		(392  0.30 268)		(349  0.30 268)		(392  0.30 268)		(784  0.15 268)		(740  0.15 268)		(784  0.30 268)		(523  0.30 268)		(622  0.30 268)		(784  0.15 268)		(740  0.15 268)		(784  0.30 268)		(880  0.30 268)		(587  0.30 268)		(784  0.15 268)		(740  0.15 268)		(784  0.30 268)		(880  0.30 268)		(523  0.15 268)		(587  0.15 268)		(622  0.60 268)		(587  0.15 268)		(523  0.15 268)		(466  0.30 346)		(rest 0.45)		(587  0.15 346)		(659  0.15 346)		(740  0.15 346)		(784  0.15 346)		(880  0.15 346)		(932  0.45 346)		(659  0.15 346)		(698  0.15 346)		(784  0.15 346)		(880  0.15 346)		(932  0.15 346)		(1047 0.45 346)		(740  0.15 346)		(784  0.15 346)		(880  0.15 346)		(932  0.30 346)		(622  0.15 346)		(587  0.15 346)		(622  0.30 346)		(392  0.30 346)		(415  0.30 346)		(698  0.15 346)		(622  0.15 346)		(698  0.30 346)		(440  0.30 346)		(466  0.30 346)		(784  0.15 346)		(698  0.15 346)		(784  0.30 346)		(494  0.30 346)		(523  0.15 346)		(698  0.15 346)		(622  0.15 346)		(587  0.15 346)		(523  0.15 346)		(466  0.15 346)		(440  0.15 346)		(392  0.15 346)		(349  0.30 346)		(831  0.30 346)		(784  0.30 346)		(698  0.30 346)		(622  0.30 346)		(587  0.30 346)		(622  0.30 346)		(698  0.30 346)		(494  0.30 346)		(523  0.30 346)		(587  0.30 346)		(494  0.30 346)		(523  0.60 346)		(rest 0.3)		(659  0.30 346)		(698  0.30 346)		(698  0.15 346)		(659  0.15 346)		(698  0.30 346)		(523  0.30 346)		(587  0.60 346)		(rest 0.3)		(587  0.30 346)		(622  0.30 346)		(622  0.15 346)		(587  0.15 346)		(622  0.30 346)		(466  0.30 346)		(523  1.20 346)		(523  0.30 346)		(587  0.15 346)		(622  0.15 346)		(698  0.15 346)		(622  0.15 346)		(698  0.15 346)		(587  0.15 346)		(494  0.30 457)		(rest 0.6)		(494  0.30 457)		(523  0.30 457)		(rest 0.6)		(622  0.30 457)		(587  0.30 457)		(rest 0.6)		(698  0.60 457)		(rest 0.6)		(698  0.30 457)		(622  0.30 457)		(831  0.30 457)		(784  0.30 457)		(698  0.30 457)		(622  0.30 457)		(587  0.30 457)		(622  0.30 457)		(698  0.30 457)		(494  0.30 457)		(523  0.30 457)		(587  0.30 457)		(494  0.30 457)		(494  0.30 457)		(523  0.30 457)		(rest 0.3)		(523  0.30 457)		(698  0.15 457)		(587  0.15 457)		(622  0.15 457)		(523  0.45 457)		(494  0.30 457)		(523  0.60 457)		(rest 0.3)		(659  0.30 268)		(698  0.60 268)		(rest 0.3)		(698  0.30 268)		(698  0.30 268)		(622  0.15 268)		(587  0.15 268)		(622  0.30 268)		(698  0.30 268)		(587  0.40 268)		(rest 0.4)		(587  0.40 268)		(rest 0.4)		(523  1.60 268)).! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 12/17/97 16:52'!bachFugueVoice2On: aSound	"Voice two of a fugue by J. S. Bach."	^ self noteSequenceOn: aSound from: #(		(rest 4.8)		(1568 0.15 346)		(1480 0.15 346)		(1568 0.30 346)		(1047 0.30 346)		(1245 0.30 346)		(1568 0.15 346)		(1480 0.15 346)		(1568 0.30 346)		(1760 0.30 346)		(1175 0.30 346)		(1568 0.15 346)		(1480 0.15 346)		(1568 0.30 346)		(1760 0.30 346)		(1047 0.15 346)		(1175 0.15 346)		(1245 0.60 346)		(1175 0.15 346)		(1047 0.15 346)		(932  0.30 346)		(1245 0.15 346)		(1175 0.15 346)		(1245 0.30 346)		(784  0.30 346)		(831  0.30 346)		(1397 0.15 346)		(1245 0.15 346)		(1397 0.30 346)		(880  0.30 346)		(932  0.30 346)		(1568 0.15 346)		(1397 0.15 346)		(1568 0.30 346)		(988  0.30 346)		(1047 0.30 346)		(1175 0.15 346)		(1245 0.15 346)		(1397 0.90 346)		(1245 0.15 346)		(1175 0.15 346)		(1047 0.15 346)		(932  0.15 346)		(831  0.15 346)		(784  0.15 346)		(698  0.30 346)		(1661 0.30 346)		(1568 0.30 346)		(1397 0.30 346)		(1245 0.30 346)		(1175 0.30 346)		(1245 0.30 346)		(1397 0.30 346)		(988  0.30 346)		(1047 0.30 346)		(1175 0.30 346)		(988  0.30 346)		(1047 0.30 457)		(1568 0.15 457)		(1480 0.15 457)		(1568 0.30 457)		(1175 0.30 457)		(1245 0.60 457)		(rest 0.3)		(1319 0.30 457)		(1397 0.30 457)		(1397 0.15 457)		(1319 0.15 457)		(1397 0.30 457)		(1047 0.30 457)		(1175 0.60 457)		(rest 0.3)		(1175 0.30 457)		(1245 0.30 457)		(1245 0.15 457)		(1175 0.15 457)		(1245 0.30 457)		(932  0.30 457)		(1047 0.30 457)		(1245 0.15 457)		(1175 0.15 457)		(1245 0.30 457)		(1397 0.30 457)		(932  0.30 457)		(1245 0.15 457)		(1175 0.15 457)		(1245 0.30 457)		(1397 0.30 457)		(831  0.15 457)		(932  0.15 457)		(1047 0.60 457)		(932  0.15 457)		(831  0.15 457)		(784  0.15 457)		(622  0.15 457)		(698  0.15 457)		(784  0.15 457)		(831  0.15 457)		(932  0.15 457)		(1047 0.15 457)		(1175 0.15 457)		(1245 0.15 457)		(1175 0.15 457)		(1047 0.15 457)		(1175 0.15 457)		(1245 0.15 457)		(1397 0.15 457)		(1568 0.15 457)		(1760 0.15 457)		(1865 0.15 457)		(698  0.15 457)		(784  0.15 457)		(831  0.15 457)		(932  0.15 457)		(1047 0.15 457)		(1175 0.15 457)		(1319 0.15 457)		(1397 0.15 457)		(1245 0.15 457)		(1175 0.15 457)		(1245 0.15 457)		(1397 0.15 457)		(1568 0.15 457)		(1760 0.15 457)		(1976 0.15 457)		(2093 0.30 457)		(1976 0.15 457)		(1760 0.15 457)		(1568 0.15 457)		(1397 0.15 457)		(1245 0.15 457)		(1175 0.15 457)		(1047 0.30 457)		(1245 0.30 457)		(1175 0.30 457)		(1047 0.30 457)		(932  0.30 457)		(880  0.30 457)		(932  0.30 457)		(1047 0.30 457)		(740  0.30 457)		(784  0.30 457)		(880  0.30 457)		(740  0.30 457)		(784  0.30 457)		(1175 0.15 457)		(1047 0.15 457)		(1175 0.30 457)		(rest 0.6)		(1319 0.15 457)		(1175 0.15 457)		(1319 0.30 457)		(rest 0.6)		(1480 0.15 457)		(1319 0.15 457)		(1480 0.30 457)		(rest 0.6)		(784  0.15 457)		(698  0.15 457)		(784  0.30 457)		(rest 0.6)		(880  0.15 457)		(784  0.15 457)		(880  0.30 457)		(rest 0.6)		(988  0.15 457)		(880  0.15 457)		(988  0.30 457)		(rest 0.6)		(1047 0.15 457)		(988  0.15 457)		(1047 0.30 457)		(784  0.30 457)		(831  0.30 457)		(1047 0.15 457)		(988  0.15 457)		(1047 0.30 457)		(1175 0.30 457)		(784  0.30 457)		(1047 0.15 457)		(988  0.15 457)		(1047 0.30 457)		(1175 0.30 457)		(698  0.15 457)		(784  0.15 457)		(831  0.60 457)		(784  0.15 457)		(698  0.15 457)		(622  0.30 457)		(1047 0.15 457)		(988  0.15 457)		(1047 0.30 457)		(784  0.30 457)		(831  0.60 457)		(rest 0.3)		(880  0.30 457)		(932  0.30 457)		(932  0.15 457)		(880  0.15 457)		(932  0.30 457)		(698  0.30 457)		(784  0.60 457)		(rest 0.3)		(784  0.60 457)		(831  0.15 457)		(932  0.15 457)		(1047 0.15 457)		(988  0.15 457)		(1047 0.15 457)		(831  0.15 457)		(698  1.20 457)		(698  0.30 591)		(1175 0.15 591)		(1047 0.15 591)		(1175 0.30 591)		(698  0.30 591)		(622  0.30 591)		(1245 0.15 591)		(1175 0.15 591)		(1245 0.30 591)		(784  0.30 591)		(698  0.30 591)		(1397 0.15 591)		(1245 0.15 591)		(1397 0.30 591)		(831  0.30 591)		(784  0.15 591)		(1397 0.15 591)		(1245 0.15 591)		(1175 0.15 591)		(1047 0.15 591)		(988  0.15 591)		(880  0.15 591)		(784  0.15 591)		(1047 0.30 591)		(1397 0.30 591)		(1245 0.30 591)		(1175 0.30 591)		(rest 0.3)		(831  0.30 591)		(784  0.30 591)		(698  0.30 591)		(784  0.30 591)		(698  0.15 591)		(622  0.15 591)		(698  0.30 591)		(587  0.30 591)		(831  0.30 591)		(784  0.30 591)		(rest 0.3)		(880  0.30 591)		(988  0.30 591)		(1047 0.30 591)		(698  0.15 591)		(622  0.15 591)		(587  0.15 591)		(523  0.15 591)		(523  0.30 591)		(1047 0.15 346)		(988  0.15 346)		(1047 0.30 346)		(784  0.30 346)		(831  0.30 346)		(1047 0.15 346)		(988  0.15 346)		(1047 0.30 346)		(1175 0.30 346)		(784  0.30 346)		(1047 0.15 346)		(988  0.15 346)		(1047 0.30 346)		(1175 0.30 346)		(698  0.20 346)		(784  0.20 346)		(831  0.80 346)		(784  0.20 346)		(698  0.20 346)		(659  1.60 346)).! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 12/17/97 16:52'!bachFugueVoice3On: aSound	"Voice three of a fugue by J. S. Bach."	^ self noteSequenceOn: aSound from: #(		(rest 14.4)		(523  0.15 457)		(494  0.15 457)		(523  0.30 457)		(392  0.30 457)		(415  0.30 457)		(523  0.15 457)		(494  0.15 457)		(523  0.30 457)		(587  0.30 457)		(392  0.30 457)		(523  0.15 457)		(494  0.15 457)		(523  0.30 457)		(587  0.30 457)		(349  0.15 457)		(392  0.15 457)		(415  0.60 457)		(392  0.15 457)		(349  0.15 457)		(311  0.15 457)		(523  0.15 457)		(494  0.15 457)		(440  0.15 457)		(392  0.15 457)		(349  0.15 457)		(311  0.15 457)		(294  0.15 457)		(262  0.15 457)		(294  0.15 457)		(311  0.15 457)		(294  0.15 457)		(262  0.15 457)		(233  0.15 457)		(208  0.15 457)		(196  0.15 457)		(175  0.15 457)		(466  0.15 457)		(415  0.15 457)		(392  0.15 457)		(349  0.15 457)		(311  0.15 457)		(294  0.15 457)		(262  0.15 457)		(233  0.15 457)		(262  0.15 457)		(294  0.15 457)		(262  0.15 457)		(233  0.15 457)		(208  0.15 457)		(196  0.15 457)		(175  0.15 457)		(156  0.15 457)		(415  0.15 457)		(392  0.15 457)		(349  0.15 457)		(311  0.15 457)		(277  0.15 457)		(262  0.15 457)		(233  0.15 457)		(208  0.30 457)		(523  0.30 457)		(466  0.30 457)		(415  0.30 457)		(392  0.30 457)		(349  0.30 457)		(392  0.30 457)		(415  0.30 457)		(294  0.30 457)		(311  0.30 457)		(349  0.30 457)		(294  0.30 457)		(311  0.30 457)		(415  0.30 457)		(392  0.30 457)		(349  0.30 457)		(392  0.30 457)		(311  0.30 457)		(294  0.30 457)		(262  0.30 457)		(294  0.30 457)		(466  0.30 457)		(415  0.30 457)		(392  0.30 457)		(415  0.30 457)		(349  0.30 457)		(311  0.30 457)		(294  0.30 457)		(311  0.30 457)		(rest 1.2)		(262  0.30 457)		(233  0.30 457)		(220  0.30 457)		(rest 0.3)		(311  0.30 457)		(294  0.30 457)		(262  0.30 457)		(294  0.30 457)		(262  0.15 457)		(233  0.15 457)		(262  0.30 457)		(294  0.30 457)		(196  0.30 591)		(466  0.15 591)		(440  0.15 591)		(466  0.30 591)		(294  0.30 591)		(311  0.30 591)		(523  0.15 591)		(466  0.15 591)		(523  0.30 591)		(330  0.30 591)		(349  0.30 591)		(587  0.15 591)		(523  0.15 591)		(587  0.30 591)		(370  0.30 591)		(392  0.60 591)		(rest 0.15)		(196  0.15 591)		(220  0.15 591)		(247  0.15 591)		(262  0.15 591)		(294  0.15 591)		(311  0.45 591)		(220  0.15 591)		(233  0.15 591)		(262  0.15 591)		(294  0.15 591)		(311  0.15 591)		(349  0.45 591)		(247  0.15 591)		(262  0.15 591)		(294  0.15 591)		(311  0.30 591)		(rest 0.6)		(330  0.30 591)		(349  0.30 591)		(175  0.30 591)		(156  0.30 591)		(147  0.30 591)		(rest 0.3)		(208  0.30 591)		(196  0.30 591)		(175  0.30 591)		(196  0.30 591)		(175  0.15 591)		(156  0.15 591)		(175  0.30 591)		(196  0.30 591)		(262  0.15 591)		(294  0.15 591)		(311  0.15 591)		(294  0.15 591)		(262  0.15 591)		(233  0.15 591)		(208  0.15 591)		(196  0.15 591)		(175  0.15 591)		(466  0.15 591)		(415  0.15 591)		(392  0.15 591)		(349  0.15 591)		(311  0.15 591)		(294  0.15 591)		(262  0.15 591)		(233  0.15 591)		(262  0.15 591)		(294  0.15 591)		(262  0.15 591)		(233  0.15 591)		(208  0.15 591)		(196  0.15 591)		(175  0.15 591)		(156  0.15 591)		(415  0.15 591)		(392  0.15 591)		(349  0.15 591)		(311  0.15 591)		(294  0.15 591)		(262  0.15 591)		(233  0.15 591)		(208  0.15 591)		(233  0.15 591)		(262  0.15 591)		(233  0.15 591)		(208  0.15 591)		(196  0.15 591)		(175  0.15 591)		(156  0.15 591)		(147  0.15 591)		(392  0.15 591)		(349  0.15 591)		(311  0.15 591)		(294  0.15 591)		(262  0.15 591)		(247  0.15 591)		(220  0.15 591)		(196  0.60 772)		(196  0.60 772)		(rest 0.15)		(196  0.15 772)		(220  0.15 772)		(247  0.15 772)		(262  0.15 772)		(294  0.15 772)		(311  0.15 772)		(349  0.15 772)		(392  0.15 772)		(349  0.15 772)		(415  0.15 772)		(392  0.15 772)		(349  0.15 772)		(311  0.15 772)		(294  0.15 772)		(262  0.15 772)		(247  0.30 772)		(262  0.15 772)		(494  0.15 772)		(262  0.30 772)		(196  0.30 772)		(208  0.30 772)		(262  0.15 772)		(247  0.15 772)		(262  0.30 772)		(294  0.30 772)		(196  0.30 772)		(262  0.15 772)		(247  0.15 772)		(262  0.30 772)		(294  0.30 772)		(175  0.15 772)		(196  0.15 772)		(208  0.60 772)		(196  0.15 772)		(175  0.15 772)		(156  0.60 772)		(rest 0.3)		(311  0.30 772)		(294  0.30 772)		(262  0.30 772)		(392  0.30 772)		(196  0.30 772)		(262  3.60 268)		(494  0.40 268)		(rest 0.4)		(494  0.40 268)		(rest 0.4)		(392  1.60 268)).! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 12/17/97 16:52'!bachFugueVoice4On: aSound	"Voice four of a fugue by J. S. Bach."	^ self noteSequenceOn: aSound from: #(		(rest 61.2)		(131  0.15 500)		(123  0.15 500)		(131  0.30 500)		(98   0.30 500)		(104  0.30 500)		(131  0.15 500)		(123  0.15 500)		(131  0.30 500)		(147  0.30 500)		(98   0.30 500)		(131  0.15 500)		(123  0.15 500)		(131  0.30 500)		(147  0.30 500)		(87   0.15 500)		(98   0.15 500)		(104  0.60 500)		(98   0.15 500)		(87   0.15 500)		(78   0.60 500)		(rest 0.3)		(156  0.30 500)		(147  0.30 500)		(131  0.30 500)		(196  0.30 500)		(98   0.30 500)		(131  3.60 268)		(131  3.20 205)).! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 1/5/98 17:45'!stereoBachFugue	"Play fugue by J. S. Bach in stereo using different timbres."	"AbstractSound stereoBachFugue play"	"(AbstractSound bachFugueVoice1On: FMSound flute1) play"	"(AbstractSound bachFugueVoice1On: PluckedSound default) play"	^ MixedSound new		add: (self bachFugueVoice1On: FMSound oboe1) pan: 0.2;		add: (self bachFugueVoice2On: FMSound organ1) pan: 0.8;		add: (self bachFugueVoice3On: PluckedSound default) pan: 0.4;		add: (self bachFugueVoice4On: FMSound brass1) pan: 0.6.! !!AbstractSound class methodsFor: 'primitive generation' stamp: 'jm 1/5/98 16:14'!cCodeForSoundPrimitives	"Return a string containing the C code for the sound primitives. This string is pasted into a file, compiled, and linked into the virtual machine. Note that the virtual machine's primitive table must also be edited to make new primitives available."	"AbstractSound cCodeForSoundPrimitives"	^ CCodeGenerator new codeStringForPrimitives: #(		(FMSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(PluckedSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(SampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)	).! !!Arc methodsFor: 'display box access'!computeBoundingBox	| aRectangle aPoint |	aRectangle _ center - radius + form offset extent: form extent + (radius * 2) asPoint.	aPoint _ center + form extent.	quadrant = 1 ifTrue: [^ aRectangle encompass: center x @ aPoint y].	quadrant = 2 ifTrue: [^ aRectangle encompass: aPoint x @ aPoint y].	quadrant = 3 ifTrue: [^ aRectangle encompass: aPoint x @ center y].	quadrant = 4 ifTrue: [^ aRectangle encompass: center x @ center y]! !!Array methodsFor: 'printing' stamp: 'di 6/20/97 09:09'!printOn: aStream	aStream nextPut: $(.	self do: [:element | element printOn: aStream. aStream space].	aStream nextPut: $)! !!Array methodsFor: 'private' stamp: 'di 8/15/97 09:55'!hasLiteralSuchThat: litBlock	"Answer true if litBlock returns true for any literal in this array, even if imbedded in further array structure.  This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"	| lit |	1 to: self size do:		[:index | lit _ self at: index.		(litBlock value: lit) ifTrue: [^ true].		(lit class == Array and: [lit hasLiteralSuchThat: litBlock]) ifTrue: [^ true]].	^false! !!Array2D methodsFor: 'access'!atCol: i put: list    "Put in a whole column.     hold first index constant"    list size = self height ifFalse: [self error: 'wrong size'].    list doWithIndex: [:value :j |        self at: i at: j put: value].! !!Array2D methodsFor: 'access'!atRow: j put: list    "Put in a whole row.     hold second index constant"    list size = self width ifFalse: [self error: 'wrong size'].    list doWithIndex: [:value :i |        self at: i at: j put: value].! !!AssignmentNode methodsFor: 'C translation'!asTranslatorNode	^TAssignmentNode new		setVariable: variable asTranslatorNode		expression: value asTranslatorNode! !!AtomMorph methodsFor: 'all'!bounceIn: aRect	| p vx vy px py |	p _ self position.	vx _ velocity x.  vy _ velocity y.	px _ p x + vx.  py _ p y + vy.	px > aRect right ifTrue: [		px _ aRect right - (px - aRect right).		vx _ velocity x negated.	].	py > aRect bottom ifTrue: [		py _  aRect bottom - (py - aRect bottom).		vy _ velocity y negated.	].	px < aRect left ifTrue: [		px _ aRect left - (px - aRect left).		vx _ velocity x negated.	].	py < aRect top ifTrue: [		py _  aRect top - (py - aRect top).		vy _ velocity y negated.	].	self position: px @ py.	self velocity: vx @ vy.! !!AtomMorph methodsFor: 'all'!drawOn: aCanvas	"Note: Set 'drawAsRect' to true to make the atoms draw faster. When testing the speed of other aspects of Morphic, such as its damage handling efficiency for large numbers of atoms, it is useful to make drawing faster."	| drawAsRect |	drawAsRect _ false.  "rectangles are faster to draw"	drawAsRect		ifTrue: [aCanvas fillRectangle: self bounds color: color]		ifFalse: [super drawOn: aCanvas].! !!AtomMorph methodsFor: 'all'!infected	^ color = Color red! !!AtomMorph methodsFor: 'all'!infected: aBoolean	aBoolean		ifTrue: [self color: Color red]		ifFalse: [self color: Color blue].! !!AtomMorph methodsFor: 'all'!initialize	"Make a new atom with a random position and velocity."	super initialize.	self extent: 8@7.	self color: Color blue.	self borderWidth: 0.	self randomPositionIn: (0@0 corner: 300@300) maxVelocity: 10.! !!AtomMorph methodsFor: 'all'!randomPositionIn: aRectangle maxVelocity: maxVelocity	"Give this atom a random position and velocity."	| origin extent |	origin _ aRectangle origin.	extent _ aRectangle extent - self bounds extent.	self position:		(origin x + extent x atRandom) @		(origin y + extent y atRandom).	velocity _		(maxVelocity - (2 * maxVelocity) atRandom) @		(maxVelocity - (2 * maxVelocity) atRandom).! !!AtomMorph methodsFor: 'all'!velocity	^ velocity! !!AtomMorph methodsFor: 'all'!velocity: newVelocity	velocity _ newVelocity.! !!AtomMorph class methodsFor: 'all' stamp: 'di 6/22/97 09:07'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !An EmbeddedServerAction that also has an Authorizer to verify username and password.!!AuthorizedServerAction methodsFor: 'URL processing' stamp: 'mjg 11/17/97 11:20'!authorizer	^authorizer! !!AuthorizedServerAction methodsFor: 'URL processing' stamp: 'mjg 11/17/97 11:20'!authorizer: anAuthorizer	authorizer _ anAuthorizer! !!AuthorizedServerAction methodsFor: 'URL processing' stamp: 'mjg 11/17/97 13:09'!checkAuthorization: request	^authorizer user: request userID.! !The Authorizer does user authorization checking. Each instance of authorizer keeps track of the realm that it is authorizing for and the users table of authorized users. An authorizer can be asked to return the user name/symbol associated with a userID (which concatenates the username and password from the HTTP request) with the user: method.!!Authorizer methodsFor: 'realms' stamp: 'mjg 11/3/97 12:33'!realm	^realm! !!Authorizer methodsFor: 'realms' stamp: 'mjg 11/3/97 12:33'!realm: aString	realm := aString! !!Authorizer methodsFor: 'authentication' stamp: 'mjg 11/3/97 13:01'!encode: nameString password: pwdString	"Encode per RFC1421 of the username:password combination."	| clear code clearSize idx map |	clear := (nameString, ':', pwdString) asByteArray.	clearSize := clear size.	[ clear size \\ 3 ~= 0 ] whileTrue: [ clear := clear, #(0) ].	idx := 1.	map := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.	code := WriteStream on: ''.	[ idx < clear size ] whileTrue: [ code 		nextPut: (map at: (clear at: idx) // 4 + 1);		nextPut: (map at: (clear at: idx) \\ 4 * 16 + ((clear at: idx + 1) // 16) + 1);   		nextPut: (map at: (clear at: idx + 1) \\ 16 * 4 + ((clear at: idx + 2) // 64) + 1);   		nextPut: (map at: (clear at: idx + 2) \\ 64 + 1).		idx := idx + 3 ].	code := code contents.	idx := code size.	clear size - clearSize timesRepeat: [ code at: idx put: $=. idx := idx - 1].	^code! !!Authorizer methodsFor: 'authentication' stamp: 'mjg 11/3/97 12:31'!mapFrom: aKey to: aPerson	"Establish a mapping from a RFC 1421 key to a user."	users isNil ifTrue: [ users := Dictionary new ].	aPerson	 isNil ifTrue: [ users removeKey: aKey ]	 ifFalse: [		users removeKey: (users keyAtValue: aPerson ifAbsent: []) ifAbsent: [].		users at: aKey put: aPerson ]! !!Authorizer methodsFor: 'authentication' stamp: 'mjg 11/3/97 13:02'!mapName: nameString password: pwdString to: aPerson	"Insert/remove the encoding per RFC1421 of the username:password combination 	 into/from the UserMap."	self mapFrom: (self encode: nameString password: pwdString) to: aPerson! !!Authorizer methodsFor: 'authentication' stamp: 'mjg 11/17/97 13:07'!user: userId	"Return the requesting user."	^users at: userId ifAbsent: [ self error: (PWS unauthorizedFor: realm) ]! !BackgroundMorph comment:'This morph incorporates tiling and regular motion with the intent of supporting, eg, panning of endless (toroidal) backgrounds.The idea is that embedded morphs get displayed at a moving offset relative to my position.  Moreover this display is tiled according to the bounding box of the submorphs (subBounds), as much as necesary to fill the rest of my bounds.'!!BackgroundMorph methodsFor: 'all' stamp: 'di 11/4/97 09:01'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	running		ifTrue: [aCustomMenu add: 'stop' action: #stopRunning]		ifFalse: [aCustomMenu add: 'start' action: #startRunning].! !!BackgroundMorph methodsFor: 'all'!drawOn: aCanvas	"The tiling is solely determined by bounds, subBounds and offset.	The extent of display is determined by bounds and the clipRect of the canvas."	| start tileCanvas d subBnds |	submorphs isEmpty ifTrue: [^ super drawOn: aCanvas].	subBnds _ self subBounds.	running ifFalse:		[super drawOn: aCanvas.		^ aCanvas fillRectangle: subBnds color: Color lightBlue].	start _ subBnds topLeft + offset - bounds topLeft - (1@1) \\ subBnds extent - subBnds extent + (1@1).	d _ subBnds topLeft - bounds topLeft."Sensor redButtonPressed ifTrue: [self halt]."	start x to: bounds width - 1 by: subBnds width do:		[:x |		start y to: bounds height - 1 by: subBnds height do:			[:y | tileCanvas _ aCanvas copyOffset: (x@y) - d clipRect: bounds.			submorphs reverseDo: [:m | m fullDrawOn: tileCanvas]]]! !!BackgroundMorph methodsFor: 'all'!fullBounds	^ self bounds! !!BackgroundMorph methodsFor: 'all'!fullDrawOn: aCanvas	running ifFalse: [^ super fullDrawOn: (aCanvas copyClipRect: (bounds translateBy: aCanvas origin))].	(aCanvas isVisible: bounds) ifTrue: [self drawOn: aCanvas].! !!BackgroundMorph methodsFor: 'all'!initialize	super initialize.	offset _ 0@0.	delta _ 1@0.	running _ true! !!BackgroundMorph methodsFor: 'all'!layoutChanged	"Do nothing, since I clip my submorphs"! !!BackgroundMorph methodsFor: 'all'!rootForGrabOf: aMorph	"Be sticky."	^ nil! !!BackgroundMorph methodsFor: 'all'!slideBy: inc	submorphs isEmpty ifTrue: [^ self].	offset _ offset + inc \\ self subBounds extent.	self changed! !!BackgroundMorph methodsFor: 'all'!startRunning	running _ true.	self changed! !!BackgroundMorph methodsFor: 'all'!step	"Answer the desired time between steps in milliseconds."	running ifTrue: [self slideBy: delta]! !!BackgroundMorph methodsFor: 'all'!stepTime	"Answer the desired time between steps in milliseconds."	^ 20! !!BackgroundMorph methodsFor: 'all'!stopRunning	running _ false.	self changed! !!BackgroundMorph methodsFor: 'all'!subBounds	"calculate the submorph bounds"	| subBounds |	subBounds _ nil.	self submorphsDo:		[:m | subBounds == nil			ifTrue: [subBounds _ m fullBounds]			ifFalse: [subBounds _ subBounds merge: m fullBounds]].	^ subBounds! !!BackgroundMorph class methodsFor: 'all'!test	^ self new image: Form fromUser! !!Bag methodsFor: 'accessing' stamp: 'di 9/11/97 16:14'!cumulativeCounts	"Answer with a collection of cumulative percents covered by elements so far."	| s n |	s _ self size // 100.0. n _ 0.	^ self sortedCounts asArray collect:		[:a | n _ n + a key. (n // s roundTo: 0.1) -> a value]! !!Bag methodsFor: 'enumerating' stamp: 'SqR 11/4/97 19:58'!asSet	"Answer a set with the elements of the receiver"	 ^contents keys! !BalloonMorph comment:'A balloon with text used for the display of explanatory information.Balloon help is integrated into Morphic as follows:If a Morph has the property #balloonText, then it will respond to #showBalloon by adding a text balloon to the world, and to #deleteBalloon by removing the balloon.Moreover, if mouseOverEnabled is true (see class msg), then the Hand will arrange to cause display of the balloon after the mouse has lingered over the morph for a while, and removal of the balloon when the mouse leaves the bounds of that morph.  In any case, the Hand will attempt to remove any such balloons before handling mouseDown events, or displaying other balloons.'!!BalloonMorph methodsFor: 'all' stamp: 'di 9/17/97 19:26'!setTarget: aMorph	target _ aMorph.	offsetFromTarget _ self position - target position! !!BalloonMorph methodsFor: 'all' stamp: 'di 9/17/97 19:27'!step	self position: target position + offsetFromTarget! !!BalloonMorph methodsFor: 'all' stamp: 'di 9/18/97 10:10'!stepTime	^ 0  "every cycle"! !!BalloonMorph class methodsFor: 'all' stamp: 'di 10/20/97 20:10'!chooseBalloonFont	| sizes reply |	sizes _ #(9 10 12 14).	reply _ (SelectionMenu labelList: (sizes collect: [:s | s printString]) selections:  sizes) startUp.	reply ifNotNil:		[BalloonFont _ (TextStyle named: #ComicPlain) fontAt: (sizes indexOf: reply)]! !!BalloonMorph class methodsFor: 'all' stamp: 'di 9/18/97 09:44'!initialize	self mouseOverEnabled: true! !!BalloonMorph class methodsFor: 'all' stamp: 'di 9/18/97 09:42'!mouseOverEnabled	^ MouseOverEnabled! !!BalloonMorph class methodsFor: 'all' stamp: 'di 9/18/97 09:44'!mouseOverEnabled: trueOrFalse	"BalloonMorph mouseOverEnabled: false  --  eg, to turn off mouseOver"	MouseOverEnabled _ trueOrFalse! !!BalloonMorph class methodsFor: 'all' stamp: 'jm 9/22/97 11:54'!removeCurrentBalloon	"Make the current help balloon, if any, disappear."	CurrentBalloon ifNotNil: [		CurrentBalloon delete.		CurrentBalloon _ nil].! !!BalloonMorph class methodsFor: 'all' stamp: 'sw 10/13/97 17:18'!string: str for: morph corner: cornerName	"Make up and return a balloon for morph.  Find the quadrant thatclips the text the least, using cornerName as a tie-breaker.  tk 9/12/97"	| tm corners p1 p2 vertices c r maxArea aa verts mp dir mbc pref |		tm _ (TextMorph new contents: (self textContentsForString: str)) centered.	corners _ tm bounds corners atAll: #(1 4 3 2).	p1 _ (corners at: 1) + ((0 - tm width//3)@0).	p2 _ (corners at: 1) + ((0 - tm width//6)@(tm height//2)).	vertices _ (Array with: p1 with: p2) , corners.	r _ p1 rect: (corners at: 3).	corners _ #(bottomRight bottomLeft topLeft topRight).	pref _ (corners indexOf: cornerName)-4.	c _ tm center.	maxArea _ 0.	(1 to: 4) do:		[:i | "Try four rel locations of the balloon for greatest unclipped area"		aa _ ((r align: (r perform: (corners atWrap: i+pref+2))			with: (mbc _ morph bounds perform: (corners atWrap: i+pref)))			intersect: (0@0 extent: morph world viewBox extent)) area.		aa >= maxArea ifTrue: [verts _ vertices.							maxArea _ aa.							mp _ mbc].		dir _ i odd ifTrue: [#horizontal] ifFalse: [#vertical].		vertices _ vertices collect: [:p | p flipBy: dir centerAt: c]].	self removeCurrentBalloon.	^ CurrentBalloon _ self new color: (Color r: 1.0 g: 1.0 b: 0.6);			setBorderWidth: 1 borderColor: Color black;			setVertices: verts;			addMorph: tm;			align: verts first with: mp;			setTarget: morph! !!BalloonMorph class methodsFor: 'all' stamp: 'sw 10/13/97 17:43'!textContentsForString: str	BalloonFont ifNotNil: [^ Text string: str attribute: (TextFontReference toFont: BalloonFont)].	^ str! !!Bark methodsFor: 'as yet unclassified' stamp: 'jm 10/9/97 04:55'!initialize	super initialize.	sound _ SampledSound		samples: #(-29 -28 -17 -40 -33 -23 -23 -36 -24 -39 -32 -49 -47 -65 -61 -64 -82 -94 -94 -103 -102 -101 -110 -125 -107 -110 -110 -114 -119 -112 -106 -111 -98 -104 -102 -103 -91 -85 -95 -111 -119 -128 -126 -128 -139 -150 -134 -143 -132 -149 -129 -136 -142 -134 -117 -129 -112 -121 -102 -98 -68 -71 -61 -54 -44 -29 -14 -13 -10 -10 -27 -48 -47 -57 -55 -58 -57 -51 -30 -37 -16 -10 -9 -10 -10 -18 -18 -20 -10 -8 -5 0 8 14 21 17 4 -10 -9 -21 -29 -24 -20 -34 -15 -3 17 21 38 34 61 61 59 64 71 69 78 85 85 84 102 103 135 115 121 114 114 98 81 73 72 65 69 66 88 92 98 108 122 121 125 115 92 70 55 52 46 30 32 22 25 35 30 13 6 -17 -35 -60 -75 -108 -110 -112 -86 -102 -76 -51 -39 -35 -33 -40 -50 -80 -98 -115 -132 -160 -186 -174 -180 -185 -170 -191 -193 -228 -241 -258 -279 -310 -320 -341 -344 -349 -351 -345 -337 -339 -346 -374 -377 -386 -395 -406 -405 -435 -423 -424 -417 -406 -380 -357 -327 -320 -294 -296 -291 -303 -309 -306 -296 -299 -292 -276 -252 -244 -225 -208 -194 -194 -197 -189 -190 -210 -202 -196 -181 -176 -143 -124 -118 -114 -89 -91 -84 -85 -59 -30 0 47 105 162 235 304 366 413 491 530 579 638 717 804 912 1022 1162 1281 1400 1518 1612 1669 1716 1723 1724 1683 1662 1646 1635 1645 1683 1746 1831 1877 1926 1912 1843 1690 1498 1241 957 647 343 95 -110 -269 -384 -455 -493 -561 -640 -743 -860 -1049 -1229 -1425 -1604 -1768 -1904 -1958 -1972 -1928 -1833 -1693 -1527 -1388 -1250 -1163 -1095 -1085 -1122 -1170 -1216 -1251 -1247 -1212 -1108 -989 -831 -698 -548 -465 -423 -429 -463 -532 -610 -688 -739 -757 -736 -684 -611 -538 -454 -414 -401 -424 -485 -579 -673 -804 -920 -1005 -1037 -1039 -981 -869 -708 -552 -375 -223 -88 18 132 200 276 340 453 582 754 944 1158 1366 1577 1761 1920 2027 2085 2094 2087 2031 1979 1914 1852 1802 1785 1754 1741 1710 1646 1549 1426 1257 1079 863 649 420 211 17 -138 -282 -380 -471 -547 -627 -695 -788 -870 -988 -1095 -1205 -1315 -1407 -1461 -1469 -1457 -1414 -1338 -1245 -1123 -1009 -922 -836 -776 -739 -699 -694 -677 -648 -615 -582 -524 -486 -442 -426 -408 -394 -413 -463 -518 -585 -670 -768 -844 -932 -972 -999 -1007 -998 -964 -933 -874 -841 -778 -729 -673 -603 -515 -434 -309 -184 -56 91 256 405 572 693 838 936 1044 1142 1249 1344 1468 1589 1728 1863 1987 2089 2183 2245 2306 2308 2293 2235 2165 2044 1920 1773 1624 1473 1315 1145 1008 845 681 497 322 137 -47 -233 -405 -559 -678 -777 -817 -874 -881 -874 -830 -822 -780 -739 -696 -662 -640 -612 -574 -562 -519 -483 -472 -476 -468 -484 -512 -569 -608 -661 -708 -742 -767 -787 -800 -828 -865 -935 -967 -1062 -1161 -1242 -1350 -1419 -1462 -1501 -1499 -1499 -1488 -1444 -1390 -1344 -1272 -1217 -1131 -1046 -947 -843 -691 -543 -360 -172 40 276 516 763 1006 1209 1407 1585 1708 1810 1908 1976 2047 2099 2155 2206 2224 2205 2155 2051 1875 1617 1339 1012 701 381 126 -98 -250 -390 -468 -524 -552 -586 -620 -671 -713 -794 -881 -974 -1063 -1147 -1168 -1148 -1059 -922 -717 -468 -208 26 236 360 424 399 315 206 81 -42 -100 -149 -136 -97 -37 3 56 58 20 -60 -155 -310 -456 -629 -787 -947 -1049 -1124 -1163 -1158 -1102 -1029 -944 -864 -788 -737 -699 -690 -676 -650 -590 -519 -394 -248 -55 148 394 636 889 1102 1325 1498 1625 1666 1673 1630 1572 1480 1388 1315 1271 1241 1222 1208 1185 1121 1042 914 780 575 354 140 -68 -299 -487 -640 -737 -818 -822 -800 -733 -667 -583 -521 -465 -452 -447 -436 -406 -394 -357 -282 -203 -110 -15 66 153 211 250 265 271 214 136 44 -73 -188 -290 -393 -460 -504 -530 -536 -521 -518 -541 -592 -637 -719 -818 -920 -1007 -1080 -1114 -1116 -1066 -995 -888 -803 -710 -630 -569 -538 -543 -572 -609 -653 -678 -705 -677 -623 -510 -366 -163 47 286 470 640 768 845 865 871 859 857 859 887 947 1053 1150 1269 1387 1480 1563 1652 1721 1785 1819 1847 1828 1785 1683 1539 1400 1231 1074 916 751 600 432 237 6 -246 -525 -794 -1083 -1329 -1586 -1782 -1944 -2072 -2167 -2201 -2184 -2130 -2016 -1823 -1616 -1359 -1119 -869 -674 -492 -364 -238 -112 4 112 261 402 575 706 813 861 887 869 825 739 649 538 465 388 365 390 483 608 763 888 1011 1054 1024 912 706 436 167 -114 -329 -507 -576 -573 -475 -320 -110 117 353 540 714 827 909 923 903 863 869 901 1014 1178 1405 1640 1844 1975 2016 1934 1738 1402 991 544 111 -288 -615 -888 -1083 -1227 -1329 -1414 -1508 -1598 -1686 -1795 -1886 -2007 -2083 -2156 -2182 -2150 -2051 -1884 -1640 -1343 -1025 -728 -451 -235 -78 -6 25 15 -14 -29 -10 18 89 168 231 258 248 182 92 -64 -231 -440 -654 -875 -1059 -1234 -1370 -1471 -1489 -1470 -1407 -1333 -1233 -1138 -1039 -960 -868 -777 -657 -502 -299 -64 232 555 872 1168 1455 1669 1889 2082 2273 2467 2692 2892 3123 3367 3609 3839 4069 4215 4332 4355 4326 4213 4065 3868 3653 3402 3138 2871 2567 2184 1753 1260 710 88 -539 -1162 -1738 -2252 -2684 -3032 -3246 -3377 -3417 -3349 -3218 -3020 -2746 -2429 -2103 -1791 -1474 -1168 -852 -572 -289 -1 284 553 817 1023 1151 1135 984 681 212 -383 -1091 -1847 -2608 -3332 -3944 -4437 -4734 -4859 -4839 -4661 -4360 -3972 -3530 -3071 -2566 -2077 -1595 -1097 -576 -74 453 985 1540 2075 2619 3108 3538 3885 4079 4126 3982 3670 3230 2669 2028 1349 665 15 -574 -1123 -1628 -2095 -2517 -2919 -3277 -3604 -3915 -4184 -4389 -4578 -4677 -4734 -4694 -4580 -4340 -4015 -3573 -3071 -2522 -1912 -1289 -672 -85 439 960 1424 1860 2278 2701 3102 3520 3939 4337 4698 5016 5249 5394 5448 5394 5204 4918 4557 4172 3740 3316 2914 2538 2167 1809 1429 1048 638 270 -88 -385 -663 -879 -1059 -1166 -1212 -1190 -1118 -958 -719 -393 -10 434 878 1300 1633 1923 2129 2314 2420 2508 2531 2545 2510 2442 2315 2161 1974 1770 1536 1319 1085 858 605 361 119 -89 -256 -378 -473 -522 -578 -616 -629 -638 -671 -672 -688 -662 -645 -592 -522 -407 -258 -119 7 148 298 429 515 576 590 545 425 276 132 -2 -140 -299 -536 -841 -1277 -1802 -2412 -3042 -3653 -4254 -4755 -5133 -5420 -5612 -5755 -5800 -5773 -5683 -5495 -5257 -5008 -4707 -4403 -4084 -3765 -3464 -3182 -2910 -2583 -2186 -1775 -1351 -960 -646 -442 -328 -325 -395 -510 -635 -733 -763 -745 -620 -453 -250 -43 220 490 786 1046 1260 1386 1445 1413 1345 1257 1166 1054 961 892 838 742 630 459 249 6 -230 -473 -655 -797 -835 -791 -604 -382 -58 316 695 1040 1368 1604 1802 1915 2003 2068 2130 2191 2284 2413 2537 2640 2756 2853 2938 2999 3046 3093 3207 3371 3605 3931 4379 4907 5587 6342 7183 8050 8881 9476 9789 9641 8966 7757 6124 4236 2341 619 -766 -1765 -2419 -2869 -3219 -3590 -4029 -4568 -5159 -5847 -6536 -7258 -7926 -8431 -8666 -8632 -8238 -7509 -6359 -4876 -3092 -1181 693 2208 3224 3597 3335 2562 1462 183 -1025 -2060 -2821 -3339 -3656 -3909 -4171 -4563 -5070 -5725 -6444 -7134 -7734 -8172 -8394 -8393 -8079 -7482 -6601 -5544 -4344 -3097 -1916 -925 -152 310 499 463 316 173 149 293 650 1184 1845 2532 3168 3656 3977 4029 3904 3619 3233 2801 2359 1955 1676 1538 1567 1764 2053 2345 2552 2568 2347 1826 1093 162 -845 -1836 -2695 -3295 -3633 -3694 -3474 -3071 -2539 -1934 -1326 -712 -119 449 986 1471 1918 2304 2670 2995 3312 3605 3879 4096 4261 4334 4275 4028 3632 3066 2440 1752 1058 403 -110 -523 -816 -1031 -1165 -1289 -1397 -1478 -1497 -1404 -1217 -923 -519 -24 558 1180 1846 2579 3382 4267 5176 6133 7143 8126 9058 9862 10519 10880 10874 10404 9404 7840 5844 3498 1058 -1330 -3407 -5132 -6444 -7315 -7878 -8273 -8553 -8789 -9010 -9238 -9505 -9756 -9948 -10019 -9870 -9483 -8779 -7769 -6386 -4746 -2791 -718 1294 2944 4118 4665 4602 3994 3015 1822 562 -615 -1632 -2358 -2852 -3191 -3415 -3647 -3880 -4134 -4384 -4637 -4829 -4975 -5025 -4934 -4644 -4108 -3361 -2453 -1438 -403 569 1409 1993 2267 2245 1962 1523 978 479 85 -190 -287 -188 61 421 773 1110 1366 1490 1466 1305 1028 680 296 -37 -231 -252 -175 -29 84 142 71 -184 -678 -1335 -2089 -2884 -3617 -4200 -4559 -4702 -4662 -4474 -4181 -3743 -3227 -2661 -2027 -1297 -471 367 1216 2067 2903 3683 4354 4980 5592 6154 6628 7020 7321 7511 7478 7270 6900 6437 5957 5497 5186 5140 5353 5803 6361 7053 7763 8388 8783 8905 8710 8145 7156 5844 4263 2478 579 -1293 -2984 -4298 -5164 -5531 -5459 -5033 -4429 -3760 -3234 -2854 -2752 -2867 -3160 -3480 -3700 -3689 -3412 -2818 -1959 -872 306 1471 2491 3264 3689 3695 3228 2368 1113 -451 -2204 -4004 -5718 -7214 -8458 -9378 -9976 -10276 -10319 -10121 -9775 -9322 -8780 -8122 -7350 -6418 -5354 -4153 -2906 -1617 -354 871 1952 2853 3564 4051 4259 4247 4028 3629 3117 2577 2020 1577 1215 937 713 495 241 -51 -375 -713 -1029 -1288 -1461 -1492 -1413 -1215 -926 -556 -197 162 517 835 1061 1172 1124 954 638 269 -115 -468 -722 -869 -895 -763 -562 -270 38 364 656 926 1133 1287 1437 1601 1783 1948 2045 2073 1974 1734 1379 935 418 -141 -742 -1288 -1797 -2235 -2600 -2846 -3009 -3125 -3202 -3220 -3164 -2998 -2783 -2423 -1925 -1289 -541 277 1134 1987 2793 3520 4188 4757 5228 5640 6007 6347 6711 7134 7654 8328 9186 10231 11329 12322 12926 12893 12039 10301 7805 4923 2011 -620 -2719 -4268 -5350 -6113 -6648 -6987 -7132 -6989 -6702 -6406 -6220 -6264 -6562 -7039 -7630 -8196 -8586 -8612 -8092 -6849 -4954 -2605 -208 1833 3213 3856 3749 3043 1842 306 -1417 -3134 -4751 -6090 -7136 -7901 -8462 -8787 -8917 -8834 -8594 -8261 -7945 -7693 -7451 -7122 -6632 -5899 -4918 -3690 -2298 -774 744 2093 3162 3874 4181 4155 3816 3308 2715 2081 1501 1106 916 977 1207 1526 1853 2117 2241 2204 1981 1585 1042 380 -304 -886 -1341 -1602 -1718 -1707 -1619 -1467 -1369 -1311 -1387 -1529 -1717 -1959 -2184 -2344 -2426 -2410 -2307 -2072 -1724 -1235 -678 -84 538 1172 1812 2463 3046 3610 4050 4369 4516 4550 4455 4286 4058 3834 3612 3331 3006 2648 2235 1809 1369 973 647 438 424 669 1168 1894 2814 3942 5169 6455 7809 9283 10772 12186 13519 14782 15809 16383 16342 15651 14285 12390 10066 7568 5097 2845 829 -955 -2491 -3825 -5112 -6335 -7500 -8479 -9261 -9872 -10462 -10992 -11447 -11787 -11925 -11789 -11305 -10422 -9144 -7456 -5504 -3486 -1705 -347 449 708 507 -17 -683 -1367 -2003 -2482 -2814 -2995 -3044 -3003 -2916 -2791 -2631 -2406 -2198 -2045 -1996 -2046 -2122 -2167 -2160 -2036 -1820 -1519 -1166 -785 -496 -368 -472 -824 -1400 -2070 -2797 -3496 -4137 -4566 -4734 -4600 -4103 -3310 -2341 -1254 -157 906 1847 2580 3036 3217 3182 3035 2817 2657 2595 2636 2697 2764 2787 2761 2616 2321 1958 1529 1048 508 -92 -698 -1260 -1756 -2092 -2257 -2254 -2050 -1703 -1240 -691 -71 492 1031 1472 1797 2017 2153 2194 2194 2114 2031 1954 1928 1927 1904 1852 1766 1646 1503 1332 1145 999 905 852 887 970 1145 1390 1690 2018 2446 2901 3379 3860 4338 4787 5214 5612 5945 6205 6390 6454 6410 6198 5752 5100 4259 3270 2307 1418 637 -66 -722 -1364 -1932 -2451 -2884 -3277 -3661 -4114 -4574 -4988 -5308 -5557 -5726 -5803 -5795 -5733 -5527 -5218 -4794 -4304 -3813 -3393 -3138 -3052 -3131 -3389 -3758 -4212 -4685 -5112 -5449 -5705 -5917 -6096 -6252 -6344 -6310 -6178 -5931 -5578 -5106 -4556 -3939 -3308 -2686 -2123 -1632 -1192 -795 -456 -215 -110 -88 -144 -265 -468 -682 -955 -1219 -1440 -1597 -1693 -1727 -1731 -1686 -1599 -1444 -1246 -1017 -752 -454 -117 251 638 1015 1388 1748 2063 2351 2559 2699 2760 2722 2576 2353 2049 1755 1485 1271 1053 881 763 743 797 934 1179 1550 2026 2654 3343 4116 4869 5578 6207 6747 7195 7600 7941 8288 8654 8993 9319 9624 10037 10483 10915 11242 11340 11053 10265 8977 7307 5442 3521 1722 92 -1271 -2341 -3131 -3660 -3932 -3957 -3782 -3537 -3278 -3082 -2921 -2880 -3057 -3424 -3874 -4240 -4437 -4358 -3891 -3119 -2117 -1110 -219 395 705 654 292 -351 -1153 -2047 -2947 -3838 -4675 -5418 -6064 -6574 -6915 -7057 -7029 -6890 -6677 -6444 -6164 -5895 -5609 -5265 -4842 -4299 -3631 -2934 -2179 -1502 -967 -630 -490 -552 -744 -1113 -1561 -2052 -2529 -2929 -3227 -3400 -3423 -3298 -3046 -2704 -2300 -1900 -1538 -1265 -1037 -847 -630 -353 25 480 986 1462 1910 2256 2546 2729 2834 2867 2885 2903 2875 2772 2572 2271 1913 1545 1189 920 744 674 731 935 1335 1881 2637 3533 4576 5698 6801 7819 8651 9222 9583 9705 9548 9163 8594 7866 7018 6038 4998 3986 2981 2036 1153 386 -218 -753 -1196 -1550 -1823 -2037 -2149 -2201 -2160 -2037 -1865 -1653 -1363 -1049 -720 -434 -160 111 411 698 949 1100 1158 1073 850 514 95 -425 -1038 -1705 -2389 -3063 -3704 -4323 -4870 -5339 -5683 -5942 -6053 -6082 -6079 -6097 -6111 -6169 -6195 -6226 -6250 -6263 -6208 -6093 -5887 -5585 -5145 -4662 -4130 -3601 -3075 -2613 -2206 -1934 -1787 -1766 -1796 -1834 -1854 -1892 -1866 -1840 -1758 -1659 -1541 -1438 -1370 -1352 -1352 -1339 -1284 -1250 -1122 -926 -646 -256 226 790 1390 1925 2403 2785 3040 3158 3167 3054 2884 2661 2441 2250 2115 1990 1894 1765 1639 1492 1369 1226 1090 957 879 870 882 909 1023 1203 1460 1768 2130 2475 2780 2965 3050 3013 2889 2699 2507 2295 2164 2112 2162 2331 2592 2950 3344 3774 4189 4525 4752 4836 4802 4590 4242 3759 3200 2628 2123 1709 1409 1190 1053 957 897 808 676 486 247 -52 -386 -736 -1083 -1438 -1703 -1894 -1975 -1945 -1796 -1494 -1070 -586 -102 335 686 890 967 886 683 387 46 -343 -735 -1138 -1470 -1781 -2034 -2238 -2378 -2477 -2517 -2568 -2607 -2728 -2912 -3197 -3510 -3842 -4114 -4334 -4457 -4492 -4385 -4188 -3913 -3596 -3277 -3001 -2707 -2447 -2237 -2095 -1997 -1975 -2014 -2078 -2136 -2193 -2198 -2167 -2119 -2085 -2037 -2037 -2014 -2013 -1964 -1889 -1758 -1578 -1347 -1097 -790 -474 -151 128 419 701 946 1110 1204 1209 1120 952 745 500 259 54 -113 -233 -311 -356 -363 -347 -265 -179 -23 170 369 573 804 997 1181 1308 1405 1449 1482 1515 1565 1603 1637 1645 1680 1724 1775 1869 1980 2098 2224 2378 2585 2854 3161 3477 3777 4041 4246 4392 4464 4433 4350 4151 3905 3632 3345 3019 2716 2405 2103 1840 1605 1451 1342 1271 1256 1218 1181 1130 1063 1005 964 961 1053 1187 1407 1625 1871 2116 2315 2426 2479 2457 2374 2208 2005 1720 1400 974 504 37 -413 -872 -1254 -1579 -1826 -2053 -2223 -2399 -2532 -2651 -2736 -2810 -2831 -2849 -2903 -2978 -3038 -3154 -3297 -3451 -3618 -3790 -3929 -4065 -4166 -4273 -4345 -4395 -4388 -4357 -4252 -4148 -4014 -3917 -3817 -3740 -3663 -3565 -3439 -3293 -3121 -2944 -2732 -2506 -2248 -2024 -1778 -1547 -1290 -1056 -825 -670 -524 -443 -395 -385 -405 -391 -373 -350 -306 -290 -272 -293 -330 -388 -423 -449 -432 -380 -275 -156 -9 72 179 280 371 471 579 706 838 930 966 964 953 921 888 837 789 770 757 735 738 725 738 780 818 896 1029 1202 1407 1612 1825 2045 2265 2455 2653 2856 3047 3214 3383 3512 3626 3674 3711 3719 3718 3666 3596 3504 3431 3373 3338 3317 3365 3435 3551 3656 3736 3789 3794 3741 3633 3463 3287 3075 2872 2650 2435 2197 1987 1767 1577 1402 1258 1113 984 843 668 470 267 23 -213 -448 -629 -777 -896 -984 -1042 -1098 -1128 -1164 -1179 -1237 -1324 -1490 -1694 -1965 -2262 -2612 -2950 -3277 -3524 -3739 -3860 -3919 -3910 -3862 -3777 -3715 -3643 -3602 -3578 -3554 -3525 -3482 -3418 -3343 -3252 -3138 -3022 -2913 -2752 -2615 -2446 -2252 -2072 -1901 -1725 -1598 -1515 -1484 -1461 -1424 -1366 -1335 -1266 -1198 -1118 -1056 -1011 -1006 -995 -1001 -963 -940 -872 -828 -814 -857 -964 -1071 -1156 -1226 -1262 -1301 -1317 -1352 -1381 -1420 -1405 -1364 -1277 -1175 -1046 -919 -785 -688 -609 -520 -425 -332 -200 -64 97 253 392 502 607 664 743 818 915 1002 1077 1096 1096 1045 974 913 896 922 1036 1170 1330 1487 1653 1806 1975 2109 2317 2552 2819 3102 3389 3660 3936 4130 4283 4369 4419 4397 4321 4198 4030 3794 3540 3279 3051 2841 2673 2557 2508 2495 2508 2489 2443 2354 2192 2013 1836 1658 1547 1476 1459 1436 1415 1397 1372 1332 1295 1233 1141 1005 848 664 474 277 119 -3 -52 -55 -7 57 134 156 145 100 31 -43 -112 -200 -276 -371 -434 -522 -574 -643 -721 -837 -961 -1097 -1244 -1402 -1548 -1697 -1798 -1847 -1859 -1816 -1716 -1608 -1456 -1283 -1104 -955 -827 -765 -766 -800 -818 -889 -957 -994 -997 -998 -980 -973 -970 -1054 -1155 -1247 -1337 -1472 -1573 -1649 -1694 -1724 -1721 -1666 -1580 -1483 -1339 -1172 -1005 -864 -759 -700 -672 -705 -732 -800 -865 -923 -957 -975 -970 -933 -865 -787 -684 -598 -499 -406 -312 -227 -149 -98 -48 -5 27 51 102 162 244 324 402 487 551 593 629 638 660 657 638 575 528 511 508 534 581 640 740 806 904 1013 1130 1223 1325 1403 1498 1561 1621 1659 1698 1713 1725 1755 1761 1765 1775 1766 1774 1770 1752 1724 1688 1645 1608 1551 1506 1441 1407 1373 1363 1365 1393 1448 1504 1586 1693 1795 1902 2001 2102 2216 2348 2477 2617 2726 2829 2899 2953 2969 2957 2880 2785 2660 2502 2324 2153 2006 1880 1753 1655 1573 1518 1468 1414 1358 1304 1220 1164 1110 1064 1032 992 943 889 848 814 757 724 681 649 607 535 436 323 199 56 -81 -204 -322 -419 -494 -528 -572 -577 -590 -612 -626 -648 -710 -766 -851 -958 -1094 -1213 -1314 -1370 -1400 -1394 -1359 -1310 -1267 -1243 -1240 -1262 -1311 -1383 -1470 -1559 -1651 -1697 -1748 -1786 -1772 -1757 -1698 -1601 -1478 -1332 -1194 -1094 -1022 -967 -940 -908 -886 -855 -836 -747 -672 -548 -415 -320 -202 -124 -93 -44 -52 -34 -3 26 59 107 168 263 368 497 638 777 874 962 1029 1042 997 924 822 718 611 545 511 511 489 471 440 385 288 184 33 -108 -275 -412 -531 -610 -655 -661 -654 -627 -607 -555 -490 -431 -398 -364 -361 -343 -320 -256 -220 -155 -71 9 94 142 190 182 174 149 116 104 76 81 80 112 144 177 207 257 314 396 457 552 640 723 788 830 851 913 958 1032 1108 1177 1221 1243 1248 1223 1195 1165 1170 1180 1162 1096 1006 912 802 701 621 572 497 448 361 282 197 126 51 -17 -110 -201 -296 -370 -427 -440 -436 -380 -299 -172 -17 173 351 547 712 829 912 960 982 1003 998 1017 1034 1046 1034 1040 1015 988 953 894 834 777 692 599 484 361 224 79 -58 -133 -204 -258 -301 -351 -439 -522 -606 -678 -756 -828 -886 -909 -906 -862 -865 -831 -800 -741 -676 -599 -558 -519 -477 -416 -406 -385 -358 -356 -364 -399 -449 -476 -505 -539 -573 -645 -712 -779 -849 -905 -984 -1025 -1073 -1115 -1165 -1202 -1223 -1243 -1264 -1260 -1266 -1258 -1263 -1232 -1172 -1080 -995 -879 -734 -633 -528 -436 -377 -333 -344 -343 -368 -378 -405 -408 -368 -303 -255 -201 -154 -105 -61 -17 0 23 22 21 6 36 64 119 169 225 271 293 299 279 235 187 79 -23 -115 -238 -351 -447 -518 -548 -565 -548 -528 -497 -443 -369 -315 -239 -181 -129 -114 -85 -40 13 58 111 163 218 253 295 312 350 368 403 420 460 508 541 607 657 681 715 733 761 765 764 774 739 664 603 517 466 395 355 295 265 205 131 68 13 -28 -51 -85 -93 -125 -159 -174 -197 -221 -221 -250 -253 -279 -305 -348 -381 -460 -544 -633 -719 -818 -882 -978 -1055 -1131 -1209 -1284 -1322 -1383 -1437 -1499 -1545 -1615 -1663 -1704 -1756 -1833 -1894 -1952 -2000 -2031 -2040 -2014 -1952 -1895 -1829 -1756 -1693 -1656 -1631 -1649 -1663 -1690 -1710 -1753 -1786 -1799 -1778 -1736 -1665 -1567 -1452 -1362 -1291 -1261 -1244 -1251 -1267 -1322 -1364 -1387 -1378 -1363 -1337 -1318 -1293 -1267 -1257 -1247 -1219 -1180 -1108 -1071 -998 -963 -920 -889 -855 -821 -751 -684 -596 -519 -472 -423 -374 -364 -351 -344 -323 -303 -227 -197 -144 -108 -55 -3 63 109 177 211 258 293 347 364 385 386 391 405 436 457 497 553 616 686 759 811 855 862 866 875 866 852 852 853 846 853 886 898 923 953 946 905 856 781 695 613 565 541 544 552 577 591 632 658 702 722 739 743 729 689 625 548 475 392 347 317 318 321 321 339 365 360 334 289 228 149 77 6 -56 -108 -128 -156 -157 -184 -184 -189 -212 -219 -228 -268 -307 -368 -423 -477 -521 -562 -605 -618 -642 -691 -719 -736 -719 -723 -691 -688 -674 -689 -695 -730 -770 -851 -906 -970 -1013 -1056 -1109 -1141 -1185 -1231 -1269 -1332 -1393 -1468 -1544 -1627 -1701 -1766 -1819 -1853 -1858 -1861 -1833 -1779 -1714 -1642 -1560 -1482 -1404 -1350 -1301 -1285 -1244 -1240 -1219 -1202 -1158 -1114 -1087 -1049 -1011 -1001 -995 -1008 -1038 -1079 -1080 -1091 -1057 -1034 -983 -939 -862 -783 -708 -616 -521 -439 -344 -264 -172 -110 -17 50 126 204 293 378 454 504 581 642 699 766 850 908 971 1009 1053 1083 1077 1056 1063 1082 1115 1150 1201 1239 1276 1300 1308 1279 1229 1161 1102 1036 958 872 794 744 705 656 657 647 637 626 590 552 529 479 429 381 359 310 292 271 246 213 171 105 23 -66 -139 -227 -308 -403 -476 -520 -545 -592 -596 -592 -579 -572 -562 -569 -583 -602 -604 -625 -612 -606 -555 -516 -453 -412 -332 -282 -242 -228 -235 -251 -286 -337 -375 -434 -501 -558 -572 -582 -568 -565 -505 -485 -463 -463 -456 -493 -519 -555 -530 -529 -511 -485 -469 -430 -401 -406 -405 -409 -416 -426 -436 -443 -443 -477 -502 -530 -528 -550 -552 -548 -518 -510 -457 -430 -391 -354 -338 -320 -305 -320 -306 -315 -314 -315 -332 -357 -370 -396 -398 -424 -432 -431 -460 -474 -480 -497 -487 -473 -455 -435 -394 -382 -341 -308 -281 -245 -216 -208 -187 -194 -184 -191 -183 -184 -180 -184 -190 -201 -217 -238 -272 -313 -344 -384 -409 -417 -429 -453 -462 -480 -475 -468 -455 -431 -381 -347 -295 -249 -196 -172 -126 -109 -79 -88 -85 -90 -106 -120 -122 -122 -84 -58 -6 48 113 158 207 220 257 242 226 195 179 157 162 164 207 218 247 296 355 398 446 467 476 460 445 424 411 389 374 355 334 313 295 288 278 244 205 162 118 72 3 -43 -76 -109 -123 -164 -197 -231 -268 -317 -353 -419 -475 -511 -544 -590 -590 -628 -652 -685 -708 -740 -780 -826 -862 -924 -970 -1011 -1046 -1074 -1080 -1097 -1087 -1083 -1050 -1046 -1020 -1025 -988 -977 -940 -882 -846 -798 -740 -684 -623 -572 -511 -473 -425 -414 -384 -351 -332 -313 -267 -227 -178 -134 -115 -85 -56 -32 -14 -30 3 9 51 88 136 185 229 293 361 398 465 521 557 589 614 608 589 556 522 497 483 453 456 451 463 477 489 497 516 511 525 523 516 500 490 483 487 477 471 450 475 487 510 541 582 620 661 713 763 814 848 881 929 929 957 979 996 1026 1054 1072 1107 1136 1146 1162 1180 1189 1207 1202 1209 1193 1195 1170 1157 1130 1101 1083 1069 1049 1043 1038 1046 1046 1060 1063 1097 1105 1123 1149 1162 1167 1168 1169 1159 1131 1090 1065 1027 977 943 900 879 851 824 800 781 748 733 700 698 681 661 653 647 644 664 674 686 683 688 672 688 691 698 695 700 693 707 707 704 698 714 714 718 705 702 709 718 712 721 735 744 749 763 772 780 780 763 742 723 683 635 611 592 545 517 487 484 451 426 391 385 338 323 288 251 228 207 173 155 151 141 146 151 143 162 167 187 205 213 236 266 289 294 298 310 292 284 269 269 269 296 317 368 397 435 484 518 518 545 552 562 561 572 584 603 616 644 688 734 771 813 863 913 952 997 1017 1027 1036 1036 1040 1021 994 997 989 989 986 986 978 987 973 984 974 983 967 960 940 916 886 861 809 758 691 643 585 552 512 478 459 451 433 428 410 402 364 335 299 259 201 174 146 124 120 115 139 178 194 218 238 272 310 353 410 443 479 535 562 607 623 627 639 661 655 682 695 712 727 746 758 794 815 833 862 882 895 916 942 964 956 977 974 983 971 984 975 978 960 927 911 897 851 834 789 751 700 640 583 530 439 386 322 291 252 224 211 196 191 176 166 171 154 157 142 146 149 149 138 161 160 170 185 212 211 226 224 236 229 203 189 190 182 194 195 207 238 268 289 321 334 366 391 402 389 408 420 437 433 466 490 518 522 524 508 490 466 437 398 364 319 301 273 263 245 248 225 225 217 211 193 179 142 132 113 123 94 84 82 108 112 121 137 136 126 137 135 136 141 156 162 175 160 188 173 180 182 201 193 194 193 199 173 173 172 202 211 216 211 230 245 286 293 347 385 426 470 500 562 619 640 687 712 724 739 753 771 780 753 759 756 759 746 748 725 712 695 663 631 596 545 504 469 442 396 369 336 318 296 267 248 218 199 182 142 136 108 64 32 5 -46 -74 -98 -109 -154 -163 -188 -204 -218 -227 -231 -222 -227 -238 -243 -221 -221 -231 -233 -242 -262 -275 -274 -268 -286 -269 -263 -262 -256 -250 -264 -244 -247 -240 -230 -208 -202 -170 -149 -120 -114 -92 -91 -85 -100 -103 -115 -138 -160 -163 -171 -175 -201 -188 -190 -188 -208 -202 -212 -245 -274 -306 -353 -369 -416 -444 -466 -473 -488 -465 -477 -454 -445 -432 -412 -387 -381 -374 -367 -357 -370 -364 -364 -320 -309 -271 -247 -210 -177 -159 -118 -86 -63 -24 14 31 40 57 73 90 102 115 107 137 119 107 105 101 78 69 49 64 60 77 82 89 92 123 141 178 194 224 245 263 248 255 255 246 242 224 214 210 182 157 133 93 69 38 -8 -35 -74 -110 -125 -146 -172 -177 -196 -185 -185 -196 -191 -176 -167 -129 -112 -91 -80 -53 -31 7 43 80 105 124 121 132 137 138 121 124 137 140 137 139 153 163 160 177 164 167 160 160 171 190 208 231 236 257 272 288 298 297 282 273 242 223 213 188 170 177 172 171 156 167 153 137 88 78 37 13 -20 -30 -47 -47 -47 -51 -57 -44 -56 -40 -37 -41 -51 -49 -65 -88 -85 -95 -110 -111 -109 -107 -113 -129 -130 -141 -160 -150 -155 -145 -129 -119 -110 -102 -103 -78 -64 -48 -21 -7 5 30 43 71 103 131 157 193 231 245 257 265 267 272 246 238 202 192 166 160 146 141 109 111 95 82 66 52 42 42 27 27 14 46 51 69 71 86 79 77 77 77 62 68 57 40 24 32 21 13 -9 -15 -23 -32 -68 -71 -93 -105 -114 -133 -145 -145 -173 -178 -195 -190 -177 -165 -150 -118 -105 -80 -65 -50 -32 -27 -34 -33 -47 -40 -44 -35 -27 4 20 49 54 78 94 105 102 108 100 79 71 59 39 45 44 46 48 62 61 61 56 51 27 1 -35 -57 -94 -98 -114 -116 -160 -167 -181 -190 -213 -221 -228 -228 -261 -273 -282 -299 -330 -342 -344 -353 -368 -363 -378 -379 -388 -388 -390 -361 -361 -351 -338 -298 -295 -256 -251 -204 -179 -153 -134 -108 -93 -73 -55 -40 -41 -40 -35 -33 -30 -27 -10 9 4 -6 -10 0 -21 -23 -25 -28 -34 -42 -51 -54 -88 -88 -81 -89 -92 -98 -108 -98 -115 -125 -126 -129 -146 -153 -169 -150 -146 -151 -133 -129 -126 -111 -90 -64 -49 -23 15 30 52 76 83 112 129 145 163 182 201 231 239 279 275 318 335 361 369 381 378 378 368 364 357 365 360 352 362 377 385 386 398 429 429 459 473 479 481 499 481 492 477 477 466 474 456 477 466 460 443 459 425 420 402 386 353 347 322 303 271 265 245 254 244 251 235 241 232 241 244 244 231 238 225 208 211 204 201 194 173 159 149 153 142 146 136 137 138 147 128 137 126 140 124 113 103 119 109 112 119 112 95 96 74 78 71 54 37 33 16 15 0 -3 -20 -28 -35 -29 -43 -41 -50 -46 -44 -37 -54 -40 -36 -29 -31 -42 -27 -40 -68 -81 -103 -111 -133 -131 -155 -168 -174 -194 -224 -225 -231 -231 -245 -256 -278 -276 -273 -264 -275 -279 -286 -287 -294 -281 -275 -275 -262 -246 -240 -221 -211 -181 -143 -142 -127 -116 -120 -97 -101 -85 -110 -109 -111 -110 -135 -134 -132 -130 -165 -193 -224 -243 -271 -287 -317 -329 -346 -355 -365 -371 -391 -381 -380 -385 -401 -410 -425 -446 -454 -475 -490 -500 -522 -531 -536 -531 -535 -540 -529 -538 -545 -536 -541 -538 -559 -559 -565 -551 -556 -535 -521 -505 -497 -474 -475 -469 -460 -453 -456 -451 -459 -447 -439 -428 -422 -396 -405 -378 -364 -358 -363 -336 -340 -332 -319 -305 -306 -286 -295 -266 -269 -244 -237 -221 -213 -213 -220 -221 -245 -239 -266 -271 -276 -294 -287 -292 -324 -321 -326 -320 -323 -317 -313 -299 -316 -301 -286 -277 -285 -269 -282 -255 -260 -248 -229 -221 -222 -208 -213 -195 -202 -205 -200 -190 -199 -190 -187 -188 -194 -196 -200 -180 -182 -183 -188 -172 -179 -166 -149 -122 -121 -110 -91 -59 -49 -35 -35 -23 -4 -7 -23 -9 -9 -10 2 0 -9 -15 -20 -10 -21 -29 -51 -51 -60 -62 -71 -74 -96 -85 -95 -98 -91 -97 -116 -132 -150 -146 -156 -156 -179 -170 -172 -176 -176 -182 -194 -188 -201 -196 -194 -194 -193 -199 -214 -207 -207 -221 -225 -215 -234 -221 -229 -228 -236 -237 -247 -255 -260 -255 -282 -271 -283 -284 -285 -272 -286 -265 -262 -256 -271 -265 -258 -242 -245 -227 -202 -191 -180 -171 -152 -124 -117 -98 -98 -74 -63 -40 -11 19 34 69 88 120 136 150 156 179 182 194 211 221 209 224 218 223 219 220 206 215 202 207 214 222 231 244 243 267 286 299 297 321 333 341 368 379 366 380 384 394 392 403 389 399 397 391 379 379 355 361 337 328 308 305 289 277 271 286 282 290 299 323 336 344 340 344 337 352 333 337 337 352 330 335 339 324 318 309 301 290 269 255 239 233 214 199 183 176 157 156 139 133 110 103 88 68 69 61 47 34 20 21 26 16 23 13 -10 -3 -17 -36 -51 -46 -64 -74 -74 -80 -85 -85 -85 -83 -98 -84 -98 -89 -97 -109 -114 -112 -132 -129 -139 -133 -120 -131 -143 -147 -156 -163 -156 -145 -159 -146 -162 -161 -166 -172 -187 -203 -213 -202 -214 -216 -216 -219 -207 -215 -207 -192 -196 -207 -221 -225 -233 -214 -211 -213 -220 -214 -205 -194 -183 -175 -169 -156 -160 -155 -182 -201 -190 -184 -208 -213 -226 -241 -252 -262 -258 -252 -265 -271 -271 -261 -268 -258 -258 -258 -256 -241 -244 -228 -228 -228 -214 -189 -187 -188 -184 -168 -173 -156 -156 -156 -163 -177 -184 -184 -210 -214 -231 -230 -240 -227 -227 -224 -235 -245 -265 -265 -288 -298 -314 -331 -360 -377 -393 -402 -436 -456 -480 -505 -544 -553 -566 -588 -618 -615 -639 -639 -641 -652 -665 -667 -663 -647 -654 -646 -647 -633 -627 -612 -620 -598 -609 -576 -593 -596 -572 -559 -571 -560 -560 -551 -555 -576 -573 -562 -572 -562 -560 -550 -550 -536 -534 -510 -510 -502 -480 -456 -440 -414 -400 -373 -357 -342 -313 -289 -275 -275 -271 -230 -246 -239 -243 -233 -246 -231 -225 -234 -236 -230 -245 -232 -231 -238 -233 -229 -241 -235 -221 -204 -205 -188 -174 -147 -142 -128 -121 -107 -106 -107 -97 -95 -95 -85 -105 -109 -112 -117 -130 -126 -128 -136 -138 -121 -121 -114 -115 -109 -100 -88 -95 -83 -77 -62 -60 -39 -49 -34 -10 3 0 4 13 3 3 6 -10 -17 -27 -34 -44 -47 -63 -52 -58 -68 -76 -78 -82 -99 -110 -103 -110 -95 -97 -102 -102 -92 -108 -107 -102 -102 -110 -100 -109 -95 -109 -110 -107 -97 -124 -126 -148 -155 -176 -189 -226 -235 -255 -252 -274 -277 -275 -270 -291 -283 -282 -289 -301 -289 -320 -321 -310 -312 -309 -286 -278 -272 -277 -256 -257 -245 -250 -244 -224 -221 -211 -196 -206 -191 -182 -177 -174 -155 -149 -126 -117 -121 -123 -114 -126 -110 -119 -127 -113 -117 -123 -125 -143 -130 -134 -142 -143 -133 -157 -164 -180 -184 -188 -185 -178 -172 -185 -177 -186 -197 -213 -208 -213 -207 -212 -212 -202 -182 -204 -201 -184 -178 -188 -177 -189)		samplingRate: 22050.! !This class encodes and decodes data in Base64 format.  This is MIME encoding.  We translate a whole stream at once, taking a Stream as input and giving one as output.  Returns a whole stream for the caller to use.           0 A            17 R            34 i            51 z           1 B            18 S            35 j            52 0           2 C            19 T            36 k            53 1           3 D            20 U            37 l            54 2           4 E            21 V            38 m            55 3           5 F            22 W            39 n            56 4           6 G            23 X            40 o            57 5           7 H            24 Y            41 p            58 6           8 I            25 Z            42 q            59 7           9 J            26 a            43 r            60 8          10 K            27 b            44 s            61 9          11 L            28 c            45 t            62 +          12 M            29 d            46 u            63 /          13 N            30 e            47 v          14 O            31 f            48 w         (pad) =          15 P            32 g            49 x          16 Q            33 h            50 yOutbound: bytes are broken into 6 bit chunks, and the 0-63 value is converted to a character.  3 data bytes go into 4 characters.Inbound: Characters are translated in to 0-63 values and shifted into 8 bit bytes.(See: N. Borenstein, Bellcore, N. Freed, Innosoft, Network Working Group, Request for Comments: RFC 1521, September 1993, MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies. Sec 6.2)By Ted Kaehler, based on Tim Olson's Base64Filter.!!Base64MimeConverter methodsFor: 'accessing' stamp: 'tk 12/9/97 13:55'!dataStream	^dataStream! !!Base64MimeConverter methodsFor: 'accessing' stamp: 'tk 12/9/97 13:51'!dataStream: anObject	dataStream _ anObject! !!Base64MimeConverter methodsFor: 'accessing' stamp: 'tk 12/9/97 13:53'!mimeStream	^mimeStream! !!Base64MimeConverter methodsFor: 'accessing' stamp: 'tk 12/9/97 13:51'!mimeStream: anObject	mimeStream _ anObject! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'tk 12/9/97 13:34'!mimeDecode	"Convert a stream in base 64 with only a-z,A-Z,0-9,+,/ to a full byte stream of characters.  Reutrn a whole stream for the user to read."	| nibA nibB nibC nibD |	[mimeStream atEnd] whileFalse: [		(nibA _ self nextValue) ifNil: [^ dataStream].		(nibB _ self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibA bitShift: 2) + (nibB bitShift: -4)) asCharacter.		nibB _ nibB bitAnd: 16rF.		(nibC _ self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibB bitShift: 4) + (nibC bitShift: -2)) asCharacter.		nibC _ nibC bitAnd: 16r3.		(nibD _ self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibC bitShift: 6) + nibD) asCharacter.		].	^ dataStream! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'tk 12/9/97 13:39'!mimeDecodeToByteArray	"Convert a stream in base 64 with only a-z,A-Z,0-9,+,/ to a full ByteArray of 0-255 values.  Reutrn a whole stream for the user to read."	| nibA nibB nibC nibD |	[mimeStream atEnd] whileFalse: [		(nibA _ self nextValue) ifNil: [^ dataStream].		(nibB _ self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibA bitShift: 2) + (nibB bitShift: -4)).		nibB _ nibB bitAnd: 16rF.		(nibC _ self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibB bitShift: 4) + (nibC bitShift: -2)).		nibC _ nibC bitAnd: 16r3.		(nibD _ self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibC bitShift: 6) + nibD).		].	^ dataStream! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'tk 12/9/97 12:57'!mimeEncode	"Convert from data to 6 bit characters."	| phase1 phase2 raw nib |	phase1 _ phase2 _ false.	[dataStream atEnd] whileFalse: [		data _ raw _ dataStream next asInteger.		nib _ (data bitAnd: 16rFC) bitShift: -2.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw _ dataStream next) ifNil: [raw _ 0. phase1 _ true].		data _ ((data bitAnd: 3) bitShift: 8) + raw asInteger.		nib _ (data bitAnd: 16r3F0) bitShift: -4.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw _ dataStream next) ifNil: [raw _ 0. phase2 _ true].		data _ ((data bitAnd: 16rF) bitShift: 8) + (raw asInteger).		nib _ (data bitAnd: 16rFC0) bitShift: -6.		mimeStream nextPut: (ToCharTable at: nib+1).		nib _ (data bitAnd: 16r3F).		mimeStream nextPut: (ToCharTable at: nib+1)].	phase1 ifTrue: [mimeStream skip: -2; nextPut: $=; nextPut: $=.			^ mimeStream].	phase2 ifTrue: [mimeStream skip: -1; nextPut: $=.			^ mimeStream].! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'tk 12/9/97 13:21'!nextValue	"The next six bits of data char from the mimeStream, or nil.  Skip all other chars"	| raw num |	[raw _ mimeStream next.	raw ifNil: [^ nil].	"end of stream"	raw == $= ifTrue: [^ nil].	num _ FromCharTable at: raw asciiValue + 1.	num ifNotNil: [^ num].	"else ignore space, return, tab, ..."	true] whileTrue.! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 14:29'!example	"Base64MimeConverter example"| ss bb | ss _ ReadWriteStream on: (String new: 10).ss nextPutAll: 'Hi There!!'.bb _ Base64MimeConverter mimeEncode: ss.	"bb contents  'SGkgVGhlcmUh'"^ (Base64MimeConverter mimeDecodeToChars: bb) contents! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 13:53'!initialize	FromCharTable _ Array new: 256.	"nils"	ToCharTable _ Array new: 64.	($A asciiValue to: $Z asciiValue) doWithIndex: [:val :ind | 		FromCharTable at: val+1 put: ind-1.		ToCharTable at: ind put: val asCharacter].	($a asciiValue to: $z asciiValue) doWithIndex: [:val :ind | 		FromCharTable at: val+1 put: ind+25.		ToCharTable at: ind+26 put: val asCharacter].	($0 asciiValue to: $9 asciiValue) doWithIndex: [:val :ind | 		FromCharTable at: val+1 put: ind+25+26.		ToCharTable at: ind+26+26 put: val asCharacter].	FromCharTable at: $+ asciiValue + 1 put: 62.	ToCharTable at: 63 put: $+.	FromCharTable at: $/ asciiValue + 1 put: 63.	ToCharTable at: 64 put: $/.	! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 12/12/97 11:41'!mimeDecodeToBytes: aStream 	"Return a RWBinaryOrTextStream of the original ByteArray.  aStream has only 65 innocuous character values.  aStream is not binary.  (See class comment). 4 bytes in aStream goes to 3 bytes in output."	| me |	aStream position: 0.	me _ self new mimeStream: aStream.	me dataStream: (RWBinaryOrTextStream on: (ByteArray new: aStream size * 3 // 4)).	me mimeDecodeToByteArray.	me dataStream position: 0.	^ me dataStream! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 13:01'!mimeDecodeToChars: aStream 	"Return a ReadWriteStream of the original String.  aStream has only 65 innocuous character values.  It is not binary.  (See class comment). 4 bytes in aStream goes to 3 bytes in output."	| me |	aStream position: 0.	me _ self new mimeStream: aStream.	me dataStream: (ReadWriteStream on: (String new: aStream size * 3 // 4)).	me mimeDecode.	me dataStream position: 0.	^ me dataStream! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 12:28'!mimeEncode: aStream	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."	| me |	aStream position: 0.	me _ self new dataStream: aStream.	me mimeStream: (ReadWriteStream on: (String new: aStream size + 20 * 4 // 3)).	me mimeEncode.	me mimeStream position: 0.	^ me mimeStream! !!Behavior methodsFor: 'initialize-release'!obsolete	"Invalidate and recycle local messages. Remove the receiver from its 	superclass' subclass list."	methodDict _ MethodDictionary new.	superclass == nil ifFalse: [superclass removeSubclass: self]! !!Behavior methodsFor: 'accessing' stamp: 'sw 3/10/97'!confirmRemovalOf: aSelector	"Determine if it is okay to remove the given selector.  Answer 1 if it should be removed, 2 if it should be removed followed by a senders browse, and 3 if it should not be removed. 	9/18/96 sw: made the wording more delicate	: bug fix -- auto select string needs to be first keyword only"	| count aMenu answer caption allCalls |	(count _ (allCalls _ Smalltalk allCallsOn: aSelector) size) > 0		ifTrue:			[aMenu _ PopUpMenu labels: 'Remove itRemove, then browse sendersDon''t remove, but show me those sendersForget it -- do nothing -- sorry I asked'.			caption _ 'This message has ', count printString, ' sender'.			count > 1 ifTrue:				[caption _ caption copyWith: $s].			answer _ aMenu startUpWithCaption: caption.			answer == 3 ifTrue:				[Smalltalk browseMessageList: allCalls					name: 'Senders of ', aSelector					autoSelect: aSelector keywords first].			answer == 0 ifTrue: [answer _ 3].  "If user didn't answer, treat it as cancel"			^ answer min: 3]		ifFalse:			[^ 1]	! !!Behavior methodsFor: 'testing'!instSize	"Answer the number of named instance variables	(as opposed to indexed variables) of the receiver."	self flag: #instSizeChange.  "Smalltalk browseAllCallsOn: #instSizeChange""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ ((format bitShift: -1) bitAnd: 16rFF) - 1	Note also that every other method in this category will require	2 bits more of right shift after the change."	^ ((format bitShift: -10) bitAnd: 16rC0) + ((format bitShift: -1) bitAnd: 16r3F) - 1! !!Behavior methodsFor: 'creating class hierarchy'!superclass: aClass 	"Change the receiver's superclass to be aClass."	(aClass == nil or: [aClass isKindOf: Behavior])		ifTrue: [superclass _ aClass]		ifFalse: [self error: 'superclass must be a class-describing object']! !!Behavior methodsFor: 'creating method dictionary' stamp: 'di 12/26/97 11:04'!addSelector: selector withMethod: compiledMethod 	"Add the message selector with the corresponding compiled method to the 	receiver's method dictionary."	methodDict at: selector put: compiledMethod.	selector flushCache! !!Behavior methodsFor: 'creating method dictionary' stamp: 'tk 12/6/97 21:33'!compile: code notifying: requestor 	"Compile the argument, code, as source code in the context of the 	receiver and insEtall the result in the receiver's method dictionary. The 	second argument, requestor, is to be notified if an error occurs. The 	argument code is either a string or an object that converts to a string or 	a PositionableStream. This method also saves the source code."	| method selector methodNode |	method _ self		compile: code "a Text"		notifying: requestor		trailer: #(0 0 0 0)		ifFail: [^nil]		elseSetSelectorAndNode: 			[:sel :parseNode | selector _ sel.  methodNode _ parseNode].	method putSource: code "a Text" fromParseNode: methodNode inFile: 2			withPreamble: [:f | f cr; nextPut: $!!; nextChunkPut: 'Behavior method'; cr].	^selector! !!Behavior methodsFor: 'creating method dictionary'!compress	"Compact the method dictionary of the receiver."	methodDict rehash! !!Behavior methodsFor: 'creating method dictionary'!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	| method trailer methodNode |	method _ self compiledMethodAt: selector.	trailer _ (method size - 3 to: method size) collect: [:i | method at: i].	methodNode _ self compilerClass new				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self addSelector: selector withMethod: (methodNode generate: trailer).! !!Behavior methodsFor: 'creating method dictionary' stamp: 'di 12/26/97 11:08'!removeSelector: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in the receiver's method dictionary, remove it. If the selector is not in 	the method dictionary, create an error notification."	methodDict removeKey: selector.	selector flushCache! !!Behavior methodsFor: 'instance creation'!new	"Answer a new instance of the receiver (which is a class) with no indexable variables. Fail if the class is indexable."	"Essential Primitive. See Object documentation whatIsAPrimitive."	<primitive: 70>	self isVariable ifTrue: [^ self basicNew: 0].	"space must be low"	Smalltalk signalLowSpace.	^ self basicNew  "retry if user proceeds"! !!Behavior methodsFor: 'instance creation'!new: anInteger 	"Primitive. Answer an instance of the receiver (which is a class) with the 	number of indexable variables specified by the argument, anInteger. Fail 	if the class is not indexable or if the argument is not a positive Integer. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>	(anInteger isInteger and: [anInteger >= 0]) ifTrue: [		"arg okay; space must be low"		Smalltalk signalLowSpace.		^ self basicNew: anInteger  "retry if user proceeds"	].	self primitiveFailed! !!Behavior methodsFor: 'accessing class hierarchy'!allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level 	"Walk the tree of subclasses, giving the class and its level"	| subclassNames subclass |	classAndLevelBlock value: self value: level.	self == Class ifTrue:  [^ self].  "Don't visit all the metaclasses"	"Visit subclasses in alphabetical order"	subclassNames _ SortedCollection new.	self subclassesDo: [:subC | subclassNames add: subC name].	subclassNames do:		[:name | (Smalltalk at: name)			allSubclassesWithLevelDo: classAndLevelBlock			startingLevel: level+1]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sw 1/15/98 19:34'!compiledMethodAt: selector ifAbsent: aBlock	"Answer the compiled method associated with the argument, selector (a Symbol), a message selector in the receiver's method dictionary. If the selector is not in the dictionary, return the value of aBlock"	^ methodDict at: selector ifAbsent: [aBlock value]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'tk 1/7/98 10:31'!compressedSourceCodeAt: selector	"(Paragraph compressedSourceCodeAt: #displayLines:affectedRectangle:) size 721 1921	Paragraph selectors inject: 0 into: [:tot :sel | tot + (Paragraph compressedSourceCodeAt: sel) size] 13606 31450"	| rawText parse |	rawText _ (self sourceCodeAt: selector) asString.	parse _ self compilerClass new parse: rawText in: self notifying: nil.	^ rawText compressWithTable:		((selector keywords ,		parse tempNames ,		self instVarNames ,		#(self super ifTrue: ifFalse:) ,		((0 to: 7) collect:			[:i | String streamContents:				[:s | s cr. i timesRepeat: [s tab]]]) ,		(self compiledMethodAt: selector) literalStrings)			asSortedCollection: [:a :b | a size > b size])! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 1/13/98 17:34'!sourceCodeAt: selector	^ (methodDict at: selector) getSourceFor: selector in: self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sw 11/3/97 00:09'!sourceCodeAt: selector ifAbsent: aBlock	^ (methodDict at: selector ifAbsent: [^ aBlock value]) getSourceFor: selector in: self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sw 11/3/97 00:10'!sourceMethodAt: selector ifAbsent: aBlock	"Answer the paragraph corresponding to the source code for the 	argument."	^ (self sourceCodeAt: selector ifAbsent: [^ aBlock value]) asText makeSelectorBoldIn: self! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'di 6/20/97 10:51'!allSubInstances 	"Answer a list of all current instances of the receiver and all of its subclasses."	| aCollection |	aCollection _ OrderedCollection new.	self allSubInstancesDo:		[:x | x == aCollection ifFalse: [aCollection add: x]].	^ aCollection! !!Behavior methodsFor: 'testing method dictionary' stamp: 'tk 9/13/97 09:53'!classThatUnderstands: selector	"Answer the class that can respond to the message whose selector	is the argument. The selector can be in the method dictionary of the	receiver's class or any of its superclasses."	(self includesSelector: selector) ifTrue: [^ self].	superclass == nil ifTrue: [^ nil].	^ superclass classThatUnderstands: selector! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 9/5/97 16:16'!thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a literal.  Dives into the compact literal notation, making it slow but thorough"	| who method |	who _ Set new.	methodDict associationsDo:		[:assn |		method _ assn value.		((method hasLiteralSuchThat: [:lit | lit == literal]) or:				[specialFlag and: [method scanFor: specialByte]])			ifTrue:			[((literal isMemberOf: Association) not				or: [method sendsToSuper not					or: [method literals allButLast includes: literal]])				ifTrue: [who add: assn key]]].	^ who! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 10/17/97 22:39'!whichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a literal."	| who method |	who _ Set new.	methodDict associationsDo:		[:assn |		method _ assn value.		((method hasLiteral: literal) or:				[specialFlag and: [method scanFor: specialByte]])			ifTrue:			[((literal isMemberOf: Association) not				or: [method sendsToSuper not					or: [method literals allButLast includes: literal]])				ifTrue: [who add: assn key]]].	^who! !!Behavior methodsFor: 'enumerating' stamp: 'di 6/20/97 10:50'!allSubInstancesDo: aBlock 	"Evaluate the argument, aBlock, for each of the current instances of the 	receiver and all its subclasses."	self allInstancesDo: aBlock.	self allSubclassesDo: [:sub | sub allInstancesDo: aBlock]! !!Behavior methodsFor: 'user interface' stamp: 'sw 8/12/97 20:18'!allCallsOn: aSymbol	"Answer a SortedCollection of all the methods that call on aSymbol."	| aSortedCollection special |	aSortedCollection _ SortedCollection new.	special _ Smalltalk hasSpecialSelector: aSymbol ifTrueSetByte: [:byte ].	self withAllSubclassesDo:		[:class | (class whichSelectorsReferTo: aSymbol special: special byte: byte) do:			[:sel | sel ~~ #DoIt ifTrue: [aSortedCollection add: class name , ' ' , sel]]].	^aSortedCollection! !!Behavior methodsFor: 'private'!format: nInstVars variable: isVar words: isWords pointers: isPointers 	"Set the format for the receiver (a Class)."	| cClass instSpec sizeHiBits |	self flag: #instSizeChange."Smalltalk browseAllCallsOn: #instSizeChange.Smalltalk browseAllImplementorsOf: #fixedFieldsOf:.Smalltalk browseAllImplementorsOf: #instantiateClass:indexableSize:.""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	For now the format word is...		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>	But when we revise the image format, it should become...		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>"	sizeHiBits _ (nInstVars+1) // 64.	cClass _ 0.  "for now"	instSpec _ isPointers		ifTrue: [isVar				ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]				ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]		ifFalse: [isWords ifTrue: [6] ifFalse: [8]].	format _ sizeHiBits.	format _ (format bitShift: 5) + cClass.	format _ (format bitShift: 4) + instSpec.	format _ (format bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"	format _ (format bitShift: 1) "This shift plus integer bit lets wordSize work like byteSize"! !!Behavior methodsFor: 'private' stamp: 'di 12/26/97 11:07'!removeSelectorSimply: selector 	"Remove the message selector from the receiver's method dictionary.	Internal access from compiler."	methodDict removeKey: selector ifAbsent: [^self].	selector flushCache! !BitBlt comment:'I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:	8:	if source is 0 and destination is 0	4:	if source is 0 and destination is 1	2:	if source is 1 and destination is 0	1:	if source is 1 and destination is 1.At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.In addition to the original 16 combination rules, this BitBlt supports	16	fails (to simulate paint bits)	17	fails (to simulate erase bits)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components	21	rgbSub: sourceWord with: destinationWord.  Sum of color components	22	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)The color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  The colorMap, if specified, must be a word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source.  For every source pixel, BitBlt will then index this array, and select the corresponding pixelValue and mask it to the destination pixel size before storing.	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)'!!BitBlt methodsFor: 'accessing'!colorMap	^ colorMap! !!BitBlt methodsFor: 'accessing' stamp: 'tk 3/19/97'!destRect	"The rectangle we are about to blit to or just blitted to.  "	^ destX @ destY extent: width @ height! !!BitBlt methodsFor: 'accessing'!destX: x destY: y width: w height: h	"Combined init message saves 3 sends from DisplayScanner"	destX _ x.	destY _ y.	width _ w.	height _ h.! !!BitBlt methodsFor: 'accessing'!fillColor	^ halftoneForm! !!BitBlt methodsFor: 'accessing'!sourceForm	^ sourceForm! !!BitBlt methodsFor: 'copying'!copyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 96>	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	self halt: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX _ destX asInteger.	destY _ destY asInteger.	width _ width asInteger.	height _ height asInteger.	sourceX _ sourceX asInteger.	sourceY _ sourceY asInteger.	clipX _ clipX asInteger.	clipY _ clipY asInteger.	clipWidth _ clipWidth asInteger.	clipHeight _ clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'copying' stamp: 'di 7/17/97 10:04'!copyForm: srcForm to: destPt rule: rule	^ self copyForm: srcForm to: destPt rule: rule		colorMap: (srcForm colormapIfNeededForDepth: destForm depth)! !!BitBlt methodsFor: 'copying' stamp: 'di 7/17/97 10:04'!copyForm: srcForm to: destPt rule: rule colorMap: map	sourceForm _ srcForm.	halftoneForm _ nil.	combinationRule _ rule.	destX _ destPt x + sourceForm offset x.	destY _ destPt y + sourceForm offset y.	sourceX _ 0.	sourceY _ 0.	width _ sourceForm width.	height _ sourceForm height.	colorMap _ map.	self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'di 7/1/97 14:09'!copyFrom: sourceRectangle in: srcForm to: destPt	| sourceOrigin |	sourceForm _ srcForm.	halftoneForm _ nil.	combinationRule _ 3.  "store"	destX _ destPt x.	destY _ destPt y.	sourceOrigin _ sourceRectangle origin.	sourceX _ sourceOrigin x.	sourceY _ sourceOrigin y.	width _ sourceRectangle width.	height _ sourceRectangle height.	colorMap _ srcForm colormapIfNeededForDepth: destForm depth.	self copyBits! !!BitBlt methodsFor: 'copying'!pixelAt: aPoint put: pixelValue	"Assumes this BitBlt has been set up specially (see the init message,	BitBlt bitPokerToForm:.  Overwrites the pixel at aPoint."	destX _ aPoint x.	destY _ aPoint y.	sourceForm bits at: 1 put: pixelValue.	self copyBits"| bb |bb _ (BitBlt bitPokerToForm: Display).[Sensor anyButtonPressed] whileFalse:	[bb pixelAt: Sensor cursorPoint put: 55]"! !!BitBlt methodsFor: 'line drawing'!drawFrom: startPoint to: stopPoint 		 ^ self drawFrom: startPoint to: stopPoint withFirstPoint: true! !!BitBlt methodsFor: 'line drawing' stamp: '6/8/97 15:41 di'!drawFrom: startPoint to: stopPoint withFirstPoint: drawFirstPoint	"Draw a line whose end points are startPoint and stopPoint.	The line is formed by repeatedly calling copyBits at every	point along the line.  If drawFirstPoint is false, then omit	the first point so as not to overstrike at line junctions."	| offset point1 point2 forwards |	"Always draw down, or at least left-to-right"	forwards _ (startPoint y = stopPoint y and: [startPoint x < stopPoint x])				or: [startPoint y < stopPoint y].	forwards		ifTrue: [point1 _ startPoint. point2 _ stopPoint]		ifFalse: [point1 _ stopPoint. point2 _ startPoint].	sourceForm == nil ifTrue:		[destX _ point1 x.		destY _ point1 y]		ifFalse:		[width _ sourceForm width.		height _ sourceForm height.		offset _ sourceForm offset.		destX _ (point1 x + offset x) rounded.		destY _ (point1 y + offset y) rounded].	"Note that if not forwards, then the first point is the last and vice versa.	We agree to always paint stopPoint, and to optionally paint startPoint."	(drawFirstPoint or: [forwards == false  "ie this is stopPoint"])		ifTrue: [self copyBits].	self drawLoopX: (point2 x - point1 x) rounded 				  Y: (point2 y - point1 y) rounded.	(drawFirstPoint or: [forwards  "ie this is stopPoint"])		ifTrue: [self copyBits].! !!BitBlt methodsFor: 'line drawing'!drawLoopX: xDelta Y: yDelta 	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and	maintains a potential, P. When P's sign changes, it is time to move in	the minor direction as well. This particular version does not write the	first and last points, so that these can be called for as needed in client code.	Optional. See Object documentation whatIsAPrimitive."	| dx dy px py P |	<primitive: 104>	dx _ xDelta sign.	dy _ yDelta sign.	px _ yDelta abs.	py _ xDelta abs.	"self copyBits."	py > px		ifTrue: 			["more horizontal"			P _ py // 2.			1 to: py do: 				[:i |				destX _ destX + dx.				(P _ P - px) < 0 ifTrue: 						[destY _ destY + dy.						P _ P + py].				i < py ifTrue: [self copyBits]]]		ifFalse: 			["more vertical"			P _ px // 2.			1 to: px do:				[:i |				destY _ destY + dy.				(P _ P - py) < 0 ifTrue: 						[destX _ destX + dx.						P _ P + px].				i < px ifTrue: [self copyBits]]]! !!BitBlt methodsFor: 'private'!paintBits	"Perform the paint operation, which requires two calls to BitBlt."	| color oldMap saveRule |	sourceForm depth = 1 ifFalse: 		[^ self halt: 'paint operation is only defined for 1-bit deep sourceForms'].	saveRule _ combinationRule.	color _ halftoneForm.  halftoneForm _ nil.	oldMap _ colorMap.	"Map 1's to ALL ones, not just one"	self colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).	combinationRule _ Form erase.	self copyBits. 		"Erase the dest wherever the source is 1"	halftoneForm _ color.	combinationRule _ Form under.	self copyBits.	"then OR, with whatever color, into the hole"	colorMap _ oldMap.	combinationRule _ saveRule" | dot |dot _ Form dotOfSize: 32.((BitBlt destForm: Display		sourceForm: dot		fillColor: Color lightGray		combinationRule: Form paint		destOrigin: Sensor cursorPoint		sourceOrigin: 0@0		extent: dot extent		clipRect: Display boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF)) copyBits"! !!BitBlt methodsFor: 'private'!setDestForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect	| aPoint |	destForm _ df.	sourceForm _ sf.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ cr.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourceOrigin x.	sourceY _ sourceOrigin y.	width _ extent x.	height _ extent y.	aPoint _ clipRect origin.	clipX _ aPoint x.	clipY _ aPoint y.	aPoint _ clipRect corner.	clipWidth _ aPoint x - clipX.	clipHeight _ aPoint y - clipY.	colorMap _ sourceForm colormapIfNeededForDepth: destForm depth.! !!BitBlt class methodsFor: 'instance creation' stamp: 'jm 11/16/97 09:03'!bitPeekerFromForm: sourceForm	"Answer an instance to be used extract individual pixels from the given Form. The destination for a 1x1 copyBits will be the low order bits of (bits at: 1)."	| pixPerWord |	pixPerWord _ 32 // sourceForm depth.	^ self destForm: (Form extent: pixPerWord@1 depth: sourceForm depth)	 	sourceForm: sourceForm		halftoneForm: nil		combinationRule: Form over		destOrigin: (pixPerWord - 1)@0		sourceOrigin: 0@0		extent: 1@1		clipRect: (0@0 extent: pixPerWord@1)! !!BitBlt class methodsFor: 'examples' stamp: 'di 12/1/97 12:08'!alphaBlendDemo	"To run this demo, use...		Display restoreAfter: [BitBlt alphaBlendDemo]		Displays 10 alphas, then lets you paint.  Option-Click to stop painting."	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk 3/10/97"		"This version uses a sliding buffer for painting that keeps pixels in 32 bits	as long as they are in the buffer, so as not to lose info by converting down	to display resolution and back up to 32 bits at each operation. - di 3/15/97"	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  	"compute color maps if needed"	Display depth <= 8 ifTrue: [		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.		map32toD _ Color cachedColormapFrom: 32 to: Display depth].	"display 10 different alphas, across top of screen"	buff _ Form extent: 500@50 depth: 32.	dispToBuff _ BitBlt toForm: buff.	dispToBuff colorMap: mapDto32.	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)						fillColor: (Color red alpha: i/10)						rule: Form blend].	buffToDisplay _ BitBlt toForm: Display.	buffToDisplay colorMap: map32toD.	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.	"Create a brush with radially varying alpha"	brush _ Form extent: 30@30 depth: 32.	1 to: 5 do: 		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)				fillColor: (Color red alpha: 0.02 * i - 0.01)				at: brush extent // 2].	"Now paint with the brush using alpha blending."	buffSize _ 100.	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"	dispToBuff colorMap: mapDto32.	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"	brushToBuff sourceForm: brush; sourceOrigin: 0@0.	brushToBuff combinationRule: Form blend.	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"	[Sensor yellowButtonPressed] whileFalse:		[prevP _ nil.		buffRect _ Sensor cursorPoint - (buffSize // 2) extent: buff extent.		dispToBuff copyFrom: buffRect in: Display to: 0@0.		[Sensor redButtonPressed] whileTrue:			["Here is the painting loop"			p _ Sensor cursorPoint - (brush extent // 2).			(prevP == nil or: [prevP ~= p]) ifTrue:				[prevP == nil ifTrue: [prevP _ p].				(p dist: prevP) > buffSize ifTrue:					["Stroke too long to fit in buffer -- clip to buffer,						and next time through will do more of it"					theta _ (p-prevP) theta.					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].				brushRect _ p extent: brush extent.				(buffRect containsRect: brushRect) ifFalse:					["Brush is out of buffer region.  Scroll the buffer,						and fill vacated regions from the display"					delta _ brushRect amountToTranslateWithin: buffRect.					buffToBuff copyFrom: buff boundingBox in: buff to: delta.					newBuffRect _ buffRect translateBy: delta negated.					(newBuffRect areasOutside: buffRect) do:						[:r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin].					buffRect _ newBuffRect].				"Interpolate from prevP to p..."				brushToBuff drawFrom: prevP - buffRect origin									to: p - buffRect origin									withFirstPoint: false.				"Update (only) the altered pixels of the destination"				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.				prevP _ p]]]! !!BitBlt class methodsFor: 'examples' stamp: 'di 12/1/97 12:09'!antiAliasDemo 	"To run this demo, use...		Display restoreAfter: [BitBlt antiAliasDemo]	Goes immediately into on-screen paint mode.  Option-Click to stop painting."	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk 3/10/97"		"This version uses a sliding buffer for painting that keeps pixels in 32 bits	as long as they are in the buffer, so as not to lose info by converting down	to display resolution and back up to 32 bits at each operation. - di 3/15/97"		"This version also uses WarpBlt to paint into twice as large a buffer,	and then use smoothing when reducing back down to the display.	In fact this same routine will now work for 3x3 soothing as well.	Remove the statements 'buff displayAt: 0@0' to hide the buffer. - di 3/19/97"	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect scale p0 |  	"compute color maps if needed"	Display depth <= 8 ifTrue: [		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.		map32toD _ Color cachedColormapFrom: 32 to: Display depth].	"Create a brush with radially varying alpha"	brush _ Form extent: 3@3 depth: 32.	brush fill: brush boundingBox fillColor: (Color red alpha: 0.05).	brush fill: (1@1 extent: 1@1) fillColor: (Color red alpha: 0.2).	scale _ 2.  "Actual drawing happens at this magnification"	"Scale brush up for painting in magnified buffer"	brush _ brush magnify: brush boundingBox by: scale.	"Now paint with the brush using alpha blending."	buffSize _ 100.	buff _ Form extent: (brush extent + buffSize) * scale depth: 32.  "Travelling 32-bit buffer"	dispToBuff _ (WarpBlt toForm: buff)  "From Display to buff - magnify by 2"		sourceForm: Display;		colorMap: mapDto32;		combinationRule: Form over.	brushToBuff _ (BitBlt toForm: buff)  "From brush to buff"		sourceForm: brush;		sourceOrigin: 0@0;		combinationRule: Form blend.	buffToDisplay _ (WarpBlt toForm: Display)  "From buff to Display - shrink by 2"		sourceForm: buff;		colorMap: map32toD;		cellSize: scale;  "...and use smoothing"		combinationRule: Form over.	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"	[Sensor yellowButtonPressed] whileFalse:		[prevP _ nil.		buffRect _ Sensor cursorPoint - (buff extent // scale // 2) extent: buff extent // scale.		p0 _ (buff extent // 2) - (buffRect extent // 2).		dispToBuff copyQuad: buffRect innerCorners toRect: buff boundingBox.buff displayAt: 0@0.  "** remove to hide sliding buffer **"		[Sensor redButtonPressed] whileTrue:			["Here is the painting loop"			p _ Sensor cursorPoint - buffRect origin + p0.  "p, prevP are rel to buff origin"			(prevP == nil or: [prevP ~= p]) ifTrue:				[prevP == nil ifTrue: [prevP _ p].				(p dist: prevP) > (buffSize-1) ifTrue:					["Stroke too long to fit in buffer -- clip to buffer,						and next time through will do more of it"					theta _ (p-prevP) theta.					p _ ((theta cos@theta sin) * (buffSize-2) asFloat + prevP) truncated].				brushRect _ p extent: brush extent.				((buff boundingBox insetBy: scale) containsRect: brushRect) ifFalse:					["Brush is out of buffer region.  Scroll the buffer,						and fill vacated regions from the display"					delta _ (brushRect amountToTranslateWithin: (buff boundingBox insetBy: scale)) // scale.					buffToBuff copyFrom: buff boundingBox in: buff to: delta*scale.					newBuffRect _ buffRect translateBy: delta negated.					p _ p translateBy: delta*scale.					prevP _ prevP translateBy: delta*scale.					(newBuffRect areasOutside: buffRect) do:						[:r | dispToBuff copyQuad: r innerCorners toRect: (r origin - newBuffRect origin*scale extent: r extent*scale)].					buffRect _ newBuffRect].				"Interpolate from prevP to p..."				brushToBuff drawFrom: prevP to: p withFirstPoint: false.buff displayAt: 0@0.  "** remove to hide sliding buffer **"				"Update (only) the altered pixels of the destination"				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.				updateRect _ updateRect origin // scale * scale						corner: updateRect corner + scale // scale * scale.				buffToDisplay copyQuad: updateRect innerCorners							toRect: (updateRect origin // scale + buffRect origin										extent: updateRect extent // scale).				prevP _ p]]]! !!BitBlt class methodsFor: 'examples'!exampleOne	"This tests BitBlt by displaying the result of all sixteen combination rules that BitBlt is capable of using. (Please see the comment in BitBlt for the meaning of the combination rules)."	| path |	path _ Path new.	0 to: 3 do: [:i | 0 to: 3 do: [:j | path add: j * 100 @ (i * 75)]].	Display fillWhite.	path _ path translateBy: 60 @ 40.	1 to: 16 do: [:index | BitBlt			exampleAt: (path at: index)			rule: index - 1			fillColor: Color black]	"BitBlt exampleOne"! !!BitBlt class methodsFor: 'private'!exampleAt: originPoint rule: rule fillColor: mask 	"This builds a source and destination form and copies the source to the	destination using the specifed rule and mask. It is called from the method	named exampleOne."	| s d border aBitBlt | 	border_Form extent: 32@32.	border fillBlack.	border fill: (1@1 extent: 30@30) fillColor: Color white.	s _ Form extent: 32@32.	s fillWhite.	s fillBlack: (7@7 corner: 25@25).	d _ Form extent: 32@32.	d fillWhite.	d fillBlack: (0@0 corner: 32@16).	s displayOn: Display at: originPoint.	border displayOn: Display at: originPoint rule: Form under.	d displayOn: Display at: originPoint + (s width @0).	border displayOn: Display at: originPoint + (s width @0) rule: Form under.	d displayOn: Display at: originPoint + (s extent // (2 @ 1)).	aBitBlt _ BitBlt		destForm: Display		sourceForm: s		fillColor: mask		combinationRule: rule		destOrigin: originPoint + (s extent // (2 @ 1))		sourceOrigin: 0 @ 0		extent: s extent		clipRect: Display computeBoundingBox.	aBitBlt copyBits.	border 		displayOn: Display at: originPoint + (s extent // (2 @ 1))		rule: Form under.   	"BitBlt exampleAt: 100@100 rule: Form over fillColor: Display gray"! !BitBltSimulation comment:'This class implements BitBlt, much as specified in the Blue Book spec.Performance has been enhanced through the use of pointer variables such as sourceIndex and destIndex, and by separating several special cases of the inner loop.Operation has been extended to color, with support for 1, 2, 4, 8, 16, and 32-bit pixel sizes.  Conversion between different pixel sizes is facilitated by accepting an optional color map.In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWordThis implementation has also been fitted with an experimental "warp drive" that allows abritrary scaling and rotation (and even limited affine deformations) with all BitBlt storage modes supported.'!!BitBltSimulation methodsFor: 'interpreter interface'!drawLoopX: xDelta Y: yDelta 	"This is the primitive implementation of the line-drawing loop.	See the comments in BitBlt>>drawLoopX:Y:"	| dx1 dy1 px py P affL affR affT affB |	xDelta > 0		ifTrue: [dx1 _ 1]		ifFalse: [xDelta = 0				ifTrue: [dx1 _ 0]				ifFalse: [dx1 _ -1]].	yDelta > 0		ifTrue: [dy1 _ 1]		ifFalse: [yDelta = 0				ifTrue: [dy1 _ 0]				ifFalse: [dy1 _ -1]].	px _ yDelta abs.	py _ xDelta abs.	affL _ affT _ 9999.  "init null rectangle"	affR _ affB _ -9999.	py > px		ifTrue: 			["more horizontal"			P _ py // 2.			1 to: py do: 				[:i |				destX _ destX + dx1.				(P _ P - px) < 0 ifTrue: 					[destY _ destY + dy1.					P _ P + py].				i < py ifTrue:					[self copyBits.					(affectedL < affectedR and: [affectedT < affectedB]) ifTrue:						["Affected rectangle grows along the line"						affL _ affL min: affectedL.						affR _ affR max: affectedR.						affT _ affT min: affectedT.						affB _ affB max: affectedB.						(affR - affL) * (affB - affT) > 4000 ifTrue:							["If affected rectangle gets large, update it in chunks"							affectedL _ affL.  affectedR _ affR.							affectedT _ affT.  affectedB _ affB.							interpreterProxy showDisplayBits.							affL _ affT _ 9999.  "init null rectangle"							affR _ affB _ -9999]].					]]]		ifFalse: 			["more vertical"			P _ px // 2.			1 to: px do:				[:i |				destY _ destY + dy1.				(P _ P - py) < 0 ifTrue: 					[destX _ destX + dx1.					P _ P + px].				i < px ifTrue:					[self copyBits.					(affectedL < affectedR and: [affectedT < affectedB]) ifTrue:						["Affected rectangle grows along the line"						affL _ affL min: affectedL.						affR _ affR max: affectedR.						affT _ affT min: affectedT.						affB _ affB max: affectedB.						(affR - affL) * (affB - affT) > 4000 ifTrue:							["If affected rectangle gets large, update it in chunks"							affectedL _ affL.  affectedR _ affR.							affectedT _ affT.  affectedB _ affB.							interpreterProxy showDisplayBits.							affL _ affT _ 9999.  "init null rectangle"							affR _ affB _ -9999]].					]]].	"Remaining affected rect"	affectedL _ affL.  affectedR _ affR.	affectedT _ affT.  affectedB _ affB.	"store destX, Y back"		interpreterProxy storeInteger: BBDestXIndex ofObject: bitBltOop withValue: destX.	interpreterProxy storeInteger: BBDestYIndex ofObject: bitBltOop withValue: destY.! !!BitBltSimulation methodsFor: 'interpreter interface'!loadBitBltFrom: bbObj	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!!"	| destBitsSize destWidth destHeight sourceBitsSize sourcePixPerWord cmSize halftoneBits |	bitBltOop _ bbObj.	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.	(interpreterProxy failed		or: [combinationRule < 0 or: [combinationRule > 29]])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.	noSource _ self ignoreSourceOrHalftone: sourceForm.	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bitBltOop.		((interpreterProxy isPointers: destForm) and: [(interpreterProxy lengthOf: destForm) >= 4])			ifFalse: [^ false].		destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.		destBitsSize _ interpreterProxy byteLengthOf: destBits.		destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.		destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.		(destWidth >= 0 and: [destHeight >= 0])			ifFalse: [^ false].		destPixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.		pixPerWord _ 32 // destPixSize.		destRaster _ destWidth + (pixPerWord-1) // pixPerWord.		((interpreterProxy isWordsOrBytes: destBits)			and: [destBitsSize = (destRaster * destHeight * 4)])			ifFalse: [^ false].		destX _ interpreterProxy fetchIntegerOrTruncFloat: BBDestXIndex ofObject: bitBltOop.	destY _ interpreterProxy fetchIntegerOrTruncFloat: BBDestYIndex ofObject: bitBltOop.	width _ interpreterProxy fetchIntegerOrTruncFloat: BBWidthIndex ofObject: bitBltOop.	height _ interpreterProxy fetchIntegerOrTruncFloat: BBHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	noSource ifTrue:		[sourceX _ sourceY _ 0]		ifFalse: 		[((interpreterProxy isPointers: sourceForm) and: [(interpreterProxy lengthOf: sourceForm) >= 4])			ifFalse: [^ false].		sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.		sourceBitsSize _ interpreterProxy byteLengthOf: sourceBits.		srcWidth _ interpreterProxy fetchIntegerOrTruncFloat: FormWidthIndex ofObject: sourceForm.		srcHeight _ interpreterProxy fetchIntegerOrTruncFloat: FormHeightIndex ofObject: sourceForm.		(srcWidth >= 0 and: [srcHeight >= 0])			ifFalse: [^ false].		sourcePixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.		sourcePixPerWord _ 32 // sourcePixSize.		sourceRaster _ srcWidth + (sourcePixPerWord-1) // sourcePixPerWord.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourceRaster * srcHeight * 4)])			ifFalse: [^ false].		colorMap _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.		"ColorMap, if not nil, must be longWords, and 		2^N long, where N = sourcePixSize for 1, 2, 4, 8 bits, 		or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits."		colorMap = interpreterProxy nilObject ifFalse:			[(interpreterProxy isWords: colorMap)			ifTrue:			[cmSize _ interpreterProxy lengthOf: colorMap.			cmBitsPerColor _ 0.			cmSize = 512 ifTrue: [cmBitsPerColor _ 3].			cmSize = 4096 ifTrue: [cmBitsPerColor _ 4].			cmSize = 32768 ifTrue: [cmBitsPerColor _ 5].			interpreterProxy primIndex ~= 147 ifTrue:				["WarpBlt has different checks on the color map"				sourcePixSize <= 8				ifTrue: [cmSize = (1 << sourcePixSize) ifFalse: [^ false] ]				ifFalse: [cmBitsPerColor = 0 ifTrue: [^ false] ]]			]			ifFalse: [^ false]].		sourceX _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceXIndex ofObject: bitBltOop.		sourceY _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceYIndex ofObject: bitBltOop].	noHalftone ifFalse: 		[((interpreterProxy isPointers: halftoneForm) and: [(interpreterProxy lengthOf: halftoneForm) >= 4])		ifTrue:		["Old-style 32xN monochrome halftone Forms"		halftoneBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: halftoneForm.		halftoneHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: halftoneForm.		(interpreterProxy isWords: halftoneBits)			ifFalse: [noHalftone _ true]]		ifFalse:		["New spec accepts, basically, a word array"		((interpreterProxy isPointers: halftoneForm) not			and: [interpreterProxy isWords: halftoneForm])			ifFalse: [^ false].		halftoneBits _ halftoneForm.		halftoneHeight _ interpreterProxy lengthOf: halftoneBits].	halftoneBase _ halftoneBits + 4].	clipX _ interpreterProxy fetchIntegerOrTruncFloat: BBClipXIndex ofObject: bitBltOop.	clipY _ interpreterProxy fetchIntegerOrTruncFloat: BBClipYIndex ofObject: bitBltOop.	clipWidth _ interpreterProxy fetchIntegerOrTruncFloat: BBClipWidthIndex ofObject: bitBltOop.	clipHeight _ interpreterProxy fetchIntegerOrTruncFloat: BBClipHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].	^ true! !!BitBltSimulation methodsFor: 'interpreter interface'!loadScannerFrom: bbObj	start: start stop: stop string: string rightX: rightX	stopArray: stopArray displayFlag: displayFlag	self inline: false.	"Load arguments and Scanner state"	scanStart _ start.	scanStop _ stop.	scanString _ string.	scanRightX _ rightX.	scanStopArray _ stopArray.	scanDisplayFlag _ displayFlag.	interpreterProxy success: (		(interpreterProxy isPointers: scanStopArray)			and: [(interpreterProxy lengthOf: scanStopArray) >= 1]).	scanXTable _ interpreterProxy fetchPointer: BBXTableIndex ofObject: bbObj.	interpreterProxy success: (		(interpreterProxy isPointers: scanXTable)			and: [(interpreterProxy lengthOf: scanXTable) >= 1]).	"width and sourceX may not be set..."	interpreterProxy storeInteger: BBWidthIndex ofObject: bbObj withValue: 0.	interpreterProxy storeInteger: BBSourceXIndex ofObject: bbObj withValue: 0.	"Now load BitBlt state if displaying"	scanDisplayFlag		ifTrue: [interpreterProxy success: (self loadBitBltFrom: bbObj)]		ifFalse: [bitBltOop _ bbObj.				destX _ interpreterProxy fetchIntegerOrTruncFloat: BBDestXIndex ofObject: bbObj].	^interpreterProxy failed not! !!BitBltSimulation methodsFor: 'interpreter interface'!scanCharacters	| left top lastIndex charVal ascii sourceX2 nextDestX |	scanDisplayFlag ifTrue:		[self clipRange.  "Need to get true x, y for affectedRectangle"		left _ dx.		top _ dy].	lastIndex _ scanStart.	[lastIndex <= scanStop]		whileTrue: [			charVal _ interpreterProxy stObject: scanString at: lastIndex.			ascii _ interpreterProxy integerValueOf: charVal.			interpreterProxy failed ifTrue: [^ nil].			stopCode _ interpreterProxy stObject: scanStopArray at: ascii + 1.			interpreterProxy failed ifTrue: [^ nil].			stopCode = interpreterProxy nilObject				ifFalse: [^ self returnAt: ascii + 1							 lastIndex: lastIndex								  left: left								  top: top].			sourceX _ interpreterProxy stObject: scanXTable at: ascii + 1.			sourceX2 _ interpreterProxy stObject: scanXTable at: ascii + 2.			interpreterProxy failed ifTrue: [^ nil].			(interpreterProxy isIntegerObject: sourceX) & (interpreterProxy isIntegerObject: sourceX2)				ifTrue: [sourceX _ interpreterProxy integerValueOf: sourceX.						sourceX2 _ interpreterProxy integerValueOf: sourceX2]				ifFalse: [interpreterProxy primitiveFail. ^ nil].			nextDestX _ destX + (width _ sourceX2 - sourceX).			nextDestX > scanRightX				ifTrue: [^ self returnAt: CrossedX							 lastIndex: lastIndex								  left: left								  top: top].			scanDisplayFlag ifTrue: [self copyBits].			destX _ nextDestX.			interpreterProxy storeInteger: BBDestXIndex ofObject: bitBltOop withValue: destX.			lastIndex _ lastIndex + 1].	self returnAt: EndOfRun		 lastIndex: scanStop			  left: left			  top: top! !!BitBltSimulation methodsFor: 'interpreter interface'!setInterpreter: anInterpreter	"Interface for InterpreterSimulator. Allows BitBltSimulation object to send messages to the interpreter. The translator will replace sends to 'interpreterProxy' with sends to self, as if BitBltSimulation were part of the interpreter."	interpreterProxy _ anInterpreter.! !!BitBltSimulation methodsFor: 'accessing'!affectedBottom	^affectedB! !!BitBltSimulation methodsFor: 'accessing'!affectedLeft	^affectedL! !!BitBltSimulation methodsFor: 'accessing'!affectedRight	^affectedR! !!BitBltSimulation methodsFor: 'accessing'!affectedTop	^affectedT! !!BitBltSimulation methodsFor: 'accessing'!stopReason	^stopCode! !!BitBltSimulation methodsFor: 'accessing'!targetForm	"Return the destination form of a copyBits or scanCharacters operation."	^destForm! !!BitBltSimulation methodsFor: 'setup'!checkSourceOverlap	| t |	"check for possible overlap of source and destination"	(sourceForm = destForm and: [dy >= sy]) ifTrue:		[dy > sy ifTrue:			["have to start at bottom"			vDir _ -1.			sy _ sy + bbH - 1.			dy _ dy + bbH - 1]		ifFalse:			[dx > sx ifTrue:				["y's are equal, but x's are backward"				hDir _ -1.				sx _ sx + bbW - 1.				"start at right"				dx _ dx + bbW - 1.				"and fix up masks"				nWords > 1 ifTrue: 					[t _ mask1.					mask1 _ mask2.					mask2 _ t]]].		"Dest inits may be affected by this change"		destIndex _ (destBits + 4) + (dy * destRaster + (dx // pixPerWord) *4).		destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir))]! !!BitBltSimulation methodsFor: 'setup'!clipRange	"clip and adjust source origin and extent appropriately"	"first in x"	destX >= clipX		ifTrue: [sx _ sourceX.				dx _ destX.				bbW _ width]		ifFalse: [sx _ sourceX + (clipX - destX).				bbW _ width - (clipX - destX).				dx _ clipX].	(dx + bbW) > (clipX + clipWidth)		ifTrue: [bbW _ bbW - ((dx + bbW) - (clipX + clipWidth))].	"then in y"	destY >= clipY		ifTrue: [sy _ sourceY.				dy _ destY.				bbH _ height]		ifFalse: [sy _ sourceY + clipY - destY.				bbH _ height - (clipY - destY).				dy _ clipY].	(dy + bbH) > (clipY + clipHeight)		ifTrue: [bbH _ bbH - ((dy + bbH) - (clipY + clipHeight))].	noSource ifTrue: [^ nil].	sx < 0		ifTrue: [dx _ dx - sx.				bbW _ bbW + sx.				sx _ 0].	sx + bbW > srcWidth		ifTrue: [bbW _ bbW - (sx + bbW - srcWidth)].	sy < 0		ifTrue: [dy _ dy - sy.				bbH _ bbH + sy.				sy _ 0].	sy + bbH > srcHeight		ifTrue: [bbH _ bbH - (sy + bbH - srcHeight)]! !!BitBltSimulation methodsFor: 'setup'!copyBits	self clipRange.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil]. 	self destMaskAndPointerInit.	bitCount _ 0.	noSource		ifTrue: [self copyLoopNoSource]		ifFalse: [self checkSourceOverlap.				(sourcePixSize ~= destPixSize					or: [colorMap ~= interpreterProxy nilObject])					ifTrue: [self copyLoopPixMap]					ifFalse: [self sourceSkewAndPointerInit.							self copyLoop]]. 	combinationRule = 22 ifTrue:		["zero width and height; return the count"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		interpreterProxy pop: 1.		^ interpreterProxy pushInteger: bitCount]. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !!BitBltSimulation methodsFor: 'setup'!destMaskAndPointerInit	"Compute masks for left and right destination words"	| startBits pixPerM1 endBits |	pixPerM1 _ pixPerWord - 1.  "A mask, assuming power of two"	"how many pixels in first word"	startBits _ pixPerWord - (dx bitAnd: pixPerM1).	mask1 _ AllOnes >> (32 - (startBits*destPixSize)).	"how many pixels in last word"	endBits _ ((dx + bbW - 1) bitAnd: pixPerM1) + 1.	mask2 _ AllOnes << (32 - (endBits*destPixSize)).	"determine number of words stored per line; merge masks if only 1"	bbW < startBits		ifTrue: [mask1 _ mask1 bitAnd: mask2.				mask2 _ 0.				nWords _ 1]		ifFalse: [nWords _ (bbW - startBits) + pixPerM1 // pixPerWord + 1].	hDir _ vDir _ 1. "defaults for no overlap with source"	"calculate byte addr and delta, based on first word of data"	"Note raster and nwords are longs, not bytes"	destIndex _ (destBits + 4) + (dy * destRaster + (dx // pixPerWord) *4).	destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir)).  "byte addr delta"! !!BitBltSimulation methodsFor: 'setup'!ignoreSourceOrHalftone: formPointer	formPointer = interpreterProxy nilObject ifTrue: [ ^true ].	combinationRule = 0 ifTrue: [ ^true ].	combinationRule = 5 ifTrue: [ ^true ].	combinationRule = 10 ifTrue: [ ^true ].	combinationRule = 15 ifTrue: [ ^true ].	^false! !!BitBltSimulation methodsFor: 'setup'!returnAt: stopIndex lastIndex: lastIndex left: left top: top	stopCode _ interpreterProxy stObject: scanStopArray at: stopIndex.	interpreterProxy failed ifTrue: [^ nil].	interpreterProxy storeInteger: BBLastIndex ofObject: bitBltOop withValue: lastIndex.	scanDisplayFlag ifTrue: [		"Now we know extent of affected rectangle"		affectedL _ left.		affectedR _ bbW + dx.		affectedT _ top.		affectedB _ bbH + dy.	].! !!BitBltSimulation methodsFor: 'setup'!sourceSkewAndPointerInit	"This is only used when source and dest are same depth,	ie, when the barrel-shift copy loop is used."	| dWid sxLowBits dxLowBits pixPerM1 |	pixPerM1 _ pixPerWord - 1.  "A mask, assuming power of two"	sxLowBits _ sx bitAnd: pixPerM1.	dxLowBits _ dx bitAnd: pixPerM1.	"check if need to preload buffer	(i.e., two words of source needed for first word of destination)"	hDir > 0 ifTrue:		["n Bits stored in 1st word of dest"		dWid _ bbW min: pixPerWord - dxLowBits.		preload _ (sxLowBits + dWid) > pixPerM1]	ifFalse:		[dWid _ bbW min: dxLowBits + 1.		preload _ (sxLowBits - dWid + 1) < 0].	"calculate right-shift skew from source to dest"	skew _ (sxLowBits - dxLowBits) * destPixSize.  " -32..32 "	preload ifTrue: 		[skew < 0			ifTrue: [skew _ skew+32]			ifFalse: [skew _ skew-32]].	"Calc byte addr and delta from longWord info"	sourceIndex _ (sourceBits + 4) + (sy * sourceRaster + (sx // (32//sourcePixSize)) *4).	"calculate increments from end of 1 line to start of next"	sourceDelta _ 4 * ((sourceRaster * vDir) - (nWords * hDir)).	preload ifTrue:		["Compensate for extra source word fetched"		sourceDelta _ sourceDelta - (4*hDir)].! !!BitBltSimulation methodsFor: 'setup'!warpBits	| ns |	ns _ noSource.  noSource _ true.		self clipRange.  "noSource suppresses sourceRect clipping"		noSource _ ns.	(noSource or: [bbW <= 0 or: [bbH <= 0]]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil]. 	self destMaskAndPointerInit.	self warpLoop. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 12/30/97 14:42'!copyLoop	| prevWord thisWord skewWord halftoneWord mergeWord hInc y unskew skewMask notSkewMask mergeFnwith |	"This version of the inner loop assumes noSource = false."	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	hInc _ hDir*4.  "Byte delta"	"degenerate skew fixed for Sparc. 10/20/96 ikp"	skew == -32		ifTrue: [skew _ unskew _ skewMask _ 0]		ifFalse: [skew < 0			ifTrue:				[unskew _ skew+32.				skewMask _ AllOnes << (0-skew)]			ifFalse:				[skew == 0					ifTrue:						[unskew _ 0.						skewMask _ AllOnes]					ifFalse:						[unskew _ skew-32.						skewMask _ AllOnes >> skew]]].	notSkewMask _ skewMask bitInvert32.	noHalftone		ifTrue: [halftoneWord _ AllOnes.  halftoneHeight _ 0]		ifFalse: [halftoneWord _ interpreterProxy longAt: halftoneBase].	y _ dy.	1 to: bbH do: "here is the vertical loop"		[ :i |		halftoneHeight > 1 ifTrue:  "Otherwise, its always the same"			[halftoneWord _ interpreterProxy longAt:						(halftoneBase + (y \\ halftoneHeight * 4)).			y _ y + vDir].		preload ifTrue:			["load the 64-bit shifter"			prevWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc]			ifFalse:			[prevWord _ 0].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask1 bitAnd: mergeWord)					bitOr: (mask1 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc.		"This central horizontal loop requires no store masking"combinationRule = 3ifTrue: [2 to: nWords-1 do: "Special inner loop for STORE"			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			interpreterProxy longAt: destIndex put: (skewWord bitAnd: halftoneWord).			destIndex _ destIndex + hInc]] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + hInc]].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask2 bitAnd: mergeWord)					bitOr: (mask2 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 12/30/97 14:43'!copyLoopNoSource	| halftoneWord mergeWord mergeFnwith |	"Faster copyLoop when source not used.  hDir and vDir are both	positive, and perload and skew are unused"	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask1 bitAnd: mergeWord)					bitOr: (mask1 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.		"This central horizontal loop requires no store masking"combinationRule = 3ifTrue: [2 to: nWords-1 do: "Special inner loop for STORE"			[ :word |			interpreterProxy longAt: destIndex put: halftoneWord.			destIndex _ destIndex + 4].] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge"			[ :word |			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + 4].].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask2 bitAnd: mergeWord)					bitOr: (mask2 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4].	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 12/30/97 14:45'!copyLoopPixMap	"This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop."	| skewWord halftoneWord mergeWord destMask srcPixPerWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask nullMap mergeFnwith |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	"Additional inits peculiar to unequal source and dest pix size..."	srcPixPerWord _ 32//sourcePixSize.	"Check for degenerate shift values 4/28/97 ar"	sourcePixSize = 32 		ifTrue: [ sourcePixMask _ -1]		ifFalse: [ sourcePixMask _ (1 << sourcePixSize) - 1].	destPixSize = 32		ifTrue: [ destPixMask _ -1]		ifFalse: [ destPixMask _ (1 << destPixSize) - 1].	nullMap _ colorMap = interpreterProxy nilObject.	sourceIndex _ (sourceBits + 4) +					(sy * sourceRaster + (sx // srcPixPerWord) *4).	scrStartBits _ srcPixPerWord - (sx bitAnd: srcPixPerWord-1).	bbW < scrStartBits		ifTrue: [nSourceIncs _ 0]		ifFalse: [nSourceIncs _ (bbW - scrStartBits)//srcPixPerWord + 1].	sourceDelta _ (sourceRaster - nSourceIncs) * 4.	"Note following two items were already calculated in destmask setup!!"	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	endBits _ ((dx + bbW - 1) bitAnd: pixPerWord-1) + 1.	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		srcBitIndex _ (sx bitAnd: srcPixPerWord - 1)*sourcePixSize.		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self pickSourcePixels: bbW nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord   "See note below"							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self pickSourcePixels: startBits nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask]. 		"Here is the horizontal loop..."		1 to: nWords do: "here is the inner horizontal loop"			[ :word |			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self pickSourcePixels: endBits nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord   "See note below"							bitShift: (pixPerWord-endBits)*destPixSize]]				ifFalse: 				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self pickSourcePixels: pixPerWord nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]"NOTE: in both noted shifts above, we are shifting the right-justified output of pickSourcePixels so that it is aligned with the destination word.  Since it gets masked anyway, we could have just picked more pixels (startBits in the first case and destPixSize in the second), and it would have been simpler, but it is slower to run the pickSourcePixels loop.  CopyLoopAlphaHack takes advantage of this to avoid having to shift full-words in its alphaSource buffer" ! !!BitBltSimulation methodsFor: 'inner loop'!warpLoop	| skewWord halftoneWord mergeWord destMask startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy	  xDelta yDelta pBx pBy smoothingCount sourceMapOop nSteps t |	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation." 	(interpreterProxy fetchWordLengthOf: bitBltOop) >= (BBWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	pAx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+3 ofObject: bitBltOop.	deltaP12x _ self deltaFrom: pAx to: t nSteps: nSteps.	deltaP12x < 0 ifTrue: [pAx _ t - (nSteps*deltaP12x)].	pAy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+1 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+4 ofObject: bitBltOop.	deltaP12y _ self deltaFrom: pAy to: t nSteps: nSteps.	deltaP12y < 0 ifTrue: [pAy _ t - (nSteps*deltaP12y)].	pBx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+9 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+6 ofObject: bitBltOop.	deltaP43x _ self deltaFrom: pBx to: t nSteps: nSteps.	deltaP43x < 0 ifTrue: [pBx _ t - (nSteps*deltaP43x)].	pBy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+10 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+7 ofObject: bitBltOop.	deltaP43y _ self deltaFrom: pBy to: t nSteps: nSteps.	deltaP43y < 0 ifTrue: [pBy _ t - (nSteps*deltaP43y)].	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"	interpreterProxy argCount = 2		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.				sourceMapOop _ interpreterProxy stackValue: 0.				sourceMapOop = interpreterProxy nilObject				ifTrue: [sourcePixSize < 16 ifTrue:					["color map is required to smooth non-RGB dest"					^ interpreterProxy primitiveFail]]				ifFalse: [(interpreterProxy fetchWordLengthOf: sourceMapOop)							< (1 << sourcePixSize) ifTrue:					["sourceMap must be long enough for sourcePixSize"					^ interpreterProxy primitiveFail]]]		ifFalse: [smoothingCount _ 1.				sourceMapOop _ interpreterProxy nilObject].	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1]. 	destY to: clipY-1 do:		[ :i |	"Advance increments if there was clipping in y"		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y].	1 to: bbH do:		[ :i |		"here is the vertical loop..."		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps. 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pBx - (nSteps*xDelta)].		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps. 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pBy - (nSteps*yDelta)].		destX to: clipX-1 do:			[:word |	"Advance increments if there was clipping in x"			sx _ sx + xDelta.			sy _ sy + yDelta].		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self warpSourcePixels: bbW									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self warpSourcePixels: startBits									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]. 		1 to: nWords do:			[ :word |		"here is the inner horizontal loop..."			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]]				ifFalse:				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop].			].		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y.		destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'combination rules'!addWord: sourceWord with: destinationWord	^sourceWord + destinationWord! !!BitBltSimulation methodsFor: 'combination rules'!alphaBlend: sourceWord with: destinationWord	"Blend sourceWord with destinationWord, assuming both are 32-bit pixels.	The source is assumed to have 255*alpha in the high 8 bits of each pixel,	while the high 8 bits of the destinationWord will be ignored.	The blend produced is alpha*source + (1-alpha)*dest, with	the computation being performed independently on each color	component.  The high byte of the result will be 0."	| alpha unAlpha colorMask result blend shift |	self inline: false.	alpha _ sourceWord >> 24.  "High 8 bits of source pixel"	unAlpha _ 255 - alpha.	colorMask _ 16rFF.	result _ 0.	1 to: 3 do:		[:i | shift _ (i-1)*8.		blend _ (((sourceWord>>shift bitAnd: colorMask) * alpha)					+ ((destinationWord>>shift bitAnd: colorMask) * unAlpha))			 	+ 254 // 255 bitAnd: colorMask.		result _ result bitOr: blend<<shift].	^ result! !!BitBltSimulation methodsFor: 'combination rules'!bitAnd: sourceWord with: destinationWord	^sourceWord bitAnd: destinationWord! !!BitBltSimulation methodsFor: 'combination rules'!bitAndInvert: sourceWord with: destinationWord	^sourceWord bitAnd: destinationWord bitInvert32! !!BitBltSimulation methodsFor: 'combination rules'!bitInvertAnd: sourceWord with: destinationWord	^sourceWord bitInvert32 bitAnd: destinationWord! !!BitBltSimulation methodsFor: 'combination rules'!bitInvertAndInvert: sourceWord with: destinationWord	^sourceWord bitInvert32 bitAnd: destinationWord bitInvert32! !!BitBltSimulation methodsFor: 'combination rules'!bitInvertDestination: sourceWord with: destinationWord	^destinationWord bitInvert32! !!BitBltSimulation methodsFor: 'combination rules'!bitInvertOr: sourceWord with: destinationWord	^sourceWord bitInvert32 bitOr: destinationWord! !!BitBltSimulation methodsFor: 'combination rules'!bitInvertOrInvert: sourceWord with: destinationWord	^sourceWord bitInvert32 bitOr: destinationWord bitInvert32! !!BitBltSimulation methodsFor: 'combination rules'!bitInvertSource: sourceWord with: destinationWord	^sourceWord bitInvert32! !!BitBltSimulation methodsFor: 'combination rules'!bitInvertXor: sourceWord with: destinationWord	^sourceWord bitInvert32 bitXor: destinationWord! !!BitBltSimulation methodsFor: 'combination rules'!bitOr: sourceWord with: destinationWord	^sourceWord bitOr: destinationWord! !!BitBltSimulation methodsFor: 'combination rules'!bitOrInvert: sourceWord with: destinationWord	^sourceWord bitOr: destinationWord bitInvert32! !!BitBltSimulation methodsFor: 'combination rules'!bitXor: sourceWord with: destinationWord	^sourceWord bitXor: destinationWord! !!BitBltSimulation methodsFor: 'combination rules'!clearWord: source with: destination	^ 0! !!BitBltSimulation methodsFor: 'combination rules'!destinationWord: sourceWord with: destinationWord	^destinationWord! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 12/30/97 14:46'!merge: sourceWord with: destinationWord	| mergeFnwith |	"Sender warpLoop is too big to include this in-line"	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	^ self mergeFn: sourceWord with: destinationWord! !!BitBltSimulation methodsFor: 'combination rules'!partitionedAdd: word1 to: word2 nBits: nBits nPartitions: nParts	"Add word1 to word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask sum result |	mask _ (1 << nBits) - 1.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		sum _ (word1 bitAnd: mask) + (word2 bitAnd: mask).		sum <= mask  "result must not carry out of partition"			ifTrue: [result _ result bitOr: sum]			ifFalse: [result _ result bitOr: mask].		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules'!partitionedAND: word1 to: word2 nBits: nBits nPartitions: nParts	"AND word1 to word2 as nParts partitions of nBits each.	Any field of word1 not all-ones is treated as all-zeroes.	Used for erasing, eg, brush shapes prior to ORing in a color"	| mask result |	mask _ (1 << nBits) - 1.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		(word1 bitAnd: mask) = mask			ifTrue: [result _ result bitOr: (word2 bitAnd: mask)].		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules'!partitionedMax: word1 with: word2 nBits: nBits nPartitions: nParts	"Max word1 to word2 as nParts partitions of nBits each"	| mask result |	mask _ (1 << nBits) - 1.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		result _ result bitOr: ((word2 bitAnd: mask) max: (word1 bitAnd: mask)).		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules'!partitionedMin: word1 with: word2 nBits: nBits nPartitions: nParts	"Min word1 to word2 as nParts partitions of nBits each"	| mask result |	mask _ (1 << nBits) - 1.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		result _ result bitOr: ((word2 bitAnd: mask) min: (word1 bitAnd: mask)).		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules'!partitionedSub: word1 from: word2 nBits: nBits nPartitions: nParts	"Subtract word1 from word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask result p1 p2 |	mask _ (1 << nBits) - 1.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		p1 _ word1 bitAnd: mask.		p2 _ word2 bitAnd: mask.		p1 < p2  "result is really abs value of thedifference"			ifTrue: [result _ result bitOr: p2 - p1]			ifFalse: [result _ result bitOr: p1 - p2].		mask _ mask << nBits  "slide left to next partition"].	^ result! !!BitBltSimulation methodsFor: 'combination rules'!pixMask: sourceWord with: destinationWord	self inline: false.	^ self partitionedAND: sourceWord bitInvert32 to: destinationWord					nBits: destPixSize nPartitions: pixPerWord! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 12/27/97 10:39'!pixPaint: sourceWord with: destinationWord	self inline: false.	sourceWord = 0 ifTrue: [^ destinationWord].	^ sourceWord bitOr:		(self partitionedAND: sourceWord bitInvert32 to: destinationWord						nBits: destPixSize nPartitions: pixPerWord)! !!BitBltSimulation methodsFor: 'combination rules'!rgbAdd: sourceWord with: destinationWord	self inline: false.	destPixSize < 16 ifTrue:		["Add each pixel separately"		^ self partitionedAdd: sourceWord to: destinationWord						nBits: destPixSize nPartitions: pixPerWord].	destPixSize = 16 ifTrue:		["Add RGB components of each pixel separately"		^ (self partitionedAdd: sourceWord to: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedAdd: sourceWord>>16 to: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Add RGB components of the pixel separately"		^ self partitionedAdd: sourceWord to: destinationWord						nBits: 8 nPartitions: 3]! !!BitBltSimulation methodsFor: 'combination rules'!rgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, XOR the two and return the number of differing pixels.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| diff pixMask |	self inline: false.	destPixSize < 16 ifTrue:		["Just xor and count differing bits if not RGB"		diff _ sourceWord bitXor: destinationWord.		pixMask _ (1 bitShift: destPixSize) - 1.		[diff = 0] whileFalse:			[(diff bitAnd: pixMask) ~= 0 ifTrue: [bitCount _ bitCount + 1].			diff _ diff >> destPixSize].		^ destinationWord "for no effect"]. 	destPixSize = 16		ifTrue:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F).		diff _ (self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F)]		ifFalse:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16rFF)							+ (diff>>8 bitAnd: 16rFF)							+ (diff>>16 bitAnd: 16rFF)].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules'!rgbMax: sourceWord with: destinationWord	self inline: false.	destPixSize < 16 ifTrue:		["Max each pixel separately"		^ self partitionedMax: sourceWord with: destinationWord						nBits: destPixSize nPartitions: pixPerWord].	destPixSize = 16 ifTrue:		["Max RGB components of each pixel separately"		^ (self partitionedMax: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMax: sourceWord>>16 with: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Max RGB components of the pixel separately"		^ self partitionedMax: sourceWord with: destinationWord						nBits: 8 nPartitions: 3]! !!BitBltSimulation methodsFor: 'combination rules'!rgbMin: sourceWord with: destinationWord	self inline: false.	destPixSize < 16 ifTrue:		["Min each pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: destPixSize nPartitions: pixPerWord].	destPixSize = 16 ifTrue:		["Min RGB components of each pixel separately"		^ (self partitionedMin: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMin: sourceWord>>16 with: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Min RGB components of the pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: 8 nPartitions: 3]! !!BitBltSimulation methodsFor: 'combination rules'!rgbSub: sourceWord with: destinationWord	self inline: false.	destPixSize < 16 ifTrue:		["Sub each pixel separately"		^ self partitionedSub: sourceWord from: destinationWord						nBits: destPixSize nPartitions: pixPerWord].	destPixSize = 16 ifTrue:		["Sub RGB components of each pixel separately"		^ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Sub RGB components of the pixel separately"		^ self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3]! !!BitBltSimulation methodsFor: 'combination rules'!sourceWord: sourceWord with: destinationWord	^sourceWord! !!BitBltSimulation methodsFor: 'combination rules'!subWord: sourceWord with: destinationWord	^sourceWord - destinationWord! !!BitBltSimulation methodsFor: 'combination rules'!tallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Note that the source should be 	specified = destination, in order for the proper color map checks 	to be performed at setup.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| mapIndex pixMask shiftWord |	colorMap = interpreterProxy nilObject		ifTrue: [^ destinationWord "no op"].	destPixSize < 16 ifTrue:		["loop through all packed pixels."		pixMask _ (1<<destPixSize) - 1.		shiftWord _ destinationWord.		1 to: pixPerWord do:			[:i |			mapIndex _ shiftWord bitAnd: pixMask.			interpreterProxy storeWord: mapIndex ofObject: colorMap				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.			shiftWord _ shiftWord >> destPixSize].		^ destinationWord].	destPixSize = 16 ifTrue:		["Two pixels  Tally the right half..."		mapIndex _ self rgbMap: destinationWord from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.		"... and then left half"		mapIndex _ self rgbMap: destinationWord>>16 from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1]	ifFalse:		["Just one pixel."		mapIndex _ self rgbMap: destinationWord from: 8 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'pixel mapping'!deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments."	x2 > x1		ifTrue: [^ x2 - x1 + FixedPt1 // (n+1) + 1]		ifFalse: [x2 = x1 ifTrue: [^ 0].				^ 0 - (x1 - x2 + FixedPt1 // (n+1) + 1)]! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'di 12/30/97 20:45'!pickSourcePixels: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask	"This is intended to be expanded in-line; it merely calls the others"	self inline: true.	sourcePixSize >= 16 ifTrue:		[^ self pickSourcePixelsRGB: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask].	nullMap ifTrue:		[^ self pickSourcePixelsNullMap: nPix srcMask: sourcePixMask destMask: destPixMask].	^ self pickSourcePixels: nPix srcMask: sourcePixMask destMask: destPixMask! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'di 12/30/97 20:46'!pickSourcePixels: nPix srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for sourcePixSize <= 8		and colorMap notNil"	"Pick nPix pixels from the source, mapped by the	color map, and right-justify them in the resulting destWord."	| sourceWord destWord sourcePix destPix |	self inline: false.	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		"look up sourcePix in colorMap"		destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask.		destWord _ (destWord << destPixSize) bitOr: destPix.		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'di 12/30/97 20:46'!pickSourcePixelsNullMap: nPix srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for colorMap==nil.		SourcePixelSize is also known to be 8 bits or less."	"With no color map, pixels are just masked or zero-filled."	| sourceWord destWord sourcePix |	self inline: false.	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		destWord _ (destWord << destPixSize) 					bitOr: (sourcePix bitAnd: destPixMask).		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'di 12/30/97 20:46'!pickSourcePixelsRGB: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for sourcePixSize >= 16"	"Pick nPix pixels from the source, mapped by the	color map, and right-justify them in the resulting destWord.	Incoming pixels of 16 or 32 bits are first reduced to cmBitsPerColor.	With no color map, pixels are just masked or zero-filled or	if 16- or 32-bit pixels, the r, g, and b are so treated individually."	| sourceWord destWord sourcePix destPix |	self inline: false.	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		nullMap		ifTrue:			["Map between RGB pixels"			sourcePixSize = 16				ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]				ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]		ifFalse:			["RGB pixels first get reduced to cmBitsPerColor"			sourcePixSize = 16				ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]				ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor].			"Then look up sourcePix in colorMap"			destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask].		destWord _ (destWord << destPixSize) bitOr: destPix.		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord! !!BitBltSimulation methodsFor: 'pixel mapping'!rgbMap: sourcePixel from: nBitsIn to: nBitsOut	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."	| mask d srcPix destPix |	self inline: true.	(d _ nBitsOut - nBitsIn) > 0		ifTrue:			["Expand to more bits by zero-fill"			mask _ (1 << nBitsIn) - 1.  "Transfer mask"			srcPix _ sourcePixel << d.			mask _ mask << d.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix << d.			^ destPix + (srcPix bitAnd: mask)				 	+ (srcPix << d bitAnd: mask << nBitsOut)]		ifFalse:			["Compress to fewer bits by truncation"			d = 0 ifTrue: [^ sourcePixel].  "no compression"			sourcePixel = 0 ifTrue: [^ sourcePixel].  "always map 0 (transparent) to 0"			d _ nBitsIn - nBitsOut.			mask _ (1 << nBitsOut) - 1.  "Transfer mask"			srcPix _ sourcePixel >> d.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix >> d.			destPix _ destPix + (srcPix bitAnd: mask)					+ (srcPix >> d bitAnd: mask << nBitsOut).			destPix = 0 ifTrue: [^ 1].  "Dont fall into transparent by truncation"			^ destPix]! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'di 12/30/97 20:07'!smoothPix: n atXf: xf yf: yf dxh: dxh dyh: dyh dxv: dxv dyv: dyv	pixPerWord: srcPixPerWord pixelMask: sourcePixMask	sourceMap: sourceMap	| sourcePix r g b x y rgb bitsPerColor d nPix maxPix |	self inline: false.	r _ g _ b _ 0.  "Separate r, g, b components"	maxPix _ n*n.	x _ xf.  y _ yf.	nPix _ 0.  "actual number of pixels (not clipped and not transparent)"	0 to: n-1 do:		[:i |		0 to: n-1 do:			[:j |			sourcePix _ (self sourcePixAtX: x + (dxh*i) + (dxv*j)  >> BinaryPoint									y: y + (dyh*i) + (dyv*j)  >> BinaryPoint									pixPerWord: srcPixPerWord)									bitAnd: sourcePixMask.			(combinationRule=25 "PAINT" and: [sourcePix = 0]) ifFalse:  			["If not clipped and not transparent, then tally rgb values"			nPix _ nPix + 1.			sourcePixSize < 16				ifTrue: ["Get 24-bit RGB values from sourcemap table"						rgb _ (interpreterProxy fetchWord: sourcePix ofObject: sourceMap) bitAnd: 16rFFFFFF]				ifFalse: ["Already in RGB format"						sourcePixSize = 32						ifTrue: [rgb _ sourcePix bitAnd: 16rFFFFFF]						ifFalse: ["Note could be faster"								rgb _ self rgbMap: sourcePix from: 5 to: 8]].			r _ r + ((rgb >> 16) bitAnd: 16rFF).			g _ g + ((rgb >> 8) bitAnd: 16rFF).			b _ b + (rgb bitAnd: 16rFF).			]].		].	(nPix = 0 or: [combinationRule=25 "PAINT" and: [nPix < (maxPix//2)]])		ifTrue: [^ 0  "All pixels were 0, or most were transparent"].	colorMap ~= interpreterProxy nilObject		ifTrue: [bitsPerColor _ cmBitsPerColor]		ifFalse: [destPixSize = 16 ifTrue: [bitsPerColor _ 5].				destPixSize = 32 ifTrue: [bitsPerColor _ 8]].	d _ 8 - bitsPerColor.	rgb _ ((r // nPix >> d) << (bitsPerColor*2))		+ ((g // nPix >> d) << bitsPerColor)		+ ((b // nPix >> d)).	rgb = 0 ifTrue: [		"only generate zero if pixel is really transparent"		(r + g + b) > 0 ifTrue: [rgb _ 1]].	colorMap ~= interpreterProxy nilObject		ifTrue: [^ interpreterProxy fetchWord: rgb ofObject: colorMap]		ifFalse: [^ rgb]! !!BitBltSimulation methodsFor: 'pixel mapping'!sourcePixAtX: x y: y pixPerWord: srcPixPerWord	| sourceWord index |	self inline: true.	(x < 0 or: [x >= srcWidth]) ifTrue: [^ 0].	(y < 0 or: [y >= srcHeight]) ifTrue: [^ 0].	index _ (y * sourceRaster + (x // srcPixPerWord) *4).												"4 = BaseHeaderSize"	sourceWord _ interpreterProxy longAt: sourceBits + 4 + index.	^ sourceWord >> ((32-sourcePixSize) - (x\\srcPixPerWord*sourcePixSize))! !!BitBltSimulation methodsFor: 'pixel mapping' stamp: 'di 12/30/97 20:10'!warpSourcePixels: nPix xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	smoothing: n sourceMap: sourceMapOop	"Pick nPix pixels using these x- and y-incs, and map color if necess."	| destWord sourcePix sourcePixMask destPixMask srcPixPerWord destPix |	self inline: false.	sourcePixSize = 32		ifTrue: [ sourcePixMask _ -1]		ifFalse: [ sourcePixMask _ (1 << sourcePixSize) - 1].	destPixSize = 32		ifTrue: [ destPixMask _ -1]		ifFalse: [ destPixMask _ (1 << destPixSize) - 1].	srcPixPerWord _ 32 // sourcePixSize.	destWord _ 0.	1 to: nPix do:		[:i |		n > 1		ifTrue:			["Average n pixels and compute dest pixel from color map"			destPix _ (self smoothPix: n atXf: sx yf: sy				dxh: xDeltah//n dyh: yDeltah//n dxv: xDeltav//n dyv: yDeltav//n				pixPerWord: srcPixPerWord pixelMask: sourcePixMask				sourceMap: sourceMapOop)					bitAnd: destPixMask]		ifFalse:			["No smoothing -- just pick pixel and map if difft depths or color map supplied"			sourcePix _ (self sourcePixAtX: sx >> BinaryPoint									y: sy >> BinaryPoint									pixPerWord: srcPixPerWord)						bitAnd: sourcePixMask.			colorMap = interpreterProxy nilObject				ifTrue:				[destPixSize = sourcePixSize				ifTrue:					[destPix _ sourcePix]				ifFalse:					[sourcePixSize >= 16 ifTrue:						["Map between RGB pixels"						sourcePixSize = 16							ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]							ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]					ifFalse: [destPix _ sourcePix bitAnd: destPixMask]]]			ifFalse:				[sourcePixSize >= 16 ifTrue:					["RGB pixels first get reduced to cmBitsPerColor"					sourcePixSize = 16						ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]						ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor]].				"Then look up sourcePix in colorMap"				destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask]].		destWord _ (destWord << destPixSize) bitOr: destPix.		sx _ sx + xDeltah.		sy _ sy + yDeltah.		].	^ destWord! !!BitBltSimulation methodsFor: 'translation support' stamp: 'di 12/30/97 09:36'!initBBOpTable	self cCode: 'opTable[0+1] = (int)clearWordwith'.	self cCode: 'opTable[1+1] = (int)bitAndwith'.	self cCode: 'opTable[2+1] = (int)bitAndInvertwith'.	self cCode: 'opTable[3+1] = (int)sourceWordwith'.	self cCode: 'opTable[4+1] = (int)bitInvertAndwith'.	self cCode: 'opTable[5+1] = (int)destinationWordwith'.	self cCode: 'opTable[6+1] = (int)bitXorwith'.	self cCode: 'opTable[7+1] = (int)bitOrwith'.	self cCode: 'opTable[8+1] = (int)bitInvertAndInvertwith'.	self cCode: 'opTable[9+1] = (int)bitInvertXorwith'.	self cCode: 'opTable[10+1] = (int)bitInvertDestinationwith'.	self cCode: 'opTable[11+1] = (int)bitOrInvertwith'.	self cCode: 'opTable[12+1] = (int)bitInvertSourcewith'.	self cCode: 'opTable[13+1] = (int)bitInvertOrwith'.	self cCode: 'opTable[14+1] = (int)bitInvertOrInvertwith'.	self cCode: 'opTable[15+1] = (int)destinationWordwith'.	self cCode: 'opTable[16+1] = (int)destinationWordwith'.	self cCode: 'opTable[17+1] = (int)destinationWordwith'.	self cCode: 'opTable[18+1] = (int)addWordwith'.	self cCode: 'opTable[19+1] = (int)subWordwith'.	self cCode: 'opTable[20+1] = (int)rgbAddwith'.	self cCode: 'opTable[21+1] = (int)rgbSubwith'.	self cCode: 'opTable[22+1] = (int)rgbDiffwith'.	self cCode: 'opTable[23+1] = (int)tallyIntoMapwith'.	self cCode: 'opTable[24+1] = (int)alphaBlendwith'.	self cCode: 'opTable[25+1] = (int)pixPaintwith'.	self cCode: 'opTable[26+1] = (int)destinationWordwith'.	self cCode: 'opTable[27+1] = (int)destinationWordwith'.	self cCode: 'opTable[28+1] = (int)destinationWordwith'.	self cCode: 'opTable[29+1] = (int)destinationWordwith'.	self cCode: 'opTable[30+1] = (int)destinationWordwith'.	self cCode: 'opTable[31+1] = (int)destinationWordwith'.! !!BitBltSimulation class methodsFor: 'initialization'!initialize	"BitBltSimulation initialize" 	self initializeRuleTable.	"Mask constants"	AllOnes _ 16rFFFFFFFF.	BinaryPoint _ 14.	FixedPt1 _ 1 << BinaryPoint.  "Value of 1.0 in Warp's fixed-point representation" 	"Indices into stopConditions for scanning"	EndOfRun _ 257.	CrossedX _ 258. 	"Form fields"	FormBitsIndex _ 0.	FormWidthIndex _ 1.	FormHeightIndex _ 2.	FormDepthIndex _ 3. 	"BitBlt fields"	BBDestFormIndex _ 0.	BBSourceFormIndex _ 1.	BBHalftoneFormIndex _ 2.	BBRuleIndex _ 3.	BBDestXIndex _ 4.	BBDestYIndex _ 5.	BBWidthIndex _ 6.	BBHeightIndex _ 7.	BBSourceXIndex _ 8.	BBSourceYIndex _ 9.	BBClipXIndex _ 10.	BBClipYIndex _ 11.	BBClipWidthIndex _ 12.	BBClipHeightIndex _ 13.	BBColorMapIndex _ 14.	BBWarpBase _ 15.	BBLastIndex _ 15.	BBXTableIndex _ 16.! !!BitBltSimulation class methodsFor: 'initialization' stamp: 'di 12/30/97 09:00'!initializeRuleTable	"BitBltSimulation initializeRuleTable"	OpTable _ #(		"0" clearWord:with:		"1" bitAnd:with:		"2" bitAndInvert:with:		"3" sourceWord:with:		"4" bitInvertAnd:with:		"5" destinationWord:with:		"6" bitXor:with:		"7" bitOr:with:		"8" bitInvertAndInvert:with:		"9" bitInvertXor:with:		"10" bitInvertDestination:with:		"11" bitOrInvert:with:		"12" bitInvertSource:with:		"13" bitInvertOr:with:		"14" bitInvertOrInvert:with:		"15" destinationWord:with:		"16" destinationWord:with:		"17" destinationWord:with:		"18" addWord:with:		"19" subWord:with:		"20" rgbAdd:with:		"21" rgbSub:with:		"22" rgbDiff:with:		"23" tallyIntoMap:with:		"24" alphaBlend:with:		"25" pixPaint:with:		"26" destinationWord:with:		"27" destinationWord:with:		"28" destinationWord:with:		"29" destinationWord:with:		"30" destinationWord:with:		"31" destinationWord:with:	).	OpTableSize _ OpTable size + 1.  "0-origin indexing"! !!BitBltSimulation class methodsFor: 'initialization'!test2  "BitBltSimulation test2"	| f |	Display fillWhite: (0@0 extent: 300@140).	1 to: 12 do:		[:i | f _ (Form extent: i@5) fillBlack.		0 to: 20 do:			[:x | f displayOn: Display					at: (x*13) @ (i*10)]]! !!BitBltSimulation class methodsFor: 'initialization'!timingTest: extent  "BitBltSimulation timingTest: 640@480"	| f f2 map |	f _ Form extent: extent depth: 8.	f2 _ Form extent: extent depth: 8.	map _ Bitmap new: 1 << f2 depth.	^ Array with:	(Time millisecondsToRun: [100 timesRepeat:		[f fillWithColor: Color white]])	with:	(Time millisecondsToRun: [100 timesRepeat:		[f copy: f boundingBox from: 0@0 in: f2 rule: Form over]])	with:	(Time millisecondsToRun: [100 timesRepeat:		[f copyBits: f boundingBox from: f2 at: 0@0 colorMap: map]])! !!BitBltSimulation class methodsFor: 'translation' stamp: 'di 12/29/97 20:00'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'opTable'		declareC: 'int opTable[' , OpTableSize printString , ']'! !!BitBltSimulator methodsFor: 'all' stamp: 'di 12/30/97 09:23'!initBBOpTable	opTable _ OpTable! !!BitBltSimulator methodsFor: 'all' stamp: 'di 12/30/97 11:07'!mergeFn: arg1 with: arg2	^ self perform: (opTable at: combinationRule+1) with: arg1 with: arg2! !!BitBltSimulator class methodsFor: 'translation' stamp: 'ikp 1/3/98 23:10'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep] 164760 167543 171826 174510"	| cg |	BitBltSimulation initialize.	Interpreter initialize.	ObjectMemory initialize.	cg _ CCodeGenerator new initialize.	cg addClass: BitBltSimulation.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	BitBltSimulation declareCVarsIn: cg.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !!BitEditor methodsFor: 'control defaults'!redButtonActivity	| formPoint displayPoint |	model depth = 1 ifTrue:		["If this is just a black&white form, then set the color to be		the opposite of what it was where the mouse was clicked"		formPoint _ (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.		color _ 1-(view workingForm pixelValueAt: formPoint).		squareForm fillColor: (color=1 ifTrue: [Color black] ifFalse: [Color white])].	[sensor redButtonPressed]	  whileTrue: 		[formPoint _ (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.		displayPoint _ view displayTransform: formPoint.		squareForm 			displayOn: Display			at: displayPoint 			clippingBox: view insetDisplayBox 			rule: Form over			fillColor: nil.		view changeValueAt: formPoint put: color]! !!BitEditor class methodsFor: 'private' stamp: 'di 1/16/98 15:46'!bitEdit: aForm at: magnifiedFormLocation scale: scaleFactor remoteView: remoteView	"Create a BitEditor on aForm. That is, aForm is a small image that will 	change as a result of the BitEditor changing a second and magnified 	view of me. magnifiedFormLocation is where the magnified form is to be 	located on the screen. scaleFactor is the amount of magnification. This 	method implements a scheduled view containing both a small and 	magnified view of aForm. Upon accept, aForm is updated."	| aFormView scaledFormView bitEditor topView extent menuView lowerRightExtent |	scaledFormView _ FormHolderView new model: aForm.	scaledFormView scaleBy: scaleFactor.	bitEditor _ self new.	scaledFormView controller: bitEditor.	bitEditor setColor: Color black.	topView _ StandardSystemView new.	remoteView == nil ifTrue: [topView label: 'Bit Editor'].	topView borderWidth: 2.	topView addSubView: scaledFormView.	remoteView == nil		ifTrue:  "If no remote view, then provide a local view of the form"			[aFormView _ FormView new model: scaledFormView workingForm.			aFormView controller: NoController new.			aForm height < 50				ifTrue: [aFormView borderWidthLeft: 0 right: 2 top: 2 bottom: 2]				ifFalse: [aFormView borderWidthLeft: 0 right: 2 top: 2 bottom: 0].			topView addSubView: aFormView below: scaledFormView]		 ifFalse:  "Otherwise, the remote one should view the same form"			[remoteView model: scaledFormView workingForm].	lowerRightExtent _ remoteView == nil			ifTrue:				[(scaledFormView viewport width - aFormView viewport width) @					(aFormView viewport height max: 50)]			ifFalse:				[scaledFormView viewport width @ 50].	menuView _ self buildColorMenu: lowerRightExtent colorCount: 1.	menuView model: bitEditor.	menuView borderWidthLeft: 0 right: 0 top: 2 bottom: 0.	topView		addSubView: menuView		align: menuView viewport topRight		with: scaledFormView viewport bottomRight.	extent _ scaledFormView viewport extent + (0 @ lowerRightExtent y)			+ (4 @ 4).  "+4 for borders"	topView minimumSize: extent.	topView maximumSize: extent.	topView translateBy: magnifiedFormLocation.	topView insideColor: Color white.	^topView! !!BitEditor class methodsFor: 'private'!buildColorMenu: extent colorCount: nColors	"See BitEditor magnifyWithSmall."	| menuView form aSwitchView	button formExtent highlightForm color leftOffset |	menuView _ FormMenuView new.	menuView window: (0@0 corner: extent).	formExtent _ 30@30 min: extent//(nColors*2+1@2).  "compute this better"	leftOffset _ extent x-(nColors*2-1*formExtent x)//2.	highlightForm _ Form extent: formExtent.	highlightForm borderWidth: 4.	1 to: nColors do:		[:index | 		color _ (nColors=1			ifTrue: [#(black)]			ifFalse: [#(black gray)]) at: index.		form _ Form extent: formExtent.		form fill: form boundingBox fillColor: (Color perform: color).		form borderWidth: 5.		form border: form boundingBox width: 4 fillColor: Color white.		button _ Button new.		index = 1 ifTrue:			[button onAction: [menuView model setColor: Color fromUser]]			ifFalse:			[button onAction: [menuView model setTransparentColor]].		aSwitchView _ SwitchView new model: button.		aSwitchView key: ((nColors=3 ifTrue: ['xvn'] ifFalse: ['xn']) at: index).		aSwitchView label: form.		aSwitchView window: (0@0 extent: form extent).		aSwitchView translateBy: (index-1*2*form width+leftOffset) @ (form height//2).		aSwitchView highlightForm: highlightForm.			aSwitchView borderWidth: 1.		aSwitchView controller selector: #turnOn.		menuView addSubView: aSwitchView].	^menuView! !!BitEditor class methodsFor: 'private'!locateMagnifiedView: aForm scale: scaleFactor	"Answer a rectangle at the location where the scaled view of the form,	aForm, should be displayed."	^ Rectangle originFromUser: (aForm extent * scaleFactor + (0@50)).	! !!Bitmap methodsFor: 'filing'!compressToByteArray	"Return a simple run-coded compression of the receiver into a byteArray:		First 4 bytes are the size of the original Bitmap.		This is followed by a number of runs...		[0 means end of runs]		[n = 1..127] [(n+3) copies of next byte]		[n = 128..191] [(n-127) next bytes as is]		[n = 192..255] [(n-190) copies of next 4 bytes]"	^ ByteArray streamContents:		[:s | 1 to: 4 do: [:i | s nextPut: (self size digitAt: 5-i)].	"positive size"		self compressToStream: s]"Space check: | n rawBytes myBytes b |n _ rawBytes _ myBytes _ 0.Form allInstancesDo:	[:f | b _ f bits.	b size > 10 ifTrue:		[n _ n + 1.		rawBytes _ rawBytes + (b size*4).		myBytes _ myBytes + (b compressToByteArray size)]].Array with: n with: rawBytes with: myBytes (69 304604 87588 )Speed test: | b |Smalltalk garbageCollect.MessageTally spyOn: [Form allInstances do:	[:f | b _ f bits.	b size > 10 ifTrue:		[Bitmap decompressFromByteArray: b compressToByteArray]]]"! !!Bitmap methodsFor: 'filing'!compressToStream: aBinaryStream	"Return a simple run-coded compression of the receiver into a byteArray:		(Caller has put negated size of original Bitmap in first 4 bytes.)		Then put out a number of runs...		[0 means end of runs]		[n = 1..127] [(n+3) copies of next byte]		[n = 128..191] [(n-127) next bytes as is]		[n = 192..255] [(n-190) copies of next 4 bytes]"	| here end runLen startAndLen junkLen s |	s _ aBinaryStream.	here _ 1.  end _ self size*4.	[here <= end] whileTrue:		["Scan for a run of 4..130 = bytes..."		runLen _ self scanForRunOf: 4 from: here to: (here+129 min: end).		runLen > 0			ifTrue:			[s nextPut: runLen - 3.  "Codes 1..127 mean n+3 copies of next byte"			s nextPut: (self byteAt: here).			here _ here + runLen]			ifFalse:			["Scan for a junk run (never 4 or more = bytes) of length 1..64				[dont want to find runs of 3 as we would miss aaabaaab]"			runLen _ self scanForNoRunOf: 4 from: here to: (here+63 min: end).			"See if there is a 4-byte repeating pattern in the junk"			startAndLen _ self scanForWordRunFrom: here to: (here+runLen-1 min: end).			startAndLen first = 0				ifTrue: [junkLen _  runLen]				ifFalse: [junkLen _ startAndLen first - here].			"Now output the junk up to repeating words if any..."			junkLen > 0				ifTrue: [s nextPut: junkLen+127.  "Codes 128..191 mean n-127 bytes of junk"						0 to: junkLen-1 do: [:i | s nextPut: (self byteAt: here + i)].						here _ here + junkLen].			startAndLen first > 0				ifTrue: ["Note: later may want to look for more copies of this						4-byte pattern up to 65"						s nextPut: startAndLen last+190.							"Codes 192-255 mean n-190  copies of next 4 bytes"						0 to: 3 do: [:i | s nextPut: (self byteAt: here + i)].						here _ here + (startAndLen last * 4)]]].	s nextPut: 0 "zero end-flag to simplify decompressor""Space check: | n rawBytes myBytes b |n _ rawBytes _ myBytes _ 0.Form allInstancesDo:	[:f | b _ f bits.	b size > 10 ifTrue:		[n _ n + 1.		rawBytes _ rawBytes + (b size*4).		myBytes _ myBytes + (b compressToByteArray size)]].Array with: n with: rawBytes with: myBytes (69 304604 87588 )Speed test: | b |Smalltalk garbageCollect.MessageTally spyOn: [Form allInstances do:	[:f | b _ f bits.	b size > 10 ifTrue:		[Bitmap decompressFromByteArray: b compressToByteArray]]]"! !!Bitmap methodsFor: 'filing' stamp: 'jm 11/13/97 10:33'!readCompressedFrom: strm	"Decompress a run-coded stream into this bitmap:		[0 means end of runs]		[n = 1..127] [(n+3) copies of next byte]		[n = 128..191] [(n-127) next bytes as is]		[n = 192..255] [(n-190) copies of next 4 bytes]"	| n byte out outBuff bytes |	out _ WriteStream on: (outBuff _ ByteArray new: self size*4).	[(n _ strm next) > 0] whileTrue:		[(n between: 1 and: 127) ifTrue:			[byte _ strm next.			1 to: n+3 do: [:i | out nextPut: byte]].		(n between: 128 and: 191) ifTrue:			[1 to: n-127 do: [:i | out nextPut: strm next]].		(n between: 192 and: 255) ifTrue:			[bytes _ (1 to: 4) collect: [:i | strm next].			1 to: n-190 do: [:i | bytes do: [:b | out nextPut: b]]]].	out position = outBuff size ifFalse: [self error: 'Decompression size error'].	"Copy the final byteArray into self"	self copyFromByteArray: outBuff."Integerity check: | f r |r _ Rectangle fromUser.f _ Form fromDisplay: r.f bits: (Bitmap decompressFromByteArray: f bits compressToByteArray).f bits size = f bitsSize ifFalse: [self halt].f displayAt: r topLeftTotal Integerity check:Form allInstances do: [:f |f bits = (Bitmap decompressFromByteArray: f bits compressToByteArray)	ifFalse: [self halt]]"! !!Bitmap methodsFor: 'filing'!scanForNoRunOf: minLen from: here to: end	| val runLen runStart |	(here + minLen - 1) > end ifTrue: [^ end - here + 1].	runStart _ here.  val _ self byteAt: runStart.	here + 1 to: end do:		[:i | (self byteAt: i) = val			ifTrue: [runLen _ i - runStart + 1.					runLen >= minLen ifTrue: [^ runStart - here]]			ifFalse: [runStart _ i.  val _ self byteAt: runStart]].	^ end - here + 1! !!Bitmap methodsFor: 'filing'!scanForRunOf: minLen from: here to: end	| val runLen |	(here + minLen - 1) > end ifTrue: [^ 0].	val _ self byteAt: here.	here + 1 to: end do:		[:i | (self byteAt: i) = val ifFalse:			[runLen _ i - here.			runLen < minLen ifTrue: [^ 0] ifFalse: [^ runLen]]].	^ end - here + 1! !!Bitmap methodsFor: 'filing'!scanForWordRunFrom: here to: end	"Returns an array with (starting byte index) , (length of run in 4-byte words)"	| runStart runLen |	here + 7 > end ifTrue: [^ Array with: 0 with: 0].  "Need at least 8 bytes"	"Scan for i such that a(i+j+4) = a(i+j), for j=0...n, n>=7"	runStart _ here.  runLen _ 0.	here to: end-4 do:		[:i | (self byteAt: i) = (self byteAt: i+4)			ifTrue: [runLen _ runLen + 1]			ifFalse: [runLen >= 8 ifTrue: [^ Array with: runStart with: runLen//4].					runStart _ i + 1.  runLen _ 0]].	runLen >= 8 ifTrue: [^ Array with: runStart with: runLen//4].	^ Array with: 0 with: 0! !!Bitmap methodsFor: 'filing' stamp: 'di 10/2/97 00:02'!swapBytesFrom: start to: stop	"Perform a bigEndian/littleEndian byte reversal of my words"	| hack blt |	"The implementation is a hack, but fast for large ranges"	hack _ Form new hackBits: self.	blt _ (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: start-1; destY: start-1; height: stop-start+1; width: 1.	blt sourceX: 0; destX: 3; copyBits.  "Exchange bytes 0 and 3"	blt sourceX: 3; destX: 0; copyBits.	blt sourceX: 0; destX: 3; copyBits.	blt sourceX: 1; destX: 2; copyBits.  "Exchange bytes 1 and 2"	blt sourceX: 2; destX: 1; copyBits.	blt sourceX: 1; destX: 2; copyBits.! !!Bitmap methodsFor: 'filing' stamp: 'jm 12/3/97 22:15'!writeOn: aStream 	"Store the array of bits onto the argument, aStream.  Use a simple run-coded compression of the receiver into a byteArray:		First 4 bytes are the size of the original Bitmap *negated*.		This is followed by a number of runs...		[0 means end of runs]		[n = 1..127] [(n+3) copies of next byte]		[n = 128..191] [(n-127) next bytes as is]		[n = 192..255] [(n-190) copies of next 4 bytes].	Difference from compressToByteArray is that first word is size negated here."	"Optimization: compress in memory, then store on aStream; 30% faster for FileStreams"	| s |	s _ WriteStream on: (ByteArray new: self size * 4).	self compressToStream: s.	aStream nextInt32Put: self size negated.	aStream nextPutAll: s contents.! !!Bitmap methodsFor: 'accessing' stamp: 'di 10/4/97 11:56'!copyFromByteArray: byteArray	"This method should work with either byte orderings"	| long |	(self size * 4) = byteArray size ifFalse: [self halt].	1 to: byteArray size by: 4 do:		[:i | long _ Integer				byte1: (byteArray at: i+3)				byte2: (byteArray at: i+2)				byte3: (byteArray at: i+1)				byte4: (byteArray at: i).		self at: i+3//4 put: long]! !!Bitmap methodsFor: 'accessing' stamp: 'di 10/4/97 11:59'!copyToByteArray: byteArray	"This method should work with either byte orderings"	| long |	(self size * 4) = byteArray size ifFalse: [self halt].	1 to: byteArray size by: 4 do:		[:i | long _ self at: i+3//4.		byteArray at: i+3 put: (long digitAt: 1).		byteArray at: i+2 put: (long digitAt: 2).		byteArray at: i+1 put: (long digitAt: 3).		byteArray at: i put: (long digitAt: 4)]! !!Bitmap methodsFor: 'accessing' stamp: 'tk 3/15/97'!pixelValueForDepth: depth	"Self is being used to represent a single color.  Answer bits that appear in ONE pixel of this color in a Bitmap of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32.  Returns an integer.  First pixel only.  "	^ (self at: 1) bitAnd: (1 bitShift: depth) - 1! !!Bitmap methodsFor: 'accessing'!primFill: aPositiveInteger	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays."	<primitive: 145>	self errorImproperStore.! !!Bitmap class methodsFor: 'instance creation'!decompressFromByteArray: b	| s size |	s _ ReadStream on: b.	size _ 0.	1 to: 4 do: [:i | size _ (size * 256) + s next].	^ (self new: size) readCompressedFrom: s! !!Bitmap class methodsFor: 'instance creation' stamp: 'tk 9/28/97 10:27'!newFromStream: s	| len |	len _ s nextInt32.	len <= 0		ifTrue: [^ (self new: len negated) readCompressedFrom: s]		ifFalse: [^ s nextInto: (self new: len)]! !!BlockContext methodsFor: 'evaluating'!ifError: aBlock	"Evaluate the block represented by the receiver. If an error occurs aBlock is evaluated	 with the error message and the receiver as parameters. The receiver should not contain	 an explicit return statement as this would leave an obsolete error handler hanging around."	| lastHandler val activeProcess |	activeProcess _ Processor activeProcess.	lastHandler _ activeProcess errorHandler.	activeProcess errorHandler: [:aString :aReceiver |		activeProcess errorHandler: lastHandler.		^ aBlock value: aString value: aReceiver].	val _ self value.	activeProcess errorHandler: lastHandler.	^ val! !!BlockContext methodsFor: 'evaluating'!value: arg1 ifError: aBlock	"Evaluate the block represented by the receiver. If an error occurs aBlock is evaluated	 with the error message and the receiver as parameters. The receiver should not contain	 an explicit return statement as this would leave an obsolete error handler hanging around."	| lastHandler val activeProcess |	activeProcess _ Processor activeProcess.	lastHandler _ activeProcess errorHandler.	activeProcess errorHandler: [:aString :aReceiver |		activeProcess errorHandler: lastHandler.		^ aBlock value: aString value: aReceiver].	val _ self value: arg1.	activeProcess errorHandler: lastHandler.	^ val! !!BlockContext methodsFor: 'evaluating' stamp: 'di 11/30/97 09:19'!value: arg1 value: arg2 value: arg3 value: arg4 	"Primitive. Evaluate the block represented by the receiver. Fail if the 	block expects other than three arguments or if the block is already being 	executed. Optional. See Object documentation whatIsAPrimitive."	<primitive: 81>	^self valueWithArguments: 		(Array			with: arg1			with: arg2			with: arg3			with: arg4)! !!BlockContext methodsFor: 'evaluating'!valueWithArguments: anArray 	"Primitive. Evaluate the block represented by the receiver. The argument 	is an Array whose elements are the arguments for the block. Fail if the 	length of the Array is not the same as the the number of arguments that 	the block was expecting. Fail if the block is already being executed. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 82>	self numArgs = anArray size		ifTrue: [self error: 'Attempt to evaluate a block that is already being evaluated.']		ifFalse: [self error: 'This block requires ' , self numArgs printString , ' arguments.']! !!BlockContext methodsFor: 'private' stamp: 'jm 9/18/97 21:40'!cannotReturn: result	"The receiver tried to return result to a method context that no longer exists."	DebuggerView		openContext: thisContext		label: 'Block cannot return'		contents: thisContext shortStack.! !!BlockContext methodsFor: 'menus' stamp: 'jm 11/4/97 07:15'!dispatchAsMenuActionTo: anObject with: argument	^self numArgs = 0		ifTrue: [self value]		ifFalse: [self numArgs = 1					ifTrue: [self value: anObject]					ifFalse: [self value: anObject value: argument]]! !!BlockNode methodsFor: 'initialize-release'!statements: statementsCollection returns: returnBool 	"Decompile."	| returnLast |	returnLast _ returnBool.	returns _ false.	statements _ 		(statementsCollection size > 1 			and: [(statementsCollection at: statementsCollection size - 1) 					isReturningIf])				ifTrue: 					[returnLast _ false.					statementsCollection allButLast]				ifFalse: [statementsCollection size = 0						ifTrue: [Array with: NodeNil]						ifFalse: [statementsCollection]].	arguments _ Array new: 0.	returnLast ifTrue: [self returnLast]! !!BlockNode methodsFor: 'code generation'!emitForValue: stack on: aStream	aStream nextPut: LdThisContext.	stack push: 1.	nArgsNode emitForValue: stack on: aStream.	remoteCopyNode		emit: stack		args: 1		on: aStream.	"Force a two byte jump."	self emitLong: size code: JmpLong on: aStream.	stack push: arguments size.	arguments reverseDo: [:arg | arg emitStorePop: stack on: aStream].	self emitForEvaluatedValue: stack on: aStream.	self returns ifFalse: [aStream nextPut: EndRemote].	stack pop: 1! !!BlockNode methodsFor: 'printing'!printStatementsOn: aStream indent: levelOrZero	| len shown thisStatement level |	level _ 1 max: levelOrZero.	comment == nil		ifFalse: 			[self printCommentOn: aStream indent: level.			aStream crtab: level].	len _ shown _ statements size.	(levelOrZero = 0 "top level" and: [statements last isReturnSelf])		ifTrue: [shown _ 1 max: shown - 1]		ifFalse: [(len = 1 and: [((statements at: 1) == NodeNil) & (arguments size = 0)])					ifTrue: [shown _ shown - 1]].	1 to: shown do: 		[:i | 		thisStatement _ statements at: i.		thisStatement printOn: aStream indent: level.		i < shown ifTrue: [aStream nextPut: $.; crtab: level].		thisStatement comment size > 0			ifTrue: 				[i = shown ifTrue: [aStream crtab: level].				thisStatement printCommentOn: aStream indent: level.				i < shown ifTrue: [aStream crtab: level]]]! !!BlockNode methodsFor: 'C translation'!asTranslatorNode	| statementList newS |	statementList _ OrderedCollection new.	statements do: [ :s |		newS _ s asTranslatorNode.		newS isStmtList ifTrue: [			"inline the statement list returned when a CascadeNode is translated"			statementList addAll: newS statements.		] ifFalse: [			statementList add: newS.		].	].	^TStmtListNode new		setArguments: (arguments asArray collect: [ :arg | arg key ])		statements: statementList! !!Boink methodsFor: 'as yet unclassified' stamp: 'jm 12/17/97 22:41'!initialize	super initialize.	sound _ FMSound pitch: 440.0 dur: 2.0 loudness: 0.5.	"(FMSound pitch: 440.0 dur: 2.0 loudness: 0.5) play"! !!BookMorph methodsFor: 'initialization' stamp: 'di 1/13/98 22:11'!addDressing	| controlColor pageControls |	self addMorph: (Morph new color: color; extent: 10@10).  "spacer"	controlColor _ (color saturation > 0.1)		ifTrue:			[color lighter]		ifFalse:			[color darker].	pageControls _ self makeAuthoringPageControlsColored: controlColor.	pageControls borderWidth: 1; inset: 4.				self addMorph: pageControls! !!BookMorph methodsFor: 'initialization' stamp: 'sw 10/3/97 18:49'!addKidsDressing	| controlColor pageControls |	self addMorph: (Morph new color: color; extent: 10@10).  "spacer"	controlColor _ (color saturation > 0.1)		ifTrue:			[color lighter]		ifFalse:			[color darker].	pageControls _ self makeKidsPageControlsColored: controlColor.	pageControls borderWidth: 1; inset: 4.				self addMorph: pageControls! !!BookMorph methodsFor: 'initialization' stamp: 'sw 10/18/97 18:03'!beThoroughlyRepelling	submorphs do: [:m | m beRepelling].	self beRepelling! !!BookMorph methodsFor: 'initialization' stamp: 'sw 8/16/97 13:39'!closeCurrentPageToDragNDrop	currentPage ifNotNil: [currentPage openToDragNDrop: false]! !!BookMorph methodsFor: 'initialization' stamp: 'jm 9/24/97 08:48'!initialize	super initialize.	self setInitialState.	pages _ OrderedCollection new.	self addDressing.	BookMorph turnOffSoundWhile: [self insertPage].! !!BookMorph methodsFor: 'initialization' stamp: 'jm 11/17/97 17:26'!newPages: pageList currentIndex: index	"Replace all my pages with the given list of BookPageMorphs. Make the current page be the page with the given index."	pages _ pages species new.	pages addAll: pageList.	pages isEmpty ifTrue: [^ self insertPage].	self goToPage: index.! !!BookMorph methodsFor: 'initialization' stamp: 'sw 8/5/97 20:52'!removeEverything	currentPage _ nil.	pages _ OrderedCollection new.	super removeAllMorphs! !!BookMorph methodsFor: 'initialization' stamp: 'sw 8/12/97 21:31'!setInitialState	orientation _ #vertical.	centering _ #topLeft.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	inset _ 5.	color _ Color white.	pageSize _ 160@300.	openToDragNDrop _ true.	copyContents _ false.! !!BookMorph methodsFor: 'accessing' stamp: 'tk 12/18/97 09:44'!allNonSubmorphMorphs	"Return a collection containing all morphs in this morph which are not currently in the submorph containment hierarchy (put in primarily for bookmorphs)"	^ pages copyWithout: currentPage! !!BookMorph methodsFor: 'accessing' stamp: 'sw 11/5/97 13:37'!currentPage	^ currentPage! !!BookMorph methodsFor: 'accessing' stamp: 'sw 9/20/97 20:29'!pageNamed: aName	^ pages detect: [:p | p externalName = aName] ifNone: [nil]! !!BookMorph methodsFor: 'accessing'!pages	^ pages! !!BookMorph methodsFor: 'accessing' stamp: 'tk 8/13/97 17:01'!pages: aMorphList	pages _ aMorphList asOrderedCollection.	"John:  While it is tempting to put this code here, it is wrong.	pages size > 0		ifTrue: [currentPage _ pages first]		ifFalse: [self insertPage].	If currentPage is not page 1, then when it comes back in, two pagesare shown at once!!	Just trust the copying mechanism and let currentPage be copiedcorrectly. --Ted."! !!BookMorph methodsFor: 'accessing'!pageSize: aPoint	pageSize _ aPoint.! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/18/97 18:03'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add submorphs just by dropping them on this morph."	(currentPage allMorphs includes: aMorph)		ifFalse: [currentPage addMorph: aMorph]! !!BookMorph methodsFor: 'dropping/grabbing'!allowSubmorphExtraction	^ false! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/18/97 18:19'!rootForGrabOf: aMorph	| root |	(openToDragNDrop or: [copyContents])		ifFalse: [^ super rootForGrabOf: aMorph].	(aMorph = currentPage or: [aMorph owner = self])		ifTrue: [^ self rootForGrabOf: self].	root _ aMorph.	[root = self] whileFalse:		[root owner == currentPage ifTrue:			[(copyContents and: [openToDragNDrop not])				ifTrue: [^ root fullCopy]				ifFalse: [^ root]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!BookMorph methodsFor: 'zooming page turns'!goToPage: pageNumber zoomingFrom: srcButtonMorph	| bigBalloonMorph i newPage cachedMorph zoomer |	pages isEmpty ifTrue: [^ self].	(self isInWorld and:	 [self world modelOrNil respondsTo: #bigBalloonMorph])		ifTrue: [bigBalloonMorph _ self world model bigBalloonMorph fullCopy]		ifFalse: [^ self goToPage: pageNumber].	bigBalloonMorph position: self world model scaffoldingBook root fullBounds origin.	bigBalloonMorph removeAllMorphs.	i _ pageNumber asInteger.	i > pages size ifTrue: [i _ 1].  "wrap"	i < 1  ifTrue: [i _ pages size].  "wrap"	newPage _ pages at: i.	cachedMorph _ CachingMorph new.	cachedMorph addMorph: bigBalloonMorph.	bigBalloonMorph addMorph: newPage fullCopy.	zoomer _ ZoomMorph new.	self world addMorphFront: zoomer.	zoomer zoomFromMorph: srcButtonMorph							toMorph: cachedMorph							andThen: [self goToPage: i].	self world ifNotNil: [self world startSteppingSubmorphsOf: zoomer].! !!BookMorph methodsFor: 'zooming page turns'!nextPageZoomingFrom: aMorph	| i |	i _ (pages indexOf: currentPage ifAbsent: [0]) + 1.	self goToPage: i zoomingFrom: aMorph.! !!BookMorph methodsFor: 'zooming page turns'!previousPageZoomingFrom: aMorph	| i |	i _ (pages indexOf: currentPage ifAbsent: [2]) - 1.	self goToPage: i zoomingFrom: aMorph.! !!BookMorph methodsFor: 'zooming page turns' stamp: 'sw 10/20/97 00:56'!showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending	ascending ifNotNil:		[self playPageFlipSound.		(PageFlipSoundOn and: [oldOrigin ~~ nil]) ifTrue:			[Display pageWarp: currentPage imageForm at: oldOrigin forward: ascending]]! !!BookMorph methodsFor: 'menu' stamp: 'jm 11/17/97 14:02'!addBookMenuItemsTo: aCustomMenu hand: aHandMorph	aCustomMenu		add: (copyContents				ifTrue: ['don''t be parts bin when closed']				ifFalse: ['be parts bin when closed'])		action: #toggleCopyContents.	aCustomMenu add: 'previous page' action: #previousPage.	aCustomMenu add: 'next page' action: #nextPage.	aCustomMenu add: 'insert a page' action: #insertPage.	aCustomMenu add: 'delete this page' action: #deletePage.	aCustomMenu add: 'page controls' action: #pageControls:.	aCustomMenu add: 'sort pages' action: #sortPages:.! !!BookMorph methodsFor: 'menu' stamp: 'sw 9/13/97 23:24'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self addBookMenuItemsTo: aCustomMenu hand: aHandMorph	"This factoring allows subclasses, such as TabbedPaletteMorph, to choose different items and different wording and still use the super call for the rest of the metamenu"! !!BookMorph methodsFor: 'menu' stamp: 'sw 10/2/97 15:22'!configureForKids	super configureForKids.	pages do:		[:aPage | aPage configureForKids].! !!BookMorph methodsFor: 'menu' stamp: 'sw 8/15/97 22:01'!deleteControls	"If the receiver has an element answering to the name 'Page Controls', delete it"	| controls |	(controls _ self findSubmorphThat: [:m | m externalName = 'Page Controls'] ifAbsent: [nil]) ifNotNil:		[controls delete.		self changed]! !!BookMorph methodsFor: 'menu'!deletePage	| oldPage |	oldPage _ currentPage.	self nextPage.	pages remove: oldPage.	oldPage delete.	currentPage = oldPage ifTrue: [self nextPage].	pages isEmpty ifTrue: [self insertPage].! !!BookMorph methodsFor: 'menu' stamp: 'sw 8/4/97 12:05'!firstPage	self goToPage: 1.! !!BookMorph methodsFor: 'menu' stamp: 'sw 8/9/97 00:02'!insertPage	self insertPageColored: self color! !!BookMorph methodsFor: 'menu' stamp: 'sw 10/12/97 21:48'!insertPage: aPage pageSize: aPageSize	^ self insertPage: aPage pageSize: aPageSize atIndex: (pages size + 1)! !!BookMorph methodsFor: 'menu' stamp: 'sw 9/15/97 01:05'!insertPage: aPage pageSize: aPageSize atIndex: anIndex	| sz  predecessor |	self flag: #deferred.  "Presently only called for TabbedPaletteComplexes, but could conceivably call this from insertPage-like methods, after maybe some fixup"	sz _ aPageSize		ifNil: [currentPage == nil			ifTrue: [pageSize]			ifFalse: [currentPage extent]]		ifNotNil:			[aPageSize].	aPage extent: sz.	((pages isEmpty | anIndex == nil) or: [anIndex > pages size])		ifTrue:			[pages add: (currentPage _ aPage)]		ifFalse:			[anIndex == 1				ifTrue:					[pages addFirst: aPage]				ifFalse:					[predecessor _ anIndex == nil						ifTrue:							[currentPage]						ifFalse:							[pages at: anIndex].					self pages add: aPage after: predecessor]].	self nextPage! !!BookMorph methodsFor: 'menu' stamp: 'jm 11/2/97 18:23'!insertPageColored: aColor	| sz newPage |	currentPage == nil		ifTrue: [sz _ pageSize]		ifFalse: [sz _ currentPage extent].	newPage _ BookPageMorph new extent: sz; color: aColor.	"newPage setNameTo: self externalName, ' page'."	pages isEmpty		ifTrue: [pages add: (currentPage _ newPage)]		ifFalse: [pages add: newPage after: currentPage].	self nextPage.! !!BookMorph methodsFor: 'menu' stamp: 'sw 10/2/97 21:31'!insertPageShowingString: aString fontName: aName fontSize: aSize	"For creating text content on a page of a BookMorph, from cold code.  Sadly, can't yet specify font..."	| aTextMorph tempContents |	self insertPage.	aTextMorph _ TextMorph new.	aTextMorph extent: (self extent - (12@0)).	aName ifNotNil:			[aTextMorph string: aString fontName: aName size: aSize]		ifNil:			[aTextMorph contentsWrapped: aString].	tempContents _ aTextMorph contents.	aTextMorph contentsWrapped: '-'.	aTextMorph extent: (self extent - (12@0)).	aTextMorph contentsWrapped: tempContents.	currentPage addMorph: aTextMorph.! !!BookMorph methodsFor: 'menu' stamp: 'sw 9/15/97 01:05'!insertPageShowingString: aString usingFont: aFont 	"For creating text content on a page of a BookMorph, from cold code.  Sadly, can't yet specify font..."	self insertPage.	currentPage addMorph:		(TextMorph new extent: (self extent - (12@0)); contentsWrapped: aString)! !!BookMorph methodsFor: 'menu' stamp: 'jm 11/17/97 16:48'!invokeBookMenu	"Answer a menu to be popped up from the book-control panel"	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(			('border color...' 		changeBorderColor:)			('border width...' 		changeBorderWidth:)			('lock'					lock)			('make bookmark'		bookmarkForThisPage)			('sort pages'				sortPages:)			('remove control panel'	deleteControls)		).	aMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.	aMenu invokeOn: self defaultSelection: nil! !!BookMorph methodsFor: 'menu' stamp: 'sw 8/4/97 12:05'!lastPage	self goToPage: pages size! !!BookMorph methodsFor: 'menu' stamp: 'sw 8/5/97 21:13'!newTextMorph	"Create a new, empty TextMorph that can be placed in this book."	self isInWorld ifTrue:		[self primaryHand attachMorph:			(TextMorph new extent: currentPage width@30)].! !!BookMorph methodsFor: 'menu' stamp: 'sw 10/1/97 00:18'!nextPage	| i |	currentPage == nil ifTrue: [^ self goToPage: 1].	i _ (pages indexOf: currentPage ifAbsent: [0]) + 1.	self goToPage: i.! !!BookMorph methodsFor: 'menu' stamp: 'sw 10/2/97 21:39'!pageControls: evt	| buttonPanel |	buttonPanel _ self makePageControls.	buttonPanel borderWidth: 1; inset: 4.	evt hand attachMorph: buttonPanel.! !!BookMorph methodsFor: 'menu' stamp: 'sw 8/11/97 23:40'!previousPage	| i |	i _ (pages indexOf: currentPage ifAbsent: [2]) - 1.	self goToPage: i.! !!BookMorph methodsFor: 'menu' stamp: 'jm 11/17/97 17:33'!sortPages: evt	| sorter |	sorter _ BookPageSorterMorph new forBook: self.	sorter pageHolder cursor: (pages indexOf: currentPage ifAbsent: [0]).	evt == nil		ifTrue: [self world addMorphFront: sorter]		ifFalse: [evt hand attachMorph: sorter].! !!BookMorph methodsFor: 'menu' stamp: 'jm 7/8/97 10:44'!toggleCopyContents	"Toggle this morph's ability to behave like a parts bin when closed."	copyContents _ copyContents not.! !!BookMorph methodsFor: 'private' stamp: 'sw 10/2/97 18:47'!authorControlSpecs	^ #(				( '<--'		firstPage		'Go to first page')			( '<-' 		previousPage	'Go to previous page')			('-'			deletePage		'Delete current page')			('<<>>'		invokeBookMenu 'Put up a menu')			('+'			insertPage		'Insert new page after this one')			('->'			nextPage		'Go to next page')			( '-->'		lastPage			'Go to final page'))! !!BookMorph methodsFor: 'private' stamp: 'sw 8/12/97 12:16'!bookmarkForThisPage	| b |	b _ SimpleButtonMorph new target: self.	b actionSelector: #goToPageMorph:.	b label: 'Bookmark'.	b arguments: (Array with: currentPage).	self primaryHand attachMorph: b! !!BookMorph methodsFor: 'private' stamp: 'di 11/14/97 09:22'!goToPage: pageNumber	| pageIndex  oldOrigin aWorld oldRect oldPageNumber ascending |	pages isEmpty ifTrue: [^ self].	oldPageNumber _ pages indexOf: currentPage ifAbsent: [1].	pageIndex _ pageNumber asInteger.	"pageIndex _ (pageIndex max: 1) min: pages size."	self flag: #deferred.  "The above rather than the below leads to the book pages of a tabbed palette complex being stacked upon one another.  Revisit this sucker!!"	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	ascending _ oldPageNumber < pageIndex.	oldPageNumber = pageIndex ifTrue: [ascending _ nil].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	currentPage ifNotNil:		[(oldRect _ currentPage screenRectangle) ifNotNil:			[oldOrigin _ oldRect origin].		currentPage releaseCachedState; delete].	currentPage _ pages at: pageIndex.	self addMorphBack: currentPage.	aWorld ifNotNil:		[self world startSteppingSubmorphsOf: currentPage.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending]! !!BookMorph methodsFor: 'private' stamp: 'jm 7/1/97 16:43'!goToPageMorph: aMorph	| i |	i _ pages indexOf: aMorph.	i = 0 ifFalse: [self goToPage: i].! !!BookMorph methodsFor: 'private' stamp: 'sw 8/7/97 16:30'!goToPageMorphNamed: aName	| aMorph |	aMorph _ pages detect: [:p | p externalName = aName] ifNone: [self break].	self goToPageMorph: aMorph! !!BookMorph methodsFor: 'private' stamp: 'sw 11/5/97 13:47'!insertPageLabel: labelString morphs: morphList	| m c labelAllowance |	self insertPage.	labelString ifNotNil:			[m _ (TextMorph new extent: currentPage width@20; contents: labelString).		m lock.		m position: currentPage position + (((currentPage width - m width) // 2) @ 5).		currentPage addMorph: m.		labelAllowance _ 40]		ifNil:			[labelAllowance _ 0].	"use a column to align the given morphs, then add them to the page"	c _ LayoutMorph newColumn centering: #center.	c addAllMorphs: morphList.	c position: currentPage position + (0 @ labelAllowance).	currentPage addAllMorphs: morphList.	^ currentPage! !!BookMorph methodsFor: 'private' stamp: 'jm 8/21/97 18:10'!insertPageLabel: labelString morphs: firstColMorphs secondColumnMorphs: secondColMorphs	| c |	self insertPageLabel: labelString morphs: firstColMorphs.	"use a column to align the given morphs, then add them to the page"	c _ LayoutMorph newColumn centering: #center.	c addAllMorphs: secondColMorphs.	c position: currentPage position + (100@40).	currentPage addAllMorphs: secondColMorphs.! !!BookMorph methodsFor: 'private' stamp: 'sw 10/18/97 18:03'!kidControlSpecs	true ifTrue: [^ self minimalKidsControlSpecs].	^ #(				( '<--'		firstPage		'Go to first page')			( '<-' 		previousPage	'Go to previous page')			('->'			nextPage		'Go to next page')			( '-->'		lastPage			'Go to final page'))! !!BookMorph methodsFor: 'private' stamp: 'sw 10/2/97 18:49'!makeAuthoringPageControlsColored: aColor	^ self makePageControlsFrom: self authorControlSpecs color: aColor! !!BookMorph methodsFor: 'private' stamp: 'sw 10/2/97 18:50'!makeKidsPageControlsColored: aColor	^ self makePageControlsFrom: self kidControlSpecs color: aColor! !!BookMorph methodsFor: 'private' stamp: 'sw 8/5/97 20:00'!makePageControls	| b c r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	c _ LayoutMorph newColumn.	c color: b color; borderWidth: 0; inset: 0.	c hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r _ LayoutMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: '<-';			actionSelector: #previousPage).	r addMorphBack: (b fullCopy label: 'Insert';		actionSelector: #insertPage).	r addMorphBack: (b fullCopy label: 'Delete';		actionSelector: #deletePage).	r addMorphBack: (b fullCopy label: 'Text';		actionSelector: #newTextMorph).	r addMorphBack: (b fullCopy label: '->';			actionSelector: #nextPage).	c addMorphBack: r.	r _ r copy removeAllMorphs.	r addMorphBack: (b fullCopy label: 'Bookmark';	actionSelector: #bookmarkForThisPage).	r addMorphBack: (b fullCopy label: 'Save';		actionSelector: #saveBookToFile).	c addMorphBack: r.		^ c! !!BookMorph methodsFor: 'private' stamp: 'sw 10/2/97 18:52'!makePageControlsFrom: controlSpecs color: aColor	| aButton aColumn aRow but |	aButton _ SimpleButtonMorph new target: self; borderColor: Color black; color: aColor.	aColumn _ LayoutMorph newColumn.	aColumn color: aButton color; borderWidth: 0; inset: 0.	aColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	aRow _ LayoutMorph newRow.	aRow color: aButton color; borderWidth: 0; inset: 0.	aRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	controlSpecs do:		[:pair | aRow addMorphBack: (but _ aButton fullCopy label: pair first; actionSelector: pair second).		but setBalloonText: pair third.		(pair last includesSubString: 'Menu')			ifTrue: [but actWhen: #buttonDown]].	aColumn addMorphBack: aRow.	aColumn setNameTo: 'Page Controls'.		^ aColumn! !!BookMorph methodsFor: 'private' stamp: 'sw 10/18/97 18:03'!minimalKidsControlSpecs	^ #(				( '<-' 		previousPage	'Go to previous page')			('->'			nextPage		'Go to next page'))! !!BookMorph methodsFor: 'private' stamp: 'sw 10/3/97 08:10'!playPageFlipSound	(self world soundsEnabled "user-controllable" and:		[PageFlipSoundOn])  "jhm's mechanism to supress sounds at init time"			ifTrue: [SampledSound playSoundNamed: 'camera'].! !!BookMorph methodsFor: 'private' stamp: 'jm 7/1/97 16:55'!saveBookToFile	"Save this book in a file."	| fileName s |	fileName _ FillInTheBlank request: 'File name for this Book?'.	fileName isEmpty ifTrue: [^ self].  "abort"	s _ SmartRefStream newFileNamed: fileName, '.morph'.	s nextPut: self fullCopy.	s close.! !!BookMorph methodsFor: 'private' stamp: 'sw 8/12/97 12:30'!switchToAuthorMode	"Replace the control panel with one specially for authoring"		self deleteControls.	self addMorph: ((self makeAuthoringPageControlsColored: self color lighter) borderWidth: 1; inset: 4)! !!BookMorph methodsFor: 'copying' stamp: 'tk 8/13/97 15:00'!copyRecordingIn: dict	"Overridden to copy the pages of this book as well."	| new |	new _ super copyRecordingIn: dict.	new pages: (pages collect: [:pg |		"the current page was copied with the submorphs"		(dict includesKey: pg)			ifTrue: [dict at: pg]  "current page; already copied"			ifFalse: [pg copyRecordingIn: dict]]).	^ new! !!BookMorph methodsFor: 'copying' stamp: 'jm 7/1/97 17:06'!updateReferencesUsing: aDictionary	super updateReferencesUsing: aDictionary.	pages do: [:page |		page allMorphsDo: [:m | m updateReferencesUsing: aDictionary]].! !!BookMorph methodsFor: 'object fileIn' stamp: 'jm 9/24/97 08:49'!convertbosfcepbbochvimolppccs0: varDict bosfcepbbochvimolppcc0: smartRefStrm	"These variables are automatically stored into the new instance ('pageSize' 'pages' 'currentPage' 'copyContents' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in () and deal with the information in ('saveBlock' )"! !!BookMorph class methodsFor: 'all' stamp: 'sw 8/12/97 18:22'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book _ self new markAsPartsDonor.	book removeEverything; pageSize: 100@120; color: (Color r: 1.0 g: 0.9 b: 1.0).	book addDressing; insertPage.	^ book! !!BookMorph class methodsFor: 'all' stamp: 'jm 9/24/97 08:42'!initialize	"BookMorph initialize"	PageFlipSoundOn _ true.! !!BookMorph class methodsFor: 'all' stamp: 'jm 9/24/97 08:47'!turnOffSoundWhile: aBlock	"Turn off page flip sound during the given block."	| old |	old _ PageFlipSoundOn.	PageFlipSoundOn _ false.	aBlock value.	PageFlipSoundOn _ old.! !!BookPageMorph methodsFor: 'all' stamp: 'jm 11/2/97 18:22'!color: aColor	super color: aColor.	fillColor2 _ aColor.! !!BookPageMorph methodsFor: 'all' stamp: 'jm 11/2/97 18:18'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	^ bounds! !!BookPageMorph methodsFor: 'all' stamp: 'jm 11/2/97 18:18'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds."	| clippingCanvas |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self drawOn: aCanvas.	clippingCanvas _ aCanvas copyClipRect: bounds.	submorphs isEmpty ifFalse: [		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]].  "draw back-to-front"! !!BookPageMorph methodsFor: 'all' stamp: 'jm 11/2/97 18:23'!initialize	super initialize.	borderWidth _ 0.	fillColor2 _ color.! !!BookPageMorph methodsFor: 'all' stamp: 'jm 11/2/97 18:18'!openToDragNDrop: beOpen	"do nothing.  We do not implement this"! !!BookPageMorph class methodsFor: 'all' stamp: 'jm 11/17/97 13:11'!includeInNewMorphMenu	^ false! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 11/17/97 17:42'!acceptSort	| pages |	pages _ OrderedCollection new.	pageHolder submorphsDo: [:m |		(m isKindOf: BookPageThumbnailMorph) ifTrue: [pages add: m page]].	book newPages: pages currentIndex: pageHolder cursor.	self delete.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 11/17/97 15:17'!addControls	| b r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ LayoutMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Okay';	actionSelector: #acceptSort).	r addMorphBack: (b fullCopy label: 'Cancel';	actionSelector: #cancelSort).	self addMorphBack: r.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 11/17/97 15:14'!cancelSort	self delete.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 11/17/97 19:06'!forBook: aBookMorph	book _ aBookMorph.	pageHolder removeAllMorphs.	pageHolder addAllMorphs:		(book pages collect: [:p | BookPageThumbnailMorph new page: p]).	pageHolder extent: pageHolder width@pageHolder fullBounds height.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 11/17/97 19:40'!initialize	super initialize.	self extent: 440@400;		orientation: #vertical;		centering: #topLeft;		hResizing: #spaceFill;		vResizing: #spaceFill;		inset: 3;		color: Color lightGray;		borderWidth: 2.	pageHolder _ HolderMorph new extent: self extent - borderWidth.	pageHolder cursor: 0.	self addControls.	self addMorphBack: pageHolder.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 11/17/97 16:46'!pageHolder	^ pageHolder! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'jm 11/17/97 17:45'!computeThumbnail	| f scale |	f _ page imageForm.	scale _ self height / f height.  "keep height invariant"	self form: (f magnify: f boundingBox by: scale@scale smoothing: 2).! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'jm 11/17/97 14:01'!initialize	| f |	super initialize.	color _ Color lightGray.  "background color"	f _ Form extent: 60@80 depth: 16.	f fill: f boundingBox fillColor: color.	self form: f.! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'jm 11/17/97 17:30'!page	^ page! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'jm 11/17/97 17:31'!page: aBookPageMorph	page _ aBookPageMorph.	self computeThumbnail.! !!BorderedMorph methodsFor: 'initialization' stamp: 'di 6/20/97 11:07'!initialize	super initialize.	borderColor _ Color black.	borderWidth _ 2.! !!BorderedMorph methodsFor: 'accessing' stamp: 'sw 8/6/97 14:34'!borderColor	^ borderColor! !!BorderedMorph methodsFor: 'accessing' stamp: 'di 6/20/97 11:08'!borderColor: colorOrNil	borderColor _ colorOrNil.	self changed! !!BorderedMorph methodsFor: 'accessing' stamp: 'di 6/20/97 11:24'!borderInset	self borderColor: #inset! !!BorderedMorph methodsFor: 'accessing' stamp: 'di 6/20/97 11:25'!borderRaised	self borderColor: #raised! !!BorderedMorph methodsFor: 'accessing' stamp: 'di 6/20/97 11:09'!borderWidth	^ borderWidth! !!BorderedMorph methodsFor: 'accessing' stamp: 'sw 11/17/97 14:57'!borderWidth: anInteger	borderColor ifNil: [borderColor _ Color black].	borderWidth _ anInteger max: 0.	self changed! !!BorderedMorph methodsFor: 'accessing' stamp: 'sw 11/17/97 14:57'!borderWidthDecr: aNumber	self borderWidth: (self borderWidth - aNumber)! !!BorderedMorph methodsFor: 'accessing' stamp: 'sw 11/17/97 14:57'!borderWidthIncr: aNumber	self borderWidth: (self borderWidth + aNumber)! !!BorderedMorph methodsFor: 'accessing' stamp: 'sw 12/12/97 01:28'!borderWidthMult: aNumber	self borderWidth: (self borderWidth * aNumber)! !!BorderedMorph methodsFor: 'accessing' stamp: 'di 6/20/97 11:19'!doesBevels	"To return true means that this object can show bevelled borders, and	therefore can accept, eg, #raised or #inset as valid borderColors.	Must be overridden by subclasses that do not support bevelled borders."	^ true! !!BorderedMorph methodsFor: 'drawing' stamp: 'di 1/9/98 22:25'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color is generated from the receiver's own color,	while the inset border color is generated from the color of its owner.	This behavior is visually more consistent. Thanks to Hans-Martin Mosner."	| insetColor |	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: bounds color: color.		^ self].	borderColor == #raised ifTrue: [		^ aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: borderWidth			topLeftColor: color lighter			bottomRightColor: color darker].	borderColor == #inset ifTrue: [		insetColor _ owner colorForInsets.		^ aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: borderWidth			topLeftColor: insetColor darker			bottomRightColor: insetColor lighter].	"solid color border"	aCanvas frameAndFillRectangle: bounds		fillColor: color		borderWidth: borderWidth		borderColor: borderColor.! !!BorderedMorph methodsFor: 'drawing' stamp: 'di 11/14/97 11:11'!drawOnFills: aRectangle	^ (bounds containsRect: aRectangle) and: [color isTransparent not]! !!BorderedMorph methodsFor: 'geometry' stamp: 'di 6/20/97 11:15'!innerBounds	^ bounds insetBy: borderWidth! !!BorderedMorph methodsFor: 'menu' stamp: 'sw 8/5/97 13:33'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addList: #(('border color...' changeBorderColor:)						('border width...' changeBorderWidth:)).	self doesBevels ifTrue:		[borderColor == #raised ifFalse: [aCustomMenu add: 'raised bevel' action: #borderRaised].		borderColor == #inset ifFalse: [aCustomMenu add: 'inset bevel' action: #borderInset]]! !!BorderedMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!changeBorderColor: evt	evt hand changeColorTarget: self selector: #borderColor:.! !!BorderedMorph methodsFor: 'menu' stamp: 'di 12/3/97 10:04'!changeBorderWidth: evt	| handle origin |	origin _ evt cursorPoint.	handle _ HandleMorph new forEachPointDo:		[:newPoint | handle removeAllMorphs.		handle addMorph:			(PolygonMorph vertices: (Array with: origin with: newPoint)				color: Color black borderWidth: 1 borderColor: Color black).		self borderWidth: (newPoint - origin) r asInteger // 5].	evt hand attachMorph: handle.	handle startStepping! !!BorderedMorph methodsFor: 'menu' stamp: 'sw 9/11/97 12:04'!partsAndTypesForViewer	"Return an array of part names and part types for use in a viewer on the receiver"	^ super partsAndTypesForViewer, #(		(borderWidth 		number)		(borderColor			color)	)! !!BorderedMorph methodsFor: 'printing' stamp: 'di 6/20/97 11:20'!fullPrintOn: aStream	aStream nextPutAll: '('.	super fullPrintOn: aStream.	aStream nextPutAll: ') setBorderWidth: '; print: borderWidth;		nextPutAll: ' borderColor: ' , (self colorString: borderColor)! !!BorderedMorph methodsFor: 'private' stamp: 'di 6/20/97 11:21'!setBorderWidth: w borderColor: bc	self borderWidth: w.	self borderColor: bc.! !!BorderedMorph methodsFor: 'private' stamp: 'di 6/20/97 11:22'!setColor: c borderWidth: w borderColor: bc	self color: c.	self borderWidth: w.	self borderColor: bc.! !BouncingAtomsMorph comment:'This morph shows how an ideal gas simulation might work. When it gets step messages, it makes all its atom submorphs move along their velocity vectors, bouncing when they hit a wall. It also exercises the Morphic damage reporting and display architecture. Here are some things to try:  1. Resize this morph as the atoms bounce around.  2. In an inspector on this morph, evaluate "self addAtoms: 10."  3. Try setting quickRedraw to false in invalidRect:. This gives the     default damage reporting and incremental redraw. Try it for     100 atoms.  4. In the drawOn: method of AtomMorph, change drawAsRect to true.  5. Create a HeaterCoolerMorph and embed it in the simulation. Extract	it and use an inspector on it to evaluate "self velocityDelta: -5", then     re-embed it. Note the effect on atoms passing over it.'!!BouncingAtomsMorph methodsFor: 'all'!addAtoms: n	"Add a bunch of new atoms."	| a |	n timesRepeat: [		a _ AtomMorph new.		a randomPositionIn: bounds maxVelocity: 10.		self addMorph: a].	self stopStepping.! !!BouncingAtomsMorph methodsFor: 'all'!addMorphFront: aMorph	"Called by the 'embed' meta action. We want non-atoms to go to the back."	"Note: A user would not be expected to write this method. However, a sufficiently advanced user (e.g, an e-toy author) might do something equivalent by overridding the drag-n-drop messages when they are implemented."	(aMorph isMemberOf: AtomMorph)		ifTrue: [super addMorphFront: aMorph]		ifFalse: [super addMorphBack: aMorph].! !!BouncingAtomsMorph methodsFor: 'all'!collisionPairs	"Return a list of pairs of colliding atoms, which are assumed to be circles of known radius. This version uses the morph's positions--i.e. the top-left of their bounds rectangles--rather than their centers."	| count sortedAtoms radius twoRadii radiiSquared collisions p1 continue j p2 distSquared |	count _ submorphs size.	sortedAtoms _ submorphs asSortedCollection:		[ :m1 :m2 | m1 position x < m2 position x].	radius _ 8.	twoRadii _ 2 * radius.	radiiSquared _ radius squared * 2.	collisions _ OrderedCollection new.	1 to: count - 1 do: [ :i |		m1 _ sortedAtoms at: i.		p1 _ m1 position.		continue _ (j _ i + 1) <= count.		[continue] whileTrue: [			m2 _ sortedAtoms at: j.			p2 _ m2 position.			(p2 x - p1 x) <= twoRadii  ifTrue: [				distSquared _ (p1 x - p2 x) squared + (p1 y - p2 y) squared.				distSquared < radiiSquared ifTrue: [					collisions add: (Array with: m1 with: m2)].				continue _ (j _ j + 1) <= count.			] ifFalse: [				continue _ false.			].		].	].	^ collisions! !!BouncingAtomsMorph methodsFor: 'all'!drawOn: aCanvas	"Clear the damageReported flag when redrawn."	super drawOn: aCanvas.	damageReported _ false.! !!BouncingAtomsMorph methodsFor: 'all' stamp: 'jm 7/30/97 09:45'!initialize	super initialize.	damageReported _ false.	self extent: 400@250.	self color: (Color r: 0.8 g: 1.0 b: 0.8).	infectionHistory _ OrderedCollection new.	transmitInfection _ false. 	self addAtoms: 30.! !!BouncingAtomsMorph methodsFor: 'all'!invalidRect: damageRect	"Try setting 'quickRedraw' to true. This invalidates the entire morph, whose bounds typically subsume all it's submorphs. (However, this code checks that assumption and passes through any damage reports for out-of-bounds submorphs. Note that atoms with super-high velocities do occaisionally shoot through the walls!!) An additional optimization is to only submit only damage report per display cycle by using the damageReported flag, which is reset to false when the morph is drawn."	| quickRedraw |	quickRedraw _ true.  "false gives the original invalidRect: behavior"	(quickRedraw and:	 [(bounds origin <= damageRect topLeft) and:	 [damageRect bottomRight <= bounds corner]]) ifTrue: [		"can use quick redraw if damage is within my bounds"		damageReported ifFalse: [super invalidRect: bounds].  "just report once"		damageReported _ true.	] ifFalse: [super invalidRect: damageRect].  "ordinary damage report"! !!BouncingAtomsMorph methodsFor: 'all'!setGermCount	| countString count |	countString _ FillInTheBlank		request: 'Number of cells?'		initialAnswer: self submorphCount printString.	countString isEmpty ifTrue: [^ self].	count _ Integer readFrom: (ReadStream on: countString).	self removeAllMorphs.	self addAtoms: count.! !!BouncingAtomsMorph methodsFor: 'all'!startInfection	self submorphsDo: [:m | m infected: false].	self firstSubmorph infected: true.	infectionHistory _ OrderedCollection new: 500.	transmitInfection _ true.	self startStepping.! !!BouncingAtomsMorph methodsFor: 'all'!step	"Bounce those atoms!!"	| r |	r _ bounds origin corner: (bounds corner - (8@8)).	self submorphsDo: [ :m |		(m isMemberOf: AtomMorph) ifTrue: [m bounceIn: r]].	transmitInfection ifTrue: [self transmitInfection].! !!BouncingAtomsMorph methodsFor: 'all'!stepTime	"As fast as possible."	^ 0! !!BouncingAtomsMorph methodsFor: 'all'!transmitInfection	| infected count graph |	self collisionPairs do: [:pair |		infected _ false.		pair do: [:atom | atom infected ifTrue: [infected _ true]].		infected			ifTrue: [pair do: [:atom | atom infected: true]]].	count _ 0.	self submorphsDo: [:m | m infected ifTrue: [count _ count + 1]].	infectionHistory addLast: count.	count = submorphs size ifTrue: [		"done!! place a graph of the infection history in the world"		graph _ GraphMorph new data: infectionHistory.		graph position: bounds topRight + (10@0).		graph extent: (((infectionHistory size * 3) + (2 * graph borderWidth))@count).		self world addMorph: graph.		graph changed.		transmitInfection _ false.		self stopStepping].! !!BraceNode methodsFor: 'code generation'!emitForValue: stack on: aStream	"elem1, ..., elemN, collectionClass, N, fromBraceStack:"	elements do: [:element | element emitForValue: stack on: aStream].	collClassNode emitForValue: stack on: aStream.	nElementsNode emitForValue: stack on: aStream.	fromBraceStackNode emit: stack args: 1 on: aStream.	stack pop: elements size! !!Browser methodsFor: 'accessing' stamp: 'di 1/14/98 13:46'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass |	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ Class template: self selectedSystemCategoryName].	editSelection == #editClass 		ifTrue: [^ self selectedClassOrMetaClass definition].	editSelection == #editComment 		ifTrue: [(theClass _ self selectedClass) ifNil: [^ ''].				comment _ theClass comment.				comment size = 0				ifTrue: [ ^ 'This class has not yet been commented.']				ifFalse: [ ^ comment]].	editSelection == #hierarchy 		ifTrue: [^ self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue: [^ self selectedClassOrMetaClass sourceCodeTemplate].	editSelection == #editMessage		ifTrue: [^ self selectedMessage].	self error: 'Browser internal error: unknown edit selection.'! !!Browser methodsFor: 'accessing' stamp: 'di 1/14/98 14:01'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be 	updated. The information can be a variety of things, depending on the 	list selections (such as templates for class or message definition, methods) 	or the user menu commands (such as definition, comment, hierarchy). 	Answer the result of updating the source."	| aString aText theClass |	aString _ input asString.	aText _ input asText.	editSelection == #editSystemCategories 		ifTrue: [^ self changeSystemCategories: aString].	editSelection == #editClass | (editSelection == #newClass) 		ifTrue: [^ self defineClass: aString notifying: aController].	editSelection == #editComment 		ifTrue: [theClass _ self selectedClass.				theClass ifNil: [PopUpMenu notify: 'You must select a classbefore giving it a comment.'.				^ false].				theClass comment: aText. ^ true].	editSelection == #hierarchy ifTrue: [^ true].	editSelection == #editMessageCategories 		ifTrue: [^ self changeMessageCategories: aString].	editSelection == #editMessage | (editSelection == #newMessage) 		ifTrue: [^ self defineMessage: aText notifying: aController].	editSelection == #none		ifTrue: [PopUpMenu notify: 'This text cannot be acceptedin this part of the browser.'.				^ false].	self error: 'unacceptable accept'! !!Browser methodsFor: 'accessing' stamp: 'tk 1/16/98 16:41'!wantsBoldSelector	"In code pane?  Only when a message selected"	^ self messageListIndex ~= 0! !!Browser methodsFor: 'system category functions'!browseAllClasses	"Create and schedule a new browser on all classes alphabetically."	| newBrowser view |	newBrowser _ HierarchyBrowser new initAlphabeticListing.	BrowserView openBrowserView: (BrowserView systemCategoryBrowser: newBrowser editString: nil)		label: 'All Classes Alphabetically'! !!Browser methodsFor: 'system category functions' stamp: 'di 6/28/97 19:02'!printOutSystemCategories	"Print a description of each class in the selected category as Html."	systemCategoryListIndex ~= 0		ifTrue: [systemOrganizer fileOutCategory: self selectedSystemCategoryName								asHtml: true ]! !!Browser methodsFor: 'class list' stamp: 'di 1/14/98 13:40'!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className |classListIndex _ anInteger.	self setClassOrganizer.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self classCommentIndicated		ifTrue: []		ifFalse: [editSelection _ anInteger = 0					ifTrue: [metaClassIndicated						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass]].	contents _ nil.	self selectedClass isNil		ifFalse: [className _ self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged! !!Browser methodsFor: 'class list'!hierarchy        "Display the inheritance hierarchy of the receiver's selected class."        classListIndex = 0 ifTrue: [^ self].        self okToChange ifFalse: [^ self].        self messageCategoryListIndex: 0.        editSelection := #hierarchy.        self changed: #editComment.        ^ self! !!Browser methodsFor: 'class list' stamp: 'sw 12/19/96'!recent	"Let the user select from a list of recently visited classes.  11/96 stp.	 12/96 di:  use class name, not classes themselves.	 : dont fall into debugger in empty case"	| className class recentList |	recentList _ RecentClasses select: [:n | Smalltalk includesKey: n].	recentList size == 0 ifTrue: [^ self beep].	className := (SelectionMenu selections: recentList) startUp.	className == nil ifTrue: [^ self].	class := Smalltalk at: className.	self systemCategoryListIndex: (self systemCategoryList indexOf: class category).	self classListIndex: (self classList indexOf: class name)! !!Browser methodsFor: 'class list'!selectClass: classNotMeta	self classListIndex: (self classList findFirst: [:each | each == classNotMeta name])! !!Browser methodsFor: 'class list'!spawnHierarchy        "Create and schedule a new class hierarchy browser on the currently selected class or meta."        | newBrowser view |        classListIndex = 0 ifTrue: [^ self].        newBrowser _ HierarchyBrowser new initHierarchyForClass: self selectedClass                         meta: self metaClassIndicated.        view _ BrowserView systemCategoryBrowser: newBrowser editString: nil.        Browser postOpenSuggestion: (Array with: self selectedClassOrMetaClass                         with: self selectedMessageName).        BrowserView openBrowserView: view                label: self selectedClassName , ' hierarchy'! !!Browser methodsFor: 'class functions' stamp: 'di 10/17/97 14:36'!browseUnusedMethods	| classes unsent messageList |	classes _ Array with: self selectedClass with: self selectedClass class.	unsent _ Set new.	classes do: [:c | unsent addAll: c selectors].	unsent _ Smalltalk allUnSentMessagesIn: unsent.	messageList _ OrderedCollection new.	classes do: [:c | (c selectors select: [:s | unsent includes: s]) asSortedCollection					do: [:sel | messageList add: c name , ' ' , sel]].	Smalltalk browseMessageList: messageList name: 'Unsent Methods in ', self selectedClass name! !!Browser methodsFor: 'class functions' stamp: 'di 1/14/98 14:09'!editComment	"Retrieve the description of the class comment."	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	editSelection _ #editComment.	self changed: #classSelectionChanged! !!Browser methodsFor: 'class functions' stamp: 'di 6/28/97 09:58'!printOutClass	"Print a description of the selected class onto a file whose name is the 	category name followed by .html."	classListIndex ~= 0 ifTrue: [self selectedClass fileOutAsHtml: true]! !!Browser methodsFor: 'class functions' stamp: 'di 7/13/97 16:43'!spawnProtocol        "Create and schedule a new protocol browser on the currently selected class or meta."        classListIndex = 0 ifTrue: [^ self].        ProtocolBrowser openSubProtocolForClass: self selectedClassOrMetaClass  ! !!Browser methodsFor: 'message category functions' stamp: 'di 6/28/97 15:38'!printOutMessageCategories	"Print a description of the selected message category of the selected class 	onto an external file in Html format."	messageCategoryListIndex ~= 0		ifTrue: 			[self selectedClassOrMetaClass fileOutCategory: self selectedMessageCategoryName										asHtml: true]! !!Browser methodsFor: 'message list' stamp: 'tk 12/12/97 13:01'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector method tempNames |	contents == nil ifFalse: [^ contents copy].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector.	(Sensor controlKeyPressed		or: [method fileIndex > 0 and: [(SourceFiles at: method fileIndex) == nil]])		ifTrue:		["Emergency or no source file -- decompile without temp names"		contents _ (class decompilerClass new decompile: selector in: class method: method)			decompileString.		^ contents copy].	Sensor leftShiftDown ifTrue:		["Special request to decompile -- get temps from source file"		tempNames _ (class compilerClass new						parse: method getSourceFromFile asString in: class notifying: nil)						tempNames.		contents _ ((class decompilerClass new withTempNames: tempNames)				decompile: selector				in: class				method: method) decompileString.		^ contents copy].	contents _ class sourceCodeAt: selector.	^ contents copy! !!Browser methodsFor: 'message functions' stamp: 'di 7/13/97 11:14'!defineMessage: aString notifying: aController 	"Compile the expressions in aString. Notify aController if a syntax error 	occurs. Install the compiled method in the selected class classified under 	the currently selected message category name. Answer true if 	compilation succeeds, false otherwise."	| selectedMessageName selector category oldMessageList |	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	contents _ nil.	selector _ self selectedClassOrMetaClass				compile: aString				classified: (category _ self selectedMessageCategoryName)				notifying: aController.	selector == nil ifTrue: [^ false].	contents _ aString copy.	selector ~~ selectedMessageName		ifTrue: 			[category = ClassOrganizer nullCategory				ifTrue: [self changed: #classSelectionChanged.						self messageCategoryListIndex: 1].			self setClassOrganizer.  "In case organization not cached"			(oldMessageList includes: selector)				ifFalse: [self changed: #messageListChanged].			self messageListIndex: (self messageList indexOf: selector)].	^ true! !!Browser methodsFor: 'message functions' stamp: 'di 6/27/97 21:25'!fileOutMessage	"Print a description of the selected message"	messageListIndex = 0 ifTrue: [^ self].	self selectedClassOrMetaClass fileOutMethod: self selectedMessageName! !!Browser methodsFor: 'message functions'!maybeSetSelection	"After a browser's message list is changed, this message is dispatched to the model, to give it a chance to refigure a selection"! !!Browser methodsFor: 'message functions'!methodHierarchy 	"Create and schedule a message set browser on all implementors of the 	currently selected message selector. Do nothing if no message is selected."	| sel list tab stab |	messageListIndex = 0 ifTrue: [^ self].	sel _ self selectedMessageName.	list _ OrderedCollection new.	tab _ ''.	self selectedClassOrMetaClass allSuperclasses reverseDo:		[:cl |		(cl includesSelector: sel) ifTrue:			[list addLast: tab , cl name, ' ', sel].		tab _ tab , '  '].	self selectedClassOrMetaClass allSubclassesWithLevelDo:		[:cl :level |		(cl includesSelector: sel) ifTrue:			[stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].			list addLast: tab , stab , cl name, ' ', sel]]	 	startingLevel: 0.	Smalltalk browseMessageList: list		name: 'Inheritance of ' , self selectedMessageName! !!Browser methodsFor: 'message functions' stamp: 'di 6/28/97 15:53'!printOutMessage	"Print a description of the selected message"	messageListIndex = 0 ifTrue: [^ self].	self selectedClassOrMetaClass fileOutMethod: self selectedMessageName							asHtml: true! !!Browser methodsFor: 'message functions' stamp: 'jm 7/30/97 16:48'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that 	the currently selected message should be removed from the system. If so, 	remove it.  If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed.	1/15/96 sw: started to modify as per Dan's request"	| messageName confirmation |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self selectedClassOrMetaClass confirmRemovalOf: messageName.	confirmation == 3 ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: self selectedMessageName.	self messageListIndex: 0.	self setClassOrganizer.  "In case organization not cached"	self changed: #messageListChanged.	confirmation == 2 ifTrue:		[Smalltalk browseAllCallsOn: messageName]! !!Browser methodsFor: 'metaclass' stamp: 'di 1/14/98 12:25'!classCommentIndicated	"Answer true iff we're viewing the class comment."	^ editSelection == #editComment ! !!Browser methodsFor: 'metaclass'!classMessagesIndicated	"Answer whether the messages to be presented should come from the 	metaclass."	^ self metaClassIndicated! !!Browser methodsFor: 'metaclass'!classOrMetaClassOrganizer	"Answer the class organizer for the metaclass or class, depending on 	which (instance or class) is indicated."	self metaClassIndicated		ifTrue: [^metaClassOrganizer]		ifFalse: [^classOrganizer]! !!Browser methodsFor: 'metaclass' stamp: 'di 1/14/98 13:20'!instanceMessagesIndicated	"Answer whether the messages to be presented should come from the 	class."	^metaClassIndicated not and: [self classCommentIndicated not]! !!Browser methodsFor: 'metaclass' stamp: 'di 1/14/98 13:19'!metaClassIndicated	"Answer the boolean flag that indicates which of the method dictionaries, 	class or metaclass."	^ metaClassIndicated and: [self classCommentIndicated not]! !!Browser methodsFor: 'metaclass'!selectedClassOrMetaClass	"Answer the selected class or metaclass."	self metaClassIndicated		ifTrue: [^ self selectedClass class]		ifFalse: [^ self selectedClass]! !!Browser methodsFor: 'metaclass' stamp: 'di 1/14/98 13:27'!setClassOrganizer	"Install whatever organization is appropriate"	| theClass |	classOrganizer _ nil.	metaClassOrganizer _ nil.	classListIndex = 0 ifTrue: [^ self].	classOrganizer _ (theClass _ self selectedClass) organization.	metaClassOrganizer _ theClass class organization.! !!Browser class methodsFor: 'instance creation'!newOnClass: aClass 	"Open a new class browser on this class."	| index newBrowser |	newBrowser _ Browser new.	newBrowser systemCategoryListIndex:		(index _ SystemOrganization numberOfCategoryOfElement: aClass name).	newBrowser classListIndex: ((SystemOrganization listAtCategoryNumber: index)			findFirst: [:each | each == aClass name]).	newBrowser metaClassIndicated: false.	BrowserView openClassBrowser: newBrowser editString: nil label: 'Class Browser:', aClass name! !!Browser class methodsFor: 'class initialization'!initialize        "Browser initialize"        RecentClasses := OrderedCollection new! !!BrowserCodeController methodsFor: 'menu messages'!explain	"Try to shed some light on what kind of entity the current selection is. 	The selection must be a single token or construct. Insert the answer after 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	| string tiVars cgVars selectors delimitors numbers sorry reply |	Cursor execute		showWhile: 			[sorry _ '"Sorry, I can''t explain that.  Please select a single token, construct, or special character.'.			sorry _ sorry , (model isUnlocked							ifTrue: ['"']							ifFalse: ['  Also, please cancel or accept."']).			(string _ self selection asString) isEmpty				ifTrue: [reply _ '']				ifFalse: 					[string _ self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are 					all  					letters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: [])						~~ nil						ifFalse: 							[tiVars _ self explainTemp: string.							tiVars == nil ifTrue: [tiVars _ self explainInst: string]].					(tiVars == nil and: [model class == Browser])						ifTrue: [tiVars _ model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars _ '']						ifFalse: [tiVars _ tiVars , NewLine].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:symbol | symbol])						ifTrue: 							[cgVars _ self explainCtxt: symbol.							cgVars == nil								ifTrue: 									[cgVars _ self explainClass: symbol.									cgVars == nil ifTrue: [cgVars _ self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors _ self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors _ self explainPartSel: string.									selectors == nil ifTrue: [selectors _ self explainAnySel: symbol]]]						ifFalse: [selectors _ self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars _ '']						ifFalse: [cgVars _ cgVars , NewLine].					selectors == nil						ifTrue: [selectors _ '']						ifFalse: [selectors _ selectors , NewLine].					string size = 1						ifTrue: ["single special characters"							delimitors _ self explainChar: string]						ifFalse: ["matched delimitors"							delimitors _ self explainDelimitor: string].					numbers _ self explainNumber: string.					numbers == nil ifTrue: [numbers _ ''].					delimitors == nil ifTrue: [delimitors _ ''].					reply _ tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply _ sorry].			self afterSelectionInsertAndSelect: reply]! !!BrowserCodeController methodsFor: 'menu messages'!format	"Reformat the contents of the receiver's view, formatted, if the view is unlocked. "	| selectedClass aCompiler newText locked |	locked _ model isLocked.	model messageListIndex = 0 | locked ifTrue: [^view flash].	selectedClass _ model selectedClassOrMetaClass.	Cursor execute showWhile: 		[aCompiler _ selectedClass compilerClass new.		self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		newText _ aCompiler			format: model contents			in: selectedClass			notifying: self.		newText == nil ifFalse: 			[self replaceSelectionWith:				(newText asText makeSelectorBoldIn: selectedClass).			self selectAt: 1]].	locked ifFalse: [self unlockModel] ! !!BrowserCodeController methodsFor: 'menu messages'!showBytecodes	"Show the bytecodes of the selected method."	| selectedClass newText |	(model messageListIndex = 0) | (model isLocked) ifTrue: [		^view flash.	].	selectedClass _ model selectedClassOrMetaClass.	Cursor execute showWhile: [		self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		newText _ (selectedClass compiledMethodAt: model selectedMessageName) symbolic asText.		self replaceSelectionWith: newText.		self selectAt: 1.	].	self unlockModel.! !!BrowserCodeController methodsFor: 'private'!explainClass: symbol 	"Is symbol a class variable or a pool variable?"	| class reply classes |	class _ model selectedClass.	class == nil ifTrue: [^nil].	  "no class is selected"	(class isKindOf: Metaclass) ifTrue: [class _ class soleInstance].	classes _ (Array with: class) , class allSuperclasses.	"class variables"	reply _ classes detect: [:each | (each classVarNames			detect: [:name | symbol = name] ifNone: [])			~~ nil] ifNone: [].	reply == nil ifFalse: [^'"is a class variable; defined in class ' , reply printString, '"', NewLine,		'Smalltalk browseAllCallsOn: (', reply printString, ' classPool associationAt: #', symbol, ').'].	"pool variables"	classes do: [:each | (each sharedPools			detect: [:pool | (pool includesKey: symbol) and: [reply _ pool. true]]			ifNone: []) ~~ nil].	reply == nil ifTrue: [(Undeclared includesKey: symbol) ifTrue: [reply _ Undeclared]].	reply == nil		ifFalse: 			[classes _ WriteStream on: Array new.			Smalltalk allBehaviorsDo: [:each |					(each sharedPools detect: [:pool | pool == reply] ifNone: [])					~~ nil ifTrue: [classes nextPut: each]].			"Perhaps not print whole list of classes if too long. (unlikely)"			^'"is a pool variable from the pool ' , (Smalltalk keyAtValue: reply),			', which is used by the following classes ' , classes contents printString , '"', NewLine,			'Smalltalk browseAllCallsOn: (', (Smalltalk keyAtValue: reply) printString,			' associationAt: #', symbol, ').'].	^nil! !!BrowserCodeController methodsFor: 'private'!explainDelimitor: string	"Is string enclosed in delimitors?"	| str |	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"	(string first = string last) ifTrue:			[^ self explainChar: (String with: string first)]		ifFalse:			[(string first = $( and: [string last = $)]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $[ and: [string last = $]]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $< and: [string last = $>]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $# and: [string last = $)]) ifTrue:				[^'"An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array."'].			string first = $# ifTrue:				[^'"An instance of class Symbol."'].			(string first = $$ and: [string size = 2]) ifTrue:				[^'"An instance of class Character.  This one is the character ', (String with: string last), '."'].			(string first = $:) ifTrue:				[str _ string allButFirst.				(self explainTemp: str) ~~ nil ifTrue:					[^'"An argument to this block will be bound to the temporary variable ',						str, '."']]].	^ nil! !!BrowserCodeController methodsFor: 'private'!explainGlobal: symbol 	"Is symbol a global variable?"	| reply classes |	reply _ Smalltalk at: symbol ifAbsent: [^nil].	(reply isKindOf: Behavior)		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,			'."', NewLine, 'Browser newOnClass: ' , symbol , '.'].	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].	reply class == Dictionary		ifTrue: 			[classes _ Set new.			Smalltalk allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]					ifNone: [])					~~ nil ifTrue: [classes add: each]].			classes _ classes printString.			^'"is a global variable.  ' , symbol , ' is a Dictionary.  It is a pool which is used by the following classes' , (classes copyFrom: 4 to: classes size) , '"'].	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'! !!BrowserCodeController methodsFor: 'private'!explainInst: string 	"Is string an instance variable of this class?"	| classes |	model selectedClassOrMetaClass == nil ifTrue: [^nil].	  "no class is selected"	classes _ (Array with: model selectedClassOrMetaClass)				, model selectedClassOrMetaClass allSuperclasses.	classes _ classes detect: [:each | (each instVarNames			detect: [:name | name = string] ifNone: [])			~~ nil] ifNone: [^nil].	classes _ classes printString.	^ '"is an instance variable of the receiver; defined in class ' , classes , '"',		NewLine , classes , ' browseAllAccessesTo: ''' , string , '''.'! !!BrowserCodeController methodsFor: 'private'!explainPartSel: string 	"Is this a fragment of a multiple-argument selector sent in this method?"	| lits whole reply classes s |	model messageListIndex = 0 ifTrue: [^nil].  "not in a message"	string last == $: ifFalse: [^nil].	"Name of this method"	lits _ Array with: model selectedMessageName.	(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]					ifNone: []) ~~ nil]				ifNone: []) ~~ nil		ifTrue: [reply _ ', which is the selector of this very method!!'.			s _ '.  To see the other definitions, go to the message list pane and use yellowbug to select ''implementors''."']		ifFalse: 			["Selectors called from this method"			lits _ (model selectedClassOrMetaClass compiledMethodAt:				model selectedMessageName) messages.			(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]							ifNone: []) ~~ nil]						ifNone: []) ~~ nil				ifFalse: [string = 'primitive:'					ifTrue: [^self explainChar: '<']					ifFalse: [^nil]].			reply _ '.'.			s _ '.  To see the definitions, go to the message list pane and use yellowbug to select ''messages''."'].	classes _ Smalltalk allClassesImplementing: whole.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !!BrowserCodeView methodsFor: 'updating' stamp: 'tk 1/16/98 16:41'!updateDisplayContents 	"Refer to the comment in StringHolderView|updateDisplayContents."	| contents |	contents _ model contents.	displayContents asString ~= contents		ifTrue: 			[model wantsBoldSelector				ifTrue: [contents _ contents asText								makeSelectorBoldIn: model selectedClassOrMetaClass].			self editString: contents.			self displayView.			model editSelection == #newMessage ifTrue:				[controller selectFrom: 1 to: contents size]]! !!BrowserListView methodsFor: 'updating'!getListAndDisplayView	"Display the list of items."	| newList |	newList _ self getList.	isEmpty & newList isEmpty		ifTrue: [^self]		ifFalse: 			[self list: newList.			model maybeSetSelection.			self displayView; emphasizeView]! !!BrowserView class methodsFor: 'instance creation' stamp: 'sw 3/11/96'!instanceBrowserViewOn: aBrowser	"Answer an instance of me on the model, aBrowser, which looks at a user-defined instance-class. The view has three subviews.  "	| browserView  messageCategoryListView messageListView browserCodeView |	browserView _ self new model: aBrowser.	messageCategoryListView _ self buildMessageCategoryListView: aBrowser.	messageListView _ self buildMessageListView: aBrowser.	browserCodeView _ self buildBrowserCodeView: aBrowser editString: nil.	browserView addSubView: messageCategoryListView.	browserView addSubView: messageListView.	browserView addSubView: browserCodeView.	messageListView 		align: messageListView viewport topLeft 		with: messageCategoryListView viewport topRight.	browserCodeView 		window: browserCodeView window 		viewport: (messageCategoryListView viewport bottomLeft 					corner: messageListView viewport bottomRight + (0 @ 110)).	^ browserView! !!BrowserView class methodsFor: 'instance scheduling' stamp: 'sw 9/19/97 16:28'!openSystemCategoryBrowser: aBrowser editString: aString 	"Create and schedule a BrowserView with label 'System Category 	Browser'. The view consists of five subviews, starting with the single 	item list view of the currently selected system category of the 	SystemOrganization. The initial text view part is a view of the characters 	in aString."	self openBrowserView: 			(BrowserView systemCategoryBrowser: aBrowser editString: aString)		label:			'Classes in category ', aBrowser selectedSystemCategoryName! !!BrowserView class methodsFor: 'private' stamp: 'di 1/14/98 13:29'!buildClassSwitchView: aBrowser	| aSwitchView |	aSwitchView _ SwitchView new.	aSwitchView model: aBrowser.	aSwitchView controller: LockedSwitchController new.	aSwitchView selector: #classMessagesIndicated.	aSwitchView controller selector: #indicateClassMessages.	aSwitchView window: (0 @ 0 extent: 15 @ 8).	aSwitchView label: 'class' asParagraph.	^aSwitchView! !!BrowserView class methodsFor: 'private' stamp: 'di 1/14/98 12:25'!buildCommentSwitchView: aBrowser	| aSwitchView |	aSwitchView _ SwitchView new.	aSwitchView model: aBrowser.	aSwitchView controller: LockedSwitchController new.	aSwitchView borderWidthLeft: 0 right: 1 top: 0 bottom: 0.	aSwitchView selector: #classCommentIndicated.	aSwitchView controller selector: #editComment.	aSwitchView window: (0 @ 0 extent: 10 @ 8).	aSwitchView label: '?' asText allBold asParagraph.	^aSwitchView! !!BrowserView class methodsFor: 'private' stamp: 'di 1/14/98 12:05'!buildInstanceClassSwitchView: aBrowser	| aView aSwitchView |	aView _ View new model: aBrowser.	aView window: (0 @ 0 extent: 50 @ 8).	aView borderWidthLeft: 2 right: 0 top: 0 bottom: 2.	aSwitchView _ self buildInstanceSwitchView: aBrowser.	aView addSubView: aSwitchView		align: aSwitchView viewport topLeft		with: aView window topLeft.	aSwitchView _ self buildCommentSwitchView: aBrowser.	aView addSubView: aSwitchView		align: aSwitchView viewport topLeft		with: aView lastSubView viewport topRight.	aSwitchView _ self buildClassSwitchView: aBrowser.	aView addSubView: aSwitchView		align: aSwitchView viewport topLeft		with: aView lastSubView viewport topRight.	^aView! !!BrowserView class methodsFor: 'private' stamp: 'di 1/14/98 13:28'!buildInstanceSwitchView: aBrowser	| aSwitchView |	aSwitchView _ SwitchView new.	aSwitchView model: aBrowser.	aSwitchView controller: LockedSwitchController new.	aSwitchView borderWidthLeft: 0 right: 1 top: 0 bottom: 0.	aSwitchView selector: #instanceMessagesIndicated.	aSwitchView controller selector: #indicateInstanceMessages.	aSwitchView window: (0 @ 0 extent: 25 @ 8).	aSwitchView label: 'instance' asParagraph.	^aSwitchView! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 22:56'!addButtonRows	"Spun off to allow subclasses to customize the buttons but still benefit from super intialize"	| r |	r _ LayoutMorph newRow vResizing: #shrinkWrap; inset: 0.	r addMorphBack: (self buttonName: '>>' action: #nextLayer).	r addMorphBack: (self buttonName: '<<' action: #prevLayer).	r addMorphBack: (self buttonName: 'shrink to changing pixels' action: #shrinkToChange).	r addMorphBack: (self buttonName: 'extract' action: #extract).	self addMorphBack: r.! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 15:28'!buttonName: aString action: aSymbol	^ SimpleButtonMorph new		target: self;		label: aString;		actionSelector: aSymbol! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 23:04'!extract	| selRect thisF holder uniqueForms |	selRect _ selectionRect innerBounds translateBy: visibleLayer topLeft negated.	uniqueForms _ OrderedCollection new.	layers do: [:f |		thisF _ f copy: selRect.		uniqueForms detect: [:oldF | oldF bits = thisF bits] ifNone: [uniqueForms add: thisF]].	holder _ HolderMorph new.	uniqueForms do: [:f | holder addMorphBack: (SketchMorph new form: f)].	self world addMorph: holder.! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 15:28'!handlesMouseDown: evt	^ selectionRect containsPoint: evt cursorPoint! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 18:18'!initialize	super initialize.	borderWidth _ 2.	inset _ 3.	orientation _ #vertical.	self addButtonRows.	layers _ EmptyArray.	visibleLayer _ SketchMorph new form: (Form extent: 50@40).	selectionRect _ RectangleMorph new		color: Color transparent;		borderColor: Color magenta;		borderWidth: 3.	visibleLayer addMorph: selectionRect.	previewer _ ImageMorph new.	self addMorphBack: (Morph new color: color; extent: 1@4).  "spacer"	self addMorphBack: visibleLayer.	self addMorphBack: (Morph new color: color; extent: 1@4).  "spacer"	self addMorphBack: previewer.	self updatePreview.! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 15:30'!layers: aCollectionOfForms	layers _ aCollectionOfForms asArray.	layers size > 0 ifTrue: [visibleLayer form: layers first].	self updateSelection.! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 15:30'!mouseDown: evt	| growHandleExtent growHandle |	selectOffset _ evt cursorPoint - selectionRect topLeft.	growHandleExtent _ 4@4.	growHandle _ ((selectionRect bottomRight - growHandleExtent) extent: growHandleExtent).	(growHandle containsPoint: evt cursorPoint)		ifTrue: [selectMode _ #grow]		ifFalse: [selectMode _ #move].! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 18:17'!mouseMove: evt	| w p |	selectMode = #move ifTrue: [		w _ selectionRect borderWidth.		p _ evt cursorPoint - selectOffset.		p _ p adhereTo:			((visibleLayer topLeft - w) extent:			 (visibleLayer extent - selectionRect innerBounds extent)).		selectionRect position: p.		self updatePreview].	selectMode = #grow ifTrue: [		selectionRect extent: (evt cursorPoint - selectionRect topLeft).		self updateSelection].! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 22:42'!nextLayer	| i |	layers size > 1 ifFalse: [^ self].	i _ ((layers indexOf: visibleLayer form) \\ layers size) + 1.	visibleLayer form: (layers at: i).	self updatePreview.! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 15:28'!noop	Smalltalk beep.! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 22:42'!prevLayer	| i |	layers size <= 1 ifTrue: [^ self].	i _ (layers indexOf: visibleLayer form) - 1.	i < 1 ifTrue: [i _ layers size].	visibleLayer form: (layers at: i).	self updatePreview.! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 22:37'!shrinkToChange	| selRect baseF buf changeRect thisF thisR |	selRect _ selectionRect innerBounds translateBy: visibleLayer topLeft negated.	baseF _ layers first copy: selRect.	buf _ Form extent: selRect extent depth: 16.	changeRect _ nil.	2 to: layers size do: [:i |		baseF displayOn: buf.		thisF _ (layers at: i) copy: selRect.		thisF displayOn: buf at: 0@0 rule: 21.  "form subtract"		thisR _ buf innerPixelRectFor: 0 orNot: true.		thisR origin x >= 0 ifTrue: [			changeRect ifNil: [changeRect _ thisR].			changeRect _ changeRect merge: thisR]].	changeRect ifNotNil: [		selectionRect position: selectionRect innerBounds origin + changeRect origin - selectionRect borderWidth.		selectionRect extent: changeRect extent + (2 * selectionRect borderWidth)].	self updateSelection.! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 18:16'!updatePreview	"Update the preview after the selection has changed."	| f |	f _ visibleLayer form		magnify: (selectionRect innerBounds translateBy: visibleLayer topLeft negated)		by: 3.	previewer image: f.! !!ButtonArtExtractorMorph methodsFor: 'all' stamp: 'jm 12/2/97 15:30'!updateSelection	"Update the selection rectangle and preview after the selection has changed."	| w newR |	"contrain selectionRect to be within the visibleLayer bounds"	w _ selectionRect borderWidth.	newR _ selectionRect bounds intersect: (visibleLayer bounds expandBy: w).	selectionRect position: newR origin.	selectionRect extent: newR extent.	self updatePreview.! !!ByteArray methodsFor: 'accessing'!asString	"Convert to a String with Characters for each byte.	Fast code uses primitive that avoids character conversion"	^ (String new: self size) replaceFrom: 1 to: self size with: self! !CachingMorph comment:'This morph can be used to cache the picture of a morph that takes a long time to draw. It should be used with judgement, however, since heavy use of caching can consume large amounts of memory.'!!CachingMorph methodsFor: 'all'!drawOn: aCanvas	submorphs isEmpty ifTrue: [^ super drawOn: aCanvas].! !!CachingMorph methodsFor: 'all'!fullDrawOn: aCanvas	self updateCacheCanvasDepth: aCanvas depth.	aCanvas image: cacheCanvas form at: self fullBounds origin.! !!CachingMorph methodsFor: 'all'!imageForm	self updateCacheCanvasDepth: Display depth.	^ cacheCanvas form offset: self fullBounds topLeft! !!CachingMorph methodsFor: 'all'!initialize	super initialize.	color _ Color veryLightGray.	damageRecorder _ DamageRecorder new.! !!CachingMorph methodsFor: 'all'!invalidRect: damageRect	"Record the given rectangle in the damage list."	damageRecorder recordInvalidRect: (damageRect translateBy: self fullBounds origin negated).	super invalidRect: damageRect.! !!CachingMorph methodsFor: 'all' stamp: 'jm 11/13/97 16:31'!releaseCachedState	super releaseCachedState.	cacheCanvas _ nil.! !!CachingMorph methodsFor: 'all' stamp: 'jm 7/30/97 12:43'!updateCacheCanvasDepth: depth	"Update the cached image of the morphs being held by this hand."	| myBnds rectList c |	myBnds _ self fullBounds.	(cacheCanvas == nil or: [cacheCanvas extent ~= myBnds extent]) ifTrue: [		cacheCanvas _ FormCanvas extent: myBnds extent depth: depth.		c _ cacheCanvas copyOffset: myBnds origin negated.		^ super fullDrawOn: c].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: myBnds extent).	damageRecorder reset.	rectList do: [:r |		c _ cacheCanvas copyOrigin: myBnds origin negated clipRect: r.		c fillColor: Color transparent.  "clear to transparent"		super fullDrawOn: c].! !Canvas comment:'A canvas is a two-dimensional medium on which morphs are drawn in a device-independent manner. Canvases keep track of the origin and clipping rectangle, as well as the underlying drawing medium (such as a window, pixmap, or postscript script).This kind of canvas does no drawing, and may be used as a "null canvas" to factor out drawing time during performance measurements.'!!Canvas methodsFor: 'initialization'!reset	origin _ 0@0.							"origin of the top-left corner of this cavas"	clipRect _ (0@0 corner: 10000@10000).		"default clipping rectangle"	shadowDrawing _ false.					"draw translucent shadows when true"! !!Canvas methodsFor: 'copying' stamp: 'jm 8/2/97 13:54'!copy	^ self clone! !!Canvas methodsFor: 'copying'!copyClipRect: aRectangle	^ self copyOrigin: origin clipRect: (aRectangle translateBy: origin)! !!Canvas methodsFor: 'copying'!copyForShadowDrawingOffset: aPoint	^ (self copyOrigin: origin + aPoint clipRect: clipRect) setShadowDrawing! !!Canvas methodsFor: 'copying'!copyOffset: aPoint	^ self copyOrigin: origin + aPoint clipRect: clipRect! !!Canvas methodsFor: 'copying'!copyOffset: aPoint clipRect: sourceClip	"Make a copy of me offset by aPoint, and further clipped	by sourceClip, a rectangle in the un-offset coordinates"	^ self copyOrigin: aPoint + origin		clipRect: ((sourceClip translateBy: origin) intersect: clipRect)! !!Canvas methodsFor: 'copying'!copyOrigin: aPoint clipRect: aRectangle	"Return a copy of this canvas with the given origin. The clipping rectangle of this canvas is the intersection of the given rectangle and the receiver's current clipping rectangle. This allows the clipping rectangles of nested clipping morphs to be composed."	^ self copy		setOrigin: aPoint		clipRect: (clipRect intersect: aRectangle)! !!Canvas methodsFor: 'accessing'!clipRect	^ clipRect translateBy: origin negated! !!Canvas methodsFor: 'accessing'!depth	^ Display depth! !!Canvas methodsFor: 'accessing'!origin	^ origin! !!Canvas methodsFor: 'testing'!isVisible: aRectangle	"Optimization of: ^ clipRect intersects: (aRectangle translateBy: origin)"	^ ((aRectangle right + origin x) < clipRect left or:	  [(aRectangle left + origin x) > clipRect right or:	  [(aRectangle bottom + origin y) < clipRect top or:	  [(aRectangle top + origin y) > clipRect bottom]]]) not! !!Canvas methodsFor: 'drawing'!fillColor: c	"Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'drawing' stamp: 'jm 8/2/97 13:54'!fillOval: r color: c	self fillOval: r color: c borderWidth: 0 borderColor: Color transparent.! !!Canvas methodsFor: 'drawing' stamp: 'jm 8/2/97 13:54'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	"Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'drawing'!fillRectangle: r color: c	"Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'drawing' stamp: 'jm 8/2/97 13:54'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	"Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'drawing' stamp: 'jm 8/2/97 13:54'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	"Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'drawing' stamp: 'jm 8/2/97 14:08'!frameOval: r color: c	self fillOval: r color: Color transparent borderWidth: 1 borderColor: c.! !!Canvas methodsFor: 'drawing' stamp: 'jm 8/2/97 14:10'!frameOval: r width: w color: c	self fillOval: r color: Color transparent borderWidth: w borderColor: c.! !!Canvas methodsFor: 'drawing'!frameRectangle: r color: c	self frameRectangle: r width: 1 color: c.! !!Canvas methodsFor: 'drawing'!frameRectangle: r width: w color: c	"Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'drawing'!image: i at: aPoint	"Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'drawing' stamp: 'jm 7/28/97 14:30'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'drawing' stamp: 'jm 8/2/97 13:54'!line: pt1 to: pt2 color: c	self line: pt1 to: pt2 width: 1 color: c.! !!Canvas methodsFor: 'drawing'!line: pt1 to: pt2 width: w color: c	"Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'drawing'!paragraph: paragraph bounds: bounds color: c	"Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'drawing'!point: p color: c	"Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'drawing' stamp: 'jm 8/2/97 13:54'!text: s at: pt font: fontOrNil color: c	^ self text: s bounds: (pt extent: 10000@10000) font: fontOrNil color: c! !!Canvas methodsFor: 'drawing' stamp: 'jm 8/2/97 13:54'!text: s bounds: boundsRect font: fontOrNil color: c	"Draw the given string in the given font and color clipped to the given rectangle. If the font is nil, the default font is used. Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'private'!setOrigin: aPoint clipRect: aRectangle	origin _ aPoint.	clipRect _ aRectangle.! !!Canvas methodsFor: 'private'!setShadowDrawing	"Put this canvas into 'shadow drawing' mode, which is used to draw translucent shadows. While in this mode, all drawing operations are done in black through a gray mask. The mask allows some of the underlying pixels to show through, providing a crude sense of transparency."	shadowDrawing _ true.! !!CascadeNode methodsFor: 'C translation'!asTranslatorNode	^TStmtListNode new		setArguments: #()		statements: (messages collect:			[ :msg | msg asTranslatorNode receiver: receiver asTranslatorNode ])! !!CautiousModel methodsFor: 'all' stamp: 'sw 8/15/97 17:20'!fullScreenSize	"Answer the size to which a window displaying the receiver should be set"	^ (0@0 extent: DisplayScreen actualScreenSize) copy! !!CautiousModel methodsFor: 'all' stamp: 'sw 10/2/97 23:16'!initialExtent	initialExtent ifNotNil: [^ initialExtent].	^ super initialExtent! !!CautiousModel methodsFor: 'all' stamp: 'sw 10/2/97 23:16'!initialExtent: anExtent	initialExtent _ anExtent! !!CautiousModel methodsFor: 'all' stamp: 'sw 10/2/97 16:19'!okToChange	| parms |	(parms _ Smalltalk at: #EToyParameters ifAbsent: [nil]) ifNotNil:		[parms cautionBeforeClosing ifFalse: [^ true]].	Sensor leftShiftDown ifTrue: [^ true].	self beep.	^ self confirm: 'Warning!!If you answer "yes" here, thiswindow will disappear andits contents will be lost!!Do you really want to do that?'"CautiousModel new okToChange"! !CCodeGenerator comment:'This class oversees the translation of a subset of Smalltalk to C, allowing the comforts of Smalltalk during development and the efficiency and portability of C for the resulting interpreter.  Executing	Interpreter translate: ''InterpTest.c'' doInlining: true.(with single quotes) will cause all the methods of Interpreter, ObjectMemory and BitBltSimulation to be translated to C, and stored in the named file.  This file together with the files emitted by InterpreterSupportCode (qv) should be adequate to produce a complete interpreter for the Macintosh environment.'!!CCodeGenerator methodsFor: 'public' stamp: 'ikp 12/4/97 23:01'!addClass: aClass	"Add the variables and methods of the given class to the code base."	| source |	self checkClassForNameConflicts: aClass.	aClass classPool associationsDo: [ :assoc |		constants at: assoc key put: (TConstantNode new setValue: assoc value).	].	"ikp..."	aClass sharedPools do: [:pool |		pool associationsDo: [ :assoc |			constants at: assoc key put: (TConstantNode new setValue: assoc value).		].	].	variables addAll: aClass instVarNames.'Adding Class ' , aClass name , '...'displayProgressAt: Sensor cursorPointfrom: 0 to: aClass selectors sizeduring: [:bar |	aClass selectors doWithIndex: [ :sel :i | bar value: i.		source _ aClass sourceCodeAt: sel.		self addMethod: ((Compiler new parse: source in: aClass notifying: nil) asTMethodFromClass: aClass).	]].! !!CCodeGenerator methodsFor: 'public' stamp: 'jm 1/5/98 16:36'!addClassVarsFor: aClass	"Add the class variables for the given class (and its superclasses) to the code base as constants."	| allClasses |	allClasses _ aClass allSuperclasses asOrderedCollection.	allClasses add: aClass.	allClasses do: [:c |		c classPool associationsDo:			[:assoc | constants at: assoc key put: (TConstantNode new setValue: assoc value)]].! !!CCodeGenerator methodsFor: 'public' stamp: 'ikp 9/26/97 14:48'!codeString	"Return a string containing all the C code for the code base. Used for testing."	| stream |	stream _ ReadWriteStream on: (String new: 1000).	self emitCCodeOn: stream doInlining: true doAssertions: true.	^stream contents! !!CCodeGenerator methodsFor: 'public' stamp: 'jm 1/5/98 16:37'!codeStringForPrimitives: classAndSelectorList	| sel aClass source s verbose meth |	self initialize.	classAndSelectorList do: [ :classAndSelector |		aClass _ Smalltalk at: (classAndSelector at: 1).		self addClassVarsFor: aClass.		sel _ classAndSelector at: 2.		source _ aClass sourceCodeAt: sel.		meth _ ((Compiler new parse: source in: aClass notifying: nil)				asTMethodFromClass: aClass).		meth preparePrimitiveInClass: aClass.		self addMethod: meth.	].	s _ ReadWriteStream on: (String new: 1000).	"method preparation"	verbose _ false.	self prepareMethods.	verbose ifTrue: [		self printUnboundCallWarnings.		self printUnboundVariableReferenceWarnings.		Transcript cr.	].	"code generation"	methods _ methods asSortedCollection: [ :m1 :m2 | m1 selector < m2 selector ].	self emitCHeaderForPrimitivesOn: s.	self emitCVariablesOn: s.	self emitCFunctionPrototypesOn: s.	methods do: [ :m | m emitCCodeOn: s generator: self ].	^ s contents! !!CCodeGenerator methodsFor: 'public'!globalsAsSet	"Used by the inliner to avoid name clashes with global variables."	((variablesSetCache == nil) or:	 [variablesSetCache size ~= variables size]) ifTrue: [		variablesSetCache _ variables asSet.	].	^ variablesSetCache! !!CCodeGenerator methodsFor: 'public'!initialize	translationDict _ Dictionary new.	inlineList _ Array new.	constants _ Dictionary new.	variables _ OrderedCollection new.	variableDeclarations _ Dictionary new.	methods _ Dictionary new.	self initializeCTranslationDictionary.! !!CCodeGenerator methodsFor: 'public' stamp: 'ikp 9/26/97 14:50'!storeCodeOnFile: fileName doInlining: inlineFlag	"Store C code for this code base on the given file."	self storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: true! !!CCodeGenerator methodsFor: 'public' stamp: 'ikp 9/26/97 14:50'!storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: assertionFlag	"Store C code for this code base on the given file."	| stream |	stream _ FileStream newFileNamed: fileName.	self emitCCodeOn: stream doInlining: inlineFlag doAssertions: assertionFlag.	stream close.! !!CCodeGenerator methodsFor: 'public'!var: varName declareC: declarationString	"Record the given C declaration for a global variable."	variableDeclarations at: varName put: declarationString.! !!CCodeGenerator methodsFor: 'error notification' stamp: 'ikp 12/4/97 22:56'!checkClassForNameConflicts: aClass	"Verify that the given class does not have constant, variable, or method names that conflict with those of previously added classes. Raise an error if a conflict is found, otherwise just return."	"check for constant name collisions"	aClass classPool associationsDo: [ :assoc |		(constants includesKey: assoc key) ifTrue: [			self error: 'Constant was defined in a previously added class: ', assoc key.		].	].	"ikp..."	aClass sharedPools do: [:pool |		pool associationsDo: [ :assoc |			(constants includesKey: assoc key) ifTrue: [				self error: 'Constant was defined in a previously added class: ', assoc key.			].		].	].	"check for instance variable name collisions"	aClass instVarNames do: [ :varName |		(variables includes: varName) ifTrue: [			self error: 'Instance variable was defined in a previously added class: ', varName.		].	].	"check for method name collisions"	aClass selectors do: [ :sel |		(methods includesKey: sel) ifTrue: [			self error: 'Method was defined in a previously added class: ', sel.		].	].! !!CCodeGenerator methodsFor: 'error notification'!printUnboundCallWarnings	"Print a warning message for every unbound method call in the code base."	| knownSelectors undefinedCalls |	undefinedCalls _ Dictionary new.	knownSelectors _ translationDict keys asSet.	knownSelectors add: #error:.	methods do: [ :m | knownSelectors add: m selector ].	methods do: [ :m |		m allCalls do: [ :sel |			(knownSelectors includes: sel) ifFalse: [				(undefinedCalls includesKey: sel)					ifTrue: [ (undefinedCalls at: sel) add: m selector ]					ifFalse: [ undefinedCalls at: sel put: (OrderedCollection with: m selector) ].			].		].	].	Transcript cr.	undefinedCalls keys asSortedCollection do: [ :undefined |		Transcript show: undefined, ' -- undefined method sent by:'; cr.		(undefinedCalls at: undefined) do: [ :caller |			Transcript tab; show: caller; cr.		].	].! !!CCodeGenerator methodsFor: 'error notification'!printUnboundVariableReferenceWarnings	"Print a warning message for every unbound variable reference in the code base."	| undefinedRefs globalVars knownVars |	undefinedRefs _ Dictionary new.	globalVars _ Set new: 100.	globalVars addAll: variables.	methods do: [ :m |		knownVars _ globalVars copy.		m args do: [ :var | knownVars add: var ].		m locals do: [ :var | knownVars add: var ].		m freeVariableReferences do: [ :varName |			(knownVars includes: varName) ifFalse: [				(undefinedRefs includesKey: varName)					ifTrue: [ (undefinedRefs at: varName) add: m selector ]					ifFalse: [ undefinedRefs at: varName put: (OrderedCollection with: m selector) ].			].		].	].	Transcript cr.	undefinedRefs keys asSortedCollection do: [ :var |		Transcript show: var, ' -- undefined variable used in:'; cr.		(undefinedRefs at: var) do: [ :sel |			Transcript tab; show: sel; cr.		].	].! !!CCodeGenerator methodsFor: 'inlining'!collectInlineList	"Make a list of methods that should be inlined."	"Details: The method must not include any inline C, since the translator cannot currently map variable names in inlined C code. Methods to be inlined must be small or called from only one place."	| methodsNotToInline callsOf inlineIt hasCCode nodeCount senderCount |	methodsNotToInline _ Set new: methods size.	"build dictionary to record the number of calls to each method"	callsOf _ Dictionary new: methods size * 2.	methods keys do: [ :sel | callsOf at: sel put: 0 ].	"For each method, scan its parse tree once to:		1. determine if the method contains C code or declarations		2. determine how many nodes it has		3. increment the sender counts of the methods it calls		4. determine if it includes any C declarations or code"	inlineList _ Set new: methods size * 2.	methods do: [ :m |		inlineIt _ #dontCare.		(translationDict includesKey: m selector) ifTrue: [			hasCCode _ true.		] ifFalse: [			hasCCode _ m declarations size > 0.			nodeCount _ 0.			m parseTree nodesDo: [ :node |				node isSend ifTrue: [					sel _ node selector.					sel = #cCode: ifTrue: [ hasCCode _ true ].					senderCount _ callsOf at: sel ifAbsent: [ nil ].					nil = senderCount ifFalse: [						callsOf at: sel put: senderCount + 1.					].				].				nodeCount _ nodeCount + 1.			].			inlineIt _ m extractInlineDirective.  "may be true, false, or #dontCare"		].		(hasCCode or: [inlineIt = false]) ifTrue: [			"don't inline if method has C code and is contains negative inline directive"			methodsNotToInline add: m selector.		] ifFalse: [			((nodeCount < 40) or: [inlineIt = true]) ifTrue: [				"inline if method has no C code and is either small or contains inline directive"				inlineList add: m selector.			].		].	].	callsOf associationsDo: [ :assoc |		((assoc value = 1) and: [(methodsNotToInline includes: assoc key) not]) ifTrue: [			inlineList add: assoc key.		].	].! !!CCodeGenerator methodsFor: 'inlining'!doInlining	"Inline the bodies of all methods that are suitable for inlining."	"Interpreter translate: 'InterpTest.c' doInlining: true"	| pass progress |	self collectInlineList.	"xxx do we need the following?"	Interpreter primitiveTable do: [ :sel |		inlineList remove: sel ifAbsent: [].	].	pass _ 0.	progress _ true.	[progress] whileTrue: [		"repeatedly attempt to inline methods until no further progress is made"		progress _ false.		('Inlining pass ', (pass _ pass + 1) printString, '...')			displayProgressAt: Sensor cursorPoint			from: 0 to: methods size			during: [ :bar |				methods doWithIndex: [ :m :i |					bar value: i.					(m tryToInlineMethodsIn: self)						ifTrue: [progress _ true]]].	].	'Inlining bytecodes'		displayProgressAt: Sensor cursorPoint		from: 1 to: 2		during: [ :bar |			self inlineDispatchesInMethodNamed: #interpret				localizingVars: #(currentBytecode localIP localSP).			bar value: 1.			self removeMethodsReferingToGlobals: #(currentBytecode localIP localSP)				except: #interpret.			bar value: 2.	].! !!CCodeGenerator methodsFor: 'inlining' stamp: 'ikp 1/3/98 23:13'!doInlining: inlineFlag	"Inline the bodies of all methods that are suitable for inlining."	"Modified slightly for the translator, since the first level of inlining for the interpret	loop must be performed in order that the instruction implementations can easily	discover their addresses."	"Interpreter translate: 'InterpTest.c' doInlining: true"	| pass progress |	inlineFlag ifFalse: [		^self inlineDispatchesInMethodNamed: #interpret localizingVars: #().	].	self collectInlineList.	"xxx do we need the following?"	Interpreter primitiveTable do: [ :sel |		inlineList remove: sel ifAbsent: [].	].	pass _ 0.	progress _ true.	[progress] whileTrue: [		"repeatedly attempt to inline methods until no further progress is made"		progress _ false.		('Inlining pass ', (pass _ pass + 1) printString, '...')			displayProgressAt: Sensor cursorPoint			from: 0 to: methods size			during: [ :bar |				methods doWithIndex: [ :m :i |					bar value: i.					(m tryToInlineMethodsIn: self)						ifTrue: [progress _ true]]].	].	'Inlining bytecodes'		displayProgressAt: Sensor cursorPoint		from: 1 to: 3		during: [ :bar |			self inlineDispatchesInMethodNamed: #interpret				localizingVars: #(currentBytecode localIP localSP localCP localTP).			bar value: 1."xxx			(methods includesKey: #translateNewMethod) ifTrue:				[self inlineDispatchesInMethodNamed: #translateNewMethod					localizingVars: #(currentByte bytePointer opPointer).				self removeMethodsReferingToGlobals: #(currentByte bytePointer opPointer)					except: #translateNewMethod.				].xxx"			bar value: 2.			self removeMethodsReferingToGlobals: #(currentBytecode localIP localSP localCP localTP)				except: #interpret.			bar value: 3.	].! !!CCodeGenerator methodsFor: 'inlining'!inlineDispatchesInMethodNamed: selector localizingVars: varsList	"Inline dispatches (case statements) in the method with the given name."	| m |	m _ self methodNamed: selector.	m = nil ifFalse: [		m inlineCaseStatementBranchesIn: self localizingVars: varsList.		m parseTree nodesDo: [ :n |			n isCaseStmt ifTrue: [				n customizeShortCasesForDispatchVar: #currentBytecode.			].		].	].	variables _ variables asOrderedCollection.	varsList do: [ :v |		variables remove: v asString ifAbsent: [].		(variableDeclarations includesKey: v asString) ifTrue: [			m declarations at: v asString put: (variableDeclarations at: v asString).			variableDeclarations removeKey: v asString.		].	].! !!CCodeGenerator methodsFor: 'inlining'!mayInline: sel	"Answer true if the method with the given selector may be inlined."	^ inlineList includes: sel! !!CCodeGenerator methodsFor: 'inlining'!methodStatsString	"Return a string describing the size, # of locals, and # of senders of each method. Note methods that have inline C code or C declarations."	| methodsWithCCode sizesOf callsOf hasCCode nodeCount senderCount s calls registers selr |	methodsWithCCode _ Set new: methods size.	sizesOf _ Dictionary new: methods size * 2.  "selector -> nodeCount"	callsOf _ Dictionary new: methods size * 2.  "selector -> senderCount"	"For each method, scan its parse tree once to:		1. determine if the method contains C code or declarations		2. determine how many nodes it has		3. increment the sender counts of the methods it calls		4. determine if it includes any C declarations or code"	methods do: [ :m |		(translationDict includesKey: m selector) ifTrue: [			hasCCode _ true.		] ifFalse: [			hasCCode _ m declarations size > 0.			nodeCount _ 0.			m parseTree nodesDo: [ :node |				node isSend ifTrue: [					selr _ node selector.					selr = #cCode: ifTrue: [ hasCCode _ true ].					senderCount _ callsOf at: selr ifAbsent: [ 0 ].					callsOf at: selr put: senderCount + 1.				].				nodeCount _ nodeCount + 1.			].		].		hasCCode ifTrue: [ methodsWithCCode add: m selector ].		sizesOf at: m selector put: nodeCount.	].	s _ WriteStream on: (String new: 5000).	methods keys asSortedCollection do: [ :sel |		m _ methods at: sel.		registers _ m locals size + m args size.		calls _ callsOf at: sel ifAbsent: [0].		registers > 11 ifTrue: [			s nextPutAll: sel; tab.			s nextPutAll: (sizesOf at: sel) printString; tab.			s nextPutAll: calls printString; tab.			s nextPutAll: registers printString; tab.			(methodsWithCCode includes: sel) ifTrue: [ s nextPutAll: 'CCode' ].		s cr.		].	].	^ s contents! !!CCodeGenerator methodsFor: 'inlining' stamp: 'ikp 9/26/97 14:50'!removeAssertions	"Remove all assertions in method bodies.  This is for the benefit of inlining, which	fails to recognise and disregard empty method bodies when checking the inlinability	of sends."	| newMethods |	newMethods _ Dictionary new.	'Removing assertions...'		displayProgressAt: Sensor cursorPoint		from: 0 to: methods size		during: [ :bar |			methods doWithIndex: [ :m :i |				bar value: i.				m isAssertion ifFalse: [					newMethods at: m selector put: m.					m removeAssertions]]].	methods _ newMethods.! !!CCodeGenerator methodsFor: 'inlining'!removeMethodsReferingToGlobals: varList except: methodName	"Remove any methods (presumably inlined) that still contain references to the given obsolete global variables."	| varListAsStrings removeIt mVars |	varListAsStrings _ varList collect: [ :sym | sym asString ].	methods keys copy do: [ :sel |		removeIt _ false.		mVars _ (self methodNamed: sel) freeVariableReferences asSet.		varListAsStrings do: [ :v |			(mVars includes: v) ifTrue: [ removeIt _ true ].		].		(removeIt and: [sel ~= methodName]) ifTrue: [			methods removeKey: sel ifAbsent: [].		].	].! !!CCodeGenerator methodsFor: 'utilities'!addMethod: aTMethod	"Add the given method to the code base."	(methods includesKey:  aTMethod selector) ifTrue: [		self error: 'Method name conflict: ', aTMethod selector.	].	methods at: aTMethod selector put: aTMethod.! !!CCodeGenerator methodsFor: 'utilities'!builtin: sel	"Answer true if the given selector is one of the builtin selectors."	((sel = #longAt:) or: [(sel = #longAt:put:) or: [sel = #error:]]) ifTrue: [ ^true ].	((sel = #byteAt:) or: [sel = #byteAt:put:]) ifTrue: [ ^true ].	^translationDict includesKey: sel! !!CCodeGenerator methodsFor: 'utilities'!cCodeForMethod: selector	"Answer a string containing the C code for the given method."	"Example:		((CCodeGenerator new initialize addClass: TestCClass1; prepareMethods)			cCodeForMethod: #ifTests)"	| m s |	m _ self methodNamed: selector.	m = nil ifTrue: [ self error: 'method not found in code base: ', selector ].	s _ (ReadWriteStream on: '').	m emitCCodeOn: s generator: self.	^ s contents! !!CCodeGenerator methodsFor: 'utilities'!emitBuiltinConstructFor: msgNode on: aStream level: level	"If the given selector is in the translation dictionary, translate it into a target code construct and return true. Otherwise, do nothing and return false."	| action |	action _ translationDict at: msgNode selector ifAbsent: [ ^false ].	self perform: action with: msgNode with: aStream with: level.	^true! !!CCodeGenerator methodsFor: 'utilities'!methodNamed: selector	"Answer the method in the code base with the given selector."	^ methods at: selector ifAbsent: [ nil ]! !!CCodeGenerator methodsFor: 'utilities'!methodsReferringToGlobal: v	"Return a collection of methods that refer to the given global variable."	| out |	out _ OrderedCollection new.	methods associationsDo: [ :assoc |		(assoc value freeVariableReferences includes: v) ifTrue: [			out add: assoc key.		].	].	^ out! !!CCodeGenerator methodsFor: 'utilities'!methodsThatCanInvoke: aSelectorList	"Return a set of methods that can invoke one of the given selectors, either directly or via a sequence of intermediate methods."	| out todo sel mSelector |	out _ Set new.	todo _ aSelectorList copy asOrderedCollection.	[todo isEmpty] whileFalse: [		sel _ todo removeFirst.		out add: sel.		methods do: [ :m |			(m allCalls includes: sel) ifTrue: [				mSelector _ m selector.				((out includes: mSelector) or:				 [todo includes: mSelector]) ifFalse: [					todo add: mSelector.				].			].		].	].	^ out	! !!CCodeGenerator methodsFor: 'utilities'!prepareMethods	"Prepare methods for browsing."	| globals |	globals _ Set new: 200.	globals addAll: variables.	methods do: [ :m |		(m locals, m args) do: [ :var |			(globals includes: var) ifTrue: [				self error: 'Local variable name may mask global when inlining: ', var.			].			(methods includesKey: var) ifTrue: [				self error: 'Local variable name may mask method when inlining: ', var.			].			].		m bindClassVariablesIn: constants.		m prepareMethodIn: self.	].! !!CCodeGenerator methodsFor: 'utilities'!reportRecursiveMethods	"Report in transcript all methods that can call themselves directly or indirectly or via a chain of N intermediate methods."	| visited calls newCalls sel called |	methods do: [: m |		visited _ translationDict keys asSet.		calls _ m allCalls asOrderedCollection.		5 timesRepeat: [			newCalls _ Set new: 50.			[calls isEmpty] whileFalse: [				sel _ calls removeFirst.				sel = m selector ifTrue: [					Transcript show: m selector, ' is recursive'; cr.				] ifFalse: [					(visited includes: sel) ifFalse: [						called _ self methodNamed: sel.						called = nil ifFalse: [ newCalls addAll: called allCalls ].					].					visited add: sel.				].			].			calls _ newCalls asOrderedCollection.		].	].! !!CCodeGenerator methodsFor: 'utilities'!unreachableMethods	"Return a collection of methods that are never invoked."	| sent out |	sent _ Set new.	methods do: [ :m |		sent addAll: m allCalls.	].	out _ OrderedCollection new.	methods keys do: [ :sel |		(sent includes: sel) ifFalse: [ out add: sel ].	].	^ out! !!CCodeGenerator methodsFor: 'C code generator'!cFunctionNameFor: aSelector	"Create a C function name from the given selector by omitting colons."	^aSelector copyWithout: $:! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'ikp 12/2/97 19:40'!cLiteralFor: anObject	"Return a string representing the C literal value for the given object."	| s |	(anObject isKindOf: Integer) ifTrue: [		(anObject < 16r7FFFFFFF)			ifTrue: [^ anObject printString]			ifFalse: [^ anObject printString , 'U']].	(anObject isKindOf: String) ifTrue: [^ '"', anObject, '"' ].	(anObject isKindOf: Float) ifTrue: [^ anObject printString ].	anObject == nil ifTrue: [^ 'null' ].	anObject == true ifTrue: [^ '1' ].			"ikp"	anObject == false ifTrue: [^ '0' ].			"ikp"	self error:								"ikp"		'Warning: A Smalltalk literal could not be translated into a C constant: ', anObject printString.	^'"XXX UNTRANSLATABLE CONSTANT XXX"'! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'ikp 12/7/97 20:54'!emitCCodeOn: aStream doInlining: inlineFlag	self emitCCodeOn: aStream doInlining: inlineFlag doAssertions: true! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'ikp 12/7/97 20:54'!emitCCodeOn: aStream doInlining: inlineFlag doAssertions: assertionFlag	"Emit C code for all methods in the code base onto the given stream. All inlined method calls should already have been expanded."	| verbose |	"method preparation"	verbose _ false.	self prepareMethods.	verbose ifTrue: [		self printUnboundCallWarnings.		self printUnboundVariableReferenceWarnings.		Transcript cr.	].	assertionFlag ifFalse: [ self removeAssertions ].	self doInlining: inlineFlag.	"code generation"	methods _ methods asSortedCollection: [ :m1 :m2 | m1 selector < m2 selector ].	self emitCHeaderOn: aStream.	self emitCVariablesOn: aStream.	self emitCFunctionPrototypesOn: aStream.'Writing Translated Code...'displayProgressAt: Sensor cursorPointfrom: 0 to: methods sizeduring: [:bar |	methods doWithIndex: [ :m :i | bar value: i.		m emitCCodeOn: aStream generator: self.]].! !!CCodeGenerator methodsFor: 'C code generator'!emitCExpression: aParseNode on: aStream	"Emit C code for the expression described by the given parse node."	aParseNode isLeaf ifTrue: [		"omit parens"		aParseNode emitCCodeOn: aStream level: 0 generator: self.	] ifFalse: [		aStream nextPut: $(.		aParseNode emitCCodeOn: aStream level: 0 generator: self.		aStream nextPut: $).	].! !!CCodeGenerator methodsFor: 'C code generator'!emitCFunctionPrototypesOn: aStream	"Store prototype declarations for all non-inlined methods on the given stream."	aStream nextPutAll: '/*** Function Prototypes ***/'; cr.	methods do: [ :m |		m emitCFunctionPrototype: aStream generator: self.		aStream nextPutAll: ';'; cr.	].! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'ikp 1/4/98 00:03'!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr; cr.	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Imported Functions/Variables ***/extern int stackValue(int);extern int successFlag;'.	aStream cr.! !!CCodeGenerator methodsFor: 'C code generator' stamp: 'ikp 1/3/98 16:08'!emitCHeaderOn: aStream	"Write a C file header onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr.	aStream nextPutAll: '/* memory access macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)int printCallStack(void);void error(char *s);void error(char *s) {	/* Print an error message and exit. */	static int printingStack = false;	printf("\n%s\n\n", s);	if (!!printingStack) {		/* flag prevents recursive error when trying to print a broken stack */		printingStack = true;		printCallStack();	}	exit(-1);}'.	aStream cr.! !!CCodeGenerator methodsFor: 'C code generator'!emitCTestBlock: aBlockNode on: aStream	"Emit C code for the given block node to be used as a loop test."	aBlockNode statements size > 1 ifTrue: [		aBlockNode emitCCodeOn: aStream level: 0 generator: self.	] ifFalse: [		aBlockNode statements first emitCCodeOn: aStream level: 0 generator: self.	].! !!CCodeGenerator methodsFor: 'C code generator'!emitCVariablesOn: aStream	"Store the global variable declarations on the given stream."	aStream nextPutAll: '/*** Variables ***/'; cr.	variables asSortedCollection do: [ :var |		(variableDeclarations includesKey: var) ifTrue: [			aStream nextPutAll: (variableDeclarations at: var), ';'; cr.		] ifFalse: [			"default variable declaration"			aStream nextPutAll: 'int ', var, ';'; cr.		].	].	aStream cr.! !!CCodeGenerator methodsFor: 'C translation'!generateAnd: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' && '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateAt: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '['.	msgNode args first emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ']'.! !!CCodeGenerator methodsFor: 'C translation'!generateAtPut: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '['.	msgNode args first emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: '] = '.	self emitCExpression: msgNode args last on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateBitAnd: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' & '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateBitInvert32: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '~'.	self emitCExpression: msgNode receiver on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateBitOr: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' | '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateBitShift: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| arg rcvr |	arg _ msgNode args first.	rcvr _ msgNode receiver.	arg isConstant ifTrue: [		"bit shift amount is a constant"		aStream nextPutAll: '((unsigned) '.		self emitCExpression: rcvr on: aStream.		arg value < 0 ifTrue: [			aStream nextPutAll: ' >> ', arg value negated printString.		] ifFalse: [			aStream nextPutAll: ' << ', arg value printString.		].		aStream nextPutAll: ')'.	] ifFalse: [		"bit shift amount is an expression"		aStream nextPutAll: '(('.		self emitCExpression: arg on: aStream.		aStream nextPutAll: ' < 0) ? ((unsigned) '.		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' >> -'.		self emitCExpression: arg on: aStream.		aStream nextPutAll: ') : ((unsigned) '.		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' << '.		self emitCExpression: arg on: aStream.		aStream nextPutAll: '))'.	].! !!CCodeGenerator methodsFor: 'C translation'!generateBitXor: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' ^ '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateCCoercion: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	aStream nextPutAll: msgNode args last value.	aStream nextPutAll: ') '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!CCodeGenerator methodsFor: 'C translation'!generateDivide: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' / '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' == '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateGreaterThan: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' > '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateGreaterThanOrEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' >= '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateIfFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler produces two arguments for ifFalse:, presumably	 to help with inlining later. Taking the last agument should do the correct	 thing even if your compiler is different."	aStream nextPutAll: 'if (!!('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ')) {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation'!generateIfFalseIfTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler reverses the argument blocks for ifFalse:ifTrue:,       presumably to help with inlining later. That is, the first argument       is the block to be evaluated if the condition is true."	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} else {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation'!generateIfTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation'!generateIfTrueIfFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} else {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation'!generateInlineCCode: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: msgNode args first value.! !!CCodeGenerator methodsFor: 'C translation'!generateInlineDirective: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '/* inline: '.	aStream nextPutAll: msgNode args first name.	aStream nextPutAll: ' */'.! !!CCodeGenerator methodsFor: 'C translation'!generateIntegerObjectOf: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ' << 1) | 1)'.! !!CCodeGenerator methodsFor: 'C translation'!generateIntegerValueOf: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '('.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ' >> 1)'.! !!CCodeGenerator methodsFor: 'C translation'!generateIsIntegerObject: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '('.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ' & 1)'.! !!CCodeGenerator methodsFor: 'C translation'!generateIsNil: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' == '.	aStream nextPutAll: (self cLiteralFor: nil).! !!CCodeGenerator methodsFor: 'C translation'!generateLessThan: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' < '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateLessThanOrEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' <= '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateMax: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' < '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ') ? '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ' : '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ')'.! !!CCodeGenerator methodsFor: 'C translation'!generateMin: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' < '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ') ? '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' : '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!CCodeGenerator methodsFor: 'C translation'!generateMinus: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' - '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateModulo: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' % '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateNot: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '!!'.	self emitCExpression: msgNode receiver on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateNotEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' !!= '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateNotNil: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' !!= '.	aStream nextPutAll: (self cLiteralFor: nil).! !!CCodeGenerator methodsFor: 'C translation'!generateOr: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' || '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generatePlus: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' + '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generatePreDecrement: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| varNode |	varNode _ msgNode receiver.	varNode isVariable		ifFalse: [ self error: 'preDecrement can only be applied to variables' ].	aStream nextPutAll: '--'.	aStream nextPutAll: varNode name.! !!CCodeGenerator methodsFor: 'C translation'!generatePreIncrement: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| varNode |	varNode _ msgNode receiver.	varNode isVariable		ifFalse: [ self error: 'preIncrement can only be applied to variables' ].	aStream nextPutAll: '++'.	aStream nextPutAll: varNode name.! !!CCodeGenerator methodsFor: 'C translation'!generateSequentialAnd: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' && ('.	self emitCTestBlock: msgNode args first on: aStream.	aStream nextPutAll: ')'.! !!CCodeGenerator methodsFor: 'C translation'!generateSequentialOr: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler produces two arguments for or:, presumably	 to help with inlining later. Taking the last agument should do the correct	 thing even if your compiler is different."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' || ('.	self emitCTestBlock: msgNode args last on: aStream.	aStream nextPutAll: ')'.! !!CCodeGenerator methodsFor: 'C translation'!generateSharedCodeDirective: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '/* common code: '.	aStream nextPutAll: msgNode args first value.	aStream nextPutAll: ' */'.! !!CCodeGenerator methodsFor: 'C translation'!generateShiftLeft: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' << '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateShiftRight: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '((unsigned) '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ')'.	aStream nextPutAll: ' >> '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateTimes: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' * '.	self emitCExpression: msgNode args first on: aStream.! !!CCodeGenerator methodsFor: 'C translation'!generateToByDo: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| iterationVar |	(msgNode args last args size = 1) ifFalse: [		self error: 'wrong number of block arguments'.	].	iterationVar _ msgNode args last args first.	aStream nextPutAll: 'for (', iterationVar, ' = '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '; ', iterationVar, ' <= '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: '; ', iterationVar, ' += '.	self emitCExpression: (msgNode args at: 2) on: aStream.	aStream nextPutAll: ') {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation'!generateToDo: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| iterationVar |	(msgNode args last args size = 1) ifFalse: [		self error: 'wrong number of block arguments'.	].	iterationVar _ msgNode args last args first.	aStream nextPutAll: 'for (', iterationVar, ' = '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '; ', iterationVar, ' <= '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: '; ', iterationVar, '++) {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation'!generateWhileFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'while (!!('.	self emitCTestBlock: msgNode receiver on: aStream.	aStream nextPutAll: ')) {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation'!generateWhileTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'while ('.	self emitCTestBlock: msgNode receiver on: aStream.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!CCodeGenerator methodsFor: 'C translation'!initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	translationDict _ Dictionary new: 200.	pairs _ #(	#&				#generateAnd:on:indent:	#|				#generateOr:on:indent:	#and:			#generateSequentialAnd:on:indent:	#or:			#generateSequentialOr:on:indent:	#not			#generateNot:on:indent:	#+				#generatePlus:on:indent:	#-				#generateMinus:on:indent:	#*				#generateTimes:on:indent:	#//				#generateDivide:on:indent:	#\\				#generateModulo:on:indent:	#<<				#generateShiftLeft:on:indent:	#>>				#generateShiftRight:on:indent:	#min:			#generateMin:on:indent:	#max:			#generateMax:on:indent:	#bitAnd:		#generateBitAnd:on:indent:	#bitOr:			#generateBitOr:on:indent:	#bitXor:			#generateBitXor:on:indent:	#bitShift:		#generateBitShift:on:indent:	#bitInvert32	#generateBitInvert32:on:indent:	#<				#generateLessThan:on:indent:	#<=				#generateLessThanOrEqual:on:indent:	#=				#generateEqual:on:indent:	#>				#generateGreaterThan:on:indent:	#>=				#generateGreaterThanOrEqual:on:indent:	#~=				#generateNotEqual:on:indent:	#==				#generateEqual:on:indent:	#isNil			#generateIsNil:on:indent:	#notNil			#generateNotNil:on:indent:	#whileTrue: 	#generateWhileTrue:on:indent:	#whileFalse:	#generateWhileFalse:on:indent:	#to:do:			#generateToDo:on:indent:	#to:by:do:		#generateToByDo:on:indent:	#ifTrue:		#generateIfTrue:on:indent:	#ifFalse:		#generateIfFalse:on:indent:	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:	#at:				#generateAt:on:indent:	#at:put:			#generateAtPut:on:indent:	#integerValueOf:	#generateIntegerValueOf:on:indent:	#integerObjectOf:	#generateIntegerObjectOf:on:indent:	#isIntegerObject: 	#generateIsIntegerObject:on:indent:	#cCode:				#generateInlineCCode:on:indent:	#cCoerce:to:			#generateCCoercion:on:indent:	#preIncrement		#generatePreIncrement:on:indent:	#preDecrement		#generatePreDecrement:on:indent:	#inline:				#generateInlineDirective:on:indent:	#sharedCodeNamed:inCase:	#generateSharedCodeDirective:on:indent:	).	1 to: pairs size by: 2 do: [ :i |		translationDict at: (pairs at: i) put: (pairs at: i + 1).	].! !!CCodeGenerator class methodsFor: 'removing from system'!removeCompilerMethods	"Before removing the C code generator classes from the system, use this method to remove the compiler node methods that support it. This avoids leaving dangling references to C code generator classes in the compiler node classes."	ParseNode withAllSubclasses do: [ :nodeClass |		nodeClass removeCategory: 'C translation'.	].	AbstractSound class removeCategory: 'primitive generation'.! !!ChangedMessageSet methodsFor: 'everything'!changeSet: aChangeSet	changeSet _ aChangeSet! !!ChangedMessageSet methodsFor: 'everything'!contents: aString notifying: aController	| selectedMessageName selector oldMessageList |	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	contents _ nil.	selector _ 		self selectedClassOrMetaClass				compile: aString				classified:  self selectedMessageCategoryName				notifying: aController.	selector == nil ifTrue: [^ false].	contents _ aString copy.	selector ~~ selectedMessageName		ifTrue: 			[(oldMessageList includes: selector)				ifFalse: [self initializeMessageList: changeSet changedMessageListAugmented.						self changed: #messageListChanged].			self messageListIndex: (self messageList indexOf: selector)].	^ true! !!ChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'sw 3/9/97'!openFor: aChangeSet	"Open up a ChangedMessageSet browser on the given change set; this is a conventional message-list browser whose message list is the list of methods in aChangeSet.  After any method submission, the message list is refigured, making it plausibly dynamic.  "	| messageSet |	messageSet _ self messageList: aChangeSet changedMessageListAugmented.	messageSet changeSet: aChangeSet.	messageSet autoSelectString: nil.	ScheduledControllers scheduleActive: 					(self open: messageSet name:  'Methods in Change Set ', aChangeSet name)! !!ChangeList methodsFor: 'scanning' stamp: 'sw 1/15/98 21:56'!scanCategory  	"Scan anything that involves more than one chunk; method name is historical only"	| itemPosition item tokens stamp isComment anIndex |	itemPosition _ file position.	item _ file nextChunk.	isComment _ (item includesSubString: 'commentStamp:').	(isComment or: [item includesSubString: 'methodsFor:']) ifFalse:		["Maybe a preamble, but not one we recognize; bail out with the preamble trick"		^ self addItem: (ChangeRecord new file: file position: itemPosition type: #preamble)				 text: ('preamble: ' , item contractTo: 50)].	tokens _ Scanner new scanTokens: item.	tokens size >= 3 ifTrue:		[stamp _ ''.		anIndex _ tokens indexOf: #stamp: ifAbsent: [nil].		anIndex ifNotNil: [stamp _ tokens at: (anIndex + 1)].		tokens second == #methodsFor:			ifTrue: [^ self scanCategory: tokens third class: tokens first							meta: false stamp: stamp].		tokens third == #methodsFor:			ifTrue: [^ self scanCategory: tokens fourth class: tokens first							meta: true stamp: stamp]].		tokens second == #commentStamp:			ifTrue:				[stamp _ tokens third.				self addItem:						(ChangeRecord new file: file position: file position type: #classComment										class: tokens first category: nil meta: false stamp: stamp)						text: 'class comment for ' , tokens first, 							  (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp]).				file nextChunk.				^ file skipStyleChunk]! !!ChangeList methodsFor: 'scanning' stamp: 'di 1/13/98 16:56'!scanCategory: category class: class meta: meta stamp: stamp	| itemPosition method |	[itemPosition _ file position.	method _ file nextChunk.	file skipStyleChunk.	method size > 0]						"done when double terminators"		whileTrue:		[self addItem: (ChangeRecord new file: file position: itemPosition type: #method							class: class category: category meta: meta stamp: stamp)			text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])				, (Parser new parseSelector: method)				, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])]! !!ChangeList methodsFor: 'scanning' stamp: 'di 1/13/98 16:57'!scanFile: aFile from: startPosition to: stopPosition	| itemPosition item prevChar |	file _ aFile.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	file position: startPosition.'Scanning changes...'	displayProgressAt: Sensor cursorPoint	from: startPosition to: stopPosition	during: [:bar |	[file position < stopPosition]		whileTrue:		[bar value: file position.		[file atEnd not and: [file peek isSeparator]]				whileTrue: [prevChar _ file next].		(file peekFor: $!!)		ifTrue:			[prevChar = Character cr ifTrue: [self scanCategory]]		ifFalse:			[itemPosition _ file position.			item _ file nextChunk.			file skipStyleChunk.			item size > 0 ifTrue:				[self addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)					text: 'do it: ' , (item contractTo: 50)]]]].	listSelections _ Array new: list size withAll: false! !!ChangeList methodsFor: 'scanning' stamp: 'di 6/28/97 09:24'!scanVersionsOf: method class: class meta: meta category: category selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp |	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	position _ method filePosition.	sourceFilesCopy _ SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	file _ sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble _ file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos _ nil.		stamp _ ''.		((file == sourceFilesCopy first) not and:			[(preamble findString: 'methodsFor:' startingAt: 1) > 0])			ifTrue: [tokens _ Scanner new scanTokens: preamble]			ifFalse: [tokens _ Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size-2.						prevPos _ tokens last.						prevFileIndex _ prevPos // 16r1000000.						prevPos _ prevPos \\ 16r1000000]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos _ tokens at: tokens size-2.						prevFileIndex _ tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos _ nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size]]. 		self addItem:				(ChangeRecord new file: file position: position type: #method						class: class name category: category meta: meta stamp: stamp)			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.		position _ prevPos.		prevPos notNil ifTrue:			[file _ sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections _ Array new: list size withAll: false! !!ChangeList methodsFor: 'menu actions' stamp: 'jm 6/12/97 10:54'!fileOutSelections 	| f |	f _ FileStream newFileNamed: (FillInTheBlank request: 'Enter file name' initialAnswer: 'Filename.st').	f header; timeStamp.	listSelections with: changeList do: 		[:selected :item | selected ifTrue: [item fileOutOn: f]].	f close.! !!ChangeList methodsFor: 'menu actions' stamp: 'di 6/13/97 23:10'!removeOlderMethodVersions	"Remove older versions of entries from the receiver."	| newChangeList newList found str |	newChangeList _ OrderedCollection new.	newList _ OrderedCollection new.	found _ OrderedCollection new.	changeList reverseWith: list do:		[:chRec :strNstamp | str _ strNstamp copyUpTo: $;.			(found includes: str)				ifFalse:					[found add: str.					newChangeList add: chRec.					newList add: strNstamp]].	newChangeList size < changeList size		ifTrue:			[changeList _ newChangeList reversed.			list _ newList reversed.			listIndex _ 0.			listSelections _ Array new: list size withAll: false].	self changed: #list! !!ChangeList methodsFor: 'menu actions' stamp: 'tk 1/7/98 10:12'!selectUnchangedMethods	"Selects all method definitions for which there is already a method in the current image, whose source is exactly the same.  9/18/96 sw"	| change class |	Cursor read showWhile: 	[1 to: changeList size do:		[:i | change _ changeList at: i.		listSelections at: i put:			((change type = #method and:				[(class _ change methodClass) notNil]) and:					[(class includesSelector: change methodSelector) and:						[change string = (class sourceCodeAt: change methodSelector) asString]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 1/15/98 22:45'!contents	^ listIndex = 0		ifTrue: ['']		ifFalse: [(changeList at: listIndex) text]! !!ChangeList methodsFor: 'viewing access' stamp: 'di 6/15/97 16:47'!contents: aString	listIndex = 0 ifTrue: [self changed: #flash. ^ false].	lostMethodPointer ifNotNil: [^ self restoreDeletedMethod].	(changeList at: listIndex) fileIn.	^ true! !!ChangeList methodsFor: 'viewing access' stamp: 'di 6/15/97 16:46'!restoreDeletedMethod	"If lostMethodPointer is not nil, then this is a version browser for a method that has been removed.  In this case we want to establish a sourceCode link to prior versions.  We do this by installing a dummy method with the correct source code pointer prior to installing this version."	| dummyMethod class selector |	dummyMethod _ CompiledMethod toReturnSelf setSourcePointer: lostMethodPointer.	class _ (changeList at: listIndex) methodClass.	selector _ (changeList at: listIndex) methodSelector.	class addSelector: selector withMethod: dummyMethod.	(changeList at: listIndex) fileIn.	"IF for some reason, the dummy remains, remove it, but (N.B.!!) we might not get control back if the compile (fileIn above) fails."	(class compiledMethodAt: selector) == dummyMethod		ifTrue: [class removeSelectorSimply: selector].	^ true! !!ChangeList methodsFor: 'accessing' stamp: 'di 6/15/97 15:13'!setLostMethodPointer: sourcePointer	lostMethodPointer _ sourcePointer! !!ChangeList class methodsFor: 'public access'!browseRecentLog    "ChangeList browseRecentLog"	"Prompt with a menu of how far back to go"	| end changesFile banners positions pos chunk i |	changesFile _ (SourceFiles at: 2) readOnlyCopy.	banners _ OrderedCollection new.	positions _ OrderedCollection new.	end _ changesFile size.	pos _ Smalltalk lastQuitLogPosition.	[pos = 0 or: [banners size > 20]] whileFalse:		[changesFile position: pos.		chunk _ changesFile nextChunk.		i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos _ Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos _ 0]].	changesFile close.	pos _ (SelectionMenu labelList: banners reversed selections: positions reversed)				startUpWithCaption: 'Browse as far back as...'.	pos == nil ifTrue: [^ self].	self browseRecent: end-pos! !!ChangeList class methodsFor: 'public access' stamp: 'di 6/15/97 15:12'!browseVersionsOf: method class: class meta: meta		category: category selector: selector lostMethodPointer: sourcePointer	| changeList |	Cursor read showWhile:		[changeList _ self new			scanVersionsOf: method class: class meta: meta			category: category selector: selector].	changeList setLostMethodPointer: sourcePointer.	self openVersions: changeList name: 'Recent versions of ' , selector! !!ChangeRecord methodsFor: 'access' stamp: 'sw 1/15/98 22:46'!fileIn	| methodClass |	Cursor read showWhile:		[(methodClass _ self methodClass) notNil ifTrue:			[methodClass compile: self text classified: category withStamp: stamp notifying: nil].		(type == #doIt) ifTrue:			[Compiler evaluate: self string].		(type == #classComment) ifTrue:			[(Smalltalk at: class asSymbol) comment: self text]]! !!ChangeRecord methodsFor: 'access' stamp: 'sw 1/15/98 22:09'!fileOutOn: f	type == #method		ifTrue:			[f nextPut: $!!.			f nextChunkPut: class asString					, (meta ifTrue: [' class methodsFor: ']							ifFalse: [' methodsFor: '])					, category asString printString.			f cr].	type == #preamble ifTrue: [f nextPut: $!!].	type == #classComment		ifTrue:			[f nextPut: $!!.			f nextChunkPut: class asString, ' commentStamp: ', stamp storeString.			f cr].	f nextChunkPut: self string.	type == #method ifTrue: [f nextChunkPut: ' '].	f cr! !!ChangeRecord methodsFor: 'access' stamp: '6/6/97 08:56 dhhi'!stamp	^ stamp! !!ChangeRecord methodsFor: 'access' stamp: 'di 1/13/98 16:57'!string 	| string |	file openReadOnly.	file position: position.	string _ file nextChunk.	file close.	^ string! !!ChangeRecord methodsFor: 'access' stamp: 'sw 1/15/98 22:35'!text	| text |	file openReadOnly.	file position: position.	text _ file nextChunkText.	file close.	^ text! !!ChangeRecord methodsFor: 'initialization' stamp: '6/6/97 08:48 dhhi'!file: f position: p type: t class: c category: cat meta: m stamp: s	self file: f position: p type: t.	class _ c.	category _ cat.	meta _ m.	stamp _ s! !ChangeSet comment:'My instances keep track of the changes made to a system, so the user can make an incremental fileOut. The order in which changes are made is not remembered.classChanges:  Dictionary {class name -> Set {eg, #change, #rename, etc}}.methodChanges:  Dictionary {class name -> IdentityDictionary {selector -> {eg, #change, #remove, etc}}.classRemoves:  Set {class name (original)}.methodRemoves:  Dictionary {(Array with: class name with: selector) -> (Array with: source pointer with: category)}.name: a String used to name the changeSet, and thus any associated project or fileOut.preamble and postscript:  two strings that serve as prefix (useful for documentation) and suffix (useful for doits) to the fileout of the changeSet.'!!ChangeSet methodsFor: 'initialize-release' stamp: 'sw 11/26/96'!clear 	"Reset the receiver to be empty.  "	classChanges _ Dictionary new.	methodChanges _ Dictionary new.	classRemoves _ Set new.	preamble _ nil.	postscript _ nil! !!ChangeSet methodsFor: 'initialize-release' stamp: 'sw 11/27/96'!editPostscript	"edit the receiver's postscript, in a separate window.  "	self assurePostscriptExists.	StringHolderView open: postscript label: 'Postscript for ChangeSet named ', name! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 6/15/97 08:40'!initialize 	"Reset the receiver to be empty."	self wither.  "Avoid duplicate entries in AllChangeSets if initialize gets called twice"	classChanges _ Dictionary new.	methodChanges _ Dictionary new.	classRemoves _ Set new.	methodRemoves _ Dictionary new.	name _ ChangeSet defaultName! !!ChangeSet methodsFor: 'testing' stamp: 'sw 9/14/97 17:16'!belongsToAProject	Project allInstances do: [:each |		each projectChangeSet == self ifTrue: [^ true]].	^ false! !!ChangeSet methodsFor: 'testing' stamp: 'sw 10/1/97 17:59'!okayToRemove	| aName |	aName _ self name.	self == Smalltalk changes ifTrue:		[self inform: 'Cannot remove "', aName, '"because it is the current change set.'.		^ false].	self belongsToAProject ifTrue:		[self inform: 'Cannot remove "', aName, '" because it belongs to a project.'.			^ false].	^ true! !!ChangeSet methodsFor: 'change management' stamp: 'di 9/22/97 13:19'!assimilateAllChangesFoundIn: aChangeSet	"Make all changes in aChangeSet take effect on self as it they happened later.  *** classes renamed in aChangeSet may have have problems"	| cls info selector pair |	aChangeSet changedClassNames do: [:className |		(cls _ Smalltalk classNamed: className) notNil ifTrue:		[info _ aChangeSet classChangeAt: className.		info do: [:each | self atClass: cls add: each].		info _ aChangeSet methodChanges at: className 			ifAbsent: [Dictionary new].		info associationsDo: [:assoc |			assoc value == #remove				ifTrue:					[selector _ assoc key.					self removeSelector: selector class: cls.					pair _ aChangeSet methodRemoves							at: (Array with: cls name with: selector)							ifAbsent: [nil].					pair ifNotNil:						["Retain source code ref if stored"						methodRemoves at: (Array with: cls name with: selector)										put: pair]]				ifFalse: 					[self atSelector: assoc key class: cls put: assoc value]]]].	self flag: #developmentNote.  "the following cannot work, since the class will not exist; SW comments this out 8/91 because it thwarts integration!!""aChangeSet classRemoves do:		[:removed | self removeClass: (Smalltalk classNamed: removed)] "! !!ChangeSet methodsFor: 'change management' stamp: 'sw 9/17/97 20:47'!noteRemovalOf: aClass	"The class is about to be removed from the system.  Adjust the receiver to reflect that fact."	classChanges removeKey: aClass name ifAbsent: [].	methodChanges removeKey: aClass name ifAbsent: [].	classChanges removeKey: aClass class name ifAbsent: [].	methodChanges removeKey: aClass class name ifAbsent: [].	classRemoves add: aClass name! !!ChangeSet methodsFor: 'change management' stamp: 'sw 9/20/97 23:44'!removeNamedClassChanges: className	"Remove all memory of changes associated with this class name.	This is here as removeClassChanges: will not work if the class	has been removed."	self flag: #deferred.  "No senders; fix-up"	classChanges removeKey: className ifAbsent: [].	methodChanges removeKey: className ifAbsent: [].	classRemoves remove: className ifAbsent: [].! !!ChangeSet methodsFor: 'method changes' stamp: 'di 9/22/97 13:18'!removeSelector: selector class: class 	"Include indication that a method has been forgotten."	(self atSelector: selector class: class) = #add		ifTrue: [self atSelector: selector					class: class					put: #addedThenRemoved]		ifFalse: [self atSelector: selector					class: class					put: #remove].	(class includesSelector: selector) ifTrue:		["Save the source code pointer and category so can still browse old versions"		methodRemoves at: (Array with: class name with: selector)			put: (Array with: (class compiledMethodAt: selector) sourcePointer						with: (class whichCategoryIncludesSelector: selector))]! !!ChangeSet methodsFor: 'method changes' stamp: 'sw 10/31/97 23:59'!selectorList	"answer a set of all the selectors represented in the change set"	"Smalltalk changes selectorList"	| aList |	aList _ OrderedCollection new.	methodChanges associationsDo: 		[:clAssoc | 		clAssoc value associationsDo: 			[:mAssoc |			(#(remove addedThenRemoved) includes: mAssoc value) ifFalse:				[aList add: mAssoc key]]].	^ aList asSet! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 11/27/96'!assurePostscriptExists	"Make sure there is a StringHolder holding the postscript.  "	postscript == nil ifTrue: [postscript _ StringHolder new contents: '']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 11/27/96'!assurePreambleExists	"Make sure there is a StringHolder holding the preamble.  	 : if it's found to have reverted to empty contents, put up the template"	(preamble == nil or: [preamble contents size == 0])		ifTrue: [preamble _ StringHolder new contents: self preambleTemplate]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 10/18/97 13:01'!checkForSlips	"Return a collection of method refs with possible debugging code."	| slips tsRef changes method |	slips _ OrderedCollection new.	tsRef _ Smalltalk associationAt: #Transcript.	self changedClasses do:		[:aClass |		changes _ methodChanges at: aClass name ifAbsent: [nil].		changes ifNotNil:			[changes associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value)					ifFalse:					[method _ aClass compiledMethodAt: mAssoc key.					((method hasLiteral: #halt) or: [method hasLiteral: tsRef])						ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 10/17/97 23:01'!fileOut	"File out the receiver, to a file whose name is a function of the change-set name and of the date and the time."	| file slips |	Cursor write showWhile:		[file _ FileStream newFileNamed: ((self name, '.', Utilities dateTimeSuffix, '.cs') truncateTo: 27).		file header; timeStamp.		self fileOutPreambleOn: file.		self fileOutOn: file.		self fileOutPostscriptOn: file.		file trailer; close].	slips _ self checkForSlips.	(slips size > 0 and: [self confirm: 'Methods in this fileOut have haltsor references to the Transcript in them.Would you like to browse them?'])		ifTrue: [Smalltalk browseMessageList: slips							name: 'References to #halt or Transcript']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 9/17/97 21:01'!fileOutOn: stream 	"Write out all the changes the receiver knows about"	| classList |	self isEmpty ifTrue: [self notify: 'Warning: no changes to file out'].	classList _ ChangeSet superclassOrder: self changedClasses asOrderedCollection.	classList do:		[:aClass |  "if class defn changed, put it onto the file now"			self fileOutClassDefinition: aClass on: stream].	classList do:		[:aClass |  "nb: he following no longer puts out class headers"			self fileOutChangesFor: aClass on: stream].	stream cr.	classList do:		[:aClass |		self fileOutPSFor: aClass on: stream].	classRemoves do:		[:aClassName | stream nextChunkPut: 'Smalltalk removeClassNamed: #', aClassName; cr].! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 11/25/96'!fileOutPostscriptOn: stream 	"If the receiver has a postscript, put it out onto the stream.  "	| aString |	((aString _ self postscriptString) size > 0)		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 11/25/96'!fileOutPreambleOn: stream 	"If the receiver has a preamble, put it out onto the stream.  "	| aString |	((aString _ self preambleString) size > 0)		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 11/27/96'!postscriptString	"Answer the string representing the postscript.  "	self assurePostscriptExists.	^ postscript contents! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 11/27/96'!postscriptString: aString	"Establish aString as the new contents of the postscript.  "	postscript _ StringHolder new contents: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 11/27/96'!preambleString	"Answer the string representing the preamble.  "	^ preamble == nil		ifTrue:			[preamble]		ifFalse:			[preamble contents]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 11/27/96'!preambleString: aString	"Establish aString as the new contents of the preamble.  "	preamble _ StringHolder new contents: aString! !!ChangeSet methodsFor: 'fileIn/Out'!preambleTemplate	"Answer a string that will form the default contents for a change set's preamble.  Just a first stab at what the content should be.12/3/96 sw"	| aStream |	aStream _ ReadWriteStream on: ''.	aStream nextPutAll: '"Change Set:'.	aStream tab;tab; nextPutAll: self name.	aStream cr; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.	aStream cr; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: 'Your Name'.	aStream cr; cr; nextPutAll: '<your descriptive text goes here>"'.	^ aStream contents"Smalltalk changes preambleTemplate"! !!ChangeSet methodsFor: 'private' stamp: 'di 6/28/97 20:34'!fileOutClassDefinition: class on: stream 	"Write out class definition for the given class on the given stream, if the class definition was added or changed.  5/15/96 sw"	((self atClass: class includes: #add) or: [self atClass: class includes: #change])		ifTrue:			[stream command: 'H3'; nextChunkPut: class definition; cr; command: '/H3']! !!ChangeSet methodsFor: 'private' stamp: 'tk 12/15/97 14:49'!fileOutClassModifications: class on: stream 	"Write out class mod-- rename, comment, reorg, remove, on the given stream.  Differs from the superseded fileOutClassChanges:on: in that it does not deal with class definitions, and does not file out entire added classes.  	 : put out a rename indicator that won't halt if class of old name not there."	| commentRemoteStr header |	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #comment) ifTrue:		[commentRemoteStr _ class theNonMetaClass organization commentRemoteStr.		commentRemoteStr ifNotNil: [			stream cr; nextPut: $!!.	"directly"			"Should be saying (file command: 'H3') for HTML, but ignoring it here"			header _ String streamContents: [:strm | 				strm nextPutAll: class theNonMetaClass name;				nextPutAll: ' commentStamp: '.				Utilities changeStamp storeOn: strm.				strm nextPutAll: ' prior: '; nextPutAll: '0'].			stream nextChunkPut: header; cr.			RemoteString				newString: commentRemoteStr text				onFileNumber: nil				toFile: stream.			stream cr]].	(self atClass: class includes: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]! !!ChangeSet methodsFor: 'accessing' stamp: 'sw 11/27/96'!editPreamble	"edit the receiver's preamble, in a separate window.  "	self assurePreambleExists.	StringHolderView open: preamble label: 'Preamble for ChangeSet named ', name! !!ChangeSet methodsFor: 'accessing' stamp: 'di 6/15/97 09:45'!methodRemoves	^methodRemoves! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 11/26/96'!initialize	"Initialize the receiver to look at the current change set.  "	self initializeFor: Smalltalk changes! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 11/26/96'!initializeFor: aChangeSet	"Initialize the receiver and have it start out life looking at aChangeSet.  "	myChangeSet _ aChangeSet.		classList _ CngsClassList new.	classList parent: self.	messageList _ CngsMsgList new.	messageList parent: self.	MsgListMenu == nil ifTrue: [self class initialize].	classList list: #().	messageList list: #().! !!ChangeSorter methodsFor: 'creation'!open  "ChangeSorter new open"	| topView |	self initialize.	topView _ StandardSystemView new.	topView model: self.	topView label: self label.	topView minimumSize: 360@360.	self openView: topView offsetBy: 0@0.	topView controller open		"Let the show begin"! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 8/7/97 18:40'!openView: topView	"Create change sorter on one changeSet only.  Two of these in a DualChangeSorter."	| classView messageView codeView |	self isThisEverCalled.	buttonView _ SwitchView new.	buttonView model: self controller: TriggerController new.	buttonView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.	buttonView selector: #whatPolarity.	buttonView controller selector: #cngSetActivity.	buttonView window: (0 @ 0 extent: 360 @ 20).	buttonView label: myChangeSet name asParagraph.	classView _ GeneralListView new.	classView controllerClass: GeneralListController.	classView model: classList.	classView window: (0 @ 0 extent: 180 @ 160).	classView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	classView controller yellowButtonMenu: ClassMenu 		yellowButtonMessages: ClassSelectors.	classList controller: classView controller.	messageView _ GeneralListView new.	messageView controllerClass: GeneralListController.	messageView model: messageList.	messageView window: (0 @ 0 extent: 180 @ 160).	messageView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	messageView controller yellowButtonMenu: MsgListMenu 		yellowButtonMessages: MsgListSelectors.	messageList controller: messageView controller.	codeView _ BrowserCodeView new.	codeView model: self.	codeView window: (0 @ 0 extent: 360 @ 180).	codeView borderWidthLeft: 2 right: 2 top: 0 bottom: 2.	topView addSubView: buttonView.	topView addSubView: classView below: buttonView.	topView addSubView: messageView toRightOf: classView.	topView addSubView: codeView below: classView."	classView 		align: classView viewport topLeft 			with: buttonView viewport bottomLeft.	messageView 		align: messageView viewport topLeft 			with: classView viewport topRight.	codeView 		align: codeView viewport topLeft 			with: classView viewport bottomLeft."! !!ChangeSorter methodsFor: 'creation'!openView: topView offsetBy: offset	"Create change sorter on one changeSet with 0@0.	Two of these in a DualChangeSorter, right one is offset by 360@0."	| classView messageView codeView |	buttonView _ SwitchView new.	buttonView model: self controller: TriggerController new.	buttonView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.	buttonView selector: #whatPolarity.	buttonView controller selector: #cngSetActivity.	buttonView window: ((0 @ 0 extent: 360 @ 20) translateBy: offset).	buttonView label: myChangeSet name asParagraph.	classView _ GeneralListView new.	classView controllerClass: GeneralListController.	classView model: classList.	classView window: (0 @ 0 extent: 180 @ 160).	classView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	classView controller yellowButtonMenu: ClassMenu 		yellowButtonMessages: ClassSelectors.	classList controller: classView controller.	messageView _ GeneralListView new.	messageView controllerClass: GeneralListController.	messageView model: messageList.	messageView window: (0 @ 0 extent: 180 @ 160).	messageView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	messageView controller yellowButtonMenu: MsgListMenu 		yellowButtonMessages: MsgListSelectors.	messageList controller: messageView controller.	codeView _ BrowserCodeView new.	codeView model: self.	codeView window: (0 @ 0 extent: 360 @ 180).	codeView borderWidthLeft: 2 right: 2 top: 0 bottom: 2.	topView addSubView: buttonView.	topView addSubView: classView below: buttonView.	topView addSubView: messageView toRightOf: classView.	topView addSubView: codeView below: classView.! !!ChangeSorter methodsFor: 'change set menu' stamp: 'sw 2/2/96'!browseChangeSet	"Open a message list browser on the new and changed methods in the current change set.  	 : launch a ChangedMessageSet"	ChangedMessageSet openFor: myChangeSet! !!ChangeSorter methodsFor: 'change set menu' stamp: 'di 12/5/97 09:19'!chooseCngSet	"Put up a list of them"	| index |	ChangeSet instanceCount > AllChangeSets size ifTrue: [self gather].	index _ (PopUpMenu labels: 		(AllChangeSets collect: [:each | each name]) asStringWithCr) startUp.	index = 0 ifFalse: [self showChangeSet: (AllChangeSets at: index)].! !!ChangeSorter methodsFor: 'change set menu' stamp: 'sw 11/26/96'!clearChangeSet	"Clear out the current change set, after getting a confirmation.  "	| message |	myChangeSet isEmpty ifFalse:		[message _ 'Are you certain that you want to forget all the changes in this set?'.		(self confirm: message) ifFalse: [^ self]].	myChangeSet clear.	self launch! !!ChangeSorter methodsFor: 'change set menu' stamp: 'sw 11/27/96'!editPostscript	"Allow the user to edit the receiver's change-set's postscript -- in a separate window at present.  "	myChangeSet editPostscript! !!ChangeSorter methodsFor: 'change set menu' stamp: 'sw 11/27/96'!editPreamble	"Allow the user to edit the receiver's change-set's preamble -- in a separate window at present.  "	myChangeSet editPreamble! !!ChangeSorter methodsFor: 'change set menu' stamp: 'jm 12/5/97 13:46'!fileIntoNewChangeSet	"Obtain a file designation from the user, and file its contents into a new change set whose name is a function of the filename; in the end, leave the current change-set unaltered.  5/30/96 sw."	| aFileName  aNewChangeSet |	aFileName _ FillInTheBlank request: 'Name of file to be imported: '.	aFileName size == 0 ifTrue: [^ self].	(FileDirectory default fileExists: aFileName) ifFalse:		[self inform: 'Sorry -- cannot find that file'.		^ self].	aNewChangeSet _ self class newChangesFromFile: aFileName.	aNewChangeSet ~~ nil ifTrue:		[myChangeSet _ aNewChangeSet.		buttonView label: aNewChangeSet name asParagraph.		buttonView display.		self changed: #set]! !!ChangeSorter methodsFor: 'change set menu' stamp: 'di 12/5/97 09:25'!newSet	"Create a new changeSet and show it.  For splitting an existing one that is showing in the other pane..  1991-tck.	 3/9/96 sw: make the new guy the current one, corresponding to 99.5% of normal use.  Also, reject name if already in use."	| newName newSet |	newName _ FillInTheBlank request: 'A name for the new change set'			initialAnswer: ChangeSet defaultName.	newName isEmpty ifTrue: [^ self].	(self class changeSetNamed: newName) ~~ nil		ifTrue:			[self inform: 'Sorry that name is already used'.			^ self].	newSet _ ChangeSet new initialize name: newName.	AllChangeSets add: newSet.	self showChangeSet: newSet.	self newCurrent.! !!ChangeSorter methodsFor: 'change set menu' stamp: 'sw 10/1/97 17:33'!remove	"Completely destroy my change set.  Check if it's OK first"	self removePrompting: true! !!ChangeSorter methodsFor: 'change set menu' stamp: 'di 12/5/97 09:26'!removePrompting: doPrompt	"Completely destroy my change set.  Check if it's OK first,  and if doPrompt is true, get the user to confirm his intentions first"	| message aName |	aName _ myChangeSet name.	myChangeSet okayToRemove ifFalse: [^ self]. "forms current changes for some project"	(myChangeSet isEmpty or: [doPrompt not]) ifFalse:		[message _ 'Are you certain that you want to remove (destroy) the change setnamed  "', aName, '" ?'.		(self confirm: message) ifFalse: [^ self]].	"Go ahead and remove the change set"	AllChangeSets remove: myChangeSet.	myChangeSet wither.		"clear out its contents"	self showChangeSet: Smalltalk changes.! !!ChangeSorter methodsFor: 'change set menu' stamp: 'di 12/5/97 09:33'!showChangeSet: chgSet	myChangeSet _ chgSet.	self changed: #set.! !!ChangeSorter methodsFor: 'change set menu' stamp: 'di 12/5/97 09:59'!submergeIntoOtherSide	"Copy the contents of the receiver to the other side, then remove the receiver -- all after checking that all is well."	| other message nextToView i |	other _ (parent other: self) changeSet.	other == myChangeSet ifTrue: [^ self inform: 'Both sides are the same!!'].	myChangeSet isEmpty ifTrue: [^ self inform: 'Nothing to copy.  To remove,simply request "remove".'].	myChangeSet okayToRemove ifFalse: [^ self].	message _ 'Please confirm:  copy all changesin "', myChangeSet name, '" into "', other name, '"and then destroy the change setnamed "', myChangeSet name, '"?'. 	(self confirm: message) ifFalse: [^ self].	other assimilateAllChangesFoundIn: myChangeSet.	nextToView _ ((AllChangeSets includes: myChangeSet)		and: [(i _ AllChangeSets indexOf: myChangeSet) < AllChangeSets size])		ifTrue: [AllChangeSets at: i+1]		ifFalse: [other].	self removePrompting: false.	self showChangeSet: nextToView.	self gather! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 1/15/98 16:43'!removeMessage	"Remove the selected message from the system"	| messageName confirmation |	self okToChange ifFalse: [^ self].  "currently it's always ok"	messageName _ self selectedMessageName.	confirmation _ self selectedClassOrMetaClass confirmRemovalOf: messageName.	confirmation ~~ 3 ifTrue: 		[self selectedClassOrMetaClass removeSelector: messageName.		self launch.		(parent other: self) launch]! !!ChangeSorter methodsFor: 'code pane' stamp: 'di 7/13/97 11:15'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Create an error if the category of the selected message is unknown. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	messageList listIndex = 0 ifTrue: [^ false].	class _ self selectedClassOrMetaClass.	oldSelector _ self selectedMessageName.	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^false].	selector == oldSelector ifFalse: [self changed: #message].	^ true! !!ChangeSorter methodsFor: 'code pane' stamp: 'di 6/15/97 09:34'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self unlock.	(classList selection) == nil ifTrue: [^ contents _ ''].	class _ classList selectedClassOrMetaClass.	(sel _ messageList selection) == nil		ifFalse: [changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents _ 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents _ 'Added then removed (see versions)'].			(class includesSelector: sel)				ifFalse: [^ contents _ 'Method was added, but cannot be found!!'].			^ contents _ (class sourceMethodAt: sel) copy]		ifTrue: [strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: class name) do: [:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Entire class was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr]].			^ contents _ strm contents].! !!ChangeSorter methodsFor: 'code pane' stamp: 'tk 1/16/98 16:49'!wantsBoldSelector	"In code pane?  Only when a message selected"	^ self messageListIndex ~= 0! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 8/11/97 18:13'!allChangeSetNames	^ self gatherChangeSets collect: [:c | c name]! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 8/11/97 18:16'!allChangeSetNamesAfter: aString	| names index |	names _ self allChangeSetNames.	index _ names indexOf: aString ifAbsent: [self error: 'not found'].	^ names copyFrom: index to: names size	"ChangeSorter allChangeSetNamesAfter: 'GenericTfr'"! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 1/15/98 19:46'!initialize	AllChangeSets == nil ifTrue:		[AllChangeSets _ OrderedCollection new].	self gatherChangeSets.	self initializeMenus	"	ChangeSorter initialize.	GeneralListController allInstancesDo:		[:each  | each model parent class == ChangeSorter ifTrue:			[each yellowButtonMenu: ClassMenu 				yellowButtonMessages: ClassSelectors.			each yellowButtonMenu: MsgListMenu 				yellowButtonMessages: MsgListSelectors]].	"! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 1/15/98 19:48'!initializeMenus	"ChangeSorter initializeMenus"	CngSetMenu _ PopUpMenu labels: 'make changes go to menew...file into new...show...fileOutbrowserenamecopy all to other sidesubmerge into other sidesubtract other sideedit preamble...edit postscript...clearremove'    lines: #(1 3 7 10 12).	CngSetSelectors  _ 		#(newCurrent newSet fileIntoNewChangeSet chooseCngSet fileOut browseChangeSet rename copyToOther submergeIntoOtherSide subtractOtherSide editPreamble editPostscript clearChangeSet remove).	ClassMenu _ PopUpMenu labels: 'copy to other sidedelete from this change setbrowse fullinst var refs...inst var defs...class var refs...class vars' 			lines: #(2 3).	ClassSelectors _ 		#(copyToOther forget browseFull  instVarRefs instVarDefs classVarRefs classVariables ).	self initializeMessageListMenu."	ChangeSorter initializeMenus.	GeneralListController allInstancesDo:		[:each  | each model parent class == ChangeSorter ifTrue:			[each yellowButtonMenu: ClassMenu 				yellowButtonMessages: ClassSelectors.			each yellowButtonMenu: MsgListMenu 				yellowButtonMessages: MsgListSelectors]].	"! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 1/15/98 19:14'!initializeMessageListMenu	"ChangeSorter initializeMessageListMenu"	MsgListMenu _ PopUpMenu labels: 'copy method to other sidedelete method from change setremove method from systembrowse fullfileOutprintOutsendersimplementorssenders of...implementors of...versionsmore...'			lines: #(1 3 6 11).	MsgListSelectors _ 	#(copyToOther forget removeMessage browseFull fileOut printOut		senders implementors  browseSendersOfMessages messages versions		shiftedYellowButtonActivity)! !!ChangeSorter class methodsFor: 'all' stamp: 'di 9/20/97 22:34'!newChangesFromFile: aFileName	"File in the code from the file of the given name, into a new change set whose name is derived from that of the filename.  Leave the 'current change set' unchanged.   Returns the new change set; Returns nil on failure.  5/30/96 sw"	^ self newChangesFromStream: (FileStream oldFileNamed: aFileName) 		named: aFileName.! !!ChangeSorter class methodsFor: 'all' stamp: 'di 9/20/97 22:34'!newChangesFromFileStream: aFileStream	"File in the code from the file, into a new change set whose name is derived from the filename.  Leave the 'current change set' unchanged.   Returns the new change set;  Returns nil on failure.  7/12/96 sw"	^ self newChangesFromStream: aFileStream 		named: aFileStream localName! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 9/14/97 17:26'!removeChangeSetsNamed: nameList	| missing rejects aSet |	missing _ OrderedCollection new.	rejects _ OrderedCollection new.	nameList do:		[:aName |			aSet _ self changeSetNamed: aName.			aSet == nil				ifTrue:					[missing add: aName]				ifFalse:					[(self removeSilently: aSet) 						ifFalse:	[rejects add: aName]]].	missing size > 0 ifTrue: [self halt: 'Some were missing'].	rejects size > 0 ifTrue: [self halt: 'some were rejected']! !!ChangeSorter class methodsFor: 'all' stamp: 'di 11/13/97 16:13'!removeSilently: aChangeSet	"Remove the given change set from the system silently; return true if the removal succeeded, or false if the change set was locked down for some reason."	aChangeSet belongsToAProject ifTrue: [^ false].	AllChangeSets remove: aChangeSet.	aChangeSet wither.	^ true"Handy code to drop all but most recent N changeSets... | allChanges |  allChanges _ ChangeSorter gatherChangeSets.(allChanges copyFrom: 1 to: (allChanges size - 40 max: 0))	do: [:oldSet | ChangeSorter removeSilently: oldSet]"! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 11/26/96'!secondaryChangeSet	"Answer a likely change set to use as the second initial one in a Dual Change Sorter.  "	| last |	self gatherChangeSets.	AllChangeSets size == 1 ifTrue: [^ AllChangeSets first].	^ (last _ AllChangeSets last) == Smalltalk changes		ifTrue: 	[AllChangeSets at: (AllChangeSets size - 1)]		ifFalse:	[last]! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'di 9/20/97 22:34'!newChangesFromStream: aFileStream named: aFileName	"File in the code from the file, into a new change set whose name is derived from the filename.  Leave the 'current change set' unchanged.   Returns the new change set;  Returns nil on failure.  7/12/96 sw  Allow any kind of stream.  tk 9/11/97"	|  newName aNewChangeSet existingChanges |	existingChanges _ Smalltalk changes.	newName _ aFileName sansPeriodSuffix.	(self changeSetNamed: newName) ~~ nil		ifTrue:			[self inform: 'Sorry -- "', newName, '" is already used as a change-set name'.			aFileStream close.			^ nil].	aNewChangeSet _ ChangeSet new initialize.	aNewChangeSet name: newName.	AllChangeSets add: aNewChangeSet.	self makeCurrent: aNewChangeSet.	aFileStream fileIn.	Transcript cr; show: 'File ', aFileName, ' successfully filed in to change set ', newName.	self makeCurrent: existingChanges.	^ aNewChangeSet! !!Character methodsFor: 'accessing'!digitValue	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 	otherwise. This is used to parse literal numbers of radix 2-36."	value <= $9 asciiValue 		ifTrue: [^value - $0 asciiValue].	value >= $A asciiValue 		ifTrue: [value <= $Z asciiValue ifTrue: [^value - $A asciiValue + 10]].	^ -1! !!Character methodsFor: 'converting'!asLowercase	"If the receiver is uppercase, answer its matching lowercase Character."		(8r101 <= value and: [value <= 8r132])  "self isUppercase"		ifTrue: [^ Character value: value + 8r40]		ifFalse: [^ self]! !!Character class methodsFor: 'accessing untypeable characters'!linefeed	"Answer the Character representing a linefeed."	^self value: 10! !!Character class methodsFor: 'constants' stamp: 'tk 12/11/97 09:29'!alphabet	^ 'abdcefghijklmnopqrstuvwxyz'! !!CharacterBlock methodsFor: 'accessing' stamp: 'di 12/2/97 14:33'!textLine	^ textLine! !!CharacterBlock methodsFor: 'accessing' stamp: 'di 12/2/97 14:33'!textLine: aLine	textLine _ aLine! !!CharacterBlock methodsFor: 'printing' stamp: 'di 12/2/97 19:15'!printOn: aStream	aStream nextPutAll: 'a CharacterBlock with index '.	stringIndex printOn: aStream.	(text ~~ nil and: [text size> 0 and: [stringIndex between: 1 and: text size]])		ifTrue: [aStream nextPutAll: ' and character '.				(text at: stringIndex) printOn: aStream].	aStream nextPutAll: ' and rectangle '.	super printOn: aStream.	textLine ifNotNil: [aStream cr; nextPutAll: ' in '.				textLine printOn: aStream].! !!CharacterBlock methodsFor: 'private'!moveBy: aPoint 	"Change the corner positions of the receiver so that its area translates by 	the amount defined by the argument, aPoint."	origin _ origin + aPoint.	corner _ corner + aPoint! !!CharacterBlock methodsFor: 'private' stamp: 'di 10/23/97 22:33'!stringIndex: anInteger text: aText topLeft: topLeft extent: extent	stringIndex _ anInteger.	text _ aText.	super setOrigin: topLeft corner: topLeft + extent ! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'di 12/2/97 14:30'!characterBlockAtPoint: aPoint index: index in: textLine	| runLength lineStop done stopCondition |	line _ textLine.	characterIndex _ index.  " == nil means scanning for point"	characterPoint _ aPoint.	(characterPoint == nil or: [characterPoint y > line bottom])		ifTrue: [characterPoint _ line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex ~~ nil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ textStyle lineGrid)					textLine: line].	rightMargin _ line rightMargin.	destX _ leftMargin _ line leftMarginForAlignment: textStyle alignment.	destY _ line top.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ text runLengthFor: line first.	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex  "scanning for index"]		ifFalse:	[lineStop _ line last  "scanning for point"].	runStopIndex _ lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0.	done  _ false.	[done] whileFalse:		[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern displaying: false.		"see setStopConditions for stopping conditions for character block 	operations."		self lastCharacterExtentSetX: (specialWidth == nil			ifTrue: [font widthOf: (text at: lastIndex)]			ifFalse: [specialWidth]).		(self perform: stopCondition) ifTrue:			[^ (CharacterBlock new				stringIndex: (characterIndex==nil ifTrue: [lastIndex] ifFalse: [characterIndex])				text: text topLeft: characterPoint extent: lastCharacterExtent)				textLine: line]]! !!CharacterBlockScanner methodsFor: 'scanning'!characterNotInFont 	"This does not handle character selection nicely, i.e., illegal characters are a 	little tricky to select.  Since the end of a run or line is subverted here by actually	having the scanner scan a different string in order to manage the illegal 	character, things are not in an absolutely correct state for the character 	location code.  If this becomes too odious in use, logic will be added to accurately 	manage the situation."	lastCharacterExtent _ 		(font widthOf: (font maxAscii + 1) asCharacter) @ line lineHeight.	^super characterNotInFont! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'di 11/12/97 19:34'!placeEmbeddedObject: anchoredMorph	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	specialWidth _ width.	^ true! !!CharacterBlockScanner methodsFor: 'stop conditions'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY _ destY +  line lineHeight.				lastCharacter _ nil.				characterPoint _ ((text at: lastIndex) = CR								ifTrue: [leftMargin]								ifFalse: [nextLeftMargin]) @ destY.				lastIndex _ lastIndex + 1.				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter _ CR.		characterPoint _ destX @ destY.		self lastCharacterExtentSetX: rightMargin - destX.		^true! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'di 11/7/97 12:20'!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| leadingTab currentX |	characterPoint x <= (destX + ((lastCharacterExtent x) // 2))		ifTrue:	[lastCharacter _ (text at: lastIndex).				characterPoint _ destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter _ (text at: line last).				characterPoint _ destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex _ lastIndex + 1.	lastCharacter _ text at: lastIndex.	currentX _ destX + lastCharacterExtent x.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint _ currentX @ destY.	"Yukky if next character is space or tab."	(lastCharacter = Space and: [textStyle alignment = Justified])		ifTrue:	[self lastCharacterExtentSetX:					(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1))).				^ true].	lastCharacter = Space		ifTrue:			["See tabForDisplay for illumination on the following awfulness."			leadingTab _ true.			(line first to: lastIndex - 1) do:			[:index |			(text at: index) ~= Tab				ifTrue: [leadingTab _ false]].			(textStyle alignment ~= Justified or: [leadingTab])				ifTrue:	[self lastCharacterExtentSetX: (textStyle nextTabXFrom: currentX							leftMargin: leftMargin rightMargin: rightMargin) -								currentX]				ifFalse:	[self lastCharacterExtentSetX:  (((currentX + (textStyle tabWidth -								(line justifiedTabDeltaFor: spaceCount))) -									currentX) max: 0)]].	^ true! !!CharacterBlockScanner methodsFor: 'stop conditions'!endOfRun	"Before arriving at the cursor location, the selection has encountered an 	end of run. Answer false if the selection continues, true otherwise. Set 	up indexes for building the appropriate CharacterBlock."	| runLength lineStop |	((characterIndex ~~ nil and:		[runStopIndex < characterIndex and: [runStopIndex < text size]])			or:	[characterIndex == nil and: [lastIndex < line last]])		ifTrue:	["We're really at the end of a real run."				runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).				characterIndex ~~ nil					ifTrue:	[lineStop _ characterIndex	"scanning for index"]					ifFalse:	[lineStop _ line last			"scanning for point"].				(runStopIndex _ lastIndex + (runLength - 1)) > lineStop					ifTrue: 	[runStopIndex _ lineStop].				self setStopConditions.				^false].	lastCharacter _ text at: lastIndex.	characterPoint _ destX @ destY.	((lastCharacter = Space and: [textStyle alignment = Justified])		or: [lastCharacter = Tab and: [lastSpaceOrTabExtent notNil]])		ifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent].	characterIndex ~~ nil		ifTrue:	["If scanning for an index and we've stopped on that index,				then we back destX off by the width of the character stopped on				(it will be pointing at the right side of the character) and return"				runStopIndex = characterIndex					ifTrue:	[self characterPointSetX: destX - lastCharacterExtent x.							^true].				"Otherwise the requested index was greater than the length of the				string.  Return string size + 1 as index, indicate further that off the				string by setting character to nil and the extent to 0."				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				self lastCharacterExtentSetX: 0.				^true].	"Scanning for a point and either off the end of the line or off the end of the string."	runStopIndex = text size		ifTrue:	["off end of string"				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				self lastCharacterExtentSetX: 0.				^true].	"just off end of line without crossing x"	lastIndex _ lastIndex + 1.	^true! !!CharacterBlockScanner methodsFor: 'stop conditions'!paddedSpace	"When the line is justified, the spaces will not be the same as the font's 	space character. A padding of extra space must be considered in trying 	to find which character the cursor is pointing at. Answer whether the 	scanning has crossed the cursor."	| pad |	pad _ 0.	spaceCount _ spaceCount + 1.	pad _ line justifiedPadFor: spaceCount.	lastSpaceOrTabExtent _ lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX:  spaceWidth + pad.	(destX + lastSpaceOrTabExtent x)  >= characterPoint x		ifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent copy.				^self crossedX].	lastIndex _ lastIndex + 1.	destX _ destX + lastSpaceOrTabExtent x.	^ false! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'di 11/11/97 08:50'!setFont	specialWidth _ nil.	super setFont! !!CharacterBlockScanner methodsFor: 'stop conditions'!tab	| currentX |	currentX _ (textStyle alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse:			[textStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastSpaceOrTabExtent _ lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX: (currentX - destX max: 0).	currentX >= characterPoint x		ifTrue: 			[lastCharacterExtent _ lastSpaceOrTabExtent copy.			^ self crossedX].	destX _ currentX.	lastIndex _ lastIndex + 1.	^false! !!CharacterBlockScanner methodsFor: 'private' stamp: 'di 12/2/97 14:30'!buildCharacterBlockIn: para	| lineIndex runLength lineStop done stopCondition |	"handle nullText"	(para numberOfLines = 0 or: [text size = 0])		ifTrue:	[^ CharacterBlock new stringIndex: 1  "like being off end of string"					text: para text					topLeft: (para leftMarginForDisplayForLine: 1)								@ para compositionRectangle top					extent: 0 @ textStyle lineGrid].	"find the line"	lineIndex _ para lineIndexOfTop: characterPoint y.	destY _ para topAtLineIndex: lineIndex.	line _ para lines at: lineIndex.	rightMargin _ para rightMarginForDisplay.	(lineIndex = para numberOfLines and:		[(destY + line lineHeight) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					self characterPointSetX: rightMargin]			ifFalse:	[characterPoint y < (para compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint _ (para compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[self characterPointSetX: rightMargin]].	destX _ leftMargin _ para leftMarginForDisplayForLine: lineIndex.	nextLeftMargin_ para leftMarginForDisplayForLine: lineIndex+1.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ (text runLengthFor: line first).	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex	"scanning for index"]		ifFalse:	[lineStop _ line last].	(runStopIndex _ lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex _ lineStop].	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0. done  _ false.	[done]	whileFalse:	[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern displaying: false.	"see setStopConditions for stopping conditions for character block 	operations."	self lastCharacterExtentSetX: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition)		ifTrue:	[^ CharacterBlock new stringIndex: lastIndex text: text					topLeft: characterPoint extent: lastCharacterExtent]]! !!CharacterBlockScanner methodsFor: 'private'!characterPointSetX: xVal	characterPoint _ xVal @ characterPoint y! !!CharacterBlockScanner methodsFor: 'private'!lastCharacterExtentSetX: xVal	lastCharacterExtent _ xVal @ lastCharacterExtent y! !!CharacterBlockScanner methodsFor: 'private'!lastSpaceOrTabExtentSetX: xVal	lastSpaceOrTabExtent _ xVal @ lastSpaceOrTabExtent y! !!CharacterScanner methodsFor: 'scanning' stamp: 'di 10/29/97 12:16'!characterNotInFont	"All fonts have an illegal character to be used when a character is not 	within the font's legal range. When characters out of ranged are 	encountered in scanning text, then this special character indicates the 	appropriate behavior. The character is usually treated as a unary 	message understood by a subclass of CharacterScanner."	| illegalAsciiString saveIndex stopCondition | 	saveIndex _ lastIndex.	illegalAsciiString _ String with: (font maxAscii + 1) asCharacter.	stopCondition _ self scanCharactersFrom: 1 to: 1			in: illegalAsciiString			rightX: rightMargin stopConditions: stopConditions			kern: kern displaying: self doesDisplaying.	lastIndex _ saveIndex + 1.	stopCondition ~= (stopConditions at: EndOfRun)		ifTrue:	[^self perform: stopCondition]		ifFalse: [lastIndex = runStopIndex					ifTrue:	[^self perform: (stopConditions at: EndOfRun)].				^false]! !!CharacterScanner methodsFor: 'scanning' stamp: 'jm 11/19/97 23:15'!ifCharIn: str at: i fits: segLen do: fonCharWidthBlock	"Scan a character of text, tracking font changes, and return true,	unless the character won't fit or it is off the end of the string."	"No kerning yet..."	| ascii char maxAscii |	i > str size ifTrue: [^ false].	(runStopIndex == nil or: [i > runStopIndex]) ifTrue:		[runStopIndex _ i + (text runLengthFor: i) - 1.		lastIndex _ i.		self setFont].	maxAscii _ xTable size-2.	ascii _ (char _ str at: i) asciiValue min: maxAscii.	width _ (xTable at: ascii + 2) - (xTable at: ascii + 1).	width > segLen ifTrue: [^ false].	fonCharWidthBlock value: font value: char value: width.	^ true! !!CharacterScanner methodsFor: 'scanning' stamp: 'di 11/17/97 15:08'!placeEmbeddedObject: anchoredMorph	"Place the anchoredMorph or return false if it cannot be placed.	In any event, advance destX by its width."	destX _ destX + (width _ anchoredMorph width).	(destX > rightMargin and: [(leftMargin + width) <= rightMargin])		ifTrue: ["Won't fit, but would on next line"				^ false].	runStopIndex _ lastIndex.  "Force new calc of emphasis"	lastIndex _ lastIndex + 1.	^ true! !!CharacterScanner methodsFor: 'scanning'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops displaying: display 	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable. If dextX would exceed rightX, then 	return stops at: 258. If displaying is true, then display the character. 	Advance destX by the width of the character. If stopIndex has been 	reached, then return stops at: 257. Fail under the same conditions that 	the Smalltalk code below would cause an error. Optional. See Object 	documentation whatIsAPrimitive."	| ascii nextDestX maxAscii |	<primitive: 103>	maxAscii _ xTable size-2.	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[ascii _ (sourceString at: lastIndex) asciiValue.			"ascii > maxAscii ifTrue: [ascii _ maxAscii]."			(stopConditions at: ascii + 1) == nil				ifFalse: [^stops at: ascii + 1].			sourceX _ xTable at: ascii + 1.			nextDestX _ destX + (width _ (xTable at: ascii + 2) - sourceX).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			display ifTrue: [self copyBits].			destX _ nextDestX.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!CharacterScanner methodsFor: 'scanning' stamp: 'di 10/31/97 12:51'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta displaying: display 	"This method will perform text scanning with non-zero kerning.	It calls the faster primitive method, if the kern delta is zero.	Some day we may want to put kerning into the primitive."	| ascii nextDestX maxAscii fillBlt |	kernDelta = 0 ifTrue:		[^ self scanCharactersFrom: startIndex to: stopIndex in: sourceString				rightX: rightX stopConditions: stops displaying: display].	display ifTrue: [fillBlt _ self fillBlt].	maxAscii _ xTable size-2.	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[ascii _ (sourceString at: lastIndex) asciiValue.			ascii > maxAscii ifTrue: [ascii _ maxAscii].			(stopConditions at: ascii + 1) == nil				ifFalse: [^stops at: ascii + 1].			sourceX _ xTable at: ascii + 1.			nextDestX _ destX + (width _ (xTable at: ascii + 2) - sourceX).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			display ifTrue:				[self copyBits				fillBlt == nil ifFalse:					[fillBlt destX: nextDestX destY: destY							width: kernDelta height: height;							copyBits]].			destX _ nextDestX + kernDelta.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!CharacterScanner methodsFor: 'private'!addEmphasis: code	"Set the bold-ital-under-strike emphasis."	emphasisCode _ emphasisCode bitOr: code! !!CharacterScanner methodsFor: 'private' stamp: 'di 10/29/97 11:58'!addKern: kernDelta	"Set the current kern amount."	kern _ kern + kernDelta! !!CharacterScanner methodsFor: 'private' stamp: 'jm 11/19/97 21:56'!beginAt: startCharIndex	lastIndex _ startCharIndex.	runStopIndex _ lastIndex + (text runLengthFor: lastIndex) - 1.	self setFont! !!CharacterScanner methodsFor: 'private' stamp: 'jm 11/19/97 21:56'!ifNextCharFits: segLen do: fonCharWidthBlock! !!CharacterScanner methodsFor: 'private'!setActualFont: aFont	"Set the basal font to an isolated font reference."	font _ aFont! !!CharacterScanner methodsFor: 'private' stamp: 'di 10/29/97 12:00'!setFont	"Set the font and other emphasis."	self setFont: 1.	emphasisCode _ 0.	kern _ 0.	(text attributesAt: lastIndex) do: 		[:att | att emphasizeScanner: self].	font _ font emphasized: emphasisCode.	"Install various parameters from the font."	spaceWidth _ font widthOf: Space. 	sourceForm _ font glyphs.  "Should only be needed in DisplayScanner"	height _ font height.			" ditto "	xTable _ font xTable.	stopConditions _ font stopConditions.	stopConditions at: Space asciiValue + 1 put: #space.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX! !!CharacterScanner methodsFor: 'private' stamp: 'di 10/24/97 09:05'!setFont: fontNumber	"Set the font by number from the textStyle."	self setActualFont: (textStyle fontAt: fontNumber)! !!CharacterScanner methodsFor: 'private' stamp: 'jm 11/19/97 20:51'!setFontAt: startCharIndex	lastIndex _ startCharIndex.	self setFont! !!CharacterScanner methodsFor: 'private' stamp: 'di 10/22/97 11:52'!text: t textStyle: ts	text _ t.	textStyle _ ts! !!CharacterScanner methodsFor: 'private'!textColor: ignored	"Overridden in DisplayScanner"! !Simple ServerAction that maintains a list of the 20 most recent submissions (chat messages).!!ChatPage methodsFor: 'chat processing' stamp: 'mjg 11/25/97 13:33'!add: aMessage 	current isNil ifTrue: [current _ OrderedCollection new].	current add: aMessage.	(current size > 20) 		ifTrue: [current _ current copyFrom: (current size - 20) to: (current size)]! !!ChatPage methodsFor: 'chat processing' stamp: 'mjg 11/17/97 13:32'!current	^current! !!ChatPage methodsFor: 'URL processing' stamp: 'mjg 11/25/97 13:34'!process: request 	| author note |	request fields isNil		ifTrue: 			[current isNil ifTrue: [current _ OrderedCollection new].			request reply: (HTMLformatter evalEmbedded: (self fileContents: 'chat.html')					with: current)]		ifFalse: 			[author _ request fields at: 'author'.			note _ request fields at: 'note'.			self add: '<b>' , author , '</b> 			<i>' , Time now printString , '-' , Date today printString , '</i><p>' , note , '<p>'.			request fields at: 'current' put: current.			request reply: (HTMLformatter evalEmbedded: (self fileContents: 'chat.html')					with: request)]! !!Class methodsFor: 'initialize-release'!sharing: poolString 	"Set up sharedPools. Answer whether recompilation is advisable."	| oldPools found |	oldPools _ self sharedPools.	sharedPools _ OrderedCollection new.	(Scanner new scanFieldNames: poolString) do: 		[:poolName | 		sharedPools add: (Smalltalk at: poolName asSymbol)].	sharedPools isEmpty ifTrue: [sharedPools _ nil].	oldPools do: [:pool | found _ false.				self sharedPools do: [:p | p == pool ifTrue: [found _ true]].				found ifFalse: [^ true "A pool got deleted"]].	^ false! !!Class methodsFor: 'copying' stamp: 'sw 6/12/96'!copyOfMethodDictionary	"Return a copy of the receiver's method dictionary.  "	^ methodDict copy! !!Class methodsFor: 'class name'!rename: aString 	"The new name of the receiver is the argument, aString."	| newName |	newName _ aString asSymbol.	(Smalltalk includesKey: newName)		ifTrue: [^self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [^ SelectionMenu notify: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	Smalltalk renameClass: self as: newName.	name _ newName.	self comment: self comment.	self class comment: self class comment! !!Class methodsFor: 'pool variables' stamp: 'tk 9/12/96'!removeSharedPool: aDictionary 	"Remove the pool dictionary, aDictionary, as one of the receiver's pool 	dictionaries. Create an error notification if the dictionary is not one of 	the pools.	: Note that it removes the wrong one if there are two empty Dictionaries in the list."	| satisfiedSet workingSet aSubclass |	(self sharedPools includes: aDictionary)		ifFalse: [^self error: 'the dictionary is not in my pool'].	"first see if it is declared in a superclass in which case we can remove it."	(self selectSuperclasses: [:class | class sharedPools includes: aDictionary]) isEmpty		ifFalse: [sharedPools remove: aDictionary.				sharedPools isEmpty ifTrue: [sharedPools _ nil].				^self]. 	"second get all the subclasses that reference aDictionary through me rather than a 	superclass that is one of my subclasses."	workingSet _ self subclasses asOrderedCollection.	satisfiedSet _ Set new.	[workingSet isEmpty] whileFalse:		[aSubclass _ workingSet removeFirst.		(aSubclass sharedPools includes: aDictionary)			ifFalse: 				[satisfiedSet add: aSubclass.				workingSet addAll: aSubclass subclasses]].	"for each of these, see if they refer to any of the variables in aDictionary because 	if they do, we can not remove the dictionary."	satisfiedSet add: self.	satisfiedSet do: 		[:sub | 		aDictionary associationsDo: 			[:aGlobal | 			(sub whichSelectorsReferTo: aGlobal) isEmpty 				ifFalse: [^self error: aGlobal key 								, ' is still used in code of class '								, sub name]]].	sharedPools remove: aDictionary.	sharedPools isEmpty ifTrue: [sharedPools _ nil]! !!Class methodsFor: 'compiling' stamp: 'tk 9/11/96'!scopeHas: varName ifTrue: assocBlock 	"Look up the first argument, varName, in the context of the receiver. If it is there,	pass the association to the second argument, assocBlock, and answer true.	Else answer false.	: Allow key in shared pools to be a string for HyperSqueak"	| assoc |	assoc _ self classPool associationAt: varName ifAbsent: [].	assoc == nil		ifFalse: 			[assocBlock value: assoc.			^true].	self sharedPools do: 		[:pool | 		varName = #Textual ifTrue: [self halt].		assoc _ pool associationAt: varName ifAbsent: [			pool associationAt: varName asString ifAbsent: []].		assoc == nil			ifFalse: 				[assocBlock value: assoc.				^true]].	superclass == nil		ifTrue: 			[assoc _ Smalltalk associationAt: varName ifAbsent: [].			assoc == nil				ifFalse: 					[assocBlock value: assoc.					^true].			^false].	^superclass scopeHas: varName ifTrue: assocBlock! !!Class methodsFor: 'subclass creation' stamp: 'sw 7/28/97 15:53'!newSubclass	| i className |	i _ 1.	[className _ (self name , i printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [i _ i + 1].	^ self subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'User Objects'"Point newSubclass new"! !!Class methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 09:58'!fileOut	"Create a file whose name is the name of the receiver with '.st' as the 	extension, and file a description of the receiver onto it."	^ self fileOutAsHtml: false! !!Class methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 20:28'!fileOutAsHtml: useHtml	"Create a file whose name is the name of the receiver with '.st' as the 	extension, and file a description of the receiver onto it."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: self name , '.html') asHtml]		ifFalse: [FileStream newFileNamed: self name , '.st'].	fileStream header; timeStamp.	self sharedPools size > 0 ifTrue:		[self shouldFileOutPools			ifTrue: [self fileOutSharedPoolsOn: fileStream]].	self fileOutOn: fileStream moveSource: false toFile: 0.	fileStream trailer; close! !!Class methodsFor: 'fileIn/Out' stamp: 'ikp 1/3/98 22:45'!fileOutPool: aPool onFileStream: aFileStream 	| aPoolName aValue |	aPoolName _ Smalltalk keyAtValue: aPool.	Transcript cr; show: aPoolName.	aFileStream nextPutAll: 'Transcript show: ''' , aPoolName , '''; cr!!'; cr.	aFileStream nextPutAll: 'Smalltalk at: #' , aPoolName , ' put: Dictionary new!!'; cr.	aPool keys asSortedCollection do: [ :aKey |		aValue _ aPool at: aKey.		aFileStream nextPutAll: aPoolName , ' at: #' , aKey asString , ' put:  '.		(aValue isKindOf: Number)			ifTrue: [aValue printOn: aFileStream]			ifFalse: [aFileStream nextPutAll: '('.					aValue printOn: aFileStream.					aFileStream nextPutAll: ')'].		aFileStream nextPutAll: '!!'; cr].	aFileStream cr! !!ClassCategoryReader methodsFor: 'fileIn/Out' stamp: 'tk 12/15/97 16:26'!scanFrom: aStream 	"File in methods from the stream, aStream."	| methodText |	[methodText _ aStream nextChunkText.	 methodText size > 0]		whileTrue:		[class compile: methodText classified: category			withStamp: changeStamp			notifying: (SyntaxError new category: category)]! !!ClassCategoryReader methodsFor: 'private' stamp: '6/5/97 di'!setClass: aClass category: aCategory	^ self setClass: aClass category: aCategory changeStamp: String new! !!ClassCategoryReader methodsFor: 'private' stamp: '6/5/97 di'!setClass: aClass category: aCategory changeStamp: aString	class _ aClass.	category _ aCategory.	changeStamp _ aString! !!ClassCommentReader methodsFor: 'as yet unclassified' stamp: 'tk 12/15/97 15:56'!scanFrom: aStream 	"File in the class comment from aStream.  Not string-i-fied, just a text, exactly as it is in the browser.  Move to changes file."	class theNonMetaClass classComment: (aStream nextChunkText).		"Writes it on the disk and saves a RemoteString ref"! !!ClassDescription methodsFor: 'initialize-release' stamp: 'sw 7/30/97 18:44'!subclassOf: newSuper oldClass: oldClass instanceVariableNames: newInstVarString variable: v words: w pointers: p ifBad: badBlock 	"Basic initialization message for creating classes using the information 	provided as arguments. Answer whether old instances will be 	invalidated."	| oldNames newNames usedNames invalid oldSuperMeta newInstVarArray oldSpec |	oldNames _ self allInstVarNames.	usedNames _ #(self super thisContext true false nil ) asSet.	newInstVarArray _ Scanner new scanFieldNames: newInstVarString.	newNames _ newSuper allInstVarNames , newInstVarArray.	newNames size > 254 ifTrue:		[self error: 'A class cannot have more than 254 instance variables'.		^ badBlock value].	newNames do: 		[:fieldName | 		(usedNames includes: fieldName)			ifTrue: 				[self error: fieldName , ' is reserved (maybe in a superclass)'.				^ badBlock value].		usedNames add: fieldName].	(invalid _ superclass ~~ newSuper)		ifTrue: 			["superclass changed"			oldSuperMeta _ superclass class.			superclass ifNotNil: [superclass removeSubclass: self].			superclass _ newSuper.			superclass addSubclass: self.			self class superclass == oldSuperMeta 				ifTrue: ["Only false when self is a metaclass"						self class superclass: newSuper class]].	instanceVariables _ newInstVarArray size = 0 ifFalse: [newInstVarArray].	invalid _ invalid | (newNames  ~= oldNames).   "field names changed"	oldSpec _ self instSpec.	self format: newNames size		variable: v		words: w		pointers: p.	invalid _ invalid | (self instSpec ~= oldSpec).  "format changed"	^invalid! !!ClassDescription methodsFor: 'initialize-release'!updateInstancesFrom: oldClass 	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary."	| oldInstVarNames map variable new instSize oldInstances |	oldClass someInstance == nil ifTrue: [^self].	"no instances to convert"	oldInstVarNames _ oldClass allInstVarNames.	map _ 		self allInstVarNames 			collect: [:instVarName | oldInstVarNames indexOf: instVarName].	variable _ self isVariable.	instSize _ self instSize.	"Now perform a bulk mutation of old instances into new ones"	oldInstances _ oldClass allInstances asArray.	oldInstances elementsExchangeIdentityWith:		(oldInstances collect: 		[:old | 		variable			ifTrue: [new _ self basicNew: old basicSize]			ifFalse: [new _ self basicNew].		1 to: instSize do: 			[:offset |  (map at: offset) > 0 ifTrue:				[new instVarAt: offset						put: (old instVarAt: (map at: offset))]].		variable 			ifTrue: [1 to: old basicSize do: 						[:offset |						new basicAt: offset put: (old basicAt: offset)]].		new])! !!ClassDescription methodsFor: 'initialize-release'!validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods 	"Recompile the receiver, a class, and redefine its subclasses if necessary.	The parameter invalidFields is no longer really used"	| newSub invalidSubMethods |	oldClass becomeUncompact.  "Its about to be abandoned"	invalidMethods & self hasMethods		ifTrue: 			[Transcript show: 'recompiling ' , self name , '...'.			self compileAllFrom: oldClass.			Transcript show: ' done'; cr].	invalidSubMethods _ invalidMethods | (self instSize ~= oldClass instSize).	self == oldClass		ifTrue: [invalidSubMethods ifFalse: [^self]]		ifFalse: [self updateInstancesFrom: oldClass].	oldClass subclasses do: 		[:sub | 		newSub _ sub copyForValidation.		newSub			subclassOf: self			oldClass: sub			instanceVariableNames: sub instVarNames			variable: sub isVariable			words: sub isBytes not			pointers: sub isBits not			ifBad: [self error: 'terrible problem in recompiling subclasses!!'].		newSub			validateFrom: sub			in: environ			instanceVariableNames: invalidFields			methods: invalidSubMethods]! !!ClassDescription methodsFor: 'accessing' stamp: 'tk 12/13/97 14:33'!comment	"Answer the receiver's comment. (If old format, not a Text, unpack the old way.) "	| aString |	aString _ self theNonMetaClass organization classComment.	(aString asString beginsWith: self name, ' comment:\''' withCRs) 		ifFalse: [^ self theNonMetaClass organization classComment]		ifTrue: ["old format"			aString size = 0 ifTrue: [^''].			"get string only of classComment, undoubling quotes"			^ String readFromString: aString]! !!ClassDescription methodsFor: 'accessing' stamp: 'tk 12/16/97 07:49'!comment: aStringOrText	"Set the receiver's comment to be the argument, aStringOrText."	self theNonMetaClass classComment: aStringOrText.	Smalltalk changes commentClass: self! !!ClassDescription methodsFor: 'printing'!classVariablesString	"Answer a string of my class variable names separated by spaces."	| aStream |	aStream _ WriteStream on: (String new: 100).	self classPool keys asSortedCollection do: [:key | aStream nextPutAll: key; space].	^aStream contents! !!ClassDescription methodsFor: 'printing'!sharedPoolsString	"Answer a string of my shared pool names separated by spaces."	| aStream |	aStream _ WriteStream on: (String new: 100).	self sharedPools do: [:x | aStream nextPutAll: (Smalltalk keyAtValue: x ifAbsent: ['private']); space].	^ aStream contents! !!ClassDescription methodsFor: 'instance variables' stamp: 'sw 7/29/97 18:34'!chooseInstVarThenDo: aBlock 	"Put up a menu of all the instance variables in the receiver, and when the user chooses one, evaluate aBlock with the chosen variable as its parameter.  7/30/96 sw"	| lines labelStream vars allVars index |	lines _ OrderedCollection new.	allVars _ OrderedCollection new.	labelStream _ WriteStream on: (String new: 200).	self withAllSuperclasses reverseDo:		[:class |		vars _ class instVarNames.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream isEmpty ifTrue:		[^ (PopUpMenu labels: ' OK ')			startUpWithCaption: 'There are noinstance variables.'].	labelStream skip: -1 "cut last CR".	index _ (PopUpMenu labels: labelStream contents lines: lines) startUpWithCaption: 'Instance variables in', class name.	index = 0 ifTrue: [^ self].	aBlock value: (allVars at: index)! !!ClassDescription methodsFor: 'instance variables' stamp: 'di 7/15/97 00:04'!renameInstVar: oldName to: newName	| i oldCode newCode parser header body sels |	(i _ instanceVariables indexOf: oldName) = 0 ifTrue:		[self error: oldName , ' is not defined in ', self name].	self allSuperclasses , self withAllSubclasses asOrderedCollection do:		[:cls | (cls instVarNames includes: newName) ifTrue:			[self error: newName , ' is already used in ', cls name]].	(self confirm: 'WARNING: Renaming of instance variablesis subject to substitution ambiguities.Do you still wish to attempt it?') ifFalse: [self halt].	"...In other words, this does a dumb text search-and-replace,	which might improperly alter, eg, a literal string.  As long as	the oldName is unique, everything should work jes' fine. - di"	instanceVariables replaceFrom: i to: i with: (Array with: newName).	self withAllSubclasses do:		[:cls | sels _ cls selectors.		sels removeAllFoundIn: #(DoIt DoItIn:).		sels do:			[:sel |			oldCode _ cls sourceCodeAt: sel.			"Don't make changes in the method header"			(parser _ cls parserClass new) parseSelector: oldCode.			header _ oldCode copyFrom: 1 to: (parser endOfLastToken min: oldCode size).			body _ header size > oldCode size					ifTrue: ['']					ifFalse: [oldCode copyFrom: header size+1 to: oldCode size].			newCode _ header , (body copyReplaceTokens: oldName with: newName).			newCode ~= oldCode ifTrue:				[cls compile: newCode					classified: (cls organization categoryOfElement: sel)					notifying: nil]].			cls isMeta ifFalse:				[oldCode _ cls comment.				newCode _ oldCode copyReplaceTokens: oldName with: newName.				newCode ~= oldCode ifTrue:					[cls comment: newCode]]]! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 6/14/97 16:03'!removeSelector: aSymbol 	"Remove the message whose selector is aSymbol from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."	(methodDict includesKey: aSymbol) ifFalse: [^nil].	Smalltalk changes removeSelector: aSymbol class: self.	super removeSelector: aSymbol.	self organization removeElement: aSymbol.	self acceptsLoggingOfCompilation ifTrue:		[Smalltalk logChange: self name , ' removeSelector: #' , aSymbol]! !!ClassDescription methodsFor: 'organization' stamp: 'di 7/17/97 00:06'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!ClassDescription methodsFor: 'organization'!zapOrganization	"Remove the organization of this class by message categories.	This is typically done to save space in small systems.  Classes and methods	created or filed in subsequently will, nonetheless, be organized"	organization _ nil.	self isMeta ifFalse: [self class zapOrganization]! !!ClassDescription methodsFor: 'compiling' stamp: 'sw 8/21/97 00:26'!compile: text classified: category notifying: requestor	| stamp |	stamp _ self acceptsLoggingOfCompilation ifTrue: [Utilities changeStamp] ifFalse: [nil].	^ self compile: text classified: category		withStamp: stamp notifying: requestor ! !!ClassDescription methodsFor: 'compiling' stamp: 'tk 12/6/97 21:30'!compile: text classified: category withStamp: changeStamp notifying: requestor 	| selector priorMethod method methodNode |	method _ self		compile: text asString		notifying: requestor		trailer: #(0 0 0 0)		ifFail: [^nil]		elseSetSelectorAndNode: 			[:sel :node | selector _ sel.			priorMethod _ methodDict at: selector ifAbsent: [nil].			methodNode _ node].	self acceptsLoggingOfCompilation ifTrue:		[method putSource: text				fromParseNode: methodNode				class: self category: category withStamp: changeStamp 				inFile: 2 priorMethod: priorMethod].	self organization classify: selector under: category.	^selector! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 12/29/97 13:11'!classComment: aString	"Store the comment, aString or Text or RemoteString, associated with the class we are orgainzing.  Empty string gets stored only if had a non-empty one before."	| ptr header file oldCommentRemoteStr |	(aString isKindOf: RemoteString) ifTrue: [^ organization classComment: aString].	oldCommentRemoteStr _ organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file _ SourceFiles at: 2) ifNotNil: [		file setToEnd; cr; nextPut: $!!.	"directly"		"Should be saying (file command: 'H3') for HTML, but ignoring it here"		header _ String streamContents: [:strm | strm nextPutAll: self name;			nextPutAll: ' commentStamp: '.			Utilities changeStamp storeOn: strm.			strm nextPutAll: ' prior: '; nextPutAll: ptr printString].		file nextChunkPut: header]].	organization classComment: (RemoteString newString: aString onFileNumber: 2).	Smalltalk changes commentClass: self.	! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 12/13/97 14:20'!commentFollows 	"Answer a ClassCommentReader who will scan in the comment."	^ ClassCommentReader new setClass: self category: #Comment	"False commentFollows inspect"! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 12/13/97 14:21'!commentStamp: changeStamp prior: indexAndOffset	"Prior source link ignored when filing in."	^ ClassCommentReader new setClass: self				category: #Comment				changeStamp: changeStamp! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 10:06'!fileOutCategory: catName 	^ self fileOutCategory: catName asHtml: false! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 10:05'!fileOutCategory: catName asHtml: useHtml	"FileOut the named category, possibly in Html format."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: self name , '-' , catName , '.html') asHtml]		ifFalse: [FileStream newFileNamed: self name , '-' , catName , '.st'].	fileStream header; timeStamp.	self fileOutCategory: catName on: fileStream moveSource: false toFile: 0.	fileStream trailer; close! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/27/97 05:27'!fileOutCategory: aString on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the receiver's category, aString, onto aFileStream. If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.sources file, and should only write one preamble per method category."	aFileStream cr.	moveSource ifTrue:		["Single header for condensing source files"		self printCategoryChunk: aString on: aFileStream].	(self organization listAtCategoryNamed: aString)		do: [:sel | self printMethodChunk: sel withPreamble: moveSource not						on: aFileStream moveSource: moveSource toFile: fileIndex].	moveSource ifTrue: [aFileStream nextChunkPut: ' ']! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/26/97 21:41'!fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the messages of this class that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.changes file, and should only write a preamble for every method."	| org sels |	(org _ self organization) categories do: 		[:cat | 		sels _ (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].		sels do:			[:sel |  self printMethodChunk: sel withPreamble: true on: aFileStream							moveSource: moveSource toFile: fileIndex]]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 15:52'!fileOutMethod: selector	"Write source code of a single method on a file.  Make up a name for the file."	self fileOutMethod: selector asHtml: false! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 15:51'!fileOutMethod: selector asHtml: useHtml	"Write source code of a single method on a file in .st or .html format"	| fileStream nameBody |	(self includesSelector: selector) ifFalse: [^ self halt: 'Selector not found'].	nameBody _ self name , '-' , (selector copyReplaceAll: ':' with: '').	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: nameBody , '.html') asHtml]		ifFalse: [FileStream newFileNamed: nameBody , '.st'].	fileStream header; timeStamp.	self printMethodChunk: selector withPreamble: true		on: fileStream moveSource: false toFile: 0.	fileStream close! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 1/15/98 23:38'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex	"File a description of the receiver on aFileStream. If the boolean 	argument, moveSource, is true, then set the trailing bytes to the position 	of aFileStream and to fileIndex in order to indicate where to find the 	source code."	aFileStream command: 'H3'.		aFileStream nextChunkPut: self definition.		aFileStream command: '/H3'.	self organization		putCommentOnFile: aFileStream		numbered: fileIndex		moveSource: moveSource		forClass: self.	self organization categories do: 		[:heading |		self fileOutCategory: heading			on: aFileStream			moveSource: moveSource			toFile: fileIndex]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 20:35'!fileOutOrganizationOn: aFileStream	"File a description of the receiver's organization on aFileStream."	aFileStream cr; nextPut: $!!.	aFileStream nextChunkPut: self name, ' reorganize'; cr.	aFileStream nextChunkPut: self organization printString; cr! !!ClassDescription methodsFor: 'fileIn/Out' stamp: '6/5/97 di'!methods	"Answer a ClassCategoryReader for compiling messages that are not classified, as in fileouts made with Smalltalk/V"	^ ClassCategoryReader new setClass: self							category: 'as yet unclassified' asSymbol! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 12/29/97 13:00'!methodsFor: categoryName 	"Answer a ClassCategoryReader for compiling the messages in the category, categoryName, of the receiver."	^ ClassCategoryReader new setClass: self category: categoryName asSymbol	"(False methodsFor: 'logical operations') inspect"! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/13/97 13:51'!methodsFor: categoryName stamp: changeStamp 	^ self methodsFor: categoryName stamp: (Utilities fixStamp: changeStamp) prior: 0! !!ClassDescription methodsFor: 'fileIn/Out' stamp: '6/5/97 di'!methodsFor: categoryName stamp: changeStamp prior: indexAndOffset	"Prior source link ignored when filing in."	^ ClassCategoryReader new setClass: self				category: categoryName asSymbol				changeStamp: changeStamp! !!ClassDescription methodsFor: 'fileIn/Out' stamp: '6/5/97 di'!printCategoryChunk: categoryName on: aFileStream	^ self printCategoryChunk: categoryName withStamp: '' on: aFileStream! !!ClassDescription methodsFor: 'fileIn/Out' stamp: '6/5/97 di'!printCategoryChunk: category on: aFileStream priorMethod: priorMethod	^ self printCategoryChunk: category on: aFileStream		withStamp: Utilities changeStamp priorMethod: priorMethod! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 6/26/97 11:51'!printCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod	"Print a method category preamble.  This must have a category name.	It may have an author/date stamp, and it may have a prior source link.	If it has a prior source link, it MUST have a stamp, even if it is empty.""The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."	aFileStream cr; command: 'H3'; nextPut: $!!.	aFileStream nextChunkPut: (String streamContents:		[:strm |		strm nextPutAll: self name; nextPutAll: ' methodsFor: '; print: category asString.		(changeStamp size > 0 or: [priorMethod ~~ nil]) ifTrue:			[strm nextPutAll: ' stamp: '; print: changeStamp].		priorMethod ~~ nil ifTrue:			[strm nextPutAll: ' prior: '; print: priorMethod sourcePointer]]).	aFileStream command: '/H3'.! !!ClassDescription methodsFor: 'fileIn/Out' stamp: '6/6/97 di'!printCategoryChunk: categoryName withStamp: changeStamp on: aFileStream	^ self printCategoryChunk: categoryName on: aFileStream withStamp: changeStamp		priorMethod: nil! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 12/15/97 15:01'!printMethodChunk: selector withPreamble: doPreamble on: outStream		moveSource: moveSource toFile: fileIndex	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method oldPos newPos sourceFile |	doPreamble 		ifTrue: [preamble _ self name , ' methodsFor: ' ,					(self organization categoryOfElement: selector) asString printString]		ifFalse: [preamble _ ''].	method _ methodDict at: selector.	((method fileIndex = 0		or: [(SourceFiles at: method fileIndex) == nil])		or: [(oldPos _ method filePosition) = 0])		ifTrue:		["The source code is not accessible.  We must decompile..."		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].		outStream nextChunkPut: (self decompilerClass new decompile: selector											in: self method: method) decompileString]		ifFalse:		[sourceFile _ SourceFiles at: method fileIndex.		sourceFile position: oldPos.		preamble size > 0 ifTrue:    "Copy the preamble"			[outStream copyPreamble: preamble from: sourceFile].		"Copy the method chunk"		newPos _ outStream position.		outStream copyMethodChunkFrom: sourceFile.		sourceFile skipSeparators.	"The following chunk may have ]style["		sourceFile peek == $] ifTrue: [			outStream cr; copyMethodChunkFrom: sourceFile].		moveSource ifTrue:    "Set the new method source pointer"			[method setSourcePosition: newPos inFile: fileIndex]].	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].	^ outStream cr.! !!ClassDescription methodsFor: 'fileIn/Out'!reformatMethodAt: selector 	| newCodeString method | 	newCodeString _ (self compilerClass new)		format: (self sourceCodeAt: selector)		in: self		notifying: nil.	method _ self compiledMethodAt: selector.	method		putSource: newCodeString		fromParseNode: nil		class: self		category: (self organization categoryOfElement: selector)		inFile: 2 priorMethod: method! !!ClassDescription methodsFor: 'private'!spaceUsed	"Answer a rough estimate of number of bytes in this class and its metaclass"	| space method |	space _ 0.	self selectorsDo:		[:sel | space _ space + 16.  "dict and org'n space"		method _ self compiledMethodAt: sel.		space _ space + (method size + 6 "hdr + avg pad").		method literals do:			[:lit | ((lit isMemberOf: Symbol) or: [lit isMemberOf: SmallInteger]) ifFalse:				[(lit isMemberOf: String) ifTrue: [space _ space + (lit size+6)].				(lit isMemberOf: Array) ifTrue: [space _ space + (lit size+1*4)]]]].	(self isMemberOf: Metaclass)		ifTrue: [^ space]		ifFalse: [^ space + self class space]! !ClassListBrowser comment:'A browser on an arbitrary list of classes.  It holds on to a classListGenerator, a block which will generate a clean class list when required.  12/6/96 sw'!!ClassListBrowser methodsFor: 'everything' stamp: 'sw 12/6/96'!classListGenerator: generatorBlock	"Initialize the receiver such that it obtains its class list from generatorBlock.  "	classListGenerator _ generatorBlock.	classList _ generatorBlock value! !!ClassListBrowser methodsFor: 'everything'!updateSystemCategories	"The class categories were changed in another browser. The receiver must 	reorganize its lists based on these changes."	self okToChange ifFalse: [^ self].	self systemCategoryListIndex: 0.	classList _ classListGenerator value.	self changed: #classListChanged.	self changed: #systemCategoriesChanged! !!ClassListController methodsFor: 'menu messages' stamp: 'di 10/17/97 14:40'!browseUnusedMethods	"Request a browser of methods that are not accessible."	self controlTerminate.	model browseUnusedMethods.	self controlInitialize! !!ClassListController methodsFor: 'menu messages' stamp: 'di 6/28/97 20:28'!fileOut	"Print a description of the selected class onto an external file in .st format."	self controlTerminate.	Cursor write showWhile:		[model fileOutClass].	self controlInitialize! !!ClassListController methodsFor: 'menu messages' stamp: 'di 6/28/97 20:27'!printOut	"Print a description of the selected class onto an external file in HTML format."	self controlTerminate.	Cursor write showWhile:		[model printOutClass].	self controlInitialize! !!ClassListController methodsFor: 'menu messages'!spawnHierarchy        "Request that the receiver's view display the class hierarchy (super- and         subclasses) of the selected class so that it can be edited."        self controlTerminate.        model spawnHierarchy.        self controlInitialize! !!ClassListController methodsFor: 'menu messages'!spawnProtocol        "Request that the receiver's model open a protocol browser."        self controlTerminate.        model spawnProtocol.        self controlInitialize! !!ClassListController class methodsFor: 'class initialization' stamp: 'di 10/17/97 14:39'!initialize        "Initialize the yellow button menu information.         2/1/96 sw: added class vars         7/29/96 sw: added 'find method' feature        11/11/96 stp: added spawn protocol and separated show/spawn hierarchy        : added recent classes feature	   : recent classes feature moved to system category-list pane"                ClassListYellowButtonMenu :=                PopUpMenu                                 labels: 'browse classprintOutfileOuthierarchydefinitioncommentspawn hierarchyspawn protocolinst var refs..inst var defs..class var refs...class varsclass refsrename...removeunsent methodsfind method...'                                 lines: #(3 6 8 10 13 16).        ClassListYellowButtonMessages :=                 #(browse  printOut fileOut                hierarchy definition comment                spawnHierarchy spawnProtocol                browseInstVarRefs browseInstVarDefs browseClassVarRefs classVariables browseClassRefs                rename remove browseUnusedMethods findMethod)        "        ClassListController initialize.        ClassListController allInstancesDo:                [:x | x initializeYellowButtonMenu].        "! !!ClassOrganizer methodsFor: 'accessing' stamp: 'tk 9/30/97 11:00'!changeFromString: aString 	"Parse the argument, aString, and make this be the receiver's structure."	| scanner oldElements newElements newCategories newStops currentStop anArray temp ii cc |	scanner _ Scanner new scanTokens: aString.	"If nothing was scanned and I had no elements before, then default me"	(scanner size = 0 and: [elementArray size = 0])		ifTrue: [^self setDefaultList: Array new].	oldElements _ elementArray asSet.	newCategories _ Array new: scanner size.	newStops _ Array new: scanner size.	currentStop _ 0.	newElements _ WriteStream on: (Array new: 16).	1 to: scanner size do: 		[:i | 		anArray _ scanner at: i.		newCategories at: i put: anArray first asSymbol.		anArray allButFirst asSortedCollection do:			[:elem |			(oldElements remove: elem ifAbsent: [nil]) notNil ifTrue:				[newElements nextPut: elem.				currentStop _ currentStop+1]].		newStops at: i put: currentStop].	"Ignore extra elements but don't lose any existing elements!!"	oldElements _ oldElements collect:		[:elem | Array with: (self categoryOfElement: elem) with: elem].	newElements _ newElements contents.	categoryArray _ newCategories.	(cc _ categoryArray asSet) size = categoryArray size ifFalse: ["has duplicate element"		temp _ categoryArray asOrderedCollection.		temp removeAll: categoryArray asSet asOrderedCollection.		temp do: [:dup | 			ii _ categoryArray indexOf: dup.			[dup _ (dup,' #2') asSymbol.  cc includes: dup] whileTrue.			cc add: dup.			categoryArray at: ii put: dup]].	categoryStops _ newStops.	elementArray _ newElements.	oldElements do: [:pair | self classify: pair last under: pair first].! !!ClassOrganizer methodsFor: 'accessing' stamp: 'tk 12/12/97 13:32'!classComment	"Answer the comment associated with the object that refers to the 	receiver."	globalComment == nil ifTrue: [^''].	^globalComment text! !!ClassOrganizer methodsFor: 'accessing' stamp: 'tk 12/16/97 07:44'!classComment: aString 	"Store the comment, aString, associated with the object that refers to the 	receiver."	(aString isKindOf: RemoteString) 		ifTrue: [globalComment _ aString]		ifFalse: [aString size = 0			ifTrue: [globalComment _ nil]			ifFalse: [				self error: 'use aClass classComment:'.				globalComment _ RemoteString newString: aString onFileNumber: 2]]				"Later add priorSource and date and initials?"! !!ClassOrganizer methodsFor: 'accessing' stamp: 'tk 12/15/97 14:41'!commentRemoteStr	^ globalComment! !!ClassOrganizer methodsFor: 'compiler access'!classify: element under: heading 	"Store the argument, element, in the category named heading."	| catName catIndex elemIndex realHeading |	heading = NullCategory		ifTrue: [realHeading _ Default]		ifFalse: [realHeading _ heading asSymbol].	(catName _ self categoryOfElement: element) = realHeading		ifTrue: [^self].  "done if already under that category"	catName ~~ nil ifTrue: 		[realHeading = Default			ifTrue: [^self].	"return if exists and realHeading is default"		self removeElement: element].	"remove if in another category"	(categoryArray indexOf: realHeading) = 0 ifTrue: [self addCategory: realHeading].	"add realHeading if not there already"	catIndex _ categoryArray indexOf: realHeading.	elemIndex _ 		catIndex > 1			ifTrue: [categoryStops at: catIndex - 1]			ifFalse: [0].	[(elemIndex _ elemIndex + 1) <= (categoryStops at: catIndex) 		and: [element >= (elementArray at: elemIndex)]] whileTrue.	"elemIndex is now the index for inserting the element. Do the insertion before it."	elementArray _ elementArray copyReplaceFrom: elemIndex to: elemIndex-1						with: (Array with: element).	"add one to stops for this and later categories"	catIndex to: categoryArray size do: 		[:i | categoryStops at: i put: (categoryStops at: i) + 1].	(self listAtCategoryNamed: Default) size = 0 ifTrue: [self removeCategory: Default]! !!ClassOrganizer methodsFor: 'method dictionary'!addCategory: catString before: nextCategory	"Add a new category named heading.	If default category exists and is empty, remove it.	If nextCategory is nil, then add the new one at the end,	otherwise, insert it before nextCategory."	| index newCategory |	newCategory _ catString asSymbol.	(categoryArray indexOf: newCategory) > 0		ifTrue: [^self].	"heading already exists, so done"	index _ categoryArray indexOf: nextCategory		ifAbsent: [categoryArray size + 1].	categoryArray _ categoryArray		copyReplaceFrom: index		to: index-1		with: (Array with: newCategory).	categoryStops _ categoryStops		copyReplaceFrom: index		to: index-1		with: (Array with: (index = 1				ifTrue: [0]				ifFalse: [categoryStops at: index-1])).	"remove empty default category"	(newCategory ~= Default			and: [(self listAtCategoryNamed: Default) isEmpty])		ifTrue: [self removeCategory: Default]! !!ClassOrganizer methodsFor: 'method dictionary'!removeCategory: cat 	"Remove the category named, cat. Create an error notificiation if the 	category has any elements in it."	| index lastStop |	index _ categoryArray indexOf: cat ifAbsent: [^self].	lastStop _ 		index = 1			ifTrue: [0]			ifFalse: [categoryStops at: index - 1].	(categoryStops at: index) - lastStop > 0 		ifTrue: [^self error: 'cannot remove non-empty category'].	categoryArray _ categoryArray copyReplaceFrom: index to: index with: Array new.	categoryStops _ categoryStops copyReplaceFrom: index to: index with: Array new.	categoryArray size = 0		ifTrue:			[categoryArray _ Array with: Default.			categoryStops _ Array with: 0]! !!ClassOrganizer methodsFor: 'fileIn/Out' stamp: 'tk 12/12/97 13:56'!moveChangedCommentToFile: aFileStream numbered: sourceIndex 	"This is part of source code compression. Move the comment about the 	class classified by the receiver from the file referenced by sourceIndex 	and to the stream, aFileStream."	(globalComment ~~ nil and: [globalComment sourceFileNumber > 1])		ifTrue: 			[aFileStream cr; cr.			globalComment _ 				RemoteString					newString: globalComment text					onFileNumber: sourceIndex					toFile: aFileStream]! !!ClassOrganizer methodsFor: 'fileIn/Out' stamp: 'sw 1/15/98 23:37'!putCommentOnFile: aFileStream numbered: sourceIndex moveSource: moveSource forClass: aClass	"Store the comment about the class onto file, aFileStream."	| commentRemoteStr header |	commentRemoteStr _ aClass organization commentRemoteStr.	commentRemoteStr ifNotNil:		[aFileStream cr; nextPut: $!!.		"Should be saying (file command: 'H3') for HTML, but ignoring it here (tck's note)"		header _ String streamContents: [:strm | 				strm nextPutAll: aClass name;				nextPutAll: ' commentStamp: '.				Utilities changeStamp storeOn: strm.				strm nextPutAll: ' prior: '; nextPutAll: '0'].		aFileStream nextChunkPut: header; cr.		RemoteString newString: commentRemoteStr text				onFileNumber: nil				toFile: aFileStream.		aFileStream cr]! !!ClassOrganizer methodsFor: 'fileIn/Out' stamp: 'di 1/13/98 16:57'!scanFrom: aStream	"Reads in the organization from the next chunk on aStream.	Categories or elements not found in the definition are not affected.	New elements are ignored."	self changeFromString: aStream nextChunk.	aStream skipStyleChunk.! !!ClassOrganizer methodsFor: 'private' stamp: 'tk 12/16/97 07:35'!setDefaultList: aSortedCollection	self classComment: ''.	categoryArray _ Array with: Default.	categoryStops _ Array with: aSortedCollection size.	elementArray _ aSortedCollection asArray! !!Clink methodsFor: 'as yet unclassified' stamp: 'jm 10/9/97 04:52'!initialize	super initialize.	sound _ SampledSound		samples: #(0 11 5 18 42 35 28 54 42 59 52 44 16 18 33 6 -39 -30 -39 -37 -61 -61 -55 -83 -71 -42 -66 -45 -61 -40 -22 1 -3 33 61 69 44 59 59 64 44 81 62 79 91 62 45 55 1 -8 -10 -1 -16 -33 -20 -57 -54 -18 10 5 -1 -6 25 62 47 49 79 52 20 50 76 94 74 91 100 94 69 67 76 76 44 71 62 64 91 93 96 113 93 125 120 108 76 67 79 54 79 69 64 83 37 39 35 6 -13 -57 -62 -52 -79 -94 -100 -78 -105 -101 -59 -69 -64 -25 -55 -33 -57 -33 -39 -33 -16 -16 -16 -30 -25 -1 -27 -32 -39 -44 -1 -18 -23 -61 -55 -45 -67 -74 -47 -23 -22 -55 -50 -18 -47 -39 -22 -32 -28 -45 -28 -50 -69 -83 -83 -66 -93 -84 -74 -74 -84 -76 -94 -52 -69 -62 -35 -3 11 -16 28 5 -10 0 3 25 -1 20 32 25 44 59 18 11 -32 0 -11 -28 -55 -67 -62 -64 -57 -49 -76 -239 -980 -1731 -1565 -478 1153 2646 2919 1799 -1385 -5482 -8325 -8427 -4347 2556 9606 13864 12797 7894 731 -6395 -9218 -6222 1491 9207 12724 10783 3258 -6050 -12631 -14020 -9175 -454 8771 14419 13457 7050 -1679 -8875 -11346 -7670 960 10478 16383 15908 10112 2191 -5150 -8398 -6123 644 8334 12364 11062 5163 -2966 -9760 -12327 -9012 -1947 4977 8880 8495 4412 -1704 -6697 -7935 -5491 -186 5557 9289 9235 4955 -819 -4990 -5843 -3005 2128 7204 9606 7728 2439 -3872 -8469 -9930 -7226 -1385 4532 7567 6452 2154 -3136 -7248 -8045 -4493 1794 7582 10089 8636 3994 -1994 -6473 -7257 -3774 1894 6760 9011 7177 1979 -4364 -8760 -9067 -5465 332 5596 7764 5742 284 -5345 -8517 -7840 -3480 2838 8592 10639 7918 2485 -3435 -7177 -7341 -3630 2542 7333 8449 5514 15 -5645 -9192 -8368 -3540 3111 8083 9218 6558 941 -5119 -8500 -7748 -2905 3329 8259 9891 6975 1192 -4921 -8285 -7411 -3123 3090 7961 9206 5967 -130 -5728 -8793 -7886 -3061 3637 8965 9864 6471 683 -5121 -8324 -7547 -2720 3679 8050 8714 5236 -373 -6032 -9138 -7679 -2653 3679 8166 8982 5906 -111 -5825 -8561 -7094 -2091 3874 8412 9128 5533 -361 -5918 -8320 -6939 -2222 4016 8376 8831 4987 -943 -6130 -8678 -7102 -2117 4149 8322 8296 4768 -744 -5827 -8144 -6444 -1172 4732 8463 8412 4659 -1111 -6519 -8782 -6838 -1876 3818 7423 7601 3966 -1852 -6722 -8505 -6354 -1297 4366 8266 8217 4386 -1206 -5891 -7589 -5647 -595 5092 8402 7645 3372 -2274 -7031 -8958 -6814 -1560 4329 7654 7123 3477 -1869 -6393 -7899 -5367 88 5572 8632 8001 3994 -1711 -6441 -7793 -5287 -393 4497 7216 6430 2176 -3494 -7572 -8412 -5660 -476 4873 7782 6690 2393 -2805 -6588 -7323 -4649 614 5879 8327 6904 2609 -2773 -6848 -7927 -5150 117 5087 7272 5923 1730 -3616 -7575 -8117 -4951 332 5082 7314 6100 1716 -3587 -7162 -7338 -4064 1063 5860 7922 6178 1477 -3845 -7267 -7575 -4571 537 5260 7199 5292 826 -4115 -7486 -7689 -4446 938 5637 7201 5421 1063 -3815 -7109 -7141 -3667 1448 5660 6990 4983 519 -4622 -7833 -7543 -3996 1080 5323 6922 5028 385 -4480 -7416 -7070 -3789 1145 5533 6878 4693 40 -4734 -7506 -7268 -3827 1353 5650 6756 4347 -161 -4821 -7581 -7051 -3301 1993 5847 6707 4347 -198 -4888 -7582 -6814 -2926 2076 5860 6719 4339 -313 -5104 -7557 -6685 -2960 1915 5679 6573 3945 -814 -5333 -7572 -6588 -2787 2269 6052 6597 3789 -877 -5189 -7406 -6525 -2636 2447 5996 6307 3497 -1070 -5450 -7609 -6463 -2340 2658 5945 6230 3482 -1158 -5519 -7458 -5949 -1767 3039 6341 6612 3603 -1267 -5625 -7343 -5857 -1774 3033 6279 6346 3156 -1653 -5721 -7357 -5877 -1742 3158 6256 6039 2848 -1752 -5721 -7285 -5643 -1223 3635 6464 6159 2960 -1731 -5771 -7229 -5280 -936 3662 6266 5823 2488 -2386 -6329 -7457 -5362 -1044 3521 6339 5962 2564 -2183 -5850 -6875 -4841 -536 4120 6763 6062 2488 -2111 -5681 -6838 -4873 -605 3845 6190 5268 1777 -2759 -6413 -7419 -5162 -680 3692 5964 5234 1888 -2556 -5979 -6624 -4157 242 4497 6702 5860 2200 -2597 -6054 -6732 -4381 -111 4183 6330 5153 1346 -3170 -6430 -7031 -4688 -198 4213 6335 5180 1519 -2753 -5777 -6198 -3531 958 5024 6619 5234 1523 -3048 -6295 -6753 -4157 137 3986 5665 4412 788 -3545 -6449 -6469 -3735 539 4539 6246 4921 1172 -3100 -5918 -6010 -3352 905 4800 6313 4702 865 -3363 -6118 -6254 -3609 753 4529 5842 4178 466 -3628 -6305 -6174 -3231 1195 4854 6112 4497 715 -3550 -6183 -5972 -3043 1265 4843 6030 4203 264 -3915 -6352 -5945 -2961 1328 4907 6001 4025 50 -3949 -6240 -5808 -2731 1620 5085 5932 3872 5 -3961 -6174 -5640 -2408 1971 5204 5806 3587 -347 -4320 -6493 -5674 -2252 2103 5245 5818 3709 -300 -4249 -6215 -5309 -2066 2078 5077 5591 3262 -809 -4558 -6335 -5384 -2111 2062 5097 5460 3022 -951 -4570 -6283 -5192 -1733 2491 5348 5475 3024 -912 -4546 -6217 -5077 -1557 2597 5245 5301 2785 -1263 -4934 -6522 -5226 -1716 2385 5104 5206 2680 -1328 -4860 -6276 -4933 -1472 2549 5211 5238 2602 -1389 -4778 -6118 -4834 -1379 2664 5109 4880 2156 -1731 -5007 -6259 -4754 -1121 2883 5297 4973 2318 -1620 -4939 -6086 -4395 -697 3187 5426 5082 2242 -1738 -5026 -6037 -4332 -754 3012 5156 4665 1777 -2237 -5294 -6125 -4310 -676 3177 5313 4707 1704 -2171 -5167 -5962 -4134 -434 3307 5221 4456 1421 -2371 -5287 -5974 -3954 -188 3542 5297 4424 1389 -2456 -5362 -5854 -3667 161 3709 5435 4476 1255 -2671 -5472 -5828 -3589 215 3804 5409 4402 1138 -2724 -5324 -5599 -3384 378 3901 5396 4091 868 -2871 -5385 -5572 -3270 525 3884 5155 3828 575 -3119 -5518 -5503 -2994 826 4095 5277 3886 615 -3100 -5348 -5202 -2603 1202 4405 5579 4064 602 -3109 -5419 -5272 -2790 899 4067 5100 3521 122 -3477 -5592 -5270 -2585 1314 4537 5531 3905 485 -3089 -5226 -4956 -2347 1443 4476 5236 3463 11 -3604 -5711 -5257 -2473 1341 4363 5141 3385 -28 -3584 -5504 -4973 -2164 1586 4456 5218 3413 -64 -3496 -5321 -4707 -1969 1721 4571 5109 3195 -329 -3723 -5474 -4821 -1969 1776 4503 4921 2919 -522 -3845 -5506 -4654 -1676 2057 4687 5036 3068 -415 -3721 -5323 -4408 -1430 2169 4614 4882 2788 -695 -3915 -5313 -4337 -1396 2132 4519 4702 2544 -905 -3866 -5124 -3993 -988 2586 4865 4841 2573 -877 -3859 -5050 -3949 -902 2556 4668 4510 2223 -1141 -4108 -5170 -3808 -703 2720 4719 4553 2271 -1131 -3972 -4907 -3489 -390 2919 4890 4537 2088 -1385 -4154 -4934 -3447 -337 2949 4792 4325 1743 -1562 -4181 -4856 -3273 -33 3316 5041 4439 1923 -1424 -3959 -4570 -2910 317 3423 4907 4088 1355 -2054 -4624 -5056 -3187 140 3307 4809 4030 1323 -2069 -4432 -4695 -2724 597 3694 5114 4179 1360 -1966 -4229 -4478 -2602 675 3715 5019 3932 1027 -2281 -4537 -4753 -2714 656 3687 4919 3859 1085 -2127 -4312 -4403 -2332 965 3786 4910 3750 882 -2391 -4437 -4402 -2254 933 3703 4646 3397 396 -2761 -4724 -4539 -2305 980 3754 4756 3469 590 -2468 -4317 -4120 -1871 1389 4050 4788 3321 318 -2715 -4503 -4201 -1837 1438 4025 4685 3201 220 -2892 -4629 -4167 -1665 1653 4171 4763 3180 93 -2975 -4602 -4015 -1499 1777 4212 4668 2927 -195 -3214 -4712 -4027 -1443 1877 4278 4609 2759 -451 -3440 -4853 -4093 -1385 1983 4334 4570 2726 -405 -3326 -4680 -3794 -1068 2210 4410 4547 2595 -554 -3460 -4715 -3725 -987 2203 4300 4352 2317 -875 -3669 -4760 -3687 -941 2237 4312 4330 2291 -778 -3453 -4486 -3475 -775 2271 4218 4105 1969 -1070 -3682 -4656 -3518 -661 2424 4262 4018 1854 -1197 -3718 -4505 -3141 -252 2809 4564 4264 2067 -1039 -3611 -4369 -3028 -201 2761 4427 4040 1772 -1318 -3740 -4352 -2907 -52 2939 4553 4008 1657 -1414 -3784 -4364 -2858 71 3089 4629 4098 1794 -1219 -3535 -4025 -2500 373 3224 4571 3896 1487 -1553 -3828 -4269 -2661 281 3126 4547 3891 1552 -1413 -3640 -3989 -2363 529 3341 4719 4010 1545 -1452 -3640 -3988 -2305 653 3467 4729 3866 1292 -1740 -3849 -4091 -2325 671 3436 4602 3716 1219 -1733 -3760 -3867 -1994 1031 3708 4758 3730 1100 -1925 -3891 -3898 -1938 1044 3640 4625 3557 921 -2020 -3859 -3776 -1813 1116 3687 4617 3465 815 -2079 -3828 -3713 -1708 1263 3759 4544 3307 641 -2169 -3855 -3674 -1608 1362 3750 4410 3090 425 -2383 -4022 -3725 -1533 1491 3835 4488 3167 390 -2378 -3928 -3509 -1257 1728 4013 4573 3123 286 -2473 -3894 -3404 -1080 1884 4078 4466 2853 -5 -2678 -4035 -3440 -1097 1857 3996 4295 2678 -137 -2821 -4118 -3421 -983 1959 4054 4283 2648 -196 -2873 -4054 -3273 -751 2161 4159 4334 2556 -320 -2965 -4064 -3201 -743 2176 4144 4225 2424 -491 -2999 -4011 -3065 -524 2366 4218 4166 2266 -527 -3007 -3950 -2995 -441 2446 4186 4011 2055 -793 -3221 -4122 -3048 -497 2269 3910 3759 1847 -951 -3318 -4032 -2861 -261 2461 4044 3777 1764 -1048 -3282 -3888 -2595 8 2720 4200 3747 1609 -1195 -3413 -4006 -2727 -94 2586 4001 3501 1396 -1321 -3396 -3835 -2456 164 2756 3984 3385 1253 -1458 -3540 -3889 -2427 161 2654 3835 3194 978 -1743 -3638 -3838 -2295 322 2819 3964 3211 939 -1698 -3550 -3689 -2147 446 2883 3884 3016 726 -1901 -3667 -3765 -2123 530 2870 3745 2848 568 -2028 -3721 -3652 -1884 743 3014 3804 2827 478 -2144 -3779 -3686 -1910 685 2910 3669 2636 249 -2295 -3828 -3676 -1867 787 3011 3681 2564 169 -2269 -3684 -3424 -1508 1109 3282 3789 2575 134 -2334 -3779 -3482 -1543 1073 3099 3608 2339 -127 -2620 -3944 -3519 -1525 1092 3151 3535 2273 -193 -2580 -3787 -3318 -1296 1326 3309 3652 2234 -256 -2634 -3888 -3409 -1348 1282 3204 3491 2125 -346 -2666 -3811 -3204 -1114 1441 3253 3462 2008 -432 -2714 -3692 -3007 -861 1662 3399 3499 1940 -547 -2821 -3765 -2983 -854 1648 3346 3394 1743 -761 -2958 -3849 -3087 -822 1676 3304 3282 1636 -822 -2963 -3772 -2878 -644 1835 3375 3296 1599 -831 -2924 -3667 -2702 -446 1998 3489 3307 1604 -885 -2949 -3667 -2658 -408 1984 3421 3207 1407 -1005 -3028 -3592 -2493 -223 2183 3519 3168 1323 -1124 -3078 -3621 -2468 -157 2191 3465 3090 1216 -1211 -3123 -3584 -2390 -106 2201 3424 2983 1031 -1414 -3236 -3594 -2278 52 2393 3518 2982 1026 -1372 -3185 -3492 -2174 217 2481 3558 2990 999 -1399 -3104 -3323 -1944 391 2603 3528 2824 765 -1645 -3338 -3516 -2118 259 2439 3404 2700 654 -1716 -3375 -3479 -1952 439 2602 3455 2704 617 -1772 -3360 -3404 -1901 493 2585 3413 2571 442 -1901 -3413 -3358 -1742 676 2719 3458 2583 442 -1862 -3275 -3184 -1514 848 2836 3482 2495 313 -1981 -3404 -3224 -1543 771 2719 3268 2198 22 -2217 -3523 -3218 -1457 934 2870 3380 2242 59 -2137 -3336 -3000 -1255 1077 2880 3290 2110 -83 -2249 -3472 -3087 -1267 1111 2885 3257 2040 -176 -2349 -3455 -3004 -1129 1255 3036 3316 2039 -227 -2339 -3367 -2824 -929 1423 3077 3287 1959 -317 -2425 -3404 -2826 -843 1430 3068 3162 1762 -476 -2500 -3382 -2659 -727 1562 3083 3145 1742 -512 -2522 -3314 -2559 -602 1664 3136 3073 1555 -715 -2690 -3413 -2556 -503 1757 3190 3055 1450 -804 -2731 -3387 -2464 -390 1826 3150 2944 1301 -988 -2887 -3487 -2491 -402 1808 3073 2807 1145 -1095 -2921 -3406 -2352 -208 1950 3141 2802 1072 -1204 -2977 -3394 -2252 -139 2044 3163 2751 988 -1284 -2999 -3350 -2217 -88 2015 3102 2629 783 -1424 -3044 -3346 -2157 -30 2050 2988 2449 636 -1582 -3178 -3411 -2135 33 2055 3016 2424 588 -1604 -3153 -3331 -2032 105 2123 3004 2344 451 -1704 -3204 -3309 -1933 240 2208 3055 2334 446 -1723 -3175 -3231 -1818 359 2308 3090 2346 386 -1787 -3260 -3265 -1820 356 2266 2999 2193 254 -1933 -3348 -3302 -1774 369 2222 2917 2042 49 -2030 -3348 -3221 -1676 551 2424 2995 2054 59 -2069 -3306 -3095 -1494 698 2522 3017 1974 -76 -2184 -3380 -3114 -1440 812 2568 3072 2033 -28 -2128 -3285 -2956 -1228 978 2724 3102 2010 -72 -2132 -3243 -2871 -1197 1016 2712 3029 1879 -193 -2206 -3229 -2775 -1056 1151 2797 3009 1818 -259 -2251 -3228 -2729 -924 1199 2758 2960 1718 -366 -2324 -3206 -2607 -812 1346 2836 2951 1687 -417 -2296 -3068 -2403 -625 1489 2924 2973 1616 -495 -2352 -3067 -2391 -554 1545 2861 2807 1397 -666 -2452 -3170 -2430 -598 1455 2785 2736 1312 -666 -2441 -3082 -2300 -371 1625 2866 2787 1319 -715 -2419 -3014 -2215 -357 1630 2768 2593 1134 -895 -2544 -3051 -2178 -300 1721 2892 2634 1145 -873 -2515 -2951 -2057 -198 1786 2807 2505 988 -1041 -2620 -2987 -2040 -173 1787 2775 2424 878 -1146 -2653 -2960 -1923 -22 1884 2870 2447 839 -1131 -2622 -2897 -1799 150 2027 2955 2466 880 -1138 -2624 -2885 -1730 215 2008 2792 2244 532 -1406 -2788 -2907 -1703 271 2074 2865 2293 571 -1377 -2724 -2844 -1597 359 2159 2905 2247 524 -1426 -2756 -2770 -1526 385 2118 2799 2111 366 -1521 -2792 -2805 -1494 476 2227 2856 2176 419 -1497 -2702 -2664 -1365 576 2242 2846 2050 288 -1597 -2805 -2685 -1346 610 2278 2780 1937 101 -1784 -2922 -2737 -1321 656 2274 2778 1906 101 -1762 -2860 -2610 -1156 798 2368 2831 1903 113 -1745 -2832 -2569 -1114 817 2385 2771 1847 64 -1781 -2734 -2446 -980 972 2488 2827 1830 -37 -1804 -2773 -2381 -854 1075 2529 2805 1762 -115 -1871 -2814 -2424 -863 995 2388 2588 1572 -262 -1977 -2756 -2281 -768 1187 2551 2702 1616 -217 -1921 -2693 -2156 -525 1368 2688 2802 1681 -176 -1843 -2583 -2054 -486 1362 2622 2668 1482 -310 -1964 -2658 -2030 -407 1440 2632 2615 1414 -419 -1998 -2603 -1949 -308 1501 2646 2553 1251 -544 -2111 -2641 -1891 -203 1606 2693 2558 1221 -636 -2152 -2639 -1867 -169 1662 2737 2547 1212 -588 -2088 -2498 -1655 66 1843 2843 2575 1178 -659 -2118 -2500 -1614 84 1874 2810 2476 1056 -807 -2218 -2522 -1633 91 1833 2736 2359 912 -917 -2295 -2539 -1521 210 1962 2793 2374 877 -956 -2273 -2486 -1486 273 1960 2763 2318 846 -924 -2200 -2364 -1294 463 2123 2812 2301 746 -1033 -2281 -2395 -1277 478 2088 2770 2203 668 -1089 -2273 -2325 -1138 593 2156 2782 2140 586 -1177 -2335 -2295 -1131 673 2266 2788 2115 527 -1240 -2337 -2291 -1065 714 2232 2751 2049 415 -1301 -2344 -2203 -912 893 2398 2875 2103 441 -1287 -2285 -2145 -860 919 2373 2787 1955 291 -1384 -2390 -2218 -926 895 2315 2670 1786 118 -1521 -2456 -2156 -763 1043 2485 2775 1905 215 -1428 -2301 -1988 -605 1143 2486 2773 1811 106 -1504 -2330 -1949 -517 1224 2539 2766 1765 -1 -1609 -2354 -1901 -485 1265 2576 2702 1630 -103 -1664 -2429 -1998 -532 1202 2383 2439 1382 -313 -1859 -2522 -1972 -449 1268 2454 2522 1407 -266 -1801 -2391 -1793 -269 1458 2597 2563 1399 -335 -1806 -2393 -1781 -264 1457 2571 2525 1296 -424 -1881 -2419 -1738 -169 1570 2620 2485 1246 -483 -1893 -2373 -1645 -76 1594 2564 2400 1128 -595 -2039 -2476 -1670 -79 1582 2556 2366 1092 -661 -2010 -2352 -1514 42 1745 2668 2398 1085 -602 -1954 -2271 -1428 161 1794 2649 2296 1000 -680 -1991 -2286 -1416 208 1781 2580 2232 882 -783 -2025 -2223 -1270 357 1925 2659 2237 856 -861 -2084 -2254 -1331 264 1833 2527 2105 724 -924 -2098 -2169 -1211 463 2013 2658 2137 717 -951 -2037 -2125 -1067 580 2088 2704 2156 712 -922 -1998 -2030 -975 687 2101 2625 2033 553 -1068 -2105 -2113 -992 614 2054 2544 1925 393 -1209 -2193 -2120 -978 659 2095 2553 1852 371 -1175 -2167 -2055 -907 712 2117 2532 1833 351 -1221 -2191 -2064 -904 722 2089 2497 1755 251 -1306 -2191 -1996 -809 793 2079 2441 1687 159 -1350 -2232 -1959 -717 875 2159 2439 1591 74 -1423 -2210 -1928 -710 904 2117 2327 1511 0 -1455 -2184 -1832 -544 1070 2242 2419 1545 6 -1440 -2161 -1769 -468 1124 2271 2393 1463 -93 -1541 -2206 -1748 -459 1145 2278 2366 1367 -193 -1575 -2225 -1774 -398 1206 2305 2327 1348 -193 -1597 -2240 -1767 -379 1195 2225 2232 1192 -351 -1692 -2218 -1655 -300 1255 2262 2245 1173 -381 -1740 -2223 -1589 -193 1358 2339 2254 1162 -359 -1698 -2137 -1513 -130 1419 2361 2208 1099 -480 -1771 -2242 -1558 -110 1399 2259 2096 965 -566 -1838 -2200 -1501 -69 1440 2279 2064 956 -566 -1796 -2127 -1367 47 1509 2339 2071 854 -666 -1862 -2105 -1321 125 1599 2378 2079 834 -676 -1816 -2062 -1279 167 1625 2349 1998 792 -726 -1860 -2055 -1178 296 1692 2369 1979 714 -802 -1893 -2084 -1211 261 1664 2237 1779 464 -1005 -2033 -2147 -1245 259 1594 2166 1720 434 -1065 -2061 -2095 -1133 371 1750 2251 1742 417 -1055 -2010 -2003 -1033 476 1747 2210 1621 274 -1178 -2098 -2074 -1051 405 1660 2091 1502 145 -1277 -2162 -2062 -1043 446 1704 2091 1430 117 -1302 -2130 -2008 -924 534 1752 2081 1391 6 -1401 -2186 -2016 -924 551 1669 1938 1233 -144 -1443 -2208 -1949 -810 656 1764 2040 1273 -74 -1399 -2100 -1818 -690 741 1816 2006 1199 -137 -1418 -2110 -1808 -673 737 1740 1866 1055 -293 -1597 -2213 -1793 -644 736 1752 1869 1050 -301 -1584 -2159 -1776 -568 810 1796 1871 1005 -364 -1608 -2164 -1706 -534 843 1798 1833 919 -422 -1660 -2137 -1655 -454 917 1830 1784 866 -449 -1647 -2147 -1604 -424 965 1801 1743 821 -566 -1743 -2128 -1562 -305 1000 1820 1704 753 -619 -1781 -2127 -1565 -334 1000 1874 1733 710 -631 -1726 -2074 -1487 -225 1072 1849 1676 690 -670 -1771 -2072 -1409 -150 1134 1842 1630 622 -744 -1801 -2088 -1375 -118 1112 1793 1572 517 -861 -1860 -2061 -1360 -125 1153 1801 1499 435 -863 -1843 -2011 -1287 -15 1250 1871 1496 419 -888 -1866 -2020 -1263 25 1240 1801 1457 354 -941 -1864 -1971 -1153 123 1290 1808 1416 300 -992 -1882 -1974 -1136 101 1265 1735 1287 169 -1145 -2027 -2006 -1172 88 1243 1709 1223 74 -1185 -2022 -1994 -1090 201 1290 1665 1151 -5 -1270 -2037 -1964 -1029 254 1341 1723 1148 -30 -1243 -1998 -1893 -990 313 1404 1692 1116 -88 -1318 -2061 -1901 -966 335 1372 1657 1007 -184 -1409 -2127 -1972 -1012 273 1297 1553 922 -283 -1502 -2195 -1944 -924 359 1353 1581 934 -257 -1472 -2069 -1782 -743 544 1508 1721 1005 -239 -1430 -2013 -1728 -726 568 1513 1687 946 -274 -1453 -2000 -1706 -615 656 1560 1662 916 -303 -1462 -2018 -1660 -619 641 1506 1558 765 -459 -1584 -2078 -1667 -602 614 1463 1504 707 -507 -1609 -2050 -1591 -502 732 1547 1574 746 -434 -1467 -1896 -1414 -320 873 1638 1558 717 -546 -1572 -1920 -1423 -303 914 1626 1499 622 -576 -1601 -1947 -1440 -315 878 1564 1413 497 -700 -1630 -1901 -1340 -235 943 1635 1450 505 -673 -1626 -1838 -1268 -117 1063 1699 1487 566 -598 -1531 -1754 -1133 6 1155 1725 1477 520 -692 -1577 -1721 -1087 50 1187 1782 1497 541 -634 -1526 -1698 -1005 122 1201 1737 1426 424 -741 -1599 -1704 -1051 98 1219 1728 1363 347 -795 -1614 -1650 -910 278 1353 1830 1470 405 -761 -1553 -1575 -782 407 1414 1867 1394 356 -827 -1587 -1589 -810 320 1326 1735 1304 232 -916 -1650 -1601 -790 378 1401 1748 1262 196 -924 -1606 -1538 -720 463 1453 1774 1262 215 -880 -1591 -1465 -619 542 1487 1760 1224 169 -924 -1567 -1379 -486 658 1604 1874 1328 256 -834 -1433 -1297 -476 680 1601 1816 1236 149 -922 -1492 -1307 -434 705 1579 1733 1136 59 -1005 -1540 -1331 -395 756 1616 1789 1146 67 -944 -1440 -1162 -234 897 1698 1796 1162 54 -965 -1433 -1126 -196 909 1742 1826 1116 39 -951 -1385 -1117 -179 985 1740 1777 1100 -3 -973 -1397 -1065 -139 965 1709 1708 1009 -83 -1061 -1492 -1114 -176 914 1630 1640 902 -188 -1100 -1497 -1082 -135 948 1676 1636 887 -137 -1063 -1382 -966 10 1061 1728 1681 890 -196 -1095 -1360 -888 52 1082 1706 1594 775 -300 -1194 -1472 -994 -25 1014 1628 1484 690 -420 -1262 -1480 -1007 -10 1063 1653 1467 631 -413 -1268 -1460 -951 27 1033 1557 1336 508 -544 -1350 -1552 -999 1 1027 1506 1307 486 -568 -1367 -1492 -904 123 1082 1574 1307 437 -602 -1372 -1474 -880 135 1083 1518 1204 320 -717 -1489 -1574 -980 22 965 1401 1092 188 -858 -1536 -1564 -893 120 1029 1372 1038 173 -824 -1484 -1470 -809 225 1095 1435 1063 156 -851 -1492 -1482 -804 189 1075 1357 992 79 -941 -1541 -1513 -817 186 1038 1329 909 -1 -951 -1550 -1487 -776 242 1068 1319 907 -37 -970 -1562 -1433 -703 281 1111 1338 877 -22 -994 -1547 -1382 -646 359 1158 1375 877 -39 -917 -1424 -1279 -513 488 1246 1396 895 -42 -944 -1430 -1251 -444 493 1180 1296 748 -193 -1056 -1523 -1294 -507 471 1189 1294 754 -176 -1068 -1426 -1178 -354 617 1314 1423 832 -137 -1029 -1413 -1138 -379 566 1257 1306 693 -251 -1112 -1494 -1204 -366 595 1224 1217 608 -351 -1167 -1513 -1184 -340 595 1201 1206 551 -368 -1260 -1558 -1240 -403 519 1117 1089 435 -536 -1324 -1623 -1250 -366 575 1173 1122 468 -466 -1309 -1516 -1111 -244 680 1257 1162 486 -441 -1211 -1443 -1011 -161 763 1258 1160 463 -481 -1258 -1414 -955 -105 773 1243 1104 435 -491 -1216 -1382 -949 -118 800 1263 1089 332 -585 -1250 -1363 -926 -47 832 1262 1027 296 -598 -1258 -1368 -829 54 919 1299 1085 378 -515 -1153 -1219 -703 189 997 1391 1145 393 -517 -1141 -1201 -678 213 1036 1363 1104 303 -605 -1216 -1279 -683 193 983 1304 1011 249 -641 -1223 -1251 -646 245 1046 1299 1002 205 -671 -1216 -1173 -554 354 1136 1397 1043 225 -659 -1189 -1133 -498 368 1139 1391 1004 178 -646 -1160 -1056 -478 432 1160 1401 978 161 -653 -1138 -1089 -420 459 1139 1341 927 115 -695 -1170 -1038 -381 468 1148 1316 893 61 -744 -1201 -1061 -376 503 1173 1341 899 49 -731 -1155 -1000 -312 536 1168 1335 853 27 -754 -1167 -983 -279 575 1219 1297 797 -8 -790 -1145 -931 -234 617 1223 1245 737 -89 -863 -1195 -949 -218 617 1167 1202 693 -183 -895 -1216 -951 -220 629 1172 1199 664 -128 -836 -1134 -844 -108 731 1265 1229 659 -157 -860 -1119 -809 -91 734 1240 1178 595 -229 -975 -1194 -870 -111 678 1150 1136 537 -283 -943 -1165 -800 -71 766 1226 1106 520 -271 -924 -1129 -800 -49 785 1221 1072 476 -361 -980 -1162 -753 1 768 1204 1063 415 -364 -994 -1122 -678 83 868 1268 1109 498 -329 -938 -1039 -631 137 880 1234 1009 354 -422 -1041 -1109 -663 72 832 1182 994 335 -478 -1029 -1136 -649 152 885 1234 1004 320 -471 -999 -1044 -539 247 926 1272 1070 373 -381 -939 -987 -490 256 966 1294 1007 305 -461 -972 -963 -469 278 966 1228 927 218 -529 -1044 -1041 -517 264 924 1143 853 105 -632 -1104 -1048 -507 313 943 1143 788 98 -670 -1100 -1019 -429 339 968 1141 822 117 -603 -1002 -907 -334 454 1050 1195 795 96 -612 -1014 -934 -369 412 983 1073 680 -47 -759 -1153 -1021 -419 335 919 1053 697 -15 -724 -1067 -916 -332 420 966 1055 659 -67 -734 -1106 -917 -349 385 929 1034 600 -96 -734 -1029 -885 -217 513 1060 1082 676 -40 -698 -1005 -785 -193 580 1063 1097 670 -45 -707 -1005 -787 -178 512 1029 1016 505 -217 -829 -1094 -827 -196 517 949 944 480 -229 -836 -1041 -753 -135 602 1100 1068 615 -83 -695 -948 -644 27 710 1133 1073 549 -179 -793 -1005 -736 -71 617 1044 990 463 -266 -831 -1017 -680 -45 658 1063 978 430 -245 -815 -944 -624 42 707 1034 910 376 -327 -880 -1014 -653 -55 636 966 812 290 -393 -917 -1022 -612 61 698 1034 902 327 -386 -912 -1005 -598 44 673 1002 838 261 -464 -944 -1053 -661 27 676 949 739 130 -537 -1031 -1097 -687 -18 653 922 690 113 -547 -1036 -1033 -597 105 719 983 751 149 -536 -978 -983 -546 125 737 949 681 79 -573 -1005 -1002 -559 108 720 895 648 28 -653 -1050 -1011 -524 137 681 834 536 -93 -754 -1160 -1085 -624 79 603 758 463 -184 -829 -1189 -1080 -563 79 631 788 434 -178 -809 -1129 -965 -454 201 724 861 497 -139 -724 -1082 -980 -405 227 729 804 430 -206 -814 -1158 -992 -439 218 683 751 351 -264 -890 -1177 -988 -449 159 661 726 356 -295 -904 -1131 -936 -415 242 697 707 301 -307 -870 -1106 -926 -337 296 739 739 356 -300 -829 -1053 -814 -212 407 821 839 378 -268 -829 -1026 -814 -232 361 749 744 274 -366 -910 -1090 -814 -254 347 751 676 184 -402 -924 -1077 -785 -189 419 763 683 240 -354 -885 -1017 -707 -117 481 812 722 290 -296 -793 -919 -590 -15 576 897 805 322 -312 -809 -890 -598 -64 544 839 715 242 -385 -836 -895 -592 10 602 878 765 291 -315 -731 -815 -454 123 707 955 826 300 -291 -717 -775 -434 139 710 973 788 254 -347 -732 -765 -391 189 714 961 776 249 -330 -707 -709 -332 230 736 941 736 196 -398 -783 -805 -408 195 663 838 632 94 -490 -849 -815 -435 162 648 822 607 83 -481 -826 -768 -320 259 731 873 649 135 -429 -734 -664 -247 335 802 921 629 89 -463 -753 -681 -300 247 693 792 513 -27 -566 -838 -714 -315 271 697 798 493 -22 -564 -860 -707 -245 281 722 819 541 -13 -505 -734 -617 -195 390 814 858 539 11 -520 -739 -607 -149 449 815 848 497 -45 -510 -790 -605 -171 369 775 780 461 -103 -603 -809 -639 -189 329 693 687 354 -183 -671 -843 -654 -193 368 739 770 376 -149 -575 -761 -578 -93 452 839 804 403 -134 -568 -726 -508 -45 498 778 773 371 -161 -625 -766 -530 -57 485 824 731 378 -179 -598 -727 -532 -25 502 773 698 291 -212 -670 -790 -546 -83 420 712 608 218 -293 -703 -787 -524 -49 471 739 649 274 -249 -661 -739 -452 57 532 810 710 274 -234 -619 -698 -413 61 558 758 602 169 -351 -732 -798 -517 -28 435 653 493 52 -408 -810 -817 -490 20 525 719 532 89 -407 -780 -804 -474 1 463 656 466 40 -463 -785 -809 -459 22 452 642 493 13 -435 -754 -717 -366 113 541 714 471 33 -456 -773 -748 -429 61 495 625 420 -15 -502 -838 -751 -402 106 500 610 395 -37 -510 -787 -739 -342 157 549 646 427 -20 -463 -734 -670 -290 208 608 709 452 -20 -469 -724 -666 -273 218 622 648 390 -44 -495)		samplingRate: 22050.! !!ClippingMorph methodsFor: 'all'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	^ bounds! !!ClippingMorph methodsFor: 'all'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds."	| clippingCanvas |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self drawOn: aCanvas.	clippingCanvas _ aCanvas copyClipRect: bounds.	submorphs isEmpty ifFalse: [		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]].  "draw back-to-front"! !!ClockMorph methodsFor: 'all'!step	self contents: Time now printString.! !!ClockMorph methodsFor: 'all'!stepTime	"Answer the desired time between steps in milliseconds."	^ 1000! !!CngsClassList methodsFor: 'menu messages' stamp: 'sw 1/15/98 18:59'!classVarRefs	"Browse class var refs for the selected class"	| myClass |	(myClass _ self selectedClassOrMetaClass) notNil ifTrue: 		[myClass browseClassVarRefs]! !!CngsClassList methodsFor: 'menu messages' stamp: 'sw 1/15/98 19:02'!instVarDefs	"Browse inst def refs for the selected class. "	| myClass |	(myClass _ self selectedClassOrMetaClass) notNil ifTrue: 		[myClass browseInstVarDefs]! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 8/12/97 22:59'!browse	controller controlTerminate.	self classAndSelectorDo:		[:cl :sel |  			BrowserView openMessageBrowserForClass: cl selector: sel editString: nil].	controller controlInitialize! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 1/15/98 17:33'!browseAllMessages	"Create and schedule a message set browser on all implementors of all the messages sent by the current method.  Originally conceived and implemented by tck, 1991"	| method filteredList aClass aName |		listIndex ~= 0 ifTrue:		[method _ (aClass _ parent selectedClassOrMetaClass) compiledMethodAt:						(aName _ parent selectedMessageName) ifAbsent: [^ self beep].		filteredList _ method messages reject: 			[:each | #(new initialize = ) includes: each].		Smalltalk browseAllImplementorsOfList: filteredList asSortedCollection			 title: 'All messages sent in ', aClass name, '.', aName]! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 8/7/97 19:28'!browseClass	controller controlTerminate.	self classAndSelectorDo:		[:cl :sel |  		Browser postOpenSuggestion: 			(Array with: cl with: sel).		Browser newOnClass: cl].	controller controlInitialize! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 8/7/97 19:25'!browseFull	self classAndSelectorDo:		[:cl :sel |  BrowserView browseFullForClass: cl method: sel from: controller]! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 1/15/98 19:04'!browseSendersOfMessages	"Create and schedule a message set browser on the senders of a user-chosen selector sent in the current message."	controller controlTerminate.	listIndex = 0 ifFalse:		[Smalltalk showMenuThenBrowseSendersOf:			(parent selectedClassOrMetaClass compiledMethodAt: 				self selection asSymbol ifAbsent: [controller controlInitialize.  ^ self beep]) messages asSortedCollection].	controller controlInitialize! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 8/7/97 19:31'!classHierarchy	self classAndSelectorDo:		[:cl :sel |  		Utilities spawnHierarchyForClass: cl selector: sel].	controller controlInitialize! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 8/12/97 22:53'!inspectInstances	controller controlTerminate.	self classAndSelectorDo:		[:cl :sel |  cl theNonMetaClass inspectAllInstances].	controller controlInitialize! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 8/12/97 22:53'!inspectSubInstances	controller controlTerminate.	self classAndSelectorDo:		[:cl :sel |  cl theNonMetaClass inspectSubInstances].	controller controlInitialize! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 1/15/98 17:35'!messages	"Create and schedule a message set browser on the the messages sent by 	the selected message."	controller controlTerminate.	listIndex = 0 ifFalse: [		Smalltalk showMenuThenBrowse:			(parent selectedClassOrMetaClass compiledMethodAt: 				self selection asSymbol ifAbsent: [controller controlInitialize.  ^ self beep]) messages asSortedCollection].	controller controlInitialize! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 8/7/97 19:32'!methodHierarchy	self classAndSelectorDo:		[:cl :sel |  		Utilities methodHierarchyBrowserForClass: cl selector: sel].	controller controlInitialize! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 1/15/98 16:48'!removeMessage	"Remove the selected msg from the system.  Real work done by the parent, a ChangeSorter"	listIndex == 0 ifFalse: [parent removeMessage]! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 1/15/98 17:43'!removeMessageFromBrowser	"This msg-list-browser command is inapplicable to change lists"	self beep! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 1/15/98 19:31'!shiftedYellowButtonActivity	^ controller shiftedYellowButtonActivity! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 1/15/98 18:59'!shiftedYellowButtonMenu	"Answer the menu to be put up when shift key is down.  "	self flag: #deferred.  "the 'revert' commands should be here as they are in msg list controllers"	^ PopUpMenu labels: 'browse method inheritancebrowse class hierarchybrowse classbrowse methodimplementors of sent messagesinspect instancesinspect subinstancesmore...' lines: #(5 7 )! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 1/15/98 18:59'!shiftedYellowButtonMessages	"Answer the messages corresponding to the shifted-yellow-button menu, to be put up when shift key is down."	^ #(methodHierarchy classHierarchy browseClass browse allImplementorsOf inspectInstances inspectSubInstances unshiftedYellowButtonActivity)! !!CngsMsgList methodsFor: 'menu messages' stamp: 'sw 8/12/97 22:55'!unshiftedYellowButtonActivity	controller controlTerminate.	controller unshiftedYellowButtonActivity.	controller controlInitialize! !!CngsMsgList methodsFor: 'menu messages' stamp: 'di 6/15/97 15:24'!versions	"Create and schedule a changelist browser on the versions of the 	selected message."	| class selector method category pair sourcePointer |	listIndex = 0 ifTrue: [^ self].	class _ parent selectedClassOrMetaClass.	selector _ parent selectedMessageName.	(class includesSelector: selector)		ifTrue: [method _ class compiledMethodAt: selector.				category _ class whichCategoryIncludesSelector: selector.				sourcePointer _ nil]		ifFalse: [pair _ parent changeSet methodRemoves							at: (Array with: class name with: selector)							ifAbsent: [^ nil].				sourcePointer _ pair first.				method _ CompiledMethod toReturnSelf setSourcePointer: sourcePointer.				category _ pair last].	controller controlTerminate.	ChangeList		browseVersionsOf: method		class: parent selectedClass meta: class isMeta		category: category selector: selector		lostMethodPointer: sourcePointer.	controller controlInitialize! !!CngsMsgList methodsFor: 'mechanics' stamp: 'sw 8/7/97 19:24'!classAndSelectorDo: blockOfTwoArgs	| class selector |	class _ parent selectedClassOrMetaClass.	selector _ parent selectedMessageName.	((class == nil) | (selector == nil)) ifTrue: [^ self].	^ blockOfTwoArgs value: class value: selector! !!CngsMsgList methodsFor: 'accessing' stamp: 'sw 8/7/97 19:18'!list: anObject	list _ anObject.	listIndex _ 0.	self changed: #list.	parent changed: #message! !!CodeBrowser methodsFor: 'initialization' stamp: 'di 6/16/97 14:54'!extent: newExtent	| w h inner labelRect |	super extent: newExtent.	inner _ self innerBounds.	labelRect _ inner topLeft corner: inner topRight + (0@self labelHeight).	w _ inner width - 2 // 4.  h _ inner height - labelRect height // 3.	systemPane bounds: (labelRect bottomLeft + (1@1) extent: w @ h).	classPane bounds: (systemPane bounds topRight extent: w @ (h - 20)).	categoryPane bounds: (classPane bounds topRight extent: w @ h).	messagePane bounds: (categoryPane bounds topRight corner: inner right-2 @ categoryPane bounds bottom).	instButton bounds: (systemPane bounds bottomRight + (2@-2) rect: classPane bounds bottomCenter + (0@2)).	classButton bounds: (categoryPane bounds bottomLeft + (-2@-2) rect: classPane bounds bottomCenter + (0@2)).	codePane bounds: (systemPane bounds bottomLeft corner: inner bottomRight - 1)! !!CodeBrowser methodsFor: 'initialization' stamp: 'di 6/16/97 15:04'!initialize	super initialize.	systemPane list: SystemOrganization categories.	self metaClassIndicated: false! !!CodeBrowser methodsFor: 'initialization' stamp: 'di 6/16/97 15:08'!initPanes	self addMorph: (systemPane _ ListPane new model: self slotName: 'systemPane').	self addMorph: (classPane _ ListPane new model: self slotName: 'classPane').	self addMorph: (instButton _ SimpleButtonMorph new borderWidth: 2; color: paneColor;							label: 'inst'; actionSelector: #instanceMode; target: self).	self addMorph: (classButton _ SimpleButtonMorph new borderWidth: 2; color: paneColor;							label: 'class'; actionSelector: #classMode; target: self).	self addMorph: (categoryPane _ ListPane new model: self slotName: 'categoryPane').	self addMorph: (messagePane _ ListPane new model: self slotName: 'messagePane').	self addMorph: (codePane _ ScrollPane new model: self slotName: 'codePane').! !!CodeBrowser methodsFor: 'input events'!categoryPaneMenuButtonPressed: arg1"Automatically generated null response.""Add code below for appropriate behavior..."! !!CodeBrowser methodsFor: 'input events' stamp: '6/6/97 15:54 di'!categoryPaneNewSelection: arg1	arg1 ifNil: [^ messagePane list: Array new].	messagePane list: (self selectedClassOrMetaClass organization listAtCategoryNamed: arg1)! !!CodeBrowser methodsFor: 'input events'!classPaneMenuButtonPressed: arg1"Automatically generated null response.""Add code below for appropriate behavior..."! !!CodeBrowser methodsFor: 'input events' stamp: '6/6/97 15:44 di'!classPaneNewSelection: arg1	arg1 ifNil: [^ categoryPane list: Array new].	categoryPane list: self selectedClassOrMetaClass organization categories! !!CodeBrowser methodsFor: 'input events'!codePaneMenuButtonPressed: arg1"Automatically generated null response.""Add code below for appropriate behavior..."! !!CodeBrowser methodsFor: 'input events'!messagePaneMenuButtonPressed: arg1"Automatically generated null response.""Add code below for appropriate behavior..."! !!CodeBrowser methodsFor: 'input events' stamp: '6/6/97 15:51 di'!messagePaneNewSelection: arg1	codePane scroller removeAllMorphs.	arg1 ifNil: [^ self].	codePane scroller addMorph:		(TextMorph new contents:			(self selectedClassOrMetaClass sourceMethodAt: arg1))! !!CodeBrowser methodsFor: 'input events'!systemPaneNewSelection: arg1	classPane list: (SystemOrganization listAtCategoryNamed: arg1)! !!CodeBrowser methodsFor: 'system pane' stamp: 'jm 11/4/97 07:46'!systemPaneMenuButtonPressed: event	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addTitle: 'system category'.	"**these two belong in class pane**"	menu add: 'select class...' action: #selectClass.	menu add: 'select recent...' action: #selectRecentClass.	menu add: 'browse all classes' action: #browseAllClasses.	menu add: 'spawn selection' action: #spawnSystemCategory.	menu addLine.	menu add: 'fileOut' action: #fileOutSystemCategory.	menu addLine.	menu add: 'reorganize' action: #editSystemOrganization.	menu add: 'add selection...' action: #addSystemCategory.	menu add: 'rename selection...' action: #renameSystemCategory.	menu add: 'remove selection' action: #removeSystemCategory.	event hand invokeMenu: menu event: event.! !!CodeBrowser methodsFor: 'private' stamp: '6/6/97 15:47 di'!classMode	self metaClassIndicated: true! !!CodeBrowser methodsFor: 'private' stamp: '6/6/97 15:47 di'!instanceMode	self metaClassIndicated: false! !!CodeBrowser methodsFor: 'private' stamp: '6/6/97 15:50 di'!metaClassIndicated: trueOrFalse	metaClassIndicated == trueOrFalse ifTrue: [^ self].	(metaClassIndicated _ trueOrFalse)		ifTrue: [instButton color: paneColor.				classButton color: paneColor darker]		ifFalse: [instButton color: paneColor darker.				classButton color: paneColor].	classPane selection == nil ifFalse:		[categoryPane list: self selectedClassOrMetaClass organization categories]! !!CodeBrowser methodsFor: 'private' stamp: '6/6/97 15:44 di'!selectedClass	^ Smalltalk at: classPane selection! !!CodeBrowser methodsFor: 'private' stamp: '6/6/97 15:32 di'!selectedClassOrMetaClass	^ metaClassIndicated		ifTrue: [self selectedClass class]		ifFalse: [self selectedClass]! !!CodeBrowser class methodsFor: 'instance creation' stamp: 'di 6/18/97 05:33'!new	^ self labelled: 'System Browser'! !!Collection methodsFor: 'testing' stamp: 'sw 8/12/97 20:59'!includesSubstringAnywhere: testString	"Answer whether the receiver includes, anywhere in its nested structure, a string that has testString as a substring"	self do:		[:element |			(element isKindOf: String)				ifTrue:					[(element includesSubString: testString) ifTrue: [^ true]].			(element isKindOf: Collection)				ifTrue:					[(element includesSubstringAnywhere: testString) ifTrue: [^ true]]].	^ false"#(first (second third) ((allSentMessages ('Elvis' includes:)))) includesSubstringAnywhere:  'lvi'"! !!Collection methodsFor: 'enumerating' stamp: 'jm 10/16/97 21:25'!average	"Return the average of all my elements."	^ self sum asFloat / self size! !!Collection methodsFor: 'enumerating' stamp: 'jm 11/14/97 11:08'!max	"Return the max of all my elements."	| max | max _ nil.	self do: [:each | (max == nil or: [each > max])					ifTrue: [max _ each]].  	^ max! !!Collection methodsFor: 'enumerating' stamp: 'di 7/5/97 14:56'!sum	"Return the sum of all my elements."	| sum |  sum _ 0.	self do: [:each | sum _ sum + each].  	^ sum! !!Collection methodsFor: 'printing' stamp: 'di 6/20/97 09:09'!printOn: aStream 	"Refer to the comment in Object|printOn:."	aStream nextPutAll: self class name, ' ('.	self do: [:element | element printOn: aStream. aStream space].	aStream nextPut: $)! !!Color methodsFor: 'access'!alpha	"Return the opacity ('alpha') value of opaque so that normal colors can be compared to TransparentColors."	^ 1.0! !!Color methodsFor: 'access'!blue	"Return the blue component of this color, a float in the range [0.0..1.0]."	^ self privateBlue asFloat / ComponentMax! !!Color methodsFor: 'access'!brightness	"Return the brightness of this color, a float in the range [0.0..1.0]."	^ ((self privateRed max:	    self privateGreen) max:	    self privateBlue) asFloat / ComponentMax! !!Color methodsFor: 'access'!green	"Return the green component of this color, a float in the range [0.0..1.0]."	^ self privateGreen asFloat / ComponentMax! !!Color methodsFor: 'access'!luminance	"Return the luminance of this color, a brightness value weighted by the human eye's color sensitivity."	^ ((299 * self privateRed) +	   (587 * self privateGreen) +	   (114 * self privateBlue)) / (1000 * ComponentMax)! !!Color methodsFor: 'access'!red	"Return the red component of this color, a float in the range [0.0..1.0]."	^ self privateRed asFloat / ComponentMax! !!Color methodsFor: 'access'!saturation	"Return the saturation of this color, a value between 0.0 and 1.0."	| r g b max min |	r _ self privateRed.	g _ self privateGreen.	b _ self privateBlue. 	max _ min _ r.	g > max ifTrue: [max _ g].	b > max ifTrue: [max _ b].	g < min ifTrue: [min _ g].	b < min ifTrue: [min _ b].	max = 0		ifTrue: [ ^ 0.0 ]		ifFalse: [ ^ (max - min) asFloat / max asFloat ].! !!Color methodsFor: 'equality' stamp: 'tk 10/21/97 11:24'!= aColor	"Return true if the receiver equals the given color. This method handles TranslucentColors, too."	aColor isColor ifFalse: [^ false].	aColor isOpaqueMask ifTrue: [^ false].	aColor isTransparent ifTrue: [^ false].	^ aColor privateRGB = rgb and:		[aColor privateAlpha = self privateAlpha]! !!Color methodsFor: 'equality'!hash	^ rgb! !!Color methodsFor: 'queries'!isColor	^ true! !!Color methodsFor: 'queries'!isOpaqueMask	^ false! !!Color methodsFor: 'queries'!isTransparent	^ false! !!Color methodsFor: 'transformations' stamp: 'di 11/2/97 14:05'!* aNumber	"Answer this color with its RGB multiplied by the given number. "	"(Color brown * 2) display"	^ Color basicNew		setPrivateRed: (self privateRed * aNumber) asInteger		green: (self privateGreen * aNumber) asInteger		blue: (self privateBlue * aNumber) asInteger! !!Color methodsFor: 'transformations' stamp: 'di 11/2/97 14:05'!+ aColor	"Answer this color mixed with the given color in an additive color space.  "	"(Color blue + Color green) display"	^ Color basicNew		setPrivateRed: self privateRed + aColor privateRed		green: self privateGreen + aColor privateGreen		blue: self privateBlue + aColor  privateBlue! !!Color methodsFor: 'transformations' stamp: 'di 11/2/97 14:05'!- aColor	"Answer aColor is subtracted from the given color in an additive color space.  "	"(Color white - Color red) display"	^ Color basicNew		setPrivateRed: self privateRed - aColor privateRed		green: self privateGreen - aColor privateGreen		blue: self privateBlue - aColor  privateBlue! !!Color methodsFor: 'transformations' stamp: 'di 11/2/97 14:07'!/ aNumber	"Answer this color with its RGB divided by the given number. "	"(Color red / 2) display"	^ Color basicNew		setPrivateRed: (self privateRed / aNumber) asInteger		green: (self privateGreen / aNumber) asInteger		blue: (self privateBlue / aNumber) asInteger! !!Color methodsFor: 'transformations'!alpha: alphaValue	"Return a new TransparentColor with the given amount of opacity ('alpha')."	^ TranslucentColor basicNew setRgb: rgb alpha: alphaValue! !!Color methodsFor: 'transformations' stamp: 'jm 12/4/97 10:45'!contrastingRed	"If I am not redish, return red to contrast with me. If I am too red, return green"	self red < 0.5 ifTrue: [^ Color red].	self red > (self green + (self blue * 0.5)) ifTrue: [^ Color green].	^ Color red! !!Color methodsFor: 'transformations'!mixed: proportion with: aColor	"Answer this color mixed with the given color. The proportion, a number between 0.0 and 1.0, determines what what fraction of the receiver to use in the mix. For example, 0.9 would yield a color close to the receiver."	"Details: This method uses RGB interpolation; HSV interpolation can lead to surprises."	| frac1 frac2 |	frac1 _ proportion asFloat min: 1.0 max: 0.0.	frac2 _ 1.0 - frac1.	^ Color		r: (self    red * frac1) + (aColor    red * frac2) 		g: (self green * frac1) + (aColor green * frac2) 		b: (self   blue * frac1) + (aColor  blue * frac2)! !!Color methodsFor: 'transformations' stamp: 'jm 9/22/97 15:11'!muchLighter	^ self mixed: 0.233 with: Color white! !!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!darkShades: thisMany	"An array of thisMany colors from black to the receiver.  Array is of length num. Very useful for displaying color based on a variable in your program.  "	"Color showColors: (Color red darkShades: 12)"	^ self class black mix: self shades: thisMany! !!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!lightShades: thisMany	"An array of thisMany colors from white to self. Very useful for displaying color based on a variable in your program.  "	"Color showColors: (Color red lightShades: 12)"	^ self class white mix: self shades: thisMany! !!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!mix: color2 shades: thisMany	"Return an array of thisMany colors from self to color2. Very useful for displaying color based on a variable in your program.  "	"Color showColors: (Color red mix: Color green shades: 12)"	| redInc greenInc blueInc rr gg bb c out |	thisMany = 1 ifTrue: [^ Array with: color2].	redInc _ color2 red - self red / (thisMany-1).	greenInc _ color2 green - self green / (thisMany-1).	blueInc _ color2 blue - self blue / (thisMany-1).	rr _ self red.  gg _ self green.  bb _ self blue.	out _ (1 to: thisMany) collect: [:num |		c _ Color r: rr g: gg b: bb.		rr _ rr + redInc.		gg _ gg + greenInc.		bb _ bb + blueInc.		c].	out at: out size put: color2.	"hide roundoff errors"	^ out! !!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!wheel: thisMany	"An array of thisMany colors around the color wheel starting at self and ending all the way around the hue space just before self.  Array is of length thisMany.  Very useful for displaying color based on a variable in your program.  "	| sat bri hue step c |	thisMany = 1 ifTrue: [^ Array with: self].	sat _ self saturation.	bri _ self brightness.	hue _ self hue.	step _ 360.0 / thisMany.	^ (1 to: thisMany) collect: [:num |		c _ Color h: hue s: sat v: bri.  "hue is taken mod 360"		hue _ hue + step.		c].! !!Color methodsFor: 'printing'!printOn: aStream	self storeOn: aStream.! !!Color methodsFor: 'printing'!shortPrintString	"Return a short (but less precise) print string for use where space is tight."	| s |	s _ WriteStream on: ''.	s		nextPutAll: '(' , self class name;		nextPutAll: ' r: ';		nextPutAll: (self red roundTo: 0.01) printString;		nextPutAll: ' g: ';		nextPutAll: (self green roundTo: 0.01) printString;		nextPutAll: ' b: ';		nextPutAll: (self blue roundTo: 0.01) printString;		nextPutAll: ')'.	^ s contents! !!Color methodsFor: 'printing'!storeOn: aStream	aStream		nextPutAll: '(' , self class name;		nextPutAll: ' r: ';		nextPutAll: (self red roundTo: 0.001) printString;		nextPutAll: ' g: ';		nextPutAll: (self green roundTo: 0.001) printString;		nextPutAll: ' b: ';		nextPutAll: (self blue roundTo: 0.001) printString;		nextPutAll: ')'.! !!Color methodsFor: 'other' stamp: 'tk 6/14/96'!display	"Show a swatch of this color tracking the cursor until the next mouseClick. "	"Color red display"	| f |	f _ Form extent: 40@20 depth: Display depth.	f fillColor: self.	Cursor blank showWhile:		[f follow: [Sensor cursorPoint] while: [Sensor noButtonPressed]]! !!Color methodsFor: 'other' stamp: 'jm 12/4/97 10:24'!name	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color."	ColorNames do:		[:name | (Color perform: name) = self ifTrue: [^ name]].	^ nil! !!Color methodsFor: 'other' stamp: 'jm 12/4/97 10:27'!rgbTriplet	"Color fromUser rgbTriplet"	^ Array		with: (self red roundTo: 0.01)		with: (self green roundTo: 0.01)		with: (self blue roundTo: 0.01)! !!Color methodsFor: 'conversions' stamp: 'di 11/3/97 08:40'!balancedPatternForDepth: depth	"A generalization of bitPatternForDepth: as it exists.  Generates a 2x2 stipple of color.	The topLeft and bottomRight pixel are closest approx to this color"	| pv1 pv2 mask1 mask2 pv3 c |	depth == cachedDepth ifTrue: [^ cachedBitPattern].	(depth between: 4 and: 16) ifFalse: [^ self bitPatternForDepth: depth].	cachedDepth _ depth.	pv1 _ self pixelValueForDepth: depth."	Subtract error due to pv1 to get pv2.	pv2 _ (self - (err1 _ (Color colorFromPixelValue: pv1 depth: depth) - self))						pixelValueForDepth: depth.	Subtract error due to 2 pv1's and pv2 to get pv3.	pv3 _ (self - err1 - err1 - ((Color colorFromPixelValue: pv2 depth: depth) - self))						pixelValueForDepth: depth."	"Above two statements computed faster by the following..."	pv2 _ (c _ self - ((Color colorFromPixelValue: pv1 depth: depth) - self))						pixelValueForDepth: depth.	pv3 _ (c + (c - (Color colorFromPixelValue: pv2 depth: depth)))						pixelValueForDepth: depth.	"Return to a 2-word bitmap that encodes a 2x2 stipple of the given pixelValues."	mask1 _ (#(- - -				16r01010101 - - -			"replicates every other 4 bits"			16r00010001 - - - - - - -	"replicates every other 8 bits"			16r00000001) at: depth).	"replicates every other 16 bits"	mask2 _ (#(- - -				16r10101010 - - -			"replicates the other 4 bits"			16r01000100 - - - - - - -	"replicates the other 8 bits"			16r00010000) at: depth).	"replicates the other 16 bits"	^ Bitmap with: (mask1*pv1) + (mask2*pv2) with: (mask1*pv3) + (mask2*pv1)! !!Color methodsFor: 'conversions' stamp: 'tk 6/14/96'!bitPatternForDepth: depth	"Return a Bitmap, possibly containing a stipple pattern, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps. The resulting Bitmap may be multiple words to represent a stipple pattern of several lines.  "	"See also:	pixelValueAtDepth:	-- value for single pixel				pixelWordAtDepth:	-- a 32-bit word filled with the pixel value"	"Details: The pattern for the most recently requested depth is cached."	depth == cachedDepth ifTrue: [^ cachedBitPattern].	cachedDepth _ depth.	depth > 2 ifTrue: [^ cachedBitPattern _ Bitmap with: (self pixelWordForDepth: depth)].	depth = 1 ifTrue: [^ cachedBitPattern _ self halfTonePattern1].	depth = 2 ifTrue: [^ cachedBitPattern _ self halfTonePattern2].! !!Color methodsFor: 'conversions'!closestPixelValue1	"Return the nearest approximation to this color for a monochrome Form."	"fast special cases"	rgb = 0 ifTrue: [^ 1].  "black"	rgb = 16r3FFFFFFF ifTrue: [^ 0].  "white"	self luminance > 0.5		ifTrue: [^ 0]  "white"		ifFalse: [^ 1].  "black"! !!Color methodsFor: 'conversions'!closestPixelValue2	"Return the nearest approximation to this color for a 2-bit deep Form."	| lum |	"fast special cases"	rgb = 0 ifTrue: [^ 1].  "black"	rgb = 16r3FFFFFFF ifTrue: [^ 2].  "opaque white"	lum _ self luminance.	lum < 0.2 ifTrue: [^ 1].  "black"	lum > 0.6 ifTrue: [^ 2].  "opaque white"	^ 3  "50% gray"! !!Color methodsFor: 'conversions'!closestPixelValue4	"Return the nearest approximation to this color for a 4-bit deep Form."	| bIndex |	"fast special cases"	rgb = 0 ifTrue: [^ 1].  "black"	rgb = 16r3FFFFFFF ifTrue: [^ 2].  "opaque white"	rgb = PureRed privateRGB ifTrue: [^ 4].	rgb = PureGreen privateRGB ifTrue: [^ 5].	rgb = PureBlue privateRGB ifTrue: [^ 6].	rgb = PureCyan privateRGB ifTrue: [^ 7].	rgb = PureYellow privateRGB ifTrue: [^ 8].	rgb = PureMagenta privateRGB ifTrue: [^ 9].	bIndex _ (self luminance * 8.0) rounded.  "bIndex in [0..8]"	^ #(		1	"black"		10	"1/8 gray"		11	"2/8 gray"		12	"3/8 gray"		3	"4/8 gray"		13	"5/8 gray"		14	"6/8 gray"		15	"7/8 gray"		2	"opaque white"	) at: bIndex + 1.! !!Color methodsFor: 'conversions'!closestPixelValue8	"Return the nearest approximation to this color for an 8-bit deep Form."	"fast special cases"	rgb = 0 ifTrue: [^ 1].  "black"	rgb = 16r3FFFFFFF ifTrue: [^ 255].  "white"	self saturation < 0.2 ifTrue: [		^ GrayToIndexMap at: (self privateGreen >> 2) + 1.  "nearest gray"	] ifFalse: [		"compute nearest entry in the color cube"		^ 40 +		  ((((self privateRed * 5) + HalfComponentMask) // ComponentMask) * 36) +		  ((((self privateBlue * 5) + HalfComponentMask) // ComponentMask) * 6) +		  (((self privateGreen * 5) + HalfComponentMask) // ComponentMask)].! !!Color methodsFor: 'conversions' stamp: 'di 9/2/97 20:21'!dominantColor	^ self! !!Color methodsFor: 'conversions' stamp: 'di 6/23/97 23:27'!halfTonePattern1	"Return a halftone-pattern to approximate luminance levels on 1-bit deep Forms."	| lum |	lum _ self luminance.	lum < 0.1 ifTrue: [^ Bitmap with: 16rFFFFFFFF]. "black"	lum < 0.4 ifTrue: [^ Bitmap with: 16rBBBBBBBB with: 16rEEEEEEEE]. "dark gray"	lum < 0.6 ifTrue: [^ Bitmap with: 16r55555555 with: 16rAAAAAAAA]. "medium gray"	lum < 0.9 ifTrue: [^ Bitmap with: 16r44444444 with: 16r11111111]. "light gray"	^ Bitmap with: 0  "1-bit white"! !!Color methodsFor: 'conversions'!halfTonePattern2	"Return a halftone-pattern to approximate luminance levels on 2-bit deep Forms."	| lum |	lum _ self luminance.	lum < 0.125 ifTrue: [^ Bitmap with: 16r55555555].  "black"	lum < 0.25 ifTrue: [^ Bitmap with: 16r55555555 with: 16rDDDDDDDD].  "1/8 gray"	lum < 0.375 ifTrue: [^ Bitmap with: 16rDDDDDDDD with: 16r77777777].  "2/8 gray"	lum < 0.5 ifTrue: [^ Bitmap with: 16rFFFFFFFF with: 16r77777777].  "3/8 gray"	lum < 0.625 ifTrue: [^ Bitmap with: 16rFFFFFFFF].  "4/8 gray"	lum < 0.75 ifTrue: [^ Bitmap with: 16rFFFFFFFF with: 16rBBBBBBBB].  "5/8 gray"	lum < 0.875 ifTrue: [^ Bitmap with: 16rEEEEEEEE with: 16rBBBBBBBB].  "6/8 gray"	lum < 1.0 ifTrue: [^ Bitmap with: 16rAAAAAAAA with: 16rBBBBBBBB].  "7/8 gray"	^ Bitmap with: 16rAAAAAAAA  "opaque white""handy expression for computing patterns for 2x2 tiles; set p to a string of 4 letters (e.g., 'wggw' for a gray-and- white checkerboard) and print the result of evaluating:| p d w1 w2 |p _ 'wggw'.d _ Dictionary new.d at: $b put: '01'.d at: $w put: '10'.d at: $g put: '11'.w1 _ (d at: (p at: 1)), (d at: (p at: 2)).w1 _ '2r', w1, w1, w1, w1, w1, w1, w1, w1, ' hex'.w2 _ (d at: (p at: 3)), (d at: (p at: 4)).w2 _ '2r', w2, w2, w2, w2, w2, w2, w2, w2, ' hex'.Array with: (Compiler evaluate: w1) with: (Compiler evaluate: w2) "! !!Color methodsFor: 'conversions' stamp: 'tk 4/24/97'!indexInMap: aColorMap	"Return the index corresponding to this color in the given color map. RGB colors are truncated to 3-, 4-, or 5-bits per color component when indexing into such a colorMap.  "	aColorMap size = 2 ifTrue: [^ (self pixelValueForDepth: 1) + 1].	aColorMap size = 4 ifTrue: [^ (self pixelValueForDepth: 2) + 1].	aColorMap size = 16 ifTrue: [^ (self pixelValueForDepth: 4) + 1].	aColorMap size = 256 ifTrue: [^ (self pixelValueForDepth: 8) + 1].	aColorMap size = 512 ifTrue: [^ (self pixelValueForDepth: 9) + 1].	aColorMap size = 4096 ifTrue: [^ (self pixelValueForDepth: 12) + 1].	aColorMap size = 32768 ifTrue: [^ (self pixelValueForDepth: 16) + 1].	self error: 'unknown pixel depth'.! !!Color methodsFor: 'conversions'!pixelValueForDepth: d	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8, black maps to the darkest possible blue."	| rgbBlack val |	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"	d < 8 ifTrue: [		d = 4 ifTrue: [^ self closestPixelValue4].		d = 2 ifTrue: [^ self closestPixelValue2].		d = 1 ifTrue: [^ self closestPixelValue1]].	rgbBlack _ 1.  "closest black that is not transparent in RGB"	d = 16 ifTrue: [		"five bits per component; top bits ignored"		val _ (((rgb bitShift: -15) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: -10) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: -5) bitAnd: 16r001F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 32 ifTrue: [		"eight bits per component; top 8 bits ignored"		val _ (((rgb bitShift: -6) bitAnd: 16rFF0000) bitOr:			 ((rgb bitShift: -4) bitAnd: 16r00FF00)) bitOr:			 ((rgb bitShift: -2) bitAnd: 16r0000FF).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"		val _ (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"		val _ (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	self error: 'unknown pixel depth: ', d printString! !!Color methodsFor: 'conversions'!pixelWordFor: depth filledWith: pixelValue	"Return to a 32-bit word that concatenates enough copies of the given pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."	depth = 32 ifTrue: [^ pixelValue].	^ (pixelValue bitAnd: (1 bitShift: depth) - 1) * 		(#(16rFFFFFFFF				"replicates at every bit"			16r55555555 -			"replicates every 2 bits"			16r11111111 - - -			"replicates every 4 bits"			16r01010101 - - - - - - -	"replicates every 8 bits"			16r00010001) at: depth)	"replicates every 16 bits"! !!Color methodsFor: 'conversions'!pixelWordForDepth: depth	"Return to a 32-bit word that concatenates enough copies of the receiver's pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."	| pixelValue |	pixelValue _ self pixelValueForDepth: depth.	^ self pixelWordFor: depth filledWith: pixelValue! !!Color methodsFor: 'private'!attemptToMutateError	"A color is immutable. Once a color's red, green, and blue have been initialized, you cannot change them. Instead, create a new Color and use it."	self error: 'Color objects are immutable once created'! !!Color methodsFor: 'private'!flushCache	"Flush my cached bit pattern."	cachedDepth _ nil.	cachedBitPattern _ nil.! !!Color methodsFor: 'private'!privateAlpha	"Private!! Return the raw alpha value for opaque. Used only for equality testing."	^ 255! !!Color methodsFor: 'private'!privateBlue	"Private!! Return the internal representation of my blue component."	^ rgb bitAnd: ComponentMask! !!Color methodsFor: 'private'!privateGreen	"Private!! Return the internal representation of my green component."	^ (rgb >> GreenShift) bitAnd: ComponentMask! !!Color methodsFor: 'private'!privateRed	"Private!! Return the internal representation of my red component."	^ (rgb bitShift: 0 - RedShift) bitAnd: ComponentMask! !!Color methodsFor: 'private'!privateRGB	"Private!! Return the internal representation of my RGB components."	^ rgb! !!Color methodsFor: 'private'!setHue: hue saturation: saturation brightness: brightness	"Initialize this color to the given hue, saturation, and brightness. See the comment in the instance creation method for details."	| s v hf i f p q t | 	s _ (saturation asFloat max: 0.0) min: 1.0.	v _ (brightness asFloat max: 0.0) min: 1.0.	"zero saturation yields gray with the given brightness"	s = 0.0 ifTrue: [ ^ self setRed: v green: v blue: v ].	hf _ hue asFloat.	(hf < 0.0 or: [hf >= 360.0])		ifTrue: [hf _ hf - ((hf quo: 360.0) asFloat * 360.0)].	hf _ hf / 60.0.	i _ hf asInteger.  "integer part of hue"	f _ hf fractionPart.         "fractional part of hue"	p _ (1.0 - s) * v.	q _ (1.0 - (s * f)) * v.	t _ (1.0 - (s * (1.0 - f))) * v.	0 = i ifTrue: [ ^ self setRed: v green: t blue: p ].	1 = i ifTrue: [ ^ self setRed: q green: v blue: p ].	2 = i ifTrue: [ ^ self setRed: p green: v blue: t ].	3 = i ifTrue: [ ^ self setRed: p green: q blue: v ].	4 = i ifTrue: [ ^ self setRed: t green: p blue: v ].	5 = i ifTrue: [ ^ self setRed: v green: p blue: q ].	self error: 'implementation error'.! !!Color methodsFor: 'private' stamp: 'di 11/2/97 12:19'!setPrivateRed: r green: g blue: b	"Initialize this color's r, g, and b components to the given values in the range [0..ComponentMax].  Encoded in a single variable as 3 integers in [0..1023]."	rgb == nil ifFalse: [self attemptToMutateError].	rgb _ ((r min: ComponentMask max: 0) bitShift: RedShift) +		((g min: ComponentMask max: 0) bitShift: GreenShift) +		 (b min: ComponentMask max: 0).	cachedDepth _ nil.	cachedBitPattern _ nil.! !!Color methodsFor: 'private'!setRed: r green: g blue: b	"Initialize this color's r, g, and b components to the given values in the range [0.0..1.0].  Encoded in a single variable as 3 integers in [0..1023]."	rgb == nil ifFalse: [self attemptToMutateError].	rgb _		(((r * ComponentMax) rounded bitAnd: ComponentMask) bitShift: RedShift) +		(((g * ComponentMax) rounded bitAnd: ComponentMask) bitShift: GreenShift) +		 ((b * ComponentMax) rounded bitAnd: ComponentMask).	cachedDepth _ nil.	cachedBitPattern _ nil.! !!Color methodsFor: 'private'!setRed: r green: g blue: b range: range	"Initialize this color's r, g, and b components to the given values in the range [0..r]."	rgb == nil ifFalse: [self attemptToMutateError].	rgb _		((((r * ComponentMask) // range) bitAnd: ComponentMask) bitShift: RedShift) +		((((g * ComponentMask) // range) bitAnd: ComponentMask) bitShift: GreenShift) +		 (((b * ComponentMask) // range) bitAnd: ComponentMask).	cachedDepth _ nil.	cachedBitPattern _ nil.! !!Color class methodsFor: 'instance creation' stamp: 'jm 12/1/97 20:43'!colorFromPixelValue: p depth: d	"Convert a pixel value for the given display depth into a color."	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."	| r g b alpha |	d = 8 ifTrue: [^ IndexedColors at: (p bitAnd: 16rFF) + 1].	d = 4 ifTrue: [^ IndexedColors at: (p bitAnd: 16r0F) + 1].	d = 2 ifTrue: [^ IndexedColors at: (p bitAnd: 16r03) + 1].	d = 1 ifTrue: [^ IndexedColors at: (p bitAnd: 16r01) + 1].	(d = 16) | (d = 15) ifTrue: [		"five bits per component"		r _ (p bitShift: -10) bitAnd: 16r1F.		g _ (p bitShift: -5) bitAnd: 16r1F.		b _ p bitAnd: 16r1F.		^ Color r: r g: g b: b range: 31].	d = 32 ifTrue: [		"eight bits per component; 8 bits of alpha"		r _ (p bitShift: -16) bitAnd: 16rFF.		g _ (p bitShift: -8) bitAnd: 16rFF.		b _ p bitAnd: 16rFF.		alpha _ p bitShift: -24.		alpha > 0			ifTrue: [^ (Color r: r g: g b: b range: 255) alpha: (alpha asFloat / 255.0)]			ifFalse: [^ (Color r: r g: g b: b range: 255)]].	d = 12 ifTrue: [		"four bits per component"		r _ (p bitShift: -8) bitAnd: 16rF.		g _ (p bitShift: -4) bitAnd: 16rF.		b _ p bitAnd: 16rF.		^ Color r: r g: g b: b range: 15].	d = 9 ifTrue: [		"three bits per component"		r _ (p bitShift: -6) bitAnd: 16r7.		g _ (p bitShift: -3) bitAnd: 16r7.		b _ p bitAnd: 16r7.		^ Color r: r g: g b: b range: 7].	self error: 'unknown pixel depth: ', d printString! !!Color class methodsFor: 'instance creation' stamp: 'sw 8/8/97 22:03'!fromRgbTriplet: list	^ self r: list first g: list second b: list last! !!Color class methodsFor: 'instance creation' stamp: 'jm 12/4/97 13:05'!gray: brightness	"Return a gray shade with the given brightness in the range [0.0..1.0]."	^ self basicNew setRed: brightness green: brightness blue: brightness! !!Color class methodsFor: 'instance creation'!h: hue s: saturation v: brightness	"Create a color with the given hue, saturation, and brightness. Hue is given as the angle in degrees of the color on the color circle where red is zero degrees. Saturation and brightness are numbers in [0.0..1.0] where larger values are more saturated or brighter colors. For example, (Color h: 0 s: 1 v: 1) is pure red."	"Note: By convention, brightness is abbreviated 'v' to to avoid confusion with blue."	^ self basicNew setHue: hue saturation: saturation brightness: brightness! !!Color class methodsFor: 'instance creation'!new	^ self r: 0.0 g: 0.0 b: 0.0! !!Color class methodsFor: 'instance creation' stamp: 'jm 12/4/97 13:04'!r: r g: g b: b	"Return a color with the given r, g, and b components in the range [0.0..1.0]."	^ self basicNew setRed: r green: g blue: b! !!Color class methodsFor: 'instance creation'!r: r g: g b: b alpha: alpha	^ (self r: r g: g b: b) alpha: alpha! !!Color class methodsFor: 'instance creation'!r: r g: g b: b range: range	"Return a color with the given r, g, and b components specified as integers in the range [0..r]. This avoids the floating point arithmetic in the red:green:blue: message and is thus a bit faster for certain applications (such as computing a sequence of colors for a palette)."	^ self basicNew setRed: r green: g blue: b range: range! !!Color class methodsFor: 'instance creation'!random	"Return a random color that isn't too dark or under-saturated."	^ self basicNew		setHue: (360.0 * RandomStream next)		saturation: (0.3 + (RandomStream next * 0.7))		brightness: (0.4 + (RandomStream next * 0.6))! !!Color class methodsFor: 'class initialization'!initialize	"Color initialize"	"Details: Externally, the red, green, and blue components of color	are floats in the range [0.0..1.0]. Internally, they are represented	as integers in the range [0..ComponentMask] packing into a	small integer to save space and to allow fast hashing and	equality testing.	For a general description of color representations for computer	graphics, including the relationship between the RGB and HSV	color models used here, see Chapter 17 of Foley and van Dam,	Fundamentals of Interactive Computer Graphics, Addison-Wesley,	1982."	ComponentMask _ 1023.	HalfComponentMask _ 512.  "used to round up in integer calculations"	ComponentMax _ 1023.0.  "a Float used to normalize components"	RedShift _ 20.	GreenShift _ 10.	BlueShift _ 0.	PureRed		 _ self r: 1 g: 0 b: 0.	PureGreen	 _ self r: 0 g: 1 b: 0.	PureBlue	 _ self r: 0 g: 0 b: 1.	PureYellow	 _ self r: 1 g: 1 b: 0.	PureCyan	 _ self r: 0 g: 1 b: 1.	PureMagenta _ self r: 1 g: 0 b: 1.	RandomStream _ Random new.	self initializeIndexedColors.	self initializeGrayToIndexMap.	self initializeNames.	self initializeHighLights.! !!Color class methodsFor: 'class initialization'!initializeGrayToIndexMap	"Build an array of gray values available in the 8-bit colormap. This array is indexed by a gray level between black (1) and white (256) and returns the pixel value for the corresponding gray level."	"Note: This method must be called after initializeIndexedColors, since it uses IndexedColors."	"Color initializeGrayToIndexMap"	| grayLevels grayIndices c distToClosest dist indexOfClosest |	"record the level and index of each gray in the 8-bit color table"	grayLevels _ OrderedCollection new.	grayIndices _ OrderedCollection new.	"Note: skip the first entry, which is reserved for transparent"	2 to: IndexedColors size do: [:i |		c _ IndexedColors at: i.		c saturation = 0.0 ifTrue: [  "c is a gray"			grayLevels add: (c privateBlue) >> 2.  "top 8 bits; R, G, and B are the same"			grayIndices add: i - 1]].  "pixel values are zero-based"	grayLevels _ grayLevels asArray.	grayIndices _ grayIndices asArray.	"for each gray level in [0..255], select the closest match"	GrayToIndexMap _ ByteArray new: 256.	0 to: 255 do: [:level |		distToClosest _ 10000.  "greater than distance to any real gray"		1 to: grayLevels size do: [:i |			dist _ (level - (grayLevels at: i)) abs.			dist < distToClosest ifTrue: [				distToClosest _ dist.				indexOfClosest _ grayIndices at: i]].		GrayToIndexMap at: (level + 1) put: indexOfClosest].! !!Color class methodsFor: 'class initialization' stamp: 'tk 6/22/96'!initializeHighLights	"Create a set of Bitmaps for quickly reversing areas of the screen without converting colors. "	"Color initializeHighLights"	| t |	t _ Array new: 32.	t at: 1 put: (Bitmap with: 16rFFFFFFFF).	t at: 2 put: (Bitmap with: 16rFFFFFFFF).	t at: 4 put: (Bitmap with: 16r55555555).	t at: 8 put: (Bitmap with: 16r7070707).	t at: 16 put: (Bitmap with: 16rFFFFFFFF).	t at: 32 put: (Bitmap with: 16rFFFFFFFF).	HighLightBitmaps _ t.! !!Color class methodsFor: 'class initialization'!initializeIndexedColors	"Build an array of colors corresponding to the fixed colormap used	 for display depths of 1, 2, 4, or 8 bits."	"Color initializeIndexedColors"	| a index grayVal |	a _ Array new: 256.	"1-bit colors (monochrome)"	a at: 1 put: (Color r: 1.0 g: 1.0 b: 1.0).		"white or transparent"	a at: 2 put: (Color r: 0.0 g: 0.0 b: 0.0).	"black"	"additional colors for 2-bit color"	a at: 3 put: (Color r: 1.0 g: 1.0 b: 1.0).	"opaque white"	a at: 4 put: (Color r: 0.5 g: 0.5 b: 0.5).	"1/2 gray"	"additional colors for 4-bit color"	a at:  5 put: (Color r: 1.0 g: 0.0 b: 0.0).	"red"	a at:  6 put: (Color r: 0.0 g: 1.0 b: 0.0).	"green"	a at:  7 put: (Color r: 0.0 g: 0.0 b: 1.0).	"blue"	a at:  8 put: (Color r: 0.0 g: 1.0 b: 1.0).	"cyan"	a at:  9 put: (Color r: 1.0 g: 1.0 b: 0.0).	"yellow"	a at: 10 put: (Color r: 1.0 g: 0.0 b: 1.0).	"magenta"	a at: 11 put: (Color r: 0.125 g: 0.125 b: 0.125).		"1/8 gray"	a at: 12 put: (Color r: 0.25 g: 0.25 b: 0.25).		"2/8 gray"	a at: 13 put: (Color r: 0.375 g: 0.375 b: 0.375).		"3/8 gray"	a at: 14 put: (Color r: 0.625 g: 0.625 b: 0.625).		"5/8 gray"	a at: 15 put: (Color r: 0.75 g: 0.75 b: 0.75).		"6/8 gray"	a at: 16 put: (Color r: 0.875 g: 0.875 b: 0.875).		"7/8 gray"	"additional colors for 8-bit color"	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"	index _ 17.	1 to: 31 do: [:v |		(v \\ 4) = 0 ifFalse: [			grayVal _ v / 32.0.			a at: index put: (Color r: grayVal g: grayVal b: grayVal).			index _ index + 1]].	"The remainder of color table defines a color cube with six steps	 for each primary color. Note that the corners of this cube repeat	 previous colors, but this simplifies the mapping between RGB colors	 and color map indices. This color cube spans indices 40 through 255	 (indices 41-256 in this 1-based array)."	0 to: 5 do: [:r |		0 to: 5 do: [:g |			0 to: 5 do: [:b |				index _ 41 + ((36 * r) + (6 * b) + g).				index > 256 ifTrue: [					self error: 'index out of range in color table compuation'].				a at: index put: (Color r: r g: g b: b range: 5)]]].	IndexedColors _ a.! !!Color class methodsFor: 'class initialization'!initializeNames	"Name some colors."	"Color initializeNames"	ColorNames _ OrderedCollection new.	self named: #black put: (Color r: 0 g: 0 b: 0).	self named: #veryVeryDarkGray put: (Color r: 0.125 g: 0.125 b: 0.125).	self named: #veryDarkGray put: (Color r: 0.25 g: 0.25 b: 0.25).	self named: #darkGray put: (Color r: 0.375 g: 0.375 b: 0.375).	self named: #gray put: (Color r: 0.5 g: 0.5 b: 0.5).	self named: #lightGray put: (Color r: 0.625 g: 0.625 b: 0.625).	self named: #veryLightGray put: (Color r: 0.75 g: 0.75 b: 0.75).	self named: #veryVeryLightGray put: (Color r: 0.875 g: 0.875 b: 0.875).	self named: #white put: (Color r: 1.0 g: 1.0 b: 1.0).	self named: #red put: (Color r: 1.0 g: 0 b: 0).	self named: #yellow put: (Color r: 1.0 g: 1.0 b: 0).	self named: #green put: (Color r: 0 g: 1.0 b: 0).	self named: #cyan put: (Color r: 0 g: 1.0 b: 1.0).	self named: #blue put: (Color r: 0 g: 0 b: 1.0).	self named: #magenta put: (Color r: 1.0 g: 0 b: 1.0).	self named: #brown put: (Color r: 0.6 g: 0.2 b: 0).	self named: #orange put: (Color r: 1.0 g: 0.6 b: 0).	self named: #lightRed put: (Color r: 1.0 g: 0.8 b: 0.8).	self named: #lightYellow put: (Color r: 1.0 g: 1.0 b: 0.8).	self named: #lightGreen put: (Color r: 0.8 g: 1.0 b: 0.6).	self named: #lightCyan put: (Color r: 0.4 g: 1.0 b: 1.0).	self named: #lightBlue put: (Color r: 0.8 g: 1.0 b: 1.0).	self named: #lightMagenta put: (Color r: 1.0 g: 0.8 b: 1.0).	self named: #lightBrown put: (Color r: 1.0 g: 0.6 b: 0.2).	self named: #lightOrange put: (Color r: 1.0 g: 0.8 b: 0.4).	self named: #transparent put: (TransparentColor new).	self named: #opaqueMask put: (OpaqueMaskColor new).! !!Color class methodsFor: 'class initialization' stamp: 'tk 6/13/96'!named: newName put: aColor	"Add a new color to the list and create an access message and a class variable for it.  The name should start with a lowercase letter.  (The class variable will start with an uppercase letter.)  (Color colorNames) returns a list of all color names.  "	| str cap sym accessor csym |	(aColor isKindOf: self) ifFalse: [^ self error: 'not a Color'].	str _ newName asString.	sym _ str asSymbol.	cap _ str capitalized.	csym _ cap asSymbol.	(self class canUnderstand: sym) ifFalse: [		"define access message"		accessor _ str, (String with: Character cr with: Character tab), 			'^', cap.		self class compile: accessor			classified: 'named colors'].	(self classPool includesKey: csym) ifFalse: [		self addClassVarName: cap].	(ColorNames includes: sym) ifFalse: [		ColorNames add: sym].	^ self classPool at: csym put: aColor! !!Color class methodsFor: 'examples'!colorRampForDepth: depth extent: aPoint	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."	"(Color colorRampForDepth: Display depth extent: 256@80) display"	"(Color colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"	| f dx dy r |	f _ Form extent: aPoint depth: depth.	dx _ aPoint x // 256.	dy _ aPoint y // 4.	0 to: 255 do: [:i |		r _ (dx * i)@0 extent: dx@dy.		f fill: r fillColor: (Color r: i g: 0 b: 0 range: 255).		r _ r translateBy: 0@dy.		f fill: r fillColor: (Color r: 0 g: i b: 0 range: 255).		r _ r translateBy: 0@dy.		f fill: r fillColor: (Color r: 0 g: 0 b: i range: 255).		r _ r translateBy: 0@dy.		f fill: r fillColor: (Color r: i g: i b: i range: 255)].	^ f! !!Color class methodsFor: 'examples' stamp: 'tk 6/19/96'!hotColdShades: thisMany	"An array of thisMany colors showing temperature from blue to red to white hot.  (Later improve this by swinging in hue.)  "	"Color showColors: (Color hotColdShades: 25)"	| n s1 s2 s3 s4 s5 |	thisMany < 5 ifTrue: [^ self error: 'must be at least 5 shades'].	n _ thisMany // 5.	s1 _ self white mix: self yellow shades: (thisMany - (n*4)).	s2 _ self yellow mix: self red shades: n+1.	s2 _ s2 copyFrom: 2 to: n+1.	s3 _ self red mix: self green darker shades: n+1.	s3 _ s3 copyFrom: 2 to: n+1.	s4 _ self green darker mix: self blue shades: n+1.	s4 _ s4 copyFrom: 2 to: n+1.	s5 _ self blue mix: self black shades: n+1.	s5 _ s5 copyFrom: 2 to: n+1.	^ s1, s2, s3, s4, s5! !!Color class methodsFor: 'examples'!showColorCube	"Show a 12x12x12 color cube."	"Color showColorCube"	0 to: 11 do: [:r |		0 to: 11 do: [:g |			0 to: 11 do: [:b |					Display fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)					fillColor: (Color r: r g: g b: b range: 11)]]].! !!Color class methodsFor: 'examples'!showColors: colorList	"Display the given collection of colors across the top of the Display."	| w r |	w _ Display width // colorList size.	r _ 0@0 extent: w@((w min: 30) max: 10).	colorList do: [:c |		Display fill: r fillColor: c.		r _ r translateBy: w@0].! !!Color class methodsFor: 'examples'!showHSVPalettes	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."	"Color showHSVPalettes"	| left top c |	left _ top _ 0.	0 to: 179 by: 15 do: [:h |		0 to: 10 do: [:s |			left _ (h * 4) + (s * 4).			0 to: 10 do: [:v |				c _ Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.				top _ (v * 4).				Display fill: (left@top extent: 4@4) fillColor: c.				c _ Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.				top _ (v * 4) + 50.				Display fill: (left@top extent: 4@4) fillColor: c]]].! !!Color class methodsFor: 'examples'!showHuesInteractively	"Shows a palette of hues at a (saturation, brightness) point determined by the mouse position. Click the mouse button to exit and return the selected (saturation, brightness) point."	"Color showHuesInteractively"	| p s v |	[Sensor anyButtonPressed] whileFalse: [		p _ Sensor cursorPoint.		s _ p x asFloat / 300.0.		v _ p y asFloat / 300.0.		self showColors: (self wheel: 12 saturation: s brightness: v)].	^ (s min: 1.0) @ (v min: 1.0)! !!Color class methodsFor: 'examples'!wheel: thisMany	"Return a collection of thisMany colors evenly spaced around the color wheel."	"Color showColors: (Color wheel: 12)"	^ Color wheel: thisMany saturation: 0.9 brightness: 0.7! !!Color class methodsFor: 'examples'!wheel: thisMany saturation: s brightness: v	"Return a collection of thisMany colors evenly spaced around the color wheel, all of the given saturation and brightness."	"Color showColors: (Color wheel: 12 saturation: 0.4 brightness: 1.0)"	"Color showColors: (Color wheel: 12 saturation: 0.8 brightness: 0.5)"	^ (Color h: 0.0 s: s v: v) wheel: thisMany! !!Color class methodsFor: 'named colors'!brown	^Brown! !!Color class methodsFor: 'named colors'!opaqueMask	^OpaqueMask! !!Color class methodsFor: 'named colors'!orange	^Orange! !!Color class methodsFor: 'named colors'!transparent	^Transparent! !!Color class methodsFor: 'named colors'!veryVeryDarkGray	^VeryVeryDarkGray! !!Color class methodsFor: 'named colors'!veryVeryLightGray	^VeryVeryLightGray! !!Color class methodsFor: 'colormaps' stamp: 'jm 11/12/97 19:16'!cachedColormapFrom: sourceDepth to: destDepth	"Return a cached colormap for mapping between the given depths. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."	| key newMap |	key _ sourceDepth@destDepth.	CachedColormaps == nil ifTrue: [CachedColormaps _ Dictionary new].	^ CachedColormaps at: key ifAbsent: [		newMap _ self computeColormapFrom: sourceDepth to: destDepth.		CachedColormaps at: key put: newMap.		((sourceDepth >= 16) and: [destDepth < 16]) ifTrue: [			"can use the same map from both 16-bits and 32-bits to a given lesser depth"			CachedColormaps at: 16@destDepth put: newMap.			CachedColormaps at: 32@destDepth put: newMap].		newMap].! !!Color class methodsFor: 'colormaps'!colorMapIfNeededFrom: sourceDepth to: destDepth	"Return a colormap for mapping between the given depths, or nil if no colormap is needed."	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"	sourceDepth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"	(sourceDepth >= 16) & (destDepth >= 16) ifTrue: [		"mapping is done in BitBlt by zero-filling or truncating each color component"		^ nil].	^ Color cachedColormapFrom: sourceDepth to: destDepth! !!Color class methodsFor: 'colormaps' stamp: 'jm 12/5/97 18:27'!computeColormapFrom: sourceDepth to: destDepth	"Compute a colorMap for translating between the given depths. A colormap is a Bitmap whose entries contain the pixel values for the destination depth. Typical clients use cachedColormapFrom:to: instead."	| map |	sourceDepth < 16 ifTrue: [		"source is 1-, 2-, 4-, or 8-bit indexed color"		map _ (IndexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))					collect: [:c | c pixelValueForDepth: destDepth].		map _ map as: Bitmap.	] ifFalse: [		"source is 16-bit or 32-bit RGB; use colormap with 4 bits per color component"		map _ self computeRGBColormapFor: destDepth bitsPerColor: 4].	"Note: zero is transparent except when source depth is one-bit deep"	sourceDepth > 1 ifTrue: [map at: 1 put: 0].	^ map! !!Color class methodsFor: 'colormaps' stamp: 'jm 12/4/97 15:25'!computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."	| mask map c |	(#(3 4 5) includes: bitsPerColor)		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].	mask _ (1 bitShift: bitsPerColor) - 1.	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).	0 to: map size - 1 do: [:i |		c _ Color			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)			b: ((i bitShift: 0) bitAnd: mask)			range: mask.		map at: i + 1 put: (c pixelValueForDepth: destDepth)].	map at: 1 put: (Color transparent pixelWordForDepth: destDepth).  "zero always transparent"	^ map! !!Color class methodsFor: 'other'!colorNames	"Return a collection of color names."	^ ColorNames! !!Color class methodsFor: 'other'!maskingMap: depth	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero. Cache the most recently used map."	| sizeNeeded |	depth <= 8		ifTrue: [sizeNeeded _ 1 bitShift: depth]		ifFalse: [sizeNeeded _ 4096].	MaskingMap size = sizeNeeded ifTrue: [^ MaskingMap].	MaskingMap _ Bitmap new: sizeNeeded withAll: 16rFFFFFFFF.	MaskingMap at: 1 put: 0.  "transparent"	^ MaskingMap! !!Color class methodsFor: 'other'!pixelScreenForDepth: depth	"Return a 50% stipple containing alternating pixels of all-zeros and all-ones to be used as a mask at the given depth."	| mask bits |	mask _ (1 bitShift: depth) - 1.	bits _ 2 * depth.	[bits >= 32] whileFalse: [		mask _ mask bitOr: (mask bitShift: bits).  "double the length of mask"		bits _ bits + bits].	^ Bitmap with: mask with: mask bitInvert32! !!Color class methodsFor: 'other'!shutDown	"Color shutDown"	ColorChart _ nil.		"Palette of colors for the user to pick from"	CachedColormaps _ nil.	"Maps to translate between color depths"	MaskingMap _ nil.		"Maps all colors except transparent to black for creating a mask"! !!Color class methodsFor: 'color from user' stamp: 'jm 12/5/97 18:35'!colorPaletteForDepth: depth extent: chartExtent	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."	"Note: It is slow to build this palette, so it should be cached for quick access."	"(Color colorPaletteForDepth: 16 extent: 190@60) display"	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |	palette _ Form extent: chartExtent depth: depth.	transCaption _ "(DisplayText text: 'no color' asText textStyle: (TextConstants at: #ComicPlain)) form storeString"		(Form extent: 34@9 depth: 1			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)			offset: 0@0).	transHt _ transCaption height.	palette fillWhite: (0@0 extent: palette width@transHt).	palette fillBlack: (0@transHt extent: palette width@1).	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).	grayWidth _ 10.	startHue _ 338.0.	vSteps _ palette height - transHt // 2.	hSteps _ palette width - grayWidth.	x _ 0.	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.		y _ transHt+1.		0 to: vSteps do: [:n | 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.			palette fill: (x@y extent: 1@1) fillColor: c.			y _ y + 1].		1 to: vSteps do: [:n | 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.			palette fill: (x@y extent: 1@1) fillColor: c.			y _ y + 1].		x _ x + 1].	y _ transHt + 1.	1 to: vSteps * 2 do: [:n | 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.		palette fill: (x@y extent: 10@1) fillColor: c.		y _ y + 1].	^ palette! !!Color class methodsFor: 'color from user' stamp: 'jm 12/4/97 10:32'!fromUser	"Displays a color palette of colors, waits for a mouse click, and returns the selected color. Any pixel on the Display can be chosen, not just those in the color palette."	"Note: Since the color chart is cached, you may need to do 'ColorChart _ nil' after changing the oldColorPaletteForDepth:extent: method."	"Color fromUser"	| d startPt save tr oldColor c here s |	d _ Display depth.	((ColorChart == nil) or: [ColorChart depth ~= Display depth]) 		ifTrue: [ColorChart _ self oldColorPaletteForDepth: d extent: (2 * 144)@80].	Sensor cursorPoint y < Display center y 		ifTrue: [startPt _ 0@(Display boundingBox bottom - ColorChart height)]		ifFalse: [startPt _ 0@0].	save _ Form fromDisplay: (startPt extent: ColorChart extent).	ColorChart displayAt: startPt.	tr _ ColorChart extent - (50@19) corner: ColorChart extent.	tr _ tr translateBy: startPt.	oldColor _ nil.	[Sensor anyButtonPressed] whileFalse: [		c _ Display colorAt: (here _ Sensor cursorPoint).		(tr containsPoint: here)			ifFalse: [Display fill: (0@61+startPt extent: 20@19) fillColor: c]			ifTrue: [				c _ Color transparent.				Display fill: (0@61+startPt extent: 20@19) fillColor: Color white].		c = oldColor ifFalse: [			Display fillWhite: (20@61 + startPt extent: 135@19).			c isTransparent				ifTrue: [s _ c shortPrintString]				ifFalse: [					s _ c shortPrintString.					s _ s copyFrom: 7 to: s size - 1].			s displayAt: 20@61 + startPt.			oldColor _ c]].	save displayAt: startPt.	Sensor waitNoButton.	^ c! !!Color class methodsFor: 'color from user' stamp: 'jm 12/5/97 18:34'!oldColorPaletteForDepth: depth extent: paletteExtent	"Returns a form of the given size showing a color palette for the given depth."	"(Color oldColorPaletteForDepth: Display depth extent: 720@100) display"	| c p f nSteps rect w h q |	f _ Form extent: paletteExtent depth: depth.	f fill: f boundingBox fillColor: Color white.	nSteps _ depth > 8 ifTrue: [12] ifFalse: [6].	w _ paletteExtent x // (nSteps * nSteps).	h _ paletteExtent y - 20 // nSteps.	0 to: nSteps-1 do: [:r |		0 to: nSteps-1 do: [:g |			0 to: nSteps-1 do: [:b |				c _ Color r: r g: g b: b range: nSteps - 1.				rect _ ((r * nSteps * w) + (b * w)) @ (g * h) extent: w@(h + 1).				f fill: rect fillColor: c]]].	q _ Quadrangle origin: paletteExtent - (50@19) corner: paletteExtent.	q displayOn: f.	('Trans.' asParagraph asForm) displayOn: f at: q origin + (9@0) rule: Form paint.	w _ ((paletteExtent x - q width - 130) // 64) max: 1.	p _ paletteExtent x - q width - (64 * w) - 1 @ (paletteExtent y - 19).	0 to: 63 do:		[:v | c _ Color r: v g: v b: v range: 63.		f fill: ((v * w)@0 + p extent: (w + 1)@19) fillColor: c].	^ f! !ColorForm comment:'ColorForm is a normal Form plus a color map of up to 2^depth Colors. Typically, one reserves one entry in the color map for transparent. This allows 1, 3, 15, or 255 non-transparent colors in ColorForms of depths 1, 2, 4, and 8 bits per pixel. ColorForms don''t support depths greater than 8 bits because that would require excessively large color maps with little real benefit, since 16-bit and 32-bit depths already support thousands and millions of colors.ColorForms have several uses:  1) Precise colors. You can have up to 256 true colors, instead being limited to the 8-bit color palette.  2) Easy transparency. Just store (Color transparent) at the desired position in the color map.  3) Cheap color remapping by changing the color map.A color map is an Array of up to 2^depth Color objects. A Bitmap colorMap is automatically computed and cached for rapid display. Note that if you change the color map, you must resubmit it via the colors: method to flush this cache.ColorForms can be a bit tricky. Note that:  a) When you BitBlt from one ColorForm to another, you must remember to copy the color map of the source ColorForm to the destination ColorForm.  b) A ColorForm''s color map is an array of depth-independent Color objects. BitBlt requires a BitMap of actual pixel values, adjusted to the destination depth. These are different things!! ColorForms automatically maintain a cache of the BitBlt-style color map corresponding to the colors array for the last depth on which the ColorForm was displayed, so there should be little need for clients to work with BitBlt-style color maps.'!!ColorForm methodsFor: 'accessing' stamp: 'jm 11/14/97 17:39'!colors	"Return my color palette."	self ensureColorArrayExists.	^ colors! !!ColorForm methodsFor: 'accessing'!colors: colorList	"Set my color palette to the given collection."	| colorArray colorCount newColors |	colorList ifNil: [		colors _ cachedDepth _ cachedColormap _ nil.		^ self].	colorArray _ colorList asArray.	colorCount _ colorArray size.	newColors _ Array new: (1 bitShift: depth).	1 to: newColors size do: [:i |		i <= colorCount			ifTrue: [newColors at: i put: (colorArray at: i)]			ifFalse: [newColors at: i put: Color transparent]].	colors _ newColors.	cachedDepth _ nil.	cachedColormap _ nil.! !!ColorForm methodsFor: 'displaying'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: rule fillColor: aForm	aDisplayMedium copyBits: self boundingBox		from: self		at: aDisplayPoint + self offset		clippingBox: clipRectangle		rule: rule		fillColor: aForm		map: (self colormapIfNeededForDepth: aDisplayMedium depth).! !!ColorForm methodsFor: 'displaying' stamp: 'di 7/17/97 10:04'!displayOnPort: port at: location	port copyForm: self to: location rule: Form paint! !!ColorForm methodsFor: 'pixel accessing' stamp: 'jm 11/14/97 17:25'!colorAt: aPoint	"Return the color of the pixel at aPoint."	^ self colors at: (self pixelValueAt: aPoint) + 1! !!ColorForm methodsFor: 'pixel accessing' stamp: 'jm 11/14/97 17:25'!colorAt: aPoint put: aColor	"Store the given color into the pixel at aPoint. The given color must match one of the colors in the receiver's colormap."	| i |	i _ self colors indexOf: aColor		ifAbsent: [^ self error: 'trying to use a color that is not in my colormap'].	self pixelValueAt: aPoint put: i - 1.! !!ColorForm methodsFor: 'pixel accessing' stamp: 'tk 10/21/97 12:27'!isTransparentAt: aPoint 	"Return true if the receiver is transparent at the given point."	^ (self colorAt: aPoint) isTransparent! !!ColorForm methodsFor: 'pixel accessing' stamp: 'jm 11/16/97 10:43'!pixelValueAt: aPoint 	"Return the raw pixel value at the given point. Typical clients use colorAt: to get a Color."	"Details: To get the raw pixel value, be sure the peeker's colorMap is nil."	^ (BitBlt bitPeekerFromForm: self) colorMap: nil; pixelAt: aPoint! !!ColorForm methodsFor: 'other'!colormapIfNeededForDepth: destDepth	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."	| newMap |	colors == nil ifTrue: [		"use the standard colormap"		^ Color colorMapIfNeededFrom: depth to: destDepth].	destDepth = cachedDepth ifTrue: [^ cachedColormap].	newMap _ Bitmap new: colors size.	1 to: colors size do: [:i |		newMap			at: i			put: ((colors at: i) pixelValueForDepth: destDepth)].	cachedDepth _ destDepth.	^ cachedColormap _ newMap.! !!ColorForm methodsFor: 'other' stamp: 'jm 11/14/97 17:29'!colorsUsed	"Return a list of the colors acutally used by this ColorForm."	| myColor list |	myColor _ self colors.	list _ OrderedCollection new.	self tallyPixelValues doWithIndex: [:count :i |		count > 0 ifTrue: [list add: (myColor at: i)]].	^ list asArray! !!ColorForm methodsFor: 'other' stamp: 'jm 11/16/97 11:18'!ensureTransparentColor	"Ensure that the receiver (a) includes Color transparent in its color map and (b) that the entry for Color transparent is the first entry in its color map."	| i |self error: 'not yet implemented'.	(colors includes: Color transparent)		ifTrue: [			(colors indexOf: Color transparent) = 1 ifTrue: [^ self].			"shift the entry for color transparent"]		ifFalse: [			i _ self unusedColormapEntry.			i = 0 ifTrue: [self error: 'no color map entry is available'].			colors at: i put: Color transparent.			"shift the entry for color transparent"].! !!ColorForm methodsFor: 'other' stamp: 'jm 11/16/97 09:13'!readFrom: aFile	self error: 'not yet implemented'.! !!ColorForm methodsFor: 'other' stamp: 'jm 11/16/97 09:08'!replaceColor: oldColor with: newColor	"Replace all occurances of the given color with the given new color in my color map."	self ensureColorArrayExists.	1 to: colors size do: [:i | 		(colors at: i) = oldColor ifTrue: [colors at: i put: newColor]].	self clearColormapCache.! !!ColorForm methodsFor: 'other' stamp: 'jm 11/16/97 09:09'!transparentColor: aColor	"Make all occurances of the given color transparent."	self replaceColor: aColor with: Color transparent.! !!ColorForm methodsFor: 'other'!twoToneFromDisplay: aRectangle backgroundColor: bgColor	"Copy one-bit deep ColorForm from the Display using a color map that maps all colors except the background color to black. Used for caching the contents of inactive MVC windows."	| map |	(width = aRectangle width and: [height = aRectangle height])		ifFalse: [self setExtent: aRectangle extent depth: depth].	"make a color map mapping the background color	 to zero and all other colors to one"	map _ Bitmap new: (1 bitShift: (Display depth min: 9)).	1 to: map size do: [:i | map at: i put: 16rFFFFFFFF].	map at: (bgColor indexInMap: map) put: 0.	(BitBlt toForm: self)		destOrigin: 0@0;		sourceForm: Display;		sourceRect: aRectangle;		combinationRule: Form over;		colorMap: map;		copyBits.! !!ColorForm methodsFor: 'copying' stamp: 'tk 10/19/97 15:26'!deepCopy	| newForm |	newForm _ self shallowCopy.	newForm bits: (bits class new: self bitsSize).	newForm colors: nil.	newForm copyBits: self boundingBox		from: self		at: 0 @ 0		clippingBox: newForm boundingBox		rule: Form over		fillColor: nil		map: (self colormapIfNeededForDepth: newForm depth).	^newForm! !!ColorForm methodsFor: 'private' stamp: 'jm 11/16/97 09:07'!clearColormapCache	cachedDepth _ nil.	cachedColormap _ nil.! !!ColorForm methodsFor: 'private' stamp: 'jm 11/16/97 09:12'!depth: bitsPerPixel	bitsPerPixel > 8 ifTrue: [self error: 'ColorForms only support depths up to 8 bits'].	super depth: bitsPerPixel.! !!ColorForm methodsFor: 'private' stamp: 'jm 11/16/97 08:37'!ensureColorArrayExists	"Return my color palette."	colors ifNil: [		depth > 8 ifTrue: [^ self error: 'ColorForms only support depths up to 8 bits'].		self colors: (Color indexedColors copyFrom: 1 to: (1 bitShift: depth))].! !!ColorForm methodsFor: 'private' stamp: 'jm 11/16/97 08:37'!setExtent: extent depth: bitsPerPixel	"Create a virtual bit map with the given extent and bitsPerPixel."	bitsPerPixel > 8 ifTrue: [self error: 'ColorForms only support depths up to 8 bits'].	super setExtent: extent depth: bitsPerPixel.! !!ColorForm methodsFor: 'private' stamp: 'jm 11/16/97 11:15'!unusedColormapEntry	"Return an unused color map entry."	| tallies |	tallies _ self tallyPixelValues.	1 to: tallies size do: [:i |		(tallies at: i) = 0 ifTrue: [^ i]].! !!ColorForm class methodsFor: 'all' stamp: 'jm 11/16/97 09:17'!mappingWhiteToTransparentFrom: aFormOrCursor	"Return a ColorForm copied from the given Form or Cursor with white mapped to transparent."	| f map |	aFormOrCursor depth <= 8 ifFalse: [		^ self error: 'argument depth must be 8-bits per pixel or less'].	(aFormOrCursor isKindOf: ColorForm) ifTrue: [		f _ aFormOrCursor deepCopy.		map _ aFormOrCursor colors.	] ifFalse: [		f _ ColorForm extent: aFormOrCursor extent depth: aFormOrCursor depth.		f copyBits: aFormOrCursor boundingBox			from: aFormOrCursor			at: 0@0			clippingBox: aFormOrCursor boundingBox			rule: Form over			fillColor: nil.		map _ Color indexedColors copyFrom: 1 to: (1 bitShift: aFormOrCursor depth)].	map _ map collect: [:c |		c = Color white ifTrue: [Color transparent] ifFalse: [c]].	f colors: map.	^ f! !!ColorForm class methodsFor: 'all'!twoToneFromDisplay: aRectangle using: oldForm backgroundColor: bgColor	"Return a 1-bit deep ColorForm copied from the given rectangle of the display. All colors except the background color will be mapped to black."	| f |	((oldForm ~~ nil) and: [oldForm extent = aRectangle extent]) ifTrue: [		f _ oldForm fromDisplay: aRectangle.	] ifFalse: [		f _ ColorForm extent: aRectangle extent depth: 1.		f twoToneFromDisplay: aRectangle backgroundColor: bgColor.		f colors: (Array			with: bgColor			with: Color black)].	^ f! !!ColorMemory2Morph methodsFor: 'as yet unclassified' stamp: 'tk 10/21/97 11:32'!click: evt	| col |	locOfCurrent _ evt cursorPoint - self topLeft.	locOfCurrent y < 16 ifTrue: [col _ Color transparent]			ifFalse: [col _ image colorAt: locOfCurrent].	prevColor _ currentColor.	currentColor _ col.	owner class == PaintBoxMorph ifTrue: [			owner takeColorEvt: evt from: self].	self invalidRect: (self bounds).! !!ColorMemory2Morph methodsFor: 'as yet unclassified' stamp: 'tk 9/16/97 19:27'!currentColor	^ currentColor! !!ColorMemory2Morph methodsFor: 'as yet unclassified' stamp: 'tk 10/21/97 10:51'!currentColor: aColor	"Force me to select the closest color to this"	prevColor _ currentColor.	locOfCurrent _ nil.	^ currentColor _ aColor	"We don't know where to put the marker"! !!ColorMemory2Morph methodsFor: 'as yet unclassified' stamp: 'tk 10/21/97 10:47'!drawOn: aCanvas 	"Image plus circles for selected places."	| formCanvas ring |	super drawOn: aCanvas.	"Is canvas always a FormCanvas?"	formCanvas _ aCanvas.	locOfCurrent ifNotNil: [		ring _ currentColor  contrastingRed. 		formCanvas fillOval: (Rectangle center: locOfCurrent + self topLeft extent: 9@9) 				color: Color transparent				borderWidth: 1 borderColor: ring].! !!ColorMemory2Morph methodsFor: 'as yet unclassified' stamp: 'tk 10/31/97 13:51'!feedback: evt	| col loc |	loc _ evt cursorPoint - self topLeft.	loc y < 16 ifTrue: [col _ Color transparent]			ifFalse: [col _ image colorAt: loc].	Display fill: (owner colorPatch bounds translateBy: self world viewBox origin) 			fillColor: col.! !!ColorMemory2Morph methodsFor: 'as yet unclassified' stamp: 'tk 10/31/97 13:50'!handlesMouseOver: evt	"Yes, we do mouseMove"	self feedback: evt.	^ true! !!ColorMemory2Morph methodsFor: 'as yet unclassified' stamp: 'tk 10/21/97 10:25'!initialize	super initialize.	currentColor _ Color black.	"prevColor _ nil.	 locOfCurrent _ nil."! !!ColorMemory2Morph methodsFor: 'as yet unclassified' stamp: 'tk 10/31/97 13:58'!mouseLeave: evt	owner invalidRect: owner colorPatch bounds.	"show last truly chosen color"	self delete.	"stop showing me"! !!ColorMemoryMorph methodsFor: 'as yet unclassified' stamp: 'tk 7/8/97 21:09'!classInit	"Set the order of the colors to show the user.  (MineToStd at: index-of-square) = place of that color in Color indexedColors.  	ColorMemoryMorph new classInit"	| grays hues |	grays _ #(1 16 17 18 10 19 20 "83" 21 11 22 23 24 12 "126" 25 26 27 3 28 29 30 "169" 13 31 32 33 14 34 "212" 35 36 15 37 38 39 2).	"0-order"	hues _ (Color indexedColors copyFrom: 41 to: 256) sortBy: [:a :b | a brightness < b brightness]."	hues _ hues sortBy: [:a :b | a hue < b hue]."	hues _ hues collect: [:aColor | (aColor pixelValueForDepth: 8)].	MineToStd _ (grays, hues, #(0 0 0 0 0 0 0)) collect: [:each | each + 1].	StdToMine _ Array new: 256 withAll: 256.	MineToStd doWithIndex: [:each :ind | StdToMine at: each put: ind].! !!ColorMemoryMorph methodsFor: 'as yet unclassified' stamp: 'tk 7/1/97 17:53'!clear	onVector _ Array new: 256 withAll: false.	onVector at: current put: true.! !!ColorMemoryMorph methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 07:34'!currentColor	^ current = 1 ifTrue: [Color transparent]		ifFalse: [Color indexedColors at: current]! !!ColorMemoryMorph methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 07:32'!currentColor: aColor	"Force me to select the closest color to this"	self invalidRect: (self rectFromIndex: current).	current _ Color transparent = aColor 		ifFalse: [(aColor pixelValueForDepth: 8) + 1]		ifTrue: [1].	onVector at: current put: true.	self invalidRect: (self rectFromIndex: current).! !!ColorMemoryMorph methodsFor: 'as yet unclassified' stamp: 'tk 7/8/97 21:10'!drawOn: aCanvas 	"Fixed bounds for now.  "	| space rect list index |	super drawOn: aCanvas.	self drawSelectionsOn: aCanvas.	space _ 1.	rect _ self topLeft + (space@space) extent: cellSize - (1@1).	list _ Color indexedColors.	"list _ (1 to: 256) collect: [:ind | list at: (MineToStd at: ind)]."	index _ 0.	1 to: 16 do: [:x |		1 to: 16 do: [:y |			aCanvas fillRectangle: rect color: (list at: (index _ index + 1)).			rect _ rect translateBy: (cellSize x @ 0)].		rect _ self bounds left + space @ (rect top + cellSize y) extent: cellSize - (1@1).		].! !!ColorMemoryMorph methodsFor: 'as yet unclassified' stamp: 'tk 6/29/97 15:59'!drawSelectionsOn: aCanvas	"highlight the borders of the colors we have used.  Current Color in black.  tk 6/29/97 15:29"	| rect hilite |	1 to: onVector size do: [:ind |		(onVector at: ind) ifTrue: [			rect _ self rectFromIndex: ind.			aCanvas fillRectangle: rect color: Color black]].	rect _ self rectFromIndex: current.	hilite _ current = 5 "Red" 		ifFalse: [Color red] ifTrue: [Color green].	aCanvas fillRectangle: rect color: hilite.! !!ColorMemoryMorph methodsFor: 'as yet unclassified' stamp: 'jm 6/27/97 13:09'!handlesMouseDown: evt	^ true! !!ColorMemoryMorph methodsFor: 'as yet unclassified' stamp: 'tk 7/1/97 17:43'!indexFromPoint: pt	"Which of 256 colors is the one under the mouse?? pt is relative to bounds topLeft."	| this |	this _ pt y // cellSize y * 16 + (pt x // cellSize x + 1).	^ (this min: 256) max: 1.! !!ColorMemoryMorph methodsFor: 'as yet unclassified' stamp: 'tk 7/8/97 11:49'!initialize	super initialize.	current _ 6.	onVector _ Array new: 256 withAll: false.	onVector at: current put: true.	borderColor _ Color black.	borderWidth _ 1.	cellSize _ 8@8.	"includes 1 pixel spacer"	bounds _ bounds origin extent: cellSize * 16 + (1@1).	StdToMine ifNil: [self classInit].! !!ColorMemoryMorph methodsFor: 'as yet unclassified' stamp: 'tk 7/7/97 22:34'!mark: aColor	"Remember this color"	onVector at: (aColor pixelValueForDepth: 8) + 1 put: true.! !!ColorMemoryMorph methodsFor: 'as yet unclassified' stamp: 'tk 6/29/97 15:51'!mouseDown: evt	"If the shift key is pressed, make this string the keyboard input focus."	self invalidRect: (self rectFromIndex: current).	current _ self indexFromPoint: (evt cursorPoint - self topLeft).	onVector at: current put: true.	self invalidRect: (self rectFromIndex: current).! !!ColorMemoryMorph methodsFor: 'as yet unclassified' stamp: 'tk 7/1/97 17:44'!rectFromIndex: index	"Where is the patch of the Nth color?  Includes one pixel border."	^ self topLeft + (index-1\\16 * cellSize x @ (index-1//16 * cellSize y)) extent: cellSize + (1@1)! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'jm 11/4/97 07:46'!initialize	super initialize.	self form: ColorChart deepCopy.	selectedColor _ Color white.	sourceHand _ nil.	deleteOnMouseUp _ true.	updateContinuously _ true.	selector _ nil.	target _ nil.! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:15'!deleteOnMouseUp	^ deleteOnMouseUp! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:15'!deleteOnMouseUp: aBoolean	deleteOnMouseUp _ aBoolean.! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:15'!selectedColor	^ selectedColor! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:15'!selector	^ selector! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:15'!selector: aSymbol	selector _ aSymbol.! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:15'!sourceHand	^ sourceHand! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:15'!sourceHand: aHand	sourceHand _ aHand.! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:15'!target	^ target! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:15'!target: anObject	target _ anObject.! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!updateContinuously	^ updateContinuously! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!updateContinuously: aBoolean	updateContinuously _ aBoolean.! !!ColorPickerMorph methodsFor: 'event handling' stamp: 'jm 11/4/97 07:15'!handlesMouseDown: evt	^ true! !!ColorPickerMorph methodsFor: 'event handling' stamp: 'jm 11/4/97 07:15'!mouseDown: evt	sourceHand _ evt hand.	self startStepping.! !!ColorPickerMorph methodsFor: 'event handling' stamp: 'jm 11/4/97 07:46'!mouseUp: evt	self stopStepping.	sourceHand _ nil.	deleteOnMouseUp ifTrue: [self delete].	self updateTargetColor.! !!ColorPickerMorph methodsFor: 'stepping' stamp: 'jm 11/4/97 07:15'!step	sourceHand ifNotNil:		[self pickColorAt: sourceHand position].! !!ColorPickerMorph methodsFor: 'stepping' stamp: 'jm 11/4/97 07:15'!stepTime	^ 50! !!ColorPickerMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!pickColorAt: aPoint	| worldBox globalP c |	(FeedbackBox containsPoint: aPoint - self topLeft) ifTrue: [^ self].  "do nothing"	"pick up color, either inside or outside this world"	worldBox _ self world viewBox.	globalP _ aPoint + worldBox topLeft.  "get point in screen coordinates"	(worldBox containsPoint: globalP)		ifTrue: [c _ self world colorAt: aPoint belowMorph: Morph new]		ifFalse: [c _ Display colorAt: globalP].	"check for transparent color and update using appropriate feedback color"	(TransparentBox containsPoint: aPoint - self topLeft)		ifTrue: [self updateColor: Color transparent feedbackColor: Color white]		ifFalse: [self updateColor: c feedbackColor: c].! !!ColorPickerMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:46'!updateColor: aColor feedbackColor: feedbackColor	"Set my selected color to the given color if it is different. Give user feedback. Inform the target of the change if the target and selector are not nil." 	selectedColor = aColor ifTrue: [^ self].  "do nothing if color doesn't change"	originalForm fill: FeedbackBox fillColor: feedbackColor.	self form: originalForm.	selectedColor _ aColor.	updateContinuously ifTrue: [self updateTargetColor].! !!ColorPickerMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:46'!updateTargetColor	((target ~~ nil) and: [selector ~~ nil]) ifTrue: [		selector numArgs = 2			ifTrue: [target perform: selector with: selectedColor with: sourceHand]			ifFalse: [target perform: selector with: selectedColor]].! !!ColorPickerMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	deleteOnMouseUp		ifTrue: [aCustomMenu add: 'stay up' action: #toggleDeleteOnMouseUp]		ifFalse: [aCustomMenu add: 'do not stay up' action: #toggleDeleteOnMouseUp].	updateContinuously		ifTrue: [aCustomMenu add: 'update only at end' action: #toggleUpdateContinuously]		ifFalse: [aCustomMenu add: 'update continuously' action: #toggleUpdateContinuously].! !!ColorPickerMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!toggleDeleteOnMouseUp	deleteOnMouseUp _ deleteOnMouseUp not.! !!ColorPickerMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!toggleUpdateContinuously	updateContinuously _ updateContinuously not.! !!ColorPickerMorph class methodsFor: 'all' stamp: 'jm 12/5/97 18:29'!initialize	"ColorPickerMorph initialize"	ColorChart _ Color colorPaletteForDepth: 16 extent: 190@60.	TransparentBox _ ColorChart boundingBox withHeight: 9.	FeedbackBox _ (ColorChart width-20)@0 extent: 20@9.! !A Comment space for a Web page.!!Comment class methodsFor: 'initialization' stamp: 'mjg 11/10/97 10:44'!initialize	CommentsTable := Dictionary new.! !!Comment class methodsFor: 'initialization' stamp: 'mjg 11/24/97 15:20'!readIn: filename	|f|	f _ ReferenceStream fileNamed: filename.	CommentsTable _ f next.	f close.! !!Comment class methodsFor: 'initialization' stamp: 'mjg 11/24/97 15:20'!saveTo: filename	|f|	f _ ReferenceStream fileNamed: filename.	f nextPut: CommentsTable.	f close.! !!Comment class methodsFor: 'initialization' stamp: 'mjg 11/17/97 14:52'!setUpExample	| newDiscussion |	newDiscussion _ Discussion new.	newDiscussion title: 'pws'.	newDiscussion description: 'Here is a space for talking about the Pluggable Web Server.'.	CommentsTable at: 'pws' put: newDiscussion.! !!Comment class methodsFor: 'URL processing' stamp: 'mjg 11/10/97 11:18'!comments	^CommentsTable! !!Comment class methodsFor: 'URL processing' stamp: 'mjg 12/19/97 13:44'!createComment: request	"Create a new comment from a Web request"	| newNote newMap |	request fields isNil ifTrue: [self error: 'No request to create a comment from!!'].	newNote := Note new.	newMap := URLmap new.	newNote author: (request fields at: 'author' ifAbsent: ['Anonymous']).	newNote title: (request fields at: 'title' ifAbsent: ['Untitled']).	newNote text: (HTMLformatter swikify: 		(request fields at: 'text' ifAbsent: ['Nothing much to say'])		linkhandler: [:phrase | newMap linkFor: phrase from: (request peerName) 			storingTo: OrderedCollection new]).	newNote timestamp: (Date today printString),' ',(Time now printString).	newNote children: OrderedCollection new. "For later addition of threaded comments"	^newNote! !!Comment class methodsFor: 'URL processing' stamp: 'mjg 12/19/97 13:51'!process: request 	"URLs are of the form Comment.commentKey or 	Comment.commentKey.note of Comment.commentKey.gif.		If commentKey is accessed but not created, 	create an empty one.	If note is accessed, display it."	| commentKey noteIndex newNote |	commentKey _ request message at: 2.	(CommentsTable includesKey: commentKey)		ifFalse: 			[CommentsTable at: commentKey put: Discussion new.			(CommentsTable at: commentKey)				title: commentKey.			(CommentsTable at: commentKey)				description: 'Discussion on ' , commentKey].	request fields isNil		ifFalse: 			["Are there input fields?"			newNote _ self createComment: request.			newNote parent: commentKey.			(CommentsTable at: commentKey)				addNote: newNote.			newNote url: ('Comment.',commentKey,'.',				(CommentsTable at: commentKey) notes size printString)].	request message size > 2		ifTrue: 			["There's a note reference or a request for a status image"			noteIndex _ request message at: 3.			noteIndex asUppercase = 'GIF'			ifTrue: [			request reply: (PWS success),(PWS content: 'image/gif').			request reply: (HTMLformatter textToGIF: 				(CommentsTable at: commentKey) status)]			ifFalse: [request reply: (self showNote: ((CommentsTable at: commentKey)						at: noteIndex asNumber))]]		ifFalse: [request reply: (self showComment: (CommentsTable at: commentKey))]! !!Comment class methodsFor: 'URL processing' stamp: 'mjg 11/18/97 10:28'!showComment: aComment	| fileName |	fileName := (ServerAction serverDirectory) , 'ShowComment.html'.	^HTMLformatter evalEmbedded: (FileStream fileNamed: fileName) contentsOfEntireFile with: aComment.! !!Comment class methodsFor: 'URL processing' stamp: 'mjg 11/18/97 10:28'!showNote: aNote	| fileName |	fileName := (ServerAction serverDirectory) , 'ShowNote.html'.	^HTMLformatter evalEmbedded: (FileStream fileNamed: fileName) contentsOfEntireFile with: aNote.! !!CompiledMethod methodsFor: 'initialize-release'!copyWithTrailerBytes: bytes"Testing:	(CompiledMethod compiledMethodAt: #copyWithTrailerBytes:)		tempNamesPut: 'copy end '"	| copy end start |	start _ self initialPC.	end _ self endPC.	copy _ CompiledMethod newMethod: end - start + 1 + bytes size				header: self header.	1 to: self numLiterals do: [:i | copy literalAt: i put: (self literalAt: i)].	start to: end do: [:i | copy at: i put: (self at: i)].	1 to: bytes size do: [:i | copy at: end + i put: (bytes at: i)].	^ copy! !!CompiledMethod methodsFor: 'accessing'!endPC	"Answer the index of the last bytecode."	| flagByte |	flagByte _ self last.	flagByte = 0 ifTrue:		["If last byte = 0, may be either 0, 0, 0, 0 or just 0"		1 to: 4 do: [:i | (self at: self size - i) = 0 ifFalse: [^ self size - i]]].	flagByte < 252 ifTrue:		["Magic sources (tempnames encoded in last few bytes)"		^ self size - self last - 1].	"Normal 4-byte source pointer"	^ self size - 4! !!CompiledMethod methodsFor: 'accessing' stamp: 'jm 9/18/97 21:06'!primitive	"Answer the primitive index associated with the receiver.	Zero indicates that this is not a primitive method.	We currently allow 11 bits of primitive index, but they are in two places	for  backward compatibility.  The time to unpack is negligible,	since the reconstituted full index is stored in the method cache."	| primBits |	primBits _ self header bitAnd: 16r300001FF.	primBits > 16r1FF		ifTrue: [^ (primBits bitAnd: 16r1FF) + (primBits bitShift: -19)]		ifFalse: [^ primBits]! !!CompiledMethod methodsFor: 'accessing' stamp: 'sw 8/15/97 16:17'!selector	"This is slow, so don't call it frivolously"	^ self who last! !!CompiledMethod methodsFor: 'printing'!storeOn: aStream	| noneYet |	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' newMethod: '.	aStream store: self size - self initialPC + 1.	aStream nextPutAll: ' header: '.	aStream store: self header.	aStream nextPut: $).	noneYet _ self storeElementsFrom: self initialPC to: self endPC on: aStream.	1 to: self numLiterals do:		[:index |		noneYet			ifTrue: [noneYet _ false]			ifFalse: [aStream nextPut: $;].		aStream nextPutAll: ' literalAt: '.		aStream store: index.		aStream nextPutAll: ' put: '.		aStream store: (self literalAt: index)].	noneYet ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!CompiledMethod methodsFor: 'printing' stamp: 'jm 9/3/97 11:05'!who 	"Answer an Array of the class in which the receiver is defined and the 	selector to which it corresponds."	Smalltalk allBehaviorsDo:		[:class |		class selectorsDo:			[:sel |			(class compiledMethodAt: sel) == self 				ifTrue: [^Array with: class with: sel]]].	^ Array with: #unknown with: #unknown! !!CompiledMethod methodsFor: 'literals' stamp: 'di 10/17/97 22:38'!hasLiteral: literal 	"Answer whether the receiver references the argument, literal."	<primitive: 132>  "a fast primitive operation equivalent to..."	2 to: self numLiterals + 1 do:		[:index |		literal == (self objectAt: index) ifTrue: [^ true]].	^ false! !!CompiledMethod methodsFor: 'literals' stamp: 'di 8/15/97 09:51'!hasLiteralSuchThat: litBlock	"Answer true if litBlock returns true for any literal in this method, even if imbedded in array structure."	| lit |	2 to: self numLiterals + 1 do:		[:index | lit _ self objectAt: index.		(litBlock value: lit) ifTrue: [^ true].		(lit class == Array and: [lit hasLiteralSuchThat: litBlock]) ifTrue: [^ true]].	^false! !!CompiledMethod methodsFor: 'scanning'!readsField: varIndex 	"Answer whether the receiver loads the instance variable indexed by the 	argument."	self isReturnField ifTrue: [^self returnField + 1 = varIndex].	varIndex <= 16 ifTrue: [^ self scanFor: varIndex - 1].	varIndex <= 64 ifTrue: [^ self scanLongLoad: varIndex - 1].	^ self scanVeryLongLoad: 64 offset: varIndex - 1! !!CompiledMethod methodsFor: 'scanning'!readsRef: literalAssociation 	"Answer whether the receiver loads the argument."	| lit |	lit _ self literals indexOf: literalAssociation ifAbsent: [^false].	lit <= 32 ifTrue: [^self scanFor: 64 + lit - 1].	lit <= 64 ifTrue: [^self scanLongLoad: 192 + lit - 1].	^ self scanVeryLongLoad: 128 offset: lit - 1! !!CompiledMethod methodsFor: 'scanning'!scanFor: byte 	"Answer whether the receiver contains the argument as a bytecode."	^ (InstructionStream on: self) scanFor: [:instr | instr = byte]"Smalltalk browseAllSelect: [:m | m scanFor: 134]"! !!CompiledMethod methodsFor: 'scanning'!scanLongStore: extension 	"Answer whether the receiver contains a long store whose extension is 	the argument."	| scanner |	scanner _ InstructionStream on: self.	^scanner scanFor: 		[:instr |  (instr = 129 or: [instr = 130]) and: [scanner followingByte = extension]]! !!CompiledMethod methodsFor: 'scanning'!scanVeryLongLoad: extension offset: offset	"Answer whether the receiver contains a long load whose extension is the 	argument."	| scanner |	scanner _ InstructionStream on: self.	^ scanner scanFor: [:instr | (instr = 132 and: [scanner followingByte = extension])											and: [scanner thirdByte = offset]]! !!CompiledMethod methodsFor: 'scanning' stamp: 'di 6/25/97 19:08'!scanVeryLongStore: extension offset: offset	"Answer whether the receiver contains a long load with the given offset.	Note that the constant +32 is the known difference between a	store and a storePop for instVars, and it will always fail on literal variables,	but these only use store (followed by pop) anyway."	| scanner ext |	scanner _ InstructionStream on: self.	^ scanner scanFor:		[:instr | (instr = 132 and: [(ext _ scanner followingByte) = extension											or: ["might be a store/pop into rcvr"												ext = (extension+32)]])							and: [scanner thirdByte = offset]]! !!CompiledMethod methodsFor: 'scanning'!sendsToSuper	"Answer whether the receiver sends any message to super."	| scanner |	scanner _ InstructionStream on: self.	^ scanner scanFor: 		[:instr |  instr = 16r85 or: [instr = 16r84						and: [scanner followingByte between: 16r20 and: 16r3F]]]! !!CompiledMethod methodsFor: 'scanning'!writesField: field 	"Answer whether the receiver stores into the instance variable indexed 	by the argument."	self isQuick ifTrue: [^false].	field <= 8 ifTrue: [^ (self scanFor: 96 + field - 1)						or: [self scanLongStore: field - 1]].	field <= 64 ifTrue: [^ self scanLongStore: field - 1].	^ self scanVeryLongStore: 160 offset: field - 1! !!CompiledMethod methodsFor: 'scanning'!writesRef: ref 	"Answer whether the receiver stores the argument."	| lit |	lit _ self literals indexOf: ref ifAbsent: [^false].	lit <= 64 ifTrue: [^ self scanLongStore: 192 + lit - 1].	^ self scanVeryLongStore: 224 offset: lit - 1! !!CompiledMethod methodsFor: 'source code management'!copyWithTempNames: tempNames	| tempStr |	tempStr _ String streamContents:		[:strm | tempNames do: [:n | strm nextPutAll: n; space]].	^ self copyWithTrailerBytes: (self qCompress: tempStr)! !!CompiledMethod methodsFor: 'source code management'!fileIndex	"Answer the index of the sources file on which this method is stored, as follows:		1:	.sources file		2:	.changes file		3 and 4 are also available for future extension of source code management"	self last < 252 ifTrue: [^ 0  "no source"].	^ self last - 251	! !!CompiledMethod methodsFor: 'source code management'!filePosition	"Answer the file position of this method's source code."	| pos |	self last < 252 ifTrue: [^ 0  "no source"].	pos _ 0.	self size - 1 to: self size - 3 by: -1 do: [:i | pos _ pos * 256 + (self at: i)].	^ pos! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 8/15/97 14:27'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| source flagByte |	flagByte _ self last.	flagByte = 0 ifTrue:		["No source pointer -- decompile without temp names"		^ (class decompilerClass new decompile: selector in: class method: self)			decompileString].	flagByte < 252 ifTrue:		["Magic sources -- decompile with temp names"		^ ((class decompilerClass new withTempNames: self tempNames)				decompile: selector in: class method: self)			decompileString].	"Situation normal;  read the sourceCode from the file"	(source _ self getSourceFromFile) == nil ifFalse: [^ source].	"Something really wrong -- decompile blind (no temps)"	^ (class decompilerClass new decompile: selector in: class method: self)			decompileString! !!CompiledMethod methodsFor: 'source code management' stamp: 'tk 12/12/97 13:03'!getSourceFromFile	"Read the source code from file, determining source file index and	file position from the last 3 bytes of this method."	| position |	(position _ self filePosition) = 0 ifTrue: [^ nil].	^ (RemoteString newFileNumber: self fileIndex position: position)			text! !!CompiledMethod methodsFor: 'source code management'!putSource: sourceStr fromParseNode: methodNode class: class category: catName	inFile: fileIndex priorMethod: priorMethod	^ self putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble:			[:file | class printCategoryChunk: catName on: file priorMethod: priorMethod.			file cr]! !!CompiledMethod methodsFor: 'source code management' stamp: '6/5/97 di'!putSource: sourceStr fromParseNode: methodNode class: class category: catName	withStamp: changeStamp inFile: fileIndex priorMethod: priorMethod	^ self putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble:			[:file |			class printCategoryChunk: catName on: file				withStamp: changeStamp priorMethod: priorMethod.			file cr]! !!CompiledMethod methodsFor: 'source code management' stamp: 'tk 12/11/97 16:21'!putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: preambleBlock	"Store the source code for the receiver on an external file.	If no sources are available, i.e., SourceFile is nil, then store	temp names for decompilation at the end of the method.	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,	in each case, storing a 4-byte source code pointer at the method end."	| file remoteString |	(SourceFiles == nil or: [(file _ SourceFiles at: fileIndex) == nil]) ifTrue:		[^ self become: (self copyWithTempNames: methodNode tempNames)].	file setToEnd.	preambleBlock value: file.  "Write the preamble"	remoteString _ RemoteString newString: sourceStr						onFileNumber: fileIndex toFile: file.	file nextChunkPut: ' '; flush.	self setSourcePosition: remoteString position inFile: fileIndex! !!CompiledMethod methodsFor: 'source code management'!qCompress: str	"A very simple text compression routine designed for method temp names.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble.	Last char of str must be a space so it may be dropped without	consequence if output ends on odd nibble."	| charTable odd ix oddNibble |	charTable _  "Character encoding table must match qDecompress:"	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ ByteArray streamContents:		[:strm | odd _ true.  "Flag for odd or even nibble out"		str do:			[:char | ix _ (charTable indexOf: char) - 1.			(ix <= 12 ifTrue: [ix]				ifFalse: [Array with: ix//16+12 with: ix\\16])				do:				[:nibble | (odd _ odd not)					ifTrue: [strm nextPut: oddNibble*16 + nibble]					ifFalse: [oddNibble _ nibble]]].		strm nextPut: strm position]"  | m s |  m _ CompiledMethod new.s _ 'charTable odd ix oddNibble '.^ Array with: s size with: (m qCompress: s) size	with: (m qDecompress: (m qCompress: s))"! !!CompiledMethod methodsFor: 'source code management'!qDecompress: byteArray	"Decompress strings compressed by qCompress:.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble"	|  charTable extended ext |	charTable _  "Character encoding table must match qCompress:"	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ String streamContents:		[:strm | extended _ false.  "Flag for 2-nibble characters"		byteArray do:			[:byte | 			(Array with: byte//16 with: byte\\16)				do:				[:nibble | extended					ifTrue: [strm nextPut: (charTable at: ext*16+nibble + 1). extended _ false]					ifFalse: [nibble < 12 ifTrue: [strm nextPut: (charTable at: nibble + 1)]									ifFalse: [ext _ nibble-12.  extended _ true]]]]]! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 6/15/97 09:14'!setSourcePointer: srcPointer	self setSourcePosition: srcPointer \\ 16r1000000 inFile: srcPointer // 16r1000000! !!CompiledMethod methodsFor: 'source code management'!setSourcePosition: position inFile: fileIndex 	"Store the location of the source code for the receiver in the receiver. The 	location consists of which source file (*.sources or *.changes) and the 	position in that file."	fileIndex > 4 ifTrue: [^ self error: 'invalid file number'].	self at: self size put: 251 + fileIndex.	1 to: 3 do: 		[:i | self at: self size - i put: ((position bitShift: (i-3)*8) bitAnd: 16rFF)].! !!CompiledMethod methodsFor: 'source code management'!setTempNamesIfCached: aBlock	"This is a cache used by the debugger, independent of the storage of	temp names when the system is converted to decompilation with temps."	TempNameCache == nil ifTrue: [^self].	TempNameCache key == self		ifTrue: [aBlock value: TempNameCache value]! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 6/15/97 09:13'!sourcePointer	^ (self fileIndex * 16r1000000) + self filePosition! !!CompiledMethod methodsFor: 'source code management'!tempNames	| byteCount bytes |	byteCount _ self at: self size.	byteCount = 0 ifTrue: [^ Array new].	bytes _ (ByteArray new: byteCount)		replaceFrom: 1 to: byteCount with: self 		startingAt: self size - byteCount.	^ (self qDecompress: bytes) findTokens: ' '! !!CompiledMethod class methodsFor: 'class initialization'!initialize    "CompiledMethod initialize"	"Initialize class variables specifying the size of the temporary frame	needed to run instances of me."	SmallFrame _ 12.	"Context range for temps+stack"	LargeFrame _ 32.! !!CompiledMethod class methodsFor: 'instance creation'!new	"This will not make a meaningful method, but it could be used	to invoke some otherwise useful method in this class."	^ self newMethod: 0 header: 0! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'jm 9/18/97 21:06'!newBytes: numberOfBytes nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit primBits |	largeBit _ (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	primBits _ primitiveIndex <= 16r1FF		ifTrue: [primitiveIndex]		ifFalse: ["For now the high 2 bits of primitive no. are in high bits of header"				(primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r600) bitShift: 19)].	^ self newMethod: numberOfBytes + 4 	" +4 to store source code ptr" 		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primBits! !!Compiler methodsFor: 'public access'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."	| methodNode method value |	class _ (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode _ self translate: sourceStream noPattern: true ifFail:		[^failBlock value].	method _ methodNode generate: #(0 0 0 0).	context == nil		ifTrue: [class addSelector: #DoIt withMethod: method.				value _ receiver DoIt.				class removeSelectorSimply: #DoIt.				^value]		ifFalse: [class addSelector: #DoItIn: withMethod: method.				value _ receiver DoItIn: context.				class removeSelectorSimply: #DoItIn:.				^value]! !!Compiler methodsFor: 'public access'!format: textOrStream in: aClass notifying: aRequestor	"Compile a parse tree from the argument, textOrStream. Answer a string 	containing the original code, formatted nicely.	If the leftShift key is pressed, then decorate the resulting text with	color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode _ self format: sourceStream noPattern: false ifFail: [^nil].	Sensor leftShiftDown		ifTrue: [^ aNode decompileText]		ifFalse: [^ aNode decompileString]! !!CompositionScanner methodsFor: 'scanning' stamp: 'di 11/29/97 08:46'!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	"Set up margins"	leftMargin _ lineRectangle left.	leftSide ifTrue: [leftMargin _ leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	spaceX _ destX _ leftMargin.	rightMargin _ lineRectangle right.	rightSide ifTrue: [rightMargin _ rightMargin - textStyle rightIndent].	lastIndex _ startIndex.	"scanning sets last index"	destY _ lineRectangle top.	lineHeight _ baseline _ 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font"	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle;				leftMargin: leftMargin.		spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern displaying: false.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^ line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!CompositionScanner methodsFor: 'scanning' stamp: 'di 10/29/97 12:17'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	spaceX _ destX _ leftMargin _ aParagraph leftMarginForCompositionForLine: lineIndex.	destY _ 0.	rightMargin _ aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex _ startIndex.	"scanning sets last index"	lineHeight _ textStyle lineGrid.  "may be increased by setFont:..."	baseline _ textStyle baseline.	self setStopConditions.	"also sets font"	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern displaying: false.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!CompositionScanner methodsFor: 'scanning' stamp: 'di 10/24/97 09:15'!setActualFont: aFont	"Keep track of max height and ascent for auto lineheight"	| descent |	super setActualFont: aFont.	lineHeight == nil		ifTrue: [descent _ font descent.				baseline _ font ascent.				lineHeight _ baseline + descent]		ifFalse: [descent _ lineHeight - baseline max: font descent.				baseline _ baseline max: font ascent.				lineHeight _ lineHeight max: baseline + descent]! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'di 11/10/97 10:35'!crossedX	"There is a word that has fallen across the right edge of the composition 	rectangle. This signals the need for wrapping which is done to the last 	space that was encountered, as recorded by the space stop condition."	spaceCount >= 1 ifTrue:		["The common case. First back off to the space at which we wrap."		line stop: spaceIndex.		lineHeight _ lineHeightAtSpace.		baseline _ baselineAtSpace.		spaceCount _ spaceCount - 1.		spaceIndex _ spaceIndex - 1.		"Check to see if any spaces preceding the one at which we wrap.			Double space after punctuation, most likely."		[(spaceCount > 1 and: [(text at: spaceIndex) = Space])]			whileTrue:				[spaceCount _ spaceCount - 1.				"Account for backing over a run which might					change width of space."				font _ text fontAt: spaceIndex withStyle: textStyle.				spaceIndex _ spaceIndex - 1.				spaceX _ spaceX - (font widthOf: Space)].		line paddingWidth: rightMargin - spaceX.		line internalSpaces: spaceCount]	ifFalse:		["Neither internal nor trailing spaces -- almost never happens."		lastIndex _ lastIndex - 1.		[destX <= rightMargin]			whileFalse:				[destX _ destX - (font widthOf: (text at: lastIndex)).				lastIndex _ lastIndex - 1].		spaceX _ destX.		line paddingWidth: rightMargin - destX.		line stop: (lastIndex max: line first)].	^true! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'di 11/13/97 12:13'!placeEmbeddedObject: anchoredMorph	| descent |	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	descent _ lineHeight - baseline.	lineHeight _ lineHeight max: anchoredMorph height.	baseline _ lineHeight - descent.	^ true! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'di 11/5/97 07:46'!space	"Record left x and character index of the space character just encounted. 	Used for wrap-around. Answer whether the character has crossed the 	right edge of the composition rectangle of the paragraph."	spaceX _ destX.	destX _ spaceX + spaceWidth.	spaceIndex _ lastIndex.	lineHeightAtSpace _ lineHeight.	baselineAtSpace _ baseline.	lastIndex _ lastIndex + 1.	spaceCount _ spaceCount + 1.	destX > rightMargin ifTrue: 	[^self crossedX].	^false! !ConciseInspector comment:'An Inspector that omits the self and all inst vars lines'!!ContextPart methodsFor: 'instruction decoding' stamp: 'sn 8/21/97 22:15'!send: selector super: superFlag numArgs: numArgs	"Simulate the action of bytecodes that send a message with selector, 	selector. The argument, superFlag, tells whether the receiver of the 	message was specified with 'super' in the source method. The arguments 	of the message are found in the top numArgs locations on the stack and 	the receiver just below them."	| receiver arguments answer |	arguments _ Array new: numArgs.	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop].	receiver _ self pop.	(selector == #halt or: [selector == #halt:]) ifTrue:		[self error: 'Cant simulate halt.  Proceed to bypass it.'.		self push: nil. ^self].	selector == #doPrimitive:receiver:args:		ifTrue: [answer _ receiver 					doPrimitive: (arguments at: 1)					receiver: (arguments at: 2)					args: (arguments at: 3).				self push: answer.				^self].	^self send: selector to: receiver with: arguments super: superFlag! !!ContextPart methodsFor: 'debugger access'!mclass 	"Answer the class in which the receiver's method was found."	self receiver class selectorAtMethod: self method setClass: [:mclass].	^mclass! !!ContextPart methodsFor: 'debugger access'!sourceCode	| selector methodClass |	selector _ self receiver class selectorAtMethod: self method		setClass: [:mclass | methodClass _ mclass].	^ methodClass sourceCodeAt: selector! !!ContextPart methodsFor: 'debugger access'!tempNames	"Answer an OrderedCollection of the names of the receiver's temporary 	variables, which are strings."	self method setTempNamesIfCached: [:names | ^names].	names _ (self mclass compilerClass new			parse: self sourceCode			in: self mclass			notifying: nil) tempNames.	self method cacheTempNames: names.	^names! !!ContextPart methodsFor: 'printing'!printOn: aStream 	| selector class |	selector _ 		(class _ self receiver class) 			selectorAtMethod: self method 			setClass: [:mclass].	selector == #?		ifTrue: 			[aStream nextPut: $?; print: self method who.			^self].	aStream nextPutAll: class name.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream nextPutAll: mclass name.			aStream nextPut: $)].	aStream nextPutAll: '>>'.	aStream nextPutAll: selector! !!ContextPart methodsFor: 'system simulation' stamp: 'di 1/5/98 11:20'!completeCallee: aContext	"Simulate the execution of bytecodes until a return to the receiver."	| ctxt current |	ctxt _ aContext.	[ctxt == current or: [ctxt hasSender: self]]		whileTrue: 			[current _ ctxt.			ctxt _ ctxt step].	self stepToSendOrReturn! !!ContextPart methodsFor: 'system simulation' stamp: 'di 1/5/98 11:20'!runSimulated: aBlock contextAtEachStep: block2	"Simulate the execution of the argument, aBlock, until it ends. aBlock 	MUST NOT contain an '^'. Evaluate block2 with the current context 	prior to each instruction executed. Answer the simulated value of aBlock."	| current |	aBlock hasMethodReturn		ifTrue: [self error: 'simulation of blocks with ^ can run loose'].	current _ aBlock.	current pushArgs: Array new from: self.	[current == self]		whileFalse:			[block2 value: current.			current _ current step].	^self pop! !!ContextPart methodsFor: 'system simulation' stamp: 'sn 8/22/97 21:55'!stepToSendOrReturn	"Simulate the execution of bytecodes until either sending a message or 	returning a value to the receiver (that is, until switching contexts)."	[self willReallySend | self willReturn]		whileFalse: [self step]! !!ContextPart methodsFor: 'private' stamp: 'di 1/4/98 23:16'!doPrimitive: primitiveIndex receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message.""	NOTE: In order for perform:WithArguments: to work reliably here,	this method must be forced to invoke a large context.  This is done	by adding extra temps until the following expression evaluates as true:		(ContextPart compiledMethodAt: #doPrimitive:receiver:args:) frameSize > 20"	| value t1 t2 t3 |	"If successful, push result and return resuming context,		else ^ #simulatorFail"	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: 					((BlockContext new: receiver size)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	primitiveIndex = 83 		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	arguments size > 6 ifTrue: [^#simulatorFail].	value _ receiver tryPrimitive: primitiveIndex withArgs: arguments.	value == #simulatorFail		ifTrue: [^ #simulatorFail]		ifFalse: [^ self push: value]! !!ContextPart class methodsFor: 'examples'!tallyInstructions: aBlock	"This method uses the simulator to count the number of occurrences of	each of the Smalltalk instructions executed during evaluation of aBlock.	Results appear in order of the byteCode set."	| tallies |	tallies _ Bag new.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current | tallies add: current nextByte].	^tallies sortedElements	"ContextPart tallyInstructions: [3.14159 printString]"! !!ContextPart class methodsFor: 'examples'!tallyMethods: aBlock	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. Results are given in order of decreasing counts."	| prev tallies |	tallies _ Bag new.	prev _ aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			current == prev ifFalse: "call or return"				[prev sender == nil ifFalse: "call only"					[tallies add: current printString].				prev _ current]].	^tallies sortedCounts	"ContextPart tallyMethods: [3.14159 printString]"! !!ContextPart class methodsFor: 'examples'!trace: aBlock		"ContextPart trace: [3 factorial]"	"This method uses the simulator to print calls and returned values in the Transcript."	| prev |	Transcript clear.	prev _ aBlock.	^ thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			Sensor anyButtonPressed ifTrue: [^ nil].			current == prev				ifFalse:					[prev sender == nil ifTrue:  "returning"						[Transcript space; nextPut: $^; print: current top].					Transcript cr;						nextPutAll: (String new: (current depthBelow: aBlock) withAll: $ );						print: current receiver; space; nextPutAll: current selector; endEntry.					prev _ current]]! !!ContextPart class methodsFor: 'examples'!trace: aBlock onFileNamed: fileName		"ContextPart trace: [3 factorial]"	"This method uses the simulator to print calls to a file."	| prev f sel |	f _ FileStream fileNamed: fileName.	prev _ aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			Sensor anyButtonPressed ifTrue: [^ nil].			current == prev				ifFalse:					[f cr;						nextPutAll: (String new: (current depthBelow: aBlock) withAll: $ );						print: current receiver class; space; nextPutAll: (sel _ current selector); flush.					prev _ current.					sel == #error: ifTrue: [self halt]]].	f close! !!ContextStackListController methodsFor: 'initialize-release'!release	model release.  "restore low space watcher"	super release.! !!ContextStackListController methodsFor: 'menu messages' stamp: 'tao 10/31/97 06:06'!down	"move down the context stack to the previous (enclosing) context"	| index |	index _ model contextStackIndex.	model toggleContextStackIndex: index+1! !!ContextStackListController methodsFor: 'menu messages'!fullStack	"Change from displaying the minimal stack to a full one."	model contextStackList size > 15 "Already expanded"		ifTrue:			[view flash]		ifFalse:			[model contextStackIndex = 0				ifFalse: [model toggleContextStackIndex: model contextStackIndex].			self controlTerminate.			model fullyExpandStack.			self controlInitialize]! !!ContextStackListController methodsFor: 'menu messages'!proceed	"Proceed execution of the receiver's model, starting after the expression at 	which an interruption occurred."	self controlTerminate.	Smalltalk okayToProceedEvenIfSpaceIsLow ifTrue: [		model proceed: view topView controller.	].	self controlInitialize! !!ContextStackListController methodsFor: 'menu messages' stamp: 'tao 10/31/97 06:07'!up	"move up the context stack to the next (enclosed) context"	| index |	index _ model contextStackIndex.	index > 1 ifTrue: [model toggleContextStackIndex: index-1]! !!ContextStackListController methodsFor: 'controlling' stamp: 'tao 10/31/97 06:11'!controlActivity	self processKeyboard.	super controlActivity.! !!ContextStackListController methodsFor: 'sensor access' stamp: 'tao 10/31/97 06:03'!processKeyboard	"Determine whether the user pressed the keyboard, and if the character is	understood as a command"	| char selector |	sensor keyboardPressed		ifTrue:			[char _ sensor keyboard.			selector _ ContextStackKeyboardCommands				at: char				ifAbsent: [nil].			selector isNil				ifTrue: [view flash]				ifFalse: [self perform: selector]]! !!ContextStackListController class methodsFor: 'class initialization' stamp: 'sw 10/31/97 13:46'!initialize	ContextStackListYellowButtonMenu _ 		PopUpMenu labels: 'fullStack (f)restart (r)proceed (p)step (t)send (e)where (w)senders (n)implementors (m)senders of...implementors of...versionsinst var refs...inst var defs...class var refs...class variablesclass refsbrowse fullmore...'	lines: #(6 11 13 16 17).	ContextStackListYellowButtonMessages _ #(fullStack restart proceed step send where  senders implementors sendersOf messages versions browseInstVarRefs browseInstVarDefs classVarRefs browseClassVariables browseClassRefs browseFull shiftedYellowButtonActivity).	ContextStackKeyboardCommands _ Dictionary new		at: $e put: #send;		at: $t put: #step;		at: $p put: #proceed;		at: $r put: #restart;		at: $f put: #fullStack;		at: $w put: #where;		at: $n put: #senders;		at: $m put:	#implementors;		at: 30 asCharacter put: #up;		at: 31 asCharacter put: #down;		yourself.	"ContextStackListController initialize"! !!ContextVariablesInspector methodsFor: 'accessing' stamp: 'sw 9/12/97 21:47'!selectedSlotName	 ^ object tempNames at: (self selectionIndex - 2)! !!ContextVariablesInspector methodsFor: 'selecting'!replaceSelectionValue: anObject 	"Refer to the comment in Inspector|replaceSelectionValue:."	selectionIndex = 1		ifTrue: [^object]		ifFalse: [^object tempAt: selectionIndex - 2 put: anObject]! !!ControlManager methodsFor: 'accessing' stamp: 'sw 9/27/96'!controllersSatisfying: aBlock	"Return a list of scheduled controllers satisfying aBlock.  "	^ scheduledControllers select:		[:aController | (aBlock value: aController) == true]! !!ControlManager methodsFor: 'accessing' stamp: 'sw 10/9/96'!removeAllControllersSatisfying: aBlock	"Unschedule and delete all controllers satisfying aBlock.  May not leave the screen exactly right sometimes. "	(self controllersSatisfying:  aBlock) do:		[:aController | aController closeAndUnschedule]! !!ControlManager methodsFor: 'accessing' stamp: 'di 10/4/97 09:05'!scheduledWindowControllers	"Same as scheduled controllers, but without ScreenController.	Avoids null views just after closing, eg, a debugger."	^ scheduledControllers select:		[:c | c ~~ screenController and: [c view ~~ nil]]! !!ControlManager methodsFor: 'scheduling' stamp: 'sw 9/30/97 13:26'!cmdDotEnabled	^ CmdDotEnabled ~~ false! !!ControlManager methodsFor: 'scheduling' stamp: 'sw 9/30/97 13:26'!cmdDotEnabled: aBoolean	CmdDotEnabled _ aBoolean! !!ControlManager methodsFor: 'scheduling' stamp: 'sw 10/12/97 21:48'!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| controllers labels index listToUse sortAlphabetically |	sortAlphabetically _ Sensor optionKeyPressed.	controllers _ OrderedCollection new.	scheduledControllers do:		[:controller | controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size == 0 ifTrue: [^ self].	listToUse _ sortAlphabetically		ifTrue:			[controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse:			[controllers].	labels _ String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index _ (PopUpMenu labels: labels) startUp.	index > 0 ifTrue:		[self activateController: (controllers at: index)]! !!ControlManager methodsFor: 'scheduling'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| suspendingList newActiveController |	suspendingList _ activeControllerProcess suspendingList.	suspendingList isNil ifTrue: [		activeControllerProcess == Processor activeProcess			ifTrue: [activeControllerProcess suspend].	] ifFalse: [		suspendingList remove: activeControllerProcess.		activeControllerProcess offList].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController _		(DebuggerView			openInterrupt: labelString			onProcess: activeControllerProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!ControlManager methodsFor: 'scheduling' stamp: 'sw 9/30/97 13:27'!maybeForkInterrupt	self cmdDotEnabled ifTrue:		[[self interruptName: 'User Interrupt'] fork]! !!ControlManager methodsFor: 'displaying' stamp: 'di 10/4/97 09:03'!restore	"Clear the screen to gray and then redisplay all the scheduled views.  Try to be a bit intelligent about the view that wants control and not display it twice if possible."	scheduledControllers first view uncacheBits.  "assure refresh"	self unschedule: screenController; scheduleOnBottom: screenController.	screenController view window: Display boundingBox; displayDeEmphasized.	self scheduledWindowControllers reverseDo:		[:aController | aController view displayDeEmphasized].! !!ControlManager methodsFor: 'displaying'!updateGray	"From Georg Gollmann - 11/96.  tell the Screen Controller's model to use the currently-preferred desktop color."	"ScheduledControllers updateGray"	(screenController view model isMemberOf: InfiniteForm)		ifTrue: [screenController view model: (InfiniteForm with:Preferences desktopColor)]! !!ControlManager class methodsFor: 'instance creation' stamp: 'sw 9/30/97 13:25'!initialize	"ControlManager initialize"	CmdDotEnabled _ true! !!ControlManager class methodsFor: 'exchange'!newScheduler: controlManager	"When switching projects, the control scheduler has to be exchanged. The 	active one is the one associated with the current project."	Smalltalk at: #ScheduledControllers put: controlManager.	ScheduledControllers restore.	controlManager searchForActiveController! !!ControlManager class methodsFor: 'snapshots' stamp: 'di 6/16/97 11:42'!shutDown  "Saves space in snapshots"	ScheduledControllers unCacheWindows! !!CRFillInTheBlankController methodsFor: 'sensor access'!dispatchOnCharacter: char with: typeAheadStream	"Accept and terminate the interation if the user hits a CR or the enter key."	(char = Character cr) | (char = Character enter)		ifTrue:			[sensor keyboard.  "gobble the character"			self accept.			^ true]		ifFalse:			[^ super dispatchOnCharacter: char with: typeAheadStream].! !!Cursor class methodsFor: 'constants' stamp: 'sw 8/15/97 13:28'!wait	"Answer the instance of me that is the shape of an Hourglass (was in the 	shape of three small balls)."	^WaitCursor! !CurveFitter class comment:'I represent a conic section determined by three points p1,p2 and p3. I interpolate p1 and p3 and am tangent to line p1,p2 at p1 and line p3,p2 at p3.'!!CurveFitter methodsFor: 'displaying' stamp: '6/9/97 10:16 di'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	| transformedPath newCurveFitter |	transformedPath _ aTransformation applyTo: self.	newCurveFitter _ CurveFitter new.	newCurveFitter firstPoint: transformedPath firstPoint.	newCurveFitter secondPoint: transformedPath secondPoint.	newCurveFitter thirdPoint: transformedPath thirdPoint.	newCurveFitter form: self form.	newCurveFitter		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!CurveFitter class methodsFor: 'examples' stamp: '6/9/97 10:16 di'!example	"Designate three locations on the screen by clicking any button. The	curve determined by the points will be displayed with a long black form."	| aCurveFitter aForm |  	aForm _ Form extent: 1@30.			"make a long thin Form for display "	aForm fillBlack.							"turn it black"	aCurveFitter _ CurveFitter new.	aCurveFitter form: aForm.						"set the form for display"				"collect three Points and show them on the dispaly"	aCurveFitter firstPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter firstPoint.	aCurveFitter secondPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter secondPoint.	aCurveFitter thirdPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter thirdPoint.	aCurveFitter displayOn: Display					"display the CurveFitter"	"CurveFitter example"! !!CurveMorph methodsFor: 'private' stamp: 'di 9/26/97 10:31'!addHandles	super addHandles.	self updateHandles! !!CurveMorph methodsFor: 'private' stamp: '6/9/97 21:28 di'!computeCurve	"Compute an array for the coefficients.  This is copied from Flegal's old	code in the Spline class."	| length extras verts |	verts _ closed ifTrue: [vertices copyWith: vertices first]				ifFalse: [vertices].	length _ verts size.	extras _ 0.	coefficients _ Array new: 8.	1 to: 8 do: [:i | coefficients at: i put: (Array new: length + extras)].	1 to: 5 by: 4 do: 		[:k | 		1 to: length do:			[:i | (coefficients at: k)					at: i put: (k = 1						ifTrue: [(verts at: i) x asFloat]						ifFalse: [(verts at: i) y asFloat])].			1 to: extras do: [:i | (coefficients at: k)					at: length + i put: ((coefficients at: k)						at: i + 1)].			self derivs: (coefficients at: k)				first: (coefficients at: k + 1)				second: (coefficients at: k + 2)				third: (coefficients at: k + 3)].	extras > 0 		ifTrue: [1 to: 8 do: 					[:i | 					coefficients at: i put: ((coefficients at: i)											copyFrom: 2 to: length + 1)]]! !!CurveMorph methodsFor: 'private' stamp: 'di 12/3/97 11:00'!curveBounds	"Compute the bounds from actual curve traversal, with leeway for borderWidth.	Also note the next-to-first and next-to-last points for arrow directions."	| curveBounds |	self computeCurve.	curveBounds _ vertices first corner: vertices last.	ntfPoint _ nil.	self lineSegmentsDo:		[:p1 :p2 | ntfPoint == nil ifTrue: [ntfPoint _ p2 asIntegerPoint].		curveBounds _ curveBounds encompass: p2 asIntegerPoint.		ntlPoint _ p1 asIntegerPoint].	^ curveBounds expandBy: borderWidth+1//2! !!CurveMorph methodsFor: 'private' stamp: '6/9/97 10:32 di'!derivs: a first: point1 second: point2 third: point3	"Compute the first, second and third derivitives (in coefficients) from	the Points in this Path (coefficients at: 1 and coefficients at: 5)."	| len v anArray |	len _ a size.	len < 2 ifTrue: [^self].	len > 2 ifTrue:		[v _ Array new: len.		 v  at: 1 put: 4.0.		 anArray _ Array new: len.		 anArray at: 1 put: (6.0 * ((a at: 1) - ((a at: 2) * 2.0) + (a at: 3))).		 2 to: len - 2 do:			[:i | 			v  at: i put: (4.0 - (1.0 / (v at: i-1))).			anArray at: i 				put: (6.0 * ((a at: i) - ((a at: i+1) * 2.0) + (a at: i+2))						- ((anArray at: i-1) / (v at: i-1)))].		 point2 at: len-1 put: ((anArray at: len-2) / (v at: len-2)).		 len - 2 to: 2 by: 0-1 do: 			[:i | 			point2 at: i 				put: ((anArray at: i-1) - (point2 at: i+1) / (v at: i-1))]].	point2 at: 1 put: (point2 at: len put: 0.0).	1 to: len - 1 do:		[:i | point1 at: i 				put: ((a at: i+1) - (a at: i) - 						((point2 at: i) * 2.0 + (point2 at: i+1) / 6.0)).		      point3 at: i put: ((point2 at: i+1) - (point2 at: i))]! !!CurveMorph methodsFor: 'private' stamp: 'di 12/4/97 09:45'!isCurve	^ true! !!CurveMorph methodsFor: 'private' stamp: 'di 11/29/97 20:54'!lineSegmentsDo: endPointsBlock	"Emit a sequence of line segments into endPointsBlock to approximate this spline."	| n t x y x1 x2 x3 y1 y2 y3 beginPoint endPoint |	vertices size < 1 ifTrue: [^ self].	beginPoint _ (x _ (coefficients at: 1) at: 1) @ (y _ (coefficients at: 5) at: 1).	1 to: (coefficients at: 1) size - 1 do: 		[:i |  "taylor series coefficients"		x1 _ (coefficients at: 2) at: i.		y1 _ (coefficients at: 6) at: i.		x2 _ ((coefficients at: 3) at: i) / 2.0.		y2 _ ((coefficients at: 7) at: i) / 2.0.		x3 _ ((coefficients at: 4) at: i) / 6.0.		y3 _ ((coefficients at: 8) at: i) / 6.0.		"guess n"		n _ 5 max: (x2 abs + y2 abs * 2.0 + ((coefficients at: 3) at: i+1) abs									+ ((coefficients at: 7) at: i+1) abs / 100.0) rounded.		1 to: n - 1 do: 			[:j | 			t _ j asFloat / n.			endPoint _ (x3 * t + x2 * t + x1 * t + x) @ (y3 * t + y2 * t + y1 * t + y).			endPointsBlock value: beginPoint							value: endPoint.			beginPoint _ endPoint].		endPoint _ (x _ (coefficients at: 1) at: i+1) @ (y _ (coefficients at: 5) at: i+1).		endPointsBlock value: beginPoint						value: endPoint.		beginPoint _ endPoint]! !!CurveMorph methodsFor: 'private' stamp: '6/9/97 12:08 di'!nextToFirstPoint  "For arrow direction"	^ ntfPoint! !!CurveMorph methodsFor: 'private' stamp: '6/9/97 12:08 di'!nextToLastPoint  "For arrow direction"	^ ntlPoint! !!CurveMorph methodsFor: 'private' stamp: '6/9/97 13:57 di'!privateMoveBy: delta	super privateMoveBy: delta.	self computeCurve! !!CurveMorph methodsFor: 'private' stamp: 'di 11/29/97 20:57'!updateHandles	| midPts nextVertIx tweens newVert p2i |	midPts _ OrderedCollection new.	nextVertIx _ 2.	tweens _ OrderedCollection new.	self lineSegmentsDo:		[:p1 :p2 | p2i _ p2 asIntegerPoint.		tweens addLast: p2i.		p2i = (vertices atWrap: nextVertIx) ifTrue:			["Found endPoint."			midPts addLast: (tweens at: tweens size // 2)						+ (tweens at: tweens size + 1 // 2) // 2.			tweens _ OrderedCollection new.			nextVertIx _ nextVertIx + 1]].	midPts withIndexDo:		[:midPt :vertIndex |		(closed or: [vertIndex < vertices size]) ifTrue:			[newVert _ handles at: vertIndex*2.			newVert position: midPt - (newVert extent // 2) + (2@0)]].! !CustomMenu comment:'I am used to build menus on-the-fly. I maintain lists of menu items, actions (usually symbols to be sent as messages), and menu section dividing lines to which my clients may append new entries and lines by sending me the messages:	add: aString action: anAction	addLineAfter the menu is constructed, it may be invoked with one of the following messages:	invoke: initialSelection	invokeI am a subclass of ActionMenu, so I inherit a number of instance variables. The ones I am particularly concerned with are:	items _ an OrderedCollection of strings to appear in the menu	selectors _ an OrderedCollection of Symbols to be used as message selectors	lineArray _ an OrderedCollection of line positions	lastLine _ used to keep track of the last line to avoid making duplicate entries in lineArray'!!CustomMenu methodsFor: 'initialize-release'!initialize	labels _ OrderedCollection new.	selections _ OrderedCollection new.	dividers _ OrderedCollection new.	lastDivider _ 0.! !!CustomMenu methodsFor: 'construction'!add: aString action: actionItem	"Add the given string as the next menu item. If it is selected, the given action (usually but not necessarily a symbol) will be returned to the client."	| s |	s _ String new: aString size + 2.	s at: 1 put: Character space.	s replaceFrom: 2 to: s size - 1 with: aString.	s at: s size put: Character space.	labels addLast: s.	selections addLast: actionItem.! !!CustomMenu methodsFor: 'construction'!addLine	"Append a line to the menu after the last entry. Suppress duplicate lines."	(lastDivider ~= selections size) ifTrue: [		lastDivider _ selections size.		dividers addLast: lastDivider].! !!CustomMenu methodsFor: 'construction' stamp: 'sw 8/5/97 13:31'!addList: listOfPairs	"Treating the input parameter as a list of the form (<what to show> <selector>), add items to the receiver for each pair"	listOfPairs do:		[:aPair | self add: aPair first action: aPair last]! !!CustomMenu methodsFor: 'invocation' stamp: 'jm 11/17/97 16:54'!invokeOn: targetObject defaultSelection: defaultSelection	"Invoke the menu with the given default selection (i.e. one of my 'action' symbols). Answer the 'action' selector associated with the menu item chosen by the user or nil if none is chosen."	| sel |	sel _ self startUp: defaultSelection.	sel = nil ifFalse: [		sel numArgs = 0			ifTrue: [^ targetObject perform: sel]			ifFalse: [^ targetObject perform: sel with: nil]].	^ nil! !!CustomMenu methodsFor: 'invocation'!startUp	"Build and invoke this menu with no initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	^ self startUp: nil! !!CustomMenu methodsFor: 'invocation'!startUp: initialSelection	"Build and invoke this menu with the given initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	^ self startUp: initialSelection withCaption: nil! !!CustomMenu methodsFor: 'invocation'!startUp: initialSelection withCaption: caption	"Build and invoke this menu with the given initial selection and caption. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	self build.	(initialSelection notNil) ifTrue: [self preSelect: initialSelection].	^ super startUpWithCaption: caption! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 7/31/97 19:31'!startUpWithCaption: caption	"Build and invoke this menu with no initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen; use the provided caption"	^ self startUp: nil withCaption: caption! !!CustomMenu methodsFor: 'private'!build	"Turn myself into an invokable ActionMenu."	| stream |	stream _ WriteStream on: (String new).	labels do: [: label | stream nextPutAll: label; cr].	(labels isEmpty) ifFalse: [stream skip: -1].  "remove final cr"	self labels: stream contents		font: (TextStyle default fontAt: 1)		lines: dividers.! !!CustomMenu methodsFor: 'private'!preSelect: action	"Pre-select and highlight the menu item associated with the given action."	| i |	i _ selections indexOf: action ifAbsent: [^ self].	marker _ marker		align: marker topLeft		with: (marker left)@(frame inside top + (marker height * (i - 1))).	selection _ i.! !!CustomMenu class methodsFor: 'instance creation'!new	^ super new initialize! !!CustomMenu class methodsFor: 'example'!example	"CustomMenu example"	| menu |	menu _ CustomMenu new.	menu add: 'apples' action: #apples.	menu add: 'oranges' action: #oranges.	menu addLine.	menu addLine.  "extra lines ignored"	menu add: 'peaches' action: #peaches.	menu addLine.	menu add: 'pears' action: #pears.	menu addLine.	^ menu startUp: #apples! !!DamageRecorder methodsFor: 'all'!blackenDamageOn: aCanvas	"For testing. Blackens the damaged rectangles momentarily so you can see the incremental redisplay at work."	| c |	invalidRects do: [:r |		c _ aCanvas copyClipRect: r.		c fillColor: Color black].! !!DamageRecorder methodsFor: 'all'!doFullRepaint	"Record that a full redisplay is needed. No further damage rectangles will be recorded until after the next reset."	^ totalRepaint _ true.! !!DamageRecorder methodsFor: 'all'!invalidRectsFullBounds: aRectangle	"Return a collection of damaged rectangles for the given canvas. If a total repaint has been requested, return the given rectangle."	totalRepaint		ifTrue: [^ Array with: aRectangle]		ifFalse: [^ invalidRects copy].! !!DamageRecorder methodsFor: 'all' stamp: 'di 12/1/97 10:18'!recordInvalidRect: aRectangle	"Record the given rectangle in my damage list, a list of rectagular areas of the display that should be redraw on the next display cycle."	"Details: Damaged rectangles are often identical or overlap significantly. In these cases, we merge them to reduce the number of damage rectangles that must be processed when the display is updated. Moreover, above a certain threshold, we ignore the individual rectangles completely, and simply do a complete repaint on the next cycle."	| mergeRect |	totalRepaint ifTrue: [^ self].  "planning full repaint; don't bother collecting damage"	invalidRects do: [:rect |		(rect intersects: aRectangle) ifTrue: [			"merge rectangle in place (see note below) if there is any overlap"			rect setOrigin: (rect origin min: aRectangle origin) truncated				corner: (rect corner max: aRectangle corner) truncated.			^ self]].	invalidRects size >= 10 ifTrue: [		"if there are too many separate areas, just repaint all"		"totalRepaint _ true.""Note:  The totalRepaint policy has poor behavior when many local rectangles (such as parts of a text selection) force repaint of the entire screen.  As an alternative, this code performs a simple merge of all rects whenever there are more than 10."		mergeRect _ Rectangle merging: invalidRects.		self reset.		invalidRects addLast: mergeRect.		^ self].	"add the given rectangle to the damage list"	"Note: We make a deep copy of all rectangles added to the damage list,	 since rectangles in this list may be extended in place."	invalidRects addLast: (aRectangle topLeft truncated corner: aRectangle bottomRight truncated).! !!DamageRecorder methodsFor: 'all'!reset	"Clear the damage list."	invalidRects _ OrderedCollection new.	totalRepaint _ false.! !!DamageRecorder methodsFor: 'all'!updateIsNeeded	"Return true if the display needs to be updated."	^ totalRepaint or: [invalidRects size > 0]! !!DamageRecorder class methodsFor: 'instance creation'!new	^ super new reset! !DataStream comment:'This is the save-to-disk facility. A DataStream can store one or more objects in a persistent form.To handle objects with sharing and cycles, you must use aReferenceStream instead of a DataStream.  (Or SmartRefStream.)  ReferenceStream is typicallyfaster and produces smaller files because it doesn''t repeatedly write the same Symbols.Here is the way to use DataStream and ReferenceStream:	rr _ ReferenceStream fileNamed: ''test.obj''.	rr nextPut: <your object>.	rr close.To get it back:	rr _ ReferenceStream fileNamed: ''test.obj''.	<your object> _ rr next.	rr close.Each object to be stored has two opportunities to control what gets stored. The high level, more useful hook is objectToStoreOnDataStream [externalize]. The low level hook is storeDataOn:. The read-in counterparts to these messages are comeFullyUpOnReload [internalize] and (class) readDataFrom:size:. See these methods, the class DiskProxy, and the class IOWeakArray for more information about externalizing and internalizing.Public messages:    (class) on:    (class) fileNamed:    (class) fileTypeCode    atEnd    beginInstance:size: (for use by storeDataOn: methods)    beginReference: (for use by readDataFrom:size: methods)    close    next    next:    nextPut:    nextPutAll:    reset    setType:    sizeNOTE: A DataStream should be treated as a read-stream *or* as awrite-stream, *not* as a read/write-stream.[TBD] We should be able to make this much faster via tight-loopbyte-string I/O. It looks like FileStream (and WriteStream)nextPutAll: do a reasonable job *if* it doesn''t have to push thewriteLimit, in which case it iterates with nextPut:. It could in manycases set the writeLimit and then use the fast case(replaceFrom:to:with:startingAt:), or fill a buffer at at time viathe fast case working on a substring.    This approach would handle Strings, ByteArrays, and all othervariable-byte classes. If(nextPutAll: aCollection) in some casesstill reverts to (aCollection do: [:e | self nextPut: e]), then we''dwant to make Obj respond to do:. Then we could speed up innerloop activities like nextPutInt32:.[TBD] Every DataStream should begin with 4 signature bytes."on:" should emit or check the signature. But the current mechanism doesn''t alwaysknow when the stream is started or ended.[TBD] Cf. notes in DataStream>>beginInstance:size: andObject>>readDataFrom:size:.[TBD] We could save disk space & I/O time by using short, 1-byte sizefields whenever possible. E.g. almost all Symbols are shorter than256 chars. We could do this either by (1) using different typeID codesto indicate when a 1-byte length follows, a scheme which could stillread all the old files but would take more code, or (2) avariable-length code for sizes.    -- 11/15/92 jhm'!!DataStream methodsFor: 'all' stamp: '6/9/97 08:14 tk'!beginInstance: aClass size: anInteger	"This is for use by storeDataOn: methods.	 Cf. Object>>storeDataOn:."		"Addition of 1 seems to make extra work, since readInstance		has to compensate.  Here for historical reasons dating back		to Kent Beck's original implementation in late 1988.		In ReferenceStream, class is just 5 bytes for shared symbol.		SmartRefStream puts out the names and number of class's instances variables for checking."	byteStream nextNumber: 4 put: anInteger + 1.	self nextPut: aClass name! !!DataStream methodsFor: 'all'!byteStream	^ byteStream! !!DataStream methodsFor: 'all' stamp: 'tk 8/16/96'!checkForPaths: anObject	"After an object is fully internalized, it should have no PathFromHome in it.	The only exception is Array, as pointed to by an IncomingObjects.  "	| pfh |	pfh _ Smalltalk at: #PathFromHome ifAbsent: [^ self].	1 to: anObject class instSize do:		[:i | (anObject instVarAt: i) class == pfh ifTrue: [			self error: 'Unresolved Path']].! !!DataStream methodsFor: 'all'!close	"Close the stream."	| bytes |	byteStream closed 		ifFalse: [			bytes _ byteStream position.			byteStream close]		ifTrue: [bytes _ 'unknown'].	^ bytes! !!DataStream methodsFor: 'all' stamp: 'tk 7/24/97 18:29'!next	"Answer the next object in the stream."	| type selector anObject isARefType pos |	type _ byteStream next.	type ifNil: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		byteStream position = 0 			ifTrue: [self error: 'The file did not exist in this directory'] 			ifFalse: [self error: 'Unexpected end of object file'].		pos.	"so can see it in debugger"		^ nil].	type = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		self error: 'Expected start of object, but found 0'.		^ nil].	isARefType _ self noteCurrentReference: type.	selector _ #(readNil readTrue readFalse readInteger			readString readSymbol readByteArray			readArray readInstance readReference readBitmap			readClass readUser readFloat readRectangle readShortInst) at: type.	anObject _ self perform: selector. "A method that recursively		calls next (readArray, readInstance, objectAt:) must save &		restore the current reference position."	false ifTrue: ["So Senders will find the perform: here"			self readNil; readTrue; readFalse; readInteger;			readString; readSymbol; readByteArray;			readArray; readInstance; readReference; readBitmap;			readClass; readUser; readFloat; readRectangle; readShortInst].	isARefType ifTrue: [self beginReference: anObject].	"After reading the externalObject, internalize it.	 #readReference is a special case. Either:	   (1) We actually have to read the object, recursively calling		   next, which internalizes the object.	   (2) We just read a reference to an object already read and		   thus already interalized.	 Either way, we must not re-internalize the object here."	selector == #readReference ifFalse:		[anObject _ self internalize: anObject.		self checkForPaths: anObject].	^ anObject! !!DataStream methodsFor: 'all' stamp: 'tk 11/24/97 16:31'!nextAndClose	"Speedy way to grab one object.  Only use when we are inside an object binary file.  Do not use for the start of a SmartRefStream mixed code-and-object file."	| obj |	byteStream peek = 4 ifFalse: ["Try to fix the user's sins..."		self inform: 'Should be using fileInObjectAndCode'.		byteStream ascii.		byteStream fileIn.		obj _ SmartRefStream scannedObject.		SmartRefStream scannedObject: nil.		^ obj].	obj _ self next.	self close.	^ obj! !!DataStream methodsFor: 'all' stamp: 'jhm 11/15/92'!nextPut: anObject	"Write anObject to the receiver stream. Answer anObject.	 NOTE: If anObject is a reference type (one that we write cross-references to) but its externalized form (result of objectToStoreOnDataStream) isn't (e.g. CompiledMethod and ViewState), then we should remember its externalized form but not add to 'references'. Putting that object again should just put its external form again. That's more compact and avoids seeks when reading. But we just do the simple thing here, allowing backward-references for non-reference types like nil. So objectAt: has to compensate. Objects that externalize nicely won't contain the likes of ViewStates, so this shouldn't hurt much.	 : writeReference: -> errorWriteReference:."	| typeID selector objectToStore |	typeID _ self typeIDFor: anObject.	(self tryToPutReference: anObject typeID: typeID)		ifTrue: [^ anObject].	(objectToStore _ anObject objectToStoreOnDataStream) == anObject		ifFalse: [typeID _ self typeIDFor: objectToStore].	byteStream nextPut: typeID.	selector _ #(writeNil: writeTrue: writeFalse: writeInteger: 		writeString: writeSymbol: writeByteArray:		writeArray: writeInstance: errorWriteReference: writeBitmap:		writeClass: writeUser: writeFloat: writeRectangle: == "dummy 16" ) at: typeID.	self perform: selector with: objectToStore.	^ anObject! !!DataStream methodsFor: 'all' stamp: ' 	6/9/97'!objectAt: anInteger	"PRIVATE -- Read & return the object at a given stream position.  08:18 tk  anInteger is a relative file position. "	| savedPosn anObject refPosn |	savedPosn _ byteStream position.	"absolute"	refPosn _ self getCurrentReference.	"relative position"	byteStream position: anInteger + basePos.	"was relative"	anObject _ self next.	self setCurrentReference: refPosn.	"relative position"	byteStream position: savedPosn.		"absolute"	^ anObject! !!DataStream methodsFor: 'all' stamp: '6/9/97 08:46 tk'!outputReference: referencePosn	"PRIVATE -- Output a reference to the object at integer stream position referencePosn (relative to basePos). To output a weak reference to an object not yet written, supply (self vacantRef) for referencePosn."	byteStream nextPut: 10. "reference typeID"	byteStream nextNumber: 4 put: referencePosn	"relative position"! !!DataStream methodsFor: 'all' stamp: '6/9/97 08:32 tk'!readArray	"PRIVATE -- Read the contents of an Array.	 We must do beginReference: here after instantiating the Array	 but before reading its contents, in case the contents reference	 the Array. beginReference: will be sent again when we return to	 next, but that's ok as long as we save and restore the current	 reference position over recursive calls to next."	| count array refPosn |	count _ byteStream nextNumber: 4.	refPosn _ self beginReference: (array _ Array new: count).		"relative pos"	1 to: count do: [:i |		array at: i put: self next].	self setCurrentReference: refPosn.		"relative pos"	^ array! !!DataStream methodsFor: 'all' stamp: 'tk 1/8/97'!readInstance	"PRIVATE -- Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.	Let the instance, not the class read the data.  "	| instSize aSymbol refPosn anObject newClass |	instSize _ (byteStream nextNumber: 4) - 1.	refPosn _ self getCurrentReference.	aSymbol _ self next.	newClass _ Smalltalk at: aSymbol asSymbol.	anObject _ newClass isVariable 	"Create object here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].	self setCurrentReference: refPosn.  "before readDataFrom:size:"	anObject _ anObject readDataFrom: self size: instSize.	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!DataStream methodsFor: 'all' stamp: ' 6/9/97'!readRectangle    "Read a compact Rectangle.  Rectangles with values outside +/- 2047 were stored as normal objects (type=9).  They will not come here.  17:22 tk"	"Encoding is four 12-bit signed numbers.  48 bits in next 6 bytes.  17:24 tk"	| acc left top right bottom |	acc _ byteStream nextNumber: 3.	left _ acc bitShift: -12.	(left bitAnd: 16r800) ~= 0 ifTrue: [left _ left - 16r1000].	"sign"	top _ acc bitAnd: 16rFFF.	(top bitAnd: 16r800) ~= 0 ifTrue: [top _ top - 16r1000].	"sign"	acc _ byteStream nextNumber: 3.	right _ acc bitShift: -12.	(right bitAnd: 16r800) ~= 0 ifTrue: [right _ right - 16r1000].	"sign"	bottom _ acc bitAnd: 16rFFF.	(bottom bitAnd: 16r800) ~= 0 ifTrue: [bottom _ bottom - 16r1000].	"sign"	    ^ Rectangle left: left right: right top: top bottom: bottom! !!DataStream methodsFor: 'all' stamp: ' 6/9/97'!readReference	"PRIVATE -- Read the contents of an object reference. Cf. outputReference:.	11/15/92 jhm: Support weak references.	08:09 tk Data on file is relative to base position (where DataStream took over)."	| referencePosition |	^ (referencePosition _ (byteStream nextNumber: 4)) = self vacantRef	"relative"		ifTrue:  [nil]		ifFalse: [self objectAt: referencePosition]		"relative pos"! !!DataStream methodsFor: 'all' stamp: 'tk 1/8/97'!readShortInst	"Read the contents of an arbitrary instance that has a short header.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.	Let the instance, not the class read the data.  "	| instSize aSymbol refPosn anObject newClass |	instSize _ (byteStream next) - 1.	"one byte of size"	refPosn _ self getCurrentReference.	aSymbol _ self readShortRef.	"class symbol in two bytes of file pos"	newClass _ Smalltalk at: aSymbol asSymbol.	anObject _ newClass isVariable 	"Create object here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].	self setCurrentReference: refPosn.  "before readDataFrom:size:"	anObject _ anObject readDataFrom: self size: instSize.	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!DataStream methodsFor: 'all' stamp: '6/10/97 17:03 tk'!readShortRef	"Read an object reference from two bytes only.  Original object must be in first 65536 bytes of the file."	| referencePosition |	^ (referencePosition _ (byteStream nextNumber: 2)) = self vacantRef	"relative"		ifTrue:  [nil]		ifFalse: [self objectAt: referencePosition]		"relative pos"! !!DataStream methodsFor: 'all' stamp: 'tk 5/29/97'!rootObject	"Return the object at the root of the tree we are filing out.  "	^ topCall! !!DataStream methodsFor: 'all' stamp: 'tk 5/29/97'!rootObject: anObject	"Return the object at the root of the tree we are filing out.  "	topCall _ anObject! !!DataStream methodsFor: 'all' stamp: '6/9/97 08:03 di'!setStream: aStream	"PRIVATE -- Initialization method."	aStream binary.	basePos _ aStream position.	"Remember where we start.  Earlier part of file contains a class or method file-in.  Allow that to be edited.  We don't deal in absolute file locations."	byteStream _ aStream.! !!DataStream methodsFor: 'all' stamp: 'tk 5/13/97'!typeIDFor: anObject	"Return the typeID for anObject's class.  This is where the tangle of objects is clipped to stop everything from going out.  	Other classes can control their instance variables by defining objectToStoreOnDataStream.	Morphs exclude objects not in their tree.  "	| tt |	tt _ anObject ioType.	tt == #User ifTrue: [^ 13].	"HS Object whose class must be reconstructed"	(anObject isKindOf: View) ifTrue: [^ 1 "nil"].	"blocked"	(anObject isKindOf: Controller) ifTrue: [		Transcript cr; show: 'Refused to store a Controller'. ^ 		1 "nil"].	(anObject isKindOf: CompiledMethod) ifTrue: [		Transcript cr; show: 'Refused to store a CompiledMethod'. 		^ 1 "nil"].	(anObject isKindOf: BlockContext) ifTrue: [		Transcript cr; show: 'Refused to store a BlockContext'. 		^ 1 "nil"].	(anObject isMorph) ifTrue: [		(anObject couldBeOwnedBy: self rootObject) 			ifTrue: [^ 9] "normal, might have nil owner"			ifFalse: [^ 1 "Only let out members of our subtree"]].		^ TypeMap at: anObject class ifAbsent: [9 "instance of any normal class"]	"See DataStream initialize.  nil=1. true=2. false=3. a SmallInteger=4. a String=5. a Symbol=6.  a ByteArray=7. an Array=8. other = 9.  a Bitmap=11. a Metaclass=12. a Float=14.  a Rectangle=15. any instance that can have a short header=16."! !!DataStream methodsFor: 'all' stamp: 'jhm 11/15/92'!vacantRef	"Answer the magic 32-bit constant we use ***ON DISK*** as a stream 'reference	 position' to identify a reference that's not yet filled in. This must be a	 value that won't be used as an ordinary reference. Cf. outputReference: and	 readReference. -- 	 NOTE: We could use a different type ID for vacant-refs rather than writing		object-references with a magic value. (The type ID and value are		overwritten by ordinary object-references when weak refs are fullfilled.)"	^ -1! !!DataStream methodsFor: 'all' stamp: 'jm 12/3/97 21:39'!writeBitmap: aBitmap	"PRIVATE -- Write the contents of a Bitmap."	(byteStream isKindOf: DummyStream) ifTrue: [^ self].	aBitmap writeOn: byteStream	"Note that this calls (byteStream nextPutAll: aBitmap) which knows enough to put 4-byte quantities on the stream!!  Reader must know that size is in long words."! !!DataStream methodsFor: 'all' stamp: 'jm 12/3/97 20:45'!writeByteArray: aByteArray	"PRIVATE -- Write the contents of a ByteArray."	(byteStream isKindOf: DummyStream) ifTrue: [^ self].	byteStream nextNumber: 4 put: aByteArray size.	"May have to convert types here..."	byteStream nextPutAll: aByteArray.! !!DataStream methodsFor: 'all' stamp: 'tk 7/29/96'!writeClass: aClass	"PRIVATE -- For now, no classes may be written.  HyperSqueak user unique classes have not state other than methods and should be reconstructed.  Could put standard fileOut code here if necessary.  ."	"Just halt for now -- 9/20/96 di."	self error: 'Should not be trying to write a class'"	Obj classPool at: #ErrorHolder put: aClass.	Transcript cr; show: 'The class ', aClass printString,' is trying to be written out.  See Obj class variable ErrorHolder.'."! !!DataStream methodsFor: 'all' stamp: 'jm 7/31/97 16:16'!writeRectangle: anObject    "Write the contents of a Rectangle.  See if it can be a compact Rectangle (type=15).  Rectangles with values outside +/- 2047 were stored as normal objects (type=9).  17:22 tk"	| ok right bottom top left acc |	ok _ true.	(right _ anObject right) > 2047 ifTrue: [ok _ false].	right < -2048 ifTrue: [ok _ false].	(bottom _ anObject bottom) > 2047 ifTrue: [ok _ false].	bottom < -2048 ifTrue: [ok _ false].	(top _ anObject top) > 2047 ifTrue: [ok _ false].	top < -2048 ifTrue: [ok _ false].	(left _ anObject left) > 2047 ifTrue: [ok _ false].	left < -2048 ifTrue: [ok _ false].	ok _ ok & left isInteger & right isInteger & top isInteger & bottom isInteger.	ok ifFalse: [		byteStream skip: -1; nextPut: 9; skip: 0. "rewrite type to be normal instance"	    ^ anObject storeDataOn: self].	acc _ ((left bitAnd: 16rFFF) bitShift: 12) + (top bitAnd: 16rFFF).	byteStream nextNumber: 3 put: acc.	acc _ ((right bitAnd: 16rFFF) bitShift: 12) + (bottom bitAnd: 16rFFF).	byteStream nextNumber: 3 put: acc.! !!DataStream methodsFor: 'all' stamp: 'jm 12/3/97 20:45'!writeString: aString	"PRIVATE -- Write the contents of a String."	(byteStream isKindOf: DummyStream) ifTrue: [^ self].	aString size < 16384 		ifTrue: [byteStream nextStringPut: aString]		ifFalse: [self writeByteArray: aString].	"takes more space"! !!DataStream class methodsFor: 'all'!fileNamed: aString	"Here is the way to use DataStream and ReferenceStream:rr _ ReferenceStream fileNamed: 'test.obj'.rr nextPut: <your object>.rr close."	| strm |	strm _ self on: (FileStream fileNamed: aString).		"will be binary"	strm byteStream setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	^ strm! !!DataStream class methodsFor: 'all' stamp: '6/10/97 16:51 tk'!initialize	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"	"DataStream initialize"	| refTypes t |	refTypes _ OrderedCollection new.	t _ TypeMap _ Dictionary new: 30. "sparse for fast hashing"	t at: UndefinedObject put: 1.   refTypes add: 0.	t at: True put: 2.   refTypes add: 0.	t at: False put: 3.   refTypes add: 0.	t at: SmallInteger put: 4.	 refTypes add: 0.	t at: String put: 5.   refTypes add: 1.	t at: Symbol put: 6.   refTypes add: 1.	t at: ByteArray put: 7.   refTypes add: 1.		"Does anything use this?"	t at: Array put: 8.   refTypes add: 1.	"(type ID 9 is for arbitrary instances, cf. typeIDFor:)"		refTypes add: 1.	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"		refTypes add: 0.	t at: Bitmap put: 11.   refTypes add: 1.	t at: Metaclass put: 12.   refTypes add: 0.	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."		refTypes add: 1.	t at: Float put: 14.  refTypes add: 1.	t at: Rectangle put: 15.  refTypes add: 1.	"Allow compact Rects."	"type ID 16 is an instance with short header.  See beginInstance:size:"		refTypes add: 1.	"t at:  put: 17.  refTypes add: 0."	ReferenceStream refTypes: refTypes.	"save it"! !!DataStream class methodsFor: 'all'!newFileNamed: aString	"Here is the way to use DataStream and ReferenceStream:rr _ ReferenceStream fileNamed: 'test.obj'.rr nextPut: <your object>.rr close."	| strm |	strm _  self on: (FileStream newFileNamed: aString).		"will be binary"	strm byteStream setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	^ strm! !!DataStream class methodsFor: 'all'!oldFileNamed: aString	"Here is the way to use DataStream and ReferenceStream:rr _ ReferenceStream oldFileNamed: 'test.obj'.^ rr nextAndClose."	| strm ff |	ff _ FileStream oldFileOrNoneNamed: aString.	ff ifNil: [^ nil].	strm _ self on: (ff binary).	^ strm! !!DataStream class methodsFor: 'all' stamp: 'di 6/24/97 00:18'!on: aStream	"Open a new DataStream onto a low-level I/O stream."	^ self basicNew setStream: aStream		"aStream binary is in setStream:"! !!DataStream class methodsFor: 'all' stamp: 'jm 12/3/97 19:36'!testWith: anObject	"As a test of DataStream/ReferenceStream, write out anObject and read it back.	11/19/92 jhm: Set the file type. More informative file name."	"DataStream testWith: 'hi'"	"ReferenceStream testWith: 'hi'"	| file result |	file _ FileStream fileNamed: (self name, ' test').	file binary.	(self on: file) nextPut: anObject.	file close.	file _ FileStream fileNamed: (self name, ' test').	file binary.	result _ (self on: file) next.	file close.	^ result! !!Date methodsFor: 'private' stamp: 'jm 1/6/98 13:38'!weekdayIndex	"Monday=1, ... , Sunday=7"	| yearIndex dayIndex |  	day < (self firstDayOfMonthIndex: 3)		ifTrue: 			[yearIndex _ year - 1.			dayIndex _ 307]		ifFalse: 			[yearIndex _ year.			dayIndex _ -58 - self leap].  		^dayIndex + day + yearIndex + (yearIndex // 4) 				+ (yearIndex // 400) - (yearIndex // 100) \\ 7 + 1! !!Date class methodsFor: 'instance creation'!fromString: aString	"Answer an instance of created from a string with format DD.MM.YYYY."	| fields |	fields := aString findTokens: './'.	^self newDay: (fields at: 1) asNumber month: (fields at: 2) asNumber year: (fields at: 3) asNumber! !!Date class methodsFor: 'instance creation'!newDay: day month: monthName year: year 	"Answer an instance of me which is the day'th day of the month named 	 monthName in the year'th year. The year may be specified as the actual 	 number of years since the beginning of the Roman calendar or the 	 number of years since the beginning of the century."	"Tolerate a month index instead of a month name."	| monthIndex daysInMonth firstDayOfMonth |	year < 100 ifTrue: [^ self			newDay: day			month: monthName			year: 1900 + year].	monthIndex _ monthName isInteger	 ifTrue: [monthName] ifFalse: [self indexOfMonth: monthName].	monthIndex = 2		ifTrue: [daysInMonth _ (DaysInMonth at: monthIndex)						+ (self leapYear: year)]		ifFalse: [daysInMonth _ DaysInMonth at: monthIndex].	monthIndex > 2		ifTrue: [firstDayOfMonth _ (FirstDayOfMonth at: monthIndex)						+ (self leapYear: year)]		ifFalse: [firstDayOfMonth _ FirstDayOfMonth at: monthIndex].	(day < 1 or: [day > daysInMonth])		ifTrue: [self error: 'illegal day in month']		ifFalse: [^self new day: day - 1 + firstDayOfMonth year: year]! !!Debugger methodsFor: 'initialize-release' stamp: 'sw 10/30/96'!expandStack	"This initialization occurs when the interrupted context is to modelled by 	a DebuggerView, rather than a NotifierView (which can not display 	more than five message-sends.	: expand the default number of frames from 7 to 15"	self newStack: (contextStackTop stackOfSize: 15).	contextStackIndex _ 0.	receiverInspector _ Inspector inspect: nil.	contextVariablesInspector _ ContextVariablesInspector inspect: nil.	proceedValue _ nil! !!Debugger methodsFor: 'accessing' stamp: 'tk 12/6/97 21:31'!contents: aText notifying: aController 	"The retrieved information has changed and its source must now be 	updated. In this case, the retrieved information is the method of the 	selected context."	| selector classOfMethod category method priorMethod parseNode |	contextStackIndex = 0 ifTrue: [^self].	(self selectedContext isKindOf: MethodContext)		ifFalse:			[(self confirm:'I will have to revert to the method fromwhich this block originated.  Is that OK?')				ifTrue: [self resetContext: self selectedContext home]				ifFalse: [^self]].	classOfMethod _ self selectedClass.	category _ self selectedMessageCategoryName.	Cursor execute showWhile:		[method _ classOfMethod		compile: aText		notifying: aController		trailer: #(0 0 0 0)		ifFail: [^ false]		elseSetSelectorAndNode: 			[:sel :methodNode | selector _ sel.			selector == self selectedMessageName				ifFalse: [self notify: 'can''t change selector'. ^ false].			priorMethod _ (classOfMethod includesSelector: selector)				ifTrue: [classOfMethod compiledMethodAt: selector]				ifFalse: [nil].			sourceMap _ methodNode sourceMap.			tempNames _ methodNode tempNames.			parseNode _ methodNode].		method cacheTempNames: tempNames].	category isNil ifFalse: "Skip this for DoIts"		[method putSource: aText				fromParseNode: parseNode				class: classOfMethod				category: category				inFile: 2 priorMethod: priorMethod.		classOfMethod organization classify: selector under: category].	contents _ aText copy.	self selectedContext restartWith: method.	contextVariablesInspector object: nil.	self resetContext: self selectedContext.	^true! !!Debugger methodsFor: 'accessing' stamp: 'tk 1/16/98 16:52'!wantsBoldSelector	"In code pane?  Only when a message selected"	^ self messageListIndex ~= 0! !!Debugger methodsFor: 'message functions' stamp: 'sw 8/6/97 13:46'!browseSendersOfMessages	"Show a menu of all messages sent by the currently selected message. 	Create and schedule a message set browser of all senders of the 	message chosen. Do nothing if no message is chosen.  Derived from    browseMessages,"	contextStackIndex = 0 ifTrue: [^ self].	Smalltalk showMenuThenBrowseSendersOf: self currentCompiledMethod messages asSortedCollection! !!Debugger methodsFor: 'message functions' stamp: 'sw 8/6/97 14:26'!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	ChangeList		browseVersionsOf: (class compiledMethodAt: selector)		class: self selectedClass		meta: self selectedClass isMeta		category: self selectedMessageCategoryName		selector: selector! !!Debugger methodsFor: 'message functions' stamp: 'sw 8/6/97 22:19'!buildMessageBrowser	"Create and schedule a message browser on the current method."	contextStackIndex = 0 ifTrue: [^ self].	^ BrowserView		openMessageBrowserForClass: self selectedClassOrMetaClass		selector: self selectedMessageName		editString: nil! !!Debugger methodsFor: 'message functions' stamp: 'sw 8/6/97 13:45'!currentCompiledMethod	^ self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName! !!Debugger methodsFor: 'code execution' stamp: 'sn 8/22/97 21:44'!send	"Send the selected message in the accessed method, and take control in 	the method invoked to allow further step or send."	| currentContext |	Sensor leftShiftDown ifTrue: [self halt].	self okToChange ifFalse: [^ self].	self checkContextSelection.	externalInterrupt ifFalse: [contextStackTop push: proceedValue].	externalInterrupt _ true. "simulation leaves same state as interrupting"	currentContext _ self selectedContext.	currentContext stepToSendOrReturn.	self contextStackIndex > 1 | currentContext willReturn		ifTrue: 			[self changed: #notChanged]		ifFalse: 			[currentContext _ currentContext step.			currentContext stepToSendOrReturn.			self resetContext: currentContext]! !!Debugger methodsFor: 'code execution' stamp: 'sn 9/6/97 16:27'!step	"Send the selected message in the accessed method, and regain control 	after the invoked method returns."		| currentContext oldMethod |	self okToChange ifFalse: [^ self].	self checkContextSelection.	externalInterrupt ifFalse: [contextStackTop push: proceedValue].	externalInterrupt _ true. "simulation leaves same state as interrupting"	currentContext _ self selectedContext.	self contextStackIndex > 1		ifTrue: 			[currentContext completeCallee: contextStackTop.			self resetContext: currentContext]		ifFalse: 			[currentContext stepToSendOrReturn.			currentContext willReturn				ifTrue: 					[oldMethod _ currentContext method.					currentContext _ currentContext step.					currentContext stepToSendOrReturn.					self resetContext: currentContext.					oldMethod == currentContext method "didnt used to update pc here"						ifTrue: [self changed: #pc]]				ifFalse: 					[currentContext completeCallee: currentContext step.					self changed: #pc.					self updateInspectors]]! !!Debugger methodsFor: 'private'!resumeProcess: aScheduledController	aScheduledController view erase.	Smalltalk installLowSpaceWatcher.  "restart low space handler"	interruptedProcess suspendedContext method			== (Process compiledMethodAt: #terminate) ifFalse:		[contextStackIndex > 1			ifTrue: [interruptedProcess popTo: self selectedContext]			ifFalse: [interruptedProcess install: self selectedContext].		ScheduledControllers						activeControllerNoTerminate: interruptedController						andProcess: interruptedProcess].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil. 	aScheduledController closeAndUnscheduleNoErase.	Processor terminateActive! !!DebuggerStub methodsFor: 'initialization' stamp: 'di 6/17/97 09:15'!extent: newExtent	| inner |	super extent: newExtent.	inner _ self innerBounds.	shortStackPane bounds: (inner topLeft + (1@(self labelHeight+1)) corner: inner bottomRight - 1)! !!DebuggerStub methodsFor: 'initialization' stamp: 'di 6/17/97 09:12'!initPanes	self addMorph: (shortStackPane _ ScrollPane new model: self slotName: 'shortStackPane').! !!DebuggerStub methodsFor: 'initialization' stamp: 'di 6/17/97 09:22'!setStackText: textOrString	shortStackPane scroller removeAllMorphs; addMorph:		(TextMorph new contents: textOrString asText)! !!DebuggerStub class methodsFor: 'instance creation' stamp: 'di 6/22/97 09:14'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!DebuggerStub class methodsFor: 'instance creation' stamp: 'di 6/18/97 05:34'!openContext: haltContext label: labelString contents: contentsString	| stub |	World addMorph: (stub _ (self labelled: labelString) setStackText: contentsString).	stub changed! !!DebuggerView class methodsFor: 'instance creation'!debugger: aDebugger 	"Answer a DebuggerView whose model is aDebugger. It consists of three 	subviews, a ContextStackView (the ContextStackListView and 	ContextStackCodeView), an InspectView of aDebugger's variables, and an 	InspectView of the variables of the currently selected method context."	| topView stackListView stackCodeView rcvrVarView rcvrValView ctxtVarView ctxtValView |	aDebugger expandStack.	topView _ self new model: aDebugger.	stackListView _ ContextStackListView new model: aDebugger.		stackListView window: (0 @ 0 extent: 150 @ 50).		stackListView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.		topView addSubView: stackListView.	stackCodeView _ ContextStackCodeView new model: aDebugger.		stackCodeView controller: ContextStackCodeController new.		stackCodeView window: (0 @ 0 extent: 150 @ 75).		stackCodeView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.		topView addSubView: stackCodeView below: stackListView.	rcvrVarView _ InspectListView new model: aDebugger receiverInspector.		rcvrVarView window: (0 @ 0 extent: 25 @ 50).		rcvrVarView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.		topView addSubView: rcvrVarView below: stackCodeView.	rcvrValView _ InspectCodeView new model: aDebugger receiverInspector.		rcvrValView window: (0 @ 0 extent: 50 @ 50).		rcvrValView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.		topView addSubView: rcvrValView toRightOf: rcvrVarView.	ctxtVarView _ InspectListView new model: aDebugger contextVariablesInspector.		ctxtVarView window: (0 @ 0 extent: 25 @ 50).		ctxtVarView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.		topView addSubView: ctxtVarView toRightOf: rcvrValView.	ctxtValView _ InspectCodeView new model: aDebugger contextVariablesInspector.		ctxtValView window: (0 @ 0 extent: 50 @ 50).		ctxtValView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.		topView addSubView: ctxtValView toRightOf: ctxtVarView.	^ topView! !!DebuggerView class methodsFor: 'instance creation'!lowSpaceChoices	"Return a notifier message string to be presented when space is running low."	^ 'Warning!! Squeak is almost out of memory!!Low space detection is now disabled. It will be restored when you close or proceed from this error notifier. Don''t panic, but do proceed with caution.Here are some suggestions: If you suspect an infinite recursion (the same methods calling each other again and again), then close this debugger, and fix the problem. If you want this computation to finish, then make more space available (read on) and choose "proceed" in this debugger. Here are some ways to make more space available...   > Close any windows that are not needed.   > Get rid of some large objects (e.g., images).   > Leave this window on the screen, choose "save as..." from the screen menu, quit, restart the Squeak VM with a larger memory allocation, then restart the image you just saved, and choose "proceed" in this window. If you want to investigate further, choose "debug" in this window.  Do not use the debugger "fullStack" command unless you are certain that the stack is not very deep (as it will be if the problem is an infinite recursion).'! !!DebuggerView class methodsFor: 'instance creation' stamp: 'di 6/24/97 11:48'!openContext: haltContext label: aString contents: contentsString	"Create and schedule a simple view on a Debugger on haltContext.	The view is labeled with aString and shows a short sender stack."	ErrorRecursion		ifTrue: 			[ErrorRecursion _ false.			self primitiveError: aString].	ErrorRecursion _ true.	World ifNotNil:			["Put up a Morphic debugger in Morphic worlds"			"Written so that Morphic can still be removed."			(Smalltalk at: #DebuggerStub) openContext: haltContext				label: aString				contents: contentsString.			ErrorRecursion _ false.			Project current spawnNewProcess.			^ Processor activeProcess suspend].	self openNotifier: (Debugger context: haltContext)		contents: contentsString		label: aString.	ErrorRecursion _ false.	Processor activeProcess suspend! !!DebuggerView class methodsFor: 'instance creation' stamp: 'sw 9/5/97 18:05'!openNotifier: aDebugger contents: msgString label: label	"Create and schedule a simple view with a debugger which can be opened later."	| msg aStringHolderView topView nLines displayPoint |	Cursor normal show.	Sensor flushKeyboard.	msg _ msgString.	(label beginsWith: 'Space is low')		ifTrue: [msg _ self lowSpaceChoices, msg].	aStringHolderView _		StringHolderView container: (StringHolder new contents: msg).	aStringHolderView controller: (NotifyStringHolderController debugger: aDebugger).	topView _ StandardSystemView new.	topView model: aStringHolderView model.	topView addSubView: aStringHolderView.	topView label: label.	nLines _ 1 + (msg occurrencesOf: Character cr).	topView minimumSize: 350 @ (14 * nLines + 6).	displayPoint _		ScheduledControllers activeController == nil			ifTrue: [Display boundingBox center]			ifFalse: [ScheduledControllers activeController view displayBox center].	displayPoint _ displayPoint max: (200@40).	topView controller openNoTerminateDisplayAt: displayPoint.	^ topView! !!Decompiler methodsFor: 'initialize-release'!initSymbols: aClass	| nTemps namedTemps |	constructor method: method class: aClass literals: method literals.	constTable _ constructor codeConstants.	instVars _ Array new: aClass instSize.	nTemps _ method numTemps.	namedTemps _ tempVars == nil ifTrue: [Array new] ifFalse: [tempVars].	tempVars _ (1 to: nTemps) collect:				[:i | i <= namedTemps size					ifTrue: [constructor codeTemp: i - 1 named: (namedTemps at: i)]					ifFalse: [constructor codeTemp: i - 1]]! !!Decompiler methodsFor: 'initialize-release'!withTempNames: tempNameArray	tempVars _ tempNameArray! !!Decompiler methodsFor: 'control' stamp: 'tao 8/20/97 22:51'!blockForCaseTo: end	"Decompile a range of code as in statementsForCaseTo:, but return a block node."	| exprs block oldBase |	oldBase _ blockStackBase.	blockStackBase _ stack size.	exprs _ self statementsForCaseTo: end.	block _ constructor codeBlock: exprs returns: lastReturnPc = lastPc.	blockStackBase _ oldBase.	lastReturnPc _ -1.  "So as not to mislead outer calls"	^block! !!Decompiler methodsFor: 'control'!checkForBlock: receiver	"We just saw a blockCopy: message. Check for a following block."	| savePc jump args argPos block |	receiver == constructor codeThisContext ifFalse: [^false].	savePc _ pc.	(jump _ self interpretJump) notNil		ifFalse:			[pc _ savePc.  ^nil].	"Definitely a block"	jump _ jump + pc.	argPos _ statements size.	[self willStorePop]		whileTrue:			[stack addLast: ArgumentFlag.  "Flag for doStore:"			self interpretNextInstructionFor: self].	args _ Array new: statements size - argPos.	1 to: args size do:  "Retrieve args"		[:i | args at: i put: statements removeLast.		(args at: i) scope: -1  "flag args as block temps"].	block _ self blockTo: jump.	stack addLast: (constructor codeArguments: args block: block).	^true! !!Decompiler methodsFor: 'control' stamp: 'tao 8/20/97 22:51'!statementsForCaseTo: end	"Decompile the method from pc up to end and return an array of	expressions. If at run time this block will leave a value on the stack,	set hasValue to true. If the block ends with a jump or return, set exit	to the destination of the jump, or the end of the method; otherwise, set	exit = end. Leave pc = end.	Note that stack initially contains a CaseFlag which will be removed by	a subsequent Pop instruction, so adjust the StackPos accordingly."	| blockPos stackPos t |	blockPos _ statements size.	stackPos _ stack size - 1. "Adjust for CaseFlag"	[pc < end]		whileTrue:			[lastPc _ pc.  limit _ end.  "for performs"			self interpretNextInstructionFor: self].	"If there is an additional item on the stack, it will be the value	of this block."	(hasValue _ stack size > stackPos)		ifTrue:			[statements addLast: stack removeLast].	lastJumpPc = lastPc ifFalse: [exit _ pc].	^self popTo: blockPos! !!Decompiler methodsFor: 'instruction decoding' stamp: 'tao 8/20/97 22:49'!case: dist	"statements = keyStmts CascadeFlag keyValueBlock ... keyStmts"	| nextCase end thenJump stmtStream elements b node cases otherBlock |	nextCase _ pc + dist.	end _ limit.	"Now add CascadeFlag & keyValueBlock to statements"	statements addLast: stack removeLast.	stack addLast: CaseFlag. "set for next pop"	statements addLast: (self blockForCaseTo: nextCase).	stack last == CaseFlag		ifTrue: "Last case"			["ensure jump is within block (in case thenExpr returns wierdly I guess)"			stack removeLast. "get rid of CaseFlag".			thenJump _ exit <= end ifTrue: [exit] ifFalse: [nextCase].			stmtStream _ ReadStream on: (self popTo: stack removeLast).			elements _ OrderedCollection new.			b _ OrderedCollection new.			[stmtStream atEnd] whileFalse:				[(node _ stmtStream next) == CascadeFlag					ifTrue:						[elements addLast: (constructor							codeMessage: (constructor codeBlock: b returns: false)							selector: (constructor codeSelector: #-> code: #macro)							arguments: (Array with: stmtStream next)).						 b _ OrderedCollection new]					ifFalse: [b addLast: node]].			b size > 0 ifTrue: [self error: 'Bad cases'].			cases _ constructor codeBrace: elements.			otherBlock _ self blockTo: thenJump.			stack addLast:				(constructor					codeMessage: stack removeLast					selector: (constructor codeSelector: #caseOf:otherwise: code: #macro)					arguments: (Array with: cases with: otherBlock))]! !!Decompiler methodsFor: 'instruction decoding' stamp: 'tao 8/20/97 22:54'!doPop	stack last == CaseFlag		ifTrue: [stack removeLast]		ifFalse: [statements addLast: stack removeLast].! !!Decompiler methodsFor: 'instruction decoding'!jump: dist if: condition	| savePc elseDist sign elsePc elseStart end cond ifExpr thenBlock elseBlock thenJump		elseJump condHasValue b |	stack last == CascadeFlag ifTrue: [^self case: dist].	elsePc _ lastPc.	elseStart _ pc + dist.	end _ limit.	"Check for bfp-jmp to invert condition.	Don't be fooled by a loop with a null body."	sign _ condition.	savePc _ pc.	((elseDist _ self interpretJump) notNil and: [elseDist >= 0 and: [elseStart = pc]])		ifTrue: [sign _ sign not.  elseStart _ pc + elseDist]		ifFalse: [pc _ savePc].	ifExpr _ stack removeLast.	thenBlock _ self blockTo: elseStart.	condHasValue _ hasValue.	"ensure jump is within block (in case thenExpr returns)"	thenJump _ exit <= end ifTrue: [exit] ifFalse: [elseStart].	"if jump goes back, then it's a loop"	thenJump < elseStart		ifTrue:			["thenJump will jump to the beginning of the while expr.  In the case of			while's with a block in the condition, the while expr			should include more than just the last expression: find all the			statements needed by re-decompiling."			pc _ thenJump.			b _ self statementsTo: elsePc.			"discard unwanted statements from block"			b size - 1 timesRepeat: [statements removeLast].			statements addLast: (constructor					codeMessage: (constructor codeBlock: b returns: false)					selector: (constructor codeSelector: (sign ifTrue: [#whileFalse:] ifFalse: [#whileTrue:]) code: #macro)					arguments: (Array with: thenBlock)).			pc _ elseStart.			self convertToDoLoop]		ifFalse:			[elseBlock _ self blockTo: thenJump.			elseJump _ exit.			"if elseJump is backwards, it is not part of the elseExpr"			elseJump < elsePc				ifTrue: [pc _ lastPc].			cond _ constructor						codeMessage: ifExpr						selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)						arguments:							(sign								ifTrue: [Array with: elseBlock with: thenBlock]								ifFalse: [Array with: thenBlock with: elseBlock]).			condHasValue				ifTrue: [stack addLast: cond]				ifFalse: [statements addLast: cond]]! !!Decompiler methodsFor: 'private'!convertToDoLoop	"If statements contains the pattern		var _ startConst.		[var <= limit] whileTrue: [...statements... var _ var + incConst]	then replace this by		startConst to: limit by: incConst do: [:var | ...statements...]"	| initStmt toDoStmt limitStmt |	statements size < 2 ifTrue: [^ self].	initStmt _ statements at: statements size-1.	(toDoStmt _ statements last toDoFromWhileWithInit: initStmt)		== nil ifTrue: [^ self].	statements removeLast; removeLast; addLast: toDoStmt.	initStmt variable scope: -1.  "Flag arg as block temp"	statements size < 2 ifTrue: [^ self].	limitStmt _ statements at: statements size-1.	(toDoStmt _ statements last toDoWithLimit: limitStmt)		== nil ifTrue: [^ self].	statements removeLast; removeLast; addLast: toDoStmt.	limitStmt variable scope: -2.  "Flag limit var as block temp"! !!Decompiler methodsFor: 'private'!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block |	constructor _ aConstructor.	method _ aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block _ self quickMethod]		ifFalse: 			[stack _ OrderedCollection new: method frameSize.			statements _ OrderedCollection new: 20.			super method: method pc: method initialPC.			block _ self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	^constructor		codeMethod: aSelector		block: block		tempVars: (tempVars select: [:t | t scope >=0])		primitive: method primitive		class: aClass! !!Decompiler class methodsFor: 'class initialization' stamp: 'tao 8/20/97 20:50'!initialize	CascadeFlag _ 'cascade'.  "A unique object"	CaseFlag _ 'case'. "Ditto"	ArgumentFlag _ 'argument'.  "Ditto"	"Decompiler initialize"! !!DecompilerConstructor methodsFor: 'constructor'!codeConstants	"Answer with an array of the objects representing self, true, false, nil,	-1, 0, 1, 2."	^(Array with: NodeSelf with: NodeTrue with: NodeFalse with: NodeNil)		, ((-1 to: 2) collect: [:i | LiteralNode new key: i code: LdMinus1 + i + 1])! !!DecompilerConstructor methodsFor: 'constructor'!codeTemp: index	^ TempVariableNode new		name: 't' , (index + 1) printString		index: index		type: LdTempType		scope: 0! !!DecompilerConstructor methodsFor: 'constructor'!codeTemp: index named: tempName	^ TempVariableNode new		name: tempName		index: index		type: LdTempType		scope: 0! !!Delay methodsFor: 'delaying' stamp: 'jm 9/12/97 11:11'!unschedule	"Unschedule this Delay. Do nothing if it wasn't scheduled."	| done |	AccessProtect critical: [		done _ false.		[done] whileFalse:			[SuspendedDelays remove: self ifAbsent: [done _ true]].		ActiveDelay == self ifTrue: [			SuspendedDelays isEmpty				ifTrue: [					ActiveDelay _ nil.					ActiveDelayStartTime _ nil]				ifFalse: [					SuspendedDelays removeFirst activate]]].! !!Delay methodsFor: 'delaying' stamp: 'jm 9/12/97 09:10'!wait	"Schedule this Delay, then wait on its semaphore. The current process will be suspended for the amount of time specified when this Delay was created."	self schedule.	delaySemaphore wait.! !!Delay methodsFor: 'private' stamp: 'jm 9/11/97 13:31'!activate	"Private!! Make the receiver the Delay to be awoken when the next timer interrupt occurs. This method should only be called from a block protected by the AccessProtect semaphore."	ActiveDelay _ self.	ActiveDelayStartTime _ Time millisecondClockValue.	TimingSemaphore initSignals.	Delay primSignal: TimingSemaphore atMilliseconds: resumptionTime.! !!Delay methodsFor: 'private' stamp: 'jm 9/11/97 14:49'!adjustResumptionTimeOldBase: oldBaseTime newBase: newBaseTime	"Private!! Adjust the value of the system's millisecond clock at which this Delay will be awoken. Used to adjust resumption times after a snapshot or clock roll-over."	resumptionTime _ newBaseTime + (resumptionTime - oldBaseTime).! !!Delay methodsFor: 'private' stamp: 'jm 9/11/97 11:54'!resumptionTime	"Answer the value of the system's millisecondClock at which the receiver's suspended Process will resume."	^ resumptionTime! !!Delay methodsFor: 'private' stamp: 'jm 9/12/97 11:10'!schedule	"Private!! Schedule this Delay, but return immediately rather than waiting. The receiver's semaphore will be signalled when its delay duration has elapsed."	beingWaitedOn ifTrue: [self error: 'This Delay has already been scheduled.'].	AccessProtect critical: [		beingWaitedOn _ true.		resumptionTime _ Time millisecondClockValue + delayDuration.		ActiveDelay == nil			ifTrue: [self activate]			ifFalse: [				resumptionTime < ActiveDelay resumptionTime					ifTrue: [						SuspendedDelays add: ActiveDelay.						self activate]					ifFalse: [SuspendedDelays add: self]]].! !!Delay methodsFor: 'private' stamp: 'jm 9/12/97 08:56'!setDelay: millisecondCount forSemaphore: aSemaphore	"Private!! Initialize this delay to signal the given semaphore after the given number of milliseconds."	delayDuration _ millisecondCount.	delaySemaphore _ aSemaphore.	beingWaitedOn _ false.! !!Delay methodsFor: 'private' stamp: 'jm 9/11/97 11:54'!signalWaitingProcess	"The delay time has elapsed; signal the waiting process."	beingWaitedOn _ false.	delaySemaphore signal.! !!Delay class methodsFor: 'instance creation' stamp: 'jm 9/15/97 17:09'!forMilliseconds: anInteger	"Return a new Delay for the given number of milliseconds. Sending 'wait' to this Delay will cause the sender's process to be suspended for approximately that length of time."	anInteger < 0 ifTrue: [self error: 'delay times cannot be negative'].	^ self new		setDelay: anInteger		forSemaphore: Semaphore new! !!Delay class methodsFor: 'instance creation' stamp: 'jm 9/15/97 17:09'!forSeconds: anInteger	"Return a new Delay for the given number of seconds. Sending 'wait' to this Delay will cause the sender's process to be suspended for approximately that length of time."	anInteger < 0 ifTrue: [self error: 'delay times cannot be negative'].	^ self new		setDelay: anInteger * 1000		forSemaphore: Semaphore new! !!Delay class methodsFor: 'instance creation' stamp: 'jm 9/12/97 11:06'!howToUse	"An instance of Delay responds to the message 'wait' by suspending the caller's process for a certain amount of time. The duration of the pause is specified when the Delay is created with the message forMilliseconds: or forSeconds:. A Delay can be used again when the current wait has finished. For example, a clock process might repeatedly wait on a one-second Delay.	The maximum delay is (SmallInteger maxVal // 2) milliseconds, or about six days. A delay in progress when an image snapshot is saved is resumed when the snapshot is re-started. Delays work across millisecond clock roll-overs."! !!Delay class methodsFor: 'instance creation' stamp: 'jm 9/15/97 17:10'!timeoutSemaphore: aSemaphore afterMSecs: anInteger	"Create and schedule a Delay to signal the given semaphore when the given number of milliseconds has elapsed. Return the scheduled Delay. The timeout can be cancelled by sending 'unschedule' to this Delay."	"Details: This mechanism is used to provide a timeout when waiting for an external event, such as arrival of data over a network connection, to signal a semaphore. The timeout ensures that the semaphore will be signalled within a reasonable period of time even if the event fails to occur. Typically, the waiting process cancels the timeout request when awoken, then determines if the awaited event has actually occurred."	anInteger < 0 ifTrue: [self error: 'delay times cannot be negative'].	^ (self new setDelay: anInteger forSemaphore: aSemaphore) schedule! !!Delay class methodsFor: 'snapshotting' stamp: 'jm 9/11/97 14:59'!restoreResumptionTimes	"Private!! Restore the resumption times of all scheduled Delays after a snapshot or clock roll-over. This method should be called only while the AccessProtect semaphore is held."	| newBaseTime |	newBaseTime _ Time millisecondClockValue.	SuspendedDelays do: [:d | d adjustResumptionTimeOldBase: 0 newBase: newBaseTime].	ActiveDelay == nil ifFalse: [		ActiveDelay adjustResumptionTimeOldBase: 0 newBase: newBaseTime.		ActiveDelay activate].! !!Delay class methodsFor: 'snapshotting' stamp: 'jm 9/11/97 15:15'!saveResumptionTimes	"Private!! Record the resumption times of all Delays relative to a base time of zero. This is done prior to snapshotting or adjusting the resumption times after a clock roll-over. This method should be called only while the AccessProtect semaphore is held."	| oldBaseTime |	oldBaseTime _ Time millisecondClockValue.	ActiveDelay == nil		ifFalse: [			oldBaseTime < ActiveDelayStartTime				ifTrue: [oldBaseTime _ ActiveDelayStartTime].  "clock rolled over"			ActiveDelay adjustResumptionTimeOldBase: oldBaseTime newBase: 0].	SuspendedDelays do:		[:d | d adjustResumptionTimeOldBase: oldBaseTime newBase: 0].! !!Delay class methodsFor: 'snapshotting' stamp: 'jm 9/11/97 15:00'!shutDown	"Suspend the active delay, if any, before snapshotting. It will be reactived when the snapshot is resumed."	"Details: This prevents a timer interrupt from waking up the active delay in the midst snapshoting, since the active delay will be restarted when resuming the snapshot and we don't want to process the delay twice."	AccessProtect wait.	self primSignal: nil atMilliseconds: 0.	self saveResumptionTimes.! !!Delay class methodsFor: 'snapshotting' stamp: 'jm 9/11/97 15:01'!startUp	"Restart active delay, if any, when resuming a snapshot."	self restoreResumptionTimes.	ActiveDelay == nil ifFalse: [ActiveDelay activate].	AccessProtect signal.! !!Delay class methodsFor: 'timer process' stamp: 'jm 9/11/97 15:15'!startTimerInterruptWatcher	"Reset the class variables that keep track of active Delays and re-start the timer interrupt watcher process. Any currently scheduled delays are forgotten."	"Delay startTimerInterruptWatcher"	| p |	self primSignal: nil atMilliseconds: 0.	TimingSemaphore == nil		ifFalse: [TimingSemaphore terminateProcess].	TimingSemaphore _ Semaphore new.	AccessProtect _ Semaphore forMutualExclusion.	SuspendedDelays _ 		SortedCollection sortBlock: 			[:d1 :d2 | d1 resumptionTime <= d2 resumptionTime].	ActiveDelay _ nil.	p _ [self timerInterruptWatcher] newProcess.	p priority: Processor timingPriority.	p resume.! !!Delay class methodsFor: 'timer process' stamp: 'jm 9/11/97 15:13'!timerInterruptWatcher	"This loop runs in its own process. It waits for a timer interrupt and wakes up the active delay. Note that timer interrupts are only enabled when there are active delays."	[true] whileTrue: [		TimingSemaphore wait.		AccessProtect critical: [			ActiveDelay == nil ifFalse: [				ActiveDelay signalWaitingProcess.				Time millisecondClockValue < ActiveDelayStartTime					ifTrue: [  "clock wrapped"						self saveResumptionTimes.						self restoreResumptionTimes]].			SuspendedDelays isEmpty				ifTrue: [					ActiveDelay _ nil.					ActiveDelayStartTime _ nil]				ifFalse: [					SuspendedDelays removeFirst activate]]].! !!Delay class methodsFor: 'example' stamp: 'jm 9/11/97 11:23'!testDelayOf: delay for: testCount rect: r	"Delay testDelayOf: 100 for: 20 rect: (10@10 extent: 30@30).	 Delay testDelayOf: 400 for: 20 rect: (50@10 extent: 30@30)."	| onDelay offDelay |	onDelay _ Delay forMilliseconds: 50.	offDelay _ Delay forMilliseconds: delay - 50.	Display fillBlack: r.	[1 to: testCount do: [:i |		Display fillWhite: r.		onDelay wait.		Display reverse: r.		offDelay wait].	] forkAt: Processor userInterruptPriority.! !!Delay class methodsFor: 'primitives' stamp: 'jm 9/11/97 10:54'!primSignal: aSemaphore atMilliseconds: aSmallInteger	"Signal the semaphore when the millisecond clock reaches the value of the second argument. Fail if the first argument is neither a Semaphore nor nil. Essential. See Object documentation whatIsAPrimitive."	<primitive: 136>	self primitiveFailed! !!Dictionary methodsFor: 'accessing' stamp: 'tk 2/18/97'!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock.	: Use =, not ==, so stings like 'this' can be found.  Note that MethodDictionary continues to use == so it will be fast." 	self associationsDo: 		[:association | value = association value ifTrue: [^association key]].	^exceptionBlock value! !!Dictionary methodsFor: 'accessing'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet _ Set new: self size.	self keysDo: [:key | aSet add: key].	^ aSet! !!Dictionary methodsFor: 'removing'!removeUnreferencedKeys   "Undeclared removeUnreferencedKeys"	^ self unreferencedKeys do: [:key | self removeKey: key].! !!Dictionary methodsFor: 'removing'!unreferencedKeys		"TextConstants unreferencedKeys"	| n |	^ 'Scanning for references . . .'		displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:		[:bar | n _ 0.		self keys select:			[:key | bar value: (n _ n+1).			(Smalltalk allCallsOn: (self associationAt: key)) isEmpty]]! !!Dictionary methodsFor: 'printing' stamp: 'di 6/20/97 09:10'!printOn: aStream	aStream nextPutAll: self class name, ' ('.	self associationsDo: [:element | element printOn: aStream. aStream space].	aStream nextPut: $)! !!Dictionary methodsFor: 'private' stamp: 'tk 8/21/97 16:12'!copy	"Must copy the associations, or later store will effect both theoriginal and the copy"	^ self shallowCopy withArray:		(array collect: [:assoc |			assoc ifNil: [nil]				ifNotNil: [Association key: assoc keyvalue: assoc value]])! !!Dictionary methodsFor: 'private'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Dictionary methodsFor: 'user interface'!inspect	"Open a DictionaryInspector on the receiver.  N.B.: this is	an inspector without trash, since InspectorTrash doesn't do the	obvious thing right now.  Use basicInspect to get a normal	(less useful) type of inspector."	DictionaryInspector openOn: self withEvalPane: false! !!Dictionary methodsFor: 'user interface' stamp: 'sw 6/28/96'!inspectFormsWithLabel: aLabel	"Open a Form Dictionary inspector on the receiver, with the given label.  "	^ DictionaryInspector openOn: self withEvalPane: false		withLabel: aLabel		valueViewClass: FormInspectView! !!Dictionary methodsFor: 'user interface'!inspectWithLabel: aLabel	"Open a DictionaryInspector on the receiver.  N.B.: this is	an inspector without trash, since InspectorTrash doesn't do the	obvious thing right now.  Use basicInspect to get a normal	(less useful) type of inspector."	DictionaryInspector openOn: self withEvalPane: false withLabel: aLabel! !!DictionaryListController methodsFor: 'menu messages' stamp: 'sw 8/12/97 22:12'!startUpYellowButtonMenu	self flag: #scottPrivate.  "Track down why this had to be smashed in sometime in early August?!!"	^ yellowButtonMenu startUp! !!DictionaryListController class methodsFor: 'class initialization'!initialize	DictionaryListYellowButtonMenu _		PopUpMenu labels:'inspectreferencesobjects pointing to this valueadd keyremove'		lines: #( 3 ).	DictionaryListYellowButtonMessages _		#(inspectSelection selectionReferences objectReferencesToSelection addEntry removeSelection )	"DictionaryListController initialize"! !A Discussion has some header information and a collection of related notes.!!Discussion methodsFor: 'access' stamp: 'mjg 11/17/97 14:25'!addNote: aNote	notes isNil ifTrue: [notes _ OrderedCollection new.].	notes add: aNote.	^notes size! !!Discussion methodsFor: 'access' stamp: 'mjg 11/17/97 14:29'!at: aKey	^notes at: aKey! !!Discussion methodsFor: 'access' stamp: 'mjg 11/17/97 14:24'!at: aKey addNote: aNote	notes isNil ifTrue: [notes _ Dictionary new.].	notes at: aKey put: aNote.! !!Discussion methodsFor: 'access' stamp: 'mjg 11/17/97 14:21'!description	^description! !!Discussion methodsFor: 'access' stamp: 'mjg 11/17/97 14:21'!description: aString	description _ aString! !!Discussion methodsFor: 'access' stamp: 'mjg 11/17/97 14:20'!notes	^notes! !!Discussion methodsFor: 'access' stamp: 'mjg 11/17/97 14:21'!relatedURL	^relatedURL! !!Discussion methodsFor: 'access' stamp: 'mjg 11/17/97 14:21'!relatedURL: aString	relatedURL _ aString! !!Discussion methodsFor: 'access' stamp: 'mjg 12/8/97 11:11'!status	| reply |	reply _ WriteStream on: String new.	reply nextPutAll: 'Number of notes: ', (notes size printString).	notes size > 0		ifTrue: [reply nextPutAll: '. Last note: ',(notes last timestamp).].	^reply contents! !!Discussion methodsFor: 'access' stamp: 'mjg 11/17/97 14:20'!title	^title! !!Discussion methodsFor: 'access' stamp: 'mjg 11/17/97 14:21'!title: aString	title _ aString! !DiskProxy comment:'A DiskProxy is an externalized form of an object to write on aDataStream. It contains a "constructor" message to regeneratethe object, in context, when sent a comeFullyUpOnReload message(i.e. "internalize").We are now using DiskProxy for shared system objects like StrikeFonts.The idea is to define, for each kind of object that needs specialexternalization, a class method that will internalize the object byreconstructing it from its defining state. We call this a"constructor" method. Then externalize such an object as a frozenmessage that invokes this method--a DiskProxy.(Here is the old comment:Constructing a new object is good for any object that (1) can not beexternalized simply by snapshotting and reloading its instancevariables (like a CompiledMethod or a Picture), or (2) wants to befree to evolve its internal representation without making storedinstances obsolete (and dangerous). Snapshotting and reloading anobject"s instance variables is a dangerous breach of encapsulation.The internal structure of the class is then free to evolve. Allexternalized instances will be useful as long as theconstructor methods are maintained with the same semantics.There may be several constructor methods for a particular class. Thisis useful for (1) instances with characteristically differentdefining state, and (2) newer, evolved forms of an object and itsconstructors, with the old constructor methods kept around so olddata can still be properly loaded.)Create one like this example from class Picture    DiskProxy global: #Picture            selector: #fromByteArray:                args: (Array with: self storage asByteArray)* See also subclass DiskProxyQ that will construct an object inthe above manner and then send it a sequence of messages. This may savecreating a wide variety of constructor methods. It is also useful becausethe newly read-in DiskProxyQ can catch messages like #objectContainedIn:(via #doesNotUnderstand:) and add them to the queue of messages tosend to the new object.* We may also want a subclass of DiskProxy that evaluates a stringexpression to compute the receiver of the constructor message.My instance variables:* globalObjectName -- the Symbol name of a global object in the    System dictionary (usually a class).* constructorSelector -- the constructor message selector Symbol to    send to the global object (perform:withArguments:), typically a    variation on newFrom:.* constructorArgs -- the Array of arguments to pass in the    constructor message.-- 11/9/92 Jerry Morrison'!!DiskProxy methodsFor: 'all'!comeFullyUpOnReload	"Internalize myself into a fully alive object after raw loading	from a DataStream. (See my class comment.)	The sender (the DataStream facility) will substitute the answer for myself."	| globalObj |	globalObj _ Smalltalk at: globalObjectName		ifAbsent: [^ self halt: 'can''t internalize'].	Symbol hasInterned: constructorSelector ifTrue: [:selector |		^ globalObj perform: selector				withArguments: constructorArgs].	^ nil 	"was not in proper form"! !!DiskProxy methodsFor: 'all'!global: globalNameSymbol selector: selectorSymbol args: argArray	"Initialize self as a DiskProxy constructor with the given	globalNameSymbol, selectorSymbol, and argument Array.	I will internalize by looking up the global object name in the	SystemDictionary (Smalltalk) and sending it this message with	these arguments."	globalObjectName _ globalNameSymbol asSymbol.	constructorSelector _ selectorSymbol asSymbol.	constructorArgs _ argArray.! !!DisplayMedium methodsFor: 'coloring'!fillBlack	"Set all bits in the receiver to black (ones)."	self fill: self boundingBox fillColor: Color black! !!DisplayMedium methodsFor: 'coloring'!fillBlack: aRectangle 	"Set all bits in the receiver's area defined by aRectangle to black (ones)."	self fill: aRectangle rule: Form over fillColor: Color black! !!DisplayMedium methodsFor: 'coloring'!fillWhite	"Set all bits in the form to white."	self fill: self boundingBox fillColor: Color white.! !!DisplayMedium methodsFor: 'coloring'!fillWhite: aRectangle	"Set all bits in the receiver's area defined by aRectangle to white."	self fill: aRectangle rule: Form over fillColor: Color white.! !!DisplayMedium methodsFor: 'coloring'!fillWithColor: aColor	"Fill the receiver's bounding box with the given color."	self fill: self boundingBox fillColor: aColor.! !!DisplayMedium methodsFor: 'bordering'!border: aRectangle width: borderWidth 	"Paint a border whose rectangular area is defined by aRectangle. The 	width of the border of each side is borderWidth. Uses black for 	drawing the border."	self border: aRectangle width: borderWidth fillColor: Color black.! !!DisplayObject methodsFor: 'display box access'!initialExtent	"Included here for when a FormView is being opened	as a window.  (4@4) covers border widths."	^ self extent + (4@4) ! !!DisplayObject methodsFor: 'displaying-generic' stamp: 'jm 10/21/97 16:56'!displayOnPort: port at: location rule: rule	port copyForm: self to: location rule: rule.! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'jm 10/22/97 07:39'!follow: locationBlock while: durationBlock bitsBehind: initialBitsBehind startingLoc: loc   "Move an image around on the Display. Restore the background continuously without causing flashing. The argument, locationBlock, supplies each new location, and the argument, durationBlock, supplies true to continue or false to stop. This variant takes the bitsBehind as an input argument, and returns the final saved saved bits as method value."   | location rect1 save1 save1Blt buffer bufferBlt newLoc rect2 bothRects |   location _ loc.   rect1 _ location extent: self extent.   save1 _ initialBitsBehind.   save1Blt _ BitBlt toForm: save1.   buffer _ Form extent: self extent*2 depth: Display depth.  "Holds overlapping region"   bufferBlt _ BitBlt toForm: buffer.   self displayOn: Display at: location rule: Form paint.   [durationBlock value] whileTrue: [		newLoc _ locationBlock value.		newLoc ~= location ifTrue: [			rect2 _ newLoc extent: self extent.			bothRects _ rect1 merge: rect2.			(rect1 intersects: rect2)				ifTrue: [  "when overlap, buffer background for both rectangles"					bufferBlt copyFrom: bothRects in: Display to: 0@0.					bufferBlt copyFrom: save1 boundingBox in: save1 to: rect1 origin - bothRects origin.					"now buffer is clean background; get new bits for save1"					save1Blt copy: (0@0 extent: self extent) from: rect2 origin - bothRects origin in: buffer.					self displayOnPort: bufferBlt at: rect2 origin - bothRects origin rule: Form paint.					Display copy: bothRects from: 0@0 in: buffer rule: Form over]				ifFalse: [  "when no overlap, do the simple thing (both rects might be too big)"					Display copy: (location extent: save1 extent) from: 0@0 in: save1 rule: Form over.					save1Blt copyFrom: rect2 in: Display to: 0@0.					self displayOn: Display at: newLoc rule: Form paint].			location _ newLoc.			rect1 _ rect2]].	^ save1 displayOn: Display at: location! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'di 9/12/97 11:09'!isTransparent	^ false! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'jm 10/22/97 07:43'!slideFrom: startPoint to: stopPoint nSteps: nSteps delay: milliSecs	"Slide this object across the display over the given number of steps, pausing for the given number of milliseconds after each step."	"Note: Does not display at the first point, but does at the last."	| i p delta |	i _ 0.	p _ startPoint.	delta _ (stopPoint - startPoint) / nSteps asFloat.	^ self		follow: [(p _ p + delta) truncated]		while: [			(Delay forMilliseconds: milliSecs) wait.			(i _ i + 1) < nSteps]! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'di 10/19/97 12:05'!slideFrom: startPoint to: stopPoint nSteps: nSteps delay: milliSecs andStay: stayAtEnd	"Does not display at the first point, but does at the last.	Moreover, if stayAtEnd is true, it leaves the dragged image at the stopPoint"	| i done |	i _ 0.	^ self follow: [startPoint + ((stopPoint-startPoint) * i // nSteps)]		while: [milliSecs ifNotNil: [(Delay forMilliseconds: milliSecs) wait].				((done _ (i _ i+1) > nSteps) and: [stayAtEnd])					ifTrue: [^ self "Return without clearing the image"].				done not]! !!DisplayScanner methodsFor: 'scanning' stamp: 'di 11/13/97 12:21'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun |	line _ textLine.	morphicOffset _ offset.	leftMargin _ (line leftMarginForAlignment: textStyle alignment) + offset x.	runX _ destX _ leftMargin.	rightMargin _ line rightMargin + offset x.	lineY _ line top + offset y.	lineHeight _ line lineHeight.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: leftMargin - line left height: lineHeight; copyBits].	lastIndex _ line first.	leftInRun <= 0		ifTrue: [self setStopConditions.  "also sets the font"				nowLeftInRun _ text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun _ leftInRun].	destY _ lineY + line baseline - font ascent.	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount _ 0.	done _ false.	[done] whileFalse: 		[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: text string rightX: rightMargin stopConditions: stopConditions						kern: kern displaying: true.		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition].	fillBlt == nil ifFalse:		[fillBlt destX: destX destY: lineY width: line right-destX height: lineHeight;				copyBits].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!DisplayScanner methodsFor: 'scanning' stamp: 'di 10/31/97 09:47'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	paragraph _ aParagraph.	foregroundColor _ paragraphColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt _ nil]		ifFalse: [fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt == nil ifFalse:			[fillBlt destX: visibleRectangle left destY: lineY				width: leftMargin - visibleRectangle left height: lineHeight; copyBits].		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		runStopIndex _ lastIndex + (runLength - 1) min: line last.		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: text string rightX: rightMargin stopConditions: stopConditions						kern: kern displaying: true.		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition].		fillBlt == nil ifFalse:			[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].		lineY _ lineY + lineHeight]! !!DisplayScanner methodsFor: 'scanning' stamp: 'di 11/13/97 12:22'!placeEmbeddedObject: anchoredMorph	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph 		ifTrue: [morphicOffset = (0@0) ifTrue:					[anchoredMorph position: (destX - width)@lineY]]		ifFalse: [destY _ lineY.				height _ anchoredMorph height.				runX _ destX.				anchoredMorph displayOn: destForm at: destX - width@destY].	^ true! !!DisplayScanner methodsFor: 'stop conditions'!crossedX	"This condition will sometimes be reached 'legally' during display, when, 	for instance the space that caused the line to wrap actually extends over 	the right boundary. This character is allowed to display, even though it 	is technically outside or straddling the clipping ectangle since it is in 	the normal case not visible and is in any case appropriately clipped by 	the scanner."	self fillLeading.	^ true ! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'di 10/21/97 20:11'!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	self fillLeading.  "Fill any leading above or below the font"	lastIndex = line last ifTrue: [^true].	runX _ destX.	runLength _ text runLengthFor: (lastIndex _ lastIndex + 1).	runStopIndex _ lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'di 10/21/97 13:53'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	| oldX |	spaceCount _ spaceCount + 1.	oldX _ destX.	destX _ destX + spaceWidth + (line justifiedPadFor: spaceCount).	fillBlt == nil ifFalse:		[fillBlt destX: oldX destY: destY width: destX - oldX height: height; copyBits].	lastIndex _ lastIndex + 1.	^ false! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'di 10/21/97 13:53'!tab	| oldX |	oldX _ destX.	destX _ (textStyle alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	fillBlt == nil ifFalse:		[fillBlt destX: oldX destY: destY width: destX - oldX height: height; copyBits].	lastIndex _ lastIndex + 1.	^ false! !!DisplayScanner methodsFor: 'private' stamp: 'di 10/31/97 12:49'!fillBlt	^ fillBlt! !!DisplayScanner methodsFor: 'private' stamp: 'di 10/21/97 13:50'!fillLeading	"At the end of every run (really only needed when font size changes),	fill any extra leading above and below the font in the larger line height"	fillBlt == nil ifTrue: [^ self].  "No fill requested"	"Fill space above the font"	fillBlt destX: runX destY: lineY width: destX - runX height: destY - lineY;		copyBits.	"Fill space below the font"	fillBlt destY: (destY + height); height: (lineY + lineHeight) - (destY + height);		copyBits.! !!DisplayScanner methodsFor: 'private' stamp: 'di 10/21/97 14:01'!setFont 	| map |	foregroundColor _ paragraphColor.	super setFont.  "Sets font and emphasis bits, and maybe foregroundColor"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this may need some caching for reasonable efficiency"		map _ (Color cachedColormapFrom: sourceForm depth to: destForm depth) copy.		map at: 1 put: ((backgroundColor bitPatternForDepth: destForm depth) at: 1).		self colorMap: map.		lastSourceDepth _ sourceForm depth].	sourceForm depth = 1 ifTrue:		[(colorMap == nil or: [destForm depth = 1]) ifFalse:			[colorMap at: 2 put: ((foregroundColor bitPatternForDepth: destForm depth) at: 1)]].	destY _ lineY + line baseline - font ascent! !!DisplayScanner methodsFor: 'private' stamp: 'di 10/31/97 09:42'!text: t textStyle: ts foreground: foreColor background: backColor fillBlt: blt	text _ t.	textStyle _ ts. 	foregroundColor _ paragraphColor _ foreColor.	(backgroundColor _ backColor) isTransparent ifFalse:		[fillBlt _ blt.		fillBlt fillColor: backgroundColor].! !!DisplayScanner methodsFor: 'private'!textColor: textColor	foregroundColor _ textColor! !!DisplayScreen methodsFor: 'displaying'!copyBits: rect from: sf at: destOrigin clippingBox: clipRect rule: cr fillColor: hf map: map	((BitBlt		destForm: self		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: rect origin		extent: rect extent		clipRect: (clipRect intersect: clippingBox)) colorMap: map) copyBits! !!DisplayScreen methodsFor: 'displaying'!flash: aRectangle 	"Flash the area of the screen defined by the given rectangle."	self reverse: aRectangle.	(Delay forMilliseconds: 100) wait.	self reverse: aRectangle.! !!DisplayScreen methodsFor: 'private' stamp: 'di 6/16/97 11:36'!newDepth: pixelSize"	Display newDepth: 8.	Display newDepth: 1."	self newDepthNoRestore: pixelSize.	ScheduledControllers unCacheWindows; restore.! !!DisplayScreen methodsFor: 'private' stamp: 'tk 12/10/96'!newDepthNoRestore: pixelSize	"Change depths.  Check if there is enough space!!  , di"	| area need |	pixelSize = depth ifTrue: [^ self  "no change"].	pixelSize < depth ifFalse:		["Make sure there is enough space"		area _ Display boundingBox area. "pixels"		ScheduledControllers scheduledWindowControllers do:			[:aController | aController view cacheBitsAsTwoTone ifFalse:				[area _ area + aController view windowBox area]].		need _ (area * pixelSize // 8) - (area * depth // 8)  "new bytes needed"				+ 80000.  "lowSpaceThreshold (should be shared)"		(Smalltalk garbageCollectMost <= need			and: [Smalltalk garbageCollect <= need])			ifTrue: [self halt: 'Insufficient free space']].	self depth: pixelSize.  	self setExtent: self extent.	ScheduledControllers updateGray.	DisplayScreen startUp! !!DisplayScreen methodsFor: 'disk I/O' stamp: 'tk 5/13/97'!objectToStoreOnDataStream	"I am about to be written on an object file.  Write a reference to the Display in the other system instead.  "	"A path to me"	^ DiskProxy global: #Display selector: #yourself args: #()! !!DisplayText methodsFor: 'converting' stamp: 'tk 10/21/97 12:28'!asParagraph	"Answer a Paragraph whose text and style are identical to that of the 	receiver."	| para |	para _ Paragraph withText: text style: textStyle.	para foregroundColor: foreColor backgroundColor: backColor.	backColor isTransparent ifTrue: [para rule: Form paint].	^ para! !!DisplayText methodsFor: 'color'!backgroundColor	backColor == nil ifTrue: [^ Color transparent].	^ backColor! !!DisplayText methodsFor: 'color'!foregroundColor	foreColor == nil ifTrue: [^ Color black].	^ foreColor! !!DisplayText class methodsFor: 'examples'!example	"Continually prints two lines of text wherever you point with the cursor 	and press any mouse button.  Terminate by pressing any key on the 	keyboard."	| tx |	tx _ 'this is a line of characters andthis is the second line.' asDisplayText.	tx foregroundColor: Color black backgroundColor: Color transparent.	tx _ tx alignedTo: #center.	[Sensor anyButtonPressed]		whileFalse:			[tx displayOn: Display at: Sensor cursorPoint]	"DisplayText example."! !I represent a DOS or Windows FileDirectory.!!DosFileDirectory class methodsFor: 'platform specific' stamp: 'jm 12/4/97 22:57'!pathNameDelimiter	^ $\! !DropShadowMorph comment:'DropShadows display all their submorphs at a given offset and in given color.'!!DropShadowMorph methodsFor: 'initialization' stamp: 'di 11/3/97 12:26'!initialize	super initialize.	shadowOffset _ 3@3! !!DropShadowMorph methodsFor: 'drawing' stamp: 'di 11/3/97 12:31'!drawOn: aCanvas	"Draw my submorphs as a shadow, then fullDrawOn will droaw them normally."	| shadowCanvas |	submorphs isEmpty ifTrue: [^ super drawOn: aCanvas].	shadowCanvas _ aCanvas copyForShadowDrawingOffset: shadowOffset.	shadowCanvas stipple: color.	submorphs reverseDo: [:m | m fullDrawOn: shadowCanvas].  "draw back-to-front"! !!DropShadowMorph methodsFor: 'geometry' stamp: 'di 11/3/97 15:00'!invalidRect: damageRect	owner ifNotNil:		[owner invalidRect: (damageRect merge: (damageRect translateBy: shadowOffset))].! !!DropShadowMorph methodsFor: 'geometry' stamp: 'di 11/3/97 13:04'!layoutChanged.	self computeBounds.	super layoutChanged.! !!DropShadowMorph methodsFor: 'menu' stamp: 'di 11/4/97 09:00'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'set offset' action: #setOffset:.	aCustomMenu add: 'remove shadow' action: #removeDropShadow.! !!DropShadowMorph methodsFor: 'menu' stamp: 'di 11/4/97 05:48'!removeDropShadow	owner addAllMorphs: self submorphs.	self delete! !!DropShadowMorph methodsFor: 'menu' stamp: 'di 11/3/97 17:02'!setOffset: evt	| handle |	handle _ HandleMorph new forEachPointDo:		[:newPoint | self shadowPoint: newPoint].	evt hand attachMorph: handle.	handle startStepping.! !!DropShadowMorph methodsFor: 'private' stamp: 'di 11/4/97 05:26'!computeBounds	submorphs isEmpty ifTrue:		[self extent: 50@40.		fullBounds _ nil.		^ self].	self changed.	bounds _ (submorphs first bounds) copy.	fullBounds _ nil.	bounds _ self fullBounds translateBy: shadowOffset.	self changed! !!DropShadowMorph methodsFor: 'private' stamp: 'di 11/3/97 17:03'!shadowPoint: newPoint	self changed.	shadowOffset _ newPoint - self center // 5.	self changed! !!DualChangeSorter methodsFor: 'everything' stamp: 'sw 8/7/97 19:01'!defaultBackgroundColor	^ #lightBlue! !!DualChangeSorter methodsFor: 'everything' stamp: 'sw 6/18/96'!open	"1991, tk.  Modified 5/16/96 sw: decrease minimum size drastically	 : more modest minimum size, and other minor adjustments	 : more useful choice for initial cs in second sorter"	| topView |	leftCngSorter _ ChangeSorter new initializeFor: Smalltalk changes.	leftCngSorter parent: self.	rightCngSorter _ ChangeSorter new initializeFor: ChangeSorter secondaryChangeSet.	rightCngSorter parent: self.	topView _ StandardSystemView new.	topView model: self.	topView label: leftCngSorter label.	topView minimumSize: 300 @ 200.	self openView: topView.	topView controller open! !!DualChangeSorter methodsFor: 'everything'!openView: topView	"Create views of dual side-by-side change sorter views""	| leftView rightView |	leftView _ View new.	leftView model: leftCngSorter.	leftView window: (0 @ 0 extent: 360 @ 360).	leftView borderWidthLeft: 0 right: 0 top: 0 bottom: 0."	leftCngSorter openView: topView offsetBy: 0@0."	rightView _ View new.	rightView model: rightCngSorter.	rightView window: (0 @ 0 extent: 360 @ 360).	rightView borderWidthLeft: 0 right: 0 top: 0 bottom: 0."	rightCngSorter openView: topView offsetBy: 360@0."	topView addSubView: leftView.	topView addSubView: rightView toRightOf: leftView."! !DummyStream comment:'The purpose of this class is to absorb all steam messages and do nothing.  This is so ReferenceStream can pretend to write on it while traversing all objects it would normally write.  We need to know what those object are.  8/17/96 tk'!!DummyStream methodsFor: 'all' stamp: 'tk 10/31/97 11:43'!close	"do nothing"! !!DummyStream methodsFor: 'all' stamp: '6/10/97 17:14 tk'!skip: aNumber	"Do nothing."! !!DummyStream class methodsFor: 'all' stamp: 'jm 12/3/97 20:25'!on: aFile	"Return a new DummyStream instance, ignoring the argument."	^ self basicNew! !DynamicContextCache comment:'I am part of the DynamicInterpreter, separate from that class for organisational purposes only.'!!DynamicContextCache methodsFor: 'initialization' stamp: 'ikp 12/11/97 16:52'!initializeCache: cacheAddress	"Initialize cache-related Interpreter state before starting execution of a new image."	"Note:	The caches initially contain garbage, which is fine since the interpreter is			expected to be *precise* in the initialisation and subsequent use of them			(including marking and remapping during GC and become operations)."	self inline: false.	"Make sure we have at least two cached contexts to play with"	(contextCacheEntries < 2) ifTrue: [self error: 'context cache too small (minimum 2 entries)'].	contextCache _ cacheAddress.	lastCachedContext _ contextCache + ((contextCacheEntries - 1) * CacheEntrySize).	activeCachedContext _ 0.	lowestCachedContext _ 0.	"Make sure we have at least contextCacheEntries stack cache entries"	(stackCacheEntries < contextCacheEntries) ifTrue: [self error: 'stack cache too small for context cache size'].	stackCache _ self contextCacheLimit.	stackCacheFence _ stackCache + ((stackCacheEntries - 1) * StackEntrySize).	stackOverflow _ false.! !!DynamicContextCache methodsFor: 'object memory support' stamp: 'ikp 12/11/97 17:00'!mapCachedContext: cp	"Notes:	the stack and instruction pointers are raw."	| tmp start limit ip meth |	self inline: true.	self assertIsCachedContext: cp.	"Map the context fields."	(self basicIsCachedMethodContext: cp) ifFalse: [		tmp _ self basicCachedHomeAt: cp.		self basicCachedHomeAt: cp put: (self remap: tmp).	].	tmp _ self basicCachedReceiverAt: cp.	(self isIntegerObject: tmp) ifFalse: [self basicCachedReceiverAt: cp put: (self remap: tmp)].	tmp _ self basicCachedTranslatedMethodAt: cp.	ip _ self basicCachedInstructionPointerAt: cp.	ip _ ip - tmp.	meth _ self remap: tmp.	ip _ ip + meth.	self basicCachedInstructionPointerAt: cp put: ip.	self basicCachedTranslatedMethodAt: cp put: meth.	tmp _ self basicCachedMethodAt: cp.	self basicCachedMethodAt: cp put: (self remap: tmp).	tmp _ self basicCachedPseudoContextAt: cp.	(tmp = 0) ifFalse: [self basicCachedPseudoContextAt: cp put: (self remap: tmp)].	"Map the stack"	start _ self cachedFramePointerAt: cp.	limit _ self cachedStackPointerAt: cp.	start to: limit by: 4 do: [ :ptr |		tmp _ self longAt: ptr.		(self isIntegerObject: tmp) ifFalse: [self longAt: ptr put: (self remap: tmp)].	].! !!DynamicContextCache methodsFor: 'object memory support' stamp: 'ikp 8/26/97 16:12'!mapContextCache	"Assumes: SP and IP are external and valid for the activeCachedContext."	| ctx tmp acc |	self inline: true.	acc _ activeCachedContext.	acc = 0 ifFalse: [		ctx _ lowestCachedContext.		tmp _ self basicCachedSenderAt: ctx.		self basicCachedSenderAt: ctx put: (self remap: tmp).		[ctx = 0] whileFalse: [			self mapCachedContext: ctx.			ctx = acc				ifTrue: [ctx _ 0]				ifFalse: [ctx _ self cachedContextAfter: ctx].		].	].! !!DynamicContextCache methodsFor: 'object memory support' stamp: 'ikp 11/30/97 18:43'!markAndTraceCachedContext: cp	| tmp start limit |	self inline: true.	self assertIsCachedContext: cp.	"Mark the context fields."	(self isCachedBlockContext: cp) ifTrue: [		self markAndTrace: (self cachedHomeAt: cp).	].	tmp _ self cachedMethodAt: cp.	self markAndTrace: tmp.	tmp _ self cachedTranslatedMethodAt: cp.	self markAndTrace: tmp.	tmp _ self cachedReceiverAt: cp.	(self isIntegerObject: tmp) ifFalse: [self markAndTrace: tmp].	tmp _ self cachedPseudoContextAt: cp.	tmp = 0 ifFalse: [self markAndTrace: tmp].	"Mark the stack."	start _ self cachedFramePointerAt: cp.	limit _ self cachedStackPointerAt: cp.	start to: limit by: 4 do: [ :ptr |		tmp _ self longAt: ptr.		(self isIntegerObject: tmp) ifFalse: [self markAndTrace: tmp].	].! !!DynamicContextCache methodsFor: 'object memory support' stamp: 'ikp 8/26/97 16:12'!markAndTraceContextCache	"Assumes: SP and IP are external and valid for the activeCachedContext."	| ctx tmp acc |	self inline: true.	acc _ activeCachedContext.	acc = 0 ifFalse: [		self assertStackPointerIsExternal.		self verifyStack.		ctx _ lowestCachedContext.		self assertIsCachedContext: ctx.		tmp _ self cachedSenderAt: ctx.		self assertIsStableContextOrNil: tmp.		self markAndTrace: tmp.			"Mark the stable section of the stack".		[ctx = 0] whileFalse: [			self markAndTraceCachedContext: ctx.			ctx = acc				ifTrue: [ctx _ 0]				ifFalse: [ctx _ self cachedContextAfter: ctx].		].	].! !!DynamicContextCache methodsFor: 'accessing' stamp: 'ikp 8/26/97 01:36'!cachedContextAfter: contextPointer	"Answer the address of the context cache frame after contextPointer.  Wrap from the	top context frame around to the bottom context frame."	self inline: true.	self assertIsCachedContext: contextPointer.	lastCachedContext = contextPointer ifTrue: [^contextCache].	^contextPointer + CacheEntrySize! !!DynamicContextCache methodsFor: 'accessing' stamp: 'ikp 12/9/97 15:48'!cachedContextBefore: contextPointer	"Answer the address of the context cache frame before contextPointer.  Wrap from the	bottom context frame around to the top context frame."	self inline: true.	self assertIsCachedContext: contextPointer.	(contextCache = contextPointer) ifTrue: [^lastCachedContext].	^contextPointer - CacheEntrySize! !!DynamicContextCache methodsFor: 'accessing' stamp: 'ikp 8/17/97 09:07'!cacheSize	"Answer the size (in bytes) of the all caches."	self inline: true.	^self contextCacheSize + self stackCacheSize! !!DynamicContextCache methodsFor: 'accessing' stamp: 'ikp 8/17/97 09:07'!contextCacheLimit	"Answer the address of the first word after the last context cache frame."	self inline: true.	^contextCache + self contextCacheSize! !!DynamicContextCache methodsFor: 'accessing' stamp: 'ikp 8/17/97 09:07'!contextCacheSize	"Answer the size (in bytes) of the context cache."	self inline: true.	^contextCacheEntries * CacheEntrySize! !!DynamicContextCache methodsFor: 'accessing' stamp: 'ikp 8/17/97 09:07'!stackCacheLimit	"Answer the address of the first word after the last stack cache location."	self inline: true.	^stackCache + self stackCacheSize! !!DynamicContextCache methodsFor: 'accessing' stamp: 'ikp 8/17/97 09:08'!stackCacheSize	"Answer the size (in bytes) of the stack cache."	self inline: true.	^stackCacheEntries * StackEntrySize! !!DynamicContextCache methodsFor: 'testing' stamp: 'ikp 8/18/97 01:35'!isBlockContext: ctx	"Answer if the stable context ctx is a BlockContext"	self inline: true.	self assertIsStableContext: ctx.	^self isIntegerObject: (self fetchPointer: MethodIndex ofObject: ctx)! !!DynamicContextCache methodsFor: 'testing' stamp: 'ikp 8/18/97 01:35'!isCachedBlockContext: cp	"Answer if the cached context cp represents a BlockContext"	self inline: true.	self assertIsCachedContext: cp.	^(self cachedHomeAt: cp) ~= 0! !!DynamicContextCache methodsFor: 'testing' stamp: 'ikp 8/18/97 01:35'!isCachedMethodContext: cp	"Answer if the cached context cp represents a MethodContext"	self inline: true.	self assertIsCachedContext: cp.	^(self cachedHomeAt: cp) = 0! !!DynamicContextCache methodsFor: 'testing' stamp: 'ikp 8/18/97 01:35'!isMethodContext: ctx	"Answer if the stable context ctx is a MethodContext"	self inline: true.	self assertIsStableContext: ctx.	^(self isBlockContext: ctx) not! !!DynamicContextCache methodsFor: 'testing' stamp: 'ikp 8/26/97 16:13'!isPseudoContext: aContext	self inline: true.	self assertIsContext: aContext.	^(self isIntegerObject: (self fetchPointer: SenderIndex ofObject: aContext))! !!DynamicContextCache methodsFor: 'testing' stamp: 'ikp 8/26/97 16:13'!isStableContext: ctx	"Answer if the object ctx is a BlockContext or MethodContext"	self inline: true.	^(self isPseudoContext: ctx) not! !!DynamicContextCache methodsFor: 'stack accessing' stamp: 'ikp 8/18/97 13:09'!cachedStackIndexAt: cp	"Answer Smalltalk's index for the stack pointer in cp."	self inline: true.	self assertIsCachedContext: cp.	^self integerObjectOf: (self cachedStackPointerAt: cp) - (self cachedFramePointerAt: cp) // 4 + 1! !!DynamicContextCache methodsFor: 'stack accessing' stamp: 'ikp 8/18/97 13:10'!cachedStackIndexAt: cp put: anInteger	self inline: true.	self assertIsIntegerObject: anInteger.	self cachedStackPointerAt: cp put: (self cachedFramePointerAt: cp) + (((self integerValueOf: anInteger) - 1) * 4)! !!DynamicContextCache methodsFor: 'stack accessing' stamp: 'ikp 8/26/97 17:14'!cachedTemporaryPointerAt: cp	self inline: true.	^self longAt: cp + (CacheTempPointerIndex * 4)! !!DynamicContextCache methodsFor: 'stack accessing' stamp: 'ikp 8/26/97 15:59'!cachedTemporaryPointerAt: cp put: tp	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CacheTempPointerIndex * 4) put: tp! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/18/97 12:54'!cachedBlockArgumentCountAt: cp	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CacheBlockArgumentCountIndex * 4)! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/18/97 12:54'!cachedBlockArgumentCountAt: cp put: anInteger	self inline: true.	self assertIsCachedContext: cp.	self assertIsIntegerObject: anInteger.	self longAt: cp + (CacheBlockArgumentCountIndex * 4) put: anInteger! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/18/97 12:54'!cachedCallerAt: cp put: aContext	self inline: true.	self assertIsCachedContext: cp.	self assertIsStableContextOrNil: aContext.	self longAt: cp + (CacheCallerIndex * 4) put: aContext! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/21/97 00:31'!cachedFramePointerAt: cp	"Answer the frame pointer for the given context"	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CacheFramePointerIndex * 4)! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/21/97 00:31'!cachedFramePointerAt: cp put: fp	"Answer the frame pointer for the given context"	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CacheFramePointerIndex * 4) put: fp! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/18/97 13:12'!cachedHomeAt: cp	self inline: true.	self assertIsCachedContext: cp.	self assertIsContextOrNull: (self longAt: cp + (CacheHomeIndex * 4)).	^self longAt: cp + (CacheHomeIndex * 4)! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/18/97 12:54'!cachedHomeAt: cp put: aContext	self inline: true.	self assertIsCachedContext: cp.	self assertIsContextOrNull: aContext.	self longAt: cp + (CacheHomeIndex * 4) put: aContext."	self cachedTemporaryPointerAt: cp put: (self temporaryPointerForCachedContext: aContext)."! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/18/97 13:12'!cachedInitialIPAt: cp	self inline: true.	self assertIsCachedContext: cp.	self assertIsIntegerObject: (self longAt: cp + (CacheInitialIPIndex * 4)).	^self longAt: cp + (CacheInitialIPIndex * 4)! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/18/97 12:54'!cachedInitialIPAt: cp put: anInteger	self inline: true.	self assertIsCachedContext: cp.	self assertIsIntegerObject: anInteger.	self longAt: cp + (CacheInitialIPIndex * 4) put: anInteger! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/18/97 13:16'!cachedMethodAt: cp	self inline: true.	self assertIsCachedContext: cp.	self assertIsCompiledMethod: (self longAt: cp + (CacheMethodIndex * 4)).	^self longAt: cp + (CacheMethodIndex * 4)! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/18/97 12:55'!cachedMethodAt: cp put: aCompiledMethod	self inline: true.	self assertIsCachedContext: cp.	self assertIsCompiledMethod: aCompiledMethod.	self longAt: cp + (CacheMethodIndex * 4) put: aCompiledMethod! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 1/5/98 16:32'!cachedPseudoContextAt: cp	self inline: true.	self assertIsCachedContext: cp.	self assertIsPseudoContextOrNull: (self longAt: cp + (CachePseudoContextIndex * 4)).	self assertIsValidPseudoContextAt: cp.	^self longAt: cp + (CachePseudoContextIndex * 4)! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 1/5/98 16:40'!cachedPseudoContextAt: cp put: aPseudoContext	self inline: true.	self assertIsCachedContext: cp.	self assertIsPseudoContextOrNull: aPseudoContext.	self longAt: cp + (CachePseudoContextIndex * 4) put: aPseudoContext.! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/18/97 13:17'!cachedReceiverAt: cp	self inline: true.	self assertIsCachedContext: cp.	self assertIsOop: (self longAt: cp + (CacheReceiverIndex * 4)).	^self longAt: cp + (CacheReceiverIndex * 4)! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/18/97 12:55'!cachedReceiverAt: cp put: anObject	self inline: true.	self assertIsCachedContext: cp.	self assertIsOop: anObject.	self longAt: cp + (CacheReceiverIndex * 4) put: anObject! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/18/97 13:17'!cachedSenderAt: cp	self inline: true.	self assertIsCachedContext: cp.	self assertIsStableContextOrNilOrNull: (self longAt: cp + (CacheSenderIndex * 4)).	^self longAt: cp + (CacheSenderIndex * 4)! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 12/17/97 13:51'!cachedSenderAt: cp put: aContext	self inline: true.	self assertIsCachedContext: cp.	self assertIsStableContextOrNilOrNull: aContext.			"nil if base context"	self longAt: cp + (CacheSenderIndex * 4) put: aContext! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/21/97 00:31'!cachedStackPointerAt: cp	"Answer the raw stack pointer for the given context"	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CacheStackPointerIndex * 4)! !!DynamicContextCache methodsFor: 'context accessing' stamp: 'ikp 8/21/97 00:32'!cachedStackPointerAt: cp put: rawPointer	"Store the stack pointer in the given context"	self inline: true.	self assertIsCachedContext: cp.	self longAt: cp + (CacheStackPointerIndex * 4) put: rawPointer! !!DynamicContextCache methodsFor: 'cache management' stamp: 'ikp 8/26/97 15:27'!allocateCachedContextAfter: activeContext frame: fp	"Answer a new cached context, initialised with the given frame pointer,	and set activeCachedContext to point to it.  If the context cache overflows then eject the lowest	cached context to make space available.  If the stack cache overflows, wrap it implicitly by setting	the framePointer in the new context to a usable stack location, and set stackOverflow to true to	alert the caller.  The caller is *obliged* to check this flag: if it is true then the caller must fetch	the frame pointer that was actually allocated out of the new context, and use it instead of the	the frame pointer originally requested.  The caller is also responsible for copying any arguments	or other values from the top of the stack cache to the new frame's location during stack overflow,	and for resetting the stackOverflow flag to false once this is done.	The new cached context has the pseudoContext and sender fields set to 0, the framePointer field	set to the actual location of the stack frame, the home field set to the supplied home pointer	(which will be 0 for methods), and the temporaryPointer field set to the base of the temporary	frame (this is either the same as the framePointer [methods], the frame pointer of the [cached]	home context, or the address of the first indexable field in the [stable] home context).								Note:	This method can cause a GC!!	This in turn obliges the caller to truncate the active context's stack AFTER calling this method."	| newCachedContext |	self inline: true.	newCachedContext _ self cachedContextAfter: activeContext.	newCachedContext = lowestCachedContext ifTrue: [		self ejectFromCache: newCachedContext.		lowestCachedContext _ self cachedContextAfter: newCachedContext.	].	self initializeCachedContext: newCachedContext.	activeCachedContext _ newCachedContext.	fp >= stackCacheFence ifTrue: [		self cachedFramePointerAt: newCachedContext put: stackCache.	"wrap the stack"		stackOverflow _ true.		^newCachedContext.	].	self cachedFramePointerAt: newCachedContext put: fp.	^newCachedContext! !!DynamicContextCache methodsFor: 'cache management' stamp: 'ikp 11/30/97 19:12'!copyCache: cp toPseudoContext: ctx setSender: senderFlag	"Copy the cached context cp into the pseudo context ctx.  Mutate ctx into the appropriate	stable context in the process.  Leave the sender field according to senderFlag, where 'true'	means use the cached sender (e.g. when ejecting because of overflow), 'false' means nil	(e.g. when stabilising during return)."	| sp sz stackSize |	self inline: false.	self assertIsCachedContext: cp.	self assertIsPseudoContext: ctx.	(self isCachedMethodContext: cp) ifTrue: [		self mutateToMethodContext: ctx.		self storePointerUnchecked:	InstructionPointerIndex		ofObject: ctx withValue:	(self cachedInstructionIndexAt: cp).		self storePointerUnchecked:	StackPointerIndex			ofObject: ctx withValue:	(sp _ self cachedStackIndexAt: cp).		self storePointerUnchecked:	MethodIndex					ofObject: ctx withValue:	(self cachedMethodAt: cp).		self storePointerUnchecked:	TranslatedMethodIndex		ofObject: ctx withValue:	(self cachedTranslatedMethodAt: cp).		self storePointerUnchecked:	ReceiverIndex				ofObject: ctx withValue:	(self cachedReceiverAt: cp).		"The cached context might have been the home context for a cached block activation -- fix the situation""		self redirectTemporaryPointersFrom: (self cachedFramePointerAt: cp)			to: (ctx + BaseHeaderSize + (TempFrameStart * 4))."	] ifFalse: [		self mutateToBlockContext: ctx.		self storePointerUnchecked:	InstructionPointerIndex		ofObject: ctx withValue:	(self cachedInstructionIndexAt: cp).		self storePointerUnchecked:	StackPointerIndex			ofObject: ctx withValue:	(sp _ self cachedStackIndexAt: cp).		self storePointerUnchecked:	BlockArgumentCountIndex	ofObject: ctx withValue:	(self cachedBlockArgumentCountAt: cp).		self storePointerUnchecked:	InitialIPIndex				ofObject: ctx withValue:	(self cachedInitialIPAt: cp).		self storePointerUnchecked:	HomeIndex					ofObject: ctx withValue:	(self cachedHomeAt: cp).	].	senderFlag ifTrue: [		self storePointerUnchecked: SenderIndex ofObject: ctx withValue: (self cachedSenderAt: cp).	] ifFalse: [		self storePointerUnchecked: SenderIndex ofObject: ctx withValue: nilObj.	].	"Copy the stack."	sz _ ((self sizeBitsOf: ctx) - BaseHeaderSize) // 4 - TempFrameStart.	"12 or 32"	stackSize _ self integerValueOf: sp.	stackSize > sz ifTrue: [self error: 'stack overflow while stabilising context'].	self	inlineTransfer:	stackSize		wordsFrom:		(self cachedFramePointerAt: cp)		to:				ctx + BaseHeaderSize + (TempFrameStart * 4).	"Pseudo-contexts are born full of nil -- no need to fill the rest."	ctx < youngStart ifTrue: [self beRootIfOld: ctx].	self assertIsStableContext: ctx.	self assertIsLegalStackOffsetInContext: ctx.	^ctx! !!DynamicContextCache methodsFor: 'cache management' stamp: 'ikp 1/5/98 16:39'!copyContextToCache: ctx	"Copy ctx into the first context cache location, resetting activeCachedContext in the process.	Mutate the source context into a PseudoContext in the process.	Assumes:	ctx is the topmost context in the stable stack.				The context cache is initially empty.	Notes:		If ctx is a BlockContext, the home context is guaranteed to be stable."	| cp sp home |	self inline: false.	self assertIsStableContext: ctx.	"Reset the context cache to initial conditions."	cp _ lowestCachedContext _ activeCachedContext _ contextCache.	self initializeCachedContext: cp.	self cachedFramePointerAt: cp put: stackCache.	(self isMethodContext: ctx) ifTrue: [		self cachedMethodAt:				cp put: (self fetchPointer: MethodIndex				ofObject: ctx).		self cachedTranslatedMethodAt:		cp put: (self fetchPointer: TranslatedMethodIndex		ofObject: ctx).		self cachedReceiverAt:				cp put: (self fetchPointer: ReceiverIndex				ofObject: ctx).		self cachedHomeAt:					cp put: 0.		self cachedSenderAt:					cp put: (self fetchPointer: SenderIndex				ofObject: ctx).		self cachedInstructionIndexAt:		cp put: (self fetchPointer: InstructionPointerIndex	ofObject: ctx).		self cachedStackIndexAt:				cp put: (self fetchPointer: StackPointerIndex			ofObject: ctx)."		self cachedTemporaryPointerAt:		cp put: stackCache."	] ifFalse: [		home _ self fetchPointer: HomeIndex ofObject: ctx.		self cachedHomeAt:					cp put: (home).		self cachedMethodAt:				cp put: (self methodOfBlockContext: ctx).		self cachedTranslatedMethodAt:		cp put: (self translatedMethodOfBlockContext: ctx).		self cachedReceiverAt:				cp put: (self receiverOfBlockContext: ctx).		self cachedCallerAt:					cp put: (self fetchPointer: CallerIndex				ofObject: ctx).		self cachedInstructionIndexAt:		cp put: (self fetchPointer: InstructionPointerIndex	ofObject: ctx).		self cachedStackIndexAt:				cp put: (self fetchPointer: StackPointerIndex			ofObject: ctx).		self cachedBlockArgumentCountAt:	cp put: (self fetchPointer: BlockArgumentCountIndex	ofObject: ctx).		self cachedInitialIPAt:				cp put: (self fetchPointer: InitialIPIndex				ofObject: ctx).		self assertIsStableMethodContext: home."		self cachedTemporaryPointerAt:		cp put: (home + BaseHeaderSize + (TempFrameStart * 4)).""		home < youngStart ifTrue: [self beRootIfOld: home]."	].	"Copy the stack"	sp _ self quickFetchInteger: StackPointerIndex ofObject: ctx.	self	inlineTransfer:	sp			wordsFrom:	ctx + BaseHeaderSize + (TempFrameStart * 4)			to:			(self cachedFramePointerAt: cp).	"Unused stack locations are ignored by GC -- no need to fill with nil"	self mutateToPseudoContext: ctx.		"fills with nil in the process"	self cachedPseudoContextAt: cp put: ctx.	self pseudoCachedContextAt: ctx put: cp.	self assertIsValidPseudoContextAt: cp.	ctx < youngStart ifTrue: [self beRootIfOld: ctx]		"*** I DON'T THINK THIS IS NEEDED (there are no real pointers in it!!) ***"! !!DynamicContextCache methodsFor: 'cache management' stamp: 'ikp 1/5/98 16:45'!deallocateAllCachedContexts	"Deallocate the all cached contexts, resetting activeCachedContext to indicate the absence of	any active context.  If any cached context has a pseudo context, copy its state into the	pseudo context, but leave the sender field nil.  Answer the topmost stable context.	Notes:	It is the caller's responsibility to reinitialise the cache for subsequent execution."	| cp pc stableContext |	self inline: false.	cp _ activeCachedContext.	[cp = 0] whileFalse: [		stableContext _ self cachedSenderAt: cp.		pc _ self cachedPseudoContextAt: cp.		pc = 0 ifFalse: [			self assertIsValidPseudoContextAt: cp.			self copyCache: cp toPseudoContext: pc setSender: false.			self cachedPseudoContextAt: cp put: 0.	"sane value for future allocations"		].		cp = lowestCachedContext			ifTrue: [cp _ 0]			ifFalse: [cp _ self cachedContextBefore: cp].	].	activeCachedContext _ 0.	^stableContext! !!DynamicContextCache methodsFor: 'cache management' stamp: 'ikp 1/5/98 16:46'!deallocateCachedContext	"Deallocate the top cached context, setting activeCachedContext to the appropriate new value.	If the old activeCachedContext has a pseudo context, copy its state into the pseudo context,	but leave the sender field nil.  If the context cache underflows, copy the topmost stable	context into the cache and reset activeCachedContext and lowestCachedContext appropriately.	If the new activeCachedContext is a block context with a stable home, make the home a root	if it is in old space."	| cp pc |	self inline: true.	cp _ activeCachedContext.	pc _ self cachedPseudoContextAt: cp.	pc = 0 ifFalse: [		self assertIsValidPseudoContextAt: cp.		self copyCache: cp toPseudoContext: pc setSender: false.		self cachedPseudoContextAt: cp put: 0.	"sane value for future allocations"	].	cp = lowestCachedContext ifTrue: [		self copyContextToCache: (self cachedSenderAt: cp).	] ifFalse: [		cp _ self cachedContextBefore: cp.		activeCachedContext _ cp.	].! !!DynamicContextCache methodsFor: 'cache management' stamp: 'ikp 8/17/97 13:55'!ejectFromCache: cp	"We're ejecting cp, the lowest cached context, to make room for a new active cached	context.  Fetch the PseudoContext for the ejected context, turn it into a real context,	and fill it in from the cache.  Fix the sender field in the following cached context to	point to the newly stabilised context.  Answer the new stable context.	Assumes:	The cached sender of cp is a stable context.	Notes:		This method can provoke a GC."	| ctx |	self inline: false.	self assertIsCachedContext: cp.	ctx _ self pseudoContextFor: cp.	self assertIsPseudoContext: ctx.	self copyCache: cp toPseudoContext: ctx setSender: true.	self assertIsStableContext: ctx.	self cachedSenderAt: (self cachedContextAfter: cp) put: ctx.	^ctx! !!DynamicContextCache methodsFor: 'cache management' stamp: 'ikp 12/9/97 15:48'!flushCacheFrom: cp	"Flush the cache starting at the cached context cp.  Answer the new top context	in the stable section of the stack.	Notes:	We flush the cache from the lowestCachedContext to cp inclusive, using			ejectFromCache: which already implements exactly the required behaviour.			This method can provoke a GC."	| ctx done |	self inline: false.	self assertIsCachedContext: cp.	done _ false.	[done] whileFalse: [		ctx _ self ejectFromCache: lowestCachedContext.		done _ lowestCachedContext = cp.		lowestCachedContext _ self cachedContextAfter: lowestCachedContext.	].	self assertIsStableContext: ctx.	cp = activeCachedContext ifTrue: [activeCachedContext _ lowestCachedContext _ 0].	^ctx! !!DynamicContextCache methodsFor: 'cache management' stamp: 'ikp 12/27/97 14:44'!initializeCachedContext: cp	"Init the private fields of cp."	"cp to: cp + CacheEntrySize - 4 by: 4 do: [:ptr | self longAt: ptr put: nilObj]."	self inline: true.	self cachedSenderAt:					cp put: 0.	self cachedPseudoContextAt:			cp put: 0.	"self cachedContextReceiverFlagAt:	cp put: 0."	"no longer needed"! !!DynamicContextCache methodsFor: 'pseudo contexts' stamp: 'ikp 1/5/98 16:45'!allocatePseudoContextFor: cp	"Answer the PseudoContext for cp.  Create one if necessary.	Notes:	This method can provoke a GC."	| pc methodHeader smallContext meth |	self inline: false.	self assertIsCachedContext: cp.	meth _ self cachedMethodAt: cp.	methodHeader _ self headerOf: meth.	smallContext _ ((methodHeader >> 18) bitAnd: 1) = 0.	smallContext ifTrue: [		pc _ self instantiateSmallClass: (self splObj: ClassPseudoContext) sizeInBytes: SmallContextSize fill: nilObj.	] ifFalse: [		pc _ self instantiateSmallClass: (self splObj: ClassPseudoContext) sizeInBytes: LargeContextSize fill: nilObj.	].	"The cached context and associated pseudo context contain back pointers to each other."	self pseudoCachedContextAt: pc put: cp.	self cachedPseudoContextAt: cp put: pc.	self assertIsValidPseudoContextAt: cp.	^pc! !!DynamicContextCache methodsFor: 'pseudo contexts' stamp: 'ikp 10/20/97 12:34'!mutateToBlockContext: aContext	"Change the class of aContext to BlockContext"	self inline: true.	self assertIsPseudoContext: aContext.	self changeClassOf: aContext to: (self splObj: ClassBlockContext)! !!DynamicContextCache methodsFor: 'pseudo contexts' stamp: 'ikp 10/20/97 12:34'!mutateToMethodContext: aContext	"Change the class of aContext to MethodContext"	self inline: true.	self assertIsPseudoContext: aContext.	self changeClassOf: aContext to: (self splObj: ClassMethodContext)! !!DynamicContextCache methodsFor: 'pseudo contexts' stamp: 'ikp 10/20/97 12:34'!mutateToPseudoContext: aContext	"Change the class of aContext to PseudoContext and set the entire contents to nil."	| nilOop |	self inline: true.	self assertIsStableContext: aContext.	self changeClassOf: aContext to: (self splObj: ClassPseudoContext)."IS THIS NECESSARY?"	nilOop _ nilObj.	self fill:		((self sizeBitsOf: aContext) - BaseHeaderSize) // 4 - 1		wordsFrom:	aContext + BaseHeaderSize		with:		nilOop.! !!DynamicContextCache methodsFor: 'pseudo contexts' stamp: 'ikp 8/17/97 09:34'!pseudoCachedContextAt: pc	"Answer the cached context pointer for the PseudoContext pc.	Notes:	The cached context pointer is encoded as an integer in the sender			field of the PseudoContext.  Subtract 1 to get the real pointer."	self inline: true.	self assertIsPseudoContext: pc.	self assertIsCachedContext: ((self fetchPointer: CachedContextIndex ofObject: pc) - 1).	^(self fetchPointer: CachedContextIndex ofObject: pc) - 1! !!DynamicContextCache methodsFor: 'pseudo contexts' stamp: 'ikp 1/5/98 16:43'!pseudoCachedContextAt: pc put: cachePointer	"Store the cached context pointer for the PseudoContext pc.	Notes:	The cached context pointer is encoded as an integer in the sender			field of the PseudoContext.  Add 1 to get the encoded integer."	self inline: true.	self assertIsPseudoContext: pc.	self assertIsCachedContext: cachePointer.	self storeWord: CachedContextIndex ofObject: pc withValue: cachePointer + 1! !!DynamicContextCache methodsFor: 'pseudo contexts' stamp: 'ikp 12/9/97 15:48'!pseudoContextFor: cp	"Answer the PseudoContext for cp.  Create one if necessary.	Notes:	This method can provoke a GC."	| pc |	self inline: true.	self assertIsCachedContext: cp.	pc _ self cachedPseudoContextAt: cp.	pc = 0 ifTrue: [pc _ self allocatePseudoContextFor: cp].	self assertIsPseudoContext: pc.	^pc! !!DynamicContextCache methodsFor: 'pseudo contexts' stamp: 'ikp 8/18/97 12:56'!stableClassOf: pc	"Answer the class needed to represent a stable version of the PseudoContext pc."	| cp |	self inline: true.	self assertIsPseudoContext: pc.	cp _ self pseudoCachedContextAt: pc.	(self isCachedBlockContext: cp)		ifTrue: [^self splObj: ClassBlockContext]		ifFalse: [^self splObj: ClassMethodContext]! !!DynamicContextCache methodsFor: 'pseudo contexts' stamp: 'ikp 8/18/97 12:57'!wordLengthOfContext: cp	"Anwer the size in words of the stable context needed to represent the cached context cp."	| pc meth methodHeader |	self inline: true.	self assertIsCachedContext: cp.	pc _ self cachedPseudoContextAt: cp.	pc = 0 ifTrue: [		meth _ self cachedMethodAt: cp.		methodHeader _ self headerOf: meth.		((methodHeader >> 18) bitAnd: 1) = 0 ifTrue: [			^SmallContextSize - BaseHeaderSize // 4.		] ifFalse: [			^LargeContextSize - BaseHeaderSize // 4.		].	] ifFalse: [		^self fetchWordLengthOf: pc.	].! !!DynamicContextCache methodsFor: 'utilities' stamp: 'ikp 8/26/97 17:37'!addRootsForCachedContext: ctx	| home |	home _ self cachedHomeAt: ctx.	home = 0 ifFalse: [		(self isStableContext: home) ifTrue: [			home < youngStart ifTrue: [self beRootIfOld: home].		].	].! !!DynamicContextCache methodsFor: 'utilities' stamp: 'ikp 8/25/97 17:11'!baseHeader: oop put: newHeader	"Note:	This method should be in ObjectMemory"	^ self longAt: oop put: newHeader! !!DynamicContextCache methodsFor: 'utilities' stamp: 'ikp 10/20/97 12:33'!changeClassOf: anObject to: aClass	"Used to mutate a PseudoContext to/from a stable Method/BlockContext.	Notes:	Tacitly assumes that the type bits are the SAME for the source and destination!!			This method should be in ObjectMemory."	| ccClass hdrObject ccObject |	self inline: false.	hdrObject _ self baseHeader: anObject.	ccObject _ hdrObject bitAnd: 16r1F000.	ccObject = 0 ifTrue: [		"object has uncompact class"		self classHeader: anObject put: aClass.	] ifFalse: [		"object has compact class"		ccClass _ (self formatOfClass: aClass) bitAnd: 16rF000.		ccClass ~= 0 ifTrue: [			"object has compact class; class is compact"			hdrObject _ (hdrObject bitXor: ccObject) bitOr: ccClass.			self baseHeader: anObject put: hdrObject.		] ifFalse: [			"object has compact class; class is uncompact"			self error: 'cannot mutate header from compact to uncompact'.		]	]! !!DynamicContextCache methodsFor: 'utilities' stamp: 'ikp 8/25/97 17:01'!classHeader: oop put: newClass	"Note:	This method should be in ObjectMemory"	^ self longAt: oop - 4 put: newClass! !!DynamicContextCache methodsFor: 'utilities' stamp: 'ikp 8/18/97 12:57'!fill: num wordsFrom: dst with: val	"Note: this could be rewritten to use memset() in the C translation."	| out ctr |	self inline: true.	out	_ dst - 4.		"pre-increment is our friend on many architectures."	ctr	_ num.	[(ctr _ ctr - 1) >= 0] whileTrue: [		self longAt: (out _ out + 4) put: val.	].! !!DynamicContextCache methodsFor: 'utilities' stamp: 'ikp 8/27/97 09:46'!inlineTransfer: num wordsFrom: src to: dst	| in out ctr |	self inline: true.	in	_ src - 4.		"pre-increment is our friend on many architectures."	out	_ dst - 4.	ctr	_ num.	[(ctr _ ctr - 1) >= 0] whileTrue: [		self longAt: (out _ out + 4) put: (self longAt: (in _ in + 4)).	].! !!DynamicContextCache methodsFor: 'utilities' stamp: 'ikp 8/27/97 12:12'!temporaryPointerForCachedContext: cp	| home |	self inline: true.	self assertIsCachedContext: cp.	home _ self cachedHomeAt: cp.	home = 0 ifTrue: [		^self cachedFramePointerAt: cp.	] ifFalse: [		(self isPseudoContext: home) ifTrue: [			^self cachedFramePointerAt: (self pseudoCachedContextAt: home).		] ifFalse: [			^home + BaseHeaderSize + (TempFrameStart * 4).		].	].! !!DynamicContextCache methodsFor: 'utilities' stamp: 'ikp 8/27/97 09:46'!transfer: num wordsFrom: src to: dst	| in out ctr |	self inline: false.	in	_ src - 4.		"pre-increment is our friend on many architectures."	out	_ dst - 4.	ctr	_ num.	[(ctr _ ctr - 1) >= 0] whileTrue: [		self longAt: (out _ out + 4) put: (self longAt: (in _ in + 4)).	].! !!DynamicContextCache methodsFor: 'private' stamp: 'ikp 8/18/97 12:57'!basicCachedHomeAt: cp	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CacheHomeIndex * 4)! !!DynamicContextCache methodsFor: 'private' stamp: 'ikp 8/18/97 12:57'!basicCachedHomeAt: cp put: aContext	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	self longAt: cp + (CacheHomeIndex * 4) put: aContext! !!DynamicContextCache methodsFor: 'private' stamp: 'ikp 8/18/97 12:57'!basicCachedInstructionPointerAt: cp	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CacheInstructionPointerIndex * 4)! !!DynamicContextCache methodsFor: 'private' stamp: 'ikp 8/18/97 12:57'!basicCachedInstructionPointerAt: cp put: ip	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CacheInstructionPointerIndex * 4) put: ip.! !!DynamicContextCache methodsFor: 'private' stamp: 'ikp 8/18/97 12:57'!basicCachedMethodAt: cp	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CacheMethodIndex * 4)! !!DynamicContextCache methodsFor: 'private' stamp: 'ikp 8/18/97 12:57'!basicCachedMethodAt: cp put: aCompiledMethod	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	self longAt: cp + (CacheMethodIndex * 4) put: aCompiledMethod! !!DynamicContextCache methodsFor: 'private' stamp: 'ikp 8/18/97 12:57'!basicCachedPseudoContextAt: cp	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CachePseudoContextIndex * 4)! !!DynamicContextCache methodsFor: 'private' stamp: 'ikp 8/18/97 12:57'!basicCachedPseudoContextAt: cp put: aPseudoContext	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CachePseudoContextIndex * 4) put: aPseudoContext! !!DynamicContextCache methodsFor: 'private' stamp: 'ikp 8/18/97 12:57'!basicCachedReceiverAt: cp	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CacheReceiverIndex * 4)! !!DynamicContextCache methodsFor: 'private' stamp: 'ikp 8/18/97 12:57'!basicCachedReceiverAt: cp put: anObject	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	self longAt: cp + (CacheReceiverIndex * 4) put: anObject! !!DynamicContextCache methodsFor: 'private' stamp: 'ikp 8/18/97 12:57'!basicCachedSenderAt: cp	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CacheSenderIndex * 4)! !!DynamicContextCache methodsFor: 'private' stamp: 'ikp 8/18/97 12:57'!basicCachedSenderAt: cp put: aContext	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	self longAt: cp + (CacheSenderIndex * 4) put: aContext! !!DynamicContextCache methodsFor: 'private' stamp: 'ikp 8/18/97 12:57'!basicIsCachedMethodContext: cp	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	^(self basicCachedHomeAt: cp) = 0! !!DynamicContextCache class methodsFor: 'class initialization' stamp: 'ikp 12/1/97 14:20'!initialize	"DynamicContextCache initialize"	super initialize.	self initializeCacheIndices.	self initializePseudoContextIndices.	ContextCacheEntries		_ 16.	CacheEntrySize			_ CachedContextSize * 4.	StackCacheEntries		_ 16.	StackEntrySize			_ 32 * 4! !!DynamicContextCache class methodsFor: 'class initialization' stamp: 'ikp 12/27/97 14:44'!initializeCacheIndices		"ContextCache initialize"	"Method contexts"	CacheSenderIndex				_ 0.						"caller of this method context"	CacheInstructionPointerIndex		_ 1.						"raw instruction pointer (points into method body)"	CacheStackPointerIndex			_ 2.						"raw stack pointer (points into stack cache)"	CacheMethodIndex				_ 3.						"method (home method for blocks)"	CacheReceiverIndex				_ 4.						"receiver (home receiver for blocks)"	"Block contexts"	CacheCallerIndex				_ CacheSenderIndex.		"caller of this block context"	CacheBlockArgumentCountIndex	_ 5.						"number of arguments (used only in stabilisation)"	CacheInitialIPIndex				_ 6.						"initial IP (used only in stabilisation)"	CacheHomeIndex					_ 7.						"home context (stable or pseudo) (0 for methods)"	"All contexts"	CachePseudoContextIndex			_ 8.						"allocated PseudoContext (0 if unallocated)"	CacheFramePointerIndex			_ 9.						"address of stack frame (first temp) in cache"	CacheTempPointerIndex			_ 10.					"address of first temporary in cache or heap context"	CacheTranslatedMethodIndex		_ 11.					"translated method corresponding to method"	"CacheContextReceiverFlagIndex	_ 12."					"non-nil if receiver is a context"	CachedContextSize				_ 12.! !!DynamicContextCache class methodsFor: 'class initialization' stamp: 'ikp 8/16/97 19:51'!initializePseudoContextIndices	"Assumes: InterpreterCore has already been initialised."	"Notes:	this permits a quick test for a pseudo context (the sender field contains			an integer object)."	CachedContextIndex _ SenderIndex.! !!DynamicContextCache class methodsFor: 'translation' stamp: 'ikp 10/28/97 01:56'!declareCVarsIn: aCCodeGenerator	"Nothing to declare..."! !DynamicInterpreter comment:'This class is a complete implementation of the Smalltalk-80 virtual machine, derived originally from the Blue Book specification.It has been modernized with 32-bit pointers, better management of Contexts, and attention to variable use that allows the CCodeGenerator (qv) to keep, eg, the instruction pointer and stack pointer in registers.In addition to SmallInteger arithmetic and Floats, it supports logic on 32-bit PositiveLargeIntegers, thus allowing it to simulate itself much more effectively than would otherwise be the case.'!!DynamicInterpreter methodsFor: 'initialization' stamp: 'ikp 1/6/98 01:43'!initializeInterpreter: bytesToShift	"Initialize Interpreter state before starting execution of a new image."	self inline: false.	self initializeObjectMemory: bytesToShift.	self initBBOpTable.	messageSelector			_ nilObj.	newReceiver			_ nilObj.	newMethod				_ nilObj.	newTranslatedMethod	_ nilObj.	pseudoReceiver			_ 0.	self initializeTranslator.	self initMethodCache.	self loadInitialContext.	interruptCheckCounter _ 0.	nextPollTick _ 0.	nextWakeupTick _ 0.	lastTick _ 0.	interruptKeycode _ 2094.  "cmd-."	interruptPending _ false.	semaphoresToSignalCount _ 0.! !!DynamicInterpreter methodsFor: 'initialization' stamp: 'ikp 12/11/97 16:51'!loadInitialContext	| sched proc |	self inline: false.	self preTranslateContextMethods.	sched _ self fetchPointer: ValueIndex ofObject: (self splObj: SchedulerAssociation).	proc _ self fetchPointer: ActiveProcessIndex ofObject: sched.	self copyContextToCache: (self fetchPointer: SuspendedContextIndex ofObject: proc).	self fetchContextRegisters: activeCachedContext.	self assertStackPointerIsExternal.! !!DynamicInterpreter methodsFor: 'initialization' stamp: 'ikp 1/5/98 17:52'!preTranslateContextMethods	"Scan the object memory for MethodContexts, translating their methods and	installing the results in their translatedMethod slot.  Note that there is one	problematical MethodContext: that which was active for #snapshot:andQuit:	when the image was saved.  This context has its root bit set, and so will not	be placed in the root table when the translated method is stored into it.  We	therefore remove any root bits that we find set in the method contexts for	which new translated methods are generated."	| oop header |	self inline: false.	oop _ self firstAccessibleObject.	[oop = nil] whileFalse: [		(self fetchClassOf: oop) = (self splObj: ClassMethodContext) ifTrue: [			header _ self longAt: oop.			(header bitAnd: RootBit) = 0 ifFalse: [self longAt: oop put: (header bitAnd: AllButRootBit)].			newMethod _ self fetchPointer: MethodIndex ofObject: oop.			(self fetchClassOf: newMethod) = (self splObj: ClassCompiledMethod) ifTrue: [				self translateNewMethod.				self assertIsTranslatedMethod: newTranslatedMethod.				self storePointer: TranslatedMethodIndex ofObject: oop					withValue: newTranslatedMethod.			].		].		oop _ self accessibleObjectAfter: oop.	].! !!DynamicInterpreter methodsFor: 'utilities'!areIntegers: oop1 and: oop2	^ ((oop1 bitAnd: oop2) bitAnd: 1) ~= 0! !!DynamicInterpreter methodsFor: 'utilities'!arrayValueOf: arrayOop	"Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."	"Note: May be called by translated primitive code."	self returnTypeC: 'void *'.	((self isIntegerObject: arrayOop) not and:	 [self isWordsOrBytes: arrayOop]) ifTrue: [		^ self cCode: '(void *) (arrayOop + 4)'	].	self primitiveFail.! !!DynamicInterpreter methodsFor: 'utilities'!booleanValueOf: obj	obj = trueObj ifTrue: [ ^ true ].	obj = falseObj ifTrue: [ ^ false ].	successFlag _ false.	^ nil! !!DynamicInterpreter methodsFor: 'utilities'!checkedIntegerValueOf: intOop	"Note: May be called by translated primitive code."	(self isIntegerObject: intOop)		ifTrue: [ ^ self integerValueOf: intOop ]		ifFalse: [ self primitiveFail. ^ 0 ]! !!DynamicInterpreter methodsFor: 'utilities' stamp: 'ikp 8/25/97 23:37'!externalizeIPandSP	"Copy the local instruction and stack pointer to global variables for use in primitives and other functions outside the interpret loop."	self internalSetInstructionPointer: (self cCoerce: localIP to: 'int').	self internalSetStackPointer: (self cCoerce: localSP to: 'int').! !!DynamicInterpreter methodsFor: 'utilities'!fetchArray: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."	"Note: May be called by translated primitive code."	| arrayOop |	self returnTypeC: 'void *'.	arrayOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self arrayValueOf: arrayOop! !!DynamicInterpreter methodsFor: 'utilities'!fetchFloat: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."	"Note: May be called by translated primitive code."	| floatOop |	self returnTypeC: 'double'.	floatOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self floatValueOf: floatOop! !!DynamicInterpreter methodsFor: 'utilities'!fetchInteger: fieldIndex ofObject: objectPointer	"Note: May be called by translated primitive code."	| intOop |	self inline: false.	intOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	(self isIntegerObject: intOop)		ifTrue: [ ^ self integerValueOf: intOop ]		ifFalse: [ self primitiveFail. ^ 0 ]! !!DynamicInterpreter methodsFor: 'utilities' stamp: 'ikp 8/18/97 12:26'!fetchIntegerOrTruncFloat: fieldIndex ofObject: objectPointer	"Return the integer value of the given field of the given object. If the field contains a Float, truncate it and return its integral part. Fail if the given field does not contain a small integer or Float, or if the truncated Float is out of the range of small integers."	"Note: May be called by translated primitive code."	| intOrFloat floatVal frac trunc |	self inline: false.	self var: #floatVal declareC: 'double floatVal'.	self var: #frac declareC: 'double frac'.	self var: #trunc declareC: 'double trunc'.	intOrFloat _ self fetchPointer: fieldIndex ofObject: objectPointer.	(self isIntegerObject: intOrFloat) ifTrue: [^ self integerValueOf: intOrFloat].	self successIfClassOf: intOrFloat is: (self splObj: ClassFloat).	successFlag ifTrue: [		self fetchFloatAt: intOrFloat + BaseHeaderSize into: floatVal.		self cCode: 'frac = modf(floatVal, &trunc)'.		"the following range check is for C ints, with range -2^31..2^31-1"		self cCode: 'success((-2147483648.0 <= trunc) && (trunc <= 2147483647.0))'].	successFlag		ifTrue: [^ self cCode: '((int) trunc)']		ifFalse: [^ 0].! !!DynamicInterpreter methodsFor: 'utilities' stamp: 'ikp 8/18/97 11:11'!floatValueOf: oop	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."	"Note: May be called by translated primitive code."	| result |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	self successIfClassOf: oop is: (self splObj: ClassFloat).	successFlag		ifTrue: [self fetchFloatAt: oop + BaseHeaderSize into: result]		ifFalse: [result _ 0.0].	^ result! !!DynamicInterpreter methodsFor: 'utilities' stamp: 'ikp 8/27/97 18:12'!internalizeIPandSP	"Copy the local instruction and stack pointer to local variables for rapid access within the interpret loop."	self assertStackPointerIsExternal.	localCP _ "self cCoerce:" activeCachedContext "to: 'char *'".	localIP _ self cCoerce: self internalInstructionPointer to: 'char *'.	localSP _ self cCoerce: self internalStackPointer to: 'char *'.	self assertStackPointerIsInternal."	localTP _ self cCoerce: self internalTemporaryPointer to: 'char *'.""	localTP _ self cCoerce: theTemporaryPointer to: 'char *'."! !!DynamicInterpreter methodsFor: 'utilities'!makePointwithxValue: xValue yValue: yValue	| pointResult |	pointResult _ self instantiateSmallClass: (self splObj: ClassPoint)							   sizeInBytes: 12									   fill: nilObj.	self storePointer: XIndex ofObject: pointResult withValue: (self integerObjectOf: xValue).	self storePointer: YIndex ofObject: pointResult withValue: (self integerObjectOf: yValue).	^ pointResult! !!DynamicInterpreter methodsFor: 'utilities'!quickFetchInteger: fieldIndex ofObject: objectPointer	"Return the integer value of the field without verifying that it is an integer value!! For use in time-critical places where the integer-ness of the field can be guaranteed."	^ self integerValueOf:		(self fetchPointer: fieldIndex ofObject: objectPointer).! !!DynamicInterpreter methodsFor: 'utilities'!signExtend16: int16	"Convert a signed 16-bit integer into a signed 32-bit integer value. The integer bit is not added here."	(int16 bitAnd: 16r8000) = 0		ifTrue: [ ^ int16 ]		ifFalse: [ ^ int16 - 16r10000 ].! !!DynamicInterpreter methodsFor: 'utilities'!storeInteger: fieldIndex ofObject: objectPointer withValue: integerValue	"Note: May be called by translated primitive code."	(self isIntegerValue: integerValue) ifTrue: [		self storeWord: fieldIndex			ofObject: objectPointer			withValue: (self integerObjectOf: integerValue).	] ifFalse: [		self primitiveFail	].! !!DynamicInterpreter methodsFor: 'utilities' stamp: 'ikp 8/18/97 11:10'!successIfClassOf: oop is: classOop	"Succeed if the given (non-integer) object is an instance of the given class. Fail if the object is an integer."	| ccIndex cl |	self inline: true.	(self isIntegerObject: oop)		ifTrue: [ successFlag _ false. ^ nil ].	ccIndex _ ((self baseHeader: oop) >> 12) bitAnd: 16r1F.	ccIndex = 0		ifTrue: [ cl _ ((self classHeader: oop) bitAnd: AllButTypeMask) ]		ifFalse: [			"look up compact class"			cl _ (self fetchPointer: (ccIndex - 1)					ofObject: (self fetchPointer: CompactClasses ofObject: specialObjectsOop))].	self success: cl = classOop.! !!DynamicInterpreter methodsFor: 'utilities' stamp: 'ikp 8/18/97 11:12'!successIfFloat: oop1 and: oop2	"Fail unless both arguments are floats."	| floatClass |	((oop1 bitOr: oop2) bitAnd: 1) ~= 0 ifTrue: [		successFlag _ false.	] ifFalse: [		floatClass _ self splObj: ClassFloat.		self successIfClassOf: oop1 is: floatClass.		self successIfClassOf: oop2 is: floatClass.	].! !!DynamicInterpreter methodsFor: 'utilities' stamp: 'ikp 12/27/97 14:50'!translatedInstructionIndex: ip toPointerIn: tMeth	self inline: true.	^(((self integerValueOf: ip) - (self translatedMethodBias: tMeth)) * 8)		+ (4 * MethodOpcodeStart) + tMeth! !!DynamicInterpreter methodsFor: 'utilities' stamp: 'ikp 12/27/97 14:50'!translatedInstructionPointer: ip toIndexIn: tMeth	self inline: true.	^self integerObjectOf:		(((ip - tMeth - (MethodOpcodeStart * 4)) // 8) + (self translatedMethodBias: tMeth))! !!DynamicInterpreter methodsFor: 'object memory support' stamp: 'ikp 1/6/98 14:58'!mapInterpreterOops	"Map all oops in the interpreter's state to their new values during garbage collection or a become: operation."	"Assume: All traced variables contain valid oops."	| oop |	nilObj				_ self remap: nilObj.	falseObj				_ self remap: falseObj.	trueObj				_ self remap: trueObj.	specialObjectsOop		_ self remap: specialObjectsOop.	messageSelector		_ self remap: messageSelector.	bytePointer	_ bytePointer - newMethod.				"*** rel to newMethod"	opPointer	_ opPointer - newTranslatedMethod.		"*** rel to newTranslatedMethod"	newMethod					_ self remap: newMethod.	newTranslatedMethod		_ self remap: newTranslatedMethod.	bytePointer	_ bytePointer + newMethod.	opPointer	_ opPointer + newTranslatedMethod.	(newReceiver = 0 or: [self isIntegerObject: newReceiver]) ifFalse: [newReceiver _ self remap: newReceiver].	(pseudoReceiver = 0) ifFalse: [pseudoReceiver _ self remap: pseudoReceiver].	self mapContextCache.	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			remapBuffer at: i put: (self remap: oop).		].	].	UseMethodCacheHashBits		"If the method cache uses proper hashes, then remap its contents"		ifTrue: [self remapMethodCache].! !!DynamicInterpreter methodsFor: 'object memory support' stamp: 'ikp 1/6/98 14:59'!markAndTraceInterpreterOops	"Mark and trace all oops in the interpreter's state."	"Assume: All traced variables contain valid oops."	| oop |	"self verifyImage."	self markAndTrace: specialObjectsOop.		"also covers nilObj, trueObj, falseObj, and compact classes"	"Tolerate SmallIntegers as selectors"	(self isIntegerObject: messageSelector) ifFalse: [self markAndTrace: messageSelector].	self markAndTrace: newMethod.	self markAndTrace: newTranslatedMethod.	(newReceiver = 0 or: [self isIntegerObject: newReceiver]) ifFalse: [self markAndTrace: newReceiver].	(pseudoReceiver = 0) ifFalse: [self markAndTrace: pseudoReceiver].	self markAndTraceContextCache.	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			self markAndTrace: oop.		].	].	UseMethodCacheHashBits		ifTrue: [self markAndTraceMethodCache]		"If the method cache uses oops as hashes, need to toss the whole thing."		ifFalse: [self flushMethodCache].! !!DynamicInterpreter methodsFor: 'object memory support' stamp: 'ikp 1/5/98 17:51'!postGCAction	| acc |"	self mapCachedTemporaryPointers."	acc _ activeCachedContext.	acc = 0 ifFalse: [		self addRootsForCachedContext: acc.		self setTemporaryPointer: (self temporaryPointerForCachedContext: acc).		checkAssertions ifTrue:			[self verifyStack.			 self verifyMethodCache].	].! !!DynamicInterpreter methodsFor: 'compiled methods'!argumentCountOf: methodPointer	^ ((self headerOf: methodPointer) >> 25) bitAnd: 16r1F! !!DynamicInterpreter methodsFor: 'compiled methods'!headerOf: methodPointer	^self fetchPointer: HeaderIndex		ofObject: methodPointer! !!DynamicInterpreter methodsFor: 'compiled methods' stamp: 'ikp 8/26/97 00:48'!literal: offset	"Assumes: always inlined into the interpreter loop"	^self literal: offset ofMethod: self internalMethod! !!DynamicInterpreter methodsFor: 'compiled methods'!literal: offset ofMethod: methodPointer	^ self fetchPointer: offset + LiteralStart ofObject: methodPointer! !!DynamicInterpreter methodsFor: 'compiled methods'!literalCountOf: methodPointer	^self literalCountOfHeader: (self headerOf: methodPointer)! !!DynamicInterpreter methodsFor: 'compiled methods'!literalCountOfHeader: headerPointer	^ (headerPointer >> 10) bitAnd: 16rFF! !!DynamicInterpreter methodsFor: 'compiled methods'!methodClassOf: methodPointer	^ self fetchPointer: ValueIndex ofObject:		(self literal: (self literalCountOf: methodPointer) - 1			ofMethod: methodPointer)! !!DynamicInterpreter methodsFor: 'compiled methods' stamp: 'ikp 9/29/97 20:58'!primitiveIndexOf: methodPointer	"Note: We now have 11 bits of primitive index, but they are in two places	for temporary backward compatibility.  The time to unpack is negligible,	since the reconstituted full index is stored in the method cache."	| primBits |	primBits _ ((self headerOf: methodPointer) >> 1) bitAnd: 16r300001FF.	primBits > 16r1FF		ifTrue: [^ (primBits bitAnd: 16r1FF) + (primBits >> 19)]		ifFalse: [^ primBits]! !!DynamicInterpreter methodsFor: 'compiled methods' stamp: 'ikp 8/25/97 14:15'!primitiveNewMethod	| header bytecodeCount class size theNewMethod literalCount |	header _ self popStack.	bytecodeCount _ self popInteger.	self success: (self isIntegerObject: header).	successFlag ifFalse: [self unPop: 2].	class _ self popStack.	size _ (self literalCountOfHeader: header) + 1 * 4 + bytecodeCount.	theNewMethod _ self instantiateClass: class indexableSize: size.	self storePointer: HeaderIndex ofObject: theNewMethod withValue: header.	literalCount _ self literalCountOfHeader: header.	1 to: literalCount do:		[:i | self storePointer: i ofObject: theNewMethod withValue: nilObj].	self push: theNewMethod! !!DynamicInterpreter methodsFor: 'registers' stamp: 'ikp 8/25/97 22:43'!instructionPointer	^self cachedInstructionPointerAt: activeCachedContext! !!DynamicInterpreter methodsFor: 'registers' stamp: 'ikp 8/25/97 23:38'!internalInstructionPointer	^self cachedInstructionPointerAt: localCP! !!DynamicInterpreter methodsFor: 'registers' stamp: 'ikp 8/26/97 00:48'!internalMethod	^self cachedMethodAt: localCP! !!DynamicInterpreter methodsFor: 'registers' stamp: 'ikp 8/25/97 23:48'!internalReceiver	^self cachedReceiverAt: localCP! !!DynamicInterpreter methodsFor: 'registers' stamp: 'ikp 8/27/97 23:48'!internalSetInstructionPointer: ip	self cachedInstructionPointerAt: localCP put: ip! !!DynamicInterpreter methodsFor: 'registers' stamp: 'ikp 8/27/97 23:49'!internalSetStackPointer: sp	self cachedStackPointerAt: localCP put: sp! !!DynamicInterpreter methodsFor: 'registers' stamp: 'ikp 8/25/97 23:39'!internalStackPointer	^self cachedStackPointerAt: localCP! !!DynamicInterpreter methodsFor: 'registers' stamp: 'ikp 12/1/97 22:32'!internalTranslatedMethod	^self cachedTranslatedMethodAt: localCP! !!DynamicInterpreter methodsFor: 'registers' stamp: 'ikp 8/26/97 00:55'!setStackPointer: sp	self cachedStackPointerAt: activeCachedContext put: sp! !!DynamicInterpreter methodsFor: 'registers' stamp: 'ikp 8/27/97 10:50'!setTemporaryPointer: tp	theTemporaryPointer _ tp! !!DynamicInterpreter methodsFor: 'registers' stamp: 'ikp 8/25/97 23:18'!stackPointer	^self cachedStackPointerAt: activeCachedContext! !!DynamicInterpreter methodsFor: 'registers' stamp: 'ikp 8/27/97 10:50'!temporaryPointer	"^self cachedTemporaryPointerAt: activeCachedContext"	^theTemporaryPointer! !!DynamicInterpreter methodsFor: 'registers' stamp: 'ikp 12/1/97 22:32'!translatedMethod	^self cachedTranslatedMethodAt: activeCachedContext! !!DynamicInterpreter methodsFor: 'context cache' stamp: 'ikp 12/11/97 17:01'!cachedInstructionIndexAt: cp"	| result |	self inline: true.	self assertIsCachedContext: cp.	result _ self longAt: cp + (CacheInstructionPointerIndex * 4).	self assertIsIntegerObject: result.	^result"	| meth index ip |	self inline: true.	ip _ self cachedInstructionPointerAt: cp.	meth _ self cachedTranslatedMethodAt: cp.	index _ self translatedInstructionPointer: ip toIndexIn: meth.	self assertIsLegalTranslatedInstructionIndex: index in: meth.	^index! !!DynamicInterpreter methodsFor: 'context cache' stamp: 'ikp 12/11/97 17:01'!cachedInstructionIndexAt: cp put: anInteger	"Only for use in situations where the transformation of representation is required."	self inline: true.	self assertIsIntegerObject: anInteger.	self cachedInstructionPointerAt: cp		put: (self translatedInstructionIndex: anInteger					toPointerIn: (self cachedTranslatedMethodAt: cp)).! !!DynamicInterpreter methodsFor: 'context cache' stamp: 'ikp 12/11/97 17:02'!cachedInstructionPointerAt: cp"	| meth index ip |	self inline: true.	self assertIsCachedContext: cp.	meth _ self cachedMethodAt: cp.	index _ self longAt: cp + (CacheInstructionPointerIndex * 4).	self assertIsIntegerObject: index.	index _ self integerValueOf: index.	ip _ meth + BaseHeaderSize + index - 2.	self assertIsLegalInstructionPointer: ip in: meth.	^ip"	self inline: true.	self assertIsCachedContext: cp.	self assertIsLegalTranslatedInstructionPointer: (self longAt: cp + (CacheInstructionPointerIndex * 4))		in: (self cachedTranslatedMethodAt: cp).	^self longAt: cp + (CacheInstructionPointerIndex * 4)! !!DynamicInterpreter methodsFor: 'context cache' stamp: 'ikp 12/11/97 17:02'!cachedInstructionPointerAt: cp put: rawPointer"	| meth index |	self inline: true.	self assertIsCachedContext: cp.	meth _ self cachedMethodAt: cp.	index _ self integerObjectOf: (rawPointer - meth - BaseHeaderSize + 2).	self assertIsLegalInstructionIndex: index in: meth.	self longAt: cp + (CacheInstructionPointerIndex * 4) put: index"	self inline: true.	self assertIsLegalTranslatedInstructionPointer: rawPointer in: (self cachedTranslatedMethodAt: cp).	self longAt: cp + (CacheInstructionPointerIndex * 4) put: rawPointer! !!DynamicInterpreter methodsFor: 'context cache' stamp: 'ikp 1/1/98 23:51'!cachedTranslatedMethodAt: cp	self inline: true.	self assertIsCachedContext: cp.	self assertIsTranslatedMethod: (self longAt: cp + (CacheTranslatedMethodIndex * 4)).	^self longAt: cp + (CacheTranslatedMethodIndex * 4)! !!DynamicInterpreter methodsFor: 'context cache' stamp: 'ikp 1/1/98 23:52'!cachedTranslatedMethodAt: cp put: anArray	self inline: true.	self assertIsCachedContext: cp.	self assertIsTranslatedMethod: anArray.	self longAt: cp + (CacheTranslatedMethodIndex * 4) put: anArray! !!DynamicInterpreter methodsFor: 'context cache-private' stamp: 'ikp 12/1/97 14:56'!basicCachedTranslatedMethodAt: cp	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	^self longAt: cp + (CacheTranslatedMethodIndex * 4)! !!DynamicInterpreter methodsFor: 'context cache-private' stamp: 'ikp 12/1/97 14:56'!basicCachedTranslatedMethodAt: cp put: anArray	"For use during GC remapping"	self inline: true.	self assertIsCachedContext: cp.	self longAt: cp + (CacheTranslatedMethodIndex * 4) put: anArray! !!DynamicInterpreter methodsFor: 'context cache-private' stamp: 'ikp 1/1/98 23:52'!translatedMethodOfBlockContext: blockContext	| home cp tMeth |	self assertIsStableBlockContext: blockContext.	home _ self fetchPointer: HomeIndex ofObject: blockContext.	(self isPseudoContext: home) ifTrue: [		cp _ self pseudoCachedContextAt: home.		tMeth _ self cachedTranslatedMethodAt: cp.	] ifFalse: [		tMeth _ self fetchPointer: TranslatedMethodIndex ofObject: home.	].	self assertIsTranslatedMethod: tMeth.	^tMeth! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/28/97 00:58'!argumentCountOfBlock: blockPointer	| argCount |	argCount _ self fetchPointer: BlockArgumentCountIndex							ofObject: blockPointer.	(self isIntegerObject: argCount)		ifTrue: [ ^ self integerValueOf: argCount ]		ifFalse: [ self primitiveFail. ^0 ].! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/27/97 10:49'!fetchContextRegisters: ctx	"No-op.  (The cache interpreter runs directly out of the cached context when IP/SP are external. :)"	self addRootsForCachedContext: ctx.	self setTemporaryPointer: (self temporaryPointerForCachedContext: ctx)! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/27/97 10:55'!internalFetchContextRegisters	"Need only to fetch the local registers from the cached context."	self inline: true.	self setTemporaryPointer: (self temporaryPointerForCachedContext: activeCachedContext).	self internalizeIPandSP.	self addRootsForCachedContext: localCP.! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/14/97 16:42'!internalPop: nItems	localSP _ localSP - (nItems * 4).! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/22/97 22:09'!internalPop: nItems thenPush: oop	self longAt: (localSP _ localSP - ((nItems - 1) * 4)) put: oop.! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/22/97 22:09'!internalPush: object	self longAt: (localSP _ localSP + 4) put: object.! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/22/97 22:09'!internalStackTop	^ self longAt: localSP! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/14/97 16:44'!internalStackValue: offset	^ self longAt: localSP - (offset * 4)! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/16/97 23:59'!methodOfBlockContext: blockContext	| home cp |	self assertIsStableBlockContext: blockContext.	home _ self fetchPointer: HomeIndex ofObject: blockContext.	(self isPseudoContext: home) ifTrue: [		cp _ self pseudoCachedContextAt: home.		^self cachedMethodAt: cp.	] ifFalse: [		^self fetchPointer: MethodIndex ofObject: home.	].! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/25/97 14:32'!pop: nItems	"Note: May be called by translated primitive code."	self setStackPointer: (self stackPointer - (nItems*4)).! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/25/97 14:32'!pop: nItems thenPush: oop	| sp |	self longAt: (sp _ self stackPointer - ((nItems - 1) * 4)) put: oop.	self setStackPointer: sp.! !!DynamicInterpreter methodsFor: 'contexts'!popInteger	| integerPointer |	integerPointer _ self popStack.	(self isIntegerObject: integerPointer)		ifTrue: [^ self integerValueOf: integerPointer]		ifFalse: [successFlag _ false.				^ 1  "in case need SOME integer prior to fail"]! !!DynamicInterpreter methodsFor: 'contexts'!popPos32BitInteger	"May set successFlag, and return false if not valid"	| top |	top _ self popStack.	^ self positive32BitValueOf: top! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/25/97 14:32'!popStack	| top |	top _ self longAt: self stackPointer.	self setStackPointer: (self stackPointer - 4).	^ top! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/25/97 14:32'!push: object	| sp |	self longAt: (sp _ self stackPointer + 4) put: object.	self setStackPointer: sp.! !!DynamicInterpreter methodsFor: 'contexts'!pushBool: trueOrFalse	trueOrFalse		ifTrue: [ self push: trueObj ]		ifFalse: [ self push: falseObj ].! !!DynamicInterpreter methodsFor: 'contexts'!pushInteger: integerValue	self push: (self integerObjectOf: integerValue).! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/17/97 00:45'!receiverOfBlockContext: blockContext	| home cp |	self assertIsStableBlockContext: blockContext.	home _ self fetchPointer: HomeIndex ofObject: blockContext.	(self isPseudoContext: home) ifTrue: [		cp _ self pseudoCachedContextAt: home.		^self cachedReceiverAt: cp.	] ifFalse: [		^self fetchPointer: ReceiverIndex ofObject: home.	].! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/25/97 11:32'!stackIntegerValue: offset	| integerPointer |	integerPointer _ self longAt: self stackPointer - (offset*4).	(self isIntegerObject: integerPointer)		ifTrue: [ ^self integerValueOf: integerPointer ]		ifFalse: [ self primitiveFail. ^0 ]! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/25/97 11:32'!stackTop	^self longAt: self stackPointer! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/25/97 11:32'!stackValue: offset	^ self longAt: self stackPointer - (offset*4)! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/27/97 18:12'!temporary: offset	self assertIsLegalTempOffset: offset.	^ self longAt: self temporaryPointer"localTP" + (offset * 4)! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/27/97 18:12'!temporary: offset put: aValue	self assertIsLegalTempOffset: offset.	^ self longAt: self temporaryPointer"localTP" + (offset * 4) put: aValue! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'ikp 8/25/97 14:32'!unPop: nItems	self setStackPointer: self stackPointer + (nItems*4)! !!DynamicInterpreter methodsFor: 'object format'!fixedFieldsOf: oop format: fmt length: wordLength"	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ (classFormat >> 2 bitAnd: 16rFF) - 1"	| class classFormat |	self inline: true.	((fmt > 3) or: [fmt = 2]) ifTrue: [^ 0].  "indexable fields only"	fmt < 2 ifTrue: [^ wordLength].  "fixed fields only (zero or more)"		"fmt = 3: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!DynamicInterpreter methodsFor: 'object format'!formatOfClass: classPointer	"**should be in-lined**"	"Note that, in Smalltalk, the instSpec will be equal to the inst spec	part of the base header of an instance (without hdr type) shifted left 1.	In this way, apart from the smallInt bit, the bits	are just where you want them for the first header word."	"Callers expect low 2 bits (header type) to be zero!!"	^ (self fetchPointer: InstanceSpecificationIndex ofObject: classPointer) - 1! !!DynamicInterpreter methodsFor: 'message sending' stamp: 'ikp 12/28/97 22:30'!activateNewMethod	"Activate the method in newMethod.  Receiver and arguments are on the stack.	Assumes:	ArgumentCount is set appropriately.				The topmost cached context is still active.				IP and SP are external.				newTranslatedMethod contains a translation of newMethod"	| newContext methodHeader tempCount cp newFrame oldSP newSP oldContext argCount nilOop |	self inline: false.	self assertStackPointerIsExternal.	argCount	_ argumentCount.	oldContext	_ activeCachedContext.	oldSP		_ self cachedStackPointerAt: oldContext.	newFrame	_ oldSP - (argCount * 4) + 4.		"first argument"	newSP		_ newFrame - 8.				"pop arguments and receiver"	newContext	_ self allocateCachedContextAfter: oldContext frame: newFrame.	"can cause GC!!"	self cachedStackPointerAt: oldContext put: newSP.		"updated AFTER possible GC"	stackOverflow ifTrue: [		newFrame _ self cachedFramePointerAt: newContext.		self	transfer:	argCount			wordsFrom:	newSP + 8			to: 			newFrame.		stackOverflow _ false.	].	methodHeader _ self headerOf: newMethod.	tempCount _ (methodHeader >> 19) bitAnd: 16r3F.	tempCount > argCount ifTrue: [		nilOop _ nilObj.		self fill:		tempCount - argCount			wordsFrom:	newFrame + (argCount * 4)			with:		nilOop.	].	self cachedMethodAt:			newContext put: (newMethod).	self cachedTranslatedMethodAt:	newContext put: (newTranslatedMethod).	self cachedReceiverAt:			newContext put: (self longAt: (newSP + 4)).	self cachedHomeAt:				newContext put: 0.	self cachedInstructionPointerAt:	newContext put: (newTranslatedMethod + BaseHeaderSize + ((MethodOpcodeStart - "pre-incr" 1) * 4)).	self cachedStackPointerAt:		newContext put: (newFrame + (tempCount * 4) - 4)."	self cachedTemporaryPointerAt:	newContext put: newFrame."	self setTemporaryPointer: newFrame.	pseudoReceiver = 0 ifFalse: [		self assertIsPseudoContext: pseudoReceiver.		cp _ self pseudoCachedContextAt: pseudoReceiver.		self flushCacheFrom: cp.		pseudoReceiver _ 0.		"self cachedContextReceiverFlagAt: cp put: 1."		"non-zero"	"deprecated"			].! !!DynamicInterpreter methodsFor: 'message sending'!argCount	^ argumentCount! !!DynamicInterpreter methodsFor: 'message sending' stamp: 'ikp 8/25/97 11:32'!createActualMessage	| argumentArray message |	self inline: false.	argumentArray _ self instantiateClass: (self splObj: ClassArray) indexableSize: argumentCount.	"remap argumentArray in case GC happens during allocation"	self pushRemappableOop: argumentArray.	message _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	argumentArray _ self popRemappableOop.	(argumentArray < youngStart) ifTrue: [ self beRootIfOld: argumentArray ].	self storePointer: MessageSelectorIndex		ofObject: message withValue: messageSelector.	self storePointer: MessageArgumentsIndex	ofObject: message withValue: argumentArray.	self pop: argumentCount.	self	transfer:	argumentCount		wordsFrom:	self stackPointer + 4					"first argument"		to:			argumentArray + BaseHeaderSize.	"first indexed field"	self push: message.	argumentCount _ 1.! !!DynamicInterpreter methodsFor: 'message sending' stamp: 'ikp 1/5/98 16:20'!executeForCachedReceiver	"Execute newMethod for a cached receiver, which might or might not be the activeCachedContext"	| cp |	self inline: false.	self assert: pseudoReceiver = newReceiver.	cp _ self pseudoCachedContextAt: pseudoReceiver.	self assert: (self cachedPseudoContextAt: cp) = pseudoReceiver.	cp = activeCachedContext ifTrue: [		(primitiveIndex = 0 or: [self primitiveResponseForCachedReceiver not]) ifTrue: [			"Bail out and perform a full activation.  This case is extremely rare,			and will get even rarer once the #release anachronisms in Process>>terminate			(left over from the days of reference counting) are removed from the image."			self activateNewMethod.		"...which cleans up the receiver situation for us"			self quickCheckForInterrupts.		].		pseudoReceiver _ 0.	] ifFalse: [		self flushCacheFrom: cp.		self assertIsStableContext: newReceiver.		pseudoReceiver _ 0.		(primitiveIndex = 0 or: [self primitiveResponse not]) ifTrue: [			"if not primitive, or primitive failed, activate the method"			self activateNewMethod.			"check for possible interrupts at each real send"			self quickCheckForInterrupts.		].	].! !!DynamicInterpreter methodsFor: 'message sending' stamp: 'ikp 8/17/97 13:28'!executeForNormalReceiver	self inline: true.	(primitiveIndex = 0 or: [self primitiveResponse not]) ifTrue: [		"if not primitive, or primitive failed, activate the method"		self activateNewMethod.		"check for possible interrupts at each real send"		self quickCheckForInterrupts.	].! !!DynamicInterpreter methodsFor: 'message sending' stamp: 'ikp 1/5/98 17:51'!executeNewMethod	"The common case (not a pseudo receiver) is inlined; the other is not."	self inline: true.	pseudoReceiver = 0 ifTrue: [		self executeForNormalReceiver.	] ifFalse: [		self assert: pseudoReceiver = newReceiver.		"One special case: #blockCopy for the activeCachedContext is inlined."		"This is utterly redundant now that we have MacroPushBlock"		(primitiveIndex = 80 and: [(self pseudoCachedContextAt: pseudoReceiver) = activeCachedContext]) ifTrue: [			self primitiveBlockCopy.			pseudoReceiver _ 0.		] ifFalse: [			self executeForCachedReceiver.		]	]! !!DynamicInterpreter methodsFor: 'message sending' stamp: 'ikp 1/13/98 00:44'!findNewMethodInClass: class	"Find the compiled method to be run when the current messageSelector is sent to the given class, setting the values of 'newMethod' and 'primitiveIndex'."	| ok cls sel |	self inline: true.	sel _ messageSelector.	ok _ self lookupInMethodCacheSel: sel class: class.	ok ifFalse: [		statMethodCacheMisses _ statMethodCacheMisses + 1.		"entry was not found in the cache; look it up the hard way"		self pushRemappableOop: class.		self lookupMethodInClass: class.		"Can provoke GC if createActualMessage is called"		cls _ self popRemappableOop.		primitiveIndex _ self primitiveIndexOf: newMethod.		"Avoid creating cache entries for PseudoContexts"		pseudoReceiver = 0 ifTrue: [			self assert: cls ~= (self splObj: ClassPseudoContext).			self addToMethodCacheSel: messageSelector				class: cls				method: newMethod				primIndex: primitiveIndex				translatedMethod: newTranslatedMethod.		].	].! !!DynamicInterpreter methodsFor: 'message sending' stamp: 'ikp 12/9/97 15:49'!lookupMethodInClass: class	"Assumes: newReceiver contains the receiver with the given class"	| currentClass dictionary found stableClass cls |	currentClass _ class.	[currentClass ~= nilObj] whileTrue: [		dictionary _ self fetchPointer: MessageDictionaryIndex ofObject: currentClass.		found _ self lookupMethodInDictionary: dictionary.		found ifTrue: [^currentClass].		currentClass _ self superclassOf: currentClass.	].	class = (self splObj: ClassPseudoContext) ifTrue: [		self assertIsPseudoContext: newReceiver.		pseudoReceiver _ newReceiver.		"changes behaviour of {activate,execute}NewMethod"		stableClass _ self stableClassOf: newReceiver.		self assertIsStableContextClass: stableClass.		self lookupMethodInClass: stableClass.		^nilObj.		"stableClass might be hit by a GC in the recursive call"	].	messageSelector = (self splObj: SelectorDoesNotUnderstand) ifTrue: [		self error: 'Recursive not understood error encountered'	].	self pushRemappableOop: class.	self createActualMessage.	cls _ self popRemappableOop.	messageSelector _ self splObj: SelectorDoesNotUnderstand.	^self lookupMethodInClass: cls! !!DynamicInterpreter methodsFor: 'message sending' stamp: 'ikp 11/30/97 16:11'!lookupMethodInDictionary: dictionary	"This method lookup tolerates integers as Dictionary keys to support	execution of images in which Symbols have been compacted out" 	| length index mask wrapAround nextSelector methodArray |	self inline: true.	length _ self fetchWordLengthOf: dictionary.	mask _ length - SelectorStart - 1.	(self isIntegerObject: messageSelector)		ifTrue:		[index _ (mask bitAnd: (self integerValueOf: messageSelector)) + SelectorStart]		ifFalse:		[index _ (mask bitAnd: (self hashBitsOf: messageSelector)) + SelectorStart].	"It is assumed that there are some nils in this dictionary, and search will	stop when one is encountered.  However, if there are no nils, then wrapAround	will be detected the second time the loop gets to the end of the table."	wrapAround _ false.	[true] whileTrue:		[nextSelector _ self fetchPointer: index					ofObject: dictionary.		nextSelector=nilObj ifTrue: [^false].		nextSelector=messageSelector			ifTrue: [methodArray _ self fetchPointer: MethodArrayIndex							ofObject: dictionary.				newMethod _ self fetchPointer:  index - SelectorStart							ofObject: methodArray.				primitiveIndex _ self primitiveIndexOf: newMethod.			"***	found newMethod: now create newTranslatedMethod ***"				self translateNewMethod.				^true].		index _ index + 1.		index = length			ifTrue: [wrapAround ifTrue: [^false].				wrapAround _ true.				index _ SelectorStart]]! !!DynamicInterpreter methodsFor: 'message sending' stamp: 'ikp 12/20/97 02:55'!sendSelectorToClass: classPointer	"Note: Requires that instructionPointer and stackPointer be externalized."	self inline: true.	self findNewMethodInClass: classPointer.	self executeNewMethod.! !!DynamicInterpreter methodsFor: 'message sending'!specialSelector: index	^ self fetchPointer: (index * 2) ofObject: (self splObj: SpecialSelectors)! !!DynamicInterpreter methodsFor: 'message sending'!superclassOf: classPointer	^ self fetchPointer: SuperclassIndex ofObject: classPointer! !!DynamicInterpreter methodsFor: 'method lookup cache' stamp: 'ikp 1/14/98 01:46'!addToMethodCacheSel: selector class: class method: meth primIndex: primIndex translatedMethod: tMeth	"Add the given entry to the method cache."	| probe |	self inline: false.	"select one of the CacheProbeMax possible entries for replacement..."	mcProbe _ (mcProbe + 1) \\ CacheProbeMax.  "in range 0..CacheProbeMax-1"	UseMethodCacheHashBits		ifTrue: [probe _ (((self hashForCacheWithSelector: selector class: class) >> mcProbe)							bitAnd: MethodCacheMask) + 1]		ifFalse: [probe _ (((selector bitXor: class) >> (mcProbe + 2))							bitAnd: MethodCacheMask) + 1].	"...and replace the entry at that probe addresses"	self assertIsCompiledMethod: meth.	self assertIsTranslatedMethod: tMeth.	(methodCache at: probe + MethodCacheSelectorCol) = 0		ifFalse: [self ejectMethodCacheLine: probe].	methodCache at: probe + MethodCacheSelectorCol		put: selector.	methodCache at: probe + MethodCacheClassCol			put: class.	methodCache at: probe + MethodCacheMethodCol		put: meth.	methodCache at: probe + MethodCachePrimIndexCol	put: primIndex.	methodCache at: probe + MethodCacheTMethodCol		put: tMeth.	UseInlineCacheDelay ifTrue:		[methodCache at: probe + MethodCacheDelayCol put: inlineCacheDelay.		 newInlineCacheDelay _ inlineCacheDelay].! !!DynamicInterpreter methodsFor: 'method lookup cache' stamp: 'ikp 12/18/97 03:00'!hashForCacheWithSelector: selector class: class	| selHash |	self inline: true.	(self isIntegerObject: selector)		ifTrue:		["We tolerate integers as selectors for now. This allows		an image to have selectors scrunched out to save space."		selHash _ self integerValueOf: selector]		ifFalse:		[selHash _ self hashBitsOf: messageSelector].	^ selHash bitXor: (self hashBitsOf: class)! !!DynamicInterpreter methodsFor: 'method lookup cache' stamp: 'ikp 1/14/98 01:45'!lookupInMethodCacheSel: selector class: class	"This method implements a simple method lookup cache. If an entry for the given selector and class is found in the cache, set the values of 'newMethod' and 'primitiveIndex' and return true. Otherwise, return false."	"About the re-probe scheme: The hash is the low bits of the XOR of two large addresses, minus their useless lowest two bits. If a probe doesn't get a hit, the hash is shifted right one bit to compute the next probe, introducing a new randomish bit. The cache is probed CacheProbeMax times before giving up."	"WARNING: The method cache must either be compeltely flushed, or all pointers must be remapped following a compaction (ie, incremental or full GC)."	| hash probe oldDelay |	self inline: true.	UseMethodCacheHashBits		ifTrue: [hash _ self hashForCacheWithSelector: selector class: class]		ifFalse: [hash _ (selector bitXor: class) >> 2].  "drop two low-order zeros from addresses"	probe _ (hash bitAnd: MethodCacheMask) + 1.  "initial probe"	1 to: CacheProbeMax do: [ :p |		(((methodCache at: probe + MethodCacheSelectorCol) = selector) and:		 [(methodCache at: probe + MethodCacheClassCol) = class]) ifTrue:			[newMethod _ methodCache at: probe + MethodCacheMethodCol.			primitiveIndex _ methodCache at: probe + MethodCachePrimIndexCol.			newTranslatedMethod _ methodCache at: probe + MethodCacheTMethodCol.			statMethodCacheHits _ statMethodCacheHits + 1.			UseInlineCacheDelay ifTrue: [				oldDelay _ methodCache at: probe + MethodCacheDelayCol.				oldDelay > 0 ifTrue: [methodCache at: probe + MethodCacheDelayCol put: oldDelay - 1].				newInlineCacheDelay _ oldDelay.			].			^ true	"found entry in cache; done"		].		probe _ ((hash >> p) bitAnd: MethodCacheMask) + 1	].	^ false! !!DynamicInterpreter methodsFor: 'method lookup cache' stamp: 'ikp 12/27/97 15:31'!markAndTraceMethodCache	"Mark from the translated methods in the method cache.  This is necessary since the method	cache might be the only place that still has a reference to a given translated method.	It is also necessary to support selective flush because a class definition change may #become:	the class in the hierarchy, leaving an obsolete class referenced only from the cache."	self inline: false.	1 to: MethodCacheEntries do: [:i | self markAndTraceMethodCacheLine: i]."	1 to: MethodCacheEntries do: [:i |		(methodCache at: i) = 0 ifFalse:			[self markAndTrace: (methodCache at: i + (MethodCacheEntries * 4))]]."! !!DynamicInterpreter methodsFor: 'method lookup cache' stamp: 'ikp 1/14/98 01:01'!markAndTraceMethodCacheLine: lineIndex	| oldOop |	self inline: true.	oldOop		_ methodCache at: lineIndex + MethodCacheSelectorCol.	oldOop ~= 0 ifTrue:		[self markAndTrace: oldOop.		 oldOop	_ methodCache at: lineIndex + MethodCacheClassCol.		 self markAndTrace: oldOop.		 oldOop	_ methodCache at: lineIndex + MethodCacheMethodCol.		 self markAndTrace: oldOop.		 oldOop	_ methodCache at: lineIndex + MethodCacheTMethodCol.		 self markAndTrace: oldOop].! !!DynamicInterpreter methodsFor: 'method lookup cache' stamp: 'ikp 12/18/97 03:00'!remapMethodCache	"Remap all pointers in the method cache.	The method cache must be remapped following a compaction (inc or full gc)."	self inline: false.	1 to: MethodCacheEntries do: [:i | self remapMethodCacheLine: i].! !!DynamicInterpreter methodsFor: 'method lookup cache' stamp: 'ikp 1/14/98 01:05'!remapMethodCacheLine: lineIndex	| oldOop |	self inline: true.	oldOop _ methodCache at:		lineIndex + MethodCacheSelectorCol.	oldOop ~= 0 ifTrue:		[methodCache at:			lineIndex + MethodCacheSelectorCol	put: (self remap: oldOop).		oldOop _ methodCache at:	lineIndex + MethodCacheClassCol.		methodCache at:				lineIndex + MethodCacheClassCol		put: (self remap: oldOop).		oldOop _ methodCache at:	lineIndex + MethodCacheMethodCol.		methodCache at:				lineIndex + MethodCacheMethodCol	put: (self remap: oldOop).		oldOop _ methodCache at:	lineIndex + MethodCacheTMethodCol.		methodCache at:				lineIndex + MethodCacheTMethodCol	put: (self remap: oldOop)].! !!DynamicInterpreter methodsFor: 'interpreter shell' stamp: 'ikp 12/12/97 18:00'!interpret	"If newTranslatedMethod = nilObj then the interpreter is initialising: dispatch on opcodeIndex	to store the address of the opcode in opcodeAddress, then return.	If newTranslatedMethod ~= nilObj then the interpreter is starting execution: dispatch to the	first instruction to begin execution."	"Note: the current instruction is called currentBytecode for historical reasons (and is hard	to change without breaking compatibility with the original Interpreter in the CCodeGenerator)."	"Note: in the simulator this code is only executed for initialisation, never for execution."	self inline: false.	self interpreterInitializing ifFalse: [		checkAssertions ifTrue: [self print: 'Warning: assertions are enabled'; cr].		self internalizeIPandSP.		self nextOp.		"dispatches to first instruction"	].	currentBytecode _ opcodeIndex.	opcodeAddress _ 0.	"the following loop is executed exactly once, but is needed to defeat dead code elimination	in some C compilers"	[opcodeAddress = 0] whileTrue: [self dispatchOn: currentBytecode in: OpcodeTable].	^opcodeAddress! !!DynamicInterpreter methodsFor: 'interpreter shell' stamp: 'ikp 12/28/97 22:30'!interpreterInitializing	^newTranslatedMethod = nilObj! !!DynamicInterpreter methodsFor: 'primitive support'!failed	^successFlag not! !!DynamicInterpreter methodsFor: 'primitive support'!positive32BitIntegerFor: integerValue	| newLargeInteger |	"Note - integerValue is interpreted as POSITIVE, eg, as the result of		Bitmap>at:, or integer>bitAnd:."	(integerValue >= 0 and: [self isIntegerValue: integerValue])		ifTrue: [^ self integerObjectOf: integerValue].	newLargeInteger _		self instantiateSmallClass: (self splObj: ClassLargePositiveInteger)				sizeInBytes: 8						 fill: 0.	self storeByte: 3 ofObject: newLargeInteger		withValue: ((integerValue >> 24) bitAnd: 16rFF).	self storeByte: 2 ofObject: newLargeInteger		withValue: ((integerValue >> 16) bitAnd: 16rFF).	self storeByte: 1 ofObject: newLargeInteger		withValue: ((integerValue >> 8) bitAnd: 16rFF).	self storeByte: 0 ofObject: newLargeInteger		withValue: (integerValue bitAnd: 16rFF).	^ newLargeInteger! !!DynamicInterpreter methodsFor: 'primitive support' stamp: 'ikp 8/18/97 11:11'!positive32BitValueOf: oop	"Convert the given object into an integer value.	The object may be either a positive ST integer or a four-byte LargePositiveInteger."	| sz value |	(self isIntegerObject: oop) ifTrue: [		value _ self integerValueOf: oop.		value < 0 ifTrue: [^ self primitiveFail].		^ value].	self successIfClassOf: oop is: (self splObj: ClassLargePositiveInteger).	successFlag ifTrue: [		sz _ self lengthOf: oop.		sz = 4 ifFalse: [^ self primitiveFail]].	successFlag ifTrue: [		^ (self fetchByte: 0 ofObject: oop) +		  ((self fetchByte: 1 ofObject: oop) <<  8) +		  ((self fetchByte: 2 ofObject: oop) << 16) +		  ((self fetchByte: 3 ofObject: oop) << 24) ].! !!DynamicInterpreter methodsFor: 'primitive support'!primIndex	^ primitiveIndex! !!DynamicInterpreter methodsFor: 'primitive support' stamp: 'ikp 8/27/97 23:44'!primitiveFail	successFlag _ false.! !!DynamicInterpreter methodsFor: 'primitive support' stamp: 'ikp 1/5/98 14:22'!primitiveResponse	self inline: false.	primitiveIndex > MaxPrimitiveIndex ifTrue: [^ false].	successFlag _ true.	self dispatchOn: primitiveIndex in: PrimitiveTable.	"check for possible timer interrupts after each primitive"	(successFlag and:	 [(nextWakeupTick ~= 0) and:	 [self ioMSecs >= nextWakeupTick]]) ifTrue: [		interruptCheckCounter _ 1000.		self checkForInterrupts].	^ successFlag! !!DynamicInterpreter methodsFor: 'primitive support' stamp: 'ikp 1/10/98 02:59'!primitiveResponseForCachedReceiver	| thisReceiver ctx result cp |	self inline: true.	successFlag _ true.	primitiveIndex >= 256		ifTrue:			[thisReceiver _ self popStack.			primitiveIndex < 264				ifTrue: ["Quick return of self or a constant"						primitiveIndex = 256 ifTrue: [self push: thisReceiver. ^true].						primitiveIndex = 257 ifTrue: [self push: trueObj. ^true].						primitiveIndex = 258 ifTrue: [self push: falseObj. ^true].						primitiveIndex = 259 ifTrue: [self push: nilObj. ^true].						primitiveIndex = 260 ifTrue: [self push: ConstMinusOne. ^true].						primitiveIndex = 261 ifTrue: [self push: ConstZero. ^true].						primitiveIndex = 262 ifTrue: [self push: ConstOne. ^true].						primitiveIndex = 263 ifTrue: [self push: ConstTwo. ^true].						^ true]				ifFalse: ["Quick return of an instance field"						self assertIsPseudoContext: thisReceiver.						self assertIsPseudoActiveContext: thisReceiver.						cp _ self pseudoCachedContextAt: thisReceiver.						ctx _ self flushCacheFrom: cp.						result _ (self fetchPointer: primitiveIndex-264 ofObject: ctx).						self copyContextToCache: ctx.						self fetchContextRegisters: activeCachedContext.						self push: result.						^ true]]		ifFalse:			[^ false]! !!DynamicInterpreter methodsFor: 'primitive support'!success: successValue	successFlag _ successValue & successFlag.! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 00:54'!checkBooleanResult: result	self inline: true.	successFlag		ifTrue: [self pushBool: result]		ifFalse: [self unPop: 2]! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 00:55'!checkIntegerResult: integerResult	self inline: true.	(successFlag and: [self isIntegerValue: integerResult])		ifTrue: [self pushInteger: integerResult]		ifFalse: [self unPop: 2.  self primitiveFail]! !!DynamicInterpreter methodsFor: 'arithmetic primitives'!compare31or32Bits: obj1 equal: obj2	"May set success to false"	"First compare two ST integers..."	((self isIntegerObject: obj1)		and: [self isIntegerObject: obj2])		ifTrue: [^ obj1 = obj2].	"Now compare, assuming positive integers, but setting fail if not"	^ (self positive32BitValueOf: obj1) = (self positive32BitValueOf: obj2)! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 00:58'!primitiveAdd	| rcvr arg result |	rcvr _ self stackValue: 1.	arg _ self stackValue: 0.	self pop: 2.	self success: (self areIntegers: rcvr and: arg).	successFlag ifTrue: [		result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).	].	self checkIntegerResult: result! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/8/97 14:25'!primitiveBitAnd	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitAnd: integerArgument))]		ifFalse: [self unPop: 2.  "self failSpecialPrim: 14"]! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 00:14'!primitiveBitOr	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitOr: integerArgument))]		ifFalse: [self unPop: 2.  "self failSpecialPrim: 15"]! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/23/97 12:02'!primitiveBitShift 	| integerReceiver integerArgument shifted |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popPos32BitInteger.	successFlag ifTrue: [		integerArgument >= 0 ifTrue: [			"Left shift -- must fail if we lose bits beyond 32"			self success: integerArgument <= 31.			shifted _ (integerReceiver << integerArgument) bitAnd: 16rFFFFFFFF.			self success: (shifted >> integerArgument) = integerReceiver.		] ifFalse: [			"Right shift -- OK to lose bits"			self success: integerArgument >= -31.			shifted _ integerReceiver bitShift: integerArgument.		].	].	successFlag		ifTrue: [self push: (self positive32BitIntegerFor: shifted)]		ifFalse: [self unPop: 2.  "self failSpecialPrim: 17"]! !!DynamicInterpreter methodsFor: 'arithmetic primitives'!primitiveBitXor	"Note: unlike all the other arithmetic primitives, this is called as	a real send, not as a special byte.  Thus successFlag has already	been set, and failure is normal, not through failSpecialPrim."	| integerReceiver integerArgument |	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitXor: integerArgument))]		ifFalse: [self unPop: 2]! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 00:59'!primitiveDiv	"Rounds negative results towards negative infinity, rather than zero."	| rcvr arg result posArg posRcvr |	successFlag _ true.	arg _ self popInteger.	rcvr _ self popInteger.	self success: arg ~= 0.	successFlag ifTrue: [		rcvr > 0 ifTrue: [			arg > 0 ifTrue: [				result _ rcvr // arg.			] ifFalse: [				"round negative result toward negative infinity"				posArg _ 0 - arg.				result _ 0 - ((rcvr + (posArg - 1)) // posArg).			].		] ifFalse: [			posRcvr _ 0 - rcvr.			arg > 0 ifTrue: [				"round negative result toward negative infinity"				result _ 0 - ((posRcvr + (arg - 1)) // arg).			] ifFalse: [				posArg _ 0 - arg.				result _ posRcvr // posArg.			].		].		self checkIntegerResult: result]	ifFalse:		[self unPop: 2]! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 00:59'!primitiveDivide	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self success: integerArgument ~= 0.	successFlag ifFalse: [integerArgument _ 1].  "fall through to fail"	self success: integerReceiver \\ integerArgument = 0.	self checkIntegerResult: integerReceiver // integerArgument! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 00:55'!primitiveEqual	| integerReceiver integerArgument result |	successFlag _ true.	integerArgument _ self popStack.	integerReceiver _ self popStack.	result _ self compare31or32Bits: integerReceiver equal: integerArgument.	self checkBooleanResult: result! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 00:55'!primitiveGreaterOrEqual	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver >= integerArgument! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 00:55'!primitiveGreaterThan	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver > integerArgument! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 00:55'!primitiveLessOrEqual	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver <= integerArgument! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 00:56'!primitiveLessThan	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver < integerArgument! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 00:59'!primitiveMakePoint	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	successFlag		ifTrue: [self push: (self makePointwithxValue: integerReceiver yValue: integerArgument)]		ifFalse: [self unPop: 2]! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 01:00'!primitiveMod	| integerReceiver integerArgument integerResult |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self success: integerArgument ~= 0.	successFlag ifFalse: [integerArgument _ 1].  "fall through to fail"	integerResult _ integerReceiver \\ integerArgument.	integerResult < 0 ifTrue: [integerResult _ integerResult + integerArgument].	self checkIntegerResult: integerResult! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 01:00'!primitiveMultiply	| rcvr arg result |	rcvr _ self stackValue: 1.	arg _ self stackValue: 0.	self pop: 2.	self success: (self areIntegers: rcvr and: arg).	successFlag ifTrue: [		rcvr _ self integerValueOf: rcvr.		arg _ self integerValueOf: arg.		result _ rcvr * arg.		"check for C overflow by seeing if computation is reversible"		self success: ((arg = 0) or: [(result // arg) = rcvr]).	].	self checkIntegerResult: result! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 00:56'!primitiveNotEqual	| integerReceiver integerArgument result |	successFlag _ true.	integerArgument _ self popStack.	integerReceiver _ self popStack.	result _ (self compare31or32Bits: integerReceiver equal: integerArgument) not.	self checkBooleanResult: result! !!DynamicInterpreter methodsFor: 'arithmetic primitives'!primitiveQuo	"Rounds negative results towards zero."	"Note: unlike the other arithmetic primitives, this is called as	a real send, not as a special byte.  Thus successFlag has already	been set, and failure is normal, not through failSpecialPrim."	| rcvr arg result |	arg _ self popInteger.	rcvr _ self popInteger.	self success: arg ~= 0.	successFlag ifTrue: [		rcvr > 0 ifTrue: [			arg > 0 ifTrue: [				result _ rcvr // arg.			] ifFalse: [				result _ 0 - (rcvr // (0 - arg)).			].		] ifFalse: [			arg > 0 ifTrue: [				result _ 0 - ((0 - rcvr) // arg).			] ifFalse: [				result _ (0 - rcvr) // (0 - arg).			].		].		self success: (self isIntegerValue: result)].	successFlag		ifTrue: [self pushInteger: result]		ifFalse: [self unPop: 2]! !!DynamicInterpreter methodsFor: 'arithmetic primitives' stamp: 'ikp 12/6/97 01:00'!primitiveSubtract	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkIntegerResult: integerReceiver - integerArgument! !!DynamicInterpreter methodsFor: 'float primitives' stamp: 'ikp 8/18/97 11:11'!popFloat	"Note: May be called by translated primitive code."	| top result |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	top _ self popStack.	self successIfClassOf: top is: (self splObj: ClassFloat).	successFlag		ifTrue: [self fetchFloatAt: top + BaseHeaderSize into: result].	^ result! !!DynamicInterpreter methodsFor: 'float primitives'!primitiveArctan	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'atan(rcvr)')]		ifFalse: [self unPop: 1]! !!DynamicInterpreter methodsFor: 'float primitives'!primitiveAsFloat	| arg |	arg _ self popInteger.	successFlag		ifTrue: [ self pushFloat: (self cCode: '((double) arg)') ]		ifFalse: [ self unPop: 1 ].! !!DynamicInterpreter methodsFor: 'float primitives'!primitiveExp	"Computes E raised to the receiver power."	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'exp(rcvr)')]		ifFalse: [self unPop: 1]! !!DynamicInterpreter methodsFor: 'float primitives'!primitiveExponent	"Exponent part of this float."	| rcvr frac pwr |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	rcvr _ self popFloat.	successFlag		ifTrue: [			self cCode: 'frac = frexp(rcvr, &pwr)'.  "rcvr = frac * 2^pwr, where frac is in [0.5..1.0)"			(pwr = 0)				ifTrue: [self pushInteger: 0]				ifFalse: [self pushInteger: pwr - 1]]		ifFalse: [self unPop: 1].! !!DynamicInterpreter methodsFor: 'float primitives' stamp: 'ikp 8/18/97 11:13'!primitiveFloatAdd	| rcvr rcvrOop arg argOop result resultOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	self var: #result declareC: 'double result'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self successIfFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		result _ rcvr + arg.		resultOop _ self clone: rcvrOop.		self storeFloatAt: resultOop + BaseHeaderSize from: result.		self pop: 2 thenPush: resultOop].! !!DynamicInterpreter methodsFor: 'float primitives' stamp: 'ikp 8/18/97 11:13'!primitiveFloatDivide	| rcvr rcvrOop arg argOop result resultOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	self var: #result declareC: 'double result'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self successIfFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self success: arg ~= 0.0.		successFlag ifTrue: [			result _ rcvr // arg.  "generates C / operation"			resultOop _ self clone: rcvrOop.			self storeFloatAt: resultOop + BaseHeaderSize from: result.			self pop: 2 thenPush: resultOop]].! !!DynamicInterpreter methodsFor: 'float primitives' stamp: 'ikp 8/18/97 11:13'!primitiveFloatEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self successIfFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr = arg].! !!DynamicInterpreter methodsFor: 'float primitives' stamp: 'ikp 8/18/97 11:13'!primitiveFloatGreaterOrEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self successIfFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr >= arg].! !!DynamicInterpreter methodsFor: 'float primitives' stamp: 'ikp 8/18/97 11:13'!primitiveFloatGreaterThan	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self successIfFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr > arg].! !!DynamicInterpreter methodsFor: 'float primitives' stamp: 'ikp 8/18/97 11:13'!primitiveFloatLessOrEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self successIfFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr <= arg].! !!DynamicInterpreter methodsFor: 'float primitives' stamp: 'ikp 8/18/97 11:13'!primitiveFloatLessThan	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self successIfFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr < arg].! !!DynamicInterpreter methodsFor: 'float primitives' stamp: 'ikp 8/18/97 11:13'!primitiveFloatMultiply	| rcvr rcvrOop arg argOop result resultOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	self var: #result declareC: 'double result'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self successIfFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		result _ rcvr * arg.		resultOop _ self clone: rcvrOop.		self storeFloatAt: resultOop + BaseHeaderSize from: result.		self pop: 2 thenPush: resultOop].! !!DynamicInterpreter methodsFor: 'float primitives' stamp: 'ikp 8/18/97 11:13'!primitiveFloatNotEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self successIfFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr ~= arg].! !!DynamicInterpreter methodsFor: 'float primitives' stamp: 'ikp 8/18/97 11:13'!primitiveFloatSubtract	| rcvr rcvrOop arg argOop result resultOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	self var: #result declareC: 'double result'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self successIfFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		result _ rcvr - arg.		resultOop _ self clone: rcvrOop.		self storeFloatAt: resultOop + BaseHeaderSize from: result.		self pop: 2 thenPush: resultOop].! !!DynamicInterpreter methodsFor: 'float primitives'!primitiveFractionalPart	| rcvr frac trunc |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	self var: #trunc declareC: 'double trunc'.	rcvr _ self popFloat.	successFlag		ifTrue: [			self cCode: 'frac = modf(rcvr, &trunc)'.			self pushFloat: frac]		ifFalse: [self unPop: 1]! !!DynamicInterpreter methodsFor: 'float primitives'!primitiveLogN	"Natural log."	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'log(rcvr)')]		ifFalse: [self unPop: 1]! !!DynamicInterpreter methodsFor: 'float primitives'!primitiveSine	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'sin(rcvr)')]		ifFalse: [self unPop: 1]! !!DynamicInterpreter methodsFor: 'float primitives'!primitiveSquareRoot	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	self success: rcvr >= 0.0.	successFlag		ifTrue: [self pushFloat: (self cCode: 'sqrt(rcvr)')]		ifFalse: [self unPop: 1]! !!DynamicInterpreter methodsFor: 'float primitives'!primitiveTimesTwoPower	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	arg _ self popInteger.	rcvr _ self popFloat.	successFlag		ifTrue: [ self pushFloat: (self cCode: 'ldexp(rcvr, arg)') ]		ifFalse: [ self unPop: 2 ].! !!DynamicInterpreter methodsFor: 'float primitives' stamp: 'di 6/7/97 09:59'!primitiveTruncated 	| rcvr frac trunc |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	self var: #trunc declareC: 'double trunc'.	rcvr _ self popFloat.	successFlag ifTrue: [		self cCode: 'frac = modf(rcvr, &trunc)'.		self cCode: 'success((-1073741824.0 <= trunc) && (trunc <= 1073741823.0))'.	].	successFlag		ifTrue: [self cCode: 'pushInteger((int) trunc)']		ifFalse: [self unPop: 1]! !!DynamicInterpreter methodsFor: 'float primitives'!pushFloat: f	| newFloatObj |	self var: #f declareC: 'double f'.	newFloatObj _ self instantiateSmallClass: (self splObj: ClassFloat) sizeInBytes: 12 fill: 0.	self storeFloatAt: newFloatObj + BaseHeaderSize from: f.	self push: newFloatObj.! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'ikp 8/18/97 11:11'!asciiOfCharacter: characterObj  "Returns an integer object"	self inline: false.	self successIfClassOf: characterObj is: (self splObj: ClassCharacter).	successFlag		ifTrue: [^ self fetchPointer: CharacterValueIndex ofObject: characterObj]		ifFalse: [^ ConstZero]  "in case some code needs an int"! !!DynamicInterpreter methodsFor: 'array and stream primitives'!byteLengthOf: oop	"Return the number of indexable bytes in the given object. This is basically a special copy of lengthOf: for BitBlt."	| header sz fmt |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: 16rFC ].	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize)]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3)]  "bytes"! !!DynamicInterpreter methodsFor: 'array and stream primitives'!characterForAscii: integerObj  "Arg must lie in range 0-255!!"	^ self fetchPointer: (self integerValueOf: integerObj)			ofObject: (self splObj: CharacterTable)! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'ikp 12/6/97 00:22'!commonAt: stringy	"This version of at: is called from the special byteCode, from	primitiveAt, and from primStringAt.  The boolean 'stringy'	indicates that the result should be converted to a Character."	| index rcvr result |	self inline: true.	index _ self stackTop.	rcvr _ self stackValue: 1.	(self isIntegerObject: index) & (self isIntegerObject: rcvr) not ifTrue: [		index _ self integerValueOf: index.		result _ self stObject: rcvr at: index.		(stringy and: [successFlag]) ifTrue: [result _ self characterForAscii: result].	] ifFalse: [		successFlag _ false.	].	successFlag ifTrue: [		self pop: 2 thenPush: result.	]" ifFalse: [		stringy			ifTrue: [self failSpecialPrim: 63]			ifFalse: [self failSpecialPrim: 60].	]."! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'ikp 12/6/97 00:24'!commonAtPut: stringy	"See the comment in commonAt:."	| value valToStore index rcvr |	self inline: true.	value _ valToStore _ self stackTop.	index _ self stackValue: 1.	rcvr _ self stackValue: 2.	(self isIntegerObject: index) & (self isIntegerObject: rcvr) not ifTrue: [		index _ self integerValueOf: index.		stringy ifTrue: [valToStore _ self asciiOfCharacter: value].		self stObject: rcvr at: index put: valToStore.	] ifFalse: [		successFlag _ false.	].	successFlag ifTrue: [		self pop: 3 thenPush: value.	] "ifFalse: [		stringy			ifTrue: [self failSpecialPrim: 64]			ifFalse: [self failSpecialPrim: 61].	]."! !!DynamicInterpreter methodsFor: 'array and stream primitives'!lengthOf: oop	"Return the number of indexable bytes or words in the given object. Assume the argument is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result."	| header sz fmt |	self inline: true.	"from ObjectMemory>sizeBitsOf:..."	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: 16rFC ].	"from ObjectMemory>formatOf:..."	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"! !!DynamicInterpreter methodsFor: 'array and stream primitives'!lengthOf: oop baseHeader: hdr format: fmt	"Return the number of indexable bytes or words in the given object. Assume the given oop is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result of this method."	| sz |	self inline: true.	(hdr bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ hdr bitAnd: 16rFC ].	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"! !!DynamicInterpreter methodsFor: 'array and stream primitives'!okArrayClass: cl	^(cl = (self splObj: ClassArray) or:	  [cl = (self splObj: ClassBitmap) or:	  [cl = (self splObj: ClassByteArray)]])! !!DynamicInterpreter methodsFor: 'array and stream primitives'!okStreamArrayClass: cl	^(cl = (self splObj: ClassString) or:	  [cl = (self splObj: ClassArray) or:	  [cl = (self splObj: ClassByteArray) or:	  [cl = (self splObj: ClassBitmap)]]])! !!DynamicInterpreter methodsFor: 'array and stream primitives'!primitiveAt	self commonAt: false.! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'di 6/21/97 10:13'!primitiveAtEnd	| stream array index limit arrayClass size |	stream _ self popStack.	successFlag _ ((self isPointers: stream)			and: [(self lengthOf: stream) >= (StreamReadLimitIndex+1)]). 	successFlag ifTrue: [		array _ self fetchPointer: StreamArrayIndex ofObject: stream.		index _ self fetchInteger: StreamIndexIndex ofObject: stream.		limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.		arrayClass _ self fetchClassOf: array.		self success: (self okStreamArrayClass: arrayClass).		size _ self stSizeOf: array]. 	successFlag		ifTrue: [self pushBool: (index >= limit) | (index >= size)]		ifFalse: [self unPop: 1].! !!DynamicInterpreter methodsFor: 'array and stream primitives'!primitiveAtPut	self commonAtPut: false.! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'ikp 8/12/97 23:31'!primitiveNext	| stream array index limit arrayClass stringy result |	stream _ self popStack.	successFlag _		((self isPointers: stream) and:		 [(self lengthOf: stream) >= (StreamReadLimitIndex + 1)]). 	successFlag ifTrue: [		array _ self fetchPointer: StreamArrayIndex ofObject: stream.		index _ self fetchInteger: StreamIndexIndex ofObject: stream.		limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.		arrayClass _ self fetchClassOf: array.		stringy _ arrayClass = (self splObj: ClassString).		stringy ifFalse: [			self success: (self okStreamArrayClass: arrayClass)].		self success: index < limit].	successFlag ifTrue: [		index _ index + 1.		self pushRemappableOop: stream.		result _ self stObject: array at: index.  "may cause GC!!"		stream _ self popRemappableOop].	successFlag ifTrue: [		self storeInteger: StreamIndexIndex			ofObject: stream			withValue: index].	successFlag ifTrue: [		stringy			ifTrue: [self push: (self characterForAscii: result)]			ifFalse: [self push: result].	] ifFalse: [		self unPop: 1].! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'ikp 8/12/97 23:32'!primitiveNextPut	| value stream index limit array arrayClass storeVal |	value _ self popStack.	stream _ self popStack.	successFlag _ ((self isPointers: stream)			and: [(self lengthOf: stream) >= (StreamWriteLimitIndex+1)]). 	successFlag ifTrue: [		array _ self fetchPointer: StreamArrayIndex ofObject: stream.		index _ self fetchInteger: StreamIndexIndex ofObject: stream.		limit _ self fetchInteger: StreamWriteLimitIndex ofObject: stream.		arrayClass _ self fetchClassOf: array.		self success: (self okStreamArrayClass: arrayClass).		self success: index < limit].	successFlag ifTrue:		[index _ index + 1.		arrayClass = (self splObj: ClassString)			ifTrue: [storeVal _ self asciiOfCharacter: value]			ifFalse: [storeVal _ value].		self stObject: array at: index put: storeVal].	successFlag ifTrue:		[self storeInteger: StreamIndexIndex ofObject: stream			withValue: index].	successFlag		ifTrue: [self push: value]		ifFalse: [self unPop: 2]! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'ikp 12/6/97 00:31'!primitiveSize	| rcvr sz |	rcvr _ self stackTop.	(self isIntegerObject: rcvr)		ifTrue: [sz _ 0]  "integers have no indexable fields"		ifFalse: [sz _ self stSizeOf: rcvr]."ikp: this is redundant!!	successFlag ifTrue: ["		self pop: 1. self pushInteger: sz"	] ifFalse: [self failSpecialPrim: 62]."! !!DynamicInterpreter methodsFor: 'array and stream primitives'!primitiveStringAt	self commonAt: true.! !!DynamicInterpreter methodsFor: 'array and stream primitives'!primitiveStringAtPut	self commonAtPut: true.! !!DynamicInterpreter methodsFor: 'array and stream primitives'!primitiveStringReplace"<array> primReplaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>"	| array start stop repl replStart hdr arrayFmt totalLength arrayInstSize replFmt replInstSize srcIndex |	array _ self stackValue: 4.	start _ self stackIntegerValue: 3.	stop _ self stackIntegerValue: 2.	repl _ self stackValue: 1.	replStart _ self stackIntegerValue: 0.	successFlag ifFalse: [^ self primitiveFail].	(self isIntegerObject: repl)  "can happen in LgInt copy"		ifTrue: [^ self primitiveFail].	hdr _ self baseHeader: array.	arrayFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: arrayFmt.	arrayInstSize _ self fixedFieldsOf: array format: arrayFmt length: totalLength.	((start >= 1) and: [(start <= stop) and: [stop + arrayInstSize <= totalLength]])		ifFalse: [^ self primitiveFail].	hdr _ self baseHeader: repl.	replFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: repl baseHeader: hdr format: replFmt.	replInstSize _ self fixedFieldsOf: repl format: replFmt length: totalLength.	((replStart >= 1) and: [stop - start + replStart + replInstSize <= totalLength])		ifFalse: [^ self primitiveFail].	"Array formats (without byteSize bits, if bytes array) must be same"	arrayFmt < 8		ifTrue: [arrayFmt = replFmt ifFalse: [^ self primitiveFail]]		ifFalse: [(arrayFmt bitAnd: 16rC) = (replFmt bitAnd: 16rC) ifFalse: [^ self primitiveFail]].	srcIndex _ replStart + replInstSize - 1.   " - 1 for 0-based access"	start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 		arrayFmt < 4 ifTrue: [  "pointer type objects"			self storePointer: i ofObject: array withValue:				(self fetchPointer: srcIndex ofObject: repl)]		ifFalse: [			arrayFmt < 8 ifTrue: [  "long-word type objects"				self storeWord: i ofObject: array withValue:					(self fetchWord: srcIndex ofObject: repl)]			ifFalse: [  "byte-type objects"				self storeByte: i ofObject: array withValue:					(self fetchByte: srcIndex ofObject: repl)]].		srcIndex _ srcIndex + 1.	].	self pop: 4.  "leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'array and stream primitives'!stObject: array at: index	"Return what ST would return for <obj> at: index."	| hdr fmt totalLength fixedFields |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	((index >= 1) and: [index <= (totalLength - fixedFields)]) ifFalse: [successFlag _ false].	successFlag		ifTrue: [^ self subscript: array with: (index + fixedFields) format: fmt]		ifFalse: [^ 0 ].! !!DynamicInterpreter methodsFor: 'array and stream primitives'!stObject: array at: index put: value	"Do what ST would return for <obj> at: index put: value."	| hdr fmt totalLength fixedFields |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	((index >= 1) and: [index <= (totalLength - fixedFields)]) ifFalse: [successFlag _ false].	successFlag ifTrue:		[self subscript: array with: (index + fixedFields) storing: value format: fmt].! !!DynamicInterpreter methodsFor: 'array and stream primitives'!stSizeOf: oop	"Return the number of indexable fields in the given object. (i.e., what Smalltalk would return for <obj> size)."	"Note: Assume oop is not a SmallInteger!!"	| hdr fmt totalLength fixedFields |	self inline: true.	hdr _ self baseHeader: oop.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: oop baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: oop format: fmt length: totalLength.	^ totalLength - fixedFields! !!DynamicInterpreter methodsFor: 'array and stream primitives'!subscript: array with: index format: fmt	"Note: This method assumes that the index is within bounds!!"	self inline: true.	fmt < 4 ifTrue: [  "pointer type objects"		^ self fetchPointer: index - 1 ofObject: array].	fmt < 8 ifTrue: [  "long-word type objects"		^ self positive32BitIntegerFor:			(self fetchWord: index - 1 ofObject: array)	] ifFalse: [  "byte-type objects"		^ self integerObjectOf:			(self fetchByte: index - 1 ofObject: array)	].! !!DynamicInterpreter methodsFor: 'array and stream primitives'!subscript: array with: index storing: oopToStore format: fmt	"Note: This method assumes that the index is within bounds!!"	| valueToStore |	self inline: true.	fmt < 4 ifTrue: [  "pointer type objects"		self storePointer: index - 1 ofObject: array withValue: oopToStore.	] ifFalse: [		fmt < 8 ifTrue: [  "long-word type objects"			valueToStore _ self positive32BitValueOf: oopToStore.			successFlag ifTrue:				[self storeWord: index - 1 ofObject: array withValue: valueToStore].		] ifFalse: [  "byte-type objects"			(self isIntegerObject: oopToStore) ifFalse: [successFlag _ false].			valueToStore _ self integerValueOf: oopToStore.			((valueToStore >= 0) and: [valueToStore <= 255]) ifFalse: [successFlag _ false].			successFlag ifTrue:				[self storeByte: index - 1 ofObject: array withValue: valueToStore].		].	].! !!DynamicInterpreter methodsFor: 'object access primitives' stamp: 'ikp 1/11/98 19:18'!primitiveArrayBecome	"We must flush the method cache here, to eliminate stale references	to mutated classes and/or selectors."	| arg rcvr |	arg _ self popStack.	rcvr _ self stackTop.	self flushMethodCache.	self flushInlineCache.	self success: (self become: rcvr with: arg).	successFlag ifFalse: [ self unPop: 1 ].! !!DynamicInterpreter methodsFor: 'object access primitives'!primitiveAsOop	| thisReceiver |	thisReceiver _ self popStack.	self success: (self isIntegerObject: thisReceiver) not.	successFlag		ifTrue: [self pushInteger: (self hashBitsOf: thisReceiver)]		ifFalse: [self unPop: 1]! !!DynamicInterpreter methodsFor: 'object access primitives' stamp: 'ikp 8/18/97 01:40'!primitiveClass	| instance class cp |	instance _ self popStack.	class _ self fetchClassOf: instance.	class = (self splObj: ClassPseudoContext) ifTrue: [		cp _ self pseudoCachedContextAt: instance.		(self isCachedMethodContext: cp)			ifTrue: [class _ self splObj: ClassMethodContext]			ifFalse: [class _ self splObj: ClassBlockContext]].	self push: class! !!DynamicInterpreter methodsFor: 'object access primitives' stamp: 'ikp 1/5/98 17:50'!primitiveClone	"Return a shallow copy of the receiver."	| newCopy |	newCopy _ self clone: (self stackTop).	self pop: 1 thenPush: newCopy.! !!DynamicInterpreter methodsFor: 'object access primitives'!primitiveEquivalent	| thisObject otherObject |	otherObject _ self popStack.	thisObject _ self popStack.	self pushBool: thisObject = otherObject! !!DynamicInterpreter methodsFor: 'object access primitives'!primitiveInstVarAt	| index rcvr hdr fmt totalLength fixedFields value |	index _ self popInteger.	rcvr _ self popStack.	successFlag ifTrue: [		hdr _ self baseHeader: rcvr.		fmt _ (hdr >> 8) bitAnd: 16rF.		totalLength _ self lengthOf: rcvr baseHeader: hdr format: fmt.		fixedFields _ self fixedFieldsOf: rcvr format: fmt length: totalLength.		((index >= 1) and: [index <= fixedFields])			ifFalse: [successFlag _ false]].	successFlag		ifTrue: [value _ self subscript: rcvr with: index format: fmt].	successFlag		ifTrue: [self push: value]		ifFalse: [self unPop: 2]! !!DynamicInterpreter methodsFor: 'object access primitives'!primitiveInstVarAtPut	| newValue index rcvr hdr fmt totalLength fixedFields |	newValue _ self popStack.	index _ self popInteger.	rcvr _ self popStack.	successFlag ifTrue: [		hdr _ self baseHeader: rcvr.		fmt _ (hdr >> 8) bitAnd: 16rF.		totalLength _ self lengthOf: rcvr baseHeader: hdr format: fmt.		fixedFields _ self fixedFieldsOf: rcvr format: fmt length: totalLength.		((index >= 1) and: [index <= fixedFields])			ifFalse: [successFlag _ false]].	successFlag		ifTrue: [self subscript: rcvr with: index storing: newValue format: fmt].	successFlag		ifTrue: [self push: newValue]		ifFalse: [self unPop: 3]! !!DynamicInterpreter methodsFor: 'object access primitives' stamp: 'ikp 8/12/97 23:30'!primitiveNew	"Allocate a new fixed-size instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free."	| class spaceOkay |	class _ self popStack.	spaceOkay _ self sufficientSpaceToInstantiate: class indexableSize: 0.	self success: spaceOkay.	successFlag		ifTrue: [ self push: (self instantiateClass: class indexableSize: 0) ]		ifFalse: [ self unPop: 1 ].! !!DynamicInterpreter methodsFor: 'object access primitives' stamp: 'ikp 8/12/97 23:31'!primitiveNewWithArg	"Allocate a new indexable instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free."	| size class spaceOkay |	size _ self popInteger.	class _ self popStack.	self success: size >= 0.	successFlag ifTrue: [		spaceOkay _ self sufficientSpaceToInstantiate: class indexableSize: size.		self success: spaceOkay.	].	successFlag		ifTrue: [ self push: (self instantiateClass: class indexableSize: size) ]		ifFalse: [ self unPop: 2 ].! !!DynamicInterpreter methodsFor: 'object access primitives'!primitiveNextInstance	| object instance |	object _ self popStack.	instance _ self instanceAfter: object.	instance = nilObj		ifTrue: [self unPop: 1. self primitiveFail]		ifFalse: [self push: instance]! !!DynamicInterpreter methodsFor: 'object access primitives'!primitiveNextObject	"Return the object following the receiver in the heap. Return the SmallInteger zero when there are no more objects."	| object instance |	object _ self popStack.	instance _ self accessibleObjectAfter: object.	instance = nil		ifTrue: [ self pushInteger: 0 ]		ifFalse: [ self push: instance ].! !!DynamicInterpreter methodsFor: 'object access primitives'!primitiveObjectAt  "Defined for CompiledMethods only"	| thisReceiver index |	index  _ self popInteger.	thisReceiver _ self popStack.	self success: index > 0.	self success: index <= ((self literalCountOf: thisReceiver) + LiteralStart).	successFlag		ifTrue: [self push: (self fetchPointer: index - 1					ofObject: thisReceiver)]		ifFalse: [self unPop: 2]! !!DynamicInterpreter methodsFor: 'object access primitives'!primitiveObjectAtPut  "Defined for CompiledMethods only"	| thisReceiver index newValue |	newValue _ self popStack.	index _ self popInteger.	thisReceiver _ self popStack.	self success: index > 0.	self success: index <= ((self literalCountOf: thisReceiver) + LiteralStart).	successFlag		ifTrue: [self storePointer: index - 1				ofObject: thisReceiver				withValue: newValue.			self push: newValue]		ifFalse: [self unPop: 3]! !!DynamicInterpreter methodsFor: 'object access primitives'!primitiveObjectPointsTo	| rcvr thang lastField |	thang _ self popStack.	rcvr _ self popStack.	(self isIntegerObject: rcvr) ifTrue: [^ self pushBool: false].	lastField _ self lastPointerOf: rcvr.	BaseHeaderSize to: lastField by: 4 do:		[:i | (self longAt: rcvr + i) = thang			ifTrue: [^ self pushBool: true]].	self pushBool: false.! !!DynamicInterpreter methodsFor: 'object access primitives' stamp: 'ikp 12/6/97 00:47'!primitivePointX	| rcvr | 	successFlag _ true.	rcvr _ self popStack.	self successIfClassOf: rcvr is: (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: XIndex ofObject: rcvr)]		ifFalse: [self unPop: 1.  "self failSpecialPrim: 0"  "will fail"]! !!DynamicInterpreter methodsFor: 'object access primitives' stamp: 'ikp 12/6/97 00:48'!primitivePointY	| rcvr | 	successFlag _ true.	rcvr _ self popStack.	self successIfClassOf: rcvr is: (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: YIndex ofObject: rcvr)]		ifFalse: [self unPop: 1.  "self failSpecialPrim: 0"  "will fail"]! !!DynamicInterpreter methodsFor: 'object access primitives' stamp: 'di 1/14/98 09:24'!primitiveSomeInstance	| class instance |	class _ self popStack.	instance _ self initialInstanceOf: class.	instance = nilObj		ifTrue: [self unPop: 1. self primitiveFail]		ifFalse: [self push: instance]! !!DynamicInterpreter methodsFor: 'object access primitives'!primitiveSomeObject	"Return the first object in the heap."	self pop: 1.	self push: self firstAccessibleObject.! !!DynamicInterpreter methodsFor: 'object access primitives'!sufficientSpaceToInstantiate: classOop indexableSize: size	"Return the number of bytes required to allocate an instance of the given class with the given number of indexable fields."	"Details: For speed, over-estimate space needed for fixed fields or literals; the low space threshold is a blurry line."	| format okay |	self inline: true.	format _ ((self formatOfClass: classOop) >> 8) bitAnd: 16rF.	"fail if attempting to call new: on non-indexable class"	(size > 0 and: [format < 2]) ifTrue: [ ^ false ].	format < 8 ifTrue: [		"indexable fields are words or pointers"		okay _ self sufficientSpaceToAllocate: (2500 + (size * 4)).	] ifFalse: [		"indexable fields are bytes"		okay _ self sufficientSpaceToAllocate: (2500 + size).	].	^ okay! !!DynamicInterpreter methodsFor: 'control primitives' stamp: 'ikp 12/1/97 22:39'!initializeCachedBlockContext: context fromClosure: closure	"Called by primitiveValue and primitiveValueWithArgs"	| home initialIP hp method tMethod |	self inline: true.	self assertIsStableBlockContext: closure.	home _ self fetchPointer: HomeIndex ofObject: closure.	self cachedHomeAt: context put: home.	(self isPseudoContext: home) ifTrue: [		hp _ self pseudoCachedContextAt: home.		method _ (self cachedMethodAt: hp).		tMethod _ (self cachedTranslatedMethodAt: hp).		self cachedReceiverAt:			context put: (self cachedReceiverAt: hp).		self cachedMethodAt:			context put: (method).		self cachedTranslatedMethodAt:	context put: (tMethod)."		self cachedTemporaryPointerAt:	context put: (self cachedFramePointerAt: hp)."		self setTemporaryPointer: (self cachedFramePointerAt: hp).	] ifFalse: [		method _ (self fetchPointer: MethodIndex ofObject: home).		tMethod _ (self fetchPointer: TranslatedMethodIndex ofObject: home).		self cachedReceiverAt:			context put: (self fetchPointer: ReceiverIndex ofObject: home).		self cachedMethodAt:			context put: (method).		self cachedTranslatedMethodAt:	context put: (tMethod)."		self cachedTemporaryPointerAt:	context put: (home + BaseHeaderSize + (TempFrameStart * 4))."		self setTemporaryPointer: (home + BaseHeaderSize + (TempFrameStart * 4)).		home < youngStart ifTrue: [self beRootIfOld: home].	].	initialIP _ (self fetchPointer: InitialIPIndex ofObject: closure).	self cachedInitialIPAt:				context put: initialIP.	self cachedInstructionIndexAt:		context put: initialIP.! !!DynamicInterpreter methodsFor: 'control primitives' stamp: 'ikp 12/11/97 17:00'!primitiveBlockCopy	| context methodContext contextSize newContext initialIP cp |	context _ self stackValue: 1.	self assertIsContext: context.	(self isPseudoContext: context) ifTrue: [		cp _ self pseudoCachedContextAt: context.		(self isCachedBlockContext: cp) ifTrue: [			methodContext _ self cachedHomeAt: cp.		] ifFalse: [			methodContext _ context.		].	] ifFalse: [		(self isBlockContext: context) ifTrue: [			methodContext _ self fetchPointer: HomeIndex ofObject: context.		] ifFalse: [			methodContext _ context.		].	].	self assertIsContext: methodContext.	contextSize _ self sizeBitsOf: methodContext.  "in bytes, including header"	context _ nil.  "context is no longer needed and is not preserved across allocation"	"remap methodContext in case GC happens during allocation"	self pushRemappableOop: methodContext.	newContext _ self instantiateSmallClass: (self splObj: ClassBlockContext)							   sizeInBytes: contextSize									   fill: nilObj.	methodContext _ self popRemappableOop.	initialIP _ (self translatedInstructionPointer: self instructionPointer					toIndexIn: self translatedMethod)				+ (2 * "integer object weighting" 2).	"Was instructionPointer + 3, but now it's greater by 		methodOop + 4 (headerSize) and less by 1 due to preIncrement"	"Assume: have just allocated a new context; it must be young.	 Thus, can use unchecked stores."	self storePointerUnchecked: CallerIndex		ofObject: newContext withValue: nilObj.	self storeWord: InstructionPointerIndex		ofObject: newContext withValue: initialIP.	self storeWord: StackPointerIndex				ofObject: newContext withValue: ConstZero.	self storeWord: BlockArgumentCountIndex		ofObject: newContext withValue: (self stackValue: 0).	self storeWord: InitialIPIndex					ofObject: newContext withValue: initialIP.	self storePointerUnchecked: HomeIndex		ofObject: newContext withValue: methodContext.	self pop: 2.  "block argument count, rcvr"	self push: newContext.! !!DynamicInterpreter methodsFor: 'control primitives' stamp: 'ikp 1/14/98 20:39'!primitiveDoPrimitiveWithArgs	| argumentArray primIdx arraySize index cntxSize stackSize |	"Stack:	... receiver primitiveIndex argumentArray"	self assertStackPointerIsExternal.	argumentArray _ self stackTop.	arraySize _ self fetchWordLengthOf: argumentArray.	cntxSize _ (self wordLengthOfContext: activeCachedContext) - TempFrameStart.		"max stack depth"	stackSize _ (self stackPointer - (self cachedFramePointerAt: activeCachedContext)) // 4.	"current stack depth"	self success: (cntxSize - stackSize) > arraySize.	self successIfClassOf: argumentArray is: (self splObj: ClassArray).	primIdx _ self stackIntegerValue: 1.	successFlag ifFalse: [^ self primitiveFail].  "invalid args"	"Pop primIndex and argArray, then push args in place..."	self pop: 2.	newReceiver _ self stackTop.	"is this actually necessary??"	primitiveIndex _ primIdx.	argumentCount _ arraySize.	index _ 0.	[index < arraySize] whileTrue:		[self push: (self fetchPointer: index ofObject: argumentArray).		 index _ index + 1].	"Run the primitive (sets successFlag)"	self pushRemappableOop: argumentArray.	"prim might alloc"	self primitiveResponse.	"pseudo receivers will already be flushed by the calling primResponse"	argumentArray _ self popRemappableOop.	successFlag ifFalse: [		self pop: arraySize.		"prim might clobber argumentCount"		self pushInteger: primIdx.		"prim might clobber primitiveIndex"		self push: argumentArray.		argumentCount _ 2.		"... caller (execNewMeth) will run failure code"]! !!DynamicInterpreter methodsFor: 'control primitives' stamp: 'ikp 11/30/97 16:06'!primitivePerform	| performSelector |	self assertStackPointerIsExternal.	performSelector _ messageSelector.	messageSelector _ self stackValue: argumentCount - 1.	newReceiver _ self stackValue: argumentCount.	"NOTE: the following lookup may fail and be converted to #doesNotUnderstand:,		so we must adjust argument count now, so that would work."	argumentCount _ argumentCount - 1.	self pushRemappableOop: performSelector."**	self lookupMethodInClass: (self fetchClassOf: newReceiver).	**"	"provokes GC!!"	self findNewMethodInClass: (self fetchClassOf: newReceiver).	"provokes GC!!"	performSelector _ self popRemappableOop.	self success: (self argumentCountOf: newMethod) = argumentCount.	successFlag ifTrue: [		"Remove the #perform: from the stack"		self inlineTransfer:	argumentCount									"N"			wordsFrom:		self stackPointer - (argumentCount * 4) + 4		"[arg1 arg2 ... argN]"			to:				self stackPointer - (argumentCount * 4).			"[selector arg1 arg2 ... argN]"		self pop: 1.		self executeNewMethod.  "Recursive xeq affects successFlag"		successFlag _ true.	] ifFalse: [		argumentCount _ argumentCount + 1.		messageSelector _ performSelector.	]! !!DynamicInterpreter methodsFor: 'control primitives' stamp: 'ikp 11/30/97 16:07'!primitivePerformWithArgs	| performSelector argumentArray arraySize index cntxSize stackSize numArgs |	self assertStackPointerIsExternal.	argumentArray _ self popStack.	arraySize _ self fetchWordLengthOf: argumentArray.	cntxSize _ (self wordLengthOfContext: activeCachedContext) - TempFrameStart.		"max stack depth"	stackSize _ (self stackPointer - (self cachedFramePointerAt: activeCachedContext)) // 4.	"current stack depth"	self success: (cntxSize - stackSize) > arraySize.	self successIfClassOf: argumentArray is: (self splObj: ClassArray).	successFlag ifTrue: [		performSelector _ messageSelector.		messageSelector _ self popStack.		newReceiver _ self stackTop.		numArgs _ argumentCount _ arraySize.		index _ 0.		[index < numArgs] whileTrue: [			self push: (self fetchPointer: index ofObject: argumentArray).			index _ index + 1].		self pushRemappableOop: performSelector.		self pushRemappableOop: argumentArray."***		self lookupMethodInClass: (self fetchClassOf: newReceiver)."	"provokes GC!!"		self findNewMethodInClass: (self fetchClassOf: newReceiver).	"provokes GC!!"		argumentArray _ self popRemappableOop.		performSelector _ self popRemappableOop.		self success: (self argumentCountOf: newMethod) = argumentCount.		successFlag ifTrue: [			self executeNewMethod.  "Recursive xeq affects successFlag"			successFlag _ true.		] ifFalse: [			self pop: argumentCount.			self push: messageSelector.			self push: argumentArray.			argumentCount _ 2.			messageSelector _ performSelector.		].	] ifFalse: [		self unPop: 1.	]! !!DynamicInterpreter methodsFor: 'control primitives' stamp: 'ikp 8/27/97 10:44'!primitiveValue	| blockContext blockArgumentCount newContext newFrame oldSP oldContext numArgs |	self assertStackPointerIsExternal.	numArgs _ argumentCount.	blockContext _ self stackValue: numArgs.	self assertIsStableBlockContext: blockContext.	blockArgumentCount _ self argumentCountOfBlock: blockContext.	self success: (numArgs = blockArgumentCount			and: [(self fetchPointer: CallerIndex ofObject: blockContext) = nilObj]).	successFlag ifTrue: [		oldContext		_ activeCachedContext.		oldSP			_ self cachedStackPointerAt: oldContext.		newFrame		_ oldSP - (numArgs * 4) + 4.	"first argument"		self pushRemappableOop: blockContext.		newContext		_ self allocateCachedContextAfter: oldContext frame: newFrame.  "GC!!"		blockContext _ self popRemappableOop.		self cachedStackPointerAt: oldContext put: (newFrame - 8).	"updated AFTER possible GC"		stackOverflow ifTrue: [			newFrame _ self cachedFramePointerAt: newContext.			self	transfer:	numArgs				wordsFrom:	oldSP - (numArgs * 4) + 4		"first argument"				to:			newFrame.			stackOverflow _ false.		].		self initializeCachedBlockContext: newContext fromClosure: blockContext.		self cachedStackPointerAt: newContext put: (newFrame + (numArgs * 4) - 4).		self cachedBlockArgumentCountAt: newContext put: (self integerObjectOf: blockArgumentCount)."		self fetchContextRegisters: newContext."	]! !!DynamicInterpreter methodsFor: 'control primitives' stamp: 'ikp 8/27/97 10:44'!primitiveValueWithArgs	| argumentArray blockContext blockArgumentCount arrayArgumentCount newContext newFrame oldSP |	self assertStackPointerIsExternal.	argumentArray _ self popStack.	blockContext _ self popStack.	self assertIsStableBlockContext: blockContext.	blockArgumentCount _ self argumentCountOfBlock: blockContext.	self successIfClassOf: argumentArray is: (self splObj: ClassArray).	successFlag ifTrue: [		arrayArgumentCount _ self fetchWordLengthOf: argumentArray.		"Note:	refusing to activate a block context that is already activated used				to be necessary when block contexts were reused during their				activations.  This restriction could easily be relaxed now that				they are copied for evaluation."		self success: (arrayArgumentCount = blockArgumentCount			and: [(self fetchPointer: CallerIndex ofObject: blockContext) = nilObj])].	successFlag ifTrue: [		oldSP _ self stackPointer.		newFrame _ oldSP + 4.					"first free location"		self pushRemappableOop: argumentArray.		self pushRemappableOop: blockContext.		newContext _ self allocateCachedContextAfter: activeCachedContext frame: newFrame.		blockContext _ self popRemappableOop.		argumentArray _ self popRemappableOop.		stackOverflow ifTrue: [			newFrame _ self cachedFramePointerAt: newContext.			stackOverflow _ false.		].		self inlineTransfer:	arrayArgumentCount			wordsFrom:		argumentArray + BaseHeaderSize			to:				newFrame.		self initializeCachedBlockContext: newContext fromClosure: blockContext.		self cachedStackPointerAt: newContext put: (newFrame + (blockArgumentCount * 4) - 4).		self cachedBlockArgumentCountAt: newContext put: (self integerObjectOf: blockArgumentCount)."		self fetchContextRegisters: newContext."	] ifFalse: [		self push: blockContext.		self push: argumentArray.	].! !!DynamicInterpreter methodsFor: 'processes'!addLastLink: proc toList: aList	"Add the given process to the given linked list and set the backpointer	of process to its new list."	| lastLink |	(self isEmptyList: aList) ifTrue: [		self storePointer: FirstLinkIndex ofObject: aList withValue: proc.	] ifFalse: [		lastLink _ self fetchPointer: LastLinkIndex ofObject: aList.		self storePointer: NextLinkIndex ofObject: lastLink withValue: proc.	].	self storePointer: LastLinkIndex ofObject: aList withValue: proc.	self storePointer: MyListIndex   ofObject:  proc withValue: aList.! !!DynamicInterpreter methodsFor: 'processes' stamp: 'ikp 9/29/97 20:49'!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now index externalObjects semaClass |	self inline: false.	now _ self ioMSecs.	now < lastTick ifTrue: [		"millisecond clock wrapped"		nextPollTick _ now + (nextPollTick - lastTick).		nextWakeupTick ~= 0			ifTrue: [nextWakeupTick _ now + (nextWakeupTick - lastTick)]].	lastTick _ now.  "used to detect millisecond clock wrapping"	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [^ self synchronousSignal: sema]].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500].  "msecs to wait before next call to ioProcessEvents"	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [^ self synchronousSignal: sema]].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [^ self synchronousSignal: sema]].	"signal all semaphores in semaphoresToSignal" 	semaphoresToSignalCount > 0 ifTrue: [		externalObjects _ self splObj: ExternalObjectsArray.		semaClass _ self splObj: ClassSemaphore.		1 to: semaphoresToSignalCount do: [:i |			index _ semaphoresToSignal at: i.			sema _ self fetchPointer: index - 1 ofObject: externalObjects.				"Note: semaphore indices are 1-based"			(self fetchClassOf: sema) = semaClass				ifTrue: [self synchronousSignal: sema]].		semaphoresToSignalCount _ 0].! !!DynamicInterpreter methodsFor: 'processes'!internalQuickCheckForInterrupts	"Internal version of quickCheckForInterrupts for use within jumps."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		interruptCheckCounter _ 1000.		self externalizeIPandSP.		self checkForInterrupts.		self internalizeIPandSP.	].! !!DynamicInterpreter methodsFor: 'processes'!isEmptyList: aLinkedList	^ (self fetchPointer: FirstLinkIndex ofObject: aLinkedList) = nilObj! !!DynamicInterpreter methodsFor: 'processes'!primitiveResume	| proc |	proc _ self stackTop.  "rcvr"	"self success: ((self fetchClassOf: proc) = (self splObj: ClassProcess))."	successFlag ifTrue: [ self resume: proc ].! !!DynamicInterpreter methodsFor: 'processes' stamp: 'ikp 8/18/97 11:11'!primitiveSignal	| sema |	sema _ self stackTop.  "rcvr"	self successIfClassOf: sema is: (self splObj: ClassSemaphore).	successFlag ifTrue: [ self synchronousSignal: sema ].! !!DynamicInterpreter methodsFor: 'processes'!primitiveSuspend	| activeProc |	activeProc _ self fetchPointer: ActiveProcessIndex						 ofObject: self schedulerPointer.	self success: self stackTop = activeProc.	successFlag ifTrue: [		self pop: 1.		self push: nilObj.		self transferTo: self wakeHighestPriority.	].! !!DynamicInterpreter methodsFor: 'processes' stamp: 'ikp 8/18/97 11:11'!primitiveWait	| sema excessSignals activeProc |	sema _ self stackTop.  "rcvr"	self successIfClassOf: sema is: (self splObj: ClassSemaphore).	successFlag ifTrue: [		excessSignals _			self fetchInteger: ExcessSignalsIndex ofObject: sema.		excessSignals > 0 ifTrue: [			self storeInteger: ExcessSignalsIndex				ofObject: sema withValue: excessSignals - 1.		] ifFalse: [			activeProc _ self fetchPointer: ActiveProcessIndex								 ofObject: self schedulerPointer.			self addLastLink: activeProc toList: sema.			self transferTo: self wakeHighestPriority.		].	].! !!DynamicInterpreter methodsFor: 'processes'!putToSleep: aProcess	"Save the given process on the scheduler process list for its priority."	| priority processLists processList |	priority _ self quickFetchInteger: PriorityIndex ofObject: aProcess.	processLists _ self fetchPointer: ProcessListsIndex ofObject: self schedulerPointer.	processList _ self fetchPointer: priority - 1 ofObject: processLists.	self addLastLink: aProcess toList: processList.! !!DynamicInterpreter methodsFor: 'processes'!quickCheckForInterrupts	"Quick check for possible user or timer interrupts. Decrement a counter and only do a real check when counter reaches zero or when a low space or user interrupt is pending."	"Note: Clients who set signalLowSpace or interruptPending should also set interruptCheckCounter to zero to get immediate results."	"Note: Requires that instructionPointer and stackPointer be external."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		interruptCheckCounter _ 1000.		self checkForInterrupts.	].! !!DynamicInterpreter methodsFor: 'processes'!removeFirstLinkOfList: aList	"Remove the first process from the given linked list."	| first last next |	first _ self fetchPointer: FirstLinkIndex ofObject: aList.	last  _ self fetchPointer: LastLinkIndex ofObject: aList.	first = last ifTrue: [		self storePointer: FirstLinkIndex ofObject: aList withValue: nilObj.		self storePointer:  LastLinkIndex ofObject: aList withValue: nilObj.	] ifFalse: [		next _ self fetchPointer: NextLinkIndex ofObject: first.		self storePointer: FirstLinkIndex ofObject: aList withValue: next.	].	self storePointer: NextLinkIndex ofObject: first withValue: nilObj.	^ first! !!DynamicInterpreter methodsFor: 'processes'!resume: aProcess	| activeProc activePriority newPriority |	self inline: false.	activeProc _ self fetchPointer: ActiveProcessIndex						 ofObject: self schedulerPointer.	activePriority _ self quickFetchInteger: PriorityIndex ofObject: activeProc.	newPriority   _ self quickFetchInteger: PriorityIndex ofObject: aProcess.	newPriority > activePriority ifTrue: [		self putToSleep: activeProc.		self transferTo: aProcess.	] ifFalse: [		self putToSleep: aProcess.	].! !!DynamicInterpreter methodsFor: 'processes'!schedulerPointer	^ self fetchPointer: ValueIndex		ofObject: (self splObj: SchedulerAssociation)! !!DynamicInterpreter methodsFor: 'processes' stamp: 'ikp 9/29/97 21:14'!signalSemaphoreWithIndex: index	"If it is not there already, record the given semaphore index in the list of semaphores to be signaled at the next convenient moment. Set the interruptCheckCounter to zero to force a real interrupt check as soon as possible."	index <= 0 ifTrue: [^ nil].  "bad index; ignore it"	interruptCheckCounter _ 0.	1 to: semaphoresToSignalCount do: [:i |		(semaphoresToSignal at: i) = index ifTrue: [^ nil]].	semaphoresToSignalCount < SemaphoresToSignalSize ifTrue: [		semaphoresToSignalCount _ semaphoresToSignalCount + 1.		semaphoresToSignal at: semaphoresToSignalCount put: index].! !!DynamicInterpreter methodsFor: 'processes'!synchronousSignal: aSemaphore	"Signal the given semaphore from within the interpreter."	| excessSignals |	self inline: false.	(self isEmptyList: aSemaphore) ifTrue: [		"no process is waiting on this semaphore"		excessSignals _			self fetchInteger: ExcessSignalsIndex ofObject: aSemaphore.		self storeInteger: ExcessSignalsIndex			ofObject: aSemaphore withValue: excessSignals + 1.	] ifFalse: [		self resume: (self removeFirstLinkOfList: aSemaphore).	].! !!DynamicInterpreter methodsFor: 'processes' stamp: 'ikp 8/26/97 01:02'!transferTo: newProcArg	"Record a process to be awoken on the next interpreter cycle.	Assumes: IP and SP are external."	| sched oldProc suspendedContext newProc |	self pushRemappableOop: newProcArg.	suspendedContext _ self flushCacheFrom: activeCachedContext.		"GC!!"	newProc _ self popRemappableOop.	self assertIsStableContext: suspendedContext.	self assertIsProcess: newProc.	sched _ self schedulerPointer.	oldProc _ self fetchPointer: ActiveProcessIndex ofObject: sched.	self storePointer: SuspendedContextIndex ofObject: oldProc withValue: suspendedContext.	self storePointer: ActiveProcessIndex      ofObject:   sched withValue: newProc.	suspendedContext _ self fetchPointer: SuspendedContextIndex ofObject: newProc.	self assertIsStableContext: suspendedContext.	self copyContextToCache: suspendedContext.	self fetchContextRegisters: activeCachedContext.! !!DynamicInterpreter methodsFor: 'processes'!wakeHighestPriority	"Return the highest priority process that is ready to run."	"Note: It is a fatal VM error if there is no runnable process."	| schedLists p processList |	schedLists _ self fetchPointer: ProcessListsIndex				ofObject: self schedulerPointer.	p _ self fetchWordLengthOf: schedLists.	p _ p - 1.  "index of last indexable field"	processList _ self fetchPointer: p ofObject: schedLists.	[self isEmptyList: processList] whileTrue: [		p _ p - 1.		p < 0 ifTrue: [ self error: 'scheduler could not find a runnable process' ].		processList _ self fetchPointer: p ofObject: schedLists.	].	^ self removeFirstLinkOfList: processList! !!DynamicInterpreter methodsFor: 'I/O primitives'!fullDisplayUpdate	"Repaint the entire smalltalk screen, ignoring the affected rectangle. Used when the Smalltalk window is brought to the front or uncovered."	| displayObj dispBits w h dispBitsIndex d |	displayObj _ self splObj: TheDisplay.	((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]) ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, 0, w, 0, h)'.	].! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveBeCursor	"Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk."	| cursorObj bitsObj extentX extentY offsetObj offsetX offsetY cursorBitsIndex |	cursorObj _ self stackTop.	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 5]).	successFlag ifTrue: [		bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		extentX _ self fetchInteger: 1 ofObject: cursorObj.		extentY _ self fetchInteger: 2 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj.		self success: ((self isPointers: offsetObj) and: [(self lengthOf: offsetObj) >= 2]).	].	successFlag ifTrue: [		offsetX _ self fetchInteger: 0 ofObject: offsetObj.		offsetY _ self fetchInteger: 1 ofObject: offsetObj.		self success: ((extentX = 16) and: [extentY = 16]).		self success: ((offsetX >= -16) and: [offsetX <= 0]).		self success: ((offsetY >= -16) and: [offsetY <= 0]).		self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).		cursorBitsIndex _ bitsObj + BaseHeaderSize.	].	successFlag ifTrue: [		self cCode: 'ioSetCursor(cursorBitsIndex, offsetX, offsetY)'.	].! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveBeDisplay	"Record the system Display object."	| rcvr |	rcvr _ self stackTop.	self success: ((self isPointers: rcvr) and: [(self lengthOf: rcvr) >= 4]).	successFlag ifTrue: [		"record the display object both in a variable and in the specialObjectsOop"		self storePointer: TheDisplay ofObject: specialObjectsOop withValue: rcvr.	].! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveBeep	self ioBeep.! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveCopyBits	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackTop.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self copyBits.		self showDisplayBits.	].! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveDrawLoop	"Invoke the line drawing primitive."	| rcvr xDelta yDelta |	rcvr _ self stackValue: 2.	xDelta _ self stackIntegerValue: 1.	yDelta _ self stackIntegerValue: 0.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self drawLoopX: xDelta Y: yDelta.		self showDisplayBits.		self pop: 2].! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveInputSemaphore	"Register the input semaphore. If the argument is not a Semaphore, unregister the current input semaphore."	| arg |	arg _ self popStack.	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [		self storePointer: TheInputSemaphore ofObject: specialObjectsOop withValue: arg.	] ifFalse: [		self storePointer: TheInputSemaphore ofObject: specialObjectsOop withValue: nilObj.	].! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveInputWord	"Return an integer indicating the reason for the most recent input interrupt."	self pop: 1.	self pushInteger: 0.	"noop for now"! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveInterruptSemaphore	"Register the user interrupt semaphore. If the argument is not a Semaphore, unregister the current interrupt semaphore."	| arg |	arg _ self popStack.	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [		self storePointer: TheInterruptSemaphore ofObject: specialObjectsOop withValue: arg.	] ifFalse: [		self storePointer: TheInterruptSemaphore ofObject: specialObjectsOop withValue: nilObj.	].! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveKbdNext	"Return the next keycode and remove it from the input buffer. The low byte is the 8-bit ISO character. The next four bits are the Smalltalk modifier bits <cmd><option><ctrl><shift>."	| keystrokeWord |	self pop: 1.	keystrokeWord _ self ioGetKeystroke.	keystrokeWord >= 0		ifTrue: [self pushInteger: keystrokeWord]		ifFalse: [self push: nilObj].! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveKbdPeek	"Return the next keycode and without removing it from the input buffer. The low byte is the 8-bit ISO character. The next four bits are the Smalltalk modifier bits <cmd><option><ctrl><shift>."	| keystrokeWord |	self pop: 1.	keystrokeWord _ self ioPeekKeystroke.	keystrokeWord >= 0		ifTrue: [self pushInteger: keystrokeWord]		ifFalse: [self push: nilObj].! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveMouseButtons	"Return the mouse button state. The low three bits encode the state of the <red><yellow><blue> mouse buttons. The next four bits encode the Smalltalk modifier bits <cmd><option><ctrl><shift>."	| buttonWord |	self pop: 1.	buttonWord _ self ioGetButtonState.	self pushInteger: buttonWord.! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveMousePoint	"Return a Point indicating current position of the mouse. Note that mouse coordinates may be negative if the mouse moves above or to the left of the top-left corner of the Smalltalk window."	| pointWord x y |	self pop: 1.	pointWord _ self ioMousePoint.	x _ self signExtend16: ((pointWord >> 16) bitAnd: 16rFFFF).	y _ self signExtend16: (pointWord bitAnd: 16rFFFF).	self push: (self makePointwithxValue: x  yValue: y).! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveScanCharacters	"Invoke the scanCharacters primitive."	| rcvr start stop string rightX stopArray displayFlag |	rcvr _ self stackValue: 6.	start _ self stackIntegerValue: 5.	stop _ self stackIntegerValue: 4.	string _ self stackValue: 3.	rightX _ self stackIntegerValue: 2.	stopArray _ self stackValue: 1.	displayFlag _ self booleanValueOf: (self stackValue: 0).	successFlag ifFalse: [^ nil].	self success: (self loadScannerFrom: rcvr					start: start stop: stop string: string rightX: rightX					stopArray: stopArray displayFlag: displayFlag).	successFlag		ifTrue: [self scanCharacters].	successFlag		ifTrue: [			displayFlag ifTrue: [self showDisplayBits].			self pop: 7.			self push: self stopReason].! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveScreenSize	"Return a point indicating the current size of the Smalltalk window."	| pointWord |	self pop: 1.	pointWord _ self ioScreenSize.	self push:		(self makePointwithxValue: ((pointWord >>16) bitAnd: 16rFFFF)						   yValue: (pointWord bitAnd: 16rFFFF)).! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveSetInterruptKey	"Set the user interrupt keycode. The keycode is an integer whose encoding is described in the comment for primitiveKbdNext."	| keycode |	keycode _ self popInteger.	successFlag		ifTrue: [ interruptKeycode _ keycode ]		ifFalse: [ self unPop: 1 ].! !!DynamicInterpreter methodsFor: 'I/O primitives'!primitiveWarpBits	"Invoke the warpBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackValue: self argCount.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self warpBits.		self showDisplayBits.	].! !!DynamicInterpreter methodsFor: 'I/O primitives'!showDisplayBits	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h affectedRectL affectedRectR affectedRectT affectedRectB dispBitsIndex d |	displayObj _ self splObj: TheDisplay.	self targetForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	successFlag ifTrue: [		affectedRectL _ self affectedLeft.		affectedRectR _ self affectedRight.		affectedRectT _ self affectedTop.		affectedRectB _ self affectedBottom.		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.	].! !!DynamicInterpreter methodsFor: 'file primitives'!asciiDirectoryDelimiter	^ self cCode: 'dir_Delimitor()'! !!DynamicInterpreter methodsFor: 'file primitives'!fileRecordSize	"Return the size of a Smalltalk file record in bytes."	^ self cCode: 'sizeof(SQFile)'.! !!DynamicInterpreter methodsFor: 'file primitives'!fileValueOf: objectPointer	"Return a pointer to the first byte of of the file record within the given Smalltalk object, or nil if objectPointer is not a file record."	| fileIndex |	self returnTypeC: 'SQFile *'.	self success:		((self isBytes: objectPointer) and:		 [(self lengthOf: objectPointer) = self fileRecordSize]).	successFlag ifTrue: [		fileIndex _ objectPointer + BaseHeaderSize.		^ self cCode: '(SQFile *) fileIndex'	] ifFalse:  [		^ nil	].! !!DynamicInterpreter methodsFor: 'file primitives'!makeDirEntryName: entryName size: entryNameSize	createDate: createDate modDate: modifiedDate	isDir: dirFlag fileSize: fileSize	| modDateOop createDateOop nameString results |	self var: 'entryName' declareC: 'char *entryName'.	"allocate storage for results, remapping newly allocated	 oops in case GC happens during allocation"	self pushRemappableOop:		(self instantiateClass: (self splObj: ClassArray) indexableSize: 5).	self pushRemappableOop:		(self instantiateClass: (self splObj: ClassString) indexableSize: entryNameSize)..	self pushRemappableOop: (self positive32BitIntegerFor: createDate).	self pushRemappableOop: (self positive32BitIntegerFor: modifiedDate).	modDateOop   _ self popRemappableOop.	createDateOop _ self popRemappableOop.	nameString    _ self popRemappableOop.	results         _ self popRemappableOop.	"copy name into Smalltalk string"	0 to: entryNameSize - 1 do: [ :i |		self storeByte: i ofObject: nameString withValue: (entryName at: i).	].	self storePointer: 0 ofObject: results withValue: nameString.	self storePointer: 1 ofObject: results withValue: createDateOop.	self storePointer: 2 ofObject: results withValue: modDateOop.	dirFlag		ifTrue: [ self storePointer: 3 ofObject: results withValue: trueObj ]		ifFalse: [ self storePointer: 3 ofObject: results withValue: falseObj ].	self storePointer: 4 ofObject: results		withValue: (self integerObjectOf: fileSize).	^ results! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveDirectoryCreate	| dirName dirNameIndex dirNameSize |	dirName _ self stackTop.	self success: (self isBytes: dirName).	successFlag ifTrue: [		dirNameIndex _ dirName + BaseHeaderSize.		dirNameSize _ self lengthOf: dirName.	].	successFlag ifTrue: [		self success:			(self cCode: 'dir_Create((char *) dirNameIndex, dirNameSize)').	].	successFlag ifTrue: [		self pop: 1.  "pop dirName; leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveDirectoryDelimitor	| ascii |	ascii _ self asciiDirectoryDelimiter.	self success: ((ascii >= 0) and: [ascii <= 255]).	successFlag ifTrue: [		self pop: 1.  "pop rcvr"		self push: (self fetchPointer: ascii ofObject: (self splObj: CharacterTable)).	].! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveDirectoryLookup	| index pathName pathNameIndex pathNameSize status entryName entryNameSize createDate modifiedDate dirFlag fileSize |	self var: 'entryName' declareC: 'char entryName[256]'.	index _ self stackIntegerValue: 0.	pathName _ self stackValue: 1.	self success: (self isBytes: pathName).	successFlag ifTrue: [		pathNameIndex _ pathName + BaseHeaderSize.		pathNameSize _ self lengthOf: pathName.	].	successFlag ifTrue: [		status _ self cCode:			'dir_Lookup(				(char *) pathNameIndex, pathNameSize, index,				entryName, &entryNameSize, &createDate, &modifiedDate,				&dirFlag, &fileSize)'.		status = DirNoMoreEntries ifTrue: [			"no more entries; return nil"			self pop: 3.  "pop pathName, index, rcvr"			self push: nilObj.			^ nil		].		status = DirBadPath ifTrue: [ ^ self primitiveFail ].  "bad path"	].	successFlag ifTrue: [		self pop: 3.  "pop pathName, index, rcvr"		self push:			(self makeDirEntryName: entryName size: entryNameSize				createDate: createDate modDate: modifiedDate				isDir: dirFlag fileSize: fileSize).	].! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveDirectorySetMacTypeAndCreator	| creatorString typeString fileName creatorStringIndex typeStringIndex fileNameIndex fileNameSize |	creatorString _ self stackTop.	typeString _ self stackValue: 1.	fileName _ self stackValue: 2.	self success: ((self isBytes: creatorString) and: [(self lengthOf: creatorString) = 4]).	self success: ((self isBytes: typeString) and: [(self lengthOf: typeString) = 4]).	self success: (self isBytes: fileName).	successFlag ifTrue: [		creatorStringIndex _ creatorString + BaseHeaderSize.		typeStringIndex _ typeString + BaseHeaderSize.		fileNameIndex _ fileName + BaseHeaderSize.		fileNameSize _ self lengthOf: fileName.	].	successFlag ifTrue: [		self success:			(self cCode: 'dir_SetMacFileTypeAndCreator(				(char *) fileNameIndex, fileNameSize,				(char *) typeStringIndex, (char *) creatorStringIndex)').	].	successFlag ifTrue: [		self pop: 3.  "pop filename, type, creator; leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveFileAtEnd	| file atEnd |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: self stackTop.	successFlag ifTrue: [ atEnd _ self sqFileAtEnd: file ].	successFlag ifTrue: [		self pop: 2.  "rcvr, file"		self pushBool: atEnd.	].! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveFileClose	| file |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: self stackTop.	successFlag ifTrue: [ self sqFileClose: file ].	successFlag ifTrue: [ self pop: 1  "pop file; leave rcvr on stack" ].! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveFileDelete	| namePointer nameIndex nameSize |	namePointer _ self stackTop.	self success: (self isBytes: namePointer).	successFlag ifTrue: [		nameIndex _ namePointer + BaseHeaderSize.		nameSize _ self lengthOf: namePointer.	].	successFlag ifTrue: [		self sqFileDeleteName: nameIndex Size: nameSize.	].	successFlag ifTrue: [ self pop: 1. "pop name, leave rcvr on stack" ].! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveFileGetPosition	| file position |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: (self stackTop).	successFlag ifTrue: [ position _ self sqFileGetPosition: file ].	successFlag ifTrue: [		self pop: 2.  "rcvr, file"		self pushInteger: position.	].! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveFileOpen	| writeFlag namePointer filePointer file nameIndex nameSize |	self var: 'file' declareC: 'SQFile *file'.	writeFlag _ self booleanValueOf: (self stackTop).	namePointer _ self stackValue: 1.	self success: (self isBytes: namePointer).	successFlag ifTrue: [		filePointer _ self instantiateClass: (self splObj: ClassByteArray)						   indexableSize: self fileRecordSize.		file _ self fileValueOf: filePointer.		nameIndex _ namePointer + BaseHeaderSize.		nameSize _ self lengthOf: namePointer.	].	successFlag ifTrue: [		self cCode: 'sqFileOpen(file, nameIndex, nameSize, writeFlag)'.	].	successFlag ifTrue: [		self pop: 3.  "rcvr, name, writeFlag"		self push: filePointer.	].! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveFileRead	| count startIndex array file byteSize arrayIndex bytesRead |	self var: 'file' declareC: 'SQFile *file'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	file			_ self fileValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [ byteSize _ 4 ]		ifFalse: [ byteSize _ 1 ].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= (self lengthOf: array)]).	successFlag ifTrue: [		arrayIndex _ array + BaseHeaderSize.		"Note: adjust startIndex for zero-origin indexing"		bytesRead _ self sqFile: file Read: (count * byteSize)						 Into: arrayIndex						   At: ((startIndex - 1) * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, file, array, startIndex, count"		self pushInteger: bytesRead // byteSize.  "push # of elements read"	].! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveFileRename	| oldNamePointer newNamePointer oldNameIndex oldNameSize newNameIndex newNameSize |	newNamePointer _ self stackTop.	oldNamePointer _ self stackValue: 1.	self success: (self isBytes: newNamePointer).	self success: (self isBytes: oldNamePointer).	successFlag ifTrue: [		newNameIndex _ newNamePointer + BaseHeaderSize.		newNameSize _ self lengthOf: newNamePointer.		oldNameIndex _ oldNamePointer + BaseHeaderSize.		oldNameSize _ self lengthOf: oldNamePointer.	].	successFlag ifTrue: [		self sqFileRenameOld: oldNameIndex Size: oldNameSize New: newNameIndex Size: newNameSize.	].	successFlag ifTrue: [		self pop: 2.  "pop new and old names, leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveFileSetPosition	| newPosition file |	self var: 'file' declareC: 'SQFile *file'.	newPosition _ self stackIntegerValue: 0.	file _ self fileValueOf: (self stackValue: 1).	successFlag ifTrue: [ self sqFile: file SetPosition: newPosition ].	successFlag ifTrue: [ self pop: 2 "pop position, file; leave rcvr on stack" ].! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveFileSize	| file size |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: (self stackTop).	successFlag ifTrue: [ size _ self sqFileSize: file ].	successFlag ifTrue: [		self pop: 2.  "rcvr, file"		self pushInteger: size.	].! !!DynamicInterpreter methodsFor: 'file primitives'!primitiveFileWrite	| count startIndex array file byteSize arrayIndex bytesWritten |	self var: 'file' declareC: 'SQFile *file'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	file			_ self fileValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [ byteSize _ 4 ]		ifFalse: [ byteSize _ 1 ].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= (self lengthOf: array)]).	successFlag ifTrue: [		arrayIndex _ array + BaseHeaderSize.		"Note: adjust startIndex for zero-origin indexing"		bytesWritten _			self sqFile: file				Write: (count * byteSize)				From: arrayIndex At: ((startIndex - 1) * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, file, array, startIndex, count"		self pushInteger: bytesWritten // byteSize.  "push # of elements written"	].! !!DynamicInterpreter methodsFor: 'memory space primitives'!primitiveBytesLeft	"Reports bytes available at this moment. For more meaningful results, calls to this primitive should be preceeded by a full or incremental garbage collection."	self pop: 1.	self pushInteger: (self sizeOfFree: freeBlock).! !!DynamicInterpreter methodsFor: 'memory space primitives'!primitiveFullGC	"Do a quick, incremental garbage collection and return the number of bytes available."	self pop: 1.	self incrementalGC.  "maximimize space for forwarding table"	self fullGC.	self pushInteger: (self sizeOfFree: freeBlock).! !!DynamicInterpreter methodsFor: 'memory space primitives'!primitiveIncrementalGC	"Do a quick, incremental garbage collection and return the number of bytes immediately available. (Note: more space may be made available by doing a full garbage collection."	self pop: 1.	self incrementalGC.	self pushInteger: (self sizeOfFree: freeBlock).! !!DynamicInterpreter methodsFor: 'memory space primitives'!primitiveLowSpaceSemaphore	"Register the low-space semaphore. If the argument is not a Semaphore, unregister the current low-space Semaphore."	| arg |	arg _ self popStack.	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [		self storePointer: TheLowSpaceSemaphore ofObject: specialObjectsOop withValue: arg.	] ifFalse: [		self storePointer: TheLowSpaceSemaphore ofObject: specialObjectsOop withValue: nilObj.	].! !!DynamicInterpreter methodsFor: 'memory space primitives'!primitiveSignalAtBytesLeft	"Set the low-water mark for free space. When the free space falls below this level, the new and new: primitives fail and system attempts to allocate space (e.g., to create a method context) cause the low-space semaphore (if one is registered) to be signalled."	| bytes |	bytes _ self popInteger.	successFlag		ifTrue: [ lowSpaceThreshold _ bytes ]		ifFalse: [			lowSpaceThreshold _ 0.			self unPop: 1.		].! !!DynamicInterpreter methodsFor: 'socket primitives' stamp: 'ikp 9/29/97 21:00'!primitiveInitializeNetwork	| resolverSemaIndex err |	resolverSemaIndex _ self stackIntegerValue: 0.	successFlag ifTrue: [		err _ self sqNetworkInit: resolverSemaIndex.		self success: err = 0.	].	successFlag ifTrue: [		self pop: 1.  "pop resolverSemaIndex, leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'socket primitives'!primitiveSocketAbortConnection	| s |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		self sqSocketAbortConnection: s.	].	successFlag ifTrue: [		self pop: 1.  "pop s; leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'socket primitives'!primitiveSocketCloseConnection	| s |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		self sqSocketCloseConnection: s.	].	successFlag ifTrue: [		self pop: 1.  "pop s; leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'socket primitives'!primitiveSocketConnectionStatus	| s status |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		status _ self sqSocketConnectionStatus: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self integerObjectOf: status).	].! !!DynamicInterpreter methodsFor: 'socket primitives' stamp: 'ikp 9/29/97 21:09'!primitiveSocketConnectToPort	| port addr s |	self var: #s declareC: 'SocketPtr s'.	port _ self stackIntegerValue: 0.	addr _ self netAddressToInt: (self stackValue: 1).	s _ self socketValueOf: (self stackValue: 2).	successFlag ifTrue: [		self sqSocket: s ConnectTo: addr Port: port.	].	successFlag ifTrue: [		self pop: 3.  "pop s, addr, port; leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'socket primitives' stamp: 'ikp 9/29/97 21:10'!primitiveSocketCreate	| semaIndex sendBufSize recvBufSize socketType netType socketOop s |	self var: #s declareC: 'SocketPtr s'.	semaIndex	_ self stackIntegerValue: 0.	sendBufSize	_ self stackIntegerValue: 1.	recvBufSize	_ self stackIntegerValue: 2.	socketType	_ self stackIntegerValue: 3.	netType		_ self stackIntegerValue: 4.	successFlag ifTrue: [		socketOop _ self instantiateClass: (self splObj: ClassByteArray)						indexableSize: self socketRecordSize.		s _ self socketValueOf: socketOop.		self sqSocket: s CreateNetType: netType SocketType: socketType			RecvBytes: recvBufSize SendBytes: sendBufSize SemaID: semaIndex.		successFlag ifTrue: [			self pop: 6  "netType, socketType, recvBufSize, sendBufSize, semaIndex, rcvr"				thenPush: socketOop.		].	].! !!DynamicInterpreter methodsFor: 'socket primitives'!primitiveSocketDestroy	| s |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		self sqSocketDestroy: s.	].	successFlag ifTrue: [		self pop: 1.  "pop s; leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'socket primitives'!primitiveSocketError	| s err |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		err _ self sqSocketError: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self integerObjectOf: err).	].! !!DynamicInterpreter methodsFor: 'socket primitives' stamp: 'ikp 9/29/97 21:10'!primitiveSocketListenOnPort	| port s |	self var: #s declareC: 'SocketPtr s'.	port _ self stackIntegerValue: 0.	s _ self socketValueOf: (self stackValue: 1).	successFlag ifTrue: [		self sqSocket: s ListenOnPort: port.	].	successFlag ifTrue: [		self pop: 2.  "pop s, port; leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'socket primitives'!primitiveSocketLocalAddress	| s addr |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		addr _ self sqSocketLocalAddress: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self intToNetAddress: addr).	].! !!DynamicInterpreter methodsFor: 'socket primitives'!primitiveSocketLocalPort	| s port |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		port _ self sqSocketLocalPort: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self integerObjectOf: port).	].! !!DynamicInterpreter methodsFor: 'socket primitives'!primitiveSocketReceiveDataAvailable	| s dataIsAvailable |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		dataIsAvailable _ self sqSocketReceiveDataAvailable: s.	].	successFlag ifTrue: [		self pop: 2.  "pop s, rcvr"		self pushBool: dataIsAvailable.	].! !!DynamicInterpreter methodsFor: 'socket primitives'!primitiveSocketReceiveDataBufCount	| count startIndex array s byteSize arrayBase bufStart bytesReceived |	self var: #s declareC: 'SocketPtr s'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	s			_ self socketValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [byteSize _ 4]		ifFalse: [byteSize _ 1].	self success: (		(startIndex >= 1) and:		[(count >= 0) and:		[(startIndex + count - 1) <= (self lengthOf: array)]]).	successFlag ifTrue: [		"Note: adjust bufStart for zero-origin indexing"		arrayBase _ array + BaseHeaderSize.		bufStart _ arrayBase + ((startIndex - 1) * byteSize).		bytesReceived _			self sqSocket: s				ReceiveDataBuf: bufStart				Count: (count * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, s, array, startIndex, count"		self pushInteger: bytesReceived // byteSize.  "push # of elements"	].! !!DynamicInterpreter methodsFor: 'socket primitives'!primitiveSocketRemoteAddress	| s addr |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		addr _ self sqSocketRemoteAddress: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self intToNetAddress: addr).	].! !!DynamicInterpreter methodsFor: 'socket primitives'!primitiveSocketRemotePort	| s port |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		port _ self sqSocketRemotePort: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self integerObjectOf: port).	].! !!DynamicInterpreter methodsFor: 'socket primitives'!primitiveSocketSendDataBufCount	| count startIndex array s byteSize arrayBase bufStart bytesSent |	self var: #s declareC: 'SocketPtr s'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	s			_ self socketValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [byteSize _ 4]		ifFalse: [byteSize _ 1].	self success: (		(startIndex >= 1) and:		[(count >= 0) and:		[(startIndex + count - 1) <= (self lengthOf: array)]]).	successFlag ifTrue: [		"Note: adjust bufStart for zero-origin indexing"		arrayBase _ array + BaseHeaderSize.		bufStart _ arrayBase + ((startIndex - 1) * byteSize).		bytesSent _			self sqSocket: s				SendDataBuf: bufStart				Count: (count * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, s, array, startIndex, count"		self pushInteger: bytesSent // byteSize.  "push # of elements"	].! !!DynamicInterpreter methodsFor: 'socket primitives'!primitiveSocketSendDone	| s done |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		done _ self sqSocketSendDone: s.	].	successFlag ifTrue: [		self pop: 2.  "pop s, rcvr"		self pushBool: done.	].! !!DynamicInterpreter methodsFor: 'socket primitives'!socketRecordSize	"Return the size of a Smalltalk socket record in bytes."	^ self cCode: 'sizeof(SQSocket)'.! !!DynamicInterpreter methodsFor: 'socket primitives'!socketValueOf: socketOop	"Return a pointer to the first byte of of the socket record within the given Smalltalk object, or nil if socketOop is not a socket record."	| socketIndex |	self returnTypeC: 'SQSocket *'.	self success:		((self isBytes: socketOop) and:		 [(self lengthOf: socketOop) = self socketRecordSize]).	successFlag ifTrue: [		socketIndex _ socketOop + BaseHeaderSize.		^ self cCode: '(SQSocket *) socketIndex'	] ifFalse:  [		^ nil	].! !!DynamicInterpreter methodsFor: 'resolver primitives'!intToNetAddress: addr	"Convert the given 32-bit integer into an internet network address represented as a four-byte ByteArray."	| netAddressOop |	netAddressOop _		self instantiateSmallClass: (self splObj: ClassByteArray)			sizeInBytes: 8			fill: 0.	self storeByte: 0 ofObject: netAddressOop		withValue: ((addr >> 24) bitAnd: 16rFF).	self storeByte: 1 ofObject: netAddressOop		withValue: ((addr >> 16) bitAnd: 16rFF).	self storeByte: 2 ofObject: netAddressOop		withValue: ((addr >> 8) bitAnd: 16rFF).	self storeByte: 3 ofObject: netAddressOop		withValue: (addr bitAnd: 16rFF).	^ netAddressOop! !!DynamicInterpreter methodsFor: 'resolver primitives' stamp: 'ikp 8/18/97 11:11'!netAddressToInt: oop	"Convert the given internet network address (represented as a four-byte ByteArray) into a 32-bit integer. Fail if the given oop is not a four-byte ByteArray."	| sz |	self successIfClassOf: oop is: (self splObj: ClassByteArray).	successFlag ifTrue: [		sz _ self lengthOf: oop.		sz = 4 ifFalse: [^ self primitiveFail]].	successFlag ifTrue: [		^ (self fetchByte: 3 ofObject: oop) +		  ((self fetchByte: 2 ofObject: oop) << 8) +		  ((self fetchByte: 1 ofObject: oop) << 16) +		  ((self fetchByte: 0 ofObject: oop) << 24) ].! !!DynamicInterpreter methodsFor: 'resolver primitives'!primitiveResolverAbortLookup	self sqResolverAbort.! !!DynamicInterpreter methodsFor: 'resolver primitives'!primitiveResolverAddressLookupResult	| sz s |	sz _ self sqResolverAddrLookupResultSize.	successFlag ifTrue: [		s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.		self sqResolverAddrLookup: (self cCoerce: (s + BaseHeaderSize) to: 'char *')			Result: sz.	].	successFlag ifTrue: [		self pop: 1 thenPush: s.	].! !!DynamicInterpreter methodsFor: 'resolver primitives'!primitiveResolverError	| err |	err _ self sqResolverError.	successFlag ifTrue: [		self pop: 1 thenPush: (self integerObjectOf: err).	].! !!DynamicInterpreter methodsFor: 'resolver primitives'!primitiveResolverLocalAddress	| addr |	addr _ self sqResolverLocalAddress.	successFlag ifTrue: [		self pop: 1 thenPush: (self intToNetAddress: addr).	].! !!DynamicInterpreter methodsFor: 'resolver primitives'!primitiveResolverNameLookupResult	| addr |	addr _ self sqResolverNameLookupResult.	successFlag ifTrue: [		self pop: 1 thenPush: (self intToNetAddress: addr).	].! !!DynamicInterpreter methodsFor: 'resolver primitives'!primitiveResolverStartAddressLookup	| addr |	addr _ self netAddressToInt: self stackTop.	successFlag ifTrue: [		self sqResolverStartAddrLookup: addr.	].	successFlag ifTrue: [		self pop: 1.  "pop addr, leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'resolver primitives' stamp: 'ikp 8/18/97 11:11'!primitiveResolverStartNameLookup	| name sz |	name _ self stackTop.	self successIfClassOf: name is: (self splObj: ClassString).	successFlag ifTrue: [		sz _ self lengthOf: name.		self sqResolverStartName: (self cCoerce: (name + BaseHeaderSize) to: 'char *')			Lookup: sz.	].	successFlag ifTrue: [		self pop: 1.  "pop name, leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'resolver primitives'!primitiveResolverStatus	| status |	status _ self sqResolverStatus.	successFlag ifTrue: [		self pop: 1 thenPush: (self integerObjectOf: status).	].! !!DynamicInterpreter methodsFor: 'sound primitives' stamp: 'di 6/7/97 09:59'!primitiveConstantFill	"Fill the receiver, which must be an indexable bytes or words objects, with the given integer value."	| fillValue rcvr rcvrIsBytes end i |	fillValue _ self positive32BitValueOf: self stackTop. 	rcvr _ self stackValue: 1.	self success: (self isWordsOrBytes: rcvr).	rcvrIsBytes _ self isBytes: rcvr.	rcvrIsBytes ifTrue: [		self success: ((fillValue >= 0) and: [fillValue <= 255]).	].	successFlag ifTrue: [		end _ rcvr + (self sizeBitsOf: rcvr).		i _ rcvr + BaseHeaderSize.		rcvrIsBytes ifTrue: [			[i < end] whileTrue: [				self byteAt: i put: fillValue.				i _ i + 1.			].		] ifFalse: [			[i < end] whileTrue: [				self longAt: i put: fillValue.				i _ i + 4.			].		].		self pop: 1.  "pop fillValue; leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'sound primitives'!primitiveShortAt	"Treat the receiver, which can be indexible by either bytes or words, as an array of signed 16-bit values. Return the contents of the given index. Note that the index specifies the i-th 16-bit entry, not the i-th byte or word."	| index rcvr sz addr value |	index _ self stackIntegerValue: 0.	rcvr _ self stackValue: 1.	self success: ((self isIntegerObject: rcvr) not and: [self isWordsOrBytes: rcvr]).	successFlag ifFalse: [ ^ nil ].	sz _ ((self sizeBitsOf: rcvr) - BaseHeaderSize) // 2.  "number of 16-bit fields"	self success: ((index >= 1) and: [index <= sz]).	successFlag ifTrue: [		addr _ rcvr + BaseHeaderSize + (2 * (index - 1)).		value _ self cCode: '*((short int *) addr)'.		self pop: 2.  "pop rcvr, index"		self pushInteger: value.  "push element value"	].! !!DynamicInterpreter methodsFor: 'sound primitives'!primitiveShortAtPut	"Treat the receiver, which can be indexible by either bytes or words, as an array of signed 16-bit values. Set the contents of the given index to the given value. Note that the index specifies the i-th 16-bit entry, not the i-th byte or word."	| index rcvr sz addr value |	value _ self stackIntegerValue: 0.	index _ self stackIntegerValue: 1.	rcvr _ self stackValue: 2.	self success: ((self isIntegerObject: rcvr) not and: [self isWordsOrBytes: rcvr]).	successFlag ifFalse: [ ^ nil ].	sz _ ((self sizeBitsOf: rcvr) - BaseHeaderSize) // 2.  "number of 16-bit fields"	self success: ((index >= 1) and: [index <= sz]).	self success: ((value >= -32768) and: [value <= 32767]).	successFlag ifTrue: [		addr _ rcvr + BaseHeaderSize + (2 * (index - 1)).		self cCode: '*((short int *) addr) = value'.		self pop: 2.  "pop index and value; leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'sound primitives'!primitiveSoundAvailableSpace	"Returns the number of sample frames of available sound output buffer space."	| frames |	frames _ self cCode: 'snd_AvailableSpace()'.  "-1 if sound output not started"	self success: frames >= 0.	successFlag ifTrue: [		self pop: 1.  "rcvr"		self push: (self positive32BitIntegerFor: frames).	].! !!DynamicInterpreter methodsFor: 'sound primitives' stamp: 'ikp 9/29/97 21:11'!primitiveSoundGetRecordingSampleRate	"Return a float representing the actual sampling rate during recording. Fail if not currently recording."	| rate |	self var: #rate declareC: 'double rate'.	rate _ self cCode: 'snd_GetRecordingSampleRate()'.  "fail if not recording"	successFlag ifTrue: [		self pop: 1.  "rcvr"		self pushFloat: rate.	].! !!DynamicInterpreter methodsFor: 'sound primitives' stamp: 'ikp 9/29/97 21:11'!primitiveSoundInsertSamples	"Insert a buffer's worth of sound samples into the currently playing buffer. Used to make a sound start playing as quickly as possible. The new sound is mixed with the previously buffered sampled."	"Details: Unlike primitiveSoundPlaySamples, this primitive always starts with the first sample the given sample buffer. Its third argument specifies the number of samples past the estimated sound output buffer position the inserted sound should start. If successful, it returns the number of samples inserted."	| leadTime buf frameCount framesPlayed |	leadTime _ self stackIntegerValue: 0.	buf _ self stackValue: 1.	frameCount _ self stackIntegerValue: 2.	self success: (self isWords: buf).	self success: (frameCount <= (self lengthOf: buf)).	successFlag ifTrue: [		framesPlayed _			self cCode: 'snd_InsertSamplesFromLeadTime(frameCount, buf + 4, leadTime)'.		self success: framesPlayed >= 0].	successFlag ifTrue: [		self pop: 4.  "pop frameCount, buf, leadTime, rcvr"		self push: (self positive32BitIntegerFor: framesPlayed)].! !!DynamicInterpreter methodsFor: 'sound primitives'!primitiveSoundPlaySamples	"Output a buffer's worth of sound samples."	| startIndex buf frameCount framesPlayed |	startIndex _ self stackIntegerValue: 0.	buf _ self stackValue: 1.	frameCount _ self stackIntegerValue: 2.	self success: (self isWords: buf).	self success: (		(startIndex >= 1) and:		[(startIndex + frameCount - 1) <= (self lengthOf: buf)]).	successFlag ifTrue: [		framesPlayed _			self cCode: 'snd_PlaySamplesFromAtLength(frameCount, buf + 4, startIndex - 1)'.		self success: framesPlayed >= 0.	].	successFlag ifTrue: [		self pop: 4.  "pop frameCount, buf, startIndex, rcvr"		self push: (self positive32BitIntegerFor: framesPlayed).	].! !!DynamicInterpreter methodsFor: 'sound primitives'!primitiveSoundPlaySilence	"Output a buffer's worth of silence. Returns the number of sample frames played."	| framesPlayed |	framesPlayed _ self cCode: 'snd_PlaySilence()'.  "-1 if sound output not started"	self success: framesPlayed >= 0.	successFlag ifTrue: [		self pop: 1.  "rcvr"		self push: (self positive32BitIntegerFor: framesPlayed).	].! !!DynamicInterpreter methodsFor: 'sound primitives' stamp: 'ikp 9/29/97 21:11'!primitiveSoundRecordSamples	"Record a buffer's worth of 16-bit sound samples."	| startWordIndex buf bufSizeInBytes samplesRecorded |	startWordIndex _ self stackIntegerValue: 0.	buf _ self stackValue: 1.	self success: (self isWords: buf).	successFlag ifTrue: [		bufSizeInBytes _ (self lengthOf: buf) * 4.		self success: ((startWordIndex >= 1) and: [((startWordIndex - 1) * 2) < bufSizeInBytes]).	].	successFlag ifTrue: [		samplesRecorded _			self cCode: 'snd_RecordSamplesIntoAtLength(buf + 4, startWordIndex - 1, bufSizeInBytes)'.	].	successFlag ifTrue: [		self pop: 3.  "pop rcvr, startWordIndex, buf"		self push: (self integerObjectOf: samplesRecorded).	].! !!DynamicInterpreter methodsFor: 'sound primitives' stamp: 'ikp 9/29/97 21:11'!primitiveSoundSetRecordLevel	"Set the sound input recording level."	| level |	level _ self stackIntegerValue: 0.	successFlag ifTrue: [		self cCode: 'snd_SetRecordLevel(level)'.	].	successFlag ifTrue: [		self pop: 1.  "pop level; leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'sound primitives' stamp: 'ikp 9/29/97 21:12'!primitiveSoundStart	"Start the double-buffered sound output with the given buffer size, sample rate, and stereo flag."	| stereoFlag samplesPerSec bufFrames |	stereoFlag		_ self booleanValueOf: (self stackValue: 0).	samplesPerSec	_ self stackIntegerValue: 1.	bufFrames		_ self stackIntegerValue: 2.	successFlag ifTrue: [		self success: (self cCode: 'snd_Start(bufFrames, samplesPerSec, stereoFlag, 0)').	].	successFlag ifTrue: [		self pop: 3.  "pop bufFrames, samplesPerSec, stereoFlag; leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'sound primitives' stamp: 'ikp 9/29/97 21:12'!primitiveSoundStartRecording	"Start recording sound with the given parameters."	| semaIndex stereoFlag desiredSamplesPerSec |	semaIndex				_ self stackIntegerValue: 0.	stereoFlag				_ self booleanValueOf: (self stackValue: 1).	desiredSamplesPerSec	_ self stackIntegerValue: 2.	successFlag ifTrue: [		self cCode: 'snd_StartRecording(desiredSamplesPerSec, stereoFlag, semaIndex)'.	].	successFlag ifTrue: [		self pop: 3.  "pop desiredSamplesPerSec, stereoFlag, and semaIndex; leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'sound primitives' stamp: 'ikp 9/29/97 21:12'!primitiveSoundStartWithSemaphore	"Start the double-buffered sound output with the given buffer size, sample rate, stereo flag, and semaphore index."	| semaIndex stereoFlag samplesPerSec bufFrames |	semaIndex		_ self stackIntegerValue: 0.	stereoFlag		_ self booleanValueOf: (self stackValue: 1).	samplesPerSec	_ self stackIntegerValue: 2.	bufFrames		_ self stackIntegerValue: 3.	successFlag ifTrue: [		self success: (self cCode: 'snd_Start(bufFrames, samplesPerSec, stereoFlag, semaIndex)').	].	successFlag ifTrue: [		self pop: 4.  "pop bufFrames, samplesPerSec, stereoFlag, semaIndex; leave rcvr on stack"	].! !!DynamicInterpreter methodsFor: 'sound primitives'!primitiveSoundStop	"Stop double-buffered sound output."	self cCode: 'snd_Stop()'.  "leave rcvr on stack"	! !!DynamicInterpreter methodsFor: 'sound primitives' stamp: 'ikp 9/29/97 21:12'!primitiveSoundStopRecording	"Stop recording sound."	self cCode: 'snd_StopRecording()'.  "leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'other primitives' stamp: 'ikp 8/18/97 11:11'!primitiveClipboardText	"When called with a single string argument, post the string to the clipboard. When called with zero arguments, return a string containing the current clipboard contents."	| s sz |	argumentCount = 1 ifTrue: [		s _ self stackTop.		self successIfClassOf: s is: (self splObj: ClassString).		successFlag ifTrue: [			sz _ self stSizeOf: s.			self clipboardWrite: sz From: (s + BaseHeaderSize) At: 0.			self pop: 1.  "pop s, leave rcvr on stack"		].	] ifFalse: [		sz _ self clipboardSize.		s _ self instantiateClass: (self splObj: ClassString)					  indexableSize: sz.		self clipboardRead: sz Into: (s + BaseHeaderSize) At: 0.		self pop: 1.  "rcvr"		self push: s.	].! !!DynamicInterpreter methodsFor: 'other primitives'!primitiveExitToDebugger	self error: 'Exit to debugger at user request'.! !!DynamicInterpreter methodsFor: 'other primitives' stamp: 'ikp 1/1/98 23:47'!primitiveFlushCache	"Clear the method lookup cache. This must be done after every programming change."	self flushMethodCache.	self flushInlineCache! !!DynamicInterpreter methodsFor: 'other primitives' stamp: 'ikp 1/5/98 00:46'!primitiveFlushCacheSelective	"The receiver is a message selector.  Clear all entries in the method lookup cache with this selector, presumably because an associated method has been redefined."	| selector |	selector _ self stackTop.	self flushMethodCacheSelective: selector.! !!DynamicInterpreter methodsFor: 'other primitives' stamp: 'ikp 1/2/98 15:00'!primitiveForceDisplayUpdate	"On some platforms, this primitive forces enqueued display updates to be processed immediately. On others, it does nothing."	self ioForceDisplayUpdate.! !!DynamicInterpreter methodsFor: 'other primitives' stamp: 'ikp 1/2/98 14:59'!primitiveFormPrint	"On platforms that support it, this primitive prints the receiver, assumed to be a Form, to the default printer."	| landscapeFlag vScale hScale rcvr bitsArray w h	 depth pixelsPerWord wordsPerLine bitsArraySize ok |	self var: #vScale declareC: 'double vScale'.	self var: #hScale declareC: 'double hScale'.	landscapeFlag _ self booleanValueOf: self stackTop.	vScale _ self floatValueOf: (self stackValue: 1).	hScale _ self floatValueOf: (self stackValue: 2).	rcvr _ self stackValue: 3.	(rcvr isIntegerObject: rcvr) ifTrue: [self success: false].	successFlag ifTrue: [		((self  isPointers: rcvr) and: [(self lengthOf: rcvr) >= 4])			ifFalse: [self success: false]].	successFlag ifTrue: [		bitsArray _ self fetchPointer: 0 ofObject: rcvr.		w _ self fetchInteger: 1 ofObject: rcvr.		h _ self fetchInteger: 2 ofObject: rcvr.		depth _ self fetchInteger: 3 ofObject: rcvr.		(w > 0 and: [h > 0]) ifFalse: [self success: false].		pixelsPerWord _ 32 // depth.		wordsPerLine _ (w + (pixelsPerWord - 1)) // pixelsPerWord.		((rcvr isIntegerObject: rcvr) not and: [self isWordsOrBytes: bitsArray])			ifTrue: [				bitsArraySize _ self byteLengthOf: bitsArray.				self success: (bitsArraySize = (wordsPerLine * h * 4))]			ifFalse: [self success: false]].		successFlag ifTrue: [		ok _ self cCode:			'ioFormPrint(bitsArray + 4, w, h, depth, hScale, vScale, landscapeFlag)'.		self success: ok].	successFlag ifTrue: [		self pop: 3].  "pop hScale, vScale, and landscapeFlag; leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'other primitives' stamp: 'ikp 9/29/97 20:57'!primitiveGetAttribute	"Fetch the system attribute with the given integer ID. The result is a string, which will be empty if the attribute is not defined."	| attr sz s |	attr _ self stackIntegerValue: 0.	successFlag ifTrue: [		sz _ self attributeSize: attr.		s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.		self getAttribute: attr Into: (s + BaseHeaderSize) Length: sz.		self pop: 2.  "rcvr, attr"		self push: s].! !!DynamicInterpreter methodsFor: 'other primitives' stamp: 'ikp 8/18/97 11:11'!primitiveImageName	"When called with a single string argument, record the string as the current image file name. When called with zero arguments, return a string containing the current image file name."	| s sz |	argumentCount = 1 ifTrue: [		s _ self stackTop.		self successIfClassOf: s is: (self splObj: ClassString).		successFlag ifTrue: [			sz _ self stSizeOf: s.			self imageNamePut: (s + BaseHeaderSize) Length: sz.			self pop: 1.  "pop s, leave rcvr on stack"		].	] ifFalse: [		sz _ self imageNameSize.		s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.		self imageNameGet: (s + BaseHeaderSize) Length: sz.		self pop: 1.  "rcvr"		self push: s.	].! !!DynamicInterpreter methodsFor: 'other primitives' stamp: 'ikp 9/29/97 21:03'!primitiveMillisecondClock	"Return the value of the millisecond clock as an integer. Note that the millisecond clock wraps around periodically. On some platforms it can wrap daily. The range is limited to SmallInteger maxVal / 2 to allow delays of up to that length without overflowing a SmallInteger."	self pop: 1.  "pop rcvr"	self push: (self integerObjectOf: (self ioMSecs bitAnd: 16r1FFFFFFF)).! !!DynamicInterpreter methodsFor: 'other primitives'!primitiveNoop	"A placeholder for primitives that haven't been implemented or are being withdrawn gradually. Just absorbs any arguments and returns the receiver."	self pop: argumentCount.  "pop args, leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'other primitives'!primitiveQuit	self ioExit.! !!DynamicInterpreter methodsFor: 'other primitives'!primitiveReadJoystick	"Read an input word from the joystick with the given index."	| index |	index _ self stackIntegerValue: 0.	successFlag ifTrue: [		self pop: 2.  "index, rcvr"		self push: (self positive32BitIntegerFor: (self joystickRead: index)).	].! !!DynamicInterpreter methodsFor: 'other primitives' stamp: 'ikp 9/29/97 21:05'!primitiveRelinquishProcessor	"Relinquish the processor for up to the given number of microseconds. The exact behavior of this primitive is platform dependent."	| microSecs |	microSecs _ self stackIntegerValue: 0.	successFlag ifTrue: [		self ioRelinquishProcessorForMicroseconds: microSecs.		self pop: 1].  "microSecs; leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'other primitives'!primitiveSecondsClock	"Return the number of seconds since January 1, 1901 as an integer."	self pop: 1.  "pop rcvr"	self push: (self positive32BitIntegerFor: self ioSeconds).! !!DynamicInterpreter methodsFor: 'other primitives'!primitiveSignalAtMilliseconds	"Cause the time semaphore, if one has been registered, to be signalled when the millisecond clock is greater than or equal to the given tick value. A tick value of zero turns off timer interrupts."	| tick sema |	tick _ self popInteger.	sema _ self popStack.	successFlag ifTrue: [		(self fetchClassOf: sema) = (self splObj: ClassSemaphore) ifTrue: [			self storePointer: TheTimerSemaphore ofObject: specialObjectsOop withValue: sema.			nextWakeupTick _ tick.		] ifFalse: [			self storePointer: TheTimerSemaphore ofObject: specialObjectsOop withValue: nilObj.			nextWakeupTick _ 0.		].	] ifFalse: [		self unPop: 2.  "sema, tick"	].! !!DynamicInterpreter methodsFor: 'other primitives' stamp: 'ikp 8/26/97 01:01'!primitiveSnapshot	| activeProc dataSize rcvr activeCntx sp |	self assertStackPointerIsExternal.	"save the state of the current process and save it on the scheduler queue"	activeCntx _ self flushCacheFrom: activeCachedContext.	self assertIsNull: activeCachedContext.	activeProc _ self fetchPointer: ActiveProcessIndex ofObject: self schedulerPointer.	self storePointer: SuspendedContextIndex ofObject: activeProc withValue: activeCntx.	"compact memory and compute the size of the memory actually in use"	self pushRemappableOop: activeCntx.	self incrementalGC.  "maximimize space for forwarding table"	self fullGC.	activeCntx _ self popRemappableOop.	dataSize _ freeBlock - (self startOfMemory).	"Assume: all objects are below the start of the free block"	self assertIsStableContext: activeCntx.	sp _ self fetchInteger: StackPointerIndex ofObject: activeCntx.	successFlag ifTrue: [		"Pop the receiver, push true"		rcvr _ self fetchPointer:	TempFrameStart + sp - 1	ofObject: activeCntx.		self storePointerUnchecked:	TempFrameStart + sp - 1	ofObject: activeCntx withValue: trueObj.		self writeImageFile: dataSize.		"Pop true off the stack"		self storeInteger: StackPointerIndex ofObject: activeCntx withValue: sp - 1.	].	self copyContextToCache: activeCntx.	self fetchContextRegisters: activeCachedContext.	successFlag		ifTrue: [ self push: falseObj ]		ifFalse: [ self push: rcvr ].! !!DynamicInterpreter methodsFor: 'other primitives'!primitiveSpecialObjectsOop	"Return the oop of the SpecialObjectsArray."	self pop: 1.	self push: specialObjectsOop.! !!DynamicInterpreter methodsFor: 'other primitives' stamp: 'ikp 1/13/98 00:45'!primitiveVMParameter	"Behaviour depends on argument count:		0 args:	return an Array of VM parameter values;		1 arg:	return the indicated VM parameter;		2 args:	set the VM indicated parameter, or interrogate VM table.	VM parameters are numbered as follows:		1	end of old-space (0-based, read-only)		2	end of young-space (read-only)		3	end of memory (read-only)		4	allocationCount (read-only)		5	allocations between GCs (read-write)		6	survivor count tenuring threshold (read-write)		7	full GCs since startup (read-only)		8	total milliseconds in full GCs since startup (read-only)		9	incremental GCs since startup (read-only)		10	total milliseconds in incremental GCs since startup (read-only)		11	tenures of surving objects since startup (read-only)	and to be implemented Real Soon Now...		12	number of methods translated (read-only)		13*	(flag) enable/disable translation time recording -- 0 means 'disabled' (read-write)		14*	total milliseconds in translation since startup (optional; read-only)		15	total number of method cache misses	 (read-only)			16	total number of method cache hits (read-only)		17*	total number of inline cache hits (read-only)		18	inline cache over-size method rejection count (read-only)		19	inline cache over-size method limit (read-write)		20	inline cache link delay (read-write)		(Statistics collection for parameters marked '*' can be disabled at VM generation		 time to reduce impact on performance.  When disabled these values are always 0.)	With two arguments, the first of which is negative, return a value from a VM	internal table.  Tables are indexed from 1, but element 0 will appear to contain	the size of the table.  VM tables are numbered as follows:		-1	opcodeTable (contains the opcode addresses for this VM)	Other stuff that might be interesting:		-	current root table size		-	number of root table overflows"	"Note: Thanks to Ian Piumarta for this primitive."	| result mem index arg |	mem _ self cCoerce: memory to: 'int'.	argumentCount = 0 ifTrue: [		result _ self instantiateClass: (self splObj: ClassArray) indexableSize: 17.		self storeWord: 0	ofObject: result withValue: (self integerObjectOf: youngStart - mem).		self storeWord: 1		ofObject: result withValue: (self integerObjectOf: freeBlock - mem).		self storeWord: 2	ofObject: result withValue: (self integerObjectOf: endOfMemory - mem).		self storeWord: 3	ofObject: result withValue: (self integerObjectOf: allocationCount).		self storeWord: 4	ofObject: result withValue: (self integerObjectOf: allocationsBetweenGCs).		self storeWord: 5	ofObject: result withValue: (self integerObjectOf: tenuringThreshold).		self storeWord: 6	ofObject: result withValue: (self integerObjectOf: statFullGCs).		self storeWord: 7	ofObject: result withValue: (self integerObjectOf: statFullGCMSecs).		self storeWord: 8	ofObject: result withValue: (self integerObjectOf: statIncrGCs).		self storeWord: 9	ofObject: result withValue: (self integerObjectOf: statIncrGCMSecs).		self storeWord: 10	ofObject: result withValue: (self integerObjectOf: statTenures).		self storeWord: 14	ofObject: result withValue: (self integerObjectOf: statMethodCacheMisses).		self storeWord: 15	ofObject: result withValue: (self integerObjectOf: statMethodCacheHits).		self storeWord: 16	ofObject: result withValue: (self integerObjectOf: statInlineCacheHits).		self pop: 1 thenPush: result.		^nil].	arg _ self stackTop.	(self isIntegerObject: arg) ifFalse: [^self primitiveFail].	arg _ self integerValueOf: arg.	argumentCount = 1 ifTrue: [	"read VM parameter"		(arg < 1 or: [arg > 19]) ifTrue: [^self primitiveFail].		arg = 1		ifTrue: [result _ youngStart - mem].		arg = 2		ifTrue: [result _ freeBlock - mem].		arg = 3		ifTrue: [result _ endOfMemory - mem].		arg = 4		ifTrue: [result _ allocationCount].		arg = 5		ifTrue: [result _ allocationsBetweenGCs].		arg = 6		ifTrue: [result _ tenuringThreshold].		arg = 7		ifTrue: [result _ statFullGCs].		arg = 8		ifTrue: [result _ statFullGCMSecs].		arg = 9		ifTrue: [result _ statIncrGCs].		arg = 10		ifTrue: [result _ statIncrGCMSecs].		arg = 11		ifTrue: [result _ statTenures].		arg = 12		ifTrue: [result _ statTranslationCount.].		arg = 13		ifTrue: [^self primitiveFail].		arg = 14		ifTrue: [^self primitiveFail].		arg = 15		ifTrue: ["result _ statMethodCacheMisses."  ^self primitiveFail].		arg = 16		ifTrue: ["result _ statMethodCacheHits."  ^self primitiveFail].		arg = 17		ifTrue: ["result _ statInlineCacheHits."  ^self primitiveFail].		arg = 18		ifTrue: [^self primitiveFail].		arg = 19		ifTrue: [result _ inlineCacheLimit].		self pop: 2 thenPush: (self integerObjectOf: result).		^nil].	argumentCount = 2 ifFalse: [^self primitiveFail].	index _ self stackValue: 1.	(self isIntegerObject: index) ifFalse: [^self primitiveFail].	index _ self integerValueOf: index.	index = 0 ifTrue: [^self primitiveFail].	index > 0 ifTrue: [			"write VM parameter"		successFlag _ false.		index = 5	ifTrue: [result _ allocationsBetweenGCs.  allocationsBetweenGCs _ arg.  successFlag _ true.].		index = 6	ifTrue: [result _ tenuringThreshold.  tenuringThreshold _ arg.  successFlag _ true.].		index = 19	ifTrue: [result _ inlineCacheLimit.  inlineCacheLimit _ arg.  successFlag _ true.].		successFlag ifFalse: [^nil].		self pop: 3 thenPush: (self integerObjectOf: result).	"answer previous value"		^nil.	] ifFalse: [					"interrogate VM table"		arg < 0 ifTrue: [^self primitiveFail].		index = -1 ifTrue: [	"opcodeTable"			arg > OpcodeTableSize ifTrue: [^self primitiveFail].			arg = 0					ifTrue: [result _ self integerObjectOf: OpcodeTableSize]				ifFalse: [result _ opcodeTable at: arg].	"Note: this is already an integer object"			self pop: 3 thenPush: result.			^nil.		].		"self primitiveFail -- unknown table"	].	self primitiveFail.! !!DynamicInterpreter methodsFor: 'other primitives'!primitiveVMPath	"Return a string containing the path name of VM's directory."	| s sz |	sz _ self vmPathSize.	s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.	self vmPathGet: (s + BaseHeaderSize) Length: sz.	self pop: 1.  "rcvr"	self push: s.! !!DynamicInterpreter methodsFor: 'quick primitives' stamp: 'ikp 9/29/97 21:02'!primitiveLoadInstVar	| thisReceiver |	thisReceiver _ self popStack.	self push: (self fetchPointer: primitiveIndex-264 ofObject: thisReceiver)! !!DynamicInterpreter methodsFor: 'quick primitives' stamp: 'ikp 9/29/97 21:02'!primitivePushFalse	self popStack.	self push: falseObj! !!DynamicInterpreter methodsFor: 'quick primitives' stamp: 'ikp 9/29/97 21:02'!primitivePushMinusOne	self popStack.	self push: ConstMinusOne! !!DynamicInterpreter methodsFor: 'quick primitives' stamp: 'ikp 9/29/97 21:02'!primitivePushNil	self popStack.	self push: nilObj! !!DynamicInterpreter methodsFor: 'quick primitives' stamp: 'ikp 9/29/97 21:02'!primitivePushOne	self popStack.	self push: ConstOne! !!DynamicInterpreter methodsFor: 'quick primitives' stamp: 'ikp 9/29/97 21:02'!primitivePushSelf"	no-op, really...	thisReceiver _ self popStack.	self push: thisReceiver"! !!DynamicInterpreter methodsFor: 'quick primitives' stamp: 'ikp 9/29/97 21:02'!primitivePushTrue	self popStack.	self push: trueObj! !!DynamicInterpreter methodsFor: 'quick primitives' stamp: 'ikp 9/29/97 21:02'!primitivePushTwo	self popStack.	self push: ConstTwo! !!DynamicInterpreter methodsFor: 'quick primitives' stamp: 'ikp 9/29/97 21:02'!primitivePushZero	self popStack.	self push: ConstZero! !!DynamicInterpreter methodsFor: 'debug printing'!cr	"For testing in Smalltalk, this method should be overridden in a subclass."	self printf: '\n'.! !!DynamicInterpreter methodsFor: 'debug printing' stamp: 'ikp 12/1/97 00:26'!print: s	"For testing in Smalltalk, this method should be overridden in a subclass."	self var: #s declareC: 'char *s'.	self cCode: 'fprintf(stderr, "%s", s)'.! !!DynamicInterpreter methodsFor: 'debug printing' stamp: 'ikp 12/16/97 01:08'!printChar: aByte	"For testing in Smalltalk, this method should be overridden in a subclass."	self cCode: 'fputc(aByte, stderr)'! !!DynamicInterpreter methodsFor: 'debug printing' stamp: 'ikp 12/1/97 00:26'!printNum: n	"For testing in Smalltalk, this method should be overridden in a subclass."	self cCode: 'fprintf(stderr, "%ld", (long) n)'.! !!DynamicInterpreter methodsFor: 'debug support'!allAccessibleObjectsOkay	"Ensure that all accessible objects in the heap are okay."	| oop |	oop _ self firstAccessibleObject.	[oop = nil] whileFalse: [		self okayFields: oop.		oop _ self accessibleObjectAfter: oop.	].! !!DynamicInterpreter methodsFor: 'debug support' stamp: 'ikp 12/29/97 02:07'!debugPrint: string	self var: #string declareC: 'char *string'.	^nil! !!DynamicInterpreter methodsFor: 'debug support'!findClassOfMethod: meth forReceiver: rcvr	| currClass classDict classDictSize methodArray i done |	currClass _ self fetchClassOf: rcvr.	done _ false.	[done] whileFalse: [		classDict _ self fetchPointer: MessageDictionaryIndex ofObject: currClass.		classDictSize _ self fetchWordLengthOf: classDict.		methodArray _ self fetchPointer: MethodArrayIndex ofObject: classDict.		i _ 0.		[i < (classDictSize - SelectorStart)] whileTrue: [			meth = (self fetchPointer: i ofObject: methodArray) ifTrue: [ ^currClass ].			i _ i + 1.		].		currClass _ self fetchPointer: SuperclassIndex ofObject: currClass.		done _ currClass = nilObj.	].	^self fetchClassOf: rcvr    "method not found in superclass chain"! !!DynamicInterpreter methodsFor: 'debug support'!findSelectorOfMethod: meth forReceiver: rcvr	| currClass done classDict classDictSize methodArray i |	currClass _ self fetchClassOf: rcvr.	done _ false.	[done] whileFalse: [		classDict _ self fetchPointer: MessageDictionaryIndex ofObject: currClass.		classDictSize _ self fetchWordLengthOf: classDict.		methodArray _ self fetchPointer: MethodArrayIndex ofObject: classDict.		i _ 0.		[i <= (classDictSize - SelectorStart)] whileTrue: [			meth = (self fetchPointer: i ofObject: methodArray) ifTrue: [				^(self fetchPointer: i + SelectorStart ofObject: classDict)			].			i _ i + 1.		].		currClass _ self fetchPointer: SuperclassIndex ofObject: currClass.		done _ currClass = nilObj.	].	^self splObj: SelectorDoesNotUnderstand    "method not found in superclass chain"! !!DynamicInterpreter methodsFor: 'debug support' stamp: 'ikp 11/30/97 19:09'!okayActiveProcessStack	| ctx stable pseudo |	ctx _ activeCachedContext.	stable _ 0.	[stable == 0] whileTrue: [		self okayFields: (self cachedMethodAt: ctx).		self okayFields: (self cachedTranslatedMethodAt: ctx).		self okayFields: (self cachedReceiverAt: ctx).		pseudo _ self cachedPseudoContextAt: ctx.		pseudo == 0 ifFalse: [self okayFields: pseudo].		ctx == lowestCachedContext ifTrue: [stable _ self cachedSenderAt: ctx].		ctx _ self cachedContextBefore: ctx.	].	[stable == nilObj] whileFalse: [		self okayFields: stable.		stable _ self fetchPointer: SenderIndex ofObject: stable.	].! !!DynamicInterpreter methodsFor: 'debug support'!okayFields: oop	"If this is a pointers object, check that its fields are all okay oops."	| i fieldOop |	(oop = nil or: [oop = 0]) ifTrue: [ ^true ].	(self isIntegerObject: oop) ifTrue: [ ^true ].	self okayOop: oop.	self oopHasOkayClass: oop.	(self isPointers: oop) ifFalse: [ ^true ].	i _ (self lengthOf: oop) - 1.	[i >= 0] whileTrue: [		fieldOop _ self fetchPointer: i ofObject: oop.		(self isIntegerObject: fieldOop) ifFalse: [			self okayOop: fieldOop.			self oopHasOkayClass: fieldOop.		].		i _ i - 1.	].! !!DynamicInterpreter methodsFor: 'debug support' stamp: 'ikp 1/14/98 01:06'!okayInterpreterObjects	| oopOrZero oop |	self okayFields: nilObj.	self okayFields: falseObj.	self okayFields: trueObj.	self okayFields: specialObjectsOop.	self okayFields: messageSelector.	self okayFields: newMethod.	newReceiver = 0 ifFalse: [self okayFields: newReceiver].	pseudoReceiver = 0 ifFalse: [self okayFields: pseudoReceiver].	1 to: MethodCacheEntries do: [ :i |		oopOrZero _ methodCache at: i + MethodCacheSelectorCol.		oopOrZero = 0 ifFalse: [			self okayFields: (methodCache at: i).								"selector"			self okayFields: (methodCache at: i + MethodCacheClassCol).		"class"			self okayFields: (methodCache at: i + MethodCacheMethodCol).	"method"		].	].	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			self okayFields: oop.		].	].	self okayActiveProcessStack.! !!DynamicInterpreter methodsFor: 'debug support'!okayOop: oop	"Verify that the given oop is legitimate. Check address, header, and size but not class."	| sz type fmt |	"address and size checks"	(self isIntegerObject: oop) ifTrue: [ ^true ].	((0 < oop) & (oop < endOfMemory))		ifFalse: [ self error: 'oop is not a valid address' ].	((oop \\ 4) = 0)		ifFalse: [ self error: 'oop is not a word-aligned address' ].	sz _ self sizeBitsOf: oop.	(oop + sz) < endOfMemory		ifFalse: [ self error: 'oop size would make it extend beyond the end of memory' ].	"header type checks"	type _ self headerType: oop.	type = HeaderTypeFree		ifTrue:  [ self error: 'oop is a free chunk, not an object' ].	type = HeaderTypeShort ifTrue: [		(((self baseHeader: oop) >> 12) bitAnd: 16r1F) = 0			ifTrue:  [ self error: 'cannot have zero compact class field in a short header' ].	].	type = HeaderTypeClass ifTrue: [		((oop >= 4) and: [(self headerType: oop - 4) = type])			ifFalse: [ self error: 'class header word has wrong type' ].	].	type = HeaderTypeSizeAndClass ifTrue: [		((oop >= 8) and:		 [(self headerType: oop - 8) = type and:		 [(self headerType: oop - 4) = type]])			ifFalse: [ self error: 'class header word has wrong type' ].	].	"format check"	fmt _ self formatOf: oop.	((fmt = 4) | (fmt = 5) | (fmt = 7))		ifTrue:  [ self error: 'oop has an unknown format type' ].	"mark and root bit checks"	((self longAt: oop) bitAnd: 16r20000000) = 0		ifFalse: [ self error: 'unused header bit 30 is set; should be zero' ]."xxx	((self longAt: oop) bitAnd: MarkBit) = 0		ifFalse: [ self error: 'mark bit should not be set except during GC' ].xxx"	(((self longAt: oop) bitAnd: RootBit) = 1 and:	 [oop >= youngStart])		ifTrue: [ self error: 'root bit is set in a young object' ].	^true! !!DynamicInterpreter methodsFor: 'debug support'!oopHasOkayClass: oop	"Attempt to verify that the given oop has a reasonable behavior. The class must be a valid, non-integer oop and must not be nilObj. It must be a pointers object with three or more fields. Finally, the instance specification field of the behavior must match that of the instance."	| oopClass formatMask behaviorFormatBits oopFormatBits |	self okayOop: oop.	oopClass _ self fetchClassOf: oop.	(self isIntegerObject: oopClass)		ifTrue: [ self error: 'a SmallInteger is not a valid class or behavior' ].	self okayOop: oopClass.	((self isPointers: oopClass) and: [(self lengthOf: oopClass) >= 3])		ifFalse: [ self error: 'a class (behavior) must be a pointers object of size >= 3' ].	(self isBytes: oop)		ifTrue: [ formatMask _ 16rC00 ]  "ignore extra bytes size bits"		ifFalse: [ formatMask _ 16rF00 ].	behaviorFormatBits _ (self formatOfClass: oopClass) bitAnd: formatMask.	oopFormatBits _ (self baseHeader: oop) bitAnd: formatMask.	behaviorFormatBits = oopFormatBits		ifFalse: [ self error: 'object and its class (behavior) formats differ' ].	^true! !!DynamicInterpreter methodsFor: 'debug support' stamp: 'ikp 12/9/97 15:49'!printCallStack	| ctxt home methodClass methodSel stable meth recv iptr |	activeCachedContext = 0 ifFalse: [		ctxt _ activeCachedContext.		self stackPointer = -1 ifTrue: [			self print: 'Warning: stackPointer is internal -- backtrace might be incorrect!!'.			self cr.			self fetchContextRegisters: activeCachedContext.		].		stable _ 0.		[stable = 0] whileTrue: [			"Find receiver and method"			(self isCachedMethodContext: ctxt) ifTrue: [				meth _ self cachedMethodAt: ctxt.				recv _ self cachedReceiverAt: ctxt.				iptr _ self cachedInstructionIndexAt: ctxt.			] ifFalse: [				home _ self cachedHomeAt: ctxt.				(self isPseudoContext: home) ifTrue: [					meth _ self cachedMethodAt: (self pseudoCachedContextAt: home).					recv _ self cachedReceiverAt: (self pseudoCachedContextAt: home).					iptr _ self cachedInstructionIndexAt: (self pseudoCachedContextAt: home).				] ifFalse: [					meth _ self fetchPointer: MethodIndex ofObject: home.					recv _ self fetchPointer: ReceiverIndex ofObject: home.					iptr _ self fetchPointer: InstructionPointerIndex ofObject: home.				].			].			methodClass _ self findClassOfMethod: meth forReceiver: recv.			methodSel _ self findSelectorOfMethod: meth forReceiver: recv.			self print: '* '; printNum: ctxt; print: '	'.			self printNum: (self integerValueOf: iptr); print: '	'.			(self isCachedMethodContext: ctxt) ifTrue: [ self print: '[] in ' ].			self printNameOfClass: methodClass count: 5; print: '>>'; printStringOf: methodSel; cr.			ctxt = lowestCachedContext				ifTrue: [stable _ self cachedSenderAt: ctxt.  ctxt _ 0]				ifFalse: [ctxt _ self cachedContextBefore: ctxt].		].	].	ctxt _ stable.	[ctxt = nilObj] whileFalse: [		(self fetchClassOf: ctxt) = (self splObj: ClassBlockContext)			ifTrue: [ home _ self fetchPointer: HomeIndex ofObject: ctxt ]			ifFalse: [ home _ ctxt ].		methodClass _			self findClassOfMethod: (self fetchPointer: MethodIndex ofObject: home)					   forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		methodSel _			self findSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)						 forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		self print: '+ '.		self printNum: ctxt.		self print: '	'.		self printNum: (self integerValueOf: (self fetchPointer: InstructionPointerIndex ofObject: ctxt)); print: '	'.		ctxt = home ifFalse: [ self print: '[] in ' ].		self printNameOfClass: methodClass count: 5.		self print: '>>'.		self printStringOf: methodSel.		self cr.		ctxt _ (self fetchPointer: SenderIndex ofObject: ctxt).	].! !!DynamicInterpreter methodsFor: 'debug support'!printNameOfClass: classOop count: cnt	"Details: The count argument is used to avoid a possible infinite recursion if classOop is a corrupted object."	cnt <= 0 ifTrue: [ ^ self print: 'bad class' ].	(self sizeBitsOf: classOop) = 16r20 ifTrue: [		self printNameOfClass: (self fetchPointer: 6 "thisClass" ofObject: classOop) count: cnt - 1.		self print: ' class'.	] ifFalse: [		self printStringOf: (self fetchPointer: 6 "name" ofObject: classOop).	].! !!DynamicInterpreter methodsFor: 'debug support'!printStringOf: oop	| fmt cnt i |	fmt _ self formatOf: oop.	fmt < 8 ifTrue: [ ^nil ].	cnt _ 100 min: (self lengthOf: oop).	i _ 0.	[i < cnt] whileTrue: [		self printChar: (self fetchByte: i ofObject: oop).		i _ i + 1.	].! !!DynamicInterpreter methodsFor: 'debug support'!reportContexts	| cntxt big small |	big _ 0.	cntxt _ freeLargeContexts.	[cntxt = NilContext] whileFalse: [		big _ big + 1.		cntxt _ self fetchWord: 0 ofObject: cntxt.	].	small _ 0.	cntxt _ freeSmallContexts.	[cntxt = NilContext] whileFalse: [		small _ small + 1.		cntxt _ self fetchWord: 0 ofObject: cntxt.	].	self print: 'Recycled contexts: '.	self printNum: small; print: ' small, '.	self printNum: big; print: ' large ('.	self printNum: (big * LargeContextSize) + (small * SmallContextSize).	self print: ' bytes)'.	self cr.! !!DynamicInterpreter methodsFor: 'image save/restore' stamp: 'ikp 10/22/97 18:24'!byteSwapByteObjects	"Byte-swap the words of all bytes objects in the image, including Strings, ByteArrays, and CompiledMethods. This returns these objects to their original byte ordering after blindly byte-swapping the entire image. For compiled methods, byte-swap only their bytecodes part."	| oop fmt wordAddr methodHeader |	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifFalse: [			fmt _ self formatOf: oop.			fmt >= 8 ifTrue: [  "oop contains bytes"				wordAddr _ oop + BaseHeaderSize.				fmt >= 12 ifTrue: [					"compiled method; start after methodHeader and literals"					methodHeader _ self longAt: oop + BaseHeaderSize.					wordAddr _ wordAddr + 4 + (((methodHeader >> 10) bitAnd: 16rFF) * 4).				].				self reverseBytesFrom: wordAddr to: oop + (self sizeBitsOf: oop).			]. 		].		oop _ self objectAfter: oop.	].! !!DynamicInterpreter methodsFor: 'image save/restore'!byteSwapped: w	"Return the given integer with its bytes in the reverse order."	^ ((w bitShift: -24) bitAnd: 16rFF) +	  ((w bitShift: -8) bitAnd: 16rFF00) +	  ((w bitShift: 8) bitAnd: 16rFF0000) +	  ((w bitShift: 24) bitAnd: 16rFF000000)! !!DynamicInterpreter methodsFor: 'image save/restore'!checkImageVersionFrom: f	"Read and verify the image file version number and return true if the the given image file needs to be byte-swapped. As a side effect, position the file stream just after the version number of the image header. This code prints a warning and does a hard-exit if it cannot find a valid version number."	"This code is based on C code by Ian Piumarta."	| expectedVersion version firstVersion |	self var: #f declareC: 'FILE *f'.	expectedVersion _ self imageFormatVersion.	"check the version number"	self fileSeek: f position: 0.	version _ firstVersion _ self getLongFromFile: f swap: false.	(version = expectedVersion) ifTrue: [^ false].	"try with byte reversal"	self fileSeek: f position: 0.	version _ self getLongFromFile: f swap: true.	(version = expectedVersion) ifTrue: [^ true].	"try skipping the first 512 bytes (prepended by certain Mac file transfer utilities)"	self fileSeek: f position: 512.	version _ self getLongFromFile: f swap: false.	(version = expectedVersion) ifTrue: [^ false].	"try skipping the first 512 bytes with byte reversal"	self fileSeek: f position: 512.	version _ self getLongFromFile: f swap: true.	(version = expectedVersion) ifTrue: [^ true].	"hard failure; abort"	self print: 'This interpreter (vers. '.	self printNum: expectedVersion.	self print: ' cannot read image file (vers. '.	self printNum: firstVersion.	self cr.	self ioExit.! !!DynamicInterpreter methodsFor: 'image save/restore'!fileSeek: f position: pos	"Position the given file stream to the given offset from the start of the file."	self var: #f declareC: 'FILE *f'.	self cCode: 'fseek(f, pos, SEEK_SET)'.! !!DynamicInterpreter methodsFor: 'image save/restore'!getLongFromFile: f swap: swapFlag	"Return the next 4-byte word of the given file, byte-swapped according to the given flag."	| w |	self var: #f declareC: 'FILE *f'.	self cCode: 'fread(&w, sizeof(char), 4, f)'.	swapFlag		ifTrue: [^ self byteSwapped: w]		ifFalse: [^ w].! !!DynamicInterpreter methodsFor: 'image save/restore'!imageFormatVersion	"Return a magic constant that changes when the image format changes. Since the image reading code uses this to detect byte ordering, one must avoid version numbers that are invariant under byte reversal."	^ 6502! !!DynamicInterpreter methodsFor: 'image save/restore'!positionOfFile: f	"Return the current position of the given file stream."	self var: #f declareC: 'FILE *f'.	^ self cCode: 'ftell(f)'! !!DynamicInterpreter methodsFor: 'image save/restore'!putLong: n toFile: f	"Append the given 4-byte long word to the given file in this platforms 'natural' byte order. (Bytes will be swapped, if necessary, when the image is read on a different platform.) Set successFlag to false if the write fails."	| wordsWritten |	self var: #f declareC: 'FILE *f'.	wordsWritten _ self cCode: 'fwrite(&n, sizeof(int), 1, f)'.	self success: wordsWritten = 1.! !!DynamicInterpreter methodsFor: 'image save/restore' stamp: 'ikp 8/18/97 00:58'!readImageFromFile: f HeapSize: desiredHeapSize	"Read an image from the given file stream, allocating the given amount of memory to its object heap. Fail if the image has an unknown format or requires more than the given amount of memory."	"Details: This method detects when the image was stored on a machine with the opposite byte ordering from this machine and swaps the bytes automatically. Furthermore, it allows the header information to start 512 bytes into the file, since some file transfer programs for the Macintosh apparently prepend a Mac-specific header of this size. Note that this same 512 bytes of prefix area could also be used to store an exec command on Unix systems, allowing one to launch Smalltalk by invoking the image name as a command."	"This code is based on C code by Ian Piumarta and Smalltalk code by Tim Rowledge. Many thanks to both of you!!!!"	| swapBytes headerStart headerSize dataSize oldBaseAddr minimumMemory memStart bytesRead bytesToShift actualHeapSize |	self var: #f declareC: 'FILE *f'.	swapBytes _ self checkImageVersionFrom: f.	headerStart _ (self positionOfFile: f) - 4.  "record header start position"	headerSize			_ self getLongFromFile: f swap: swapBytes.	dataSize				_ self getLongFromFile: f swap: swapBytes.	oldBaseAddr			_ self getLongFromFile: f swap: swapBytes.	specialObjectsOop		_ self getLongFromFile: f swap: swapBytes.	lastHash			_ self getLongFromFile: f swap: swapBytes.	savedWindowSize	_ self getLongFromFile: f swap: swapBytes.	lastHash = 0 ifTrue: [		"lastHash wasn't stored (e.g. by the cloner); use 999 as the seed"		lastHash _ 999].	"compare memory requirements with availability".	minimumMemory _ dataSize + 80000.  "need at least 80K of breathing room"	desiredHeapSize < minimumMemory		ifTrue: [ self error: 'Insufficient memory for this image' ].	contextCacheEntries = nil ifTrue: [contextCacheEntries _ ContextCacheEntries].	stackCacheEntries = nil ifTrue: [stackCacheEntries _ StackCacheEntries].	actualHeapSize _ desiredHeapSize + self cacheSize.	"allocate a contiguous block of memory for the Squeak heap"	memory _ self cCode: '(unsigned char *) malloc(actualHeapSize)'.	memory = nil		ifTrue: [ self error: 'Failed to allocate memory for the heap' ].	memStart _ self startOfMemory.	memoryLimit _ (memStart + desiredHeapSize) - 24.  "decrease memoryLimit a tad for safety"	endOfMemory _ memStart + dataSize.	"position file after the header"	self fileSeek: f position: headerStart + headerSize.	"read in the image in bulk, then swap the bytes if necessary"	bytesRead _ self cCode: 'fread(memory, sizeof(unsigned char), dataSize, f)'.	bytesRead ~= dataSize		ifTrue: [ self error: 'Read failed or premature end of image file' ].	swapBytes ifTrue: [self reverseBytesInImage].	"compute difference between old and new memory base addresses"	bytesToShift _ memStart - oldBaseAddr.	self initializeCache: memStart + desiredHeapSize.	self initializeInterpreter: bytesToShift.  "adjusts all oops to new location"	^ dataSize! !!DynamicInterpreter methodsFor: 'image save/restore' stamp: 'ikp 10/22/97 18:25'!reverseBytesFrom: startAddr to: stopAddr	"Byte-swap the given range of memory (not inclusive!!)."	| addr |	addr _ startAddr.	[addr < stopAddr] whileTrue:		[self longAt: addr put: (self byteSwapped: (self longAt: addr)).		addr _ addr + 4].! !!DynamicInterpreter methodsFor: 'image save/restore' stamp: 'ikp 10/22/97 18:26'!reverseBytesInImage	"Byte-swap all words in memory after reading in the entire image file with bulk read. Contributed by Tim Rowledge."	"First, byte-swap every word in the image. This fixes objects headers."	self reverseBytesFrom: self startOfMemory to: endOfMemory.	"Second, return the bytes of bytes-type objects to their orginal order."	self byteSwapByteObjects.! !!DynamicInterpreter methodsFor: 'image save/restore' stamp: 'ikp 12/14/97 14:00'!writeImageFile: imageBytes	| headerStart headerSize f bytesWritten |	self var: #f declareC: 'FILE *f'.	"local constants"	headerStart _ 0.  "change to 512 to leave room for a Unix exec string"	headerSize _ 64.  "header size in bytes; do not change!!"	f _ self cCode: 'fopen(imageName, "wb")'.	f = nil ifTrue: [		"could not open the image file for writing"		self success: false.		^ nil ].	self cCode: '/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */'.	"position file to start of header"	self fileSeek: f position: headerStart.	self putLong: (self imageFormatVersion) toFile: f.	self putLong: headerSize toFile: f.	self putLong: imageBytes toFile: f.	self putLong: (self startOfMemory) toFile: f.	self putLong: specialObjectsOop toFile: f.	self putLong: lastHash toFile: f.	self putLong: (self ioScreenSize) toFile: f.	1 to: 9 do: [:i | self putLong: 0 toFile: f].  "fill remaining header words with zeros"	successFlag ifFalse: [		"write or seek failure"		self cCode: 'fclose(f)'.		^ nil ].	"position file after the header"	self fileSeek: f position: headerStart + headerSize.	"write the image data"	bytesWritten _ self cCode: 'fwrite(memory, sizeof(unsigned char), imageBytes, f)'.	self success: bytesWritten = imageBytes.	self cCode: 'fclose(f)'.	"set Mac file type and creator; this is a noop on other platforms"	self cCode: 'dir_SetMacFileTypeAndCreator(imageName, strlen(imageName), "STim", "FAST")'.! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 12/3/97 13:05'!assert: boolean	boolean ifFalse: [self error: 'assertion failed'].! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 12/3/97 13:04'!assertAny: ignored	"always succeeds"! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 11/30/97 17:48'!assertIsArray: t1 	self inline: false.	self assertIsOop: t1.	(self fetchClassOf: t1)		== (self splObj: ClassArray) ifFalse: [self error: 'Array expected']! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 12/29/97 21:39'!assertIsArrayOrNil: t1 	self inline: false.	self assertIsOop: t1.	(t1 = nilObj or: [(self fetchClassOf: t1) = (self splObj: ClassArray)])		ifFalse: [self error: 'Array or nil expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsCachedBaseContext: t1 	^ self! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsCachedBlockContext: t1 	self inline: false.	(self isCachedBlockContext: t1)		ifFalse: [self error: 'cached block context expected']! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 8/26/97 03:36'!assertIsCachedContext: t1 	self inline: false.	(t1 < contextCache		or: [t1 > lastCachedContext or: [t1 - contextCache \\ CacheEntrySize ~= 0]])		ifTrue: [self error: 'cached context pointer expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsCachedMethodContext: t1 	self inline: false.	(self isCachedMethodContext: t1)		ifFalse: [self error: 'cached method context expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsCompiledMethod: t1 	self inline: false.	self assertIsOop: t1.	(self fetchClassOf: t1)		== (self splObj: ClassCompiledMethod) ifFalse: [self error: 'CompiledMethod expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsCompiledMethodOrInteger: t1 	self inline: false.	self assertIsOop: t1.	((self isIntegerObject: t1)		or: [(self fetchClassOf: t1)				== (self splObj: ClassCompiledMethod)])		ifFalse: [self error: 'CompiledMethod expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsContext: t1 	| t2 |	self inline: false.	self assertIsOop: t1.	t2 _ self fetchClassOf: t1.	(t2 == (self splObj: ClassBlockContext)		or: [t2 == (self splObj: ClassMethodContext) or: [t2 == (self splObj: ClassPseudoContext)]])		ifFalse: [self error: 'context expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsContextOrNull: t1 	| t2 |	self inline: false.	t1 = 0		ifFalse: 			[self assertIsOop: t1.			t2 _ self fetchClassOf: t1.			(t2 == (self splObj: ClassBlockContext)				or: [t2 == (self splObj: ClassMethodContext) or: [t2 == (self splObj: ClassPseudoContext)]])				ifFalse: [self error: 'context expected']]! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsIntegerObject: t1 	self inline: false.	(self isIntegerObject: t1)		ifFalse: [self error: 'integer object expected']! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 8/26/97 01:34'!assertIsLegalCachedTempPointer: t1 	self inline: false.	self assertIsWordAligned: t1.	t1 < stackCache ifTrue: [self error: 'cached temporary pointer is below the start of stack'].	t1 > stackCacheFence ifTrue: [self error: 'cached temporary pointer is above the stack fence']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsLegalInstructionIndex: t1 in: t2 	| t3 |	self inline: false.	self assertIsIntegerObject: t1.	t3 _ self integerValueOf: t1.	t3 < (BaseHeaderSize + 1) ifTrue: [self error: 'ip points before first bytecode'].	t3 > ((self sizeBitsOf: t2)			- BaseHeaderSize) ifTrue: [self error: 'ip points after last bytecode']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsLegalInstructionPointer: t1 in: t2 	self inline: false.	t1 < (t2 + BaseHeaderSize + 4 - 1) ifTrue: [self error: 'ip points before first bytecode'].	t1 > (t2 + (self sizeBitsOf: t2) - 1) ifTrue: [self error: 'ip points after last bytecode']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsLegalStableTempPointer: t1 	| t2 t3 |	self inline: false.	self assertIsWordAligned: t1.	t2 _ t1 - BaseHeaderSize - (TempFrameStart * 4).	self assertIsOop: t2.	self assertIsStableMethodContext: t2.	t2 < youngStart		ifTrue: 			[t3 _ self longAt: t2.			(t3 bitAnd: RootBit)				== 0 ifTrue: [self error: 'old context is not a root']]! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsLegalStackOffsetInContext: t1 	| t2 t3 |	self inline: false.	t2 _ self fetchWord: StackPointerIndex ofObject: t1.	self assertIsIntegerObject: t2.	t2 _ self integerValueOf: t2.	t3 _ (self sizeBitsOf: t1)				- BaseHeaderSize - (TempFrameStart * 4).	t2 >= t3 ifTrue: [self error: 'illegal stack pointer in stable context']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsLegalStackPointer: t1 	self inline: false.	self assertIsWordAligned: t1.	t1 < (stackCache - 4) ifTrue: [self error: 'cached stack pointer is below the start of stack'].	t1 >= self stackCacheLimit ifTrue: [self error: 'cached stack pointer is above the stack limit']! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 8/25/97 12:17'!assertIsLegalTempOffset: t1 	| t2 |	self inline: false.	t1 < 0 ifTrue: [self error: 'negative temp offset'].	self assertIsLegalTempPointer: self temporaryPointer.	self temporaryPointer > contextCache		ifTrue: [(t1 < 0 or: [t1 > 31])				ifTrue: [self error: 'illegal cached temp offset']]		ifFalse: 			[t2 _ self sizeBitsOf: self temporaryPointer - BaseHeaderSize - (TempFrameStart * 4).			t2 _ t2 - BaseHeaderSize // 4 - TempFrameStart.			t1 >= t2 ifTrue: [self error: 'stable temp offset too large']]! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsLegalTempPointer: t1 	self inline: false.	t1 >= contextCache		ifTrue: [self assertIsLegalCachedTempPointer: t1]		ifFalse: [self assertIsLegalStableTempPointer: t1]! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 12/1/97 14:53'!assertIsLegalTranslatedInstructionIndex: t1 in: t2 	| t3 |	self inline: false.	self assertIsIntegerObject: t1.	t3 _ self integerValueOf: t1.	t3 < (BaseHeaderSize + 1) ifTrue: [self error: 'ip points before first instruction'].	t3 > ((self sizeBitsOf: t2)			- BaseHeaderSize) ifTrue: [self error: 'ip points after last instruction']! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 12/1/97 22:21'!assertIsLegalTranslatedInstructionPointer: t1 in: t2 	self inline: false.	t1 < (t2 + BaseHeaderSize + 4 - 1) ifTrue: [self error: 'ip points before first bytecode'].	t1 > (t2 + (self sizeBitsOf: t2) - 1) ifTrue: [self error: 'ip points after last bytecode']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsNotNull: t1 	self inline: false.	t1 == 0 ifTrue: [self error: 'non-null expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsNull: t1 	self inline: false.	t1 == 0 ifFalse: [self error: 'null expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsOop: t1 	self inline: false.	(self isIntegerObject: t1)		ifFalse: [(self okayOop: t1)				ifFalse: [self error: 'not a valid oop']]! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsProcess: t1 	self inline: false.	self assertIsOop: t1.	(self fetchClassOf: t1)		= (self splObj: ClassProcess) ifFalse: [self error: 'process expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsPseudoActiveContext: t1 	self inline: false.	self assertIsOop: t1.	t1 == (self cachedPseudoContextAt: activeCachedContext) ifFalse: [self error: 'active PseudoContext expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsPseudoContext: t1 	self inline: false.	self assertIsOop: t1.	(self fetchClassOf: t1)		== (self splObj: ClassPseudoContext) ifFalse: [self error: 'PseudoContext expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsPseudoContextOrNull: t1 	self inline: false.	t1 == 0 ifFalse: [self assertIsOop: t1].	(t1 == 0 or: [(self fetchClassOf: t1)			== (self splObj: ClassPseudoContext)])		ifFalse: [self error: 'PseudoContext expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsStableBaseContext: t1 	^ self! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsStableBlockContext: t1 	self inline: false.	self assertIsOop: t1.	(self fetchClassOf: t1)		== (self splObj: ClassBlockContext) ifFalse: [self error: 'stable BlockContext expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsStableContext: t1 	| t2 |	self inline: false.	self assertIsOop: t1.	t2 _ self fetchClassOf: t1.	(t2 == (self splObj: ClassBlockContext) or: [t2 == (self splObj: ClassMethodContext)])		ifFalse: [self error: 'stable context expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsStableContextClass: t1 	self inline: false.	self assertIsOop: t1.	(t1 == (self splObj: ClassMethodContext) or: [t1 == (self splObj: ClassBlockContext)])		ifFalse: [self error: 'stable context class expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsStableContextOrNil: t1 	self inline: false.	self assertIsOop: t1.	(t1 == nilObj or: [self isStableContext: t1])		ifFalse: [self error: 'stable context or null expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsStableContextOrNilOrNull: t1 	self inline: false.	t1 == 0		ifFalse: 			[(t1 == nilObj or: [self isStableContext: t1])				ifFalse: [self error: 'stable context or null expected'].			self assertIsOop: t1]! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsStableContextOrNull: t1 	self inline: false.	t1 == 0 ifFalse: [self assertIsOop: t1].	(t1 == 0 or: [self isStableContext: t1])		ifFalse: [self error: 'stable context or null expected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertIsStableMethodContext: t1 	self inline: false.	self assertIsStableContext: t1.	(self fetchClassOf: t1)		== (self splObj: ClassMethodContext) ifFalse: [self error: 'stable method context expected']! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 1/5/98 16:45'!assertIsValidPseudoContextAt: cp	| pc cpp |	pc _ self basicCachedPseudoContextAt: cp.	pc = 0 ifFalse: [		cpp _ (self fetchPointer: CachedContextIndex ofObject: pc) - 1.		self assert: cp = cpp]! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 12/9/97 15:49'!assertIsWordAligned: t1 	self inline: false.	t1 \\ 4 = 0 ifFalse: [self error: 'non-aligned word access']! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 12/18/97 17:59'!assertNotIntegerObject: t1 	self inline: false.	(self isIntegerObject: t1)		ifTrue: [self error: 'integer object unexpected']! !!DynamicInterpreter methodsFor: 'assert-verify'!assertStackPointerIsExternal	^ self! !!DynamicInterpreter methodsFor: 'assert-verify'!assertStackPointerIsInternal	^ self! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 11/30/97 19:10'!verifyCachedContext: t1 	| t2 t3 t4 t5 |	self cachedMethodAt: t1.	self cachedTranslatedMethodAt: t1.	self cachedReceiverAt: t1.	self cachedHomeAt: t1.	t2 _ self cachedPseudoContextAt: t1.	t2 == 0		ifFalse: [(self pseudoCachedContextAt: t2)				== t1 ifFalse: [self error: 'cached/pseudo context backpointers broken']].	t3 _ self cachedFramePointerAt: t1.	t4 _ self cachedStackPointerAt: t1.	t5 _ t4 + 4 - t3 // 4.	t5 < 0 ifTrue: [self error: 'cached stack underflow'].	t5 > 32 ifTrue: [self error: 'cached stack overflow'].	t3		to: t4		by: 4		do: [:t6 | self okayFields: (self longAt: t6)]! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 1/14/98 01:03'!verifyMethodCache	1 to: MethodCacheEntries do: [:index |		self okayFields: (methodCache at: index + MethodCacheSelectorCol).	"selector"		self okayFields: (methodCache at: index + MethodCacheClassCol).		"class"		self okayFields: (methodCache at: index + MethodCacheMethodCol).		"method"		self okayFields: (methodCache at: index + MethodCacheTMethodCol).	"translated method"	]! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 12/9/97 15:49'!verifyStableContext: t1 	| t2 t3 t4 t5 |	t2 _ self fetchPointer: SenderIndex ofObject: t1.	t2 = nilObj ifFalse: [self assertIsStableContext: t2].	self assertIsIntegerObject: (self fetchPointer: InstructionPointerIndex ofObject: t1).	self assertIsIntegerObject: (t3 _ self fetchPointer: StackPointerIndex ofObject: t1).	t4 _ self fetchPointer: MethodIndex ofObject: t1.	(self isIntegerObject: t4)		ifTrue: 			[t5 _ self fetchPointer: HomeIndex ofObject: t1.			self assertIsStableMethodContext: t5]		ifFalse: [self assertIsCompiledMethod: t4].	t3 _ self integerValueOf: t3.	t3 < 0 ifTrue: [self error: 'stable stack underflow'].	t3 > 32 ifTrue: [self error: 'stable stack overflow'].	self okayFields: t1! !!DynamicInterpreter methodsFor: 'assert-verify' stamp: 'ikp 12/9/97 15:49'!verifyStack	| t1 t2 t3 |	checkAssertions ifFalse: [^nil ].	(t1 _ activeCachedContext) = 0		ifTrue: [self print: 'Warning: no active context in #verifyStack';			 cr]		ifFalse: 			[t2 _ 0.			[t2 = 0]				whileTrue: 					[self verifyCachedContext: t1.					t1 = lowestCachedContext ifTrue: [t2 _ self cachedSenderAt: t1].					t1 _ self cachedContextBefore: t1].			t2 = nilObj ifTrue: [self assertIsCachedBaseContext: lowestCachedContext].			[t2 = nilObj]				whileFalse: 					[self verifyStableContext: t2.					t3 _ self fetchPointer: SenderIndex ofObject: t2.					t3 = nilObj ifTrue: [self assertIsStableBaseContext: t2].					t2 _ t3].			nil]! !!DynamicInterpreter class methodsFor: 'translation' stamp: 'ikp 1/1/98 17:13'!declareCVarsIn: aCCodeGenerator! !!DynamicInterpreter class methodsFor: 'translation' stamp: 'ikp 1/1/98 02:56'!patchInterp: fileName	"Interpreter patchInterp: 'Squeak VM PPC'"	"This will patch out the unneccesary range check (a compare	 and branch) in the inner interpreter dispatch loop."	"NOTE: You must edit in the Interpeter file name, and the	 number of instructions (delta) to count back to find the compare	 and branch that we want to get rid of."	| delta f code len remnant i |	delta _ 6.	f _ FileStream fileNamed: fileName.	f binary.	code _ Bitmap new: (len _ f size) // 4.	f nextInto: code.	remnant _ f next: len - (code size * 4).	i _ 0.	["Look for a BCTR instruction"	(i _ code indexOf: 16r4E800420 startingAt: i + 1 ifAbsent: [0]) > 0] whileTrue: [		"Look for a CMPLWI FF, 6 instrs back"	       ((code at: i - delta) bitAnd: 16rFFE0FFFF) = 16r280000FF ifTrue: [	       	"Copy dispatch instrs back over the compare"			SelectionMenu notify: 'Patching at ', i hex.			0 to: delta - 2 do: [ :j |				code at: (i - delta) + j put: (code at: (i - delta) + j + 2).			].		].	].	f position: 0; nextPutAll: code; nextPutAll: remnant.	f close.! !!DynamicInterpreter class methodsFor: 'translation' stamp: 'ikp 1/7/98 04:06'!translate: fileName doInlining: inlineFlag doAssertions: assertionFlag	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: false doAssertions: false.		Smalltalk beep]"	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: false doAssertions: true.		Smalltalk beep]"	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: true doAssertions: true.		Smalltalk beep]"	"Time millisecondsToRun: [		DynamicInterpreter translate: 'translator.c' doInlining: true doAssertions: false.		Smalltalk beep]"	self	translate: fileName		doInlining: inlineFlag		doAssertions: assertionFlag		fromClasses: (OrderedCollection new				add: BitBltSimulation;				add: ObjectMemory;				add: DynamicInterpreterState;				add: DynamicContextCache;				add: DynamicTranslator;				add: DynamicInterpreter;			yourself)! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 1/7/98 03:10'!browseUnreferencedClassVars	"DynamicInterpreter browseUnreferencedClassVars"	| msgList users pool unrefed classList |	classList _ DynamicInterpreterSimulator allSuperclasses remove: Object; yourself.	unrefed _ Dictionary new.	msgList _ OrderedCollection new.	classList do: [:thisClass |		pool _ thisClass classPool.		('Checking ' , thisClass printString , '...')			displayProgressAt: Sensor cursorPoint			from: 1 to: pool size			during: [:bar |			thisClass classPool keys doWithIndex: [:key :idx |				bar value: idx.				users _ Set new.				classList do: [:thatClass |					users addAll: ((thatClass whichSelectorsReferTo: (pool associationAt: key))						collect: [:sel | thatClass name , ' ' , sel , '  (' , key , ')']).					users addAll: ((thatClass class whichSelectorsReferTo: (pool associationAt: key))						collect: [:sel | thatClass class name , ' ' , sel , '  (' , key , ')'])].				users isEmpty					ifTrue: [unrefed add: (pool associationAt: key)]					ifFalse: [users size < 2 ifTrue: [msgList addAll: users]]]]].	unrefed isEmpty		ifTrue: [PopUpMenu notify: 'no unreferenced class vars']		ifFalse: [(PopUpMenu confirm: 'inspect unrefed?')					ifTrue: [unrefed inspect]].	Smalltalk browseMessageList: msgList asSortedCollection name: 'suspicious class vars'.! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 1/7/98 03:36'!browseUnreferencedInstVars	"DynamicInterpreter browseUnreferencedInstVars"	| instList unrefed classList |	classList _ DynamicInterpreterSimulator withAllSuperclasses remove: Object; yourself.	unrefed _ DynamicInterpreterSimulator allInstVarNames asSet.	classList do: [:thisClass |		instList _ unrefed asArray.		('Checking' , thisClass name , '...')			displayProgressAt: Sensor cursorPoint			from: 1 to: instList size			during: [:bar |				instList doWithIndex: [:instVar :index |					bar value: index.					(thisClass whichSelectorsAccess: instVar) isEmpty						ifFalse: [unrefed remove: instVar]]]].	unrefed isEmpty		ifTrue: [PopUpMenu notify: 'no unreferenced inst vars']		ifFalse: [unrefed inspect]! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 1/1/98 19:35'!browseUnsentMessages	"DynamicInterpreter browseUnsentMessages"	| sent destClasses sourceClasses unsent |	destClasses _ { DynamicInterpreter. DynamicTranslator. DynamicContextCache }.	sourceClasses _ destClasses , { BitBltSimulation. ObjectMemory. DynamicInterpreterSimulator }.	sent _ IdentitySet new.	sourceClasses do: [:cls |		cls selectors do: [:sel |			sent addAll: ((cls compiledMethodAt: sel) literals select: [:lit | lit isMemberOf: Symbol])]].	sent		addAll: DynamicInterpreter primitiveTable;		addAll: DynamicInterpreter translationTable;		addAll: DynamicInterpreter opcodeTable.	unsent _ Set new.	destClasses do: [:cls |		unsent addAll: ((cls selectors reject: [:sel | sent includes: sel])						collect: [:sel | cls name , ' ' , sel])].	Smalltalk browseMessageList: unsent asSortedCollection name: 'unused methods'.! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 1/1/98 17:22'!checkClassConflicts	"DynamicInterpreter checkClassConflicts"	"Browse source conflicts between DynamicInterpreter class and methods of the same name in Interpreter class"	| coreSrc interpSrc coreSels interpSels conflicts selector |	coreSels _ DynamicInterpreter class selectors asArray.	interpSels _ Interpreter class selectors.	conflicts _ IdentitySet new.	('Comparing source...')		displayProgressAt: Sensor cursorPoint		from: 0 to: coreSels size		during: [ :bar |			1 to: coreSels size do: [:index |				bar value: index.				selector _ coreSels at: index.				((interpSels includes: selector) and:					[coreSrc _ (DynamicInterpreter class compiledMethodAt: selector) getSourceFromFile.					interpSrc _ (Interpreter class compiledMethodAt: selector) getSourceFromFile.					coreSrc ~= interpSrc])						ifTrue: [conflicts add: 'DynamicInterpreter class ' , selector; add: 'Interpreter class ' , selector]]].	Smalltalk		browseMessageList: conflicts asSortedCollection		name: 'DynamicInterpreter class conflicts'! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 1/1/98 17:33'!checkClassDuplicates	"DynamicInterpreter checkClassDuplicates"	"Browse source conflicts in DynamicInterpreter hierarchy"	| conflicts selectors classes messages |	classes _ IdentitySet new				add: ObjectMemory;				add: DynamicInterpreterState;				add: DynamicContextCache;				add: DynamicTranslator;				add: DynamicInterpreter;				collect: [:cls | cls class].	selectors _ Bag new.	classes do: [:cls | selectors addAll: cls selectors].	conflicts _ (selectors select: [:elt | (selectors occurrencesOf: elt) > 1]) asSet.	conflicts isEmpty		ifTrue:			[PopUpMenu notify: 'No duplicates in ' , selectors size printString , ' methods']		ifFalse:			[messages _ OrderedCollection new.			 conflicts do: [:sel |				classes do: [:cls |					(cls selectors includes: sel)						ifTrue: [messages add: cls printString , ' ' , sel]]].			 Smalltalk				browseMessageList: messages asSortedCollection				name: 'DynamicInterpreter class conflicts'].	^{classes. selectors}! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 1/1/98 17:22'!checkConflicts	"DynamicInterpreter checkConflicts"	"Browse source conflicts between DynamicInterpreter and methods of the same name in Interpreter"	| coreSrc interpSrc coreSels interpSels conflicts selector |	coreSels _ DynamicInterpreter selectors asArray.	interpSels _ Interpreter selectors.	conflicts _ IdentitySet new.	('Comparing source...')		displayProgressAt: Sensor cursorPoint		from: 0 to: coreSels size		during: [ :bar |			1 to: coreSels size do: [:index |				bar value: index.				selector _ coreSels at: index.				((interpSels includes: selector) and:					[coreSrc _ (DynamicInterpreter compiledMethodAt: selector) getSourceFromFile.					interpSrc _ (Interpreter compiledMethodAt: selector) getSourceFromFile.					coreSrc ~= interpSrc])						ifTrue: [conflicts add: 'DynamicInterpreter ' , selector; add: 'Interpreter ' , selector]]].	Smalltalk		browseMessageList: conflicts asSortedCollection		name: 'DynamicInterpreter conflicts'! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 1/1/98 17:33'!checkDuplicates	"DynamicInterpreter checkDuplicates"	"Browse source conflicts in DynamicInterpreter hierarchy"	| conflicts selectors classes messages |	classes _ IdentitySet new				add: ObjectMemory;				add: DynamicInterpreterState;				add: DynamicContextCache;				add: DynamicTranslator;				add: DynamicInterpreter;				yourself.	selectors _ Bag new.	classes do: [:cls | selectors addAll: cls selectors].	conflicts _ (selectors select: [:elt | (selectors occurrencesOf: elt) > 1]) asSet.	conflicts isEmpty		ifTrue:			[PopUpMenu notify: 'No duplicates in ' , selectors size printString , ' methods']		ifFalse:			[messages _ OrderedCollection new.			 conflicts do: [:sel |				classes do: [:cls |					(cls selectors includes: sel)						ifTrue: [messages add: cls name , ' ' , sel]]].			 Smalltalk				browseMessageList: messages asSortedCollection				name: 'DynamicInterpreter conflicts'].	^{classes. selectors}! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 1/1/98 17:22'!checkErrors	"DynamicInterpreter checkErrors"	| classes messages |	classes _ (Set with: DynamicInterpreter with: DynamicContextCache with: DynamicInterpreter) asArray.	messages _ Set new.	classes do: [:aClass | messages addAll:				((aClass selectors					select: [:sel | (aClass compiledMethodAt: sel) literals includes: #error:])					collect: [:sel | aClass name , ' ' , sel])].	Smalltalk		browseMessageList: messages asSortedCollection		name: 'senders of #error: in ', classes printString		autoSelect: #error:! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 8/15/97 16:55'!checkGC		"CacheInterpreter checkGC"	"Browse all methods in the interpreter hierarchy that might provoke a GC.  Useful for checking	if oops are being made remappable in all the dangerous places."	| list |	list _ self makeGCList.	"Possible optimisation: remove any entries for methods that have no temporaries or arguments?"	Smalltalk		browseMessageList: (list at: 2)		name: 'methods susceptible to garbage collection'! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 1/1/98 17:22'!checkOverlap	"DynamicInterpreter checkOverlap"	| intSels coreSels |	intSels _ DynamicInterpreter selectors.	coreSels _ DynamicInterpreter selectors.	Smalltalk		browseMessageList: ((intSels select: [:sel | coreSels includes: sel])								collect: [:sel | 'DynamicInterpreter ' , sel]) asSortedCollection		name: 'overlapping methods'! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 1/1/98 18:32'!checkScopes: aClass	"DynamicInterpreter checkScopes: DynamicContextCache"	"DynamicInterpreter checkScopes: DynamicTranslator"	"DynamicInterpreter checkScopes: DynamicInterpreter"	"Open a message list browser on those methods that refer to	instance variables defined outside their class."	| theClass classList |	classList _ OrderedCollection new.	theClass _ aClass superclass.	[theClass = ObjectMemory]		whileFalse:			[classList add: theClass.			 theClass _ theClass superclass].	self checkScopes: aClass from: classList! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 1/1/98 18:35'!checkScopes: aClass from: classList	"DynamicInterpreter checkScopes: DynamicContextCache from: DynamicInterpreterState"	"DynamicInterpreter checkScopes: DynamicTranslator from: DynamicContextCache"	"DynamicInterpreter checkScopes: DynamicInterpreter from: DynamicContextCache"	"DynamicInterpreter checkScopes: DynamicInterpreter from: DynamicTranslator"	"DynamicInterpreter checkScopes: DynamicInterpreter from: { DynamicContextCache. DynamicTranslator }"	"Open a message list browser on those methods that refer to instance variables defined outside their class."	| foreignVars msgList refList varSet |	foreignVars _ IdentitySet new.	classList do: [:theClass | foreignVars addAll: theClass instVarNames].	refList _ Dictionary new.	varSet _ Set new.	foreignVars do: [:var |		(aClass whichSelectorsAccess: var) do: [:sel |			(refList at: sel ifAbsent: [refList at: sel put: Set new]) add: var.			varSet add: var.]].	Transcript cr; cr;		nextPutAll: 'The following inherited instance variables were referenced in ' , aClass name , ':';		crtab.	varSet asSortedCollection do: [:var | Transcript nextPutAll: var; space].	Transcript endEntry.	msgList _ Set new.	refList associationsDo: [:assoc |		msgList add: (String streamContents: [:str |			str nextPutAll: aClass name; space; nextPutAll: assoc key; nextPutAll: '  ( '.			assoc value do: [:var | str nextPutAll: var; space].			str nextPut: $)])].	Smalltalk		browseMessageList: msgList asSortedCollection		name: 'foreign inst var accesses'! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 1/1/98 18:45'!checkState		"DynamicInterpreter checkState"	"Quick check for which instance variables in InterpreterState could be moved down to Interpreter"	| classList varList okList |	classList _ Set with: DynamicContextCache with: DynamicTranslator.	varList _ DynamicInterpreterState instVarNames.	okList _ varList asSet.	classList do: [:cls |		okList removeAll: (varList select: [:var | (cls whichSelectorsAccess: var) isEmpty not])].	Transcript cr; cr; show: 'The following state is accessed only from within DynamicInterpreter:'; cr.	Transcript show: okList printString.! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 11/29/97 23:06'!checkVariables	"DynamicInterpreter checkVariables"	| vars |	vars _ IdentitySet new addAll: (				ObjectMemory instVarNames ,				DynamicContextCache instVarNames ,				DynamicInterpreter instVarNames);			yourself.	(vars select: [:var | (ObjectMemory whichSelectorsAccess: var) isEmpty							and: [(DynamicContextCache whichSelectorsAccess: var) isEmpty							and: [(DynamicInterpreter whichSelectorsAccess: var) isEmpty]]])		do: [:var | Transcript show: var; cr]! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 1/1/98 17:23'!inlineCacheInterpreter	"CacheInterpreter inlineCacheInterpreter"	"Browse all inlined methods in classes CacheInterpreter, ContextCache, and DynamicInterpreter"	Smalltalk browseMessageList: (DynamicInterpreter allCallsOn: #inline:)			name: 'CacheInterpreter senders of inline:'			autoSelect: #inline:! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 8/21/97 16:51'!inlineInterpreter	"CacheInterpreter inlineInterpreter"	"Browse all inlined methods in class Interpreter"	Smalltalk browseMessageList: (Interpreter allCallsOn: #inline:)			name: 'Interpreter senders of inline:'			autoSelect: #inline:! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 8/27/97 18:49'!quickBenchmarks	| iterations time times factor mark average result |	iterations _ 5.	factor _ 10.	times _ SortedCollection new.	Transcript cr.	iterations timesRepeat: [		Smalltalk garbageCollectMost.		time _ Time millisecondsToRun: [(10 * factor) benchmark].		mark _ 5000000 * 1000 * factor // time.		Transcript show: mark printString; space; space.		times add: mark].	average _ (times removeFirst; removeLast; inject: 0 into: [:sum :next | sum + next]) // (iterations - 2).	Transcript tab; tab; show: 'average = ' , average printString.	times _ SortedCollection new.	Transcript cr.	iterations timesRepeat: [		Smalltalk garbageCollectMost.		time _ Time millisecondsToRun: [result _ 31 benchFib].		mark _ result * 1000 // time.		Transcript show: mark printString; space; space.		times add: mark].	average _ (times removeFirst; removeLast; inject: 0 into: [:sum :next | sum + next]) // (iterations - 2).	Transcript tab; tab; show: 'average = ' , average printString.! !!DynamicInterpreter class methodsFor: 'development support' stamp: 'ikp 8/15/97 17:14'!reportGC		"CacheInterpreter reportGC"	"Report all methods in the interpreter hierarchy that might provoke a GC, giving for each a list	of the methods that it calls around which temporaries and arguments must be made remappable.	Useful for finding those obscure remapping errors in the VM: save the result, print it out, and	pin it to your wall!!	(An alternative approach is to munge the ObjectMemory into provoking a fullGC after every	allocation, then generate a VM with checks enabled -- but the result runs [in fully optimised	and gnuified C] *slower* than the InterpreterSimulator!!!! ;-)"	| list selectors break theClass theSelector dangerous result |	list _ self makeGCList.	selectors _ list at: 1.	result _ String streamContents: [:report |		(list at: 2) do: [:classAndSelector |				break _ classAndSelector indexOf: $ .			theClass _ Smalltalk at: (classAndSelector copyFrom: 1 to: break - 1) asSymbol.			theSelector _ (classAndSelector copyFrom: break + 1 to: classAndSelector size) asSymbol.			dangerous _ (theClass compiledMethodAt: theSelector) literals select: [:lit | selectors includes: lit].			dangerous isEmpty ifTrue: [self error: 'huh?'].			report nextPutAll: classAndSelector , ' --'.			dangerous do: [:dangerSelector | report space; nextPutAll: dangerSelector].			report cr]].	StringHolderView open: (StringHolder new contents: result) label: 'GC-unsafe sends'! !!DynamicInterpreter class methodsFor: 'private' stamp: 'ikp 1/1/98 17:34'!makeGCList		"DynamicInterpreter checkGC"	"Answer an Array containing all methods in the interpreter hierarchy that might provoke a GC.	It suffices to find all transitive callers of fullGC, since an incrementalGC calls this when the root	table is full."	| classList selectors newSelectors prevSize messages newMessages |	classList _ Set new				add: ObjectMemory;				add: DynamicInterpreterState;				add: DynamicContextCache;				add: DynamicTranslator;				add: DynamicInterpreter;		yourself.	selectors _ Set with: #fullGC.	messages _ Set new.	[prevSize _ selectors size.	newSelectors _ Set new.	newMessages _ Set new.	classList do: [:aClass |		aClass selectors do: [:sel |			((aClass compiledMethodAt: sel) literals detect: [:lit | selectors includes: lit] ifNone: [])				isNil ifFalse:					[newSelectors add: sel.					newMessages add: aClass name , ' ' , sel.]]].	selectors addAll: newSelectors.	messages addAll: newMessages.	newSelectors size = prevSize]		whileFalse.	^Array with: selectors asSortedCollection with: messages asSortedCollection! !!DynamicInterpreter class methodsFor: 'private' stamp: 'ikp 1/11/98 18:48'!translateTestSuite		"DynamicInterpreter translateTestSuite"	"Translate a collection of 32 source files with the various options encoded as:		D/d		- enable/disable decoding of literal frame at translation time		H/h		- enable/disable hash bits in method cache		M/m	- enable/disable macro opcodes		I/i		- enable/disable inline cache		E/e		- enable/disable eager flush"		| enabled disabled code |	FreezeConfiguration _ true.	enabled _ 'DHMIE'.	disabled _ 'dhmie'.	0 to: 31 do: [:flags |		code _ 'xxxxx'.		code at: 1 put: (((EagerInlineCacheFlush _ (flags bitAnd: 1) = 1)			ifTrue: [enabled] ifFalse: [disabled]) at: 1).		code at: 2 put: (((UseInlineCache _ (flags bitAnd: 2) = 2)			ifTrue: [enabled] ifFalse: [disabled]) at: 2).		code at: 3 put: (((UseMacroOpcodes _ (flags bitAnd: 4) = 4)			ifTrue: [enabled] ifFalse: [disabled]) at: 3).		code at: 4 put: (((UseMethodCacheHashBits _ (flags bitAnd: 8) = 8)			ifTrue: [enabled] ifFalse: [disabled]) at: 4).		code at: 5 put: (((DecodeLiteralConstants _ (flags bitAnd: 16) = 16)			ifTrue: [enabled] ifFalse: [disabled]) at: 5).		DecodeLiteralSelectors	_ DecodeLiteralConstants.		DecodeLiteralVariables	_ DecodeLiteralConstants.		Transcript cr; print: flags; tab; show: 'translating ' , code; tab.		Transcript print: (Time millisecondsToRun: [			self translate: 'translator-' , code , '.c'				doInlining: true				doAssertions: false]).	].	FreezeConfiguration _ false.	self initializeConfiguration.! !DynamicInterpreterSimulator class comment:'This class defines basic memory access and primitive simulation so that the Interpreter can run simulated in the Squeak environment.  It also defines a number of handy object viewing methods to facilitate pawing around in the object memory.To see the thing actually run, you could (after backing up this image and changes), execute	(InterpreterSimulator new openOn: Smalltalk imageName) testand be patient both to wait for things to happen, and to accept various things that may go wrong depending on how large or unusual your image may be.  We usually do this with a small and simple benchmark image.'!!DynamicInterpreterSimulator methodsFor: 'initialization'!close  "close any files that ST may have opened"	filesOpen do: [:f | f setToEnd; close]! !!DynamicInterpreterSimulator methodsFor: 'initialization' stamp: 'ikp 1/3/98 22:12'!initBBOpTable	^ myBitBlt initBBOpTable! !!DynamicInterpreterSimulator methodsFor: 'initialization' stamp: 'ikp 1/5/98 18:20'!initialize	"Initialize the InterpreterSimulator when running the interpreter inside Smalltalk. The primary responsibility of this method is to allocate Smalltalk Arrays for variables that will be declared as statically-allocated global arrays in the translated code."	"initialize class variables"	self class initialize.	methodCache _ Array new: MethodCacheSize.	rootTable _ Array new: RootTableSize.	remapBuffer _ Array new: RemapBufferSize.	semaphoresToSignal _ Array new: SemaphoresToSignalSize.	"initialize InterpreterSimulator variables used for debugging"	byteCount _ 0.	sendCount _ 0.	gcCount _ 0.	traceOn _ true.	myBitBlt _ BitBltSimulator new setInterpreter: self.	displayForm _ nil.  "displayForm is created in response to primitiveBeDisplay"	filesOpen _ OrderedCollection new.! !!DynamicInterpreterSimulator methodsFor: 'initialization' stamp: 'ikp 12/7/97 13:29'!initializeOpcodeTable	opcodeTable _ Array new: OpcodeTableSize + 1! !!DynamicInterpreterSimulator methodsFor: 'initialization' stamp: 'ikp 1/5/98 22:47'!initializeSendTables	shortSendTable			_ Array new: 3.	extendedSendTable		_ Array new: 3.	doubleExtendedSendTable	_ Array new: 3.	super initializeSendTables.! !!DynamicInterpreterSimulator methodsFor: 'initialization' stamp: 'ikp 12/10/97 19:23'!initOpcode: index	super initOpcode: index.	self assert: opcodeAddress == (self integerObjectOf: index - 1)! !!DynamicInterpreterSimulator methodsFor: 'initialization'!nextLongFrom: aStream	"Read a 32-bit quantity from the given (binary) stream."	| bytes |	bytes _ aStream nextInto: (ByteArray new: 4).	^ Integer		byte1: (bytes at: 4)		byte2: (bytes at: 3)		byte3: (bytes at: 2)		byte4: (bytes at: 1)! !!DynamicInterpreterSimulator methodsFor: 'initialization' stamp: 'ikp 10/22/97 18:26'!nextLongFrom: aStream swap: swapFlag	swapFlag 		ifTrue: [^ self byteSwapped: (self nextLongFrom: aStream)]		ifFalse: [^ self nextLongFrom: aStream]! !!DynamicInterpreterSimulator methodsFor: 'initialization' stamp: 'ikp 1/7/98 03:56'!openOn: fileName	"(DynamicInterpreterSimulator new openOn: 'clone.image') test"	self openOn: fileName extraMemory: 1000000.! !!DynamicInterpreterSimulator methodsFor: 'initialization' stamp: 'ikp 11/30/97 20:38'!openOn: fileName extraMemory: extraBytes	"InterpreterSimulator new openOn: 'clone.im' extraMemory: 100000"	| f version headerSize count oldBaseAddr bytesToShift swapBytes totalMemory |	"open image file and read the header"	checkAssertions _ false.	f _ FileStream oldFileNamed: fileName.	imageName _ f fullName.	f binary; readOnly.	version _ self nextLongFrom: f.  "current version: 16r1966 (=6502)"	version = self imageFormatVersion		ifTrue: [swapBytes _ false]		ifFalse: [(version _ self byteSwapped: version) = self imageFormatVersion					ifTrue: [swapBytes _ true]					ifFalse: [self error: 'incomaptible image format']].	headerSize _ self nextLongFrom: f swap: swapBytes.	endOfMemory _ self nextLongFrom: f swap: swapBytes.  "first unused location in heap"	oldBaseAddr _ self nextLongFrom: f swap: swapBytes.  "object memory base address of image"	specialObjectsOop _ self nextLongFrom: f swap: swapBytes.	lastHash _ self nextLongFrom: f swap: swapBytes.  "Should be loaded from, and saved to the image header"	savedWindowSize _ self nextLongFrom: f swap: swapBytes.	lastHash = 0 ifTrue: [lastHash _ 999].	"allocate interpreter memory"	contextCacheEntries = nil ifTrue: [contextCacheEntries _ ContextCacheEntries].	stackCacheEntries = nil ifTrue: [stackCacheEntries _ StackCacheEntries].	memoryLimit _ endOfMemory + extraBytes.	totalMemory _ memoryLimit + self cacheSize.	"read in the image in bulk, then swap the bytes if necessary"	f position: headerSize.	memory _ Bitmap new: totalMemory // 4.	count _ f readInto: memory startingAt: 1 count: endOfMemory // 4.	count ~= (endOfMemory // 4) ifTrue: [self halt].	f close.	swapBytes ifTrue: [Utilities informUser: 'Swapping bytes of foreign image...'								during: [self reverseBytesInImage]].	self initialize.	bytesToShift _ 0 - oldBaseAddr.  "adjust pointers for zero base address"	endOfMemory _ endOfMemory.	self initializeCache: memoryLimit.	Utilities informUser: 'Relocating object pointers...'				during: [self initializeInterpreter: bytesToShift].	checkAssertions _ false.! !!DynamicInterpreterSimulator methodsFor: 'initialization' stamp: 'ikp 10/22/97 18:25'!reverseBytesFrom: begin to: end	"Byte-swap the given range of memory (not inclusive!!)."	| wordAddr |	wordAddr _ begin.	memory swapBytesFrom: wordAddr // 4 + 1 to: end // 4! !!DynamicInterpreterSimulator methodsFor: 'initialization'!startOfMemory	"Return the start of object memory."	^ 0! !!DynamicInterpreterSimulator methodsFor: 'utilities' stamp: 'ikp 12/24/97 20:34'!offsetObjectOf: offsetValue	"Overridden in the simulator since we can't store negative integers into the memory.	Note: a bias of 16r20000000 avoids LargeInteger arithmetic."	self assert: ((offsetValue bitAnd: 1) = 0).	self assert: (offsetValue < (1024 * 8) and: [offsetValue > (-1024 * 8)]).	^16r20000000 + offsetValue + 1! !!DynamicInterpreterSimulator methodsFor: 'utilities' stamp: 'ikp 12/24/97 20:34'!offsetValueOf: offsetObject	"Overridden in the simulator since we can't store negative integers into the memory.	Note: a bias of 16r20000000 avoids LargeInteger arithmetic."	| offset |	self assertIsIntegerObject: offsetObject.	offset _ offsetObject - 16r20000000 - 1.	self assert: (offset < (1024 * 8) and: [offset > (-1024 * 8)]).	^offset! !!DynamicInterpreterSimulator methodsFor: 'testing'!findNewMethodInClass: class"	| cName |	traceOn ifTrue:		[cName _ (self sizeBitsOf: class) = 16r20			ifTrue: ['class ' , (self nameOfClass: (self fetchPointer: 6 ofObject: class))]			ifFalse: [(self nameOfClass: class)].		self cr; print: cName , '>>' , (self stringOf: messageSelector)].""(self stringOf: messageSelector) = 'raisedToInteger:' ifTrue: [self halt]."	sendCount _ sendCount + 1.	super findNewMethodInClass: class.! !!DynamicInterpreterSimulator methodsFor: 'testing' stamp: 'ikp 12/25/97 04:41'!profileSends: nBytecodes	"(DynamicInterpreterSimulatorLSB new openOn: 'devel-1.3.image') profileSends: 5000"	Transcript clear.	InterpreterLog close.	byteCount _ 0.	Transcript show: (Time millisecondsToRun: [MessageTally tallySendsTo: self		inBlock:				[self internalizeIPandSP.				[byteCount < nBytecodes] whileTrue:					[currentBytecode _ self fetchInstruction.					self dispatchOn: currentBytecode in: OpcodeTable.					byteCount _ byteCount + 1].				self externalizeIPandSP]		showTree: true]) printString.! !!DynamicInterpreterSimulator methodsFor: 'testing' stamp: 'ikp 9/29/97 21:37'!stats	| oop fieldAddr fieldOop last ints ints100 ints1000 fields ints10 spl v intsM100 intsM1000 rel100 rel1000 relM100 relM1000 d |	Transcript show: 'Taking stats...'.	ints _ fields _ 0.	ints10 _ ints100 _ ints1000 _ intsM100 _ intsM1000 _ 0.	rel100 _ rel1000 _ relM100 _ relM1000 _ 0.	spl _ Bag new.	oop _ self firstObject.	[oop < endOfMemory] whileTrue:		[(self isFreeObject: oop) ifFalse:			[fieldAddr _ oop + (self lastPointerOf: oop).			[fieldAddr > oop] whileTrue:				[fieldOop _ self longAt: fieldAddr.				fields _ fields + 1.				(self isIntegerObject: fieldOop)					ifTrue: [v _ self integerValueOf: fieldOop.							ints _ ints + 1.							(v between: 0 and: 10) ifTrue: [ints10 _ ints10 + 1].							(v between: 0 and: 100) ifTrue: [ints100 _ ints100 + 1].							(v between: 0 and: 1000) ifTrue: [ints1000 _ ints1000 + 1].							(v between: -100 and: -1) ifTrue: [intsM100 _ intsM100 + 1].							(v between: -1000 and: -1) ifTrue: [intsM1000 _ intsM1000 + 1]]					ifFalse: [fieldOop = nilObj ifTrue: [spl add: fieldOop].							fieldOop = falseObj ifTrue: [spl add: fieldOop].							fieldOop = trueObj ifTrue: [spl add: fieldOop].							d _ fieldOop - oop.							(d between: 0 and: 100) ifTrue: [rel100 _ rel100 + 1].							(d between: 0 and: 1000) ifTrue: [rel1000 _ rel1000 + 1].							(d between: -100 and: -1) ifTrue: [relM100 _ relM100 + 1].							(d between: -1000 and: -1) ifTrue: [relM1000 _ relM1000 + 1]].				fieldAddr _ fieldAddr - 4]].		last _ oop.		oop _ self objectAfter: oop].	Transcript show: 'done.'; cr.	^ (Array with: fields with: ints with: ints10) ,		(Array with: ints100 with: ints1000 with: intsM100 with: intsM1000) ,		(Array with: rel100 with: rel1000 with: relM100 with: relM1000) ,		(Array with: spl sortedElements)! !!DynamicInterpreterSimulator methodsFor: 'testing'!testBecome	"Become some young things.  AA testBecome    "	| array list1 list2 p1 p2 p3 p4 |	array _ self splObj: ClassArray.	list1 _ self instantiateClass: array indexableSize: 2.	list2 _ self instantiateClass: array indexableSize: 2.	p1 _ self instantiateClass: (self splObj: ClassPoint) indexableSize: 0.	self push: p1.	self storePointer: 0 ofObject: list1 withValue: p1.	p2 _ self instantiateClass: (self splObj: ClassPoint) indexableSize: 0.	self push: p2.	self storePointer: 1 ofObject: list1 withValue: p2.	p3 _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	self push: p3.	self storePointer: 0 ofObject: list2 withValue: p3.	p4 _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	self push: p4.	self storePointer: 1 ofObject: list2 withValue: p4.	(self become: list1 with: list2) ifFalse: [self error: 'failed'].	self popStack = p2 ifFalse: [self halt].	self popStack = p1 ifFalse: [self halt].	self popStack = p4 ifFalse: [self halt].	self popStack = p3 ifFalse: [self halt].	(self fetchPointer: 0 ofObject: list1) = p3 ifFalse: [self halt].	(self fetchPointer: 1 ofObject: list1) = p4 ifFalse: [self halt].	(self fetchPointer: 0 ofObject: list2) = p1 ifFalse: [self halt].	(self fetchPointer: 1 ofObject: list2) = p2 ifFalse: [self halt].! !!DynamicInterpreterSimulator methodsFor: 'testing'!validate	| oop prev |	Transcript show: 'Validating...'.	oop _ self firstObject.	[oop < endOfMemory] whileFalse: [		self validate: oop.		prev _ oop.  "look here if debugging prev obj overlapping this one"		oop _ self objectAfter: oop.	].	Transcript show: 'done.'; cr! !!DynamicInterpreterSimulator methodsFor: 'testing' stamp: 'ikp 9/29/97 21:38'!validate: oop	| header type cc sz fmt nextChunk | 	header _ self longAt: oop.	type _ header bitAnd: 3.	type = 2 ifFalse: [type = (self rightType: header) ifFalse: [self halt]].	sz _ (header >> 2) bitAnd: 16r3F.	(self isFreeObject: oop)		ifTrue: [ nextChunk _ oop + (self sizeOfFree: oop) ]		ifFalse: [  nextChunk _ oop + (self sizeBitsOf: oop) ].	nextChunk > endOfMemory		ifTrue: [oop = endOfMemory ifFalse: [self halt]].	(self headerType: nextChunk) = 0 ifTrue: [		(self headerType: (nextChunk + 8)) = 0 ifFalse: [self halt]].	(self headerType: nextChunk) = 1 ifTrue: [		(self headerType: (nextChunk + 4)) = 1 ifFalse: [self halt]].	type = 2 ifTrue:		["free block" ^ self].	fmt _ (header >> 8) bitAnd: 16rF.	cc _ (header >> 12) bitAnd: 31.	cc > 15 ifTrue: [self halt].	type = 0 ifTrue:		["three-word header"		((self longAt: oop-4) bitAnd: 3) = type ifFalse: [self halt].		((self longAt: oop-8) bitAnd: 3) = type ifFalse: [self halt].		((self longAt: oop-4) = type) ifTrue: [self halt].	"Class word is 0"		sz = 0 ifFalse: [self halt]].	type = 1 ifTrue:		["two-word header"		((self longAt: oop-4) bitAnd: 3) = type ifFalse: [self halt].		cc > 0 ifTrue: [sz = 1 ifFalse: [self halt]].		sz = 0 ifTrue: [self halt]].	type = 3 ifTrue:		["one-word header"		cc = 0 ifTrue: [self halt]].	fmt = 4 ifTrue: [self halt].	fmt = 5 ifTrue: [self halt].	fmt = 7 ifTrue: [self halt].	fmt >= 12 ifTrue:		["CompiledMethod -- check for integer header"		(self isIntegerObject: (self longAt: oop + 4)) ifFalse: [self halt]].! !!DynamicInterpreterSimulator methodsFor: 'testing'!validateOopsIn: object	| fieldPtr limit former header | 	"for each oop in me see if it is legal"	fieldPtr _ object + BaseHeaderSize.	"first field"	limit _ object + (self lastPointerOf: object).	"a good field"	[fieldPtr > limit] whileFalse: [		former _ self longAt: fieldPtr.		self validOop: former.		fieldPtr _ fieldPtr + 4].	"class"	header _ self baseHeader: object.	(header bitAnd: 16r1F000 "compact class bits") = 0 ifTrue: [			former _ (self classHeader: object) bitAnd: 16rFFFFFFFC.		self validOop: former].! !!DynamicInterpreterSimulator methodsFor: 'testing'!validOop: oop	"halt if invalid active object"	(oop bitAnd: 1) = 1 ifTrue: [^ self].	(oop bitAnd: 3) = 0 ifFalse: [self halt].	oop >= endOfMemory ifTrue: [self halt].	"could test if within the first large freeblock"	(self longAt: oop) = 4 ifTrue: [self halt].	(self headerType: oop) = 2 ifTrue: [self halt].	"free object"! !!DynamicInterpreterSimulator methodsFor: 'debug printing'!cr	traceOn ifTrue: [ Transcript cr; endEntry ].! !!DynamicInterpreterSimulator methodsFor: 'debug printing' stamp: 'ikp 12/30/97 00:28'!debugPrint: string	"Transcript show: string."! !!DynamicInterpreterSimulator methodsFor: 'debug printing'!print: s	traceOn ifTrue: [ Transcript show: s ]! !!DynamicInterpreterSimulator methodsFor: 'debug printing'!printChar: aByte	traceOn ifTrue: [ Transcript nextPut: aByte asCharacter ].! !!DynamicInterpreterSimulator methodsFor: 'debug printing'!printNum: anInteger	traceOn ifTrue: [ Transcript show: anInteger printString ].! !!DynamicInterpreterSimulator methodsFor: 'debug support'!charsOfLong: long	^ (4 to: 1 by: -1) collect:		[:i | ((long digitAt: i) between: 14 and: 126)					ifTrue: [(long digitAt: i) asCharacter]					ifFalse: [$?]]! !!DynamicInterpreterSimulator methodsFor: 'debug support'!classAndSelectorOfMethod: meth forReceiver: rcvr	| mClass dict length methodArray |	mClass _ self fetchClassOf: rcvr.	[dict _ self fetchPointer: MessageDictionaryIndex ofObject: mClass.	length _ self fetchWordLengthOf: dict.	methodArray _ self fetchPointer: MethodArrayIndex ofObject: dict.	0 to: length-SelectorStart-1 do: 		[:index | 		meth = (self fetchPointer: index ofObject: methodArray) 			ifTrue: [^ Array				with: mClass				with: (self fetchPointer: index + SelectorStart ofObject: dict)]].	mClass _ self fetchPointer: SuperclassIndex ofObject: mClass.	mClass = nilObj]		whileFalse: [].	^ Array		with: (self fetchClassOf: rcvr)		with: (self splObj: SelectorDoesNotUnderstand)! !!DynamicInterpreterSimulator methodsFor: 'debug support'!compactClassAt: ccIndex	"Index must be between 1 and compactClassArray size. (A zero compact class index in the base header indicate that the class is in the class header word.)"	| classArray |	classArray _ self fetchPointer: CompactClasses ofObject: specialObjectsOop.	^ self fetchPointer: (ccIndex - 1) ofObject: classArray! !!DynamicInterpreterSimulator methodsFor: 'debug support'!dumpHeader: hdr	| cc |	^ String streamContents:		[:strm |		strm nextPutAll: '<cc=', (cc_ (hdr >> 12) bitAnd: 16r1F) hex.			cc > 0 ifTrue:				[strm nextPutAll: ':' , (self nameOfClass: (self compactClassAt: cc))].			strm nextPutAll: '>'.		strm nextPutAll: '<ft=', ((hdr bitShift: -8) bitAnd: 16rF) hex , '>'.		strm nextPutAll: '<sz=', (hdr bitAnd: 16rFC) hex , '>'.		strm nextPutAll: '<hdr=', (#(big class gcMark short) at: (hdr bitAnd: 3) +1) , '>'.		]! !!DynamicInterpreterSimulator methodsFor: 'debug support'!dumpMethodHeader: hdr	^ String streamContents:		[:strm |		strm nextPutAll: '<nArgs=', ((hdr >> 25) bitAnd: 16r1F) printString , '>'.		strm nextPutAll: '<nTemps=', ((hdr >> 19) bitAnd: 16r3F) printString , '>'.		strm nextPutAll: '<lgCtxt=', ((hdr >> 18) bitAnd: 16r1) printString , '>'.		strm nextPutAll: '<nLits=', ((hdr >> 10) bitAnd: 16rFF) printString , '>'.		strm nextPutAll: '<prim=', ((hdr >> 1) bitAnd: 16r1FF) printString , '>'.		]! !!DynamicInterpreterSimulator methodsFor: 'debug support'!headerStart: oop	^ (self extraHeaderBytes: oop) negated! !!DynamicInterpreterSimulator methodsFor: 'debug support'!hexDump100: oop	| byteSize val |	^ String streamContents:		[:strm |		byteSize _ 256.		(self headerStart: oop) to: byteSize by: 4 do:			[:a | val _ self longAt: oop+a.			strm cr; nextPutAll: (oop+a) hex8; space; space; 				nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8;				space; space.			strm nextPutAll: (self charsOfLong: val).			strm space; space; nextPutAll: (oop+a) printString]]! !!DynamicInterpreterSimulator methodsFor: 'debug support'!hexDump: oop	| byteSize val |	(self isIntegerObject: oop) ifTrue: [^ self shortPrint: oop].	^ String streamContents:		[:strm |		byteSize _ 256 min: (self sizeBitsOf: oop)-4.		(self headerStart: oop) to: byteSize by: 4 do:			[:a | val _ self longAt: oop+a.			strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8;				space; space.			a=0				ifTrue: [strm nextPutAll: (self dumpHeader: val)]				ifFalse: [strm nextPutAll: (self charsOfLong: val)]]]! !!DynamicInterpreterSimulator methodsFor: 'debug support'!longPrint: oop	| lastPtr val lastLong hdrType prevVal |	(self isIntegerObject: oop) ifTrue: [^ self shortPrint: oop].	^ String streamContents:		[:strm |		lastPtr _ 256 min: (self lastPointerOf: oop).		hdrType _ self headerType: oop.		hdrType = 2 ifTrue: [lastPtr _ 0].		prevVal _ 0.		(self headerStart: oop) to: lastPtr by: 4 do:			[:a | val _ self longAt: oop+a.			(a > 0 and: [(val = prevVal) & (a ~= lastPtr)])			ifTrue:			[prevVal = (self longAt: oop+a-8) ifFalse: [strm cr; nextPutAll: '        ...etc...']]			ifFalse:			[strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8; space; space.			a=-8 ifTrue: [strm nextPutAll: 'size = ' , (val - hdrType) hex].			a=-4 ifTrue: [strm nextPutAll: '<' , (self nameOfClass: (val - hdrType)) , '>'].			a=0 ifTrue: [strm cr; tab; nextPutAll: (self dumpHeader: val)].			a>0 ifTrue: [strm nextPutAll: (self shortPrint: val)].			a=4 ifTrue: [(self fetchClassOf: oop) = (self splObj: ClassCompiledMethod) ifTrue:							[strm cr; tab; nextPutAll: (self dumpMethodHeader: val)]]].			prevVal _ val].		lastLong _ 256 min: (self sizeBitsOf: oop) - 4.		hdrType = 2			ifTrue: ["free" strm cr; nextPutAll: (oop+(self longAt: oop)-2) hex;				space; space; nextPutAll: (oop+(self longAt: oop)-2) printString]			ifFalse: [lastPtr+4 to: lastLong by: 4 do:				[:a | val _ self longAt: oop+a.				strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 					space; space; space.				strm nextPutAll: val hex8; space; space;						nextPutAll: (self charsOfLong: val)]].	]! !!DynamicInterpreterSimulator methodsFor: 'debug support'!nameOfClass: classOop	(self sizeBitsOf: classOop) = 16r20 ifTrue:		[^ (self nameOfClass:				(self fetchPointer: 6 "thisClass" ofObject: classOop)) , ' class'].	^ self stringOf: (self fetchPointer: 6 "name" ofObject: classOop)! !!DynamicInterpreterSimulator methodsFor: 'debug support'!shortPrint: oop	| name classOop |	(self isIntegerObject: oop) ifTrue: [^ '=' , (self integerValueOf: oop) printString , ' (' , (self integerValueOf: oop) hex , ')'].	classOop _ self fetchClassOf: oop.	(self sizeBitsOf: classOop) =16r20 ifTrue: [^ 'class ' , (self nameOfClass: oop)].	name _ self nameOfClass: classOop.	name size = 0 ifTrue: [name _ '??'].	name = 'String' ifTrue: [^ (self stringOf: oop) printString].	name = 'Symbol' ifTrue: [^ '#' , (self stringOf: oop)].	name = 'Character' ifTrue: [^ '=' ,			(Character value: (self integerValueOf: (self fetchPointer: 0 ofObject: oop))) printString].	name = 'UndefinedObject' ifTrue: [^ 'nil'].	name = 'False' ifTrue: [^ 'false'].	name = 'True' ifTrue: [^ 'true'].	name = 'Float' ifTrue: [^ '=' , (self floatValueOf: oop) printString].	name = 'Association' ifTrue: [^ '(' ,				(self shortPrint: (self longAt: oop + BaseHeaderSize)) ,				' -> ' ,				(self longAt: oop + BaseHeaderSize + 4) hex8 , ')'].	('AEIOU' includes: name first)		ifTrue: [^ 'an ' , name]		ifFalse: [^ 'a ' , name]! !!DynamicInterpreterSimulator methodsFor: 'debug support'!stringOf: oop	| size long nLongs chars |	^ String streamContents:		[:strm |		size _ 100 min: (self stSizeOf: oop).		nLongs _ size-1//4+1.		1 to: nLongs do:			[:i | long _ self longAt: oop + BaseHeaderSize + (i-1*4).			chars _ self charsOfLong: long.			strm nextPutAll: (i=nLongs							ifTrue: [chars copyFrom: 1 to: size-1\\4+1]							ifFalse: [chars])]]! !!DynamicInterpreterSimulator methodsFor: 'debug extras' stamp: 'ikp 8/18/97 01:02'!clearTranscript	Transcript		clear;		nextPutAll:	'context cache at ' , contextCache printString ,					', size ' , contextCacheEntries printString ,					' length ' , self contextCacheSize printString; cr;		nextPutAll:	'stack cache at ' , stackCache printString ,					', size ' , stackCacheEntries printString ,					' length ' , self stackCacheSize printString; cr;		endEntry.! !!DynamicInterpreterSimulator methodsFor: 'debug extras' stamp: 'ikp 8/17/97 19:14'!dumpCachedContext: aContext	| sp ip rcvr elt lo hi |	sp _ self cachedStackIndexAt: aContext.	ip _ self cachedInstructionIndexAt: aContext.	rcvr _ (self isCachedMethodContext: aContext)				ifTrue: [self cachedReceiverAt: aContext]				ifFalse: [0].	^String streamContents: [:str |		str	nextPutAll: (self printCachedContext: aContext); cr;			nextPutAll: '	ip		'	, (self shortPrint: ip); cr;			nextPutAll: '	sp		'	, (self shortPrint: sp); cr.		rcvr = 0 ifFalse: [str nextPutAll: ' 	rcvr	'	, (self shortPrint: rcvr); cr].		str nextPutAll: '	stack	{ '.		lo _ self cachedFramePointerAt: aContext.		hi _ self cachedStackPointerAt: aContext.		lo to: hi by: 4 do: [ :ptr |			elt _ self longAt: ptr.			str nextPutAll: (self shortPrint: elt).			ptr == hi ifFalse: [str cr; nextPutAll: '			  '].		].		str nextPutAll: ' }'.].! !!DynamicInterpreterSimulator methodsFor: 'debug extras' stamp: 'ikp 8/12/97 13:22'!dumpStableBlockContext: aContext	| sp ip isp elt home |	sp _ self fetchPointer: StackPointerIndex ofObject: aContext.	ip _ self fetchPointer: InstructionPointerIndex ofObject: aContext.	home _ self fetchPointer: HomeIndex ofObject: aContext.	^String streamContents: [:str |		str	nextPutAll: (self printStableContext: aContext); cr;			nextPutAll: '	ip		'	, (self shortPrint: ip); cr;			nextPutAll: '	sp		'	, (self shortPrint: sp); cr;			nextPutAll: '	stack	{ '.		isp _ self integerValueOf: sp.		0 to: isp - 1 do: [ :off |			elt _ self fetchPointer: off + TempFrameStart ofObject: aContext.			str nextPutAll: (self shortPrint: elt).			off == (isp - 1) ifFalse: [str cr; nextPutAll: '			  '].		].		str nextPutAll: ' }'; cr; nextPutAll: '	home	' , (self dumpStableContext: home).].! !!DynamicInterpreterSimulator methodsFor: 'debug extras' stamp: 'ikp 8/11/97 16:48'!dumpStableContext: aContext	(self isMethodContext: aContext)		ifTrue: [^self dumpStableMethodContext: aContext]		ifFalse: [^self dumpStableBlockContext: aContext]! !!DynamicInterpreterSimulator methodsFor: 'debug extras' stamp: 'ikp 8/12/97 13:22'!dumpStableMethodContext: aContext	| sp ip rcvr isp elt |	sp _ self fetchPointer: StackPointerIndex ofObject: aContext.	ip _ self fetchPointer: InstructionPointerIndex ofObject: aContext.	rcvr _ self fetchPointer: ReceiverIndex ofObject: aContext.	^String streamContents: [:str |		str	nextPutAll: (self printStableContext: aContext); cr;			nextPutAll: '	ip		'	, (self shortPrint: ip); cr;			nextPutAll: '	sp		'	, (self shortPrint: sp); cr;			nextPutAll: ' 	rcvr	'	, (self shortPrint: rcvr); cr;			nextPutAll: '	stack	{ '.		isp _ self integerValueOf: sp.		0 to: isp - 1 do: [ :off |			elt _ self fetchPointer: off + TempFrameStart ofObject: aContext.			str nextPutAll: (self shortPrint: elt).			off == (isp - 1) ifFalse: [str cr; nextPutAll: '			  '].		].		str nextPutAll: ' }'.].! !!DynamicInterpreterSimulator methodsFor: 'debug extras' stamp: 'ikp 8/11/97 16:45'!dumpStack	| ctx stable |	^String streamContents: [:strm |		ctx _ activeCachedContext.		stable _ 0.		[stable == 0] whileTrue: [			strm nextPutAll: '* ' , (self dumpCachedContext: ctx); cr.			ctx == lowestCachedContext ifTrue: [stable _ self cachedSenderAt: ctx].			ctx _ self cachedContextBefore: ctx.		].		[stable == nilObj] whileFalse: [			strm nextPutAll: '+ ', (self dumpStableContext: stable); cr.			stable _ self fetchPointer: SenderIndex ofObject: stable.		].	].! !!DynamicInterpreterSimulator methodsFor: 'debug extras' stamp: 'ikp 8/13/97 13:47'!error: reason	| backtrace |	backtrace _ 'VM panic: ' , reason , ''", self dumpStack".	InterpreterLog show: backtrace.	InterpreterLog isTranscript ifFalse: [Transcript show: backtrace].	super error: 'VM panic: ' , reason! !!DynamicInterpreterSimulator methodsFor: 'debug extras' stamp: 'ikp 12/21/97 16:09'!instructionIndex: ip	^self integerValueOf:		(self translatedInstructionPointer: ip toIndexIn: (self translatedMethod))! !!DynamicInterpreterSimulator methodsFor: 'debug extras' stamp: 'ikp 8/17/97 00:58'!printCachedContext: aContext	| classAndSel meth recv |	^ String streamContents: [:strm |		"Find receiver and method"		meth _ self cachedMethodAt: aContext.		recv _ self cachedReceiverAt: aContext.		classAndSel _ self classAndSelectorOfMethod: meth forReceiver: recv.		(self isCachedBlockContext: aContext) ifTrue: [strm nextPutAll: '[] in '].		strm nextPutAll: (self nameOfClass: classAndSel first).		strm nextPutAll: '>>'; nextPutAll: (self shortPrint: classAndSel last).]! !!DynamicInterpreterSimulator methodsFor: 'debug extras' stamp: 'ikp 8/12/97 13:22'!printStableContext: aContext	| classAndSel home |	^ String streamContents: [:strm |		home _ (self fetchClassOf: aContext) = (self splObj: ClassBlockContext)			ifTrue: [self fetchPointer: HomeIndex ofObject: aContext]			ifFalse: [aContext].		classAndSel _ self			classAndSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)			forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		aContext = home ifFalse: [strm nextPutAll: '[] in '].		strm nextPutAll: (self nameOfClass: classAndSel first).		strm nextPutAll: '>>'; nextPutAll: (self shortPrint: classAndSel last).]! !!DynamicInterpreterSimulator methodsFor: 'debug extras' stamp: 'ikp 8/13/97 12:48'!singleStep	| panic |	Transcript endEntry.	Sensor waitButton.	panic _ Sensor blueButtonPressed.	Sensor waitNoButton.	panic ifTrue: [self error: 'single step aborted']! !!DynamicInterpreterSimulator methodsFor: 'debug extras' stamp: 'ikp 8/10/97 23:26'!stackDepth	| ctx stable depth |	depth _ 0.	ctx _ activeCachedContext.	stable _ 0.	[stable == 0] whileTrue: [		depth _ depth + 1.		ctx == lowestCachedContext ifTrue: [stable _ self cachedSenderAt: ctx].		ctx _ self cachedContextBefore: ctx.	].	[stable == nilObj] whileFalse: [		depth _ depth + 1.		stable _ self fetchPointer: SenderIndex ofObject: stable.	].	^depth! !!DynamicInterpreterSimulator methodsFor: 'logging' stamp: 'ikp 8/10/97 08:18'!initializeCache: addr	super initializeCache: addr.	self clearTranscript! !!DynamicInterpreterSimulator methodsFor: 'logging' stamp: 'ikp 1/5/98 14:37'!markAndTraceInterpreterOops	Transcript show: 'G'.	super markAndTraceInterpreterOops! !!DynamicInterpreterSimulator methodsFor: 'logging' stamp: 'ikp 1/5/98 14:37'!postGCAction	Transcript show: 'C'.	super postGCAction! !!DynamicInterpreterSimulator methodsFor: 'logging' stamp: 'ikp 1/1/98 02:53'!printExecutionState	| lo hi byte |	^String streamContents: [:str |		str nextPutAll: '			{ '.		lo _ self cachedFramePointerAt: activeCachedContext.		hi _ localSP.		lo to: hi by: 4 do: [:ptr |			ptr == lo ifFalse: [str nextPutAll: ' , '].			str nextPutAll: (self shortPrint: (self longAt: ptr))].		str nextPutAll: ' }'; crtab; tab.		(self instructionIndex: localIP - 4 "instr already fetched") printOn: str.		byte _ self byteAt: (self internalMethod + BaseHeaderSize + (self instructionIndex: localIP) - "0-rel" 1).		str tab; nextPutAll: byte hex; tab; nextPutAll: (Interpreter bytecodeTable at: byte + 1).	].! !!DynamicInterpreterSimulator methodsFor: 'tracing' stamp: 'ikp 12/4/97 20:37'!logTo: fileName	InterpreterLog logToFile: fileName.	byteCount _ 0.	self internalizeIPandSP.	[true] whileTrue: [		currentBytecode _ self fetchInstruction.		"InterpreterLog>>endEntry is called at every context change"		InterpreterLog isActive ifTrue:			[InterpreterLog cr; nextPutAll: (self printExecutionState)].		self dispatchOn: currentBytecode in: OpcodeTable.		(byteCount _ byteCount + 1) "= -40900 ifTrue: [InterpreterLog logToFile: 'LOG']".	].	self externalizeIPandSP.! !!DynamicInterpreterSimulator methodsFor: 'tracing' stamp: 'ikp 12/21/97 16:16'!step	InterpreterLog logToTranscript.	byteCount _ 0.	self internalizeIPandSP.	[true] whileTrue: [		self assertStackPointerIsInternal.		currentBytecode _ self fetchInstruction.		"InterpreterLog>>endEntry is called at every context change"		InterpreterLog isActive ifTrue:			[InterpreterLog cr; nextPutAll: (self printExecutionState)].		self singleStep.		self dispatchOn: currentBytecode in: OpcodeTable.		self assertIsLegalStackPointer: localSP.		self assertIsLegalTempPointer: self temporaryPointer.		(byteCount _ byteCount + 1)" == 7000 ifTrue: [self halt]".	].	self externalizeIPandSP.! !!DynamicInterpreterSimulator methodsFor: 'tracing' stamp: 'ikp 1/5/98 17:48'!test	InterpreterLog close.	byteCount _ 0.	self internalizeIPandSP.	[true] whileTrue: [		self assertStackPointerIsInternal.		currentBytecode _ self fetchInstruction.		"InterpreterLog>>endEntry is called at every context change"		InterpreterLog isActive ifTrue:			[InterpreterLog cr; nextPutAll: (self printExecutionState)].		self dispatchOn: currentBytecode in: OpcodeTable.		self assertIsLegalStackPointer: localSP.		self assertIsLegalTempPointer: self temporaryPointer.		(byteCount _ byteCount + 1).	].	self externalizeIPandSP.! !!DynamicInterpreterSimulator methodsFor: 'tracing' stamp: 'ikp 12/4/97 18:14'!trace	InterpreterLog logToTranscript.	byteCount _ 0.	self internalizeIPandSP.	[true] whileTrue: [		self assertStackPointerIsInternal.		currentBytecode _ self fetchInstruction.		"InterpreterLog>>endEntry is called at every context change -- only do it below if debugging				the execution of the first few bytecodes"		InterpreterLog isActive ifTrue:			[InterpreterLog cr; nextPutAll: (self printExecutionState); endEntry].		self dispatchOn: currentBytecode in: OpcodeTable.		self assertIsLegalStackPointer: localSP.		self assertIsLegalTempPointer: self temporaryPointer.		(byteCount _ byteCount + 1)" == 175000 ifTrue: [InterpreterLog logToFile: 'LOG']".	].	self externalizeIPandSP.! !!DynamicInterpreterSimulator methodsFor: 'interpreter shell' stamp: 'ikp 12/10/97 19:19'!beginOp: opIndex	"no-op, defined as a macro in translated code"! !!DynamicInterpreterSimulator methodsFor: 'interpreter shell'!dispatchOn: anInteger in: selectorArray	"Simulate a case statement via selector table lookup.	The given integer must be between 0 and selectorArray size-1, inclusive.	For speed, no range test is done, since it is done by the at: operation."	"assert: (anInteger >= 0) | (anInteger < selectorArray size)""Transcript cr; show: anInteger hex , '  ' , (selectorArray at: (anInteger + 1)).Sensor waitButton.Sensor yellowButtonPressed ifTrue: [self halt]."	self perform: (selectorArray at: (anInteger + 1)).! !!DynamicInterpreterSimulator methodsFor: 'interpreter shell' stamp: 'ikp 12/10/97 19:19'!endOp: opIndex	"no-op, defined as a macro in translated code"! !!DynamicInterpreterSimulator methodsFor: 'interpreter shell' stamp: 'ikp 12/28/97 23:38'!execOp: opIndex	"transfer control to the opcode with the given index (this is a macro in translated code)"	^self dispatchOn: (self integerValueOf: opIndex) in: OpcodeTable.! !!DynamicInterpreterSimulator methodsFor: 'interpreter shell' stamp: 'ikp 12/11/97 17:03'!fetchExtension	"This method uses the preIncrement builtin function which has no Smalltalk equivalent. Thus, it must be overridden in the simulator."	| ext |	self inline: true.	ext _ self longAt: (localIP _ localIP + 4).	"localIP _ localIP + 4."		"skip empty slot"	^self integerValueOf: ext! !!DynamicInterpreterSimulator methodsFor: 'interpreter shell' stamp: 'ikp 12/11/97 17:03'!fetchInstruction	"This method uses the preIncrement builtin function which has no Smalltalk equivalent. Thus, it must be overridden in the simulator."	| insn |	self inline: true.	insn _ self longAt: (localIP _ localIP + 4).			"localIP _ localIP + 4."		"skip empty extension slot""Transcript cr; show: '### ' , (self integerValueOf: insn) hex."	^self integerValueOf: insn! !!DynamicInterpreterSimulator methodsFor: 'interpreter shell' stamp: 'ikp 8/18/97 11:11'!fetchIntegerOrTruncFloat: fieldIndex ofObject: objectPointer	"Overridden to support the simulator."	| intOrFloat |	intOrFloat _ self fetchPointer: fieldIndex ofObject: objectPointer.	(self isIntegerObject: intOrFloat) ifTrue: [^ self integerValueOf: intOrFloat].	self successIfClassOf: intOrFloat is: (self splObj: ClassFloat).	successFlag ifTrue: [^ (self floatValueOf: intOrFloat) truncated].! !!DynamicInterpreterSimulator methodsFor: 'interpreter shell' stamp: 'ikp 12/10/97 19:20'!initOp: opIndex	"Defined as a macro in translated code, in the simulator this must	store the 'address' of the opcode in opcodeAddress and then answer	'true' during initialisation, or simply answer 'false' when executing."	self interpreterInitializing ifFalse: [^false].	opcodeAddress _ self integerObjectOf: (opIndex - 1).	self assert: opcodeAddress == (self integerObjectOf: opcodeIndex).	^true! !!DynamicInterpreterSimulator methodsFor: 'interpreter shell'!isIntegerValue: valueWord 	^ valueWord >= 16r-40000000 and: [valueWord <= 16r3FFFFFFF]! !!DynamicInterpreterSimulator methodsFor: 'interpreter shell' stamp: 'ikp 12/7/97 21:05'!nextOp	"no-op, defined as a macro in translated code"! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives'!ioProcessEvents! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives'!primitiveBeCursor	"Take note of the current cursor"	| cursorObj bitsObj offsetObj ourCursor |	cursorObj _ self stackTop.	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 4]).	successFlag ifTrue:		[bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj.		ourCursor _ Cursor			extent: (self fetchInteger: 1 ofObject: cursorObj)@(self fetchInteger: 2 ofObject: cursorObj)			fromArray: ((1 to: 16) collect: [:i |					((self fetchWord: i-1 ofObject: bitsObj) >> 16) bitAnd: 16rFFFF])			offset: (self fetchInteger: 0 ofObject: offsetObj)@(self fetchInteger: 1 ofObject: offsetObj)].	successFlag		ifTrue: [ourCursor show]		ifFalse: [self primitiveFail].! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives'!primitiveBeDisplay	"Extended to create a scratch Form for use by showDisplayBits."	| rcvr destWidth destHeight destDepth |	rcvr _ self stackTop.	self success: ((self isPointers: rcvr) and: [(self lengthOf: rcvr) >= 4]).	successFlag ifTrue: [		destWidth _ self fetchInteger: 1 ofObject: rcvr.		destHeight _ self fetchInteger: 2 ofObject: rcvr.		destDepth _ self fetchInteger: 3 ofObject: rcvr.	].	successFlag ifTrue: [		"create a scratch form the same size as Smalltalk displayObj"		displayForm _ Form extent: destWidth @ destHeight							depth: destDepth.	].	super primitiveBeDisplay.! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives' stamp: 'ikp 10/22/97 18:27'!primitiveKbdNext	self pop: 1.	Sensor keyboardPressed		ifTrue: [self pushInteger: Sensor primKbdNext]		ifFalse: [self push: nilObj]! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives' stamp: 'ikp 10/22/97 18:27'!primitiveKbdPeek	self pop: 1.	Sensor keyboardPressed		ifTrue: [self pushInteger: Sensor primKbdPeek]		ifFalse: [self push: nilObj]! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives' stamp: 'ikp 10/22/97 18:27'!primitiveMouseButtons	| buttons |	self pop: 1.	buttons _ Sensor primMouseButtons.	self pushInteger: buttons! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives'!primitiveMousePoint	| relPt |	self pop: 1.	displayForm == nil		ifTrue: [self push: (self makePointwithxValue: 99 yValue: 66)]		ifFalse: [relPt _ Sensor cursorPoint - (Display extent - displayForm extent - (10@10)).				self push: (self makePointwithxValue: relPt x yValue: relPt y)]! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives'!primitiveScreenSize  "Dummied for now"	self pop: 1.	self push: (self makePointwithxValue: 640 yValue: 480).! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives' stamp: 'ikp 10/22/97 18:28'!showDisplayBits	| displayObj destBits raster destDepth pixPerWord simDisp realDisp top bottom rect |	displayObj _ self splObj: TheDisplay.	self targetForm = displayObj ifFalse: [^ self].	destBits _ self fetchPointer: 0 ofObject: displayObj.	destDepth _ self fetchInteger: 3 ofObject: displayObj.	pixPerWord _ 32 // destDepth.	raster _ displayForm width + (pixPerWord - 1) // pixPerWord.	simDisp _ Form new hackBits: memory.	realDisp _ Form new hackBits: displayForm bits.	top _ myBitBlt affectedTop.	bottom _ myBitBlt affectedBottom.	realDisp		copy: (0 @ (top * raster) extent: 4 @ (bottom - top * raster))		from: 0 @ (destBits + 4 // 4 + (top * raster))		in: simDisp		rule: Form over.	rect _ 0 @ top corner: displayForm width @ bottom.	Display		copy: (rect translateBy: self displayLocation)		from: rect topLeft		in: displayForm		rule: Form over! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support'!copyBits	^ myBitBlt copyBits! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support'!displayLocation	^ Display extent - displayForm extent - (10@10)! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support'!drawLoopX: xDelta Y: yDelta	^ myBitBlt drawLoopX: xDelta Y: yDelta! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'ikp 9/29/97 21:22'!ioMicroMSecs	"Return the value of the microsecond clock (dummied here)."	^ 0! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support'!ioMSecs	"Return the value of the millisecond clock."	^ Time millisecondClockValue! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support'!ioProcessEventsEveryMSecs: mSecs	"Noop during simulation."! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'ikp 9/29/97 21:25'!ioScreenSize	"Return the screen extent packed into 32 bits."	^ (displayForm width << 16) + displayForm height! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'ikp 9/29/97 21:26'!ioSeconds	"Return the value of the second clock."	^ Time primSecondsClock! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support'!loadBitBltFrom: bbObj	^ myBitBlt loadBitBltFrom: bbObj! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support'!loadScannerFrom: bbObj	start: start stop: stop string: string rightX: rightX	stopArray: stopArray displayFlag: displayFlag	^ myBitBlt loadScannerFrom: bbObj		start: start stop: stop string: string rightX: rightX		stopArray: stopArray displayFlag: displayFlag! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'ikp 9/29/97 21:59'!primitiveGetAttribute	"return nil as if attribute isn't defined"	self pop: 2 thenPush: nilObj! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'ikp 9/29/97 21:33'!primitiveRelinquishProcessor	"No-op in simulator"	^ self! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support'!scanCharacters	^ myBitBlt scanCharacters! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support'!stopReason	^ myBitBlt stopReason! !!DynamicInterpreterSimulator methodsFor: 'I/O primitives support'!targetForm	^ myBitBlt targetForm! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!asciiDirectoryDelimiter	^ FileDirectory pathNameDelimiter asciiValue! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!fileValueOf: integerPointer	"Convert the (integer) fileID to the actual fileStream it uses"	self success: (self isIntegerObject: integerPointer).	successFlag		ifTrue: [^ filesOpen at: (self integerValueOf: integerPointer)]		ifFalse: [^ nil]! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!primitiveFileDelete	| namePointer |	namePointer _ self stackTop.	self success: (self isBytes: namePointer).	self success: (FileDirectory includesKey: (self stringOf: namePointer)).	successFlag ifTrue: [		FileDirectory removeKey: (self stringOf: namePointer) ifAbsent: [].	].	successFlag ifTrue: [		self pop: 1.  "fileName; leave rcvr on stack"	].! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!primitiveFileOpen	| namePointer writeFlag fileName |	writeFlag _ self booleanValueOf: self stackTop.	namePointer _ self stackValue: 1.	self success: (self isBytes: namePointer).	successFlag ifTrue:		[fileName _ self stringOf: namePointer.		filesOpen addLast: (writeFlag			ifTrue: [(FileStream fileNamed: fileName) binary]			ifFalse: [(FileDirectory default includesKey: fileName)				ifTrue: [(FileStream oldFileNamed: fileName) readOnly; binary]				ifFalse: [^ self primitiveFail]]).		self pop: 3.  "rcvr, name, write"		self pushInteger: filesOpen size]! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!primitiveFileRename	| oldNamePointer newNamePointer f |	oldNamePointer _ self stackTop.	newNamePointer _ self stackValue: 1.	self success: (self isBytes: oldNamePointer).	self success: (self isBytes: newNamePointer).	self success: (FileDirectory includesKey: (self stringOf: oldNamePointer)).	self success: (FileDirectory includesKey: (self stringOf: newNamePointer)) not.	successFlag ifTrue: [		f _ FileStream oldFileNamed: (self stringOf: oldNamePointer).		f rename: (self stringOf: newNamePointer).		f close.	].	successFlag ifTrue: [		self pop: 2.  "oldName, newName; leave rcvr on stack"	].! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!primitiveImageName	"Note: For now, this only implements getting, not setting, the image file name."	| result imageNameSize |	self pop: 1.	imageNameSize _ imageName size.	result _ self instantiateClass: (self splObj: ClassString)				   indexableSize: imageNameSize.	1 to: imageNameSize do:		[:i | self storeByte: i-1 ofObject: result			withValue: (imageName at: i) asciiValue].	self push: result.! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!sqFile: file Read: count Into: byteArrayIndex At: startIndex	startIndex to: (startIndex + count - 1) do: [ :i |		file atEnd ifTrue: [ ^ i - startIndex ].		self byteAt: byteArrayIndex + i put: file next.	].	^ count! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!sqFile: file SetPosition: newPosition	file position: newPosition.! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!sqFile: file Write: count From: byteArrayIndex At: startIndex	startIndex to: (startIndex + count - 1) do: [ :i |		file nextPut: (self byteAt: byteArrayIndex + i).	].	^ count! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!sqFileAtEnd: file	^ file atEnd! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!sqFileClose: file	file close.! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!sqFileGetPosition: file	^ file position! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!sqFileSize: file	^ file size! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!vmPathGet: stringBase Length: stringSize	| pathName stringOop |	pathName _ Smalltalk vmPath.	stringOop _ stringBase - BaseHeaderSize. "Due to C call in Interp"	1 to: stringSize do:		[:i | self storeByte: i-1 ofObject: stringOop			withValue: (pathName at: i) asciiValue].! !!DynamicInterpreterSimulator methodsFor: 'file primitives'!vmPathSize	^ Smalltalk vmPath size! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!floatObjectOf: float	| result sign exponent mantissa mantSize long0 long1 |true ifTrue: [	"No conversion needed in Apple ST"	long0 _ float at: 1.	long1 _ float at: 2.] ifFalse: ["Following code useful when porting to different formats"	((float at: 1) = 0 and: [(float at: 2) = 0])		ifTrue: [long0 _ 0. long1 _ 0]		ifFalse: 	["Read from the PPS 32-bit format"	sign _ ((float at: 1) bitAnd: 16r8000) bitShift: -15.				"1-bit sign"	exponent _ (((float at: 1) bitShift: -7) bitAnd: 16rFF) - 16r80. 		"8-bit expt"	mantissa _ (((float at: 1) bitAnd: 16r7F) bitShift: 16) + (float at: 2).	"23 bit mantissa"	mantSize _ 23.	"Convert to first 32 bits of 64-bit IEEE format"	long0 _ (sign bitShift: 31)										"1-bit sign"			+ (exponent + 16r400 bitShift: 20)						"11-bit expt"			+ ((mantissa bitShift: 20 - mantSize) bitAnd: 16rFFFFF).	"20 bit mantissa"	]. ]. "end of porting code"	result _ self instantiateClass: (self splObj: ClassFloat) indexableSize: 2.	self storeWord: 0 ofObject: result withValue: long0.	self storeWord: 1 ofObject: result withValue: long1.	^ result! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!floatValueOf: objectPointer	| float len long0 long1 sign exponent mantissa mantSize |	(self isIntegerObject: objectPointer)		ifTrue: [^ (self integerValueOf: objectPointer) asFloat].	(self fetchClassOf: objectPointer) = (self splObj: ClassFloat)		ifFalse: [self success: false.  ^0.0].	len _ self fetchWordLengthOf: objectPointer.	(len between: 2 and: 3)		ifFalse: [self success: false.  ^0.0].	"FIRST convert image formats to sign/exponent/mantissa"	len = 2 ifTrue:  		["Normal 64-bit IEEE format"		long0 _ self fetchWord: 0 ofObject: objectPointer.		long1 _ self fetchWord: 1 ofObject: objectPointer.true ifTrue: [float _ Float new: 2.  "No conversion needed for AST"			float at: 1 put: long0.			float at: 2 put: long1.			^ float].		long0 = 0 ifTrue: [^ 0.0].		sign _ (long0 bitAnd: 16r80000000) bitShift: -31.				"1-bit sign"		exponent _ ((long0 bitShift: -20) bitAnd: 16r7FF) - 16r400.		"11-bit exponent"		mantissa _ ((long0 bitAnd: 16rFFFFF) bitShift: 32) + long1.		"52-bit mantissa"		mantSize _ 52]		ifFalse:  		["Weird 80-bit Apple format -- will go away soon"		long0 _ self fetchWord: 0 ofObject: objectPointer.		long1 _ self fetchWord: 1 ofObject: objectPointer.		long0 = 0 ifTrue: [^ 0.0].		sign _ (long0 bitAnd: 16r80000000) bitShift: -31.				"1-bit sign"		exponent _ ((long0 bitShift: -16) bitAnd: 16r7FFF) - 16r4000. 	"15-bit exponent"		"Note: drop the (redundant) high bit (16r8000) of mantissa"		mantissa _ ((long0 bitAnd: 16r7FFF) bitShift: 32) + long1.		"47-bit mantissa"		mantSize _ 47].	"THEN convert sign/exponent/mantissa to host format"	float _ Float new: 2.  "PPSST FP uses 2 16-bit words"	float at: 1 put: (sign bitShift: 15)							"1-bit sign"				+ (exponent + 16r80 bitShift: 7)				"8-bit expt"				+ ((mantissa bitShift: 7 - mantSize) bitAnd: 16r7F).	"7 bits of mantissa"	float at: 2 put: ((mantissa bitShift: 16 - (mantSize - 7)) bitAnd: 16rFFFF).  "16 more bits of mantissa"	^ float! !!DynamicInterpreterSimulator methodsFor: 'float primitives' stamp: 'ikp 12/5/97 19:49'!popFloat	^self floatValueOf: (self popStack)! !!DynamicInterpreterSimulator methodsFor: 'float primitives' stamp: 'ikp 12/5/97 23:27'!popFloatOnly	| number |	(self isIntegerObject: (number _ self popStack)) ifTrue: [		self success: false.		^0.0.	].	^ self floatValueOf: number! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveArctan	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr arcTan]		ifFalse: [self unPop: 1].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveAsFloat	"Use host Smalltalk's native function."	| arg |	arg _ self popInteger.	successFlag		ifTrue: [self pushFloat: arg asFloat]		ifFalse: [self unPop: 1].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveExp	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr exp]		ifFalse: [self unPop: 1].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveExponent	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushInteger: rcvr exponent]		ifFalse: [self unPop: 1].! !!DynamicInterpreterSimulator methodsFor: 'float primitives' stamp: 'ikp 9/29/97 21:28'!primitiveFloatAdd	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloatOnly.	rcvr _ self popFloatOnly.	successFlag		ifTrue: [self pushFloat: rcvr + arg]		ifFalse: [self unPop: 2].! !!DynamicInterpreterSimulator methodsFor: 'float primitives' stamp: 'ikp 9/29/97 21:29'!primitiveFloatDivide	"Note: This method overridden here because the translator (intentionally) doesn't translate the / operator (since the semantics of C / are the semantics of Smalltalk //). This allows the version of this method to be translated to express division as //, which translates to the float division operator /."	| rcvr arg |	arg _ self popFloatOnly.	rcvr _ self popFloatOnly.	successFlag ifTrue: [self success: arg ~= 0.0].	successFlag		ifTrue: [self pushFloat: rcvr / arg]		ifFalse: [self unPop: 2].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveFloatEqual	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr = arg]		ifFalse: [self unPop: 2].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveFloatGreaterOrEqual	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr >= arg]		ifFalse: [self unPop: 2].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveFloatGreaterThan	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr > arg]		ifFalse: [self unPop: 2].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveFloatLessOrEqual	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr <= arg]		ifFalse: [self unPop: 2].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveFloatLessThan	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr < arg]		ifFalse: [self unPop: 2].! !!DynamicInterpreterSimulator methodsFor: 'float primitives' stamp: 'ikp 9/29/97 21:31'!primitiveFloatMultiply	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloatOnly.	rcvr _ self popFloatOnly.	successFlag		ifTrue: [self pushFloat: rcvr * arg]		ifFalse: [self unPop: 2].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveFloatNotEqual	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr ~= arg]		ifFalse: [self unPop: 2].! !!DynamicInterpreterSimulator methodsFor: 'float primitives' stamp: 'ikp 9/29/97 21:31'!primitiveFloatSubtract	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloatOnly.	rcvr _ self popFloatOnly.	successFlag		ifTrue: [self pushFloat: rcvr - arg]		ifFalse: [self unPop: 2].! !!DynamicInterpreterSimulator methodsFor: 'float primitives' stamp: 'ikp 9/29/97 21:31'!primitiveFractionalPart	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloatOnly.	successFlag		ifTrue: [self pushFloat: rcvr fractionPart]		ifFalse: [self unPop: 1].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveLogN	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr ln]		ifFalse: [self unPop: 1].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveSine	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr sin]		ifFalse: [self unPop: 1].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveSquareRoot	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr sqrt]		ifFalse: [self unPop: 1].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveTimesTwoPower	"Use Smalltalk's native function (tho could just fail)"	| rcvr arg |	arg _ self popInteger.	rcvr _ self popFloat.	successFlag		ifTrue: [ self pushFloat: (rcvr timesTwoPower: arg) ]		ifFalse: [ self unPop: 2 ].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!primitiveTruncated	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushInteger: rcvr truncated]		ifFalse: [self unPop: 1].! !!DynamicInterpreterSimulator methodsFor: 'float primitives'!pushFloat: f	self push: (self floatObjectOf: f).! !!DynamicInterpreterSimulator methodsFor: 'memory access'!byteAt: byteAddress	| lowBits |	lowBits _ byteAddress bitAnd: 3.	^((self longAt: byteAddress - lowBits)		bitShift: (lowBits - 3) * 8)		bitAnd: 16rFF! !!DynamicInterpreterSimulator methodsFor: 'memory access' stamp: 'ikp 8/12/97 19:13'!byteAt: byteAddress put: byte	| longWord shift lowBits |	lowBits _ byteAddress bitAnd: 3.	longWord _ self longAt: byteAddress - lowBits.	shift _ (3 - lowBits) * 8.	longWord _ longWord - (longWord bitAnd: (16rFF bitShift: shift)) + (byte bitShift: shift).	self longAt: byteAddress - lowBits put: longWord! !!DynamicInterpreterSimulator methodsFor: 'memory access' stamp: 'ikp 8/13/97 08:19'!longAt: byteAddress	"Note: Adjusted for Smalltalk's 1-based array indexing."	self assertIsWordAligned: byteAddress.	^memory at: (byteAddress // 4) + 1! !!DynamicInterpreterSimulator methodsFor: 'memory access' stamp: 'ikp 12/10/97 14:04'!longAt: byteAddress put: a32BitValue	"Note: Adjusted for Smalltalk's 1-based array indexing."	self assertIsWordAligned: byteAddress.	^memory at: (byteAddress // 4) + 1 put: a32BitValue! !!DynamicInterpreterSimulator methodsFor: 'arithmetic' stamp: 'ikp 12/17/97 21:59'!opPrimGreaterOrEqual	"Must be overridden from Interpreter because simulator doesn't have		32-bit signed ints to work with"	| rcvr arg |	self interpreterInitializing ifFalse: [		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg)			ifTrue: [				self skip: 1.				^self internalPop: 2 thenPushBool: (self integerValueOf: rcvr) >= (self integerValueOf: arg).		].	].	^super opPrimGreaterOrEqual! !!DynamicInterpreterSimulator methodsFor: 'arithmetic' stamp: 'ikp 12/17/97 21:59'!opPrimGreaterThan	"Must be overridden from Interpreter because simulator doesn't have		32-bit signed ints to work with"	| rcvr arg |	self interpreterInitializing ifFalse: [		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg)			ifTrue: [				self skip: 1.				^self internalPop: 2 thenPushBool: (self integerValueOf: rcvr) > (self integerValueOf: arg).		].	].	^super opPrimGreaterThan! !!DynamicInterpreterSimulator methodsFor: 'arithmetic' stamp: 'ikp 12/17/97 21:59'!opPrimLessOrEqual	"Must be overridden from Interpreter because simulator doesn't have		32-bit signed ints to work with"	| rcvr arg |	self interpreterInitializing ifFalse: [		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg)			ifTrue: [				self skip: 1.				^ self internalPop: 2 thenPushBool: (self integerValueOf: rcvr) <= (self integerValueOf: arg).		].	].	^super opPrimLessOrEqual! !!DynamicInterpreterSimulator methodsFor: 'arithmetic' stamp: 'ikp 12/17/97 21:59'!opPrimLessThan	"Must be overridden from Interpreter because simulator doesn't have		32-bit signed ints to work with"	| rcvr arg |	self interpreterInitializing ifFalse: [		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg)			ifTrue: [				self skip: 1.				^self internalPop: 2 thenPushBool: (self integerValueOf: rcvr) < (self integerValueOf: arg).		].	].	^super opPrimLessThan! !!DynamicInterpreterSimulator methodsFor: 'assertions'!assertIsCachedBaseContext: t1 	(self printCachedContext: t1)		= '[] in BlockContext>>#newProcess' ifFalse: [self error: 'incorrect cached base context']! !!DynamicInterpreterSimulator methodsFor: 'assertions'!assertIsStableBaseContext: t1 	self assertIsOop: t1.	(self printStableContext: t1)		= '[] in BlockContext>>#newProcess' ifFalse: [self error: 'incorrect stable base context']! !DynamicInterpreterSimulatorLSB comment:'I am a version of DynamicInterpreterSimulator tweaked to run on little-endian machines.'!!DynamicInterpreterSimulatorLSB methodsFor: 'initialization'!nextLongFrom: aStream	"Read a 32-bit quantity from the given (binary) stream."	| bytes |	bytes _ aStream nextInto: (ByteArray new: 4).	^ Integer		byte1: (bytes at: 1)		byte2: (bytes at: 2)		byte3: (bytes at: 3)		byte4: (bytes at: 4)! !!DynamicInterpreterSimulatorLSB methodsFor: 'memory access'!byteAt: byteAddress	| lowBits |	lowBits _ byteAddress bitAnd: 3.	^((self longAt: byteAddress - lowBits)		bitShift: (0 - lowBits) * 8)		bitAnd: 16rFF! !!DynamicInterpreterSimulatorLSB methodsFor: 'memory access' stamp: 'ikp 12/8/97 00:54'!byteAt: byteAddress put: byte	| longWord shift lowBits |	lowBits _ byteAddress bitAnd: 3.	longWord _ self longAt: byteAddress - lowBits.	shift _ lowBits * 8.	longWord _ longWord - (longWord bitAnd: (16rFF bitShift: shift)) + (byte bitShift: shift).	self longAt: byteAddress - lowBits put: longWord! !!DynamicInterpreterSimulatorLSB methodsFor: 'debug support'!charsOfLong: long	^ (1 to: 4) collect:		[:i | ((long digitAt: i) between: 14 and: 126)					ifTrue: [(long digitAt: i) asCharacter]					ifFalse: [$?]]! !DynamicInterpreterState comment:'This class provides the state that is owned by DynamicInterpreter, but which (for various reasons) is referred to from its superclasses.  This class will disappear in a puff of rationalisation one day, when things settle down a little.See DynamicInterpreter class>>checkScopes for a list of the problem cases.'!!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'ikp 1/14/98 00:51'!initialize	"DynamicInterpreterState initialize"	super initialize.	self initializeAssociationIndex.	self initializeCharacterIndex.	self initializeClassIndices.	self initializeContextIndices.	self initializeDirectoryLookupResultCodes.	self initializeMessageIndices.	self initializeMethodCacheIndices.	self initializeMethodIndices.	self initializePointIndices.	self initializePrimitiveTable.	self initializeSchedulerIndices.	self initializeSmallIntegers.	self initializeStreamIndices.	SemaphoresToSignalSize _ 25.! !!DynamicInterpreterState class methodsFor: 'class initialization'!initializeAssociationIndex	ValueIndex _ 1! !!DynamicInterpreterState class methodsFor: 'class initialization'!initializeCharacterIndex	CharacterValueIndex _ 0! !!DynamicInterpreterState class methodsFor: 'class initialization'!initializeClassIndices	"Class Class"	SuperclassIndex _ 0.	MessageDictionaryIndex _ 1.	InstanceSpecificationIndex _ 2.	"Fields of a message dictionary"	MethodArrayIndex _ 1.	SelectorStart _ 2! !!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'ikp 11/30/97 19:17'!initializeContextIndices	"Class MethodContext"	SenderIndex _ 0.	InstructionPointerIndex _ 1.	StackPointerIndex _ 2.	MethodIndex _ 3.	TranslatedMethodIndex _ 4.	ReceiverIndex _ 5.	TempFrameStart _ 6.	"Class BlockContext"	CallerIndex _ 0.	BlockArgumentCountIndex _ 3.	InitialIPIndex _ 4.	HomeIndex _ 5! !!DynamicInterpreterState class methodsFor: 'class initialization'!initializeDirectoryLookupResultCodes	DirEntryFound _ 0.	DirNoMoreEntries _ 1.	DirBadPath _ 2.! !!DynamicInterpreterState class methodsFor: 'class initialization'!initializeMessageIndices	MessageSelectorIndex _ 0.	MessageArgumentsIndex _ 1.	MessageSize _ 2! !!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'di 1/14/98 21:33'!initializeMethodCacheIndices		"DynamicInterpreter initializeMethodCacheIndices"	CacheProbeMax _ 3.	MethodCacheEntries _ 1024.	MethodCacheSelectorCol		_ 0 * MethodCacheEntries.	"selector oop"	MethodCacheClassCol			_ 1 * MethodCacheEntries.	"class oop"	MethodCacheMethodCol		_ 2 * MethodCacheEntries.	"CompiledMethod oop"	MethodCachePrimIndexCol	_ 3 * MethodCacheEntries.	"raw primitive index"	MethodCacheTMethodCol		_ 4 * MethodCacheEntries.	"TranslatedMethod oop"	MethodCacheDelayCol		_ 5 * MethodCacheEntries.	"raw inline cache link delay"	MethodCacheColumns		_ 6.	MethodCacheMask _ MethodCacheEntries - 1.	(MethodCacheEntries bitAnd: MethodCacheMask) = 0		ifFalse: [ self error: 'MethodCacheEntries must be a power of two' ].	MethodCacheSize _ MethodCacheEntries * MethodCacheColumns.! !!DynamicInterpreterState class methodsFor: 'class initialization'!initializeMethodIndices	"Class CompiledMethod"	HeaderIndex _ 0.	LiteralStart _ 1! !!DynamicInterpreterState class methodsFor: 'class initialization'!initializePointIndices	XIndex _ 0.	YIndex _ 1! !!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'ikp 1/14/98 20:39'!initializePrimitiveTable	"DynamicInterpreter initializePrimitiveTable"	"This table generates a C switch statement."	"NOTE: The real limit here is 2047, but some C compilers barf over 700"	MaxPrimitiveIndex _ 699.	PrimitiveTable _ Array new: MaxPrimitiveIndex+1.	self table: PrimitiveTable from: 	#(		"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveFail)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		(126 primitiveFail)		(127 primitiveFail)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"Unassigned Primitives"		(520 primitiveBeep) "test of new primitive indices"		(521 699 primitiveFail)	).! !!DynamicInterpreterState class methodsFor: 'class initialization'!initializeSchedulerIndices	"Class ProcessorScheduler"	ProcessListsIndex _ 0.	ActiveProcessIndex _ 1.	"Class LinkedList"	FirstLinkIndex _ 0.	LastLinkIndex _ 1.	"Class Semaphore"	ExcessSignalsIndex _ 2.	"Class Link"	NextLinkIndex _ 0.	"Class Process"	SuspendedContextIndex _ 1.	PriorityIndex _ 2.	MyListIndex _ 3! !!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'ikp 11/29/97 23:07'!initializeSmallIntegers	"SmallIntegers"	ConstMinusOne _ DynamicInterpreterState new integerObjectOf: -1.	ConstZero _ DynamicInterpreterState new integerObjectOf: 0.	ConstOne _ DynamicInterpreterState new integerObjectOf: 1.	ConstTwo _ DynamicInterpreterState new integerObjectOf: 2! !!DynamicInterpreterState class methodsFor: 'class initialization'!initializeStreamIndices	StreamArrayIndex _ 0.	StreamIndexIndex _ 1.	StreamReadLimitIndex _ 2.	StreamWriteLimitIndex _ 3.! !!DynamicInterpreterState class methodsFor: 'class initialization'!table: anArray from: specArray	"SpecArray is an array of either (index selector) or (index1 index2 selector)."	| contiguous |	contiguous _ 0.	specArray do: [ :spec |		(spec at: 1) = contiguous ifFalse: [ self error: 'Non-contiguous table entry' ].		spec size = 2 ifTrue: [			anArray at: ((spec at: 1) + 1) put: (spec at: 2).			contiguous _ contiguous + 1.		] ifFalse: [			(spec at: 1) to: (spec at: 2) do: [ :i | anArray at: (i + 1) put: (spec at: 3) ].			contiguous _ contiguous + ((spec at: 2) - (spec at: 1)) + 1.		].	].! !!DynamicInterpreterState class methodsFor: 'constants' stamp: 'ikp 1/1/98 17:11'!primitiveTable	^ PrimitiveTable! !!DynamicInterpreterState class methodsFor: 'translation' stamp: 'ikp 1/1/98 17:12'!declareCVarsIn: aCCodeGenerator	"aCCodeGenerator var: 'localTP' declareC: 'char * localTP'."	aCCodeGenerator var: 'localCP' declareC: 'int localCP'.	aCCodeGenerator var: 'methodCache'		declareC: 'int methodCache[', (MethodCacheSize + 1) printString, ']'.	aCCodeGenerator var: 'localIP' declareC: 'char * localIP'.	aCCodeGenerator var: 'localSP' declareC: 'char * localSP'.	aCCodeGenerator var: 'semaphoresToSignal'		declareC: 'int semaphoresToSignal[', (SemaphoresToSignalSize + 1) printString, ']'.! !!DynamicInterpreterState class methodsFor: 'translation' stamp: 'ikp 1/1/98 17:13'!translate: fileName doInlining: inlineFlag doAssertions: assertionFlag fromClasses: classList	| cg |	cg _ CCodeGenerator new initialize.	self initialize.	classList do: [:class | cg addClass: class].	classList do: [:class | class declareCVarsIn: cg].	cg storeCodeOnFile: fileName doInlining: inlineFlag doAssertions: assertionFlag.! !DynamicTranslator comment:'I am part of the DynamicInterpreter, separate from that class for organisational purposes only.'!!DynamicTranslator methodsFor: 'initialization' stamp: 'ikp 12/19/97 02:29'!initializeOpcodeTable	"no-op in translated code, overriden in simulator to allocate opcodeTable"	self inline: true! !!DynamicTranslator methodsFor: 'initialization' stamp: 'ikp 1/5/98 22:50'!initializeSendTables	"Note: assumes that the opcodeTable has already been initialised."	self inline: true.	shortSendTable at: ImmediateSendType	put: (opcodeTable at: LinkedImmediateSend).	shortSendTable at: CompactSendType		put: (opcodeTable at: LinkedCompactSend).	shortSendTable at: NormalSendType		put: (opcodeTable at: LinkedNormalSend).	extendedSendTable at: ImmediateSendType		put: (opcodeTable at: ExtendedImmediateSend).	extendedSendTable at: CompactSendType		put: (opcodeTable at: ExtendedCompactSend).	extendedSendTable at: NormalSendType		put: (opcodeTable at: ExtendedNormalSend).	doubleExtendedSendTable at: ImmediateSendType	put: (opcodeTable at: DoubleExtendedImmediateSend).	doubleExtendedSendTable at: CompactSendType	put: (opcodeTable at: DoubleExtendedCompactSend).	doubleExtendedSendTable at: NormalSendType		put: (opcodeTable at: DoubleExtendedNormalSend).! !!DynamicTranslator methodsFor: 'initialization' stamp: 'ikp 1/14/98 01:55'!initializeTranslator	self inline: true.	translationCycle _ ConstZero.	inlineCacheLimit _ InlineCacheLimit.	self initializeOpcodeTable.	1 to: OpcodeTableSize do: [:op | self initOpcode: op].	self initializeSendTables.	statInlineCacheHits _ 0.	statMethodCacheHits _ 0.	statMethodCacheMisses _ 0.	"The following is a read-write vm parameter"	UseInlineCacheDelay ifTrue: [inlineCacheDelay _ InlineCacheDelay].! !!DynamicTranslator methodsFor: 'initialization' stamp: 'ikp 12/29/97 01:58'!initOpcode: index	self inline: false.	opcodeIndex _ index - 1.	self assert: self interpreterInitializing.	self interpret.	"leaves opcode address in opcodeAddress"	(self isIntegerObject: opcodeAddress) ifFalse:		[self error: 'opcode address is not an integer object'].	opcodeTable at: index put: opcodeAddress! !!DynamicTranslator methodsFor: 'translator shell' stamp: 'ikp 12/20/97 14:40'!emitInteger: integer	self emitLiteral: (self integerObjectOf: integer)! !!DynamicTranslator methodsFor: 'translator shell' stamp: 'ikp 12/20/97 14:40'!emitLiteral: literal	"opPointer is pre-incremented!!"	self emitSkip: 1.	self longAt: opPointer put: literal.! !!DynamicTranslator methodsFor: 'translator shell' stamp: 'ikp 12/20/97 14:39'!emitLiteralConstant: index	"Note: this won't be inlined until the conditional is removed."	DecodeLiteralConstants		ifTrue: [self emitLiteral: (self literal: index ofMethod: newMethod)]		ifFalse: [self emitInteger: index]! !!DynamicTranslator methodsFor: 'translator shell' stamp: 'ikp 12/20/97 14:39'!emitLiteralSelector: index	"Note: this won't be inlined until the conditional is removed."	DecodeLiteralSelectors		ifTrue: [self emitLiteral: (self literal: index ofMethod: newMethod)]		ifFalse: [self emitInteger: index]! !!DynamicTranslator methodsFor: 'translator shell' stamp: 'ikp 12/20/97 14:39'!emitLiteralVariable: index	"Note: this won't be inlined until the conditional is removed."	DecodeLiteralVariables		ifTrue: [self emitLiteral: (self literal: index ofMethod: newMethod)]		ifFalse: [self emitInteger: index]! !!DynamicTranslator methodsFor: 'translator shell' stamp: 'ikp 12/24/97 19:26'!emitOffset: integer	self emitLiteral: (self offsetObjectOf: integer * 8)! !!DynamicTranslator methodsFor: 'translator shell' stamp: 'ikp 12/20/97 14:39'!emitOp: opIndex	"Assumes: support code makes all opcode addresses look like Smallintegers"	self emitLiteral: (opcodeTable at: opIndex)! !!DynamicTranslator methodsFor: 'translator shell' stamp: 'ikp 12/20/97 14:39'!emitSkip: size	opPointer _ opPointer + (size * 4)! !!DynamicTranslator methodsFor: 'translator shell' stamp: 'ikp 12/20/97 14:51'!nextByte	"Note: bytePointer is pre-incremented!!"	^self byteAt: (bytePointer _ bytePointer + 1)! !!DynamicTranslator methodsFor: 'translator shell' stamp: 'ikp 12/20/97 14:51'!peekByte: offset	"Callers beware: bytePointer is pre-incremented!!"	^self byteAt: bytePointer + offset! !!DynamicTranslator methodsFor: 'translator shell' stamp: 'ikp 1/12/98 01:02'!translateNewMethod	"Translate the method in newMethod and store the result in newTranslatedMethod."	"Future optimisations include:		- make a cache of class-independent quick reponse methods and reuse them		- pre-translate a method for #doesNotUnderstand:"	| header nLits bcSize firstBC lastBC tMeth bias prevBC prevOP |	self inline: false.	"as if you needed telling"	header _ self headerOf: newMethod.	nLits _ self literalCountOfHeader: header.	firstBC _ BaseHeaderSize + "method header" 4 + "literals" (nLits * 4).	lastBC _ self endPC: newMethod.	bcSize _ lastBC - firstBC + 1.	tMeth _ self instantiateClass: (self splObj: ClassTranslatedMethod) indexableSize: MethodOpcodeStart + (2 "words" * bcSize).	newTranslatedMethod _ tMeth.	"ASSUME: tMeth is young -- can use unchecked stores.  *** CAVEAT HACOR ***"	bias _ firstBC - BaseHeaderSize + 1.		"this happens to be the same as the initial vPC for the method"	self storePointerUnchecked: MethodBiasIndex				ofObject: tMeth					withValue: (self integerObjectOf: bias).	self storePointerUnchecked: MethodSelectorIndex			ofObject: tMeth					withValue: (messageSelector).	self storePointerUnchecked: MethodArgCountIndex			ofObject: tMeth					withValue: (self integerObjectOf: (self argumentCountOf: newMethod)).	self storePointerUnchecked: MethodMethodIndex			ofObject: tMeth					withValue: (newMethod).	self storePointerUnchecked: MethodClassIndex				ofObject: tMeth					withValue: nilObj.	"see #linkSend"	EagerInlineCacheFlush ifFalse: [		self storePointerUnchecked: MethodCycleIndex		ofObject: tMeth					withValue: translationCycle].	opPointer _ tMeth + BaseHeaderSize + (MethodOpcodeStart * 4) - "pre-incr" 4.	"first opcode"	bytePointer _ newMethod + firstBC - "pre-incr" 1.								"first bytecode"	blockEnd _ newMethod.														"not in block"	[bytePointer < (newMethod + lastBC)] whileTrue: [		"benign assertions record information needed by later real assertions"		self assertAny: (prevBC _ bytePointer).		self assertAny: (prevOP _ opPointer).		currentByte _ self nextByte.		self dispatchOn: currentByte in: TranslationTable.		"assert: bytecodeSize bytes(words) were consumed(generated) in the compiled(translated) method.				(Assumes: currentByte was not modified while translating the bytecode)"		self assert: (bytePointer = (prevBC + (self bytecodeSize: currentByte))).		self assert: (opPointer = (prevOP + ((self bytecodeSize: currentByte) * 8))).	].	"assert: byte(op)Pointer points to the last element in the compiled(translated) method."	self assert: (bytePointer = (newMethod + lastBC + 1 - "pre-incr" 1)).	self assert: (opPointer = (newTranslatedMethod + (self sizeBitsOf: newTranslatedMethod) - "pre-incr" 4)).! !!DynamicTranslator methodsFor: '  translated methods' stamp: 'ikp 1/1/98 23:52'!translatedMethodBias: tMeth	| bias |	self assertIsTranslatedMethod: tMeth.	bias _ self fetchWord: MethodBiasIndex ofObject: tMeth.	self assertIsIntegerObject: bias.	^self integerValueOf: bias! !!DynamicTranslator methodsFor: '  opcode rewriting' stamp: 'ikp 12/26/97 01:50'!isLongJump: offset	^(self peekByte: offset) >= 160 and: [(self peekByte: offset) < 168]! !!DynamicTranslator methodsFor: '  opcode rewriting' stamp: 'ikp 12/27/97 18:53'!rewrite: offset from: oldIndex to: newIndex	(self longAt: opPointer + offset) = (opcodeTable at: oldIndex)		ifTrue:			[self longAt: opPointer + offset put: (opcodeTable at: newIndex).			 ^true]		ifFalse:			[^false]! !!DynamicTranslator methodsFor: '  opcode rewriting' stamp: 'ikp 12/27/97 18:54'!rewrite: offset fromPushIntegerTo: newIndex	(self wasPushInteger: offset)		ifTrue:			[self longAt: opPointer + offset put: (opcodeTable at: newIndex).			 ^true]		ifFalse:			[^false]! !!DynamicTranslator methodsFor: '  opcode rewriting' stamp: 'ikp 12/26/97 21:25'!rewrite: offset to: opIndex	self longAt: (opPointer + offset) put: (opcodeTable at: opIndex)! !!DynamicTranslator methodsFor: '  opcode rewriting' stamp: 'ikp 12/25/97 16:57'!wasPushActiveContext: offset	^(self longAt: (opPointer + offset)) = (opcodeTable at: PushActiveContext)! !!DynamicTranslator methodsFor: '  opcode rewriting' stamp: 'ikp 12/25/97 16:45'!wasPushConstant: offset	^(self longAt: (opPointer + offset)) = (opcodeTable at: PushConstant)! !!DynamicTranslator methodsFor: '  opcode rewriting' stamp: 'ikp 12/25/97 16:45'!wasPushInteger: offset	^(self wasPushConstant: offset)		and: [self isIntegerObject: (self longAt: opPointer + offset + 4)]! !!DynamicTranslator methodsFor: '  utilities' stamp: 'ikp 12/17/97 21:58'!internalPop: nItems thenPushBool: cond	self inline: true.	cond		ifTrue: [self internalPop: nItems thenPush: trueObj]		ifFalse: [self internalPop: nItems thenPush: falseObj]! !!DynamicTranslator methodsFor: '  utilities' stamp: 'ikp 12/24/97 20:40'!offsetObjectOf: offsetValue	"This method must be overridden in the simulator because the simulated	object memory cannot store negative integers."	self assertIsIntegerObject: (offsetValue + 1).	^offsetValue + 1! !!DynamicTranslator methodsFor: '  utilities' stamp: 'ikp 1/1/98 19:16'!offsetValueOf: offsetObject	"This method must be overridden in the simulator because the simulated	object memory cannot store negative integers.  In the translated VM we win	big from the compiler combining sequences of arithmetic operations on the	localIP, the overall effect of which is that the transformation from an	integer-encoded form to a usable offset has zero overhead in many cases."	self assertIsIntegerObject: offsetObject.	^offsetObject - 1! !!DynamicTranslator methodsFor: '  private' stamp: 'ikp 12/3/97 13:44'!bytecodeSize: bytecode	| type lo |	type _ bytecode // 16.	type = 8		ifTrue:			[lo _ bytecode \\ 16.			lo = 4 ifTrue: [^3].			lo < 7 ifTrue: [^2]]		ifFalse: [type = 10 ifTrue: [^2]].	^1! !!DynamicTranslator methodsFor: '  private' stamp: 'ikp 1/12/98 01:01'!endPC: aCompiledMethod	"Answer the 0-based index, relative to aCompiledMethod, of the last bytecode."	"Note: this is based closely on CompiledMethod>>endPC"	| lastIndex flagByte |	lastIndex _ self stSizeOf: newMethod.			"1-based Smalltalk index of last byte in method"	lastIndex _ lastIndex + BaseHeaderSize - 1.	"0-based VM index of last byte in method"	flagByte _ self byteAt: aCompiledMethod + lastIndex.	flagByte = 0 ifTrue:		["If last byte = 0, may be either 0, 0, 0, 0 or just 0"		 1 to: 4 do: [:i | (self byteAt: aCompiledMethod + lastIndex - i) = 0 ifFalse:[^lastIndex - i]]].	flagByte < 252 ifTrue:		["tempnames encoded in last few bytes; last byte is size of encoding bytes"		^lastIndex - flagByte - 1].	"Normal 4-byte source pointer"	^lastIndex - 4! !!DynamicTranslator methodsFor: 'interpreter shell' stamp: 'ikp 1/2/98 23:54'!decodeLiteralSelector: litSel	"Note: this won't be inlined until the conditional is removed."	self inline: true.	DecodeLiteralSelectors		ifTrue: [^litSel]		ifFalse: [^self literal: (self integerValueOf: litSel)]! !!DynamicTranslator methodsFor: 'interpreter shell' stamp: 'ikp 1/1/98 22:38'!fetchCachedSelector	self inline: true.	DecodeLiteralSelectors		ifTrue: [^self fetchLiteral]		ifFalse: [^self literal: self fetchInteger]! !!DynamicTranslator methodsFor: 'interpreter shell' stamp: 'ikp 12/20/97 14:27'!fetchInteger	self inline: true.	^self integerValueOf: (self fetchLiteral)! !!DynamicTranslator methodsFor: 'interpreter shell' stamp: 'ikp 12/20/97 14:27'!fetchLiteral	"This method uses the preIncrement builtin function which has no Smalltalk equivalent. Thus, it must be overridden in the simulator."	self inline: true.	^self longAt: (localIP _ localIP + 4)! !!DynamicTranslator methodsFor: 'interpreter shell' stamp: 'ikp 12/19/97 01:55'!fetchLiteralConstant	"Note: this won't be inlined until the conditional is removed."	self inline: true.	DecodeLiteralConstants		ifTrue: [^self fetchLiteral]		ifFalse: [^self literal: self fetchInteger]! !!DynamicTranslator methodsFor: 'interpreter shell' stamp: 'ikp 12/19/97 01:55'!fetchLiteralSelector	"Note: this won't be inlined until the conditional is removed."	self inline: true.	DecodeLiteralSelectors		ifTrue: [^self fetchLiteral]		ifFalse: [^self literal: self fetchInteger]! !!DynamicTranslator methodsFor: 'interpreter shell' stamp: 'ikp 12/19/97 01:55'!fetchLiteralVariable	"Note: this won't be inlined until the conditional is removed."	self inline: true.	DecodeLiteralVariables		ifTrue: [^self fetchLiteral]		ifFalse: [^self literal: self fetchInteger]! !!DynamicTranslator methodsFor: 'interpreter shell' stamp: 'ikp 12/24/97 19:25'!fetchOffset	self inline: true.	^(self offsetValueOf: (self fetchLiteral)) "* 8"! !!DynamicTranslator methodsFor: 'interpreter shell' stamp: 'ikp 12/20/97 03:19'!peekInteger: offset	self inline: true.	self assertIsIntegerObject: (self peekLiteral: offset).	^self integerValueOf: (self peekLiteral: offset)! !!DynamicTranslator methodsFor: 'interpreter shell' stamp: 'ikp 12/20/97 03:19'!peekLiteral: offset	self inline: true.	^self longAt: (localIP + (offset * 4))! !!DynamicTranslator methodsFor: 'interpreter shell' stamp: 'ikp 1/1/98 20:19'!peekLiteralSelector: offset	"Note: this won't be inlined until the conditional is removed."	self inline: true.	DecodeLiteralSelectors		ifTrue: [^self peekLiteral: offset]		ifFalse: [^self literal: (self peekInteger: offset)]! !!DynamicTranslator methodsFor: 'interpreter shell' stamp: 'ikp 12/26/97 00:21'!peekOffset: offset	self inline: true.	^(self offsetValueOf: (self peekLiteral: offset)) "* 8"! !!DynamicTranslator methodsFor: 'interpreter shell' stamp: 'ikp 12/27/97 19:04'!skip: count	localIP _ localIP + (count * 4)! !!DynamicTranslator methodsFor: '  object memory support' stamp: 'ikp 1/5/98 18:20'!addMethodRoot: tMeth	"Record that the given translated method in the old object area may point to an object in the young area."	self beRootIfOld: tMeth! !!DynamicTranslator methodsFor: '  object memory support' stamp: 'ikp 1/14/98 01:18'!preGCAction: fullGCFlag	fullGCFlag		ifTrue: [FlushCacheOnFullGC ifTrue: [self flushMethodCache]]		ifFalse: [FlushCacheOnIncrGC ifTrue: [self flushMethodCache]].! !!DynamicTranslator methodsFor: '  message sending' stamp: 'ikp 1/4/98 14:19'!normalSend	"Send a message, starting lookup with the receiver's class."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| rcvrClass rcvr |	self inline: true.	self sharedCodeNamed: 'commonSend' inCase: CommonNormalSendCase.	newReceiver _ (rcvr _ self internalStackValue: argumentCount).	rcvrClass _ self fetchClassOf: rcvr.	self externalizeIPandSP.	self sendSelectorToClass: rcvrClass.	self internalizeIPandSP.! !!DynamicTranslator methodsFor: '  message sending' stamp: 'ikp 12/7/97 18:43'!superclassSend	"Send a message to self, starting lookup with the superclass of the class containing the currently executing method."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| superClass |	self inline: true.	self sharedCodeNamed: 'commonSuperSend' inCase: CommonSuperCase.	newReceiver _ 0.	superClass _ self superclassOf: (self methodClassOf: self internalMethod).	self externalizeIPandSP.	self sendSelectorToClass: superClass.	self internalizeIPandSP.! !!DynamicTranslator methodsFor: '  method cache support' stamp: 'ikp 1/14/98 00:58'!ejectMethodCacheLine: index	| tMeth |	EagerInlineCacheFlush ifTrue: [		"Invalidate the outgoing translated method"		tMeth _ methodCache at: index + MethodCacheTMethodCol.		tMeth = 0 ifFalse: [			self assertIsTranslatedMethod: tMeth.			self storePointerUnchecked: MethodLinkageIndex ofObject: tMeth							withValue: ConstInvalidLinkage]]! !!DynamicTranslator methodsFor: '  method cache support' stamp: 'ikp 1/6/98 01:48'!flushInlineCache	"Called from several places, just after a call to flushMethodCache"	EagerInlineCacheFlush ifFalse:		[translationCycle _ translationCycle + 2].		"ConstOne minus the tag bit"! !!DynamicTranslator methodsFor: '  method cache support' stamp: 'ikp 1/6/98 01:40'!flushMethodCache	"Flush the method cache. The method cache is flushed on every programming change.  It must also be flushed following a compaction, unless the hashing scheme is invariant, in which case remapping will suffice."	1 to: MethodCacheEntries do: [ :i | self flushMethodCacheLine: i].	mcProbe _ 0.! !!DynamicTranslator methodsFor: '  method cache support' stamp: 'ikp 1/14/98 00:59'!flushMethodCacheLine: index	self ejectMethodCacheLine: index.	"it should really only be necessary to zap the selector slot"	0 to: MethodCacheColumns - 1 do:		[:col | methodCache at: index + (MethodCacheEntries * col) put: 0]! !!DynamicTranslator methodsFor: '  method cache support' stamp: 'ikp 1/15/98 02:56'!flushMethodCacheSelective: sel	"Flush all entries of the method cache that refer to the given selector.	Note: we first invalidate all translated methods, and then reinstate those that are reachable through the method cache by bringing them forward into the new translation cycle.  This is not perfect (monomorphic send sites [the happiest clients of the inline cache] never refill themselves from the method cache, so they are hit worst by this scheme) -- but it's better than the 'correct' solution of scanning the whole of object memory."	| probe |	self inline: false.	self flushInlineCache.	1 to: MethodCacheEntries do: [:i |		probe _ methodCache at: i + MethodCacheSelectorCol.		probe = 0 ifFalse:			[probe = sel				ifTrue: [self flushMethodCacheLine: i]				ifFalse: [self preserveMethodCacheLine: i]]]! !!DynamicTranslator methodsFor: '  method cache support' stamp: 'ikp 1/6/98 01:43'!initMethodCache	1 to: MethodCacheSize do: [ :i | methodCache at: i put: 0 ].	mcProbe _ 0.! !!DynamicTranslator methodsFor: '  method cache support' stamp: 'ikp 1/14/98 00:58'!preserveMethodCacheLine: index	| tMeth |	EagerInlineCacheFlush ifFalse: [		"bring this translated method forward into the current cycle"		tMeth _ methodCache at: index + MethodCacheTMethodCol.		self assertIsTranslatedMethod: tMeth.		self storePointerUnchecked: MethodCycleIndex ofObject: tMeth						withValue: translationCycle]! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'ikp 1/14/98 02:03'!canLinkTo: tMeth	"Apply a simply heuristic to determine if it's worth linking to this method."	self inline: true.	(UseInlineCacheDelay and: [newInlineCacheDelay = 0])		ifTrue: [^true].	^(self fetchPointer: MethodPrimIndex ofObject: tMeth) ~= ConstZero		"method has a primitive response"		or: [(((self sizeBitsOf: tMeth) "bytes"					- (MethodOpcodeStart * 4 "bytes per header word") - BaseHeaderSize)					// 8 "translated bytes per bytecode")				< inlineCacheLimit]! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'ikp 1/13/98 00:43'!checkSend: tMeth to: rcvr data: data nArgs: nArgs type: type	| prevData cacheHit prevCycle |	self inline: true.	prevData _ self fetchPointer: MethodLinkageIndex ofObject: tMeth.	EagerInlineCacheFlush ifTrue: [		cacheHit _ (data = prevData).	] ifFalse: [		prevCycle _ self fetchPointer: MethodCycleIndex ofObject: tMeth.		cacheHit _ (data = prevData and: [prevCycle = translationCycle]).	].	cacheHit ifTrue: [		statInlineCacheHits _ statInlineCacheHits + 1.		self executeLinkedSend: tMeth to: rcvr nArgs: nArgs.	] ifFalse: [		self relinkSend: tMeth to: rcvr nArgs: nArgs type: type.	]! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'ikp 1/6/98 00:30'!compactSend: tMeth type: type	| nArgs rcvr rcvrClass |	self inline: true.	self assertIsTranslatedMethod: tMeth.	nArgs _ self fetchPointer: MethodArgCountIndex ofObject: tMeth.	nArgs _ self integerValueOf: nArgs.	rcvr _ self internalStackValue: nArgs.	(self isIntegerObject: rcvr)		ifTrue: [rcvrClass _ 0]		ifFalse: [rcvrClass _ ((self baseHeader: rcvr) bitAnd: 16r1F000) + 1].	self checkSend: tMeth to: rcvr data: rcvrClass nArgs: nArgs type: type! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'ikp 1/5/98 23:28'!executeLinkedSend: tMeth to: rcvr nArgs: nArgs	"Need to set up messageSelector for the benefit of primitivePerform."	| primIdx |	self inline: true.	newReceiver _ rcvr.	"XXX this is not necessary XXX"	messageSelector _ self fetchPointer: MethodSelectorIndex ofObject: tMeth.	argumentCount _ nArgs.	primIdx _ self fetchPointer: MethodPrimIndex ofObject: tMeth.	self assertIsIntegerObject: primIdx.	primitiveIndex _ self integerValueOf: primIdx.	newMethod _ self fetchPointer: MethodMethodIndex ofObject: tMeth.	self assertIsCompiledMethod: newMethod.	newTranslatedMethod _ tMeth.	self externalizeIPandSP.	self executeNewMethod.	self internalizeIPandSP.! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'ikp 1/6/98 00:28'!immediateSend: tMeth type: type	| nArgs rcvr |	self inline: true.	self assertIsTranslatedMethod: tMeth.	nArgs _ self fetchPointer: MethodArgCountIndex ofObject: tMeth.	nArgs _ self integerValueOf: nArgs.	rcvr _ self internalStackValue: nArgs.	self checkSend: tMeth to: rcvr data: (rcvr bitAnd: 1) nArgs: nArgs type: type! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'ikp 1/6/98 00:57'!linkAndSendSelector: sel to: rcvr nArgs: nArgs type: type	"The name says it all.	sel is a Symbol; type is 0 for short sends, 1 for extended, 2 for double-extended."	| prevClass tMeth primIdx ip rcvrClass |	self inline: false.	messageSelector _ sel.	argumentCount _ nArgs.	newReceiver _ rcvr.	rcvrClass _ self fetchClassOf: rcvr.	self pushRemappableOop: rcvrClass.	self findNewMethodInClass: rcvrClass.	prevClass _ self popRemappableOop.	messageSelector ~= (self splObj: SelectorDoesNotUnderstand) ifTrue: [		tMeth _ newTranslatedMethod.		"Note: tMeth might have come out of the method cache, so we can't assume it's young."		self assertIsTranslatedMethod: tMeth.		(self canLinkTo: tMeth) ifTrue: [			(pseudoReceiver = 0) ifFalse: [prevClass _ self stableClassOf: newReceiver].			ip _ self instructionPointer.		"ip might change during lookup"			self linkSendOpcode: ip type: type receiver: newReceiver class: prevClass method: tMeth.			primIdx _ self integerObjectOf: primitiveIndex.			"this next store is probably redundant"			self storePointer: MethodClassIndex ofObject: tMeth withValue: prevClass.			self storeWord: MethodPrimIndex ofObject: tMeth withValue: primIdx]].	self executeNewMethod! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'ikp 1/6/98 00:58'!linkSendOpcode: ip type: type receiver: rcvr class: rcvrClass method: tMeth	"Rewrite the send opcode at ip.	ip:		the address of the linked extension word.	type:	0=short, 1=extended, 2=double-extended.	class:	the receiver class for which the inline cache hits."	"Note: the opcode itself is located at (ip - 4 - (type * 8))."	| op addr sendType linkData ccIndex currentMethod |	self assertAny: (addr _ 0).	self assertAny: (sendType _ 0).	(self isIntegerObject: rcvr)		ifTrue: [sendType _ ImmediateSendType.  linkData _ ConstZero]		ifFalse:			[ccIndex _ ((self formatOfClass: rcvrClass) bitAnd: 16r1F000).			 ccIndex > 0				ifTrue: [sendType _ CompactSendType.  linkData _ ccIndex + 1]				ifFalse: [sendType _ NormalSendType.  linkData _ rcvrClass]].	self assert: (sendType ~= 0).	type = ShortSendType	 		ifTrue:	[addr _ ip - 4.	op _ shortSendTable at: sendType]			ifFalse: [	type = ExtendedSendType			ifTrue:	[addr _ ip - 12.	op _ extendedSendTable at: sendType]		ifFalse: [	type = DoubleExtendedSendType	ifTrue:	[addr _ ip - 20.	op _ doubleExtendedSendTable at: sendType]	]].	self assert: (addr ~= 0).	self longAt: addr put: op.	self longAt: ip put: tMeth.	self storePointer: MethodLinkageIndex ofObject: tMeth withValue: linkData.	tMeth >= youngStart ifTrue:		"store of young object into old object"		[currentMethod _ self translatedMethod.		 currentMethod < youngStart			ifTrue: [self addMethodRoot: currentMethod]].! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'ikp 1/6/98 00:29'!normalSend: tMeth type: type	| nArgs rcvr rcvrClass |	self inline: true.	self assertIsTranslatedMethod: tMeth.	nArgs _ self fetchPointer: MethodArgCountIndex ofObject: tMeth.	nArgs _ self integerValueOf: nArgs.	rcvr _ self internalStackValue: nArgs.	rcvrClass _ self fetchClassOf: rcvr.	self checkSend: tMeth to: rcvr data: rcvrClass nArgs: nArgs type: type! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'ikp 1/6/98 00:02'!relinkSend: tMeth to: rcvr nArgs: nArgs type: type	| selector |	self inline: true.	selector _ self fetchPointer: MethodSelectorIndex ofObject: tMeth.	self externalizeIPandSP.	self linkAndSendSelector: selector to: rcvr nArgs: nArgs type: type.	self internalizeIPandSP.! !!DynamicTranslator methodsFor: '  fake inline cache' stamp: 'ikp 1/5/98 23:39'!unlinkedSend: litSel nArgs: nArgs type: type	"litSel is the literal selector (an integer index or Symbol depening on configuration).	nArgs is the argument count (a raw integer).	type is {Short,[Double]Extended}SendType."	| sel rcvr |	self inline: true.	UseInlineCache ifTrue: [		rcvr _ self internalStackValue: nArgs.		sel _ self decodeLiteralSelector: litSel.		self externalizeIPandSP.		self linkAndSendSelector: sel to: rcvr nArgs: nArgs type: type.		self internalizeIPandSP.	] ifFalse: [		messageSelector _ self decodeLiteralSelector: litSel.		argumentCount _ nArgs.		self normalSend.			"will this confuse the shared code handling?"	]! !!DynamicTranslator methodsFor: 'opcodes' stamp: 'ikp 1/1/98 19:06'!cannotReturn: resultObj	| result errantContext rcvrClass |	self inline: false.	self assertStackPointerIsExternal.	self pushRemappableOop: resultObj.	errantContext _ self pseudoContextFor: activeCachedContext.	self push: errantContext.	result _ self popRemappableOop.	self push: result.	messageSelector _ self splObj: SelectorCannotReturn.	argumentCount _ 1.	newReceiver _ errantContext.	rcvrClass _ self fetchClassOf: newReceiver.	self sendSelectorToClass: rcvrClass.! !!DynamicTranslator methodsFor: 'opcodes' stamp: 'ikp 1/2/98 20:14'!jump: offset	self inline: true.	localIP _ localIP + (offset "* 8").	offset < 0 ifTrue: [		"backward jump means we're in a loop; check for possible interrupts"		self internalQuickCheckForInterrupts.	]! !!DynamicTranslator methodsFor: 'opcodes' stamp: 'ikp 1/2/98 20:14'!jumpIfFalseBy: offset	| boolean |	self inline: true.	boolean _ self internalStackTop.	boolean = falseObj ifTrue: [		self jump: offset.	] ifFalse: [		boolean = trueObj ifFalse: [			messageSelector _ self splObj: SelectorMustBeBoolean.			argumentCount _ 0.			^self normalSend		].	].	self internalPop: 1.! !!DynamicTranslator methodsFor: 'opcodes' stamp: 'ikp 1/2/98 20:14'!jumpIfTrueBy: offset	| boolean |	self inline: true.	boolean _ self internalStackTop.	boolean = trueObj ifTrue: [		self jump: offset.	] ifFalse: [		boolean = falseObj ifFalse: [			messageSelector _ self splObj: SelectorMustBeBoolean.			argumentCount _ 0.			^self normalSend		].	].	self internalPop: 1.! !!DynamicTranslator methodsFor: 'opcodes' stamp: 'ikp 1/1/98 19:07'!localReturn: value	self inline: true.	self sharedCodeNamed: 'commonLocalReturn' inCase: CommonLocalReturnCase.	self assertStackPointerIsInternal.	(self cachedSenderAt: localCP) = nilObj ifTrue: [		self externalizeIPandSP.		self cannotReturn: value.		self internalizeIPandSP.		^nil	].	self deallocateCachedContext.	self internalFetchContextRegisters.	self internalPush: value.	self internalQuickCheckForInterrupts.! !!DynamicTranslator methodsFor: 'opcodes' stamp: 'ikp 1/1/98 19:06'!nonLocalBlockReturn: value	"Return value to the sender of the home context.  Not inlined into the interpreter loop since		(a)	it isn't that fast compared to externalising ip/sp and a function call;		(b)	it causes a proliferation of temporary variables in interpret();		(c)	it isn't executed particularly frequently."	| home cp ctx returnContext senderContext nilOop |	self inline: false.	self assertStackPointerIsExternal.	nilOop _ nilObj.	home _ self cachedHomeAt: activeCachedContext.	(self isPseudoContext: home) ifTrue: [		cp _ self pseudoCachedContextAt: home.		[activeCachedContext == cp] whileFalse: [			(self cachedSenderAt: activeCachedContext) = nilObj ifTrue: [^self cannotReturn: value].			self deallocateCachedContext.		].		(self cachedSenderAt: activeCachedContext) = nilObj ifTrue: [^self cannotReturn: value].		self deallocateCachedContext.		"return from home context"	] ifFalse: [		"Check that it is possible to reach the return context from the active context"		returnContext _ self fetchPointer: SenderIndex ofObject: home.		returnContext == nilOop ifTrue: [^self cannotReturn: value].		"Do a quick search for the return context.  If it's not found, raise the error in the		context that is trying to return.  (The cost of this is almost unmeasurably small.)"		ctx _ self cachedSenderAt: lowestCachedContext.		[ctx ~= returnContext and: [ctx ~= nilOop]] whileTrue: [			ctx _ self fetchPointer: SenderIndex ofObject: ctx.		].		ctx == nilOop ifTrue: [^self cannotReturn: value].		"Unwind the stack, zapping sender fields to prevent further use"		ctx _ self deallocateAllCachedContexts.		[ctx ~= returnContext] whileTrue: [			senderContext _ self fetchPointer: SenderIndex ofObject: ctx.			senderContext == nilOop ifTrue: [				"Returns crossing process boundaries terminate the active process"				self copyContextToCache: ctx.				self fetchContextRegisters: ctx.				^self cannotReturn: value.		"does Processor terminateActive in image"			].			self storePointerUnchecked: SenderIndex ofObject: ctx withValue: nilOop.			ctx _ senderContext.		].		"Resume execution in the returnContext"		self copyContextToCache: returnContext.	].	self fetchContextRegisters: activeCachedContext.	self push: value.	self quickCheckForInterrupts.! !!DynamicTranslator methodsFor: 'opcodes' stamp: 'ikp 1/1/98 19:07'!nonLocalReturn: value	"Return value to the sender of the method that created the active context.  For methods	this is the sender, for blocks this is the sender of the home context."	self inline: true.	self sharedCodeNamed: 'commonNonLocalReturn' inCase: CommonNonLocalReturnCase.	(self isCachedMethodContext: localCP) ifTrue: [		self localReturn: value.	] ifFalse: [		self externalizeIPandSP.		self nonLocalBlockReturn: value.		self internalizeIPandSP.	]! !!DynamicTranslator methodsFor: 'opcodes' stamp: 'ikp 1/1/98 19:06'!pushReceiverVariable: fieldIndex	self internalPush:		(self fetchPointer: fieldIndex ofObject: self internalReceiver).! !!DynamicTranslator methodsFor: 'opcodes' stamp: 'ikp 1/1/98 19:06'!pushTemporaryVariable: temporaryIndex	self internalPush: (self temporary: temporaryIndex).! !!DynamicTranslator methodsFor: 'opcodes' stamp: 'ikp 1/1/98 19:07'!sendSpecialSelector: selectorIndex nArgs: numArgs	self inline: true.	messageSelector _ self specialSelector: selectorIndex.	argumentCount _ numArgs.	self normalSend.! !!DynamicTranslator methodsFor: 'opcodes' stamp: 'ikp 1/1/98 19:06'!storeAndPopReceiverVariable: fieldIndex	"Note: This code uses storePointerUnchecked:ofObject:withValue: and does the store check explicitly in order to help the translator produce better code."	| rcvr top |	rcvr _ self internalReceiver.	top _ self internalStackTop.	(rcvr < youngStart) ifTrue: [		self possibleRootStoreInto: rcvr value: top.	].	self storePointerUnchecked: (fieldIndex)		ofObject: rcvr		withValue: top.	self internalPop: 1.! !!DynamicTranslator methodsFor: 'opcodes' stamp: 'ikp 1/1/98 19:05'!storeAndPopTemporaryVariable: temporaryIndex	self temporary: (temporaryIndex) put: self internalStackTop.	self internalPop: 1.! !!DynamicTranslator methodsFor: '  linked send opcodes' stamp: 'ikp 1/6/98 01:05'!opDoubleExtendedCompactSend	"	0:	DoubleExtendedCompactSend		1:	nil		2:	nil		3:	nil		4:	nil		5:	method"	(self initOp: DoubleExtendedCompactSend) ifFalse: [	self beginOp: DoubleExtendedCompactSend.		self skip: 5.		self compactSend: (self peekLiteral: 0) type: DoubleExtendedSendType.	self endOp: DoubleExtendedCompactSend	]! !!DynamicTranslator methodsFor: '  linked send opcodes' stamp: 'ikp 1/6/98 01:05'!opDoubleExtendedImmediateSend	"	0:	DoubleExtendedImmediateSend		1:	nil		2:	nil		3:	nil		4:	nil		5:	method"	(self initOp: DoubleExtendedImmediateSend) ifFalse: [	self beginOp: DoubleExtendedImmediateSend.		self skip: 5.		self immediateSend: (self peekLiteral: 0) type: DoubleExtendedSendType.	self endOp: DoubleExtendedImmediateSend	]! !!DynamicTranslator methodsFor: '  linked send opcodes' stamp: 'ikp 1/6/98 01:05'!opDoubleExtendedNormalSend	"	0:	DoubleExtendedNormalSend		1:	nil		2:	nil		3:	nil		4:	nil		5:	method"	(self initOp: DoubleExtendedNormalSend) ifFalse: [	self beginOp: DoubleExtendedNormalSend.		self skip: 5.		self normalSend: (self peekLiteral: 0) type: DoubleExtendedSendType.	self endOp: DoubleExtendedNormalSend	]! !!DynamicTranslator methodsFor: '  linked send opcodes' stamp: 'ikp 1/6/98 00:41'!opExtendedCompactSend	"	0:	ExtendedCompactSend		1:	nil		2:	nil		3:	method"	(self initOp: ExtendedCompactSend) ifFalse: [	self beginOp: ExtendedCompactSend.		self skip: 3.		self compactSend: (self peekLiteral: 0) type: ExtendedSendType.	self endOp: ExtendedCompactSend	]! !!DynamicTranslator methodsFor: '  linked send opcodes' stamp: 'ikp 1/6/98 00:41'!opExtendedImmediateSend	"	0:	ExtendedImmediateSend		1:	nil		2:	nil		3:	method"	(self initOp: ExtendedImmediateSend) ifFalse: [	self beginOp: ExtendedImmediateSend.		self skip: 3.		self immediateSend: (self peekLiteral: 0) type: ExtendedSendType.	self endOp: ExtendedImmediateSend	]! !!DynamicTranslator methodsFor: '  linked send opcodes' stamp: 'ikp 1/6/98 00:41'!opExtendedNormalSend	"	0:	ExtendedNormalSend		1:	nil		2:	nil		3:	method"	(self initOp: ExtendedNormalSend) ifFalse: [	self beginOp: ExtendedNormalSend.		self skip: 3.		self normalSend: (self peekLiteral: 0) type: ExtendedSendType.	self endOp: ExtendedNormalSend	]! !!DynamicTranslator methodsFor: '  linked send opcodes' stamp: 'ikp 1/5/98 23:21'!opLinkedCompactSend	"	0:	LinkedCompactSend		1:	method"	(self initOp: LinkedCompactSend) ifFalse: [	self beginOp: LinkedCompactSend.		self compactSend: self fetchLiteral type: ShortSendType.	self endOp: LinkedCompactSend	]! !!DynamicTranslator methodsFor: '  linked send opcodes' stamp: 'ikp 1/5/98 23:21'!opLinkedImmediateSend	"	0:	LinkedImmediateSend		1:	method"	(self initOp: LinkedImmediateSend) ifFalse: [	self beginOp: LinkedImmediateSend.		self immediateSend: self fetchLiteral type: ShortSendType.	self endOp: LinkedImmediateSend	]! !!DynamicTranslator methodsFor: '  linked send opcodes' stamp: 'ikp 1/5/98 23:21'!opLinkedNormalSend	"	0:	LinkedNormalSend		1:	method"	(self initOp: LinkedNormalSend) ifFalse: [	self beginOp: LinkedNormalSend.		self normalSend: self fetchLiteral type: ShortSendType.	self endOp: LinkedNormalSend	]! !!DynamicTranslator methodsFor: '  send opcodes' stamp: 'ikp 1/6/98 01:09'!opDoubleExtendedSend	"	0:	DoubleExtendedSend		1:	numArgs		2:	nil		3:	nil		4:	nil		5:	selector | translatedMethod"	(self initOp: DoubleExtendedSend) ifFalse: [	self beginOp: DoubleExtendedSend.		self skip: 5.		self unlinkedSend: (self peekLiteral: 0) nArgs: (self peekInteger: -4) type: DoubleExtendedSendType.	self endOp: DoubleExtendedSend	]! !!DynamicTranslator methodsFor: '  send opcodes' stamp: 'ikp 1/5/98 23:38'!opSendLiteralSelector0	"	0:	SendLiteralSelector0		1:	selector"	(self initOp: SendLiteralSelector0) ifFalse: [	self beginOp: SendLiteralSelector0.		self unlinkedSend: self fetchLiteral nArgs: 0 type: ShortSendType.	self endOp: SendLiteralSelector0	]! !!DynamicTranslator methodsFor: '  send opcodes' stamp: 'ikp 1/6/98 00:36'!opSendLiteralSelector1	"	0:	SendLiteralSelector1		1:	selector"	(self initOp: SendLiteralSelector1) ifFalse: [	self beginOp: SendLiteralSelector1.		self unlinkedSend: self fetchLiteral nArgs: 1 type: ShortSendType.	self endOp: SendLiteralSelector1	]! !!DynamicTranslator methodsFor: '  send opcodes' stamp: 'ikp 1/6/98 00:37'!opSendLiteralSelector2	"	0:	SendLiteralSelector2		1:	selector"	(self initOp: SendLiteralSelector2) ifFalse: [	self beginOp: SendLiteralSelector2.		self unlinkedSend: self fetchLiteral nArgs: 2 type: ShortSendType.	self endOp: SendLiteralSelector2	]! !!DynamicTranslator methodsFor: '  send opcodes' stamp: 'ikp 1/6/98 00:39'!opSingleExtendedSend	"	0:	SingleExtendedSend		1:	numArgs		2:	nil		3:	selector"	(self initOp: SingleExtendedSend) ifFalse: [	self beginOp: SingleExtendedSend.		self skip: 3.		self unlinkedSend: (self peekLiteral: 0) nArgs: (self peekInteger: -2) type: ExtendedSendType.	self endOp: SingleExtendedSend	]! !!DynamicTranslator methodsFor: '  super send opcodes' stamp: 'ikp 1/5/98 18:24'!opDoubleExtendedSuper	"	0:	DoubleExtendedSuper		1:	numArgs		2:	nil		3:	nil		4:	nil		5:	selector"	(self initOp: DoubleExtendedSuper) ifFalse: [	self beginOp: DoubleExtendedSuper.		argumentCount _ self peekInteger: 1.		messageSelector _ self peekLiteralSelector: 5.		self skip: 5.		"do this before send, in case of doesNotUnderstand"		self superclassSend.	self endOp: DoubleExtendedSuper	]! !!DynamicTranslator methodsFor: '  super send opcodes' stamp: 'ikp 1/5/98 18:24'!opSingleExtendedSuper	"	0:	SingleExtendedSuper		1:	numArgs		2:	nil		3:	selector"	(self initOp: SingleExtendedSuper) ifFalse: [	self beginOp: SingleExtendedSuper.		argumentCount _ self peekInteger: 1.		messageSelector _ self peekLiteralSelector: 3.		self skip: 3.		self superclassSend.	self endOp: SingleExtendedSuper	]! !!DynamicTranslator methodsFor: '  jump opcodes' stamp: 'ikp 12/24/97 03:03'!opLongJumpIfFalse	| offset |	(self initOp: LongJumpIfFalse) ifFalse: [	self beginOp: LongJumpIfFalse.		offset _ self fetchOffset.		self skip: 2.		self jumpIfFalseBy: offset.	self endOp: LongJumpIfFalse	]! !!DynamicTranslator methodsFor: '  jump opcodes' stamp: 'ikp 12/24/97 03:03'!opLongJumpIfTrue	| offset |	(self initOp: LongJumpIfTrue) ifFalse: [	self beginOp: LongJumpIfTrue.		offset _ self fetchOffset.		self skip: 2.		self jumpIfTrueBy: offset.	self endOp: LongJumpIfTrue	]! !!DynamicTranslator methodsFor: '  jump opcodes' stamp: 'ikp 1/2/98 20:13'!opLongUnconditionalJump	"LongUnconditionalJump	signedOffset	nil	nil"	| offset |	(self initOp: LongUnconditionalJump) ifFalse: [	self beginOp: LongUnconditionalJump.		offset _ self fetchOffset.		self skip: 2.		self jump: offset.	self endOp: LongUnconditionalJump	]! !!DynamicTranslator methodsFor: '  jump opcodes' stamp: 'ikp 12/24/97 03:03'!opShortConditionalJump	| offset |	(self initOp: ShortConditionalJump) ifFalse: [	self beginOp: ShortConditionalJump.		offset _ self fetchOffset.		"must be broken into two for inlining"		self jumpIfFalseBy: offset.	self endOp: ShortConditionalJump	]! !!DynamicTranslator methodsFor: '  jump opcodes' stamp: 'ikp 12/24/97 03:03'!opShortUnconditionalJump	| offset |	(self initOp: ShortUnconditionalJump) ifFalse: [	self beginOp: ShortUnconditionalJump.		offset _ self fetchOffset.		"must be broken into two for inlining"		self jump: offset.	self endOp: ShortUnconditionalJump	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 01:58'!opDoubleExtendedPushConstant	(self initOp: DoubleExtendedPushConstant) ifFalse: [	self beginOp: DoubleExtendedPushConstant.		self internalPush: self fetchLiteralConstant.		self skip: 4.	self endOp: DoubleExtendedPushConstant	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 01:58'!opDoubleExtendedPushLiteralVariable	(self initOp: DoubleExtendedPushLiteralVariable) ifFalse: [	self beginOp: DoubleExtendedPushLiteralVariable.		self internalPush: (self fetchPointer: ValueIndex ofObject: self fetchLiteralVariable).		self skip: 4.	self endOp: DoubleExtendedPushLiteralVariable	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/18/97 00:35'!opDoubleExtendedPushReceiverVariable	(self initOp: DoubleExtendedPushReceiverVariable) ifFalse: [	self beginOp: DoubleExtendedPushReceiverVariable.		self pushReceiverVariable: (self fetchInteger).		self skip: 4.	self endOp: DoubleExtendedPushReceiverVariable	]"	self skip: 1.	self pushReceiverVariable: (currentBytecode bitAnd: 16rF)."! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/18/97 00:44'!opDoubleExtendedStoreAndPopReceiverVariable	self inline: true.	(self initOp: DoubleExtendedStoreAndPopReceiverVariable) ifFalse: [	self beginOp: DoubleExtendedStoreAndPopReceiverVariable.		self storePointer: (self fetchInteger) ofObject: self internalReceiver withValue: self internalStackTop.		self internalPop: 1.		self skip: 4.	self endOp: DoubleExtendedStoreAndPopReceiverVariable	].! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 02:00'!opDoubleExtendedStoreLiteralVariable	self inline: true.	(self initOp: DoubleExtendedStoreLiteralVariable) ifFalse: [	self beginOp: DoubleExtendedStoreLiteralVariable.		self storePointer: ValueIndex ofObject: (self fetchLiteralVariable) withValue: self internalStackTop.		self skip: 4.	self endOp: DoubleExtendedStoreLiteralVariable	].! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/18/97 00:39'!opDoubleExtendedStoreReceiverVariable	self inline: true.	(self initOp: DoubleExtendedStoreReceiverVariable) ifFalse: [	self beginOp: DoubleExtendedStoreReceiverVariable.		self storePointer: (self fetchInteger) ofObject: self internalReceiver withValue: self internalStackTop.		self skip: 4.	self endOp: DoubleExtendedStoreReceiverVariable	].! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/18/97 03:08'!opDuplicateTop	(self initOp: DuplicateTop) ifFalse: [	self beginOp: DuplicateTop.		self internalPush: self internalStackTop.		self skip: 1.	self endOp: DuplicateTop	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 02:01'!opExtendedPushConstant	(self initOp: ExtendedPushConstant) ifFalse: [	self beginOp: ExtendedPushConstant.		self internalPush: (self fetchLiteralConstant).		self skip: 2.	self endOp: ExtendedPushConstant	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 02:01'!opExtendedPushLiteralVariable	(self initOp: ExtendedPushLiteralVariable) ifFalse: [	self beginOp: ExtendedPushLiteralVariable.		self internalPush: (self fetchPointer: ValueIndex ofObject: (self fetchLiteralVariable)).		self skip: 2.	self endOp: ExtendedPushLiteralVariable	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/17/97 23:25'!opExtendedPushReceiverVariable	(self initOp: ExtendedPushReceiverVariable) ifFalse: [	self beginOp: ExtendedPushReceiverVariable.		self pushReceiverVariable: (self fetchInteger).		self skip: 2.	self endOp: ExtendedPushReceiverVariable	]"	self skip: 1.	self pushReceiverVariable: (currentBytecode bitAnd: 16rF)."! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/17/97 23:25'!opExtendedPushTemporaryVariable	(self initOp: ExtendedPushTemporaryVariable) ifFalse: [	self beginOp: ExtendedPushTemporaryVariable.		self pushTemporaryVariable: (self fetchInteger).		self skip: 2.	self endOp: ExtendedPushTemporaryVariable	]"	self skip: 1.	self pushTemporaryVariable: (currentBytecode bitAnd: 16rF)."! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 02:02'!opExtendedStoreAndPopLiteralVariable	self inline: true.	(self initOp: ExtendedStoreAndPopLiteralVariable) ifFalse: [	self beginOp: ExtendedStoreAndPopLiteralVariable.		self storePointer: ValueIndex ofObject: (self fetchLiteralVariable) withValue: self internalStackTop.		self internalPop: 1.		self skip: 2.	self endOp: ExtendedStoreAndPopLiteralVariable	].! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/18/97 00:04'!opExtendedStoreAndPopReceiverVariable	self inline: true.	(self initOp: ExtendedStoreAndPopReceiverVariable) ifFalse: [	self beginOp: ExtendedStoreAndPopReceiverVariable.		self storePointer: (self fetchInteger) ofObject: self internalReceiver withValue: self internalStackTop.		self internalPop: 1.		self skip: 2.	self endOp: ExtendedStoreAndPopReceiverVariable	].! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/18/97 00:04'!opExtendedStoreAndPopTemporaryVariable	self inline: true.	(self initOp: ExtendedStoreAndPopTemporaryVariable) ifFalse: [	self beginOp: ExtendedStoreAndPopTemporaryVariable.		self temporary: (self fetchInteger) put: self internalStackTop.		self internalPop: 1.		self skip: 2.	self endOp: ExtendedStoreAndPopTemporaryVariable	].! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 02:02'!opExtendedStoreLiteralVariable	self inline: true.	(self initOp: ExtendedStoreLiteralVariable) ifFalse: [	self beginOp: ExtendedStoreLiteralVariable.		self storePointer: ValueIndex ofObject: (self fetchLiteralVariable) withValue: self internalStackTop.		self skip: 2.	self endOp: ExtendedStoreLiteralVariable	].! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/18/97 00:00'!opExtendedStoreReceiverVariable	self inline: true.	(self initOp: ExtendedStoreReceiverVariable) ifFalse: [	self beginOp: ExtendedStoreReceiverVariable.		self storePointer: (self fetchInteger) ofObject: self internalReceiver withValue: self internalStackTop.		self skip: 2.	self endOp: ExtendedStoreReceiverVariable	].! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/18/97 00:00'!opExtendedStoreTemporaryVariable	self inline: true.	(self initOp: ExtendedStoreTemporaryVariable) ifFalse: [	self beginOp: ExtendedStoreTemporaryVariable.		self temporary: (self fetchInteger) put: self internalStackTop.		self skip: 2.	self endOp: ExtendedStoreTemporaryVariable	].! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/18/97 03:09'!opPopStack	(self initOp: PopStack) ifFalse: [	self beginOp: PopStack.		self internalPop: 1.		self skip: 1.	self endOp: PopStack	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/8/97 00:13'!opPushActiveContext	(self initOp: PushActiveContext) ifFalse: [	self beginOp: PushActiveContext.		self skip: 1.		self externalizeIPandSP.		self push: (self pseudoContextFor: activeCachedContext).		self internalizeIPandSP.	self endOp: PushActiveContext	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/20/97 19:37'!opPushConstant	(self initOp: PushConstant) ifFalse: [	self beginOp: PushConstant.		self internalPush: (self fetchLiteral).	self endOp: PushConstant	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 02:07'!opPushConstantFalse	(self initOp: PushConstantFalse) ifFalse: [	self beginOp: PushConstantFalse.		self internalPush: falseObj.		self skip: 1.	self endOp: PushConstantFalse	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 02:08'!opPushConstantMinusOne	(self initOp: PushConstantMinusOne) ifFalse: [	self beginOp: PushConstantMinusOne.		self internalPush: ConstMinusOne.		self skip: 1.	self endOp: PushConstantMinusOne	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 02:08'!opPushConstantNil	(self initOp: PushConstantNil) ifFalse: [	self beginOp: PushConstantNil.		self internalPush: nilObj.		self skip: 1.	self endOp: PushConstantNil	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 02:08'!opPushConstantOne	(self initOp: PushConstantOne) ifFalse: [	self beginOp: PushConstantOne.		self internalPush: ConstOne.		self skip: 1.	self endOp: PushConstantOne	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 02:35'!opPushConstantTrue	(self initOp: PushConstantTrue) ifFalse: [	self beginOp: PushConstantTrue.		self internalPush: trueObj.		self skip: 1.	self endOp: PushConstantTrue	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 02:08'!opPushConstantTwo	(self initOp: PushConstantTwo) ifFalse: [	self beginOp: PushConstantTwo.		self internalPush: ConstTwo.		self skip: 1.	self endOp: PushConstantTwo	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 02:08'!opPushConstantZero	(self initOp: PushConstantZero) ifFalse: [	self beginOp: PushConstantZero.		self internalPush: ConstZero.		self skip: 1.	self endOp: PushConstantZero	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/20/97 19:36'!opPushLiteralConstant	(self initOp: PushLiteralConstant) ifFalse: [	self beginOp: PushLiteralConstant.		self internalPush: (self fetchLiteralConstant).	self endOp: PushLiteralConstant	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/19/97 02:15'!opPushLiteralVariable	(self initOp: PushLiteralVariable) ifFalse: [	self beginOp: PushLiteralVariable.		self internalPush: (self fetchPointer: ValueIndex ofObject: (self fetchLiteralVariable)).	self endOp: PushLiteralVariable	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/18/97 03:09'!opPushReceiver	(self initOp: PushReceiver) ifFalse: [	self beginOp: PushReceiver.		self internalPush: self internalReceiver.		self skip: 1.	self endOp: PushReceiver	]! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/17/97 22:06'!opPushReceiverVariable	(self initOp: PushReceiverVariable) ifFalse: [	self beginOp: PushReceiverVariable.		self pushReceiverVariable: (self fetchInteger).	self endOp: PushReceiverVariable	]"	self skip: 1.	self pushReceiverVariable: (currentBytecode bitAnd: 16rF)."! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/17/97 22:07'!opPushTemporaryVariable	(self initOp: PushTemporaryVariable) ifFalse: [	self beginOp: PushTemporaryVariable.		self pushTemporaryVariable: (self fetchInteger).	self endOp: PushTemporaryVariable	]"	self skip: 1.	self pushTemporaryVariable: (currentBytecode bitAnd: 16rF)."! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/17/97 22:07'!opStoreAndPopReceiverVariable	(self initOp: StoreAndPopReceiverVariable) ifFalse: [	self beginOp: StoreAndPopReceiverVariable.		self storeAndPopReceiverVariable: (self fetchInteger).	self endOp: StoreAndPopReceiverVariable	]"	| rcvr top |	self skip: 1.	rcvr _ self internalReceiver.	top _ self internalStackTop.	(rcvr < youngStart) ifTrue: [		self possibleRootStoreInto: rcvr value: top.	].	self storePointerUnchecked: (currentBytecode bitAnd: 7)		ofObject: rcvr		withValue: top.	self internalPop: 1."! !!DynamicTranslator methodsFor: '  stack opcodes' stamp: 'ikp 12/17/97 22:07'!opStoreAndPopTemporaryVariable	(self initOp: StoreAndPopTemporaryVariable) ifFalse: [	self beginOp: StoreAndPopTemporaryVariable.		self storeAndPopTemporaryVariable: (self fetchInteger).	self endOp: StoreAndPopTemporaryVariable	]"	self skip: 1.	self temporary: (currentBytecode bitAnd: 7) put: self internalStackTop.	self internalPop: 1."! !!DynamicTranslator methodsFor: '  return opcodes' stamp: 'ikp 1/1/98 19:07'!opReturnConstant	(self initOp: ReturnConstant) ifFalse: [	self beginOp: ReturnConstant.		self nonLocalReturn: (self fetchLiteral).	self endOp: ReturnConstant	]! !!DynamicTranslator methodsFor: '  return opcodes' stamp: 'ikp 12/8/97 00:19'!opReturnReceiver	(self initOp: ReturnReceiver) ifFalse: [	self beginOp: ReturnReceiver.		self skip: 1.		self nonLocalReturn: self internalReceiver.	self endOp: ReturnReceiver	]! !!DynamicTranslator methodsFor: '  return opcodes' stamp: 'ikp 1/1/98 19:07'!opReturnTopFromBlock	(self initOp: ReturnTopFromBlock) ifFalse: [	self beginOp: ReturnTopFromBlock.		self skip: 1.		self localReturn: (self internalStackTop).	self endOp: ReturnTopFromBlock	]! !!DynamicTranslator methodsFor: '  return opcodes' stamp: 'ikp 12/8/97 00:19'!opReturnTopFromMethod	(self initOp: ReturnTopFromMethod) ifFalse: [	self beginOp: ReturnTopFromMethod.		self skip: 1.		self nonLocalReturn: (self internalStackTop).	self endOp: ReturnTopFromMethod	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/18/97 03:09'!opPrimAdd	| rcvr arg result |	(self initOp: PrimAdd) ifFalse: [	self beginOp: PrimAdd.		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg) ifTrue: [			result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).			(self isIntegerValue: result) ifTrue: [				self longAt: (localSP _ localSP - 4)						put: (self integerObjectOf: result).				self skip: 1.				^self nextOp.			].		].		self skip: 1.		self externalizeIPandSP.		successFlag _ true.		self primitiveFloatAdd.		self internalizeIPandSP.		successFlag ifFalse: [self sendSpecialSelector: 0 nArgs: 1].	self endOp: PrimAdd.	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/8/97 00:22'!opPrimAt	| index rcvr result rcvrClass stringy |	(self initOp: PrimAt) ifFalse: [	self beginOp: PrimAt.		self skip: 1.		index _ self internalStackTop.		rcvr _ self internalStackValue: 1.		successFlag _ self isIntegerObject: index.		successFlag ifTrue: [			rcvrClass _ self fetchClassOf: rcvr.			stringy _ rcvrClass = (self splObj: ClassString).			(stringy or: [self okArrayClass: rcvrClass])				ifFalse: [successFlag _ false]].		successFlag ifTrue: [			index _ self integerValueOf: index.			self externalizeIPandSP.			result _ self stObject: rcvr at: index.			self internalizeIPandSP.			(stringy and: [successFlag]) ifTrue: [result _ self characterForAscii: result]].		successFlag ifTrue: [			self internalPop: 2 thenPush: result.		] ifFalse: [			self sendSpecialSelector: 16 nArgs: 1.		].	self endOp: PrimAt	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/7/97 21:28'!opPrimAtPut	| value valToStore index rcvr rcvrClass stringy |	(self initOp: PrimAtPut) ifFalse: [	self beginOp: PrimAtPut.		self skip: 1.		value _ valToStore _ self internalStackTop.		index _ self internalStackValue: 1.		rcvr _ self internalStackValue: 2.		successFlag _ self isIntegerObject: index.		successFlag ifTrue: [			rcvrClass _ self fetchClassOf: rcvr.			stringy _ rcvrClass = (self splObj: ClassString).			(stringy or: [self okArrayClass: rcvrClass])				ifFalse: [successFlag _ false]].		successFlag ifTrue: [			index _ self integerValueOf: index.			stringy ifTrue: [valToStore _ self asciiOfCharacter: value].			self stObject: rcvr at: index put: valToStore.		].		successFlag ifTrue: [			self internalPop: 3 thenPush: value.		] ifFalse: [			self sendSpecialSelector: 17 nArgs: 2.		].	self endOp: PrimAtPut	].! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/7/97 21:31'!opPrimBlockCopy	| rcvrClass |	(self initOp: PrimBlockCopy) ifFalse: [	self beginOp: PrimBlockCopy.		self skip: 1.		rcvrClass _ self fetchClassOf: (self internalStackValue: 1).		successFlag _ true.		self success:			((rcvrClass = (self splObj: ClassPseudoContext)) or:			 [rcvrClass = (self splObj: ClassBlockContext) or:			 [rcvrClass = (self splObj: ClassMethodContext)]]).		successFlag ifTrue: [			self externalizeIPandSP.			self primitiveBlockCopy.			self internalizeIPandSP.		].		successFlag ifFalse: [			self sendSpecialSelector: 24 nArgs: 1.		].	self endOp: PrimBlockCopy	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/18/97 03:12'!opPrimDivide	| rcvr arg result |	(self initOp: PrimDivide) ifFalse: [	self beginOp: PrimDivide.		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg) ifTrue: [			rcvr _ self integerValueOf: rcvr.			arg _ self integerValueOf: arg.			((arg ~= 0) and: [(rcvr \\ arg) = 0]) ifTrue: [				result _ rcvr // arg.  "generates C / operation"				(self isIntegerValue: result) ifTrue: [					self longAt: (localSP _ localSP - 4)							put: (self integerObjectOf: result).					self skip: 1.					^self nextOp.				].			].		].		self skip: 1.		self externalizeIPandSP.		successFlag _ true.		self primitiveFloatDivide.		self internalizeIPandSP.		successFlag ifFalse: [self sendSpecialSelector: 9 nArgs: 1].	self endOp: PrimDivide	].! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/18/97 03:10'!opPrimEqual	| rcvr arg |	(self initOp: PrimEqual) ifFalse: [	self beginOp: PrimEqual.		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg) ifTrue: [			self internalPop: 2 thenPushBool: rcvr = arg.			self skip: 1.			^self nextOp.		].		self skip: 1.		self externalizeIPandSP.		successFlag _ true.		self primitiveFloatEqual.		self internalizeIPandSP.		successFlag ifFalse: [self sendSpecialSelector: 6 nArgs: 1].	self endOp: PrimEqual	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/18/97 03:12'!opPrimEquivalent	| rcvr arg |	(self initOp: PrimEquivalent) ifFalse: [	self beginOp: PrimEquivalent.		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		self internalPop: 2 thenPushBool: rcvr = arg.		self skip: 1.	self endOp: PrimEquivalent	].! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/18/97 03:12'!opPrimGreaterOrEqual	| rcvr arg |	(self initOp: PrimGreaterOrEqual) ifFalse: [	self beginOp: PrimGreaterOrEqual.		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg) ifTrue: [			self internalPop: 2 thenPushBool: rcvr >= arg.			self skip: 1.			^self nextOp.		].		self skip: 1.		self externalizeIPandSP.		successFlag _ true.		self primitiveFloatGreaterOrEqual.		self internalizeIPandSP.		successFlag ifFalse: [self sendSpecialSelector: 5 nArgs: 1].	self endOp: PrimGreaterOrEqual	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/18/97 03:12'!opPrimGreaterThan	| rcvr arg |	(self initOp: PrimGreaterThan) ifFalse: [	self beginOp: PrimGreaterThan.		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg) ifTrue: [			self internalPop: 2 thenPushBool: rcvr > arg.			self skip: 1.			^self nextOp.		].		self skip: 1.		self externalizeIPandSP.		successFlag _ true.		self primitiveFloatGreaterThan.		self internalizeIPandSP.		successFlag ifFalse: [self sendSpecialSelector: 3 nArgs: 1].	self endOp: PrimGreaterThan	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/18/97 03:12'!opPrimLessOrEqual	| rcvr arg |	(self initOp: PrimLessOrEqual) ifFalse: [	self beginOp: PrimLessOrEqual.		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg) ifTrue: [			self internalPop: 2 thenPushBool: rcvr <= arg.			self skip: 1.			^self nextOp.		].		self skip: 1.		self externalizeIPandSP.		successFlag _ true.		self primitiveFloatLessOrEqual.		self internalizeIPandSP.		successFlag ifFalse: [self sendSpecialSelector: 4 nArgs: 1].	self endOp: PrimLessOrEqual	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/18/97 03:13'!opPrimLessThan	| rcvr arg |	(self initOp: PrimLessThan) ifFalse: [	self beginOp: PrimLessThan.		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg) ifTrue: [			self internalPop: 2 thenPushBool: rcvr < arg.			self skip: 1.			^self nextOp.		].		self skip: 1.		self externalizeIPandSP.		successFlag _ true.		self primitiveFloatLessThan.		self internalizeIPandSP.		successFlag ifFalse: [self sendSpecialSelector: 2 nArgs: 1].	self endOp: PrimLessThan	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/18/97 03:13'!opPrimMultiply	| rcvr arg result |	(self initOp: PrimMultiply) ifFalse: [	self beginOp: PrimMultiply.		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg) ifTrue: [			rcvr _ self integerValueOf: rcvr.			arg _ self integerValueOf: arg.			result _ rcvr * arg.			((arg = 0 or: [(result // arg) = rcvr]) and:			 [self isIntegerValue: result]) ifTrue: [				self longAt: (localSP _ localSP - 4)						put: (self integerObjectOf: result).				self skip: 1.				^self nextOp.				].		].		self skip: 1.		self externalizeIPandSP.		successFlag _ true.		self primitiveFloatMultiply.		self internalizeIPandSP.		successFlag ifFalse: [self sendSpecialSelector: 8 nArgs: 1].	self endOp: PrimMultiply	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/18/97 03:13'!opPrimNotEqual	| rcvr arg |	(self initOp: PrimNotEqual) ifFalse: [	self beginOp: PrimNotEqual.		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg) ifTrue: [			self internalPop: 2 thenPushBool: rcvr ~= arg.			self skip: 1.			^self nextOp.		].		self skip: 1.		self externalizeIPandSP.		successFlag _ true.		self primitiveFloatNotEqual.		self internalizeIPandSP.		successFlag ifFalse: [self sendSpecialSelector: 7 nArgs: 1].	self endOp: PrimNotEqual	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/7/97 23:57'!opPrimPointX	(self initOp: PrimPointX) ifFalse: [	self beginOp: PrimPointX.		self skip: 1.		self externalizeIPandSP.		self primitivePointX.		self internalizeIPandSP.		successFlag ifFalse: [self sendSpecialSelector: 30 nArgs: 0].	self endOp: PrimPointX	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/7/97 23:58'!opPrimPointY	(self initOp: PrimPointY) ifFalse: [	self beginOp: PrimPointY.		self skip: 1.		self externalizeIPandSP.		self primitivePointY.		self internalizeIPandSP.		successFlag ifFalse: [self sendSpecialSelector: 31 nArgs: 0].	self endOp: PrimPointY	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/7/97 23:58'!opPrimSize	"See the comment in bytePrimitiveAt"	| arrayClass |	(self initOp: PrimSize) ifFalse: [	self beginOp: PrimSize.		self skip: 1.		arrayClass _ self fetchClassOf: (self internalStackValue: 0).		(self okStreamArrayClass: arrayClass) ifTrue: [			self externalizeIPandSP.			self primitiveSize.			self internalizeIPandSP.		] ifFalse: [			self sendSpecialSelector: 18 nArgs: 0.		].	self endOp: PrimSize	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/18/97 03:10'!opPrimSubtract	| rcvr arg result |	(self initOp: PrimSubtract) ifFalse: [	self beginOp: PrimSubtract.		rcvr _ self internalStackValue: 1.		arg _ self internalStackValue: 0.		(self areIntegers: rcvr and: arg) ifTrue: [			result _ (self integerValueOf: rcvr) - (self integerValueOf: arg).			(self isIntegerValue: result) ifTrue: [				self longAt: (localSP _ localSP - 4)						put: (self integerObjectOf: result).				self skip: 1.				^self nextOp.			].		].		self skip: 1.		self externalizeIPandSP.		successFlag _ true.		self primitiveFloatSubtract.		self internalizeIPandSP.		successFlag ifFalse: [self sendSpecialSelector: 1 nArgs: 1].	self endOp: PrimSubtract	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/7/97 23:59'!opPrimValue	| block |	(self initOp: PrimValue) ifFalse: [	self beginOp: PrimValue.		self skip: 1.		block _ self internalStackTop.		successFlag _ true.		argumentCount _ 0.		self successIfClassOf: block is: (self splObj: ClassBlockContext).		successFlag ifTrue: [			self externalizeIPandSP.			self primitiveValue.			self internalizeIPandSP.		].		successFlag ifFalse: [			self sendSpecialSelector: 25 nArgs: 0		].	self endOp: PrimValue	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/7/97 23:59'!opPrimValueWithArg	| block |	(self initOp: PrimValueWithArg) ifFalse: [	self beginOp: PrimValueWithArg.		self skip: 1.		block _ self internalStackValue: 1.		successFlag _ true.		argumentCount _ 1.		self successIfClassOf: block is: (self splObj: ClassBlockContext).		successFlag ifTrue: [			self externalizeIPandSP.			self primitiveValue.			self internalizeIPandSP.		].		successFlag ifFalse: [			self sendSpecialSelector: 26 nArgs: 1		].	self endOp: PrimValueWithArg	]! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/17/97 22:07'!opSendSpecialSelector	| descriptor |	(self initOp: SendSpecialSelector) ifFalse: [	self beginOp: SendSpecialSelector.		descriptor _ self fetchInteger.		self sendSpecialSelector: (descriptor >> 8) nArgs: (descriptor bitAnd: 255).	self endOp: SendSpecialSelector	].! !!DynamicTranslator methodsFor: '  common selector opcodes' stamp: 'ikp 12/17/97 22:07'!opSpecialPrimitive	| descriptor |	(self initOp: SpecialPrimitive) ifFalse: [	self beginOp: SpecialPrimitive.		descriptor _ self fetchInteger.		primitiveIndex _ (descriptor >> 16).		self externalizeIPandSP.		self primitiveResponse.		self internalizeIPandSP.		successFlag ifFalse: [			self sendSpecialSelector: ((descriptor >> 8) bitAnd: 255) nArgs: (descriptor bitAnd: 255).		].	self endOp: SpecialPrimitive	].! !!DynamicTranslator methodsFor: '  unimplemented opcodes' stamp: 'ikp 12/8/97 00:20'!opExperimental	(self initOp: Experimental) ifFalse: [	self beginOp: Experimental.		self skip: 1.		self error: 'Experimental opcode'.	self endOp: Experimental	]! !!DynamicTranslator methodsFor: '  unimplemented opcodes' stamp: 'ikp 12/8/97 00:20'!opUnknown	(self initOp: Unknown) ifFalse: [	self beginOp: Unknown.		self skip: 1.		self error: 'Unknown opcode'.	self endOp: Unknown	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/21/97 03:07'!opMacroConstAdd	"Note: inline constant is a guaranteed SmallInteger"	"0:PushConst		1:integer	 2:PrimAdd		3:nil"	| tempA tempB |	(self initOp: MacroConstAdd) ifFalse: [	self beginOp: MacroConstAdd.		tempA _ self internalStackTop.		tempB _ self peekInteger: 1.		(self isIntegerObject: tempA) ifTrue: [			tempA _ (self integerValueOf: tempA) + tempB.			(self isIntegerValue: tempA) ifTrue: [				 self longAt: localSP put: (self integerObjectOf: tempA).				 self skip: 3.				^self nextOp]].		self internalPush: self fetchLiteral.		"PushConstant"	self endOp: MacroConstAdd	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/23/97 12:05'!opMacroConstBitAnd	"Note: inline constant is a guaranteed SmallInteger"	"0:PushConst		1:integer	 2:PrimBitAnd	3:nil"	| tempA tempB |	(self initOp: MacroConstBitAnd) ifFalse: [	self beginOp: MacroConstBitAnd.		tempA _ self internalStackTop.		tempB _ self fetchLiteral.			(self isIntegerObject: tempA) ifTrue: [			self longAt: localSP put: (tempA bitAnd: tempB).			self skip: 2.			^self nextOp].		self internalPush: tempB.		"PushConstant"	self endOp: MacroConstBitAnd	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/23/97 12:05'!opMacroConstBitOr	"Note: inline constant is a guaranteed SmallInteger"	"0:PushConst		1:integer	 2:PrimBitOr		3:nil"	| tempA tempB |	(self initOp: MacroConstBitOr) ifFalse: [	self beginOp: MacroConstBitOr.		tempA _ self internalStackTop.		tempB _ self fetchLiteral.			(self isIntegerObject: tempA) ifTrue: [			self longAt: localSP put: (tempA bitOr: tempB).			self skip: 2.			^self nextOp].		self internalPush: tempB.		"PushConstant"	self endOp: MacroConstBitOr	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/21/97 03:33'!opMacroConstMul	"Note: inline constant is a guaranteed SmallInteger"	"0:PushConst		1:integer	 2:PrimMul		3:nil"	| tempA tempB result |	(self initOp: MacroConstMul) ifFalse: [	self beginOp: MacroConstMul.		tempA _ self internalStackTop.		tempB _ self peekInteger: 1.		(self isIntegerObject: tempA) ifTrue: [			tempA _ self integerValueOf: tempA.			result _ tempA * tempB.			((tempB = 0 or: [(result // tempB) = tempA]) and: [self isIntegerValue: result]) ifTrue: [				 self longAt: localSP put: (self integerObjectOf: result).				 self skip: 3.				^self nextOp]].		self internalPush: (self fetchLiteral).		"PushConstant"	self endOp: MacroConstMul	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/23/97 12:05'!opMacroConstNegativeBitShift	"Note: inline constant is a guaranteed SmallInteger [0..31]"	"0:PushConst			1:integer	 2:PrimPosBitShift	3:nil"	| tempA tempB rcvr distance result |	(self initOp: MacroConstNegativeBitShift) ifFalse: [	self beginOp: MacroConstNegativeBitShift.		tempA _ self internalStackTop.		tempB _ self fetchLiteral.			(self isIntegerObject: tempA) ifTrue: [			rcvr _ self integerValueOf: tempA.			distance _ self integerValueOf: tempB.			result _ rcvr bitShift: distance.	"ok to lose LS bits"			self longAt: localSP put: (self integerObjectOf: result).			self skip: 2.			^self nextOp].		self internalPush: tempB.		"PushConstant"	self endOp: MacroConstNegativeBitShift	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/23/97 12:05'!opMacroConstPositiveBitShift	"Note: inline constant is a guaranteed SmallInteger [0..31]"	"0:PushConst			1:integer	 2:PrimPosBitShift	3:nil"	| tempA tempB rcvr distance result |	(self initOp: MacroConstPositiveBitShift) ifFalse: [	self beginOp: MacroConstPositiveBitShift.		tempA _ self internalStackTop.		tempB _ self fetchLiteral.		(self isIntegerObject: tempA) ifTrue: [			rcvr _ self integerValueOf: tempA.			distance _ self integerValueOf: tempB.			result _ rcvr << distance.			(((result >> distance) = rcvr) and: [(self isIntegerValue: result) and: [result >= 0]]) ifTrue: [				self longAt: localSP put: (self integerObjectOf: result).				self skip: 2.				^self nextOp]].		self internalPush: tempB.		"PushConstant"	self endOp: MacroConstPositiveBitShift	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/23/97 18:52'!opMacroConstSub	"Note: inline constant is a guaranteed SmallInteger"	"0:PushConst		1:integer	 2:PrimSub		3:nil"	| tempA tempB |	(self initOp: MacroConstSub) ifFalse: [	self beginOp: MacroConstSub.		tempA _ self internalStackTop.		tempB _ self peekInteger: 1.		(self isIntegerObject: tempA) ifTrue: [			tempA _ (self integerValueOf: tempA) - tempB.			(self isIntegerValue: tempA) ifTrue: [				 self longAt: localSP put: (self integerObjectOf: tempA).				 self skip: 3.				^self nextOp]].		self internalPush: self fetchLiteral.		"PushConstant"	self endOp: MacroConstSub	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/26/97 00:22'!opMacroLoopStep	"0:PushTemp		 1:index	 2:PushConst	 3:<SmallInteger>		-- guaranteed	 4:add			 5:nil	 6:PopTemp		 7:index	 8:LongJump	 9:offset	10:nil			11:nil"	| rcvr arg offset |	(self initOp: MacroLoopStep) ifFalse: [	self beginOp: MacroLoopStep.		rcvr _ self peekInteger: 1.		rcvr _ self temporary: rcvr.		(self isIntegerObject: rcvr) ifTrue: [				rcvr _ self integerValueOf: rcvr.				arg _ self peekInteger: 3.				rcvr _ rcvr + arg.				(self isIntegerValue: rcvr) ifTrue: [					 rcvr _ self integerObjectOf: rcvr.					 arg _ self peekInteger: 7.					 self temporary: arg put: rcvr.					 offset _ self peekOffset: 9.					 self jump: (11 * 4) + offset.					^self nextOp]].		self pushTemporaryVariable: (self fetchInteger).		"PushTemporaryVariable"	self endOp: MacroLoopStep	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/25/97 01:23'!opMacroMoveTempRcvr	"0:PushTemp		1:tempIndex	 2:PopStoreRcvr	3:rcvrIndex"	| value rcvr |	(self initOp: MacroMoveTempRcvr) ifFalse: [	self beginOp: MacroMoveTempRcvr.		value _ self temporary: (self peekInteger: 1).		rcvr _ self internalReceiver.		(rcvr < youngStart) ifTrue: [self possibleRootStoreInto: rcvr value: value].		self storePointerUnchecked: (self peekInteger: 3) ofObject: rcvr withValue: value.		self skip: 3.	self endOp: MacroMoveTempRcvr	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/23/97 18:58'!opMacroPopDup	(self initOp: MacroPopDup) ifFalse: [	self beginOp: MacroPopDup.		self longAt: localSP put: (self internalStackValue: 1).		self skip: 3.	self endOp: MacroPopDup	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/26/97 00:23'!opMacroPushBlock	"	0:MacroPushBlock	1:nil			(PushActiveContext)		2:PushConstant		3:numArgs		4:PrimBlockCopy		5:nil		6:LongJump			7:offset		8:nil				9:nil"	"We can do a LOT better than the following.  Consider the current implementation as	a placeholder for some impending rocket science."	| offset |	(self initOp: MacroPushBlock) ifFalse: [	self beginOp: MacroPushBlock.		self skip: 5.											"finishing PrimBlockCopy"		self externalizeIPandSP.		self push: (self pseudoContextFor: localCP).			"pushActiveContext -- provokes GC"		localIP _ self			cCoerce: self internalInstructionPointer			"in case of GC"			to: 'char *'.		self push: (self peekLiteral: -2).						"pushLiteral: numArgs"		successFlag _ true.		self primitiveBlockCopy.								"pop: 2 thenPush: closure"		successFlag ifFalse: [			"ip/sp should be internal, but I don't think it matters"			self sendSpecialSelector: 24 nArgs: 1.				"ip/sp correct for primitive failure:"			^self nextOp.									"	return from fail to longJump"		].		self internalizeIPandSP.		offset _ self peekOffset: 2.		self jump: (2 * 8) + offset.				"tPC is two bytecodes early for longJump"	self endOp: MacroPushBlock	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/26/97 21:25'!opMacroPushInstTemp	"0:PushInst		1:index1	 2:PushTemp	3:index2"	| index |	(self initOp: MacroPushInstTemp) ifFalse: [	self beginOp: MacroPushInstTemp.		index _ self peekInteger: 1.		self pushReceiverVariable: index.		index _ self peekInteger: 3.		self pushTemporaryVariable: index.		self skip: 3.	self endOp: MacroPushInstTemp	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/25/97 20:57'!opMacroPushTempConst	"0:PushTemp		1:index1	 2:PushConst	3:literal"	| index literal |	(self initOp: MacroPushTempConst) ifFalse: [	self beginOp: MacroPushTempConst.		index _ self peekInteger: 1.		self pushTemporaryVariable: index.		literal _ self peekLiteral: 3.		self internalPush: literal.		self skip: 3.	self endOp: MacroPushTempConst	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/25/97 18:16'!opMacroPushTempTemp	"0:PushTemp		1:index1	 2:PushTemp	3:index2"	| index |	(self initOp: MacroPushTempTemp) ifFalse: [	self beginOp: MacroPushTempTemp.		index _ self peekInteger: 1.		self pushTemporaryVariable: index.		index _ self peekInteger: 3.		self pushTemporaryVariable: index.		self skip: 3.	self endOp: MacroPushTempTemp	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/25/97 22:46'!opMacroTempConstAdd	"0:PushTemp		1:index	 2:PushConst	3:<SmallInteger>		-- guaranteed	 4:add			5:nil	 6:PopTemp		7:index"	| rcvr arg |	(self initOp: MacroTempConstAdd) ifFalse: [	self beginOp: MacroTempConstAdd.		rcvr _ self peekInteger: 1.		rcvr _ self temporary: rcvr.		(self isIntegerObject: rcvr) ifTrue: [				rcvr _ self integerValueOf: rcvr.				arg _ self peekInteger: 3.				rcvr _ rcvr + arg.				(self isIntegerValue: rcvr) ifTrue: [					 self internalPush: (self integerObjectOf: rcvr).					 self skip: 5.					^self nextOp]].		self pushTemporaryVariable: (self fetchInteger).		"PushTemporaryVariable"	self endOp: MacroTempConstAdd	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/25/97 22:46'!opMacroTempConstAddTemp	"0:PushTemp		1:index	 2:PushConst	3:<SmallInteger>		-- guaranteed	 4:add			5:nil	 6:PopTemp		7:index"	| rcvr arg |	(self initOp: MacroTempConstAddTemp) ifFalse: [	self beginOp: MacroTempConstAddTemp.		rcvr _ self peekInteger: 1.		rcvr _ self temporary: rcvr.		(self isIntegerObject: rcvr) ifTrue: [				rcvr _ self integerValueOf: rcvr.				arg _ self peekInteger: 3.				rcvr _ rcvr + arg.				(self isIntegerValue: rcvr) ifTrue: [					 rcvr _ self integerObjectOf: rcvr.					 arg _ self peekInteger: 7.					 self temporary: arg put: rcvr.					 self skip: 7.					^self nextOp]].		self pushTemporaryVariable: (self fetchInteger).		"PushTemporaryVariable"	self endOp: MacroTempConstAddTemp	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/26/97 21:25'!opMacroTempConstLessEq	"0:PushTemp		1:index1		-- guaranteed SI	 2:PushConst	3:literal		-- guaranteed SI	 4:LessOrEqual	5:nil"	| rcvr arg |	(self initOp: MacroTempConstLessEq) ifFalse: [	self beginOp: MacroTempConstLessEq.		self assertIsIntegerObject: (self peekLiteral: 1).		rcvr _ self peekInteger: 1.		rcvr _ self temporary: rcvr.		(self isIntegerObject: rcvr) ifTrue:			[rcvr _ self integerValueOf: rcvr.			 self assertIsIntegerObject: (self peekLiteral: 3).			 arg _ self peekInteger: 3.			 rcvr <= arg				ifTrue: [self internalPush: trueObj]				ifFalse: [self internalPush: falseObj].			 self skip: 5.			^self nextOp].		self pushTemporaryVariable: (self fetchInteger).		"PushTemp"	self endOp: MacroTempConstLessEq	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/25/97 18:28'!opMacroTempTempAdd	"0:PushTemp		1:index1	 2:PushTemp	3:index2	 4:add			5:nil"	| tempA tempB |	(self initOp: MacroTempTempAdd) ifFalse: [	self beginOp: MacroTempTempAdd.		tempA _ self temporary: (self peekInteger: 1).		"index1"		tempB _ self temporary: (self peekInteger: 3).		"index2"		(self areIntegers: tempA and: tempB) ifTrue: [				tempA _ (self integerValueOf: tempA) + (self integerValueOf: tempB).				(self isIntegerValue: tempA) ifTrue: [					 self internalPush: (self integerObjectOf: tempA).					 self skip: 5.					^self nextOp]].		self pushTemporaryVariable: (self fetchInteger).		"PushTemporaryVariable"	self endOp: MacroTempTempAdd	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/20/97 17:30'!opMacroTempTempAddTemp	"0:PushTemp		1:index1	 2:PushTemp	3:index2	 4:add			5:nil	 6:PopStoreTemp 7:index3"	| tempA tempB |	(self initOp: MacroTempTempAddTemp) ifFalse: [	self beginOp: MacroTempTempAddTemp.		tempA _ self temporary: (self peekInteger: 1).		"index1"		tempB _ self temporary: (self peekInteger: 3).		"index2"		(self areIntegers: tempA and: tempB) ifTrue: [				tempA _ (self integerValueOf: tempA) + (self integerValueOf: tempB).				(self isIntegerValue: tempA) ifTrue: [					 self temporary: (self peekInteger: 7) put: (self integerObjectOf: tempA).					 self skip: 7.					^self nextOp]].		self pushTemporaryVariable: (self fetchInteger).		"PushTemporaryVariable"	self endOp: MacroTempTempAddTemp	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/25/97 18:32'!opMacroTempTempMul	"0:PushTemp		1:index1	 2:PushTemp	3:index2	 4:PrimMultiply	5:nil"	| tempA tempB result |	(self initOp: MacroTempTempMul) ifFalse: [	self beginOp: MacroTempTempMul.		tempA _ self temporary: (self peekInteger: 1).		"index1"		tempB _ self temporary: (self peekInteger: 3).		"index2"		(self areIntegers: tempA and: tempB) ifTrue: [				tempA _ self integerValueOf: tempA.				tempB _ self integerValueOf: tempB.				result _ tempA * tempB.				((tempB = 0 or: [(result // tempB) = tempA]) and: [self isIntegerValue: result]) ifTrue: [					 self internalPush: (self integerObjectOf: result).					 self skip: 5.					^self nextOp]].		self pushTemporaryVariable: (self fetchInteger).		"PushTemporaryVariable"	self endOp: MacroTempTempMul	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/20/97 17:30'!opMacroTempTempMulTemp	"0:PushTemp		1:index1	 2:PushTemp	3:index2	 4:PrimMultiply	5:nil	 6:PopStoreTemp 7:index3"	| tempA tempB result |	(self initOp: MacroTempTempMulTemp) ifFalse: [	self beginOp: MacroTempTempMulTemp.		tempA _ self temporary: (self peekInteger: 1).		"index1"		tempB _ self temporary: (self peekInteger: 3).		"index2"		(self areIntegers: tempA and: tempB) ifTrue: [				tempA _ self integerValueOf: tempA.				tempB _ self integerValueOf: tempB.				result _ tempA * tempB.				((tempB = 0 or: [(result // tempB) = tempA]) and: [self isIntegerValue: result]) ifTrue: [					 self temporary: (self peekInteger: 7) put: (self integerObjectOf: result).					 self skip: 7.					^self nextOp]].		self pushTemporaryVariable: (self fetchInteger).		"PushTemporaryVariable"	self endOp: MacroTempTempMulTemp	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/25/97 18:32'!opMacroTempTempSub	"0:PushTemp		1:index1	 2:PushTemp	3:index2	 4:PrimSubtract	5:nil"	| tempA tempB |	(self initOp: MacroTempTempSub) ifFalse: [	self beginOp: MacroTempTempSub.		tempA _ self temporary: (self peekInteger: 1).		"index1"		tempB _ self temporary: (self peekInteger: 3).		"index2"		(self areIntegers: tempA and: tempB) ifTrue: [				tempA _ (self integerValueOf: tempA) - (self integerValueOf: tempB).				(self isIntegerValue: tempA) ifTrue: [					 self internalPush: (self integerObjectOf: tempA).					 self skip: 5.					^self nextOp]].		self pushTemporaryVariable: (self fetchInteger).		"PushTemporaryVariable"	self endOp: MacroTempTempSub	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/20/97 17:29'!opMacroTempTempSubTemp	"0:PushTemp		1:index1	 2:PushTemp	3:index2	 4:PrimSubtract	5:nil	 6:PopStoreTemp 7:index3"	| tempA tempB |	(self initOp: MacroTempTempSubTemp) ifFalse: [	self beginOp: MacroTempTempSubTemp.		tempA _ self temporary: (self peekInteger: 1).		"index1"		tempB _ self temporary: (self peekInteger: 3).		"index2"		(self areIntegers: tempA and: tempB) ifTrue: [				tempA _ (self integerValueOf: tempA) - (self integerValueOf: tempB).				(self isIntegerValue: tempA) ifTrue: [					 self temporary: (self peekInteger: 7) put: (self integerObjectOf: tempA).					 self skip: 7.					^self nextOp]].		self pushTemporaryVariable: (self fetchInteger).		"PushTemporaryVariable"	self endOp: MacroTempTempSubTemp	]! !!DynamicTranslator methodsFor: '  macro opcodes' stamp: 'ikp 12/26/97 00:23'!opMacroUpLoopTest	"0:PushTemp			1:index1	 2:PushConst		3:<SmallInteger>			-- SI guaranteed by translator	 4:LessOrEqual		5:nil	 6:LongJumpFalse	7:<offset>	8:<unused>			9:<unused>"	| temp limit offset |	(self initOp: MacroUpLoopTest) ifFalse: [	self beginOp: MacroUpLoopTest.		temp _ self peekInteger: 1.		temp _ self temporary: temp.		(self isIntegerObject: temp) ifTrue: [			temp _ self integerValueOf: temp.			limit _ self peekInteger: 3.			(temp <= limit)				ifTrue: "don't jump"					[self skip: 9.					^self nextOp]				ifFalse: "take jump"					[offset _ self peekOffset: 7.					 self jump: (9 * 4) + offset.		"9 words early for jump"					^self nextOp]].		self pushTemporaryVariable: (self fetchInteger).		"fail: PushTemporary"	self endOp: MacroUpLoopTest	]! !!DynamicTranslator methodsFor: 'bytecode translation' stamp: 'ikp 1/1/98 19:07'!xxPushConstant	"Called from all pushConstant bytecodes before they emit a PushConstant opcode."	"	-4	pushTempVar		_	macroPushTempConst		-0	<SmallInteger>"	self rewrite: -4 from: PushTemporaryVariable to: MacroPushTempConst.! !!DynamicTranslator methodsFor: '  send bytecodes' stamp: 'ikp 1/5/98 18:25'!xSecondExtendedSend	"	10000110		send argCount=xx selectorIndex=yyyyyy		xxyyyyyy	=>	SingleExtendedSend		nArgs		nil		selector"	"Note: see also xDoubleExtendedDoAnything"	| descriptor |	descriptor _ self nextByte.	self emitOp: SingleExtendedSend.	self emitInteger: ((descriptor >> 6) bitAnd: 3).		"arg count"	self emitSkip: 1.	self emitLiteralSelector: (descriptor bitAnd: 63 "selector index").! !!DynamicTranslator methodsFor: '  send bytecodes' stamp: 'ikp 1/2/98 18:21'!xSendLiteralSelector	"	11xxyyyy	sendLiteralSelector yyyy with {illegal 0 1 2}[xx] args	=>	SendLiteralSelector{0,1,2,3}		selector"	"Note: see also xDoubleExtendedDoAnything"	| nArgs |	nArgs _ (((currentByte >> 4) bitAnd: 3) - 1).	nArgs = 0	ifTrue: [self emitOp: SendLiteralSelector0]	ifFalse: [	nArgs = 1	ifTrue: [self emitOp: SendLiteralSelector1]		ifFalse: [	nArgs = 2	ifTrue: [self emitOp: SendLiteralSelector2]	]].	self emitLiteralSelector: (currentByte bitAnd: 15).! !!DynamicTranslator methodsFor: '  send bytecodes' stamp: 'ikp 1/1/98 22:58'!xSingleExtendedSend	"	10000011		send argCount=xxx selectorIndex=yyyyy		xxxyyyyy	=>	SingleExtendedSend		nArgs		nil		selector"	"Note: see also xDoubleExtendedDoAnything"	| descriptor |	descriptor _ self nextByte.	self emitOp: SingleExtendedSend.	self emitInteger: (descriptor >> 5).		"arg count"	self emitSkip: 1.	self emitLiteralSelector: (descriptor bitAnd: 31 "selector index").! !!DynamicTranslator methodsFor: '  send bytecodes' stamp: 'ikp 1/1/98 22:59'!xSingleExtendedSuper	"	10000101		super send argCount=xxx selectorIndex=yyyyy		xxxyyyyy	=>	SingleExtendedSuper		nArgs		nil		selector"	"Note: see also xDoubleExtendedDoAnything"	| descriptor |	descriptor _ self nextByte.	self emitOp: SingleExtendedSuper.	self emitInteger: (descriptor >> 5).		"arg count"	self emitSkip: 1.	self emitLiteralSelector: (descriptor bitAnd: 31 "selector index").! !!DynamicTranslator methodsFor: '  return bytecodes' stamp: 'ikp 12/25/97 19:10'!xReturnFalse	self emitOp: ReturnConstant.	self emitLiteral: falseObj.! !!DynamicTranslator methodsFor: '  return bytecodes' stamp: 'ikp 12/25/97 19:10'!xReturnNil	self emitOp: ReturnConstant.	self emitLiteral: nilObj.! !!DynamicTranslator methodsFor: '  return bytecodes' stamp: 'ikp 12/25/97 19:10'!xReturnReceiver	self emitOp: ReturnReceiver.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  return bytecodes' stamp: 'ikp 12/25/97 19:10'!xReturnTopFromBlock	self emitOp: ReturnTopFromBlock.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  return bytecodes' stamp: 'ikp 12/25/97 19:10'!xReturnTopFromMethod	self emitOp: ReturnTopFromMethod.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  return bytecodes' stamp: 'ikp 12/25/97 19:10'!xReturnTrue	self emitOp: ReturnConstant.	self emitLiteral: trueObj.! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 1/1/98 22:50'!xDoubleExtendedDoAnything	"Replaces the Blue Book double-extended send [132], in which	the first byte was wasted on 8 bits of argument count.	Here we use 3 bits for the operation sub-type (opType),	and the remaining 5 bits for argument count where needed.	The last byte give access to 256 instVars or literals.	See also secondExtendedSendBytecode.	"	"Translator paradise: we've got FIVE extension words to play with!!"	| descriptor index opType nArgs |	descriptor _ self nextByte.	"was: byte2"	index _ self nextByte.		"was: byte3"	opType _ (descriptor >> 5).	nArgs _ (descriptor bitAnd: 16r1F).	opType = 0 ifTrue: [ "DoubleExtendedSend numArgs nil nil nil selector"		 self emitOp: DoubleExtendedSend.		 self emitInteger: nArgs.		 self emitSkip: 3.		^self emitLiteralSelector: index].	opType = 1 ifTrue: [ "DoubleExtendedSuper numArgs nil nil nil selector"		 self emitOp: DoubleExtendedSuper.		 self emitInteger: nArgs.		 self emitSkip: 3.		^self emitLiteralSelector: index].	opType = 2 ifTrue: [ "DoubleExtendedPushReceiverVar index nil nil nil nil"		 self emitOp: DoubleExtendedPushReceiverVariable.		 self emitInteger: index.		^self emitSkip: 4].	opType = 3 ifTrue: [ "DoubleExtendedPushConst constant nil nil nil nil"		 self emitOp: DoubleExtendedPushConstant.		 self emitLiteralConstant: index.		^self emitSkip: 4].	opType = 4 ifTrue: [ "DoubleExtendedPushLiteralVar association nil nil nil nil"		 self emitOp: DoubleExtendedPushLiteralVariable.		 self emitLiteralVariable: index.		^self emitSkip: 4].	opType = 5 ifTrue: [ "DoubleExtendedStoreReceiverVar index nil nil nil nil"		 self emitOp: DoubleExtendedStoreReceiverVariable.		 self emitInteger: index.		^self emitSkip: 4].	opType = 6 ifTrue: [ "DoubleExtendedStorePopReceiverVar index nil nil nil nil"		 self emitOp: DoubleExtendedStoreAndPopReceiverVariable.		 self emitInteger: index.		^self emitSkip: 4].	opType = 7 ifTrue: [ "DoubleExtendedStoreLiteralVar association nil nil nil nil"		 self emitOp: DoubleExtendedStoreLiteralVariable.		 self emitLiteralVariable: index.		^self emitSkip: 4].! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/26/97 21:25'!xDuplicateTop	"	-4	PopStack	_	MacroPopDup		-0	nil"	self rewrite: -4 from: PopStack to: MacroPopDup.	self emitOp: DuplicateTop; emitSkip: 1.! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 19:11'!xExtendedPush	"	1000000		extendedPush {Receiver Temp LiteralConst Global}[xx] index=yyyyyy		xxyyyyyy	=>	ExtendedPush{ReceiverVar,TempVar,Const,LiteralVar}		{index, index, literal, association}		nil		nil"	| descriptor variableType index |	descriptor _ self nextByte.	variableType _ (descriptor >> 6) bitAnd: 3.	index _ descriptor bitAnd: 16r3F.	variableType = 0 ifTrue:		[self emitOp: ExtendedPushReceiverVariable.		 self emitInteger: index.		^self emitSkip: 2].	variableType = 1 ifTrue:		[self emitOp: ExtendedPushTemporaryVariable.		 self emitInteger: index.		^self emitSkip: 2].	variableType = 2 ifTrue:		[self emitOp: ExtendedPushConstant.		 self emitLiteralConstant: index.		^self emitSkip: 2].	variableType = 3 ifTrue:		[self emitOp: ExtendedPushLiteralVariable.		 self emitLiteralVariable: index.		^self emitSkip: 2].	self error: 'bad type in xExtendedPush'.! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 19:11'!xExtendedStore	"	1000001		extendedStore {Receiver Temp Illegal Global}[xx] index=yyyyyy		xxyyyyyy	=>	ExtendedStore{Receiver,Temp,Literal}Variable		{index,index,association}		nil		nil"	| descriptor variableType index |	descriptor _ self nextByte.	variableType _ (descriptor >> 6) bitAnd: 3.	index _ descriptor bitAnd: 16r3F.	variableType = 0 ifTrue:		[self emitOp: ExtendedStoreReceiverVariable.		 self emitInteger: index.		^self emitSkip: 2].	variableType = 1 ifTrue:		[self emitOp: ExtendedStoreTemporaryVariable.		 self emitInteger: index.		^self emitSkip: 2].	variableType = 3 ifTrue:		[self emitOp: ExtendedStoreLiteralVariable.		 self emitLiteralVariable: index.		^self emitSkip: 2].	self error: 'illegal store in xExtendedStore'.! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 19:11'!xExtendedStoreAndPop	"	1000010		extendedStoreAndPop {Receiver Temp Illegal Global}[xx] index=yyyyyy		xxyyyyyy	=>	ExtendedStoreAndPop		000000xx		00yyyyyy		nil"	| descriptor variableType index |	descriptor _ self nextByte.	variableType _ (descriptor >> 6) bitAnd: 3.	index _ descriptor bitAnd: 16r3F.	variableType = 0 ifTrue:		[self emitOp: ExtendedStoreAndPopReceiverVariable.		 self emitInteger: index.		^self emitSkip: 2].	variableType = 1 ifTrue:		[self emitOp: ExtendedStoreAndPopTemporaryVariable.		 self emitInteger: index.		^self emitSkip: 2].	variableType = 3 ifTrue:		[self emitOp: ExtendedStoreAndPopLiteralVariable.		 self emitLiteralVariable: index.		^self emitSkip: 2].	self error: 'illegal store in xExtendedStoreAndPop'.! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 17:04'!xPopStack	self emitOp: PopStack; emitSkip: 1! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 18:44'!xPushActiveContext	self emitOp: PushActiveContext; emitSkip: 1.! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 19:11'!xPushConstantFalse	DecodeQuickConstants		ifTrue: [self emitOp: PushConstant; emitLiteral: falseObj]		ifFalse: [self emitOp: PushConstantFalse; emitSkip: 1]! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 19:27'!xPushConstantMinusOne	DecodeQuickConstants		ifTrue: [self xxPushConstant;  emitOp: PushConstant;  emitLiteral: ConstMinusOne]		ifFalse: [self emitOp: PushConstantMinusOne;  emitSkip: 1]! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 19:11'!xPushConstantNil	DecodeQuickConstants		ifTrue: [self emitOp: PushConstant; emitLiteral: nilObj]		ifFalse: [self emitOp: PushConstantNil; emitSkip: 1]! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 19:27'!xPushConstantOne	DecodeQuickConstants		ifTrue: [self xxPushConstant;  emitOp: PushConstant; emitLiteral: ConstOne]		ifFalse: [self emitOp: PushConstantOne; emitSkip: 1]! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 19:43'!xPushConstantTrue	DecodeQuickConstants		ifTrue: [self emitOp: PushConstant; emitLiteral: trueObj]		ifFalse: [self emitOp: PushConstantTrue; emitSkip: 1]! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 19:27'!xPushConstantTwo	DecodeQuickConstants		ifTrue: [self xxPushConstant;  emitOp: PushConstant; emitLiteral: ConstTwo]		ifFalse: [self emitOp: PushConstantTwo; emitSkip: 1]! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 19:27'!xPushConstantZero	DecodeQuickConstants		ifTrue: [self xxPushConstant;  emitOp: PushConstant;  emitLiteral: ConstZero]		ifFalse: [self emitOp: PushConstantZero;  emitSkip: 1]! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 20:24'!xPushLiteralConstant	"	001xxxxx		pushLiteralConstant: xxxxx	=>	PushLiteralConstant		xxxxx"	| literal |	DecodeLiteralConstants		ifTrue:			[literal _ self literal: (currentByte bitAnd: 31) ofMethod: newMethod.			 (self isIntegerObject: literal) ifTrue: [self xxPushConstant].			 self emitOp: PushConstant; emitLiteral: literal]		ifFalse:			[self emitOp: PushLiteralConstant; emitLiteralConstant: (currentByte bitAnd: 31)]! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/19/97 02:15'!xPushLiteralVariable	"	010xxxxx		pushLiteralVariable: xxxxx	=>	PushLiteralVariable		association"	self emitOp: PushLiteralVariable.	self emitLiteralVariable: (currentByte bitAnd: 31)! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 19:12'!xPushReceiver	self emitOp: PushReceiver.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/25/97 18:46'!xPushReceiverVariable	"	0000xxxx	pushReceiverVariable: xxxx	=>	PushReceiverVariable		xxxx"	self emitOp: PushReceiverVariable.	self emitInteger: (currentByte bitAnd: 15)! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/26/97 21:25'!xPushTemporaryVariable	"	0001xxxx		pushTemporaryVariable: xxxx	=>	PushTemporaryVariable		xxxx"	"	-4	PushTempVar	_	MacroPushTempTemp		-0	<SmallInteger>"	self rewrite: -4 from: PushTemporaryVariable to: MacroPushTempTemp.	"	-4	PushInstVar	_	MacroPushInstTemp		-0	<SmallInteger>"	self rewrite: -4 from: PushReceiverVariable to: MacroPushInstTemp.	self emitOp: PushTemporaryVariable.	self emitInteger: (currentByte bitAnd: 15).! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/26/97 21:25'!xStoreAndPopReceiverVariable	"	01100xxx		storeAndPopReceiverVariable: xxx	=>	StoreAndPopReceiverVariable		xxx"	"	-4	PushTempVar	_	MacroMoveTempRcvr		-0	<SmallInteger>"	self rewrite: -4 from: PushTemporaryVariable to: MacroMoveTempRcvr.	self emitOp: StoreAndPopReceiverVariable.	self emitInteger: (currentByte bitAnd: 7).! !!DynamicTranslator methodsFor: '  stack bytecodes' stamp: 'ikp 12/27/97 18:56'!xStoreAndPopTemporaryVariable	"	01101xxx		storeAndPopTemporaryVariable: xxx	=>	StoreAndPopTemporaryVariable		xxx"	"	-20	opPushTemp{Temp{Add,Sub,Mul},ConstAdd}			-16	<index>		-12	[ opMacroConst{Add,Sub.Mul}		-8	  <SmallInteger>		-4	  [ opPrim{Add,Sub.Mul}		-0	    <nil> ] ]			<--- opPointer		+0	PopStoreTemp		<--- bytePointer"	(self rewrite: -20 from: MacroTempTempAdd to: MacroTempTempAddTemp) ifFalse:	"The following two are very rare -- is it really worth it?"	[(self rewrite: -20 from: MacroTempTempSub to: MacroTempTempSubTemp) ifFalse:	[(self rewrite: -20 from: MacroTempTempMul to: MacroTempTempMulTemp) ifFalse:	"This is the first part of the loop step sequence"	[(self rewrite: -20 from: MacroTempConstAdd to: MacroTempConstAddTemp)]]].	self emitOp: StoreAndPopTemporaryVariable.	self emitInteger: (currentByte bitAnd: 7).! !!DynamicTranslator methodsFor: '  jump bytecodes' stamp: 'ikp 12/26/97 21:25'!xLongJumpIfFalse	"	101011xx		longJumpIfFalse: (xxx*256)+yyyyyyyy		yyyyyyyy	=>	LongJumpIfFalse		(xxx*256)+yyyyyyyy		nil		nil"	"	-20	MacroTempConstLessEq	_	MacroUpLoopTest		-16	<SmallInteger>		-12	[ PushConst		-8	  <SmallInteger>		-4	  PrimLessEq		-0	  nil ]"	self rewrite: -20 from: MacroTempConstLessEq to: MacroUpLoopTest.	self emitOp: LongJumpIfFalse.	self emitOffset: ((currentByte bitAnd: 3) * 256) + self nextByte.	self emitSkip: 2.! !!DynamicTranslator methodsFor: '  jump bytecodes' stamp: 'ikp 12/24/97 03:06'!xLongJumpIfTrue	"	101010xx		longJumpIfTrue: (xxx*256)+yyyyyyyy		yyyyyyyy	=>	LongJumpIfTrue		(xxx*256)+yyyyyyyy		nil		nil"	self emitOp: LongJumpIfTrue.	self emitOffset: ((currentByte bitAnd: 3) * 256) + self nextByte.	self emitSkip: 2.! !!DynamicTranslator methodsFor: '  jump bytecodes' stamp: 'ikp 12/26/97 21:25'!xLongUnconditionalJump	"	10100xxx		longUnconditionalJump: (xxx-4)*256+yyyyyyyy		yyyyyyyy	=>	LongUnconditionalJump		((xxx-4)*256)+yyyyyyyy		nil		nil"	"	-28	MacroTempConstAddTemp		_	MacroLoopStep		-24	<SmallInteger>		-20	[ PushConst		-16	  <SmallInteger>		-12	  PrimAdd		-8	  nil		-4	  PopStoreTemp		-0	  <SmallInteger> ]"	self rewrite: -28 from: MacroTempConstAddTemp to: MacroLoopStep.	self emitOp: LongUnconditionalJump.	self emitOffset: (((currentByte bitAnd: 7) - 4) * 256) + self nextByte.	self emitSkip: 2.! !!DynamicTranslator methodsFor: '  jump bytecodes' stamp: 'ikp 12/24/97 03:05'!xShortConditionalJump	"	10011xxx		shortConditionalJump: xxx	=>	ShortConditionalJump		xxx"	self emitOp: ShortConditionalJump.	self emitOffset: (currentByte bitAnd: 7) + 1."	self emitBytecode.	self emitSkip: 1."! !!DynamicTranslator methodsFor: '  jump bytecodes' stamp: 'ikp 12/24/97 03:05'!xShortUnconditionalJump	"	10010xxx		shortUnconditionalJump: xxx	=>	ShortUnconditionalJump		xxx"	self emitOp: ShortUnconditionalJump.	self emitOffset: (currentByte bitAnd: 7) + 1."	self emitBytecode.	self emitSkip: 1."! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/27/97 18:55'!xPrimAdd	"	-4	PushConstant	_	MacroConstAdd		-0	<SmallInteger>"	self rewrite: -4 fromPushIntegerTo: MacroConstAdd.	"	-12	PushTempTemp	_	MacroTempTempAdd		-8	<SmallInteger>		-4	[PushTemp]		-0	[<SmallInteger>]"	(self rewrite: -12 from: MacroPushTempTemp to: MacroTempTempAdd) ifFalse:	"	-12	PushTempTemp	_	MacroTempTempAdd		-8	<SmallInteger>		-4	[PushTemp]		-0	[<SmallInteger>]"	[self rewrite: -12 from: MacroPushTempConst to: MacroTempConstAdd].	self emitOp: PrimAdd.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:06'!xPrimAt	self emitOp: PrimAt.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:06'!xPrimAtEnd	self emitOp: SendSpecialSelector.	self emitInteger: (21 << 8) + 0.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:06'!xPrimAtPut	self emitOp: PrimAtPut.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/26/97 21:25'!xPrimBitAnd	"	-4	PushConstant	_	MacroConstBitAnd		-0	<SmallInteger>"	self rewrite: -4 fromPushIntegerTo: MacroConstBitAnd.	self emitOp: SpecialPrimitive.	self emitInteger: (PrimitiveBitAnd << 16) + (14 << 8) + 1! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/26/97 21:25'!xPrimBitOr	"	-4	PushConstant	_	MacroConstBitOr		-0	<SmallInteger>"	self rewrite: -4 fromPushIntegerTo: MacroConstBitOr.	self emitOp: SpecialPrimitive.	self emitInteger: (PrimitiveBitOr << 16) + (15 << 8) + 1! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/26/97 21:25'!xPrimBitShift	| distance |	"	-4	PushConstant	_	MacroConstBitShift		-0	<SmallInteger>"	(self wasPushInteger: -4) ifTrue:		[distance _ self integerValueOf: (self longAt: opPointer).		 ((distance >= 0) and: [distance <= 31]) ifTrue: [self rewrite: -4 to: MacroConstPositiveBitShift].		 ((distance >= -31) and: [distance < 0]) ifTrue: [self rewrite: -4 to: MacroConstNegativeBitShift]].	self emitOp: SpecialPrimitive.	self emitInteger: (PrimitiveBitShift << 16) + (12 << 8) + 1! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/26/97 21:25'!xPrimBlockCopy	"	-12	opPushActiveContext		-8	nil		-4	opPushConstant		-0	<SmallInteger>	<-- opPointer		+0	BlockCopy		<-- bytePointer		+1	LongJump		+2	<offset>	Note that we fail to cope with blocks for which the opPushConstant is generated	from an extendedPush.  Ho hum."	UseMacroPushBlock ifTrue: [		((self wasPushInteger: -4) and: [(self wasPushActiveContext: -12) and: [(self isLongJump: 1)]])			ifTrue:				[self rewrite: -12 to: MacroPushBlock.				 "record the fact that we're in a block, for special treatment of certain bytecodes."				 blockEnd _ bytePointer + 2	+ (((currentByte bitAnd: 7) - 4) * 256)											+ (self byteAt: bytePointer + 1).		]	].	self emitOp: PrimBlockCopy.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:06'!xPrimClass	self emitOp: SpecialPrimitive.	self emitInteger: (PrimitiveClass << 16) + (23 << 8) + 0! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:07'!xPrimDiv	self emitOp: SpecialPrimitive.	self emitInteger: (PrimitiveDiv << 16) + (13 << 8) + 1! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:07'!xPrimDivide	self emitOp: PrimDivide.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:07'!xPrimDo	self emitOp: SendSpecialSelector.	self emitInteger: (27 << 8) + 1! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:07'!xPrimEqual	self emitOp: PrimEqual.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:07'!xPrimEquivalent	self emitOp: PrimEquivalent.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:07'!xPrimGreaterOrEqual	self emitOp: PrimGreaterOrEqual.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:07'!xPrimGreaterThan	self emitOp: PrimGreaterThan.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/26/97 21:25'!xPrimLessOrEqual	"	-12	MacroPushTempConst	_	MacroTempConstLessEq		-8	<SmallInteger>		-4	[ PushConst		-0	[ <SmallInteger> ]"	self rewrite: -12 from: MacroPushTempConst to: MacroTempConstLessEq.	self emitOp: PrimLessOrEqual.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:07'!xPrimLessThan	self emitOp: PrimLessThan.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:07'!xPrimMakePoint	self emitOp: SpecialPrimitive.	self emitInteger: (PrimitiveMakePoint << 16) + (11 << 8) + 1! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:07'!xPrimMod	self emitOp: SpecialPrimitive.	self emitInteger: (PrimitiveMod << 16) + (10 << 8) + 1! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/26/97 21:25'!xPrimMultiply	"	-4	PushConstant	_	MacroConstMul		-0	<SmallInteger>"	self rewrite: -4 fromPushIntegerTo: MacroConstMul.	"	-12	PushTempTemp	_	MacroTempTempMul		-8	<SmallInteger>		-4	[PushTemp]		-0	[<SmallInteger>]"	self rewrite: -12 from: MacroPushTempTemp to: MacroTempTempMul.	self emitOp: PrimMultiply.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:08'!xPrimNew	self emitOp: SendSpecialSelector.	self emitInteger: (28 << 8) + 0! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:08'!xPrimNewWithArg	self emitOp: SendSpecialSelector.	self emitInteger: (29 << 8) + 1! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:08'!xPrimNext	self emitOp: SendSpecialSelector.	self emitInteger: (19 << 8) + 0! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:08'!xPrimNextPut	self emitOp: SendSpecialSelector.	self emitInteger: (20 << 8) + 1! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:08'!xPrimNotEqual	self emitOp: PrimNotEqual.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:08'!xPrimPointX	self emitOp: PrimPointX.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:08'!xPrimPointY	self emitOp: PrimPointY.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:08'!xPrimSize	self emitOp: PrimSize.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/26/97 21:25'!xPrimSubtract	"	-4	PushConstant	_	MacroConstSub		-0	<SmallInteger>"	self rewrite: -4 fromPushIntegerTo: MacroConstSub.	"	-12	PushTempTemp	_	MacroTempTempSub		-8	<SmallInteger>		-4	[ PushTemp		-0	  <SmallInteger> ]"	self rewrite: -12 from: MacroPushTempTemp to: MacroTempTempSub.	self emitOp: PrimSubtract.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:09'!xPrimValue	self emitOp: PrimValue.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  common selector bytecodes' stamp: 'ikp 12/25/97 19:09'!xPrimValueWithArg	self emitOp: PrimValueWithArg.	self emitSkip: 1.! !!DynamicTranslator methodsFor: '  unimplemented bytecodes' stamp: 'ikp 12/25/97 19:09'!xExperimental	self error: 'translating experimental opcode'! !!DynamicTranslator methodsFor: '  unimplemented bytecodes' stamp: 'ikp 12/25/97 19:09'!xUnknown	self error: 'translating unknown opcode'! !!DynamicTranslator methodsFor: 'assertions' stamp: 'ikp 1/1/98 23:53'!assertIsTranslatedMethod: anObject	(self fetchClassOf: anObject) = (self splObj: ClassTranslatedMethod)		ifFalse: [self error: 'translated method expected'].! !!DynamicTranslator methodsFor: 'obsolete' stamp: 'ikp 1/6/98 00:34'!oldCompactSend: tMeth type: type	| nArgs rcvr prevClass rcvrClass |	self inline: true.	self assertIsTranslatedMethod: tMeth.	nArgs _ self fetchPointer: MethodArgCountIndex ofObject: tMeth.	nArgs _ self integerValueOf: nArgs.	rcvr _ self internalStackValue: nArgs.	prevClass _ (self fetchPointer: MethodLinkageIndex ofObject: tMeth) - 1.	self assert: prevClass ~= 0.	(self isIntegerObject: rcvr)		ifTrue: [rcvrClass _ 0]		ifFalse: [rcvrClass _ ((self baseHeader: rcvr) bitAnd: 16r1F000)].	(rcvrClass = prevClass) ifTrue: [		self executeLinkedSend: tMeth to: rcvr nArgs: nArgs.	] ifFalse: [		self relinkSend: tMeth to: rcvr nArgs: nArgs type: type.	]! !!DynamicTranslator methodsFor: 'obsolete' stamp: 'ikp 1/6/98 00:35'!oldImmediateSend: tMeth type: type	| nArgs rcvr prevClass |	self inline: true.	self assertIsTranslatedMethod: tMeth.	nArgs _ self fetchPointer: MethodArgCountIndex ofObject: tMeth.	nArgs _ self integerValueOf: nArgs.	rcvr _ self internalStackValue: nArgs.	prevClass _ self fetchPointer: MethodLinkageIndex ofObject: tMeth.	"Check prevClass for ConstZero in order to detect flushed methods"	((self isIntegerObject: rcvr) and: [prevClass = ConstZero]) ifTrue: [		self executeLinkedSend: tMeth to: rcvr nArgs: nArgs.	] ifFalse: [		self relinkSend: tMeth to: rcvr nArgs: nArgs type: type.	]! !!DynamicTranslator methodsFor: 'obsolete' stamp: 'ikp 1/6/98 00:35'!oldNormalSend: tMeth type: type	| nArgs rcvr prevClass rcvrClass |	self inline: true.	self assertIsTranslatedMethod: tMeth.	nArgs _ self fetchPointer: MethodArgCountIndex ofObject: tMeth.	nArgs _ self integerValueOf: nArgs.	rcvr _ self internalStackValue: nArgs.	prevClass _ self fetchPointer: MethodLinkageIndex ofObject: tMeth.	rcvrClass _ self fetchClassOf: rcvr.	(rcvrClass = prevClass) ifTrue: [		self executeLinkedSend: tMeth to: rcvr nArgs: nArgs.	] ifFalse: [		self relinkSend: tMeth to: rcvr nArgs: nArgs type: type.	]! !!DynamicTranslator class methodsFor: 'class initialisation' stamp: 'ikp 1/5/98 22:27'!initialize		"DynamicTranslator initialize"	super initialize.	self initializeConfiguration.	self initializeOpcodeTables.		"initialises OpcodeTable and TranslatorOpcodeEncodings (pool dict)"	self initializeTranslationTable.	self initializeSharedCodeIndices.	self initializePrimitiveIndices.	self initializeTranslatedMethodIndices.	self initializeSendTypes.	OpcodeTableSize = TranslatorOpcodeEncodings size		ifFalse: [self error: 'table size mismatch'].! !!DynamicTranslator class methodsFor: 'class initialisation' stamp: 'ikp 1/14/98 19:57'!initializeConfiguration		"DynamicTranslator initialize"	"Tunable translator parameters.  Changes to these parameters take effect immediately	in the Simulator.  Changes take effect in the compiled VM only after regenerating	the C sources and recompiling to produce a new executable.  (The options manifest	themselves as the [constant] conditions in 'if (0) {...} else {...}' and 'if (1) {...} else {...}'	statements in the generated C code.  Corollary: this facility adds no overheads to the	compiled VM, provided care is taken not to upset the CCodeGenerator's inlining	mechanisms.)"FreezeConfiguration = nil ifTrue: [FreezeConfiguration _ false].	"see DynInterp>>translateTestSuite"FreezeConfiguration ifTrue: [Transcript cr; show: 'WARNING -- configuration frozen!!'] ifFalse: [	DecodeLiteralSelectors	_ true.		"lookup selectors at translation time"	DecodeLiteralVariables	_ true.		"lookup global/class/pool associations at translation time"	DecodeLiteralConstants	_ true.		"lookup literal frame constants at translation time"	DecodeQuickConstants	_ true.		"use PushConstant opcode for all pushConstantX bytecodes"	UseMethodCacheHashBits	_ true.		"preserve method cache across minor GCs"	UseMacroOpcodes		_ true.		"use macro opcodes for common bytecode sequences"	UseMacroPushBlock		_ true.		"optimise block creation sequences"	UseInlineCache			_ true.		"enable the Fake Inline Cache"	InlineCacheLimit		_ 128.		"do not link to methods larger than this (in bytecodes)"	EagerInlineCacheFlush	_ false.		"invalidate translated method when ejected from method cache"	UseInlineCacheDelay		_ true.		"delay linking in the inline cache"	InlineCacheDelay		_ 5.			"number of method cache hits before inline cache is linked""Note: the following will also flush the inline cache if EagerInlineCacheFlush is true, but this is possibly NOT what we wantwhen the inline cache delay is operational"	FlushCacheOnFullGC		_ true.		"flush method cache at every full GC"	FlushCacheOnIncrGC		_ false.		"flush method cache at every incremental GC"	ConstInvalidLinkage		_ 1333.		"guaranteed not to match a class, compact index, or ConstOne"]! !!DynamicTranslator class methodsFor: 'class initialisation' stamp: 'ikp 1/5/98 22:14'!initializeOpcodeTables			"DynamicTranslator initialize"	"This method replaces the two separate initialisation methods for OpcodeTable and	TranslatorOpcodeEncodings.  It enforces correspondance between encoding and position	in the opcode dispatch table (which is only required for running the simulator)."	| missing declared defined suspect recompile |	TranslatorOpcodeEncodings = nil ifTrue:		[TranslatorOpcodeEncodings _ IdentityDictionary new.		self inform:'DynamicTranslator>>TranslatorOpcodeEncodings initialised.Unless you are filing-in this source code for the first time,consider forcing recompilation of me and my subclasses.'].	TranslatorOpcodeEncodings associationsDo: [:assoc | assoc value: 0].	recompile _ false.	"The following collection could be inferred from the defined selectors, but I prefer to keep the	encodings predictable (and hence debuggable) for the moment.  The order is completely arbitrary."	#(DoubleExtendedPushConstant DoubleExtendedPushLiteralVariable DoubleExtendedPushReceiverVariable DoubleExtendedSend DoubleExtendedStoreAndPopReceiverVariable DoubleExtendedStoreLiteralVariable DoubleExtendedStoreReceiverVariable DoubleExtendedSuper DuplicateTop Experimental ExtendedPushConstant ExtendedPushLiteralVariable ExtendedPushReceiverVariable ExtendedPushTemporaryVariable ExtendedStoreAndPopLiteralVariable ExtendedStoreAndPopReceiverVariable ExtendedStoreAndPopTemporaryVariable ExtendedStoreLiteralVariable ExtendedStoreReceiverVariable ExtendedStoreTemporaryVariable LongJumpIfFalse LongJumpIfTrue LongUnconditionalJump PopStack PrimAdd PrimAt PrimAtPut PrimBlockCopy PrimDivide PrimEqual PrimEquivalent PrimGreaterOrEqual PrimGreaterThan PrimLessOrEqual PrimLessThan PrimMultiply PrimNotEqual PrimPointX PrimPointY PrimSize PrimSubtract PrimValue PrimValueWithArg PushActiveContext PushConstant PushConstantFalse PushConstantMinusOne PushConstantNil PushConstantOne PushConstantTrue PushConstantTwo PushConstantZero PushLiteralConstant PushLiteralVariable PushReceiver PushReceiverVariable PushTemporaryVariable ReturnConstant ReturnReceiver ReturnTopFromBlock ReturnTopFromMethod SendLiteralSelector0 SendLiteralSelector1 SendLiteralSelector2 SendSpecialSelector ShortConditionalJump ShortUnconditionalJump SingleExtendedSend SingleExtendedSuper SpecialPrimitive StoreAndPopReceiverVariable StoreAndPopTemporaryVariable Unknown	MacroMoveTempRcvr MacroPushTempTemp MacroPushInstTemp	MacroPushTempConst MacroTempConstLessEq	MacroTempConstAdd MacroTempConstAddTemp	MacroTempTempAdd MacroTempTempSub MacroTempTempMul	MacroTempTempAddTemp MacroTempTempSubTemp MacroTempTempMulTemp	MacroConstAdd MacroConstSub MacroConstMul	MacroConstPositiveBitShift MacroConstNegativeBitShift MacroConstBitAnd MacroConstBitOr	MacroPopDup MacroPushBlock MacroUpLoopTest MacroLoopStep	LinkedImmediateSend LinkedCompactSend LinkedNormalSend	ExtendedImmediateSend ExtendedCompactSend ExtendedNormalSend	DoubleExtendedImmediateSend DoubleExtendedCompactSend DoubleExtendedNormalSend)		doWithIndex: [:opname :index |			(TranslatorOpcodeEncodings includesKey: opname) ifFalse: [recompile _ true].			(TranslatorOpcodeEncodings at: opname ifAbsent: [0]) = 0				ifFalse: [self error: 'duplicated opcode: ' , opname].			TranslatorOpcodeEncodings at: opname put: index].	missing _ OrderedCollection new.	TranslatorOpcodeEncodings associationsDo: [:assoc | assoc value = 0 ifTrue: [missing add: assoc]].	missing isEmpty ifFalse:		[(self confirm: (String streamContents: [:str |			str nextPutAll: 'The following opcodes were not initialised:'; cr; cr.			missing doWithIndex: [:assoc :i |				i \\ 6 = 0 ifTrue: [str cr] ifFalse: [str space].				str nextPutAll: assoc key].			str cr; cr; nextPutAll: 'Shall I remove then from the encodings pool?']))				ifTrue:					[recompile _ true.		"paranoid, but safe"					'Removing opcodes...'							displayProgressAt: Sensor cursorPoint							from: 0 to: missing size							during: [:bar |								missing doWithIndex: [:assoc :i |									bar value: i.									(Smalltalk allCallsOn: assoc) isEmpty										ifTrue: [TranslatorOpcodeEncodings removeKey: assoc key]										ifFalse: [self error: assoc key , ' is still referenced']]]]].	OpcodeTableSize _ TranslatorOpcodeEncodings size.	OpcodeTable _ Array new: OpcodeTableSize.	TranslatorOpcodeEncodings associationsDo: [:assoc |		OpcodeTable at: assoc value put: ('op' , assoc key) asSymbol].	declared _ TranslatorOpcodeEncodings keys.	defined _ DynamicTranslator selectors select: [:sel | sel beginsWith: 'op'].	suspect _ declared reject: [:sel | defined includes: ('op' , sel) asSymbol].	suspect isEmpty ifFalse:		[Transcript cr; show: 'The following opcodes were declared but have no implementation:'; cr; tab.		suspect do: [:sel | Transcript space; show: sel]].	suspect _ defined reject: [:sel | declared includes: (sel copyFrom: 3 to: sel size) asSymbol].	suspect isEmpty ifFalse:		[Transcript cr; show: 'The following opcodes are implemented but have no implementation:'; cr; tab.		suspect do: [:sel | Transcript space; show: sel]].	recompile ifTrue:		[(self confirm: 'Shared pools have been changed.  Shall I recompileaffected classes (highly recommended)?') ifTrue:			[DynamicTranslator recompile: DynamicTranslator]]! !!DynamicTranslator class methodsFor: 'class initialisation' stamp: 'ikp 1/1/98 19:20'!initializePrimitiveIndices		"DynamicTranslator initialize"	PrimitiveBitAnd		_ self findPrimitiveIndex: #primitiveBitAnd.	PrimitiveBitOr		_ self findPrimitiveIndex: #primitiveBitOr.	PrimitiveBitShift	_ self findPrimitiveIndex: #primitiveBitShift.	PrimitiveClass		_ self findPrimitiveIndex: #primitiveClass.	PrimitiveDiv		_ self findPrimitiveIndex: #primitiveDiv.	PrimitiveMakePoint	_ self findPrimitiveIndex: #primitiveMakePoint.	PrimitiveMod		_ self findPrimitiveIndex: #primitiveMod.! !!DynamicTranslator class methodsFor: 'class initialisation' stamp: 'ikp 1/7/98 02:23'!initializeSendTypes		"DynamicTranslator initialize"	ShortSendType _ 0.	ExtendedSendType _ 1.	DoubleExtendedSendType _ 2.	ImmediateSendType _ 1.	CompactSendType _ 2.	NormalSendType _ 3.! !!DynamicTranslator class methodsFor: 'class initialisation' stamp: 'ikp 1/4/98 15:45'!initializeSharedCodeIndices		"DynamicTranslator initialize"	CommonLocalReturnCase		_ ReturnTopFromBlock - 1.	"implicit return at end of block"	CommonNonLocalReturnCase	_ ReturnTopFromMethod - 1.	"explicit return"	CommonNormalSendCase		_ SendSpecialSelector - 1.	CommonSuperCase			_ SingleExtendedSuper - 1.! !!DynamicTranslator class methodsFor: 'class initialisation' stamp: 'ikp 1/5/98 22:40'!initializeTranslatedMethodIndices			"DynamicTranslator initialize"	MethodBiasIndex			_ 0.		"bias + 0-relative pre-inc tPC // 8 == Smalltalk 1-relative post-inc vPC"	MethodSelectorIndex		_ 1.		"the method's selector"	MethodArgCountIndex	_ 2.		"number of arguments"	MethodMethodIndex		_ 3.		"original CompiledMethod"	MethodClassIndex		_ 4.		"the expected class of the receiver"	MethodPrimIndex		_ 5.		"primitive index of this method"	MethodCycleIndex		_ 6.		"translation cycle to which this method belongs"	MethodLinkageIndex		_ 7.		"additional data with which to check linked sends"	"the following are currently unused by the Fake Inline Cache..."	MethodCheckIndex		_ nil.		"prologue: check opcode"	MethodCheckExtension	_ nil.		"check opcode extension word"	MethodActivateIndex		_ nil.		"prologue: activation opcode"	MethodActivateExtension	_ nil.		"activation opcode extension word"	MethodOpcodeStart		_ 8.		"first opcode in translated method"	"Notes:	  -	the original selector is not available in relink, so is stored in the header during translation.			  -	argumentCount is needed even in linked sends, in order to pop the stack.  Sigh."! !!DynamicTranslator class methodsFor: 'class initialisation' stamp: 'ikp 1/7/98 03:50'!initializeTranslationTable		"DynamicTranslator initialize"	"Note: This table will be used to generate a C switch statement."	TranslationTable _ Array new: 256.	self table: TranslationTable from:	#(		(  0  15	 xPushReceiverVariable)		( 16  31	 xPushTemporaryVariable)		( 32  63	 xPushLiteralConstant)		( 64  95	 xPushLiteralVariable)		( 96 103	 xStoreAndPopReceiverVariable)		(104  111	 xStoreAndPopTemporaryVariable)		(112		 xPushReceiver)		(113		 xPushConstantTrue)		(114		 xPushConstantFalse)		(115		 xPushConstantNil)		(116		 xPushConstantMinusOne)		(117		 xPushConstantZero)		(118		 xPushConstantOne)		(119		 xPushConstantTwo)		(120		 xReturnReceiver)		(121		 xReturnTrue)		(122		 xReturnFalse)		(123		 xReturnNil)		(124		 xReturnTopFromMethod)		(125		 xReturnTopFromBlock)		(126		 xUnknown)		(127		 xUnknown)		(128		 xExtendedPush)		(129		 xExtendedStore)		(130		 xExtendedStoreAndPop)		(131		 xSingleExtendedSend)		(132		 xDoubleExtendedDoAnything)		(133		 xSingleExtendedSuper)		(134		 xSecondExtendedSend)		(135		 xPopStack)		(136		 xDuplicateTop)		(137		 xPushActiveContext)		(138 143	 xExperimental)		(144 151	 xShortUnconditionalJump)		(152 159	 xShortConditionalJump)		(160 167	 xLongUnconditionalJump)		(168 171	 xLongJumpIfTrue)		(172 175	 xLongJumpIfFalse)		(176		 xPrimAdd)		(177		 xPrimSubtract)		(178		 xPrimLessThan)		(179		 xPrimGreaterThan)		(180		 xPrimLessOrEqual)		(181		 xPrimGreaterOrEqual)		(182		 xPrimEqual)		(183		 xPrimNotEqual)		(184		 xPrimMultiply)		(185		 xPrimDivide)		(186		 xPrimMod)		(187		 xPrimMakePoint)		(188		 xPrimBitShift)		(189		 xPrimDiv)		(190		 xPrimBitAnd)		(191		 xPrimBitOr)			(192		 xPrimAt)		(193		 xPrimAtPut)		(194		 xPrimSize)		(195		 xPrimNext)		(196		 xPrimNextPut)		(197		 xPrimAtEnd)		(198		 xPrimEquivalent)		(199		 xPrimClass)		(200		 xPrimBlockCopy)		(201		 xPrimValue)		(202		 xPrimValueWithArg)		(203		 xPrimDo)		(204		 xPrimNew)		(205		 xPrimNewWithArg)		(206		 xPrimPointX)		(207		 xPrimPointY)		(208 255	 xSendLiteralSelector)	).	"self checkTableSelectors: TranslationTable"! !!DynamicTranslator class methodsFor: 'constants' stamp: 'ikp 1/5/98 01:22'!opcodeEncodings	^TranslatorOpcodeEncodings! !!DynamicTranslator class methodsFor: 'constants' stamp: 'ikp 1/1/98 19:27'!opcodeTable	^OpcodeTable! !!DynamicTranslator class methodsFor: 'constants' stamp: 'ikp 1/1/98 19:27'!translationTable	^TranslationTable! !!DynamicTranslator class methodsFor: 'translation' stamp: 'ikp 1/10/98 01:39'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'opcodeTable'		declareC: 'int opcodeTable[', (OpcodeTableSize + 1) printString, ']'.	aCCodeGenerator var: 'shortSendTable'			declareC: 'int shortSendTable[4]'.	aCCodeGenerator var: 'extendedSendTable'		declareC: 'int extendedSendTable[4]'.	aCCodeGenerator var: 'doubleExtendedSendTable'	declareC: 'int doubleExtendedSendTable[4]'.! !!DynamicTranslator class methodsFor: 'utilities' stamp: 'ikp 1/5/98 02:33'!disassemble: tMeth	"Select the following line:			DynamicTranslator disassemble: (thisContext copy instVarAt: 5)	and then 'inspect it' for a quick demonstration.	(Try implementing *that* in Java!!)"	| opNames word constants defaultPrinter printers |	opNames _ self opcodeNameMap.	constants _ { nil. true. false }.	defaultPrinter _	 [:w |		'	' , ((constants includes: w)			ifTrue: [w printString]			ifFalse: ['<' , w class printString , '>'])].	printers _ IdentityDictionary new		at: SmallInteger			put: [:w | opNames at: w ifAbsent: ['	' , w printString]];		at: Symbol				put: [:w | '	' , w printString];		at: TranslatedMethod		put: [:w | '	[' , (self headerStringOf: w) , ']'];		at: Association			put: [:w | '	Association' , ((w key isMemberOf: Symbol)																ifTrue: [' #' , w key]																ifFalse: [''])];		yourself.	^String streamContents: [:str |		str	nextPutAll: (self headerStringOf: tMeth); cr.		MethodOpcodeStart + 1 to: tMeth size do: [:pc |			word _ tMeth at: pc.			str	print: pc; tab;				nextPutAll: ((printers at: word class ifAbsent: [defaultPrinter]) value: word);				cr]]! !!DynamicTranslator class methodsFor: 'utilities' stamp: 'ikp 1/5/98 02:32'!headerStringOf: tMeth	^String streamContents: [:str | str		print: (tMeth at: MethodClassIndex + 1);		nextPutAll: '>>';		print: (tMeth at: MethodSelectorIndex + 1);		nextPutAll: ' (args='; print: (tMeth at: MethodArgCountIndex + 1);		nextPutAll: ', prim='; print: (tMeth at: MethodPrimIndex + 1);		nextPutAll: ', bias='; print: (tMeth at: MethodBiasIndex + 1);		nextPutAll: ', cycle='; print: (tMeth at: MethodCycleIndex + 1);		nextPut: $)]! !!DynamicTranslator class methodsFor: 'utilities' stamp: 'ikp 1/5/98 02:25'!opcodeNameMap	"Note: assumes that the opcode set of the running VM corresponds	to that of the VM implementation in the image."	| tableSize opAddr opName map |	map _ IdentityDictionary new.	tableSize _ Smalltalk vmTable: -1 at: 0.	1 to: tableSize do: [:i |		opAddr _ Smalltalk vmTable: -1 at: i.		opName _ DynamicTranslator opcodeEncodings keyAtValue: i.		map at: opAddr put: opName].	^map! !!DynamicTranslator class methodsFor: 'private' stamp: 'ikp 12/4/97 16:48'!checkTableSelectors: anArray	| selectors cls missing |	selectors _ IdentitySet new.	cls _ DynamicInterpreter.	[cls == Object] whileFalse:		[selectors addAll: cls selectors.		cls _ cls superclass].	missing _ anArray reject: [:sel | selectors includes: sel].	missing isEmpty ifFalse:		[Transcript cr; show: 'The following table selectors are undefined: '; tab.		(IdentitySet new addAll: missing; yourself) do: [:sel | Transcript space; nextPutAll: sel].		Transcript cr; endEntry.		self halt.]! !!DynamicTranslator class methodsFor: 'private' stamp: 'ikp 1/1/98 03:07'!findPrimitiveIndex: primitiveSelector	self primitiveTable doWithIndex: [:sel :i | sel == primitiveSelector ifTrue: [^i - 1]].	self error: 'primitive not found'! !!DynamicTranslator class methodsFor: 'private' stamp: 'ikp 1/3/98 01:40'!inlineCacheLimit	^Smalltalk vmParameterAt: 19! !!DynamicTranslator class methodsFor: 'private' stamp: 'ikp 1/3/98 01:41'!inlineCacheLimit: newLimit	| oldLimit |	oldLimit _ Smalltalk vmParameterAt: 19 put: newLimit.	Object flushCache.	^oldLimit! !!DynamicTranslator class methodsFor: 'private' stamp: 'ikp 1/1/98 03:07'!recompile: aClass	| selectors |	selectors _ aClass selectors.	('Recompiling ' , aClass name)		displayProgressAt: Sensor cursorPoint		from: 0 to: selectors size		during: [:bar |			selectors doWithIndex: [:sel :i |				bar value: i.				aClass recompile: sel from: aClass]]! !!DynamicTranslator class methodsFor: 'documentation' stamp: 'ikp 12/28/97 01:29'!commonBytecodeSequences"pushTrue shortJumpIfTrue						-> extendedJump		(unimplemented)pushTrue shortJumpIfFalse						-> extendedNoop		(unimplemented)pushFalse shortJumpIfTrue						-> extendedNop		(unimplemented)pushFalse shortJumpIfFalse						-> extendedJump		(unimplemented)pushLit returnTop								-> returnLitpop dup											-> popDup			(implemented)thisCtx pushLit blockCopy longJump				-> pushBlock		(implemented)pushLit add										-> pushLitAdd		(implemented)pushLit sub										-> pushLitSub		(implemented)pushLit mul										-> pushLitMul		(implemented)pushLit bitShift									-> pushLitBitShift	(implemented)pushLit bitOr									-> pushLitBitAnd		(implemented)pushLit bitAnd									-> pushLitBitOr		(implemented){cond} jumpTrue									-> {cond}JumpTrue{cond} jumpFalse									-> {cond}JumpFalsepushTemp pushTemp add popStoreTemp			-> addTemps			(implemented)pushTemp popStoreInst							-> moveTempInst		(implemented)pushTemp pushConst <= jumpFalse				-> loopTestUppushTemp pushConst >= jumpFalse				-> loopTestDownpushTemp pushConst + popStoreTemp longJump	-> loopStepspecialise return bytecodes within blocks:	returnXyz									-> localReturnXyz	[... returnXyz ...]							-> nonLocalReturnXyz"	^self error: 'documentation only'! !!DynamicTranslator class methodsFor: 'documentation' stamp: 'ikp 1/5/98 02:59'!fakeInlineCache"The real inline cache (see #inlineCaches) is not yet implemented.  In the meantime a far simpler, low-performance alternative is being used (mainly to investigate the GC behaviour in the presences of inline caches) in the form of the Fake Inline Cache.There are no distinct opcodes for linked and unlinked sends.  Each send opcode must guarantee one thing: that the literal index of the selector is placed in the *last* extension word of the opcode.  (localIP therefore points at this location at the moment the send is actually invoked.)  This word is fetched into some temporary variable (let's call it 'selOrMeth' for now) and argumentCount is set appropriately before invoking the send mechanism.The send mechanism checks selOrMeth.  If this is an integer object then the send is 'unlinked' and it contains the literal frame index of the message selector, otherwise the send is 'linked' and selOrMeth contains the destination TranslatedMethod.For unlinked sends, the messageSelector is fetched from the literal frame.  If the selector is #doesNotUnderstand: then a normal send is performed without attempting to link the destination method.  (Linking the send in this case would be disasterous: the argumentCount would most likely be wrong, and the expected Message object would not be present on the stack.)  If the selector is something else then the class of the receiver is fetched, #findNewMethodInClass: is invoked to find the destination newTranslatedMethod, and this value is written into the location pointed to by localIP -- thus replacing the selector index in the caller's translated method.  The MethodClass field of the translated method is initialised appropriately (with the class of the receiver) along with various other interpreter registers (primIndex, newMethod and messageSelector), and finally the method is executed as normal.For linked sends, the class of the receiver is fetched and compared against the MethodClass field in the cached translated method.  If they agree, the interpeter restores the interpreter state cached in the destination method (messageSelector, method, primitiveIndex) and then executes the method directly, without performing any lookup.  If the receiver's class does not agree with that stored in the translated method's header, the send is relinked by setting messageSelector to the value stored in the method header and performing the linking steps described above.  Note that once a send site has been successfully linked, the semantics of the language guarantee that the argumentCount and messageSelector at that send site never change.The main purpose of the Fake Inline Cache is to provide a trivial mechanism that can be used to instrument the interpreter's behaviour when inline caches are in use, and to investigate management algorithms and heuristics that will eventually influence the implementation details of the real inline cache.  In short: the performance sucks."	^self error: 'documentation only'! !!DynamicTranslator class methodsFor: 'documentation' stamp: 'ikp 1/5/98 03:02'!inlineCacheFlush"The inline caches must be flushed on every programming change.  This is more difficult than it may seem, since contexts that are already executing in some redefined method must continue to execute the stale version until the next time they are invoked.  At the same time, all further sends (whether they are linked or unlinked) must reach the redefined version of the method.The translator performs this flushing by writing the current 'translation cycle' (an integer) into the header of every translated method.  When performing a linked send, the VM compares the translation cycle stored in the method header with the current translation cycle; if they differ then the cache 'misses' and the send is relinked.  To flush the inline cache it suffices to increment the current translation cycle.  This causes all linked send sites to 'miss' the next time that they execute.  (See DynamicTranslator>>flushInlineCache.)The impact of this rather brutal flushing can be reduced (during a selective flush) by bringing any translated methods that are referenced from the method cache (*after* the affected selector has been flushed from the method cache) forward into the new translation cycle.  (See DynamicTranslator>>flushMethodCacheSelective:.)Note that the above mechanism ensures that live Contexts will continue to execute in the stale translated version of a redefined method, as required."	^self error: 'documentation only'! !!DynamicTranslator class methodsFor: 'documentation' stamp: 'ikp 12/28/97 16:07'!inlineCaches"The send opcodes have only one responsibility: finding the translated method corresponding to the receiver and selector.  The appropriate 'invokation response' for this method (including, but not limited to: rejecting the invocation, normal activation, primitive response, special magic to initialise receiver variables from arguments, or whatever) is NOT the responsibility of the send opcode -- but rather that of the translated method's *prologue*.Each send can therefore optimise its role by 'memoising' its response, without worrying about when the implied assumptions behind this memoisation might become invalid.  The momoisation is accomplished by having two forms of each send opcode, 'unlinked' and 'linked'.  Unlinked sends perform a lookup, then replace themselves with a linked send and memoise the destination method by writing into an extension word at the send site.  Linked sends simply transfer control directly to the prologue of their memoised destination method.  This is the limit of the send opcodes' responsibilities.  An unlinked send opcode looks something like this:	- initialise messageSelector and argumentCount appropriately;	- advance localIP to the last extension word, then externalise IP and SP;	- call #lookupMethodInCache to find the destination method;	- replace the unlinked send with the corresponding linked send opcode;	- internalise IP and SP;	- link to the destination method, and invoke its prologue.Linking to the destination method involves several steps:	- write the address of the translated method into the extension word at localIP;	- choose an appropriate prologue for the method;	- write the prologue into the translated method header;	- write any relevant prologue extension word(s) into the translated method header;	- execute the method prologue.The method prologue has two distinct reponsibilities, implemented as two distinct 'opcodes' that are dispatched explicitly (rather than implicitly though localIP).The first responsibility is to check the validity of any assumptions (such as the class of the receiver) that might have been made by the send opcode.  If these assumtions are no longer valid then the prologue must 'fail' the send, normally by relinking it.  Note that the conditions in effect when the prologue executes are precisely those in effect when the send was first linked -- the prologue can therefore fail the send by simply reinvoking the linking procedure described above.  This part of the prologue is implemented by a 'check' opcode.The choice of check opcode to use is determined by several factors.  These are approximately as follows:  -	if the receiver is a tagged type then opCheckTag is used.  This fails the send if the	receiver does not have the expected tag.  -	if the receiver is an instance of a compact class, opCheckCompact is used.  This relinks	the send if the receiver's base header does not have the expected compact class index.  -	otherwise, opCheckClass is used.  This relinks the send if the receiver's class is not the	same as the method class that is stored in the translated method's header.Note that the correct choice of check opcode depends on the conditions at the send site at the time the send is linked.  The choice is therefore made in the send linking routine; hence a translated method is initially generated with an illegal check opcode, overwritten with a legal opcode at the time the send is first linked.If the send succeeds then a second 'activation opcode' is executed.  This secondary opcode is chosen approximately as follows:  -	if the original CompiledMethod has a primitive index then opActivatePrimitive is used.	This first tries running the corresponding primitive (whose index is stored in an activation	extension word) and either continues execution in the caller at localIP (if successFlag is true)	or activates the translated method normally (if the successFlag is false) to run the primitive	failure code.  -	if the original CompiledMethod has no primitive response, opActivate is used to unconditionally	activate the method.Other activation responses are possible.  For example, a translated method that contains only:	[PushTemporaryVariable StoreAndPopReceiverVariable]+ Returncan use a dedicated activation prologue that performs the necessary initialisation of the receiver without ever needing to activate the method.  (Method activation is very expensive compared to the cost of opcode and prologue dispatch.)Note that the choice of activation opcode depends on the nature of the original CompiledMethod, and is therefore made at method translation time.  Once chosen, the activation opcode is never altered.Each translated method therefore requires 28 bytes of header, as follows:	0:	=methodBias					(#translateNewMethod explains what this is for)	1:	 methodSelector				(used during relink -- the send's selector is no longer available)	2:	=argumentCount				(needed to pop the stack during activation)	3:	=prologueOpcode				(e.g: =opCheckTag,	=opCheckCompact,	=opCheckClass	)	4:	 prologueExtensionWord		(e.g:  nil,			=ccIndex,			 classOoop		)	5:	=activationOpcode			(e.g: =opActivate,	=opActivatePrimitive					)	6:	 activationExtensionWord	(e.g:  nil,			=primitiveIndex						)	7:	... opcodes ...Note that the default path through the above mechanism (linked send, check succeeds, dispatch to activation) avoids needlessly externalising IP and SP before reaching the activation opcode.  For example, the overheads for a primitive send to a SmallInteger are as follows:[linked send opcode]	- increment localIP to point to last extension word	- load the destination method address from (longAt: localIP)	- load the prologue check opcode (fetchWord: CheckOpcodeIndex ofObject: newTranslatedMethod)	- execute it (execOp: checkProlog)[check opcode]	- fetch the argument count (fetchInteger: ArgCountIndex ofObject: newTranslatedMethod)	- tag-check the receiver (isIntegerObject: (internalStackValue: argumentCount))	- load the activation opcode (fetchWord: ActivationOpcodeIndex ofObject: newTranslatedMethod)	- execute it (execOp: activationProlog)[activate opcode]	- fetch the primitive index (fetchInteger: PrimitiveIndexIndex ofObject: newTranslatedMethod)	- try the primitive (externaliseIPandSP; primitiveResponse: primIndex)	- activate on failure (successFlag or: [self activateNewMethod])	- dispatch next instruction (internaliseIPandSP; self endOp)[success: opcode following send;  failure: first opcode of fail-case code in activated method]"	^self error: 'documentation only'! !!DynamicTranslator class methodsFor: 'documentation' stamp: 'ikp 1/5/98 02:54'!patternMatchingPhilosophy"There are two possible approaches to matching patterns of bytecodes.  The obvious way is to look forward in the CompiledMethod being translated for particular bytecode patterns, and choose an opcode to emit for the current bytecode based on the bytecodes that follow.  A less obvious way is to look backwards at the opcodes that were translated for previous bytecodes, and back-patch some previous opcode during the translation of the last bytecode in the 'matched' sequence.  We choose the latter approach (with a few pragmatic hybrids -- e.g. xPrimBlockCopy) for several reasons:	- it reduces considerably the number of comparisons that have to be performed;	- it eliminates the need to detect sets of equivalent bytecodes		(e.g: push{LiteralConstant,Const{MinusOne,Zero,One,Two}} are all translated as 'PushConstant', so		 checking the opcode rather than the bytecode reduces the number of cases that must be detected		 from five to one);	- pattern matching can be done incrementally by checking for previous 'sub-optimisations'		(e.g:	pushTemp pushConst add popStoreTemp			is detected by looking for:				pushTemp macroPushConstAdd <ignored> popStoreTemp).	  This has the pleasant side-effect that things like 'pushTemp pushTemp' are encoded as	  'PushTempTemp' for the benefit of faster matching, but will also work as perfectly good	  macros in their own right (making for a faster VM) should the expected pattern fail to	  be matched later on.This approach has other, subtler benefits.  For example, consider a situation where three pushTemp bytecodes appear contiguously, with the second being a branch destination:				original code		(sub)optimisations				---------------		---------------------			0:	pushTemp A			1:	jumpTo then	else:	2:	pushTemp B			_ pushTempTemp B,C (implicit jumpTo: 4)	then:	3:	pushTemp C			4:	. . .In this case we get optimal behaviour regardless of whether the code is entered from the top or from the branch destination.  (For the incredulous, the above pattern will occur, exactly as shown, in: '(cond ifTrue: [tempA] ifFalse: [tempB]) foo: tempC'.)Finally, if the translator ever breaks away from the current linear proportionality between vPC and tPC, the above matching mechanism will cope with the single- and double-extended forms of various bytecodes without any changes whatsoever."	^self error: 'documentation only'! !!DynamicTranslator class methodsFor: 'documentation' stamp: 'ikp 1/5/98 02:49'!translatedCodeRules"The layout of translated code must adhere to one vary important rule: even-numbered extension words (where the opcode is word 0 and the extension words are numbered 1, 2, 3, ...) must *NEVER* contain a SmallInteger literal.This rule is necessary because the translator encodes opcodes as SmallIntegers, and then checks their values when performing rewrites on previously translated opcodes.  All bets are off should a SmallInteger literal in an extension word ever be mistaken for an opcode, and subsequently be replaced with a different (SmallInteger) opcode because a rewrite rule was triggered.Note: some of the extended opcodes do not implement this policy yet, so we're currently living dangerously.  I am hoping that this won't be an immediate problem since the integers that appear in extension word 2 for these opcodes are all indices between 0 and 255, which should not clash with the opcodes (which are all code addresses in the compiled VM implementation, guaranteed [on every architecture that I know about] to have values much higher than 255).  (The simulator is another matter, since it uses SmallIntegers between 1 and OpcodeTableSize to represent translated opcodes.  Yikes!!)"	^self error: 'documentation only'! !!EllipseMorph methodsFor: 'all' stamp: 'di 11/14/97 13:50'!containsPoint: aPoint	| radius other delta xOverY |	(bounds containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"	(bounds width = 1 or: [bounds height = 1])		ifTrue: [^ true].  "Degenerate case -- code below fails by a bit"	radius _ bounds height asFloat / 2.	other _ bounds width asFloat / 2.	delta _ aPoint - bounds topLeft - (other@radius).	xOverY _ bounds width asFloat / bounds height asFloat.	^ (delta x asFloat / xOverY) squared + delta y squared <= radius squared! !!EllipseMorph methodsFor: 'all' stamp: 'di 6/20/97 11:29'!doesBevels	^ false! !!EllipseMorph methodsFor: 'all'!drawOn: aCanvas 	aCanvas fillOval: bounds		color: color		borderWidth: borderWidth		borderColor: borderColor.! !!EllipseMorph methodsFor: 'all' stamp: 'di 11/14/97 11:13'!drawOnFills: aRectangle	^ false  "Could be improved by quick check of inner rectangle"! !!EllipseMorph methodsFor: 'all'!initialize	super initialize.	color _ Color yellow.	borderColor _ Color black.	borderWidth _ 1.! !EmbeddedServerAction works like a normal ServerAction, except that it interprets any embedded Smalltalk code (within <? ?> tags, stolen from Microsoft's notation for a similar capability) and replaces the embedded code with the value returned from the execution of the code.!!EmbeddedServerAction methodsFor: 'URL processing' stamp: 'mjg 11/7/97 11:29'!replyTo: pieces from: request	(StandardFileStream isAFileNamed: pieces) 	ifTrue:		[request reply: PWS success; reply: PWS contentHTML.		request reply: (HTMLformatter evalEmbedded:			(FileStream fileNamed: pieces) contentsOfEntireFile with: request)]	ifFalse:		[request error: PWS notFound].! !EmphasizedMenu comment:'A selection menu in which individual selections are allowed to have different emphases.  Emphases allowed are: bold, italic, struckThrough, and plain.  Provide an emphasis array, with one element per selection, to use.  Refer to the class method #example.'!!EmphasizedMenu methodsFor: 'display'!startUpWithCaption: captionOrNil	self setEmphasis.	^ super startUpWithCaption: captionOrNil! !!EmphasizedMenu methodsFor: 'emphasis'!emphases: emphasisArray	emphases _ emphasisArray! !!EmphasizedMenu methodsFor: 'emphasis' stamp: 'sw 12/11/96'!onlyBoldItem: itemNumber	"Set up emphasis such that all items are plain except for the given item number.  "	emphases _ (Array new: selections size) atAllPut: nil.	emphases at: itemNumber put: #bold! !!EmphasizedMenu methodsFor: 'private' stamp: 'sw 12/11/96'!setEmphasis	"Set up the receiver to reflect the emphases in the emphases array.  "	| selStart selEnd currEmphasis |	labelString _ labelString asText.	emphases size == 0 ifTrue: [^ self].	selStart _ 1.	1 to: selections size do:		[:line |			selEnd _ selStart + (selections at: line) size - 1.			((currEmphasis _ emphases at: line) size > 0 and: [currEmphasis ~~ #plain]) ifTrue:				[labelString addAttribute: (TextEmphasis perform: currEmphasis)					from: selStart to: selEnd].			selStart _ selEnd + 2]! !!EmphasizedMenu class methodsFor: 'instance creation' stamp: 'sw 12/11/96'!example1	"An example of how to get an EmphasizedMenu to work for you.  "	(self selections: 			#('how' 'well' 'does'   'this'   'work?') 		emphases: 			#(bold     0    italic struckOut plain))		startUpWithCaption: 'A Menu with Emphases'"EmphasizedMenu example1"! !!EmphasizedMenu class methodsFor: 'instance creation' stamp: 'sw 9/11/97 16:14'!example2	"EmphasizedMenu example2"	| aMenu |	aMenu _ EmphasizedMenu selections: #('One' 'Two' 'Three' 'Four').	aMenu onlyBoldItem: 3.	^ aMenu startUpWithCaption: 'Only the Bold'! !!EmphasizedMenu class methodsFor: 'instance creation' stamp: 'sw 12/11/96'!example3	"An example of how to get an EmphasizedMenu to work for you.  "	^ (self selectionAndEmphasisPairs: 		#('how' bold   'well'	0  'does'  italic   'this'  struckOut  'work' plain))		startUpWithCaption: 'A Menu with Emphases'"EmphasizedMenu example3"! !!EmphasizedMenu class methodsFor: 'instance creation' stamp: 'sw 12/23/96'!selectionAndEmphasisPairs: interleavedList	"An alternative form of call.  "	| selList  emphList |	selList _ OrderedCollection new.	emphList _ OrderedCollection new.	interleavedList pairsDo:		[:aSel :anEmph |			selList add: aSel.			emphList add: anEmph].	^ self selections:selList emphases: emphList! !!EmphasizedMenu class methodsFor: 'instance creation' stamp: 'sw 12/11/96'!selections: selList emphases: emphList	"Answer an instance of the receiver with the given selections and emphases.  "	^ (self selections: selList) emphases: emphList"(EmphasizedMenu selections: #('how' 'well' 'does' 'this' 'work?') emphases: #(bold 0 italic struckOut plain)) startUp" ! !!Encoder methodsFor: 'initialize-release'!fillDict: dict with: nodeClass mapping: keys to: codeArray	| codeStream |	codeStream _ ReadStream on: codeArray.	keys do: 		[:key | dict 				at: key				put:  (nodeClass new name: key key: key code: codeStream next)]! !!Encoder methodsFor: 'initialize-release'!init: aClass context: aContext notifying: req	| node n homeNode indexNode |	requestor _ req.	class _ aClass.	nTemps _ 0.	supered _ false.	self initScopeAndLiteralTables.	n _ -1.	class allInstVarNames do: 		[:variable | 		node _ VariableNode new					name: variable					index: (n _ n + 1)					type: LdInstType.		scopeTable at: variable put: node].	aContext == nil		ifFalse: 			[homeNode _ self bindTemp: 'homeContext'.			"first temp = aContext passed as arg"			n _ 0.			aContext tempNames do: 				[:variable | 				indexNode _ self encodeLiteral: (n _ n + 1).				node _ MessageNode new							receiver: homeNode							selector: #tempAt:							arguments: (Array with: indexNode)							precedence: 3							from: self.				scopeTable at: variable put: node]].	sourceRanges _ Dictionary new: 32! !!Encoder methodsFor: 'encoding'!encodeVariable: name ifUnknown: action	| varNode |	varNode _ 		scopeTable 			at: name			ifAbsent: 				[self lookupInPools: name 					ifFound: [:assoc | ^self global: assoc name: name].				^action value].	^varNode! !!Encoder methodsFor: 'encoding'!litIndex: literal	| p |	p _ literalStream position.	p = 256 ifTrue:		[self notify: 'More than 256 literals referenced. You must split or otherwise simplify this method.The 257th literal is: ', literal printString. ^nil].		"Would like to show where it is in the source code, 		 but that info is hard to get."	literalStream nextPut: literal.	^ p! !!Encoder methodsFor: 'temps'!autoBind: name 	"Declare a block argument as a temp if not already declared."	| node |	node _ scopeTable 			at: name			ifAbsent: 				[(self lookupInPools: name ifFound: [:assoc | assoc])					ifTrue: [self notify: 'Name already used in a Pool or Global'].				^ (self reallyBind: name) nowHasDef nowHasRef scope: 1].	node isTemp		ifTrue: [node scope >= 0 ifTrue:					[^ self notify: 'Name already used in this method'].				node nowHasDef nowHasRef scope: 1]		ifFalse: [^ self notify: 'Name already used in this class'].	^node! !!Encoder methodsFor: 'temps' stamp: 'jm 9/18/97 21:06'!bindArg: name 	"Declare an argument."	| node |	nTemps >= 15		ifTrue: [^self notify: 'Too many arguments'].	node _ self bindTemp: name.	^ node nowHasDef nowHasRef! !!Encoder methodsFor: 'temps'!newTemp: name	nTemps _ nTemps + 1.	^ TempVariableNode new		name: name		index: nTemps - 1		type: LdTempType		scope: 0! !!Encoder methodsFor: 'results'!tempNames 	| tempNodes |	tempNodes _ SortedCollection sortBlock: [:n1 :n2 | n1 code <= n2 code].	scopeTable associationsDo:		[:assn | (assn value isMemberOf: TempVariableNode)			ifTrue: [tempNodes add: assn value]].	^ tempNodes collect: [:node | node key]! !!Encoder methodsFor: 'results'!tempsAndBlockArgs	| tempNodes var |	tempNodes _ OrderedCollection new.	scopeTable associationsDo:		[:assn | var _ assn value.		((var isTemp and: [var isArg not])					and: [var scope = 0 or: [var scope = -1]])			ifTrue: [tempNodes add: var]].	^ tempNodes! !!Encoder methodsFor: 'results'!unusedTempNames 	| unused |	unused _ OrderedCollection new.	scopeTable associationsDo:		[:assn | (assn value isUnusedTemp)			ifTrue: [unused add: assn value key]].	^ unused! !!Encoder methodsFor: 'source mapping'!sourceMap	"Answer with a sorted set of associations (pc range)."	^ (sourceRanges keys collect: 		[:key |  Association key: key pc value: (sourceRanges at: key)])			asSortedCollection! !!Encoder methodsFor: 'private'!lookupInPools: name ifFound: assocBlock	| |	Symbol 		hasInterned: name 		ifTrue: [:sym | ^class scopeHas: sym ifTrue: assocBlock].	^ class scopeHas: name ifTrue: assocBlock.  "Its a string in the pool"! !An envelope models a three-stage progression for a musical note: attack, sustain, decay. Envelopes can either return the envelope value at a given time or can update some target object using a client-specified message selector.The points instance variable holds an array of (time, value) points, where the times are in milliseconds. The points array must contain at least two points. The time coordinate of the first point must be zero and the time coordinates of subsequent points must be in ascending order, although the spacing between them is arbitrary. Envelope values between points are computed by linear interpolation.The scale slot is initially set so that the peak of envelope matches some note attribute, such as its loudness. When entering the decay phase, the scale is adjusted so that the decay begins from the envelope's current value. This avoids a potential sharp transient when entering the decay phase.The loopStartIndex and loopEndIndex slots contain the indices of points in the points array; if they are equal, then the envelope holds a constant value for the sustain phase of the note. Otherwise, envelope values are computed by repeatedly looping between these two points.The loopEndMSecs slot can be set in advance (as when playing a score) or dynamically (as when responding to interactive inputs from a MIDI keyboard). In the latter case, the value of scale is adjusted to start the decay phase with the current envelope value. Thus, if a note ends before its attack is complete, the decay phase is started immediately (i.e., the attack phase is never completed).For best results, amplitude envelopes should start and end with zero values. Otherwise, the sharp transient at the beginning or end of the note may cause audible clicks or static. For envelopes on other parameters, this may not be necessary.!!Envelope methodsFor: 'accessing' stamp: 'jm 11/26/97 08:53'!decayTime	"Return the time taken by the decay phase."	^ points last x - (points at: loopEndIndex) x! !!Envelope methodsFor: 'accessing' stamp: 'jm 11/24/97 14:38'!duration	"Return the time of the final point."	loopEndMSecs == nil		ifTrue: [^ points last x]		ifFalse: [^ loopEndMSecs + (points last x - (points at: loopEndIndex) x)].! !!Envelope methodsFor: 'accessing' stamp: 'jm 11/24/97 14:38'!duration: seconds	"Set the note duration to the given number of seconds."	| totalMSecs |	totalMSecs _ (seconds asFloat * 1000.0) asInteger.	self sustainEnd: (totalMSecs - self decayTime).! !!Envelope methodsFor: 'accessing' stamp: 'jm 11/24/97 14:37'!points	^ points! !!Envelope methodsFor: 'accessing' stamp: 'jm 11/24/97 14:36'!scale	^ scale! !!Envelope methodsFor: 'accessing' stamp: 'jm 11/24/97 14:36'!scale: aNumber	scale _ aNumber asFloat.! !!Envelope methodsFor: 'accessing' stamp: 'jm 11/26/97 09:25'!target	^ target! !!Envelope methodsFor: 'accessing' stamp: 'jm 11/26/97 09:25'!target: anObject	target _ anObject.! !!Envelope methodsFor: 'accessing' stamp: 'jm 11/24/97 14:34'!updateSelector	^ updateSelector! !!Envelope methodsFor: 'accessing' stamp: 'jm 11/26/97 08:52'!updateSelector: aSymbol	updateSelector _ aSymbol.! !!Envelope methodsFor: 'applying' stamp: 'jm 11/26/97 09:07'!showOnDisplay	"Envelope example showOnDisplay"	| xOrigin yOrigin minVal maxVal yScale step x v y |	xOrigin _ 30.	yOrigin _ 130.	minVal _ 1e100.	maxVal _ -1e100.	points do: [:p |		p y < minVal ifTrue: [minVal _ p y].		p y > maxVal ifTrue: [maxVal _ p y]].	yScale _ 100.0 / ((maxVal - minVal) * scale).	step _ (self duration // 150) max: 1.	Display fillBlack: ((xOrigin + ((points at: loopStartIndex) x // step))@(yOrigin - 100) extent: 1@100).	Display fillBlack: ((xOrigin + ((points at: loopEndIndex) x // step))@(yOrigin - 100) extent: 1@100).	Display fillBlack: (xOrigin@(yOrigin - 100) extent: 1@100).	x _ xOrigin.	step negated to: self duration + step by: step do: [:mSecs |		v _ self valueAtMSecs: mSecs.		y _ yOrigin - ((v - minVal) * yScale) asInteger.		Display fillBlack: ((x - 1)@(y - 1) extent: 2@2).		Display fillBlack: (x@yOrigin extent: 1@1).		x _ x + 1].! !!Envelope methodsFor: 'applying' stamp: 'jm 12/12/97 14:33'!sustainEnd: mSecs	"Set the ending time of the sustain phase of this envelope; the decay phase will start this point. Typically derived from a note's duration."	"Details: to avoid a sharp transient, the decay phase is scaled so that the beginning of the decay matches the envelope's instantaneous value when the decay phase starts."	| vIfSustaining firstVOfDecay |	loopEndMSecs _ nil. "pretend to be sustaining"	decayScale _ 1.0.	vIfSustaining _ self valueAtMSecs: mSecs.  "get value at end of sustain phase"	loopEndMSecs _ mSecs.	firstVOfDecay _ (points at: loopEndIndex) y * scale.	firstVOfDecay = 0.0		ifTrue: [decayScale _ 1.0]		ifFalse: [decayScale _ vIfSustaining / firstVOfDecay].! !!Envelope methodsFor: 'applying' stamp: 'jm 12/17/97 21:48'!updateTargetAt: mSecs	"Send my updateSelector to the given target object with the value of this envelope at the given number of milliseconds from its onset. Do nothing if updateSelector is nil."	(target == nil or: [updateSelector == nil])		ifFalse: [			target				perform: updateSelector				with: (self valueAtMSecs: mSecs)].! !!Envelope methodsFor: 'applying' stamp: 'jm 11/24/97 14:33'!valueAtMSecs: mSecs	"Return the value of this envelope at the given number of milliseconds from its onset. Return zero for times outside the time range of this envelope."	| t i |	mSecs < 0 ifTrue: [^ 0.0].	((loopEndMSecs ~~ nil) and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"		t _ (points at: loopEndIndex) x + (mSecs - loopEndMSecs).		i _ self indexOfPointAfterMSecs: t startingAt: loopEndIndex.		i == nil ifTrue: [^ 0.0].  "past end"		^ (self interpolate: t between: (points at: i - 1) and: (points at: i)) * decayScale].	mSecs < loopStartMSecs ifTrue: [  "attack phase"		i _ self indexOfPointAfterMSecs: mSecs startingAt: 1.		i = 1 ifTrue: [^ (points at: 1) y].		^ self interpolate: mSecs between: (points at: i) and: (points at: i - 1)].	"sustain phase"	loopMSecs = 0 ifTrue: [^ (points at: loopEndIndex) y].  "looping on a single point"	t _ loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).	i _ self indexOfPointAfterMSecs: t startingAt: loopStartIndex.	^ self interpolate: t between: (points at: i - 1) and: (points at: i)! !!Envelope methodsFor: 'private' stamp: 'jm 11/26/97 09:03'!checkParameters	"Verify that the point array, loopStartIndex, and loopStopIndex obey the rules."	| lastT t |	points size > 1		ifFalse: [^ self error: 'the point list must contain at least two points'].	points first x = 0		ifFalse: [^ self error: 'the time of the first point must be zero'].	lastT _ points first x.	2 to: points size do: [:i |		t _ (points at: i) x.		t >= lastT			ifFalse: [^ self error: 'the points must be in ascending time order']].	(loopStartIndex isInteger and:	 [(loopStartIndex > 0) and: [loopStartIndex <= points size]])		ifFalse: [^ self error: 'loopStartIndex is not a valid point index'].	(loopEndIndex isInteger and:	 [(loopEndIndex > 0) and: [loopEndIndex <= points size]])		ifFalse: [^ self error: 'loopEndIndex is not a valid point index'].	 loopStartIndex <= loopEndIndex		ifFalse: [^ self error: 'loopEndIndex must not precede loopStartIndex'].! !!Envelope methodsFor: 'private' stamp: 'jm 12/16/97 16:51'!indexOfPointAfterMSecs: mSecs startingAt: startIndex	"Return the index of the first point whose time is greater that mSecs, starting with the given index. Return nil if mSecs is after the last point's time."	startIndex to: points size do:		[:i | (points at: i) x > mSecs ifTrue: [^ i]].	^ nil! !!Envelope methodsFor: 'private' stamp: 'jm 11/24/97 14:37'!interpolate: mSecs between: p1 and: p2	"Return the scaled, interpolated value for the given time between the given time points."	"Assume: p1 x <= mSecs <= p2 x"	| timeRange valueRange |	timeRange _ (p2 x - p1 x) asFloat.	valueRange _ (p2 y - p1 y) asFloat.	^ (p1 y + (((mSecs - p1 x) asFloat / timeRange) * valueRange)) * scale.! !!Envelope methodsFor: 'private' stamp: 'jm 12/17/97 21:48'!setPoints: pointList loopStart: startIndex loopEnd: endIndex	points _ pointList asArray collect: [:p | p x asInteger @ p y asFloat].	loopStartIndex _ startIndex.	loopEndIndex _ endIndex.	self checkParameters.	loopStartMSecs _ (points at: loopStartIndex) x.	loopMSecs _ (points at: loopEndIndex) x - (points at: loopStartIndex) x.	target _ nil.	updateSelector _ nil.	loopEndMSecs _ nil.  "unknown end time; sustain until end time is known"	scale _ 1.0.	decayScale _ 1.0.! !!Envelope class methodsFor: 'all' stamp: 'jm 11/26/97 09:14'!example	"Envelope example showOnDisplay"	| p |	p _ Array with: 0@0 with: 100@1.0 with: 250@0.7 with: 400@1.0 with: 500@0.	^ (self points: p loopStart: 2 loopEnd: 4) sustainEnd: 1200.! !!Envelope class methodsFor: 'all' stamp: 'jm 1/7/98 11:54'!exponentialDecay: multiplier stepSize: mSecsPerStep	"(Envelope exponentialDecay: 0.92 stepSize: 20) showOnDisplay"	| pList t v |	((multiplier > 0.0) and: [multiplier < 1.0])		ifFalse: [self error: 'multiplier must be greater than 0.0 and less than 1.0'].	pList _ OrderedCollection new.	pList add: 0@0.0.	v _ 1.0.	t _ 10.	[v > 0.01] whileTrue: [		pList add: t@v.		t _ t + mSecsPerStep.		v _ v * multiplier].	pList add: (t + mSecsPerStep)@0.0.	^ self points: pList asArray		loopStart: pList size - 1		loopEnd: pList size - 1! !!Envelope class methodsFor: 'all' stamp: 'jm 11/26/97 08:49'!points: pList loopStart: loopStart loopEnd: loopEnd	^ self new setPoints: pList asArray		loopStart: loopStart		loopEnd: loopEnd! !EventHandler comment:'Events in Morphic originate in a Hand, pass to a target morph, and are then dispatched by an EventHandler.  EventHandlers support redirection of mouse and keyboard activity by specifying and independent recipient object and message selector for each of the possible events.  In addition each eventHandler can supply an optional value parameter for distinguishing between, eg, events from a number of otherwise identical source morphs.The basic protocol of an event handler is to receive a message of the form	mouseDown: event in: targetMorphand redirect this as one of	mouseDownRecipient perform: mouseDownSelector0	mouseDownRecipient perform: mouseDownSelector1 with: event	mouseDownRecipient perform: mouseDownSelector2 with: event with: targetMorph	mouseDownRecipient perform: mouseDownSelector3 with: event with: targetMorph with: valueParameterdepending on the arity of the mouseDownSelector.'!!EventHandler methodsFor: 'initialization'!on: eventName send: selector to: recipient	eventName = #mouseDown ifTrue:		[mouseDownRecipient _ recipient.  mouseDownSelector _ selector. ^ self].	eventName = #mouseStillDown ifTrue:		[mouseStillDownRecipient _ recipient.  mouseStillDownSelector _ selector. ^ self].	eventName = #mouseUp ifTrue:		[mouseUpRecipient _ recipient.  mouseUpSelector _ selector. ^ self].	eventName = #mouseEnter ifTrue:		[mouseEnterRecipient _ recipient.  mouseEnterSelector _ selector. ^ self].	eventName = #mouseLeave ifTrue:		[mouseLeaveRecipient _ recipient.  mouseLeaveSelector _ selector. ^ self].	eventName = #keyStroke ifTrue:		[keyStrokeRecipient _ recipient.  keyStrokeSelector _ selector. ^ self].	self error: 'Event name, ' , eventName , ' is not recognizable.'! !!EventHandler methodsFor: 'initialization'!on: eventName send: selector to: recipient withValue: value	selector numArgs = 3 ifFalse:		[self halt: 'Warning: value parameters are passed as last of 3 arguments'].	self on: eventName send: selector to: recipient.	valueParameter _ value! !!EventHandler methodsFor: 'testing'!handlesMouseDown: evt	mouseDownRecipient ifNotNil: [^ true].	mouseStillDownRecipient ifNotNil: [^ true].	mouseUpRecipient ifNotNil: [^ true].	^ false! !!EventHandler methodsFor: 'testing'!handlesMouseOver: evt	mouseEnterRecipient ifNotNil: [^ true].	mouseLeaveRecipient ifNotNil: [^ true].	^ false! !!EventHandler methodsFor: 'testing'!mouseDownRecipient	^ mouseDownRecipient! !!EventHandler methodsFor: 'testing'!mouseDownSelector	^ mouseDownSelector! !!EventHandler methodsFor: 'testing'!mouseUpSelector	^ mouseUpSelector! !!EventHandler methodsFor: 'events'!handleEvent: evt fromMorph: sourceMorph	"Handle the given event by using the event type to decide what to do. This method is less efficient than the specific event handling messages."	"Note: This method cannot be used for mouse enter and leave transitions, since these events are just mouseMove events whose interpretation depends on context."	evt isMouse ifTrue: [		evt isMouseMove ifTrue: [			^ self mouseStillDown: evt fromMorph: sourceMorph].		evt isMouseDown ifTrue: [			^ self mouseDown: evt fromMorph: sourceMorph].		evt isMouseUp ifTrue: [			^ self mouseUp: evt fromMorph: sourceMorph]].	evt isKeystroke ifTrue: [		^ self keyStroke: evt fromMorph: sourceMorph].! !!EventHandler methodsFor: 'events'!keyStroke: event fromMorph: sourceMorph	^ self send: keyStrokeSelector to: keyStrokeRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events'!mouseDown: event fromMorph: sourceMorph	^ self send: mouseDownSelector to: mouseDownRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events'!mouseEnter: event fromMorph: sourceMorph	^ self send: mouseEnterSelector to: mouseEnterRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events'!mouseLeave: event fromMorph: sourceMorph	^ self send: mouseLeaveSelector to: mouseLeaveRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events'!mouseStillDown: event fromMorph: sourceMorph	^ self send: mouseStillDownSelector to: mouseStillDownRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events'!mouseUp: event fromMorph: sourceMorph	^ self send: mouseUpSelector to: mouseUpRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events'!send: selector to: recipient withEvent: event fromMorph: sourceMorph	| arity |	recipient ifNil: [^ self].	arity _ selector numArgs.	arity = 0 ifTrue:		[^ recipient perform: selector].	arity = 1 ifTrue:		[^ recipient perform: selector with: event].	arity = 2 ifTrue:		[^ recipient perform: selector with: event with: sourceMorph].	arity = 3 ifTrue:		[^ recipient perform: selector with: event with: sourceMorph with: valueParameter].	self error: 'Event handling selectors must be Symbols and take 0-3 arguments'! !!EventHandler methodsFor: 'access' stamp: 'tk 9/13/97 10:31'!messageList	"Return a list of 'Class selector' for each message I can send.  tk9/13/97"	| list |	list _ SortedCollection new.	mouseDownRecipient ifNotNil:		[list add: (mouseDownRecipient class classThatUnderstands:	mouseDownSelector) name,			' ', mouseDownSelector].	mouseStillDownRecipient ifNotNil:		[list add: (mouseStillDownRecipient class classThatUnderstands:	mouseStillDownSelector) name,			' ', mouseStillDownSelector].	mouseUpRecipient ifNotNil:		[list add: (mouseUpRecipient class classThatUnderstands:	mouseUpSelector) name,			' ', mouseUpSelector].	mouseEnterRecipient ifNotNil:		[list add: (mouseEnterRecipient class classThatUnderstands:	mouseEnterSelector) name,			' ', mouseEnterSelector].	mouseLeaveRecipient ifNotNil:		[list add: (mouseLeaveRecipient class classThatUnderstands:	mouseLeaveSelector) name,			' ', mouseLeaveSelector].	keyStrokeRecipient ifNotNil:		[list add: (keyStrokeRecipient class classThatUnderstands:	keyStrokeSelector) name,			' ', keyStrokeSelector].	^ list! !!EventHandler methodsFor: 'access' stamp: 'sw 9/26/97 11:45'!sinfulMouseUpRecipient	"Sinful, temporary -- answer the receiver's mouseUpRecipient, though that is meant to be private"	self flag: #temporary.	^ mouseUpRecipient! !!EventHandler methodsFor: 'access' stamp: 'tk 7/28/97 22:50'!valueParameter: vv	"shared by all actions of this event handler"	valueParameter _ vv! !!EventRecorder methodsFor: 'as yet unclassified'!handleEvent: anEvent	"Start, Stop, and record events.  Playback.  5/21/97 tk""state = nil   stopped, not recording 	= #record	recording	= #play		playing backControl 1 = start recordingControl 2 = stop recording (or playing back)Control 3 = start playing back"state == nil ifTrue: [^ self testControl: anEvent].state == #record ifTrue: [tape addLast: anEvent.	^ self testControl: anEvent].state == #play ifTrue: [^ self testControl: anEvent].	"ignore my own events.  	Playback happens from another method.""AA _ EventRecorder new.hands first startReportingEventsTo: AA. "! !!EventRecorder methodsFor: 'as yet unclassified'!testControl: anEvent	"See if it is a control event for me.  Control 1 = start recordingControl 2 = stop recording (or playing back)Control 3 = start playing back"	anEvent isKeystroke ifFalse: [^ self].	anEvent controlKeyPressed ifFalse: [^ self].	anEvent commandKeyPressed ifTrue: [^ self].	"not this"	anEvent optionKeyPressed ifTrue: [^ self].	"not this"	anEvent shiftPressed ifTrue: [^ self].	"not this"	anEvent keyCharacter = $1 ifTrue: ["start recording"		tape ifNil: [tape _ OrderedCollection new].		state _ #record].	anEvent keyCharacter = $2 ifTrue: ["stop recording (or playing back)"		state _ nil].	anEvent keyCharacter = $3 ifTrue: ["start playing back"		state _ #play.		tape ifNotNil: [			tape do: [:evt | 				anEvent hand world runStepMethods.				anEvent hand handleEvent: evt.				anEvent hand world displayWorld]].		state _ nil].! !!ExternalStream methodsFor: 'accessing' stamp: 'tk 10/11/97 16:22'!contentsOfEntireFile	"For non-file streams"	^ self contents! !!ExternalStream methodsFor: 'accessing'!nextInto: buffer 	"fill buffer from my collection"	(buffer isMemberOf: Bitmap) ifTrue:		[1 to: buffer size do:			[:index | buffer at: index put: (self nextNumber: 4)].		^ buffer].	1 to: buffer size do:		[:index | buffer at: index put: self next].	^ buffer! !!ExternalStream methodsFor: 'nonhomogeneous accessing' stamp: 'di 9/19/97 09:12'!nextLitteEndianNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."	| s bytes |	bytes _ self next: n.	s _ 0.	n to: 1 by: -1 do: [: i | s _ (s bitShift: 8) bitOr: (bytes at: i)].	^ s! !!ExternalStream methodsFor: 'nonhomogeneous accessing' stamp: 'di 9/19/97 14:34'!nextLitteEndianNumber: n put: value	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."	| bytes |	bytes _ ByteArray new: n.	1 to: n do: [: i | bytes at: i put: (value digitAt: i)].	self nextPutAll: bytes! !!ExternalStream methodsFor: 'nonhomogeneous accessing'!nextNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger."	| s |	s _ 0.	1 to: n do: 		[:i | s _ (s bitShift: 8) bitOr: self next].	^ s normalize! !!ExternalStream methodsFor: 'nonhomogeneous accessing' stamp: '6/9/97 18:27 tk'!nextNumber: n put: v 	"Append to the receiver the argument, v, which is a positive 	SmallInteger or a LargePositiveInteger, as the next n bytes.	Possibly pad with leading zeros."	1 to: n do: [:i | self nextPut: (v digitAt: n+1-i)].	^ v! !!FatBitsPaint methodsFor: 'initialization' stamp: 'jm 12/1/97 09:34'!initialize	super initialize.	formToEdit _ Form extent: 50@40 depth: 8.	formToEdit fill: formToEdit boundingBox fillColor: Color veryVeryLightGray.	magnification _ 4.	color _ Color veryVeryLightGray.	brushColor _ Color red.	brushSize _ 3.	self revert.! !!FatBitsPaint methodsFor: 'events' stamp: 'jm 12/1/97 12:00'!griddedPoint: evt	| relativePt |	relativePt _ evt cursorPoint - self position.	^ (relativePt x truncateTo: magnification)@(relativePt y truncateTo: magnification)! !!FatBitsPaint methodsFor: 'events' stamp: 'jm 11/4/97 07:15'!handlesMouseDown: evt	^ true! !!FatBitsPaint methodsFor: 'events' stamp: 'jm 12/1/97 10:21'!mouseDown: evt	lastMouse _ nil.! !!FatBitsPaint methodsFor: 'events' stamp: 'jm 12/1/97 10:22'!mouseMove: evt	| p p2 damageRect |	p _ self griddedPoint: evt.	lastMouse = p ifTrue: [^ self].	lastMouse ifNil: [lastMouse _ p].  "first point in a stroke"	"draw etch-a-sketch style-first horizontal, then vertical"	p2 _ p x@lastMouse y.	brush drawFrom: lastMouse to: p2.	brush drawFrom: p2 to: p.				damageRect _ 		((lastMouse min: p) - brush sourceForm extent) corner:		((lastMouse max: p) + brush sourceForm extent).	self invalidRect: (damageRect translateBy: self position).	lastMouse _ p.! !!FatBitsPaint methodsFor: 'menu' stamp: 'jm 12/1/97 12:16'!accept	| f |	f _ (self form shrink: self form boundingBox by: magnification).	((f boundingBox = formToEdit boundingBox) and: [f depth = formToEdit depth])		ifFalse: [^ self error: 'implementation error; form dimensions and depth should match'].	formToEdit bits: f bits.  "modify formToEdit in place"! !!FatBitsPaint methodsFor: 'menu' stamp: 'jm 12/1/97 12:02'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'pen color' action: #setPenColor:.	aCustomMenu add: 'pen size' action: #setPenSize:.	aCustomMenu add: 'fill' action: #fill.	aCustomMenu add: 'magnification' action: #setMagnification:.	aCustomMenu add: 'accept' action: #accept.	aCustomMenu add: 'revert' action: #revert.! !!FatBitsPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!brushColor: aColor	brushColor _ aColor.	brush color: aColor.! !!FatBitsPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:16'!fill	| fillPt |	Cursor blank show.	Cursor crossHair showWhile:		[fillPt _ Sensor waitButton - self world viewBox origin - self position].	originalForm shapeFill: brushColor interiorPoint: fillPt.	self changed.! !!FatBitsPaint methodsFor: 'menu' stamp: 'jm 12/1/97 13:06'!magnification: aNumber	| oldPenSize oldForm |	oldPenSize _ brushSize / magnification.	oldForm _ self form shrink: self form boundingBox by: magnification.	magnification _ aNumber asInteger max: 1.	self form: (oldForm magnify: oldForm boundingBox by: magnification).	brush _ Pen newOnForm: originalForm.	self penSize: oldPenSize.	brush color: brushColor.! !!FatBitsPaint methodsFor: 'menu' stamp: 'jm 12/1/97 12:09'!penSize: aNumber	brushSize _ (aNumber * magnification) asInteger.	brush squareNib: brushSize.! !!FatBitsPaint methodsFor: 'menu' stamp: 'jm 12/1/97 09:38'!revert	self form: (formToEdit magnify: formToEdit boundingBox by: magnification).	brush _ Pen newOnForm: originalForm.	brush squareNib: brushSize.	brush color: brushColor.! !!FatBitsPaint methodsFor: 'menu' stamp: 'jm 12/1/97 13:14'!setMagnification: evt	| menu |	menu _ MenuMorph new.	((1 to: 8), #(16 24 32)) do: [:w |		menu add: w printString			target: self			selector: #magnification:			argumentList: (Array with: w)].	menu popUpAt: evt hand position event: evt.! !!FatBitsPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:16'!setPenColor: evt	evt hand changeColorTarget: self selector: #brushColor:.! !!FatBitsPaint methodsFor: 'menu' stamp: 'jm 12/1/97 10:18'!setPenSize: evt	| menu sizes |	menu _ MenuMorph new.	sizes _ (1 to: 5), (6 to: 12 by: 2), (15 to: 40 by: 5).	sizes do: [:w |		menu add: w printString			target: self			selector: #penSize:			argumentList: (Array with: w)].	menu popUpAt: evt hand position event: evt.! !FFT comment:'This class implements the Fast Fourier Transform roughly as described on page 367of "Theory and Application of Digital Signal Processing" by Rabiner and Gold.Each instance caches tables used for transforming a given size (n = 2^nu samples) of data.It would have been cleaner using complex numbers, but often the data is all real.'!!FFT methodsFor: 'initialization' stamp: 'di 6/17/97 07:47'!nu: order	"Initialize variables and tables for transforming 2^nu points"	|  j perms k |	nu _ order.	n _ 2 bitShift: nu-1.	"Initialize permutation table (bit-reversed indices)"	j_0.	perms _ WriteStream on: (Array new: n).	0 to: n-2 do:		[:i |		i < j ifTrue: [perms nextPut: i+1; nextPut: j+1].		k _ n // 2.		[k <= j] whileTrue: [j _ j-k.  k _ k//2].		j _ j + k].	permTable _ perms contents.	"Initialize sin table 0..pi/2 in n/4 steps."	sinTable _ (0 to: n/4) collect: [:i | (i asFloat / (n//4) * Float pi / 2.0) sin]! !!FFT methodsFor: 'initialization' stamp: 'di 6/17/97 07:47'!realData: real	realData _ real.	imagData _ real collect: [:i | 0.0]  "imaginary component all zero"! !!FFT methodsFor: 'initialization' stamp: 'di 6/17/97 07:47'!realData: real imagData: imag	realData _ real.	imagData _ imag! !!FFT methodsFor: 'transforming' stamp: 'di 6/17/97 07:47'!permuteData	| i end a b |	i _ 1.	end _ permTable size.	[i <= end] whileTrue:		[a _ permTable at: i.		b _ permTable at: i+1.		realData swap: a with: b.		imagData swap: a with: b.		i _ i + 2]! !!FFT methodsFor: 'transforming' stamp: 'di 6/17/97 07:47'!scaleData	"Scale all elements by 1/n when doing inverse"	| realN |	realN _ n asFloat.	1 to: n do:		[:i |		realData at: i put: (realData at: i) / realN.		imagData at: i put: (imagData at: i) / realN]! !!FFT methodsFor: 'transforming' stamp: 'di 6/17/97 07:47'!transformForward: forward	| lev lev1 ip theta realU imagU realT imagT i |	self permuteData.	1 to: nu do:		[:level |		lev _ 1 bitShift: level.		lev1 _ lev // 2.		1 to: lev1 do:			[:j |			theta _ j-1 * (n // lev).   "pi * (j-1) / lev1 mapped onto 0..n/2"			theta < (n//4)  "Compute U, the complex multiplier for each level"				ifTrue:					[realU _ sinTable at: sinTable size - theta.					imagU _ sinTable at: theta + 1]				ifFalse:					[realU _ (sinTable at: theta - (n//4) + 1) negated.					imagU _ sinTable at: (n//2) - theta + 1].			forward ifFalse: [imagU _ imagU negated]."			Here is the inner loop...			j to: n by: lev do:				[:i |   hand-transformed to whileTrue..."			i _ j.			[i <= n] whileTrue:				[ip _ i + lev1.				realT _ ((realData at: ip) * realU) - ((imagData at: ip) * imagU).				imagT _ ((realData at: ip) * imagU) + ((imagData at: ip) * realU).				realData at: ip put: (realData at: i) - realT.				imagData at: ip put: (imagData at: i) - imagT.				realData at: i put: (realData at: i) + realT.				imagData at: i put: (imagData at: i) + imagT.				i _ i + lev]]].	forward ifFalse: [self scaleData]  "Reverse transform must scale to be an inverse"! !!FFT methodsFor: 'testing' stamp: 'di 6/17/97 07:47'!plot: samples in: rect	"Throw-away code just to check out a couple of examples"	| min max x dx pen y |	Display fillWhite: rect; border: (rect expandBy: 2) width: 2.	min _ 1.0e30.  max _ -1.0e30.	samples do:		[:v |		min _ min min: v.		max _ max max: v].	pen _ Pen new.  pen up.	x _ rect left.	dx _ rect width asFloat / samples size.	samples do:		[:v |		y _ (max-v) / (max-min) * rect height asFloat.		pen goto: x asInteger @ (rect top + y asInteger).		pen down.		x _ x + dx].	max printString displayOn: Display at: (x+2) @ (rect top-9).	min printString displayOn: Display at: (x+2) @ (rect bottom - 9)! !!FFT methodsFor: 'testing' stamp: 'di 6/17/97 07:47'!test  "Display restoreAfter: [(FFT new nu: 8) test].  --  Test on an array of 256 samples"	"Initialize to pure (co)Sine Wave, plot, transform, plot, invert and plot again"	self realData: ((1 to: n) collect: [:i | (Float pi * (i-1) / (n/8)) cos]).	self plot: realData in: (100@20 extent: 256@60).	self transformForward: true.	self plot: realData in: (100@100 extent: 256@60).	self plot: imagData in: (100@180 extent: 256@60).	self transformForward: false.	self plot: realData in: (100@260 extent: 256@60)! !A FileDirectory represents a folder or directory in the underlying platform's file system. It carries a fully-qualified path name for the directory it represents, and can enumerate the files and directories within that directory.A FileDirectory can be thought of as a Dictionary whose keys are the local names of files in that directory, and whose values are directory "entries". Each entry is an array of five items:	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>The times are given in seconds, and can be converted to a time and date via Time>dateAndTimeFromSeconds:. See the comment in lookupEntry:... which provides primitive access to this information.!!FileDirectory methodsFor: 'path access' stamp: 'jm 12/5/97 12:18'!pathName	"Return the path from the root of the file system to this directory."	^ pathName! !!FileDirectory methodsFor: 'path access' stamp: 'jm 12/5/97 12:19'!pathNameDelimiter	"Return the delimiter character for this kind of directory. This depends on the current platform."	^ self class pathNameDelimiter! !!FileDirectory methodsFor: 'path access' stamp: 'jm 12/5/97 12:17'!pathParts	"Return the path from the root of the file system to this directory as an array of directory names."	^ pathName findTokens: self pathNameDelimiter asString! !!FileDirectory methodsFor: 'file stream creation' stamp: 'jm 12/5/97 11:51'!fileNamed: localFileName	"Open the file with the given name in this directory for writing."	^ StandardFileStream fileNamed: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'file stream creation' stamp: 'jm 12/5/97 11:52'!newFileNamed: localFileName	"Create a new file with the given name in this directory."	^ StandardFileStream newFileNamed: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'file stream creation' stamp: 'jm 12/5/97 11:52'!oldFileNamed: localFileName	"Open the existing file with the given name in this directory."	^ StandardFileStream oldFileNamed: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'file stream creation' stamp: 'jm 12/5/97 11:52'!readOnlyFileNamed: localFileName	"Open the existing file with the given name in this directory for read-only access."	^ StandardFileStream readOnlyFileNamed: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 1/5/98 20:49'!containingDirectory	"Return the directory containing this directory."	^ FileDirectory on: (FileDirectory dirPathFor: pathName)! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/5/97 15:46'!directoryNamed: localFileName	"Return the subdirectory of this directory with the given name."	^ FileDirectory on: (self fullNameFor: localFileName)! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/5/97 15:44'!directoryNames	"Return a collection of names for the subdirectories of this directory."	"FileDirectory default directoryNames"	^ (self entries select: [:entry | entry at: 4])		collect: [:entry | entry first]! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/5/97 12:23'!entries	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name><creationTime><modificationTime><dirFlag><fileSize>). See primLookupEntryIn:index: for further details."	"FileDirectory default entries"	^ self directoryContentsFor: pathName! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/5/97 15:39'!fileAndDirectoryNames	"FileDirectory default fileAndDirectoryNames"	^ self entries collect: [:entry | entry first]! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/5/97 15:44'!fileNames	"Return a collection of names for the files (but not directories) in this directory."	"FileDirectory default fileNames"	^ (self entries select: [:entry | (entry at: 4) not])		collect: [:entry | entry first]! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/5/97 15:39'!keysDo: nameBlock	"Evaluate the given block for each file or directory name in this directory."	^ self fileAndDirectoryNames do: nameBlock! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/5/97 12:35'!statsForDirectoryTree: rootedPathName	"Return the size statistics for the entire directory tree starting at the given root. The result is a three element array of the form: (<number of folders><number of files><total bytes in all files>). This method also serves as an example of how recursively enumerate a directory tree."	"FileDirectory default statsForDirectoryTree: 'Black Uhuru:System Folder'"	| dirs files bytes todo p entries |	dirs _ files _ bytes _ 0.	todo _ OrderedCollection with: rootedPathName.	[todo isEmpty] whileFalse: [		p _ todo removeFirst.		entries _ self directoryContentsFor: p.		entries do: [:entry |			(entry at: 4)				ifTrue: [					todo addLast: (p, ':', (entry at: 1)).					dirs _ dirs + 1]				ifFalse: [					files _ files + 1.					bytes _ bytes + (entry at: 5)]]].	^ Array with: dirs with: files with: bytes! !!FileDirectory methodsFor: 'testing' stamp: 'jm 12/5/97 15:35'!fileExists: filenameOrPath	"Answer true if a file of the given name exists. The given name may be either a full path name or a local file within this directory."	| fullName |	FileDirectory splitName: filenameOrPath to:		[:filePath :ignore |			filePath isEmpty				ifTrue: [  "file in this directory"					fullName _ pathName, self pathNameDelimiter asString, filenameOrPath]				ifFalse: [  "file has its own path"					fullName _ filenameOrPath]].	^ StandardFileStream isAFileNamed: fullName! !!FileDirectory methodsFor: 'testing' stamp: 'jm 12/5/97 15:39'!includesKey: localName	"Answer true if this directory includes a file or directory of the given name. Note that the name should be a local file name, in contrast with fileExists:, which takes either local or full-qualified file names."	^ self fileAndDirectoryNames includes: localName! !!FileDirectory methodsFor: 'file operations' stamp: 'jm 12/4/97 22:53'!copyFileNamed: fileName1 toFileNamed: fileName2	"Copy the contents of the existing file with the first name into a new file with the second name. Both files are assumed to be in this directory."	"FileDirectory default copyFileNamed: 'todo.txt' toFileNamed: 'todocopy.txt'"	| file1 file2 buffer |	file1 _ self readOnlyFileNamed: fileName1.	file2 _ self newFileNamed: fileName2.	buffer _ String new: 50000.	[file1 atEnd] whileFalse:		[file2 nextPutAll: (file1 nextInto: buffer)].	file1 close.	file2 close.! !!FileDirectory methodsFor: 'file operations' stamp: 'jm 12/4/97 22:55'!createDirectory: localFileName	"Create a directory with the given name in this directory. Fail if the name is bad or if a file or directory with that name already exists." 	self primCreateDirectory: (self fullNameFor: localFileName).! !!FileDirectory methodsFor: 'file operations' stamp: 'jm 12/5/97 16:33'!deleteFileNamed: localFileName	"Delete the file with the given name in this directory."	self deleteFileNamed: localFileName ifAbsent: [].! !!FileDirectory methodsFor: 'file operations' stamp: 'jm 12/4/97 22:56'!deleteFileNamed: localFileName ifAbsent: failBlock	"Delete the file of the given name if it exists, else evaluate failBlock."	(self primDeleteFileNamed: (self fullNameFor: localFileName)) == nil		ifTrue: [^ failBlock value].! !!FileDirectory methodsFor: 'file operations' stamp: 'jm 12/5/97 15:50'!rename: oldFileName toBe: newFileName	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name."	^ self primRename: (self fullNameFor: oldFileName)				     to: (self fullNameFor: newFileName) ! !!FileDirectory methodsFor: 'file operations' stamp: 'jm 12/5/97 15:21'!setMacFileNamed: fileName type: typeString creator: creatorString	"Set the Macintosh file type and creator info for the file with the given name. Fails if the file does not exist or if the type and creator type arguments are not strings of length 4."	"FileDirectory default setMacFileNamed: 'foo' type: 'TEXT' creator: 'ttxt'" 	self primSetMacFileNamed: (self fullNameFor: fileName)		type: typeString		creator: creatorString.! !!FileDirectory methodsFor: 'file name utilities' stamp: 'jm 12/4/97 21:19'!checkName: aFileName fixErrors: fixing	"Check a string aFileName for validity as a file name. Answer the original file name if it is valid. If the name is not valid (e.g., it is too long or contains illegal characters) and fixing is false, raise an error. If fixing is true, fix the name (usually by truncating and/or tranforming characters), and answer the corrected name. The default behavior is to truncate the name to 31 chars. Subclasses can do any kind of checking and correction appropriate to the underlying platform."	aFileName size = 0 ifTrue: [self error: 'zero length file name'].	aFileName size > 31 ifTrue: [		fixing			ifTrue: [^ aFileName contractTo: 31]			ifFalse: [self error: 'file name is too long']].	^ aFileName! !!FileDirectory methodsFor: 'file name utilities' stamp: 'jm 12/4/97 21:01'!fileNamesMatching: pat	"FileDirectory default fileNamesMatching: '*'"	^ self fileNames select: [:name | pat match: name]! !!FileDirectory methodsFor: 'file name utilities' stamp: 'jm 12/5/97 12:14'!fullNameFor: fileName	"Return a corrected, fully-qualified name for the given file name. If the given name is already a full path (i.e., it contains a delimiter character), assume it is already a fully-qualified name. Otherwise, prefix it with the path to this directory. In either case, correct the local part of the file name."	"Details: Note that path relative to a directory, such as '../../foo' are disallowed by this algorithm."	| correctedLocalName prefix |	FileDirectory splitName: fileName to:		[:filePath :localName |			correctedLocalName _ self checkName: localName fixErrors: true.			filePath isEmpty				ifTrue: [prefix _ pathName]  "path to this directory"				ifFalse: [prefix _ filePath]].  "path supplied with fileName"	prefix isEmpty		ifTrue: [^ correctedLocalName]		ifFalse: [^ prefix, self pathNameDelimiter asString, correctedLocalName].! !!FileDirectory methodsFor: 'file name utilities' stamp: 'jm 12/4/97 21:19'!isLegalFileName: aString 	"Answer true if the given string is a legal file name."	^ (self checkName: aString fixErrors: true) = aString! !!FileDirectory methodsFor: 'printing' stamp: 'jm 12/4/97 19:41'!printOn: aStream 	"Refer to the comment in Object|printOn:."	aStream nextPutAll: self class name.	aStream nextPutAll: ' on '.	pathName printOn: aStream.! !!FileDirectory methodsFor: 'private' stamp: 'jm 12/5/97 12:37'!directoryContentsFor: fullPath	"Return a collection of directory entries for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	"FileDirectory default directoryContentsFor: ''"	| entries index done entry |	entries _ OrderedCollection new: 200.	index _ 1.	done _ false.	[done] whileFalse: [		entry _ self primLookupEntryIn: fullPath index: index.		entry == nil			ifTrue: [done _ true]			ifFalse: [entries addLast: entry].		index _ index + 1].	^ entries asArray! !!FileDirectory methodsFor: 'private' stamp: 'jm 12/4/97 21:35'!primCreateDirectory: fullPath	"Create a directory named by the given path. Fail if the path is bad or if a file or directory by that name already exists." 	<primitive: 160>	self primitiveFailed! !!FileDirectory methodsFor: 'private' stamp: 'jm 12/4/97 21:38'!primDeleteFileNamed: aFileName	"Delete the file of the given name. Return self if the primitive succeeds, nil otherwise."	<primitive: 156>	^ nil! !!FileDirectory methodsFor: 'private' stamp: 'jm 12/4/97 21:47'!primLookupEntryIn: fullPath index: index	"Look up the index-th entry of the directory with the given fully-qualified path (i.e., starting from the root of the file hierarchy) and return an array containing:	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>	The empty string enumerates the top-level files or drives. (For example, on Unix, the empty path enumerates the contents of '/'. On Macs and PCs, it enumerates the mounted volumes/drives.)	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given path is bad." 	<primitive: 162>	self primitiveFailed! !!FileDirectory methodsFor: 'private' stamp: 'jm 12/4/97 21:45'!primRename: oldFileFullName to: newFileFullName 	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name."	<primitive: 159>	self error:'Attempt to rename a non-existent file,or to use a name that is already in use'.! !!FileDirectory methodsFor: 'private' stamp: 'jm 12/5/97 15:22'!primSetMacFileNamed: fileName type: typeString creator: creatorString	"Set the Macintosh file type and creator info for the file with the given name. Fails if the file does not exist or if the type and creator type arguments are not strings of length 4. This primitive is Mac specific; it is a noop on other platforms." 	<primitive: 169>	self primitiveFailed! !!FileDirectory methodsFor: 'private' stamp: 'jm 12/4/97 22:44'!setPathName: pathString	pathName _ pathString.! !!FileDirectory class methodsFor: 'instance creation' stamp: 'jm 12/4/97 19:24'!default	"Answer the default directory."	^ DefaultDirectory! !!FileDirectory class methodsFor: 'instance creation' stamp: 'jm 12/4/97 22:02'!on: pathName	"Return a new instance for the directory the given path. (The instance is of the appropriate subclass for the current OS platform)."	^ self activeDirectoryClass new setPathName: pathName! !!FileDirectory class methodsFor: 'instance creation' stamp: 'jm 12/4/97 23:29'!root	"Answer the root directory."	^ self on: ''! !!FileDirectory class methodsFor: 'name utilities' stamp: 'jm 12/4/97 23:38'!checkName: fullName fixErrors: flag	"Check a string aFileName for validity as a file name. Answer the original file name if it is valid. If the name is not valid (e.g., it is too long or contains illegal characters) and fixing is false, raise an error. If fixing is true, fix the name (usually by truncating and/or tranforming characters), and answer the corrected name. The default behavior is to truncate the name to 31 chars. Subclasses can do any kind of checking and correction appropriate to the underlying platform."	^ DefaultDirectory		checkName: (self localNameFor: fullName)		fixErrors: flag! !!FileDirectory class methodsFor: 'name utilities' stamp: 'jm 12/5/97 13:30'!dirPathFor: fullName	"Return the directory part the given name."	self		splitName: fullName		to: [:dirPath :localName | ^ dirPath]! !!FileDirectory class methodsFor: 'name utilities' stamp: 'jm 12/4/97 23:40'!isLegalFileName: fullName	"Return true if the given string is a legal file name."	^ DefaultDirectory isLegalFileName: (self localNameFor: fullName)! !!FileDirectory class methodsFor: 'name utilities' stamp: 'jm 12/5/97 13:30'!localNameFor: fullName	"Return the local part the given name."	self		splitName: fullName		to: [:dirPath :localName | ^ localName]! !!FileDirectory class methodsFor: 'name utilities' stamp: 'jm 12/4/97 23:37'!splitName: fullName to: pathAndNameBlock	"Take the file name and convert it to the path name of a directory and a local file name within that directory. FileName must be of the form: <dirPath><delimitor><localName>, where <dirPath><delimitor> is optional. The <dirPath> part may contain delimitors."	| delimiter i dirName localName |	delimiter _ self pathNameDelimiter.	(i _ fullName findLast: [:c | c = delimiter]) = 0		ifTrue: [			dirName _ String new.			localName _ fullName]		ifFalse: [			dirName _ fullName copyFrom: 1 to: i - 1.			localName _ fullName copyFrom: i + 1 to: fullName size].	^ pathAndNameBlock value: dirName value: localName! !!FileDirectory class methodsFor: 'create/delete file' stamp: 'tk 1/13/98 17:21'!deleteFilePath: fullPathToAFile	"Delete the file after finding its directory"	| dir |	dir _ self on: (self dirPathFor: fullPathToAFile).	dir deleteFileNamed: (self localNameFor: fullPathToAFile).! !!FileDirectory class methodsFor: 'system start up' stamp: 'jm 12/5/97 16:26'!openSources: sourcesName andChanges: changesName forImage: imageName	"Initialize the default directory to the image directory and open the sources and changes files, if possible. Look for the changes file in image directory. Look for the system sources (or an alias to it) first in the VM directory, then in the image directory. Open the changes and sources files and install them in SourceFiles."	"Note: SourcesName and imageName are full paths; changesName is a local name."	| sources changes sourceAlias msg localSourcesName |	msg _'Squeak cannot locate &fileRef.Please check that the file is named properly and is in thesame directory as this image.  Further explanation can foundin the startup window, ''How Squeak Finds Source Code''.'.	self setDefaultDirectoryFrom: imageName.	sources _ changes _ nil.	"look for the sources file or an alias to it in the VM's directory"	(DefaultDirectory fileExists: sourcesName)		ifTrue: [sources _ DefaultDirectory readOnlyFileNamed: sourcesName]		ifFalse: [			"look for an un-renamed Macintosh alias to the sources file"			sourceAlias _ sourcesName, ' alias'.			(DefaultDirectory fileExists: sourceAlias)				ifTrue: [sources _ DefaultDirectory readOnlyFileNamed: sourceAlias]].	sources ifNil: [		"look for the sources file or an alias to it in the image directory"		localSourcesName _ FileDirectory localNameFor: sourcesName.		(DefaultDirectory fileExists: localSourcesName)			ifTrue: [sources _ DefaultDirectory readOnlyFileNamed: localSourcesName]			ifFalse: [				"look for an un-renamed Macintosh alias to the sources file"				sourceAlias _ localSourcesName, ' alias'.				(DefaultDirectory fileExists: sourceAlias)					ifTrue: [sources _ DefaultDirectory readOnlyFileNamed: sourceAlias]]].	(DefaultDirectory fileExists: changesName)		ifTrue: [changes _ DefaultDirectory oldFileNamed: changesName].	((sources == nil) and: [Preferences valueOfFlag: #warnIfNoSourcesFile]) ifTrue: [		PopUpMenu notify:			(msg copyReplaceAll: '&fileRef' with: 'the sources file named ' , sourcesName)].	((changes == nil) and: [Preferences valueOfFlag: #warnIfNoChangesFile]) ifTrue: [		PopUpMenu notify:			(msg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName)].	SourceFiles _ Array with: sources with: changes.! !!FileDirectory class methodsFor: 'system start up' stamp: 'jm 12/4/97 22:32'!setDefaultDirectoryFrom: imageName	"Initialize the default directory to the directory containing the Squeak image file. This method is called when the image start up."	DefaultDirectory _ self on: (self dirPathFor: imageName).! !!FileDirectory class methodsFor: 'platform specific' stamp: 'jm 12/4/97 23:41'!pathNameDelimiter	"Return the directory path delimiter character for this directory."	^ self primPathNameDelimiter! !!FileDirectory class methodsFor: 'private' stamp: 'jm 12/4/97 23:36'!activeDirectoryClass	"Return the concrete FileDirectory subclass for the platform on which we are currently running."	| platformDelimiter |	platformDelimiter _ self primPathNameDelimiter.	FileDirectory allSubclasses do: [:class |		class pathNameDelimiter = platformDelimiter ifTrue: [^ class]].	"no responding subclass; use FileDirectory"	^ FileDirectory! !!FileDirectory class methodsFor: 'private' stamp: 'jm 12/4/97 23:42'!primPathNameDelimiter	"Return the path delimiter for the underlying platform's file system." 	<primitive: 161>	self primitiveFailed! !!FileList methodsFor: 'initialization'!directory: dir	"Set the path of the volume to be displayed."	sortMode == nil ifTrue: [sortMode _ #date].   "2/7/97 sw personal preference"	self okToChange ifFalse: [^ self].	directory _ dir.	volList _ (Array with: '[]'), directory pathParts.	self changed: #relabel.	self changed: #list.	self newListAndPattern: (pattern == nil ifTrue: ['*']										ifFalse: [pattern]).! !!FileList methodsFor: 'list access' stamp: 'jm 12/4/97 19:29'!toggleFileListIndex: anInteger	"Select the file name in the receiver's list whose index is the argument, 	anInteger. If the current selection index is already anInteger, deselect it."	| item name |	listIndex = anInteger	ifTrue:		[listIndex _ 0.		fileName _ nil]	ifFalse: 		[listIndex _ anInteger.		item _ list at: anInteger.		item first = $( ifTrue:  "remove size or date"			[item _ item copyFrom: (item indexOf: $)) + 2 to: item size].		(item endsWith: self folderString)			ifTrue:			["remove [...] folder string and open the folder"			name _ item copyFrom: 1 to: item size - self folderString size.			listIndex _ 0.			^ self directory: (FileDirectory on: (directory fullNameFor: name))]			ifFalse:			["open the file selected"			self setFileName: item]].	self changed: #fileListIndex! !!FileList methodsFor: 'list access' stamp: 'jm 12/4/97 19:29'!toggleListIndex: index	"Select the volume name in the receiver's list whose index is the argument."	| delim path |	volListIndex _ index.	delim _ directory pathNameDelimiter.	path _ String streamContents: [:strm |		2 to: index do: [:i |			strm nextPutAll: (volList at: i).			i < index ifTrue: [strm nextPut: delim]]].	self directory: (FileDirectory on: path).! !!FileList methodsFor: 'menu messages' stamp: 'jm 12/5/97 11:45'!copyName	listIndex = 0 ifTrue: [^ self].	ParagraphEditor new clipboardTextPut: self fullName asText.! !!FileList methodsFor: 'private'!defaultContents	list == nil ifTrue: [^ String new].	^ String streamContents:		[:s | s nextPutAll: 'NO FILE SELECTED'; cr.		s nextPutAll: '  -- Folder Summary --'; cr.		list do: [:item | s nextPutAll: item; cr]]! !!FileList methodsFor: 'private' stamp: 'jm 12/5/97 12:26'!listForPattern: pat	"Make the list be those file names which match the pattern."	| entries maxiPad newList allFiles thisName sizeStr |	entries _ directory entries.	sortMode == #size		ifTrue: [maxiPad _ (entries inject: 0 into:						[:mx :spec | mx max: (spec at: 5)])							asStringWithCommas size - 1].	newList _ sortMode == #name		ifTrue: [(SortedCollection new: 30) sortBlock: [:x :y | x <= y]]		ifFalse: [(SortedCollection new: 30) sortBlock: [:x :y | x >= y]].	allFiles _ pat = '*'.	entries do:		[:spec | "<name><creationTime><modificationTime><dirFlag><fileSize>"		thisName _ (spec at: 4)			ifTrue: [spec first , self folderString]			ifFalse: [spec first].		(allFiles or: [pat match: thisName]) ifTrue:			[sortMode == #date				ifTrue: [thisName _ '(' ,						((Date fromDays: (spec at: 3) // 86400)							printFormat: #(3 2 1 $. 1 1 2)) , ' ' ,						(String streamContents: [:s |							(Time fromSeconds: (spec at: 3) \\ 86400)								print24: true on: s])						, ') ' , thisName].			sortMode == #size				ifTrue: [sizeStr _ (spec at: 5) asStringWithCommas.						thisName _ '(' ,							((sizeStr size to: maxiPad) collect: [:i | $ ]) ,							sizeStr						, ') ' , thisName].			newList add: thisName]].	^ newList! !!FileList methodsFor: 'private'!readContentsBrief: brevity	"Read the contents of the receiver's selected file."	listIndex = 0		ifTrue: [^self defaultContents]		ifFalse: [^ super readContentsBrief: brevity]! !!FileListController methodsFor: 'menu messages' stamp: 'jm 11/13/97 14:12'!importImage	"Import the selected image file, storing the resulting Form or ColorForm in the global GIFImports dictionary at a key derived from the filename."	model isLocked ifTrue: [^ view flash].	self controlTerminate.	model importImage.	self controlInitialize.! !!FileListController methodsFor: 'menu messages'!openImageInWindow	self controlTerminate.	model openImageInWindow.	self controlInitialize	! !!FileListController methodsFor: 'menu messages' stamp: 'jm 12/18/97 23:04'!playMidiFile	self controlTerminate.	model playMidiFile.	self controlInitialize.! !!FileListController methodsFor: 'menu messages' stamp: 'tk 1/7/98 12:16'!putUpdate	"Put this file out as an Update on the servers."	| serverGroups index names |	model isLocked ifTrue: [^ view flash].	self controlTerminate.	serverGroups _ ServerDirectory serverGroups.	"OC of associations"	names _ serverGroups collect: [:each | each key].	index _ (PopUpMenu labelArray: names lines: #()) 		startUpWithCaption: 'Choose a group of servers to write on.'.	index > 0 ifTrue: [		(serverGroups at: index) value putUpdate: 				(FileStream oldFileNamed: model fullName)].	self controlInitialize! !!FileListController class methodsFor: 'class initialization' stamp: 'di 1/8/98 15:08'!initialize   "FileListController initialize"	"Initialize the file list menu.  6/96 di; modified 7/12/96 sw to add the file-into-new-change-set feature"	FileListYellowButtonMenu _ PopUpMenu labels:'fileInfile into new change setbrowse changesspawn this filecopy name to clipboardopen image in a windowread image into GIFImportsplay midi filesort by namesort by sizesort by daterenamedeleteadd new filebroadcast as update' lines: # (5 7 8 11).	FileListYellowButtonMessages _#(fileInSelection fileIntoNewChangeSet browseChanges editFile copyName openImageInWindow importImage playMidiFile sortByName sortBySize sortByDate renameFile deleteFile addNewFile putUpdate)! !!FileModel methodsFor: 'accessing' stamp: 'di 6/28/97 21:25'!fileAllIn	"FileIn all of the contents from the external file"	| f |	f _ FileStream oldFileNamed: self fullName.	(self fileNameSuffix sameAs: 'html') ifTrue: [f _ f asHtml].	f fileIn! !!FileModel methodsFor: 'accessing' stamp: 'di 6/28/97 21:26'!fileIntoNewChangeSet	"FileIn all of the contents from the external file, into a new change set."	| f |	f _ FileStream oldFileNamed: self fullName.	(self fileNameSuffix sameAs: 'html') ifTrue: [f _ f asHtml].	ChangeSorter newChangesFromFileStream: f! !!FileModel methodsFor: 'accessing' stamp: 'di 6/28/97 21:21'!fileNameSuffix	| name i |	name _ self fullName.	i _ name findLast: [:c | c = $.].	i = 0 ifTrue: [^ ''].	^ name copyFrom: i+1 to: name size! !!FileModel methodsFor: 'accessing' stamp: 'jm 11/12/97 18:22'!importImage	"Import the selected file and store the resulting Form or ColorForm in the global dictionary GIFImports, at a key consisting of the short filename up to the first period."	| f |	f _ Form fromFileNamed: self fullName.	f ifNil: [^ self error: 'unrecognized image file format'].	Smalltalk gifImports at: (self fileName sansPeriodSuffix) put: f.! !!FileModel methodsFor: 'accessing' stamp: 'jm 11/12/97 18:13'!openImageInWindow	"Handle three file formats: GIF, Form stoteOn: (run coded), and BMP. Fail if file format is not recognized." 	| f |	f _ Form fromFileNamed: self fullName.	f ifNil: [^ self error: 'unrecognized image file format'].	FormView open: f named: fileName.! !!FileModel methodsFor: 'accessing' stamp: 'jm 12/30/97 10:20'!playMidiFile	"Play a midi file." 	MIDIFileReader playFileNamed: self fullName.! !!FileModel methodsFor: 'accessing'!put: aString 	| f |	(aString size >= 5 and:		[#('File ' '16r0 ') includes: (aString copyFrom: 1 to: 5)])		ifTrue: [(self confirm:'Abbreviated and hexadecimal file viewscannot be meaningfully saved at present.Is this REALLY what you want to do?')				ifFalse: [^ self]].	f _ FileStream newFileNamed: self fullName.	Cursor write showWhile: [f nextPutAll: aString; close].! !!FileModel methodsFor: 'accessing' stamp: 'tk 9/21/96'!readContentsBrief: brevityFlag	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size newContents first1000 last1000 |	f _ FileStream oldFileOrNoneNamed: self fullName. 	f == nil ifTrue:		[^ 'For some reason, this file cannot be read'].	(brevityFlag and: [(size _ f size) > 30000]) ifFalse: 		[^ f contentsOfEntireFile].	"Don't display long files at first.	Composing the paragraph may take a long time."	first1000 _ f next: 1000.	f position: size - 1000.	last1000 _ f next: 1000.	f close.	^ 'File ''' , fileName , ''' is ', size printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 1000 characters:--------------------------------' , first1000 , '... and here are the last 1000 characters:--------------------------------------' , last1000! !!FileModel methodsFor: 'accessing' stamp: 'tk 9/21/96'!readContentsHex	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f _ FileStream oldFileOrNoneNamed: self fullName. 	f == nil ifTrue:		[^ 'For some reason, this file cannot be read'].	(size _ f size) > 10000		ifTrue: [data _ f next: 10000. f close]		ifFalse: [data _ f contentsOfEntireFile].	s _ WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].		s cr].	hexData _ s contents.	size > 10000		ifTrue: [^ 'First 10k bytes:------------------' , hexData]		ifFalse: [^ hexData].! !I represent a Stream that accesses a FilePage from a File. One use for my instance is to access larger "virtual Strings" than can be stored contiguously in main memory. I restrict the objects stored and retrieved to be Integers or Characters. An end of file pointer terminates reading; it can be extended by writing past it, or the file can be explicitly truncated.	To use the file system for most applications, you typically create a FileStream. This is done by sending a message to a FileDirectory (file:, oldFile:, newFile:, rename:newName:) which creates an instance of me. Accesses to the file are then done via my instance.*** On Mac and DOS, files cannot be shortened!!  ***  To overwrite a file with a shorter one, first delete the old file (FileDirectory deleteFilePath: 'Hard Disk:aFolder:dataFolder:foo') or (aFileDirectory deleteFileNamed: 'foo').  Then write your new shorter version.!!FileStream methodsFor: 'file accessing' stamp: 'jm 12/5/97 12:53'!localName	^ FileDirectory localNameFor: self name! !!FileStream methodsFor: 'file modes' stamp: 'tk 6/26/97 12:15'!ascii	"Set the receiver's file to be in text mode.	 1/31/96 sw: subclassResponsibility"	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'tk 6/26/97 12:15'!text	"Define both text and ascii as meaning not binary.  We need to supply what people will think of.  tk 6/26/97 12:15"	self ascii! !!FileStream methodsFor: 'file status'!close	"Set the receiver's file status to closed."	closed		ifFalse: 			[self writing 				ifTrue: [(rwmode bitAnd: Shorten) = Shorten							ifTrue: [self shorten]							ifFalse: [self flush]].			closed _ true.			readLimit _ writeLimit _ 0.			self file close].! !!FileStream methodsFor: 'fileIn/Out' stamp: 'jm 12/3/97 23:06'!fileInObjectAndCode	"Optimization: Read entire file into memory before processing."	| s |	self text.	s _ RWBinaryOrTextStream with: (self contentsOfEntireFile).	s position: 0.	^ s fileInObjectAndCode! !!FileStream class methodsFor: 'instance creation'!fileNamed: fileName 	^ self concreteStream fileNamed: (self fullName: fileName)! !!FileStream class methodsFor: 'instance creation'!newFileNamed: fileName 	^ self concreteStream newFileNamed: (self fullName: fileName)! !!FileStream class methodsFor: 'instance creation'!oldFileNamed: fileName 	^ self concreteStream oldFileNamed: (self fullName: fileName)! !!FileStream class methodsFor: 'instance creation' stamp: 'tk 9/21/96'!oldFileOrNoneNamed: fileName	"Only open the file if it exists already.  Don't get an error if not there.  "| myName |myName _ self fullName: fileName.^ (self concreteStream isAFileNamed: myName) 	ifTrue: [self concreteStream oldFileNamed: myName]	ifFalse: [nil].! !!FileStream class methodsFor: 'instance creation'!readOnlyFileNamed: fileName 	^ self concreteStream readOnlyFileNamed: (self fullName: fileName)! !!FileStream class methodsFor: 'concrete classes' stamp: 'tk 9/21/96'!concreteStream	"Who should we really direct class queries to?  "	^ StandardFileStream! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'sw 9/21/97 12:04'!message: messageString displayAt: aPoint centered: centered action: aBlock initialAnswer: aString answerHeight: answerHeight windowTitle: windowTitle	"Answer an instance of me whose question is messageString. Once the 	user provides an answer, then evaluate aBlock. If centered, a Boolean, is 	false, display the view of the instance at aPoint; otherwise display it 	with its center at aPoint."	| newBlank |	newBlank _ self new initialize.	newBlank action: aBlock.	newBlank contents: aString.	^ FillInTheBlankView		openOn: newBlank		message: messageString		displayAt: aPoint		centered: centered		answerHeight: answerHeight		windowTitle: windowTitle! !!FillInTheBlankView class methodsFor: 'instance creation' stamp: 'sw 9/21/97 11:51'!openOn: aFillInTheBlank message: messageString displayAt: originPoint centered: centered	"Create and schedule an instance of me that displays aFillInTheBlank 	asking the question messageString. If the argument centered, a Boolean, 	is false, display the instance with top left corner at originPoint; 	otherwise, display it with its center at originPoint. Do not schedule, 	rather take control immediately and insist that the user respond."	^ self openOn: aFillInTheBlank message: messageString displayAt: originPoint centered: centered answerHeight: 40 windowTitle: 'Type a response'! !!FillInTheBlankView class methodsFor: 'instance creation' stamp: 'sw 9/21/97 12:06'!openOn: aFillInTheBlank message: messageString displayAt: originPoint centered: centered answerHeight: answerHeight windowTitle: windowTitle	"Do not schedule, rather take control immediately and insist that the user respond."	| topView messageView answerView |	messageView _ self buildMessageView: messageString.	answerView _ 		self buildAnswerView: aFillInTheBlank 			frameWidth: messageView window width height: answerHeight.	topView _ StandardSystemView new model: aFillInTheBlank.	topView addSubView: messageView.	topView addSubView: answerView below: messageView. 	topView		align: (centered				ifTrue: [topView viewport center]				ifFalse: [topView viewport topLeft])		with: originPoint.	topView label: windowTitle.	topView window: 		(0@0 extent: messageView window width @ (messageView window height + answerHeight)).	topView controller openDisplayAt: originPoint! !!FillInTheBlankView class methodsFor: 'private' stamp: 'sw 9/21/97 11:47'!buildAnswerView: aFillInTheBlank frameWidth: widthInteger	^ self buildAnswerView: aFillInTheBlank frameWidth: widthInteger height: 40! !!FillInTheBlankView class methodsFor: 'private' stamp: 'sw 9/21/97 11:46'!buildAnswerView: aFillInTheBlank frameWidth: widthInteger height: aHeight	| answerView |	answerView _ self new model: aFillInTheBlank.	answerView window: (0@0 extent: widthInteger @ aHeight).	answerView borderWidth: 2.	^ answerView! !!FlasherMorph methodsFor: 'all'!color: aColor	super color: aColor.	onColor _ aColor.! !!FlasherMorph methodsFor: 'all'!fullPrintOn: aStream	color _ onColor.	super fullPrintOn: aStream.! !!FlasherMorph methodsFor: 'all'!initialize	super initialize.	self color: Color red.	self extent: 25@25.	self borderWidth: 2.! !!FlasherMorph methodsFor: 'all'!step	color = onColor		ifTrue: [super color: (onColor mixed: 0.5 with: Color black)]		ifFalse: [super color: onColor].! !!FlasherMorph methodsFor: 'all'!stepTime	"Answer the desired time between steps in milliseconds."	^ 500! !!Float methodsFor: 'arithmetic'!* aNumber 	"Primitive. Answer the result of multiplying the receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 49>	^ (aNumber adaptFloat: self) * aNumber adaptToFloat! !!Float methodsFor: 'arithmetic'!+ aNumber 	"Primitive. Answer the sum of the receiver and aNumber. Essential.	Fail if the argument is not a Float. See Object documentation	whatIsAPrimitive."	<primitive: 41>	^ (aNumber adaptFloat: self) + aNumber adaptToFloat! !!Float methodsFor: 'arithmetic'!- aNumber 	"Primitive. Answer the difference between the receiver and aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 42>	^ (aNumber adaptFloat: self) - aNumber adaptToFloat! !!Float methodsFor: 'arithmetic'!/ aNumber 	"Primitive. Answer the result of dividing receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 50>	aNumber = 0		ifTrue: [self error: 'attempt to divide by zero']		ifFalse: [^ (aNumber adaptFloat: self) / aNumber adaptToFloat]! !!Float methodsFor: 'arithmetic'!abs	"This is faster than using Number abs."	self < 0.0		ifTrue: [^ 0.0 - self]		ifFalse: [^ self]! !!Float methodsFor: 'arithmetic'!reciprocal	^ 1.0 / self! !!Float methodsFor: 'mathematical functions'!arcCos	"Answer the angle in radians."	^ Halfpi - self arcSin! !!Float methodsFor: 'mathematical functions'!arcSin	"Answer the angle in radians."	((self < -1.0) or: [self > 1.0]) ifTrue: [self error: 'Value out of range'].	((self = -1.0) or: [self = 1.0])		ifTrue: [^ Halfpi]		ifFalse: [^ (self / (1.0 - (self * self)) sqrt) arcTan]! !!Float methodsFor: 'mathematical functions'!arcTan	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| theta eps step sinTheta cosTheta |	<primitive: 57>	"Newton-Raphson"	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].	"first guess"	theta _ (self * Halfpi) / (self + 1.0).	"iterate"	eps _ Halfpi * Epsilon.	step _ theta.	[(step * step) > eps] whileTrue: [		sinTheta _ theta sin.		cosTheta _ theta cos.		step _ (sinTheta * cosTheta) - (self * cosTheta * cosTheta).		theta _ theta - step].	^ theta! !!Float methodsFor: 'mathematical functions'!cos	"Answer the cosine of the receiver taken as an angle in radians."	^ (self + Halfpi) sin! !!Float methodsFor: 'mathematical functions'!degreeCos	"Answer the cosine of the receiver taken as an angle in degrees."	^ self degreesToRadians cos! !!Float methodsFor: 'mathematical functions'!degreeSin	"Answer the sine of the receiver taken as an angle in degrees."	^ self degreesToRadians sin! !!Float methodsFor: 'mathematical functions'!exp	"Answer E raised to the receiver power.	 Optional. See Object documentation whatIsAPrimitive." 	| base fract correction delta div |	<primitive: 59>	"Taylor series"	"check the special cases"	self < 0.0 ifTrue: [^ (self negated exp) reciprocal].	self = 0.0 ifTrue: [^ 1].	self abs > MaxValLn ifTrue: [self error: 'exp overflow'].	"get first approximation by raising e to integer power"	base _ E raisedToInteger: (self truncated).	"now compute the correction with a short Taylor series"	"fract will be 0..1, so correction will be 1..E"	"in the worst case, convergance time is logarithmic with 1/Epsilon"	fract _ self fractionPart.	fract = 0.0 ifTrue: [ ^ base ].  "no correction required"	correction _ 1.0 + fract.	delta _ fract * fract / 2.0.	div _ 2.0.	[delta > Epsilon] whileTrue: [		correction _ correction + delta.		div _ div + 1.0.		delta _ delta * fract / div].	correction _ correction + delta.	^ base * correction! !!Float methodsFor: 'mathematical functions'!floorLog: radix 	"Quick computation of (self log: radix) floor."	| x rsq |	self < radix ifTrue: [^0]. 	"self assumed positive"	self < (rsq _ radix * radix) ifTrue: [^1].	x _ 2 * (self floorLog: rsq).	"binary recursion like ipow"	^x + (self / (radix raisedTo: x) floorLog: radix)! !!Float methodsFor: 'mathematical functions'!ln	"Answer the natural logarithm of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	| expt n mant x div pow delta sum eps |	<primitive: 58>	"Taylor series"	self <= 0.0 ifTrue: [self error: 'ln is only defined for x > 0.0'].	"get a rough estimate from binary exponent"	expt _ self exponent.	n _ Ln2 * expt.	mant _ self timesTwoPower: 0 - expt.	"compute fine correction from mantinssa in Taylor series"	"mant is in the range [0..2]"	"we unroll the loop to avoid use of abs"	x _ mant - 1.0.	div _ 1.0.	pow _ delta _ sum _ x.	x _ x negated.  "x <= 0"	eps _ Epsilon * (n abs + 1.0).	[delta > eps] whileTrue: [		"pass one: delta is positive"		div _ div + 1.0.		pow _ pow * x.		delta _ pow / div.		sum _ sum + delta.		"pass two: delta is negative"		div _ div + 1.0.		pow _ pow * x.		delta _ pow / div.		sum _ sum + delta].	^ n + sum	"2.718284 ln 1.0"! !!Float methodsFor: 'mathematical functions'!log	"Answer the base 10 logarithm of the receiver."	^ self ln / Ln10! !!Float methodsFor: 'mathematical functions'!raisedTo: power	^ (self ln * power asFloat) exp! !!Float methodsFor: 'mathematical functions'!sin	"Answer the sine of the receiver taken as an angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| sum delta self2 i |	<primitive: 56>	"Taylor series"	"normalize to the range [0..Pi/2]"	self < 0.0 ifTrue: [^ (0.0 - ((0.0 - self) sin))].	self > Twopi ifTrue: [^ (self \\ Twopi) sin].	self > Pi ifTrue: [^ (0.0 - (self - Pi) sin)].	self > Halfpi ifTrue: [^ (Pi - self) sin].	"unroll loop to avoid use of abs"	sum _ delta _ self.	self2 _ 0.0 - (self * self).	i _ 2.0.	[delta > Epsilon] whileTrue: [		"once"		delta _ (delta * self2) / (i * (i + 1.0)).		i _ i + 2.0.		sum _ sum + delta.		"twice"		delta _ (delta * self2) / (i * (i + 1.0)).		i _ i + 2.0.		sum _ sum + delta].	^ sum! !!Float methodsFor: 'mathematical functions'!sqrt	"Answer the square root of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	| exp guess eps delta |	<primitive: 55>	"Newton-Raphson"	self <= 0.0 ifTrue: [		self = 0.0			ifTrue: [^ 0.0]			ifFalse: [^ self error: 'sqrt is invalid for x < 0']].	"first guess is half the exponent"	exp _ self exponent // 2.	guess _ self timesTwoPower: (0 - exp).	"get eps value"	eps _ guess * Epsilon.	eps _ eps * eps.	delta _ (self - (guess * guess)) / (guess * 2.0).	[(delta * delta) > eps] whileTrue: [		guess _ guess + delta.		delta _ (self - (guess * guess)) / (guess * 2.0)].	^ guess! !!Float methodsFor: 'mathematical functions'!tan	"Answer the tangent of the receiver taken as an angle in radians."	^ self sin / self cos! !!Float methodsFor: 'comparing'!< aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 43>	^ (aNumber adaptFloat: self) < aNumber adaptToFloat! !!Float methodsFor: 'comparing'!<= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object	documentation whatIsAPrimitive."	<primitive: 45>	^ (aNumber adaptFloat: self) <= aNumber adaptToFloat! !!Float methodsFor: 'comparing'!= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is equal to the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 47>	aNumber isNumber ifFalse: [^ false].	^ (aNumber adaptFloat: self) = aNumber adaptToFloat! !!Float methodsFor: 'comparing'!> aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 44>	^ (aNumber adaptFloat: self) > aNumber adaptToFloat! !!Float methodsFor: 'comparing'!>= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object documentation 	whatIsAPrimitive. "	<primitive: 46>	^ (aNumber adaptFloat: self) >= aNumber adaptToFloat! !!Float methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented.	 Both words of the double float are used; 8 bits are	 removed from each end to clear most of the exponent	 regardless of the byte ordering. (Three bitAnd:s are	 utilized to assure the intermediate results do not	 become a large integer.) Slower than the original	 version in the ratios 12:5 to 2:1 depending on values.	 Answers the same result on Big Endian and Small Endian	 IEEE machines.(DNS, 11 May, 1997) "	^ (		(			((self basicAt: 1) bitAnd: 16r00FFFF00) +			((self basicAt: 2) bitAnd: 16r00FFFF00)		) bitAnd: 16r00FFFF00	  ) >> 8! !!Float methodsFor: 'truncation and round off'!fractionPart	"Primitive. Answer a Float whose value is the difference between the 	receiver and the receiver's asInteger value. Optional. See Object 	documentation whatIsAPrimitive."	<primitive: 52>	^self - self truncated asFloat! !!Float methodsFor: 'truncation and round off'!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value. Essential. See Object documentation 	whatIsAPrimitive. "	<primitive: 51>	^ (self quo: 16383.0) * 16383 + (self rem: 16383.0) truncated! !!Float methodsFor: 'converting'!adaptFraction: aFraction	"If I am involved in arithmetic with a Fraction, convert the Fraction."	^ aFraction asFloat! !!Float methodsFor: 'converting'!adaptInteger: anInteger	"If I am involved in arithmetic with an Integer, convert the Integer."	^ anInteger asFloat! !!Float methodsFor: 'converting'!adaptToFraction	"If I am involved in arithmetic with a Fraction, do not convert me."	^ self! !!Float methodsFor: 'converting'!adaptToInteger	"If I am involved in arithmetic with an Integer, do not convert me."	^ self! !!Float methodsFor: 'converting'!asApproximateFraction	"Answer a Fraction approximating the receiver. This conversion uses the 	continued fraction method to approximate a floating point number."	| num1 denom1 num2 denom2 int frac newD temp |	num1 _ self asInteger.	"The first of two alternating numerators"	denom1 _ 1.		"The first of two alternating denominators"	num2 _ 1.		"The second numerator"	denom2 _ 0.		"The second denominator--will update"	int _ num1.		"The integer part of self"	frac _ self fractionPart.		"The fractional part of self"	[frac = 0]		whileFalse: 			["repeat while the fractional part is not zero"			newD _ 1.0 / frac.			"Take reciprocal of the fractional part"			int _ newD asInteger.		"get the integer part of this"			frac _ newD fractionPart.	"and save the fractional part for next time"			temp _ num2.				"Get old numerator and save it"			num2 _ num1.				"Set second numerator to first"			num1 _ num1 * int + temp.	"Update first numerator"			temp _ denom2.				"Get old denominator and save it"			denom2 _ denom1.			"Set second denominator to first"			denom1 _ int * denom1 + temp.		"Update first denominator"			10000000000.0 < denom1				ifTrue: 					["Is ratio past float precision?  If so, pick which 					of the two ratios to use"					num2 = 0.0 						ifTrue: ["Is second denominator 0?"								^ Fraction numerator: num1 denominator: denom1].					^ Fraction numerator: num2 denominator: denom2]].	"If fractional part is zero, return the first ratio"	denom1 = 1		ifTrue: ["Am I really an Integer?"				^ num1 "Yes, return Integer result"]		ifFalse: ["Otherwise return Fraction result"				^ Fraction numerator: num1 denominator: denom1]! !!Float methodsFor: 'converting'!asFraction	^ self asApproximateFraction ! !!Float methodsFor: 'converting'!asTrueFraction	" Answer a fraction that EXACTLY represents self,	  a double precision IEEE floating point number.	  (It tears an IEEE float into its components; it	  assumes 'correct' byte ordering; runs on PPC.) 	  Thanks to David N. Smith"	| shifty sign exp fraction |	shifty := ((self at: 1) bitShift: 32) bitOr: (self at: 2).	sign := (shifty bitShift: -63) = 0 ifTrue: [1] ifFalse: [-1].	exp := (shifty >> 52) bitAnd: 16r7FF.	fraction := shifty bitAnd:  16r000FFFFFFFFFFFFF.	(exp = 0) & (fraction = 0) ifTrue: [ ^ 0  ].	fraction := fraction bitOr: 16r0010000000000000.	exp := exp - 16r3FF.	" Validate that the dismemberment was correct "	(sign * fraction / (2 raisedToInteger: 52 - exp)) asFloat = self		ifFalse: [self error: 'asFraction validation failed' ].	^ sign * fraction / (2 raisedToInteger: 52 - exp)! !!Float methodsFor: 'converting'!isFloat	^ true! !!Float methodsFor: 'printing'!hex  "If ya really want to know..."	| word nibble |	^ String streamContents:		[:strm |		1 to: 2 do:			[:i | word _ self at: i.			1 to: 8 do: 				[:s | nibble _ (word bitShift: -8+s*4) bitAnd: 16rF.				strm nextPut: ('0123456789ABCDEF' at: nibble+1)]]]"(-2.0 to: 2.0) collect: [:f | f hex]"! !!Float methodsFor: 'printing'!printOn: aStream base: base	"Estimate significant figures and handle sign." 	| digitCount |	digitCount _ 2r1.0e52 floorLog: base asFloat.  "IEEE double -- 52 bits"	self > 0.0		ifTrue: [self absPrintOn: aStream base: base digitCount: digitCount]		ifFalse: [self = 0.0 ifTrue: [^ aStream nextPutAll: '0.0'].				aStream nextPutAll: '-'.				self negated absPrintOn: aStream base: base digitCount: digitCount]! !!Float methodsFor: 'private'!absPrintOn: aStream base: base digitCount: digitCount 	"Print me in the given base, using digitCount significant figures."	| fuzz x exp q fBase |	fBase _ base asFloat.	"x is myself normalized to [1.0, fBase), exp is my exponent"	exp _ 		self < 1.0			ifTrue: [(fBase / self floorLog: fBase) negated]			ifFalse: [self floorLog: fBase].	x _ self / (fBase raisedTo: exp).	fuzz _ fBase raisedTo: 1 - digitCount.	"round the last digit to be printed"	x _ 0.5 * fuzz + x.	x >= fBase		ifTrue: 			["check if rounding has unnormalized x"			x _ x / fBase.			exp _ exp + 1].	(exp < 6 and: [exp > -4])		ifTrue: 			["decimal notation"			q _ 0.			exp < 0 ifTrue: [1 to: 1 - exp do: [:i | aStream nextPut: ('0.0000' at: i)]]]		ifFalse: 			["scientific notation"			q _ exp.			exp _ 0].	[x >= fuzz]		whileTrue: 			["use fuzz to track significance"			i _ x asInteger.			aStream nextPut: (Character digitValue: i).			x _ x - i asFloat * fBase.			fuzz _ fuzz * fBase.			exp _ exp - 1.			exp = -1 ifTrue: [aStream nextPut: $.]].	[exp >= -1]		whileTrue: 			[aStream nextPut: $0.			exp _ exp - 1.			exp = -1 ifTrue: [aStream nextPut: $.]].	q ~= 0		ifTrue: 			[aStream nextPut: $e.			q printOn: aStream]! !!Float methodsFor: 'private'!timesTwoPower: anInteger 	"Primitive. Answer with the receiver multiplied by 2.0 raised	to the power of the argument.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 54>	anInteger < -29 ifTrue: [^ self * (2.0 raisedToInteger: anInteger)].	anInteger < 0 ifTrue: [^ self / (1 bitShift: (0 - anInteger)) asFloat].	anInteger < 30 ifTrue: [^ self * (1 bitShift: anInteger) asFloat].	^ self * (2.0 raisedToInteger: anInteger)! !!Float class methodsFor: 'class initialization'!initialize		"Float initialize. Float pi" 	"Constants from Computer Approximations, pp. 182-183:		Pi = 3.14159265358979323846264338327950288 		Pi/2 = 1.57079632679489661923132169163975144 		Pi/4 = 0.78539816339744830961566084581987572 		Pi*2 = 6.28318530717958647692528676655900576 		Pi/180 = 0.01745329251994329576923690768488612 		2.0 ln = 0.69314718055994530941723212145817657 		2.0 sqrt = 1.41421356237309504880168872420969808"	Pi _ 3.14159265358979323846264338327950288.	Halfpi _ Pi / 2.0.	Fourthpi _ Pi / 4.0.	Twopi _ Pi * 2.0.	RadiansPerDegree _ Pi / 180.0.	Ln2 _ 0.69314718055994530941723212145817657.	Ln10 _ 10.0 ln.	Sqrt2 _ 1.41421356237309504880168872420969808.	E _ 2.718281828459045235360287471353.	Epsilon _ 0.000000000001.  "Defines precision of mathematical functions"	MaxVal _ 1e306.	MinVal _ 1e-306.	MaxValLn _ 704.! !!Float class methodsFor: 'constants'!e	"Answer the constant, E."	^E! !!FMSound methodsFor: 'initialization' stamp: 'jm 12/19/97 08:33'!setPitch: p dur: d loudness: vol	"(FMSound pitch: 880.0 dur: 2.5 loudness: 0.8) play"	waveTable _ SineTable.	scaledWaveTableSize _ waveTable size * ScaleFactor.	modulation ifNil: [modulation _ 0.0].	multiplier ifNil: [multiplier _ 0.0].	self pitch: p.	self duration: d.	self setLoudness: vol.	self initialVolume: vol.	self reset.! !!FMSound methodsFor: 'accessing' stamp: 'jm 12/16/97 11:27'!duration	^ (initialCount / self samplingRate asFloat) rounded! !!FMSound methodsFor: 'accessing' stamp: 'jm 12/16/97 11:28'!duration: seconds	super duration: seconds.	initialCount _ (seconds * self samplingRate) rounded.! !!FMSound methodsFor: 'accessing' stamp: 'jm 12/17/97 18:05'!modulation	^ modulation! !!FMSound methodsFor: 'accessing' stamp: 'jm 12/17/97 18:05'!modulation: mod	self modulation: mod multiplier: multiplier.! !!FMSound methodsFor: 'accessing' stamp: 'jm 12/17/97 20:53'!modulation: mod multiplier: mult	modulation _ mod abs.	multiplier _ mult abs.	normalizedModulation _ (modulation * scaledIndexIncr) // ScaleFactor.	scaledOffsetIndexIncr _ (multiplier * scaledIndexIncr) rounded.	"clip to maximum values if necessary"	normalizedModulation > MaxScaledValue ifTrue: [		normalizedModulation _ MaxScaledValue.		modulation _ (normalizedModulation * ScaleFactor) asFloat / scaledIndexIncr].	scaledOffsetIndexIncr > (scaledWaveTableSize // 2) ifTrue: [		scaledOffsetIndexIncr _ scaledWaveTableSize // 2.		multiplier _ scaledOffsetIndexIncr asFloat / scaledIndexIncr].! !!FMSound methodsFor: 'accessing' stamp: 'jm 12/17/97 18:05'!multiplier	^ multiplier! !!FMSound methodsFor: 'accessing' stamp: 'jm 12/17/97 18:04'!multiplier: mult	self modulation: modulation multiplier: mult.! !!FMSound methodsFor: 'accessing' stamp: 'jm 12/17/97 19:49'!pitch	^ (self samplingRate * (scaledIndexIncr // ScaleFactor)) asFloat / waveTable size! !!FMSound methodsFor: 'accessing' stamp: 'jm 12/17/97 22:12'!pitch: p	scaledIndexIncr _		((p asFloat * waveTable size asFloat * ScaleFactor asFloat) // self samplingRate asFloat) rounded			min: (waveTable size // 2) * ScaleFactor.	self modulation: modulation multiplier: multiplier.! !!FMSound methodsFor: 'sound generation' stamp: 'jm 1/5/98 18:29'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy."	"(FMSound pitch: 440.0 dur: 1.0 loudness: 0.5) play"	| doingFM lastIndex sample offset i s |	<primitive: 180>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #waveTable declareC: 'short int *waveTable'.	doingFM _ (normalizedModulation ~= 0) and: [scaledOffsetIndexIncr ~= 0].	lastIndex _ (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sample _ (scaledVol * (waveTable at: (scaledIndex // ScaleFactor) + 1)) // ScaleFactor.		doingFM			ifTrue: [				offset _ normalizedModulation * (waveTable at: (scaledOffsetIndex // ScaleFactor) + 1).				scaledOffsetIndex _ (scaledOffsetIndex + scaledOffsetIndexIncr) \\ scaledWaveTableSize.				scaledOffsetIndex < 0					ifTrue: [scaledOffsetIndex _ scaledOffsetIndex + scaledWaveTableSize].				scaledIndex _ (scaledIndex + scaledIndexIncr + offset) \\ scaledWaveTableSize.				scaledIndex < 0					ifTrue: [scaledIndex _ scaledIndex + scaledWaveTableSize]]			ifFalse: [				scaledIndex _ (scaledIndex + scaledIndexIncr) \\ scaledWaveTableSize].		leftVol > 0 ifTrue: [			i _ (2 * sliceIndex) - 1.			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i _ 2 * sliceIndex.			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0]]].	count _ count - n.! !!FMSound methodsFor: 'sound generation' stamp: 'jm 12/17/97 19:18'!reset	super reset.	count _ initialCount.	scaledIndex _ 0.	scaledOffsetIndex _ 0.! !!FMSound methodsFor: 'sound generation' stamp: 'jm 12/8/97 19:34'!samplesRemaining	^ count! !!FMSound class methodsFor: 'class initialization' stamp: 'jm 12/17/97 21:27'!initialize	"Build a sine wave table."	"FMSound initialize"	| tableSize radiansPerStep peak |	tableSize _ 4000.	SineTable _ SoundBuffer newMonoSampleCount: tableSize.	radiansPerStep _ (2.0 * Float pi) / tableSize asFloat.	peak _ ((1 bitShift: 15) - 1) asFloat.  "range is +/- (2^15 - 1)"	1 to: tableSize do: [:i |		SineTable at: i put: (peak * (radiansPerStep * i) sin) rounded].! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/7/98 11:54'!bass1	"FMSound bass1 play"	"(FMSound lowMajorScaleOn: FMSound bass1) play"	| snd |	snd _ FMSound pitch: 220 dur: 1 loudness: 0.8.	snd modulation: 0 multiplier: 0.	snd addEnvelope:		(VolumeEnvelope exponentialDecay: 0.95 stepSize: 10).	snd duration: 1.0.	^ snd! !!FMSound class methodsFor: 'instruments' stamp: 'jm 12/17/97 22:38'!brass1	"FMSound brass1 play"	"(FMSound lowMajorScaleOn: FMSound brass1) play"	| snd p env |	snd _ FMSound pitch: 220 dur: 1 loudness: 0.8.	snd modulation: 0 multiplier: 1.	p _ OrderedCollection new.	p add: 0.1@0; add: 70@1.0; add: 100@0.8; add: 220@0.7; add: 320@0.8; add: 380@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env target: snd; updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	p _ OrderedCollection new.	p add: 0@0.0; add: 90@1.0; add: 120@0.9; add: 220@0.7; add: 320@0.9; add: 380@0.0.	env _ VolumeEnvelope points: p loopStart: 3 loopEnd: 5.	env target: snd; scale: 0.7.	snd addEnvelope: env.	snd duration: 1.0.	^ snd! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/6/98 23:20'!brass2	"FMSound brass2 play"	"(FMSound lowMajorScaleOn: FMSound brass2) play"	| snd p env |	snd _ FMSound pitch: 220 dur: 1 loudness: 0.8.	snd modulation: 0 multiplier: 1.	p _ OrderedCollection new.	p add: 0.1@0; add: 30@1.0; add: 40@0.8; add: 220@0.7; add: 320@0.8; add: 380@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env target: snd; updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	p _ OrderedCollection new.	p add: 0@0.0; add: 20@1.0; add: 40@0.9; add: 100@0.7; add: 160@0.9; add: 200@0.0.	env _ VolumeEnvelope points: p loopStart: 3 loopEnd: 5.	env target: snd.	snd addEnvelope: env.	snd duration: 1.0.	^ snd! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/5/98 17:35'!default	^ self oboe1! !!FMSound class methodsFor: 'instruments' stamp: 'jm 12/30/97 14:50'!flute1	"FMSound flute1 play"	"(FMSound majorScaleOn: FMSound flute1) play"	| snd p env |	snd _ FMSound pitch: 220 dur: 1 loudness: 0.8.	snd modulation: 0 multiplier: 0.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 110@0.0.	env _ VolumeEnvelope points: p loopStart: 2 loopEnd: 3.	env target: snd; scale: 1.0.	snd addEnvelope: env.	snd duration: 1.0.	^ snd! !!FMSound class methodsFor: 'instruments' stamp: 'jm 12/31/97 12:44'!oboe1	"FMSound oboe1 play"	"(FMSound majorScaleOn: FMSound oboe1) play"	| snd p env |	snd _ FMSound pitch: 220 dur: 1 loudness: 0.8.	snd modulation: 1 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0; add: 5@1.0; add: 100@1.0; add: 110@0.0.	env _ VolumeEnvelope points: p loopStart: 2 loopEnd: 3.	env target: snd; scale: 1.0.	snd addEnvelope: env.	snd duration: 0.5.	^ snd! !!FMSound class methodsFor: 'instruments' stamp: 'jm 12/17/97 22:20'!organ1	"FMSound organ1 play"	"(FMSound majorScaleOn: FMSound organ1) play"	| snd p env |	snd _ FMSound pitch: 220 dur: 1 loudness: 0.8.	snd modulation: 0 multiplier: 0.	p _ OrderedCollection new.	p add: 0@0; add: 60@1.0; add: 125@0.6; add: 200@1.0; add: 250@0.0.	env _ VolumeEnvelope points: p loopStart: 2 loopEnd: 4.	env target: snd; scale: 1.0.	snd addEnvelope: env.	snd duration: 1.0.	^ snd! !!FMSound class methodsFor: 'instruments' stamp: 'jm 12/17/97 22:40'!randomWeird1	"FMSound randomWeird1 play"	| snd env p |	p _ 200.0 + 1200 atRandom.	snd _ FMSound pitch: p dur: 5.0 loudness: 0.5.	env _ VolumeEnvelope exponentialDecay: 0.92 stepSize: 50.	env target: snd; scale: 1.0.	snd addEnvelope: env.	env _ Envelope example.	env target: snd; updateSelector: #pitch:; scale: p.	snd addEnvelope: env.	snd duration: 5.0.	^ snd! !!FMSound class methodsFor: 'instruments' stamp: 'jm 12/17/97 22:40'!randomWeird2	"FMSound randomWeird2 play"	| p snd env |	p _ (Random new next * 2400.0) + 1200.0.	snd _ FMSound pitch: p dur: 5.0 loudness: 0.5.	env _ VolumeEnvelope exponentialDecay: 0.92 stepSize: 50.	env target: snd; scale: 1.0.	snd addEnvelope: env.	env _ Envelope exponentialDecay: 0.98 stepSize: 70.	env target: snd; updateSelector: #pitch:; scale: p.	snd addEnvelope: env.	snd duration: 5.0.	^ snd! !!FontSet class methodsFor: 'as yet unclassified'!acceptsLoggingOfCompilation	"Dont log sources for my subclasses, so as not to waste time and space	storing printstring versions of the string literals."	^ self == FontSet! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'di 9/15/97 12:01'!convertFontsNamed: familyName  "FontSet convertFontsNamed: 'Palatino' "	^ self convertFontsNamed: familyName inDirectoryNamed: ''! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'jm 12/5/97 15:46'!convertFontsNamed: familyName inDirectoryNamed: dirName		"FontSet convertFontsNamed: 'Tekton' inDirectoryNamed: 'Tekton Fonts' "	"This utility is for use after you have used BitFont to produce data files 	for the fonts you wish to use.  It will read the BitFont files and build	a fontset class from them.  If one already exists, the sizes that can be	found will be overwritten."	"For this utility to work as is, the BitFont data files must be named 'familyNN.BF',	and must reside in the directory named by dirName (use '' for the current directory)."	| f allFontNames className fontSet sizeChars header fontString tempName dir |	"Check first for matching file names and usable FontSet class name."	dir _ dirName isEmpty		ifTrue: [FileDirectory default]		ifFalse: [FileDirectory default directoryNamed: dirName].	allFontNames _ dir fileNamesMatching: familyName , '##.BF'.	allFontNames isEmpty ifTrue: [^ self halt: 'No files found like ' , familyName , 'NN.BF'].	className _ (familyName select: [:c | c isAlphaNumeric]) capitalized asSymbol.	(Smalltalk includesKey: className)		ifTrue: ["Check that this is already a FontSet"				((fontSet _ Smalltalk at: className) inheritsFrom: self)					ifFalse: [self halt: 'The name ' , familyName , ' is already in use']]		ifFalse: [fontSet _ self subclass: className					instanceVariableNames: '' classVariableNames: ''					poolDictionaries: '' category: self category].	tempName _ 'FontTemp.sf2'.	allFontNames do:		[:fname | Transcript cr; show: fname.		f _ StrikeFont new readFromBitFont: (dir fullNameFor: fname).		f writeAsStrike2named: tempName.		fontString _ (FileStream oldFileNamed: tempName) contentsOfEntireFile.		sizeChars _ (fname copyFrom: familyName size + 1 to: fname size) copyUpTo: $. .		header _ 'sizeNN	^ self size: NN fromLiteral:' copyReplaceAll: 'NN' with: sizeChars.		fontSet class compile: header , fontString printString			classified: 'font creation' notifying: nil].	FileDirectory default deleteFileNamed: tempName.! !!FontSet class methodsFor: 'as yet unclassified' stamp: 'di 7/2/97 07:42'!fileOut	"FileOut and then change the properties of the file so that it won't be	treated as text by, eg, email attachment facilities"	super fileOut.	(FileStream oldFileNamed: self name , '.st') setFileTypeToObject; close! !!Form methodsFor: 'accessing' stamp: 'tk 3/9/97'!center	"Note that offset is ignored here.  Are we really going to embrace offset?  "	^ (width @ height) // 2! !!Form methodsFor: 'accessing'!size	"Should no longer be used -- use bitsSize instead.  length of variable part of instance."	^ super size! !!Form methodsFor: 'copying' stamp: 'jm 11/12/97 19:28'!as8BitColorForm	"Simple conversion of zero pixels to transparent.  Force it to 8 bits."	| f map |	f _ ColorForm extent: self extent depth: 8.	self displayOn: f at: self offset negated.	map _ Color indexedColors copy.	map at: 1 put: Color transparent.	f colors: map.	f offset: self offset.	^ f! !!Form methodsFor: 'copying'!copy: aRect 	"Return a new form which derives from the portion of the original form delineated by aRect."	| newForm |	newForm _ self class extent: aRect extent depth: depth.	^ newForm copyBits: aRect from: self at: 0@0		clippingBox: newForm boundingBox rule: Form over fillColor: nil! !!Form methodsFor: 'copying'!copy: sourceRectangle from: sourceForm to: destPt rule: rule	^ self copy: (destPt extent: sourceRectangle extent)		from: sourceRectangle topLeft in: sourceForm rule: rule! !!Form methodsFor: 'displaying' stamp: 'di 7/1/97 14:06'!colormapIfNeededForDepth: destDepth	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."	depth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"	^ Color colorMapIfNeededFrom: depth to: destDepth! !!Form methodsFor: 'displaying'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm map: map	"Make up a BitBlt table and copy the bits.  Use a colorMap."	((BitBlt 		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: rule		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: clipRect) colorMap: map) copyBits! !!Form methodsFor: 'displaying'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: rule fillColor: aForm	aDisplayMedium copyBits: self boundingBox		from: self		at: aDisplayPoint + self offset		clippingBox: clipRectangle		rule: rule		fillColor: aForm		map: (self colormapIfNeededForDepth: aDisplayMedium depth).! !!Form methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aForm 	"Graphically, it means nothing to scale a Form by floating point values.  	Because scales and other display parameters are kept in floating point to 	minimize round off errors, we are forced in this routine to round off to the 	nearest integer."	| absolutePoint scale magnifiedForm |	absolutePoint _ displayTransformation applyTo: relativePoint.	absolutePoint _ absolutePoint x asInteger @ absolutePoint y asInteger.	displayTransformation noScale		ifTrue: [magnifiedForm _ self]		ifFalse: 			[scale _ displayTransformation scale.			scale _ scale x @ scale y.			(1@1 = scale)					ifTrue: [scale _ nil. magnifiedForm _ self]					ifFalse: [magnifiedForm _ self magnify: self boundingBox by: scale]].	magnifiedForm		displayOn: aDisplayMedium		at: absolutePoint - alignmentPoint		clippingBox: clipRectangle		rule: ruleInteger		fillColor: aForm! !!Form methodsFor: 'filling' stamp: 'tk 6/20/96'!colorAt: aPoint	"Return the color in the pixel at the given point.  "	^ Color 		colorFromPixelValue: (self pixelValueAt: aPoint)		depth: depth! !!Form methodsFor: 'filling' stamp: 'tk 6/20/96'!colorAt: aPoint put: aColor	"Store a Color into the pixel at coordinate aPoint.  "	self pixelValueAt: aPoint put: (aColor pixelValueForDepth: depth)."[Sensor anyButtonPressed] whileFalse:	[Display colorAt: Sensor cursorPoint put: Color red]"! !!Form methodsFor: 'filling'!isTransparentAt: aPoint 	"Return true if the receiver is transparent at the given point."	depth = 1 ifTrue: [^ false].  "no transparency at depth 1"	^ (self pixelValueAt: aPoint) = (Color transparent pixelValueForDepth: depth)! !!Form methodsFor: 'filling'!makeBWForm: foregroundColor	"Map this form into a B/W form with 1's in the foreground regions."	| bwForm map |	bwForm _ Form extent: self extent.	map _ self newColorMap.  "All non-foreground go to 0's"	map at: (foregroundColor indexInMap: map) put: 1.	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.	^ bwForm! !!Form methodsFor: 'filling' stamp: 'tk 6/20/96'!pixelValueAt: aPoint 	"Return the raw pixel value at the given point. This pixel value depends on the receiver's depth. Typical clients use colorAt: to get a Color.  "	^ (BitBlt bitPeekerFromForm: self) pixelAt: aPoint! !!Form methodsFor: 'filling' stamp: 'tk 6/20/96'!pixelValueAt: aPoint put: pixelValue	"Store the given raw pixel value at the given point. Typical clients use colorAt:put: to store a color. "	(BitBlt bitPokerToForm: self) pixelAt: aPoint put: pixelValue.! !!Form methodsFor: 'filling' stamp: 'sw 9/19/96'!shapeFill: aColor interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind |	depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ Bitmap new: (1 bitShift: (depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd _ depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color _ Color colorFromPixelValue: interiorPixVal depth: depth.				ind _ color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.		"bwForm _ self makeBWForm: interiorColor."	"not work for two whites"	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Finally use that shape as a mask to flood the region with color"	((BitBlt destForm: self sourceForm: bwForm 		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits."	bwForm displayOn: self		at: 0@0		clippingBox: self boundingBox		rule: Form erase1bitShape		fillColor: nil.	"	"(cColor pixelValueForDepth: depth) = 0 ifTrue: [^ bwForm]."	"transparent"	self fillShape: bwForm fillColor: aColor.	^ bwForm! !!Form methodsFor: 'filling'!shapeFill: aColor seedBlock: seedBlock	depth > 1 ifTrue: [self error: 'This call only meaningful for B/W forms'].	(self findShapeAroundSeedBlock: seedBlock)		displayOn: self at: 0@0 clippingBox: self boundingBox		rule: Form under fillColor: aColor ! !!Form methodsFor: 'bordering'!border: rect width: borderWidth rule: rule fillColor: fillColor        "Paint a border whose rectangular area is defined by rect. Thewidth of the border of each side is borderWidth. Uses fillColor for drawingthe border."        | blt |        blt _ (BitBlt toForm: self) combinationRule: rule; fillColor: fillColor.        blt sourceOrigin: 0@0.        blt destOrigin: rect origin.        blt width: rect width; height: borderWidth; copyBits.        blt destY: rect corner y - borderWidth; copyBits.        blt destY: rect origin y + borderWidth.        blt height: rect height - borderWidth - borderWidth; width:borderWidth; copyBits.        blt destX: rect corner x - borderWidth; copyBits! !!Form methodsFor: 'bordering'!borderFormOfWidth: borderWidth sharpCorners: sharpen	"Smear this form around and then subtract the original to produce	an outline.  If sharpen is true, then cause right angles to be outlined	by right angles (takes an additional diagonal smears ANDed with both	horizontal and vertical smears)."	| smearForm bigForm smearPort all cornerForm cornerPort nbrs |	depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	bigForm _ self deepCopy.	all _ bigForm boundingBox.	smearForm _ Form extent: self extent.	smearPort _ BitBlt toForm: smearForm.	sharpen ifTrue:		[cornerForm _ Form extent: self extent.		cornerPort _ BitBlt toForm: cornerForm].	nbrs _ (0@0) fourNeighbors.	1 to: borderWidth do:		[:i |  "Iterate to get several layers of 'skin'"		nbrs do:			[:d |  "Smear the self in 4 directions to grow each layer of skin"			smearPort copyForm: bigForm to: d rule: Form under].		sharpen ifTrue:			["Special treatment to smear sharp corners"			nbrs with: ((2 to: 5) collect: [:i2 | nbrs atWrap: i2]) do:				[:d1 :d2 |				"Copy corner points diagonally"				cornerPort copyForm: bigForm to: d1+d2 rule: Form over.				"But only preserve if there were dots on either side"				cornerPort copyForm: bigForm to: d1+d1+d2 rule: Form and.				cornerPort copyForm: bigForm to: d1+d2+d2 rule: Form and.				smearPort copyForm: cornerForm to: 0@0 rule: Form under].			].		bigForm copy: all from: 0@0 in: smearForm rule: Form over.		].	"Now erase the original shape to obtain the outline"	bigForm copy: all from: 0@0 in: self rule: Form erase.	^ bigForm! !!Form methodsFor: 'bordering'!borderWidth: anInteger 	"Set the width of the border for the receiver to be anInteger and paint it 	using black as the border color."	self border: self boundingBox width: anInteger fillColor: Color black! !!Form methodsFor: 'bordering'!shapeBorder: aColor width: borderWidth interiorPoint: interiorPoint	sharpCorners: sharpen internal: internal	"Identify the shape (region of identical color) at interiorPoint,	and then add an outline of width=borderWidth and color=aColor.	If sharpen is true, then cause right angles to be outlined by	right angles.  If internal is true, then produce a border that lies	within the identified shape.  Thus one can put an internal border	around the whole background, thus effecting a normal border	around every other foreground image."	| shapeForm borderForm interiorColor |	"First identify the shape in question as a B/W form"	interiorColor _ self colorAt: interiorPoint.	shapeForm _ (self makeBWForm: interiorColor) reverse				findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Reverse the image to grow the outline inward"	internal ifTrue: [shapeForm reverse].	"Now find the border fo that shape"	borderForm _ shapeForm borderFormOfWidth: borderWidth sharpCorners: sharpen.	"Finally use that shape as a mask to paint the border with color"	self fillShape: borderForm fillColor: aColor! !!Form methodsFor: 'scaling, rotation'!flipBy: direction centerAt: aPoint	"Return a copy of the receiver flipped either #vertical or #horizontal."	| newForm quad |	newForm _ Form extent: self extent depth: depth.	quad _ self boundingBox innerCorners.	quad _ (direction = #vertical ifTrue: [#(2 1 4 3)] ifFalse: [#(4 3 2 1)])		collect: [:i | quad at: i].	(WarpBlt toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		combinationRule: 3;		copyQuad: quad toRect: newForm boundingBox.	newForm offset: (self offset flipBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))			flipBy: #vertical centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f flipBy: #vertical centerAt: 0@0.	(f2 flipBy: #vertical centerAt: 0@0) displayAt: p]"! !!Form methodsFor: 'scaling, rotation'!magnify: aRectangle by: scale 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	^ self magnify: aRectangle by: scale smoothing: 1"Dynamic test...[Sensor anyButtonPressed] whileFalse:	[(Display magnify: (Sensor cursorPoint extent: 31@41) by: 5@3) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:	[cp _ Sensor cursorPoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent) display]]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f magnify: f boundingBox by: 5@3.	(f2 shrink: f2 boundingBox by: 5@3) displayAt: p]"! !!Form methodsFor: 'scaling, rotation'!magnify: aRectangle by: scale smoothing: cellSize	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	| newForm |	newForm _ Form extent: (aRectangle extent * scale) truncated depth: depth.	(WarpBlt toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: 3;		copyQuad: aRectangle innerCorners toRect: newForm boundingBox.	^ newForm"Dynamic test...[Sensor anyButtonPressed] whileFalse:	[(Display magnify: (Sensor cursorPoint extent: 131@81) by: 0.5 smoothing: 2) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:	[cp _ Sensor cursorPoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent smoothing: 2) display]]"! !!Form methodsFor: 'scaling, rotation'!rotateBy: deg	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	^ self rotateBy: deg smoothing: 1" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5)) display].f display"! !!Form methodsFor: 'scaling, rotation'!rotateBy: direction centerAt: aPoint	"Return a rotated copy of the receiver. 	direction = #right, #left, or #pi"	| newForm quad rot |	newForm _ self class extent: (direction = #pi ifTrue: [width@height]											ifFalse: [height@width]) depth: depth.	quad _ self boundingBox innerCorners.	rot _ #(right pi left) indexOf: direction.	(WarpBlt toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		combinationRule: 3;		copyQuad: ((1+rot to: 4+rot) collect: [:i | quad atWrap: i])			 toRect: newForm boundingBox.	newForm offset: (self offset rotateBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: #left centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f rotateBy: #left centerAt: 0@0.	(f2 rotateBy: #right centerAt: 0@0) displayAt: p]"! !!Form methodsFor: 'scaling, rotation' stamp: 'tk 3/26/97'!rotateBy: deg magnify: scale smoothing: cellSize	"Rotate the receiver by the indicated number of degrees and magnify.  "	"rot is the destination form, big enough for any angle."	| side rot warp r1 pts p bigSide |	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.	bigSide _ (side * scale) rounded.	rot _ Form extent: bigSide@bigSide depth: self depth.	warp _ (WarpBlt toForm: rot)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form paint.	r1 _ (0@0 extent: side@side) align: (side@side)//2 with: self boundingBox center.	"Rotate the corners of the source rectangle." 	pts _ r1 innerCorners collect:		[:pt | p _ pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5) magnify: 0.75 smoothing: 2) display].f display"! !!Form methodsFor: 'scaling, rotation' stamp: 'sw 8/9/96'!rotateBy: deg rotationCenter: aPoint	"Rotate the receiver by the indicated number of degrees.  This variant gets a rotation center, but in fact ignores the thing -- awaiting someone's doing the right thing.   	Note that rotationCenter should now be easy to include in the offset of the resulting form -- see <Point> rotateBy: angle about: center.  Could be even faster by sharing the sin, cos inside rotateBy:.  This should really be reversed so that this becomes the workhorse, and rotateBy: calls this with rotationCenter: self boundingBox center.  And while we're at it, why not include scaling?   "	^ self rotateBy: deg smoothing: 1! !!Form methodsFor: 'scaling, rotation'!rotateBy: deg smoothing: cellSize	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	| side rot warp r1 pts p center |	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.	rot _ Form extent: side@side depth: self depth.	center _ rot extent // 2.	"Now compute the sin and cos constants for the rotation angle." 	warp _ (WarpBlt toForm: rot)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form over.	r1 _ rot boundingBox align: center with: self boundingBox center.	pts _ r1 innerCorners collect:		[:pt | p _ pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5) smoothing: 2) display].f display"! !!Form methodsFor: 'scaling, rotation'!shrink: aRectangle by: scale 	| scalePt |	scalePt _ scale asPoint.	^ self magnify: aRectangle by: (1.0 / scalePt x asFloat) @ (1.0 / scalePt y asFloat)! !!Form methodsFor: 'scaling, rotation'!xmagnify: aRectangle by: scale smoothing: cellSize	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	| newForm |	newForm _ Form extent: (aRectangle extent * scale) truncated depth: depth.	(WarpBlt toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: 3;		clipRect: (Sensor cursorPoint extent: 20@20);		copyQuad: aRectangle innerCorners toRect: newForm boundingBox.	^ newForm"Dynamic test...[Sensor anyButtonPressed] whileFalse:	[(Display xmagnify: Display boundingBox by: 0.1 smoothing: 1) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:	[cp _ Sensor cursorPoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent smoothing: 2) display]]"! !!Form methodsFor: 'image manipulation' stamp: 'di 9/2/97 20:21'!dominantColor	| tally max maxi |	tally _ self tallyPixelValues.	max _ maxi _ 0.	tally withIndexDo: [:n :i | n > max ifTrue: [maxi _ i]].	^ Color colorFromPixelValue: maxi - 1 depth: depth! !!Form methodsFor: 'image manipulation' stamp: 'tk 10/21/97 12:29'!replaceColor: oldColor withColor: newColor	"Replace one color with another everywhere is this form"	| cm newInd target ff |	cm _ Bitmap new: (1 bitShift: (depth min: 15)).	1 to: cm size do: [:i | cm at: i put: i - 1].	newInd _ newColor pixelValueForDepth: depth.	cm at: (oldColor pixelValueForDepth: depth)+1 put: newInd.	target _ newColor isTransparent 		ifTrue: [ff _ Form extent: self extent depth: depth.			ff fillWithColor: newColor.  ff]		ifFalse: [self].	(BitBlt toForm: target)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form paint;		destX: 0 destY: 0 width: width height: height;		colorMap: cm;		copyBits.	newColor = Color transparent 		ifTrue: [target displayOn: self].! !!Form methodsFor: 'image manipulation' stamp: 'jm 12/1/97 20:30'!tallyPixelValues	"Return a Bitmap with tallies in it of the number of pixels in this Form that have each pixel value. Note that several Forms may be tallied into the same table by tallyPixelValuesPrimitive:into: with the same table. Also Forms of depth 16 or 32 can be tallied into a tables of size 512, 4096, or 32768 entries by making a direct call with a Bitmap of the given size."	| tallies pixPerWord extraZeros |	tallies _ Bitmap new: (1 bitShift: (self depth min: 15)).	self tallyPixelValuesPrimitive: self boundingBox into: tallies.	pixPerWord _ 32 // depth.	(self width \\ pixPerWord) = 0		ifFalse: [			"subtract extra zeros counts due to word-boundary"			extraZeros _ self height * (pixPerWord - (self width \\ pixPerWord)).			tallies at: 1 put: (tallies at: 1) - extraZeros].	^ tallies! !!Form methodsFor: 'image manipulation' stamp: 'jm 12/1/97 19:22'!tallyPixelValuesPrimitive: destRect into: valueTable	"Tally the selected pixels of this form into valueTable, a Bitmap similar to a color map, and return valueTable. Since the BitBlt function that performs the tally does not do bit-boundary clipping, the tallies for any word-boundary fringes must be subtracted by the sender."	(BitBlt toForm: self)		sourceForm: self;  "src must be given for color map ops"		sourceOrigin: 0@0;		colorMap: valueTable;		combinationRule: 23;		destRect: destRect;		copyBits.	^ valueTable! !!Form methodsFor: 'image manipulation' stamp: 'di 10/28/97 07:49'!xTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by x-value.	Note that if not is true, then this will tally those different from pv."	| cm slice countBlt copyBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: 1@height.	copyBlt _ (BitBlt destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: 1 @ slice height				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 22.	^ (0 to: width-1) collect:		[:x |		copyBlt sourceOrigin: x@0; copyBits.		countBlt copyBits]! !!Form methodsFor: 'image manipulation' stamp: 'di 10/28/97 07:56'!yTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by y-value.	Note that if not is true, then this will tally those different from pv."	| cm slice copyBlt countBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: width@1.	copyBlt _ (BitBlt destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: slice width @ 1				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 22.	^ (0 to: height-1) collect:		[:y |		copyBlt sourceOrigin: 0@y; copyBits.		countBlt copyBits]! !!Form methodsFor: 'fileIn/Out' stamp: 'jm 9/18/97 23:13'!storeOn: aStream base: anInteger 	"Store the receiver out as an expression that can be evaluated to recreate a Form with the same contents as the original."	aStream nextPut: $(.	aStream nextPutAll: self species name.	aStream crtab: 1.	aStream nextPutAll: 'extent: '.	self extent printOn: aStream.	aStream crtab: 1.	aStream nextPutAll: 'depth: '.	self depth printOn: aStream.	aStream crtab: 1.	aStream nextPutAll: 'fromArray: #('.	1 to: bits size do: [:index | 		anInteger = 10			ifTrue: [aStream space]			ifFalse: [aStream crtab: 2].		(self bits at: index) printOn: aStream base: anInteger].	aStream nextPut: $).	aStream crtab: 1.	aStream nextPutAll: 'offset: '.	self offset printOn: aStream.	aStream nextPut: $).! !!Form methodsFor: 'fileIn/Out' stamp: 'di 9/19/97 14:55'!writeBMPfileNamed: fName  "Display writeBMPfileNamed: 'display'"	| fileName bhSize biSize biClrUsed f biSizeImage bfOffBits rowBytes rgb data |	(#(1 4 8 32) includes: depth) ifFalse: [self halt  "depth must be one of these"].	((fileName _ fName) asUppercase endsWith: '.BMP')		ifFalse: [fileName _ fName , '.BMP'].	bhSize _ 14.  "# bytes in file header"	biSize _ 40.  "info header size in bytes" 	biClrUsed _ depth = 32 ifTrue: [0] ifFalse:[1 << depth].  "No. color table entries"	bfOffBits _ biSize + bhSize + (4*biClrUsed).	rowBytes _ ((depth min: 24) * width + 31 // 32) * 4.	biSizeImage _ height * rowBytes. 	f _ (FileStream newFileNamed: fileName) binary.	"Write the file header"	f position: 0.	f nextLitteEndianNumber: 2 put: 19778.  "bfType = BM" 	f nextLitteEndianNumber: 4 put: bfOffBits + biSizeImage.  "Entire file size in bytes"	f nextLitteEndianNumber: 4 put: 0.  "bfReserved" 	f nextLitteEndianNumber: 4 put: bfOffBits.  "Offset of bitmap data from start of hdr (and file)"	"Write the bitmap info header"	f position: bhSize.	f nextLitteEndianNumber: 4 put: biSize.  "info header size in bytes" 	f nextLitteEndianNumber: 4 put: width.  "biWidth" 	f nextLitteEndianNumber: 4 put: height.  "biHeight" 	f nextLitteEndianNumber: 2 put: 1.  "biPlanes" 	f nextLitteEndianNumber: 2 put: (depth min: 24).  "biBitCount" 	f nextLitteEndianNumber: 4 put: 0.  "biCompression" 	f nextLitteEndianNumber: 4 put: biSizeImage.  "size of image section in bytes"	f nextLitteEndianNumber: 4 put: 2800.  "biXPelsPerMeter" 	f nextLitteEndianNumber: 4 put: 2800.  "biYPelsPerMeter" 	f nextLitteEndianNumber: 4 put: biClrUsed.	f nextLitteEndianNumber: 4 put: 0.  "biClrImportant" 	1 to: biClrUsed do:  "Color map"		[:i | rgb _ (Color indexedColors at: i) pixelValueForDepth: 32.		0 to: 24 by: 8 do: [:j | f nextPut: (rgb >> j bitAnd: 16rFF)]].	'Writing image data' displayProgressAt: Sensor cursorPoint		from: 1 to: height during: [:bar |			1 to: height do:				[:i | bar value: i.				data _ (self copy: (0@(height-i) extent: width@1)) bits.				depth = 32				ifTrue: [1 to: data size do: [:j | f nextLitteEndianNumber: 3 put: (data at: j)].						1 to: (data size*3)+3//4*4-(data size*3) do: [:j | f nextPut: 0 "pad to 32-bits"]]				ifFalse: ["1 to: data size do: [:j | f nextNumber: 4 put: (data at: j)]"						f nextPutAll: data]]].	f position = (bfOffBits + biSizeImage) ifFalse: [self halt].	f close.! !!Form methodsFor: 'private' stamp: 'di 9/23/97 14:36'!hackBits: bitThing	"This method provides an initialization so that BitBlt may be used, eg, to 	copy ByteArrays and other non-pointer objects efficiently.	The resulting form looks 4 wide, 8 deep, and bitThing-size-in-words high."	width _ 4.	depth _ 8.	bitThing class isBits ifFalse: [self error: 'bitThing must be a non-pointer object'].	bitThing class isBytes		ifTrue: [height _ bitThing size // 4]		ifFalse: [height _ bitThing size].	bits _ bitThing! !!Form methodsFor: 'private'!initFromArray: array	"Fill the bitmap from array.  If the array is shorter,	then cycle around in its contents until the bitmap is filled."	| ax aSize array32 i j word16 |	ax _ 0.	aSize _ array size.	aSize > bits size ifTrue:		["backward compatibility with old 16-bit bitmaps and their forms"		array32 _ Array new: height * (width + 31 // 32).		i _ j _ 0.		1 to: height do:			[:y | 1 to: width+15//16 do:				[:x16 | word16 _ array at: (i _ i + 1).				x16 odd ifTrue: [array32 at: (j _ j+1) put: (word16 bitShift: 16)]						ifFalse: [array32 at: j put: ((array32 at: j) bitOr: word16)]]].		^ self initFromArray: array32].	1 to: bits size do:		[:index |		(ax _ ax + 1) > aSize ifTrue: [ax _ 1].		bits at: index put: (array at: ax)]! !!Form methodsFor: 'private' stamp: '6/9/97 16:10 di'!setExtent: extent depth: bitsPerPixel	"Create a virtual bit map with the given extent and bitsPerPixel."	width _ extent x asInteger.	width < 0 ifTrue: [width _ 0].	height _ extent y asInteger.	height < 0 ifTrue: [height _ 0].	depth _ bitsPerPixel.	bits _ Bitmap new: self bitsSize! !!Form methodsFor: 'other' stamp: 'jm 12/5/97 21:54'!as32LevelGrayScale	"Assume the receiver is a grayscale image. Return an grayscale 8-bit Form computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit Form to save space, while retaining all 32 levels of gray available in the 8-bit color map. (The default colormap quantizes grays to only 16 levels.)"	| result |	result _ Form extent: width@height depth: 8.	self asGrayScale displayOn: result.	^ result! !!Form methodsFor: 'other' stamp: 'jm 12/5/97 20:47'!asGrayScale	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)"	| f32 srcForm result map bb grays |	depth = 32 ifFalse: [		f32 _ Form extent: width@height depth: 32.		self displayOn: f32.		f32 asGrayScale].	srcForm _ Form extent: (width * 4)@height depth: 8.	srcForm bits: bits.	result _ ColorForm extent: width@height depth: 8.	map _ Bitmap new: 256.	2 to: 256 do: [:i | map at: i put: i - 1].	map at: 1 put: 1.  "map zero pixel values to near-black"	bb _ (BitBlt toForm: result)		sourceForm: srcForm;		combinationRule: Form over;		colorMap: map.	0 to: width - 1 do: [:dstX |		bb  sourceRect: (((dstX * 4) + 2)@0 extent: 1@height);			destOrigin: dstX@0;			copyBits].	"final BitBlt to zero-out pixels that were truely transparent in the original"	map _ Bitmap new: 512.	map at: 1 put: 16rFF.	(BitBlt toForm: result)		sourceForm: self;		sourceRect: self boundingBox;		destOrigin: 0@0;		combinationRule: Form erase;		colorMap: map;		copyBits.		grays _ (0 to: 255) collect: [:brightness | Color gray: brightness asFloat / 255.0].	grays at: 1 put: Color transparent.	result colors: grays.	^ result! !!Form methodsFor: 'other' stamp: 'jm 12/5/97 19:44'!colorReduced	"Return a color-reduced ColorForm version of the receiver, if possible, or the receiver itself if not."	| tally tallyDepth colorCount newForm cm newFormColors nextColorIndex |	tally _ self tallyPixelValues asArray.	tallyDepth _ (tally size log: 2) asInteger.	colorCount _ 0.	tally do: [:n | n > 0 ifTrue: [colorCount _ colorCount + 1]].	(tally at: 1) = 0 ifTrue: [colorCount _ colorCount + 1].  "include transparent"	colorCount > 256 ifTrue: [^ self].  "cannot reduce"	newForm _ self formForColorCount: colorCount.	"build an array of just the colors used, and a color map to translate	 old pixel values to their indices into this color array"	cm _ Bitmap new: tally size.	newFormColors _ Array new: colorCount.	newFormColors at: 1 put: Color transparent.	nextColorIndex _ 2.	2 to: cm size do: [:i |		(tally at: i) > 0 ifTrue: [			newFormColors				at: nextColorIndex				put: (Color colorFromPixelValue: i - 1 depth: tallyDepth).			cm at: i put: nextColorIndex - 1.  "pixel values are zero-based indices"			nextColorIndex _ nextColorIndex + 1]].	"copy pixels into new ColorForm, mapping to new pixel values"	newForm copyBits: self boundingBox		from: self		at: 0@0		clippingBox: self boundingBox		rule: Form over		fillColor: nil		map: cm.	newForm colors: newFormColors.	^ newForm! !!Form methodsFor: 'other' stamp: 'jm 12/5/97 19:48'!colorsUsed	"Return a list of the Colors this form uses."	| tallies tallyDepth usedColors |	tallies _ self tallyPixelValues.	tallyDepth _ (tallies size log: 2) asInteger.	usedColors _ OrderedCollection new.	tallies doWithIndex: [:count :i |		count > 0 ifTrue: [			usedColors add: (Color colorFromPixelValue: i - 1 depth: tallyDepth)]].	^ usedColors asArray! !!Form methodsFor: 'other' stamp: 'jm 9/27/97 21:02'!formForColorCount: colorCount	"Return a ColorForm of sufficient depth to represent the given number of colors. The maximum number of colors is 256."	colorCount > 256 ifTrue: [^ self error: 'too many colors'].	colorCount > 16 ifTrue: [^ ColorForm extent: self extent depth: 8].	colorCount > 4 ifTrue: [^ ColorForm extent: self extent depth: 4].	colorCount > 2 ifTrue: [^ ColorForm extent: self extent depth: 2].	^ ColorForm extent: self extent depth: 1! !!Form methodsFor: 'other' stamp: 'jm 1/7/98 06:57'!mapColor: oldColor to: newColor	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	depth < 16		ifTrue: [map _ (Color cachedColormapFrom: depth to: depth) copy]		ifFalse: [			"use maximum resolution color map"			"source is 16-bit or 32-bit RGB; use colormap with 5 bits per color component"			map _ Color computeRGBColormapFor: depth bitsPerColor: 5].	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: depth).	(BitBlt toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!Form methodsFor: 'other' stamp: 'jm 12/1/97 19:58'!newColorMap 	"Return an uninitialized color map array appropriate to this Form's depth."	^ Bitmap new: (1 bitShift: (depth min: 15))! !!Form methodsFor: 'other' stamp: 'jm 1/6/98 10:37'!primPrintHScale: hScale vScale: vScale landscape: aBoolean	"On platforms that support it, this primitive prints the receiver, assumed to be a Form, to the default printer."	"(Form extent: 10@10) primPrintHScale: 1.0 vScale: 1.0 landscape: true"	<primitive: 232>	self primitiveFailed! !!Form methodsFor: 'other' stamp: 'jm 11/12/97 19:47'!removeZeroPixelsFromForm	"Make all zero-valued pixels in this Form be black, rather than transparent."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	self mapColor: Color transparent to: Color black.! !!Form methodsFor: 'transitions' stamp: 'jj 10/20/97 15:53'!fadeImage: otherImage at: topLeft	indexAndMaskDo: indexAndMaskBlock	"This fade uses halftones as a blending hack.	Zeros in the halftone produce the original image (self), and 	ones in the halftone produce the 'otherImage'.	IndexAndMaskBlock gets evaluated prior to each cycle,	and the resulting boolean determines whether to continue cycling."	| index imageRect maskForm resultForm |	imageRect _ otherImage boundingBox.	resultForm _ self copy: (topLeft extent: imageRect extent).	maskForm _ Form extent: 32@32.	index _ 0.	[indexAndMaskBlock value: (index _ index+1) value: maskForm]	whileTrue:		[maskForm reverse.		resultForm copyBits: imageRect from: resultForm at: 0@0			clippingBox: imageRect rule: Form over fillColor: maskForm.		maskForm reverse.		resultForm copyBits: imageRect from: otherImage at: 0@0			clippingBox: imageRect rule: Form under fillColor: maskForm.		self copyBits: imageRect from: resultForm at: topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Smalltalk forceDisplayUpdate]! !!Form methodsFor: 'transitions' stamp: 'jj 10/20/97 15:54'!pageImage: otherImage at: topLeft corner: corner	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.  Corner specifies which corner, as		1=topLeft, 2=topRight, 3=bottomRight, 4=bottomLeft."	| bb maskForm resultForm delta maskLoc maskRect stepSize cornerSel smallRect |	stepSize _ 10.	bb _ otherImage boundingBox.	resultForm _ self copy: (topLeft extent: bb extent).	maskForm _ Form extent: ((otherImage width min: otherImage height) + stepSize) asPoint.	"maskLoc _ starting loc rel to topLeft"	otherImage width > otherImage height		ifTrue: ["wide image; motion is horizontal."				(corner between: 2 and: 3) not ifTrue:					["motion is to the right"					delta _ 1@0.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [maskForm width@0]						ifFalse: [maskForm width@stepSize])]					ifFalse:					["motion is to the left"					delta _ -1@0.					maskLoc _ bb topRight - (corner = 2						ifTrue: [0@0]						ifFalse: [0@stepSize])]]		ifFalse: ["tall image; motion is vertical."				corner <= 2 ifTrue:					["motion is downward"					delta _ 0@1.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [0@maskForm height]						ifFalse: [stepSize@maskForm height])]					ifFalse:					["motion is upward"					delta _ 0@-1.					maskLoc _ bb bottomLeft - (corner = 3						ifTrue: [stepSize@0]						ifFalse: [0@0])]].	"Build a solid triangle in the mask form"	(Pen newOnForm: maskForm) do: [:p |		corner even  "Draw 45-degree line"			ifTrue: [p place: 0@0; turn: 135; go: maskForm width*3//2]			ifFalse: [p place: 0@(maskForm height-1); turn: 45; go: maskForm width*3//2]].	maskForm smear: delta negated distance: maskForm width.	"Copy the mask to full resolution for speed.  Make it be the reversed	so that it can be used for ORing in the page-corner color"	maskForm _ (Form extent: maskForm extent depth: otherImage depth)		copyBits: maskForm boundingBox from: maskForm at: 0@0		colorMap: (Bitmap with: 16rFFFFFFFF with: 0).	"Now move the triangle maskForm across the resultForm selecting the	triangular part of otherImage to display, and across the resultForm,	selecting the part of the original image to erase."	cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: corner.	1 to: (otherImage width + otherImage height // stepSize)+1 do:		[:i |		"Determine the affected square"		maskRect _ (maskLoc extent: maskForm extent) intersect: bb.		((maskLoc x*delta x) + (maskLoc y*delta y)) < 0 ifTrue:			[smallRect _ 0@0 extent: (maskRect width min: maskRect height) asPoint.			maskRect _ smallRect align: (smallRect perform: cornerSel)								with: (maskRect perform: cornerSel)].		"AND otherForm with triangle mask, and OR into result"		resultForm copyBits: bb from: otherImage at: 0@0				clippingBox: maskRect rule: Form over fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form erase fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form under fillColor: Color lightBrown.		"Now update Display in a single BLT."		self copyBits: maskRect from: resultForm at: topLeft + maskRect topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Smalltalk forceDisplayUpdate.		maskLoc _ maskLoc + (delta*stepSize)]"1 to: 4 do: [:corner | Display pageImage:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 corner: corner]"! !!Form methodsFor: 'transitions' stamp: 'jj 10/20/97 15:55'!pageWarp: otherImage at: topLeft forward: forward	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.	forward == true means turn pages toward you, else away. [ignored for now]"	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |	pageRect _ otherImage boundingBox.	oldPage _ self copy: (pageRect translateBy: topLeft).	(forward ifTrue: [oldPage] ifFalse: [otherImage])		border: pageRect		widthRectangle: (Rectangle				left: 0				right: 2				top: 1				bottom: 1)		rule: Form over		fillColor: Color black.	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).	nSteps _ 8.	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.	1 to: nSteps-1 do:		[:i | forward			ifTrue: [buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.					p _ pageRect topRight + (d * i // nSteps)]			ifFalse: [buffer copy: pageRect from: oldPage to: 0@0 rule: Form over.					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).		sourceQuad _ Array with: pageRect topLeft			with: pageRect bottomLeft + (0@p y)			with: pageRect bottomRight			with: pageRect topRight - (0@p y).		warp _ (WarpBlt toForm: buffer)				clipRect: leafRect;				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);				combinationRule: Form paint.		warp copyQuad: sourceQuad toRect: leafRect.		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.		Smalltalk forceDisplayUpdate].	buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.	Smalltalk forceDisplayUpdate."1 to: 4 do: [:corner | Display pageWarp:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 forward: false]"! !!Form methodsFor: 'transitions' stamp: 'jj 10/20/97 15:57'!slideImage: otherImage at: topLeft delta: delta	"Display slideImage: (Form fromDisplay: (40@40 extent: 300@300)) reverse		at: 40@40 delta: 3@-4"	| bb nSteps clipRect |	bb _ otherImage boundingBox.	clipRect _ topLeft extent: otherImage extent.	nSteps _ 1.	delta x = 0 ifFalse: [nSteps _ nSteps max: (bb width//delta x abs) + 1].	delta y = 0 ifFalse: [nSteps _ nSteps max: (bb height//delta y abs) + 1].	1 to: nSteps do:			[:i | self copyBits: bb from: otherImage				at: delta*(i-nSteps) + topLeft				clippingBox: clipRect rule: Form over fillColor: nil.			Smalltalk forceDisplayUpdate]! !!Form methodsFor: 'transitions' stamp: 'jj 10/20/97 16:14'!wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex: rectForIndexBlock	| index thisRect clipRect |	index _ 0.	clipRect _ topLeft extent: otherImage extent.	clipBox ifNotNil: [clipRect _ clipRect intersect: clipBox].	[(thisRect _ rectForIndexBlock value: (index _ index+1)) == nil]	whileFalse:		[thisRect do:			[:r | self copyBits: r from: otherImage at: topLeft + r topLeft				clippingBox: clipRect rule: Form over fillColor: nil.			Smalltalk forceDisplayUpdate]].! !!Form methodsFor: 'transitions' stamp: 'jm 10/16/97 15:21'!wipeImage: otherImage at: topLeft delta: delta	"Display wipeImage: (Form fromDisplay: (40@40 extent: 300@300)) reverse		at: 40@40 delta: 0@-2"	self wipeImage: otherImage at: topLeft delta: delta clippingBox: nil.! !!Form methodsFor: 'transitions' stamp: 'jm 10/16/97 15:17'!wipeImage: otherImage at: topLeft delta: delta clippingBox: clipBox	| wipeRect bb nSteps |	bb _ otherImage boundingBox.	wipeRect _ delta x = 0		ifTrue:		[delta y = 0 ifTrue: [nSteps _ 1. bb "allow 0@0"] ifFalse: [		nSteps _ bb height//delta y abs + 1.  "Vertical movement"		delta y > 0			ifTrue: [bb topLeft extent: bb width@delta y]			ifFalse: [bb bottomLeft+delta extent: bb width@delta y negated]]]		ifFalse:		[nSteps _ bb width//delta x abs + 1.  "Horizontal movement"		delta x > 0			ifTrue: [bb topLeft extent: delta x@bb height]			ifFalse: [bb topRight+delta extent: delta x negated@bb height]].	^ self wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex:		[:i | i <= nSteps			ifTrue: [wipeRect translateBy: (delta* (i-1))]			ifFalse: [nil]]! !!Form methodsFor: 'transitions' stamp: 'jm 10/16/97 15:20'!zoomInTo: otherImage at: topLeft	"Display zoomInTo: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	^ self wipeImage: otherImage at: topLeft clippingBox: nil rectForIndex:		[:i | i <= 16			ifTrue: [otherImage center - (otherImage extent*i//32)						extent: otherImage extent*i//16]			ifFalse: [nil]]! !!Form methodsFor: 'transitions' stamp: 'jm 10/16/97 15:20'!zoomOutTo: otherImage at: topLeft	"Display zoomOutTo: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	^ self wipeImage: otherImage at: topLeft clippingBox: nil rectForIndex:		[:i | i <= 16			ifTrue: [(otherImage center - (otherImage extent*(17-i)//32)						extent: otherImage extent*(17-i)//16)					areasOutside:					(otherImage center - (otherImage extent*(16-i)//32)						extent: otherImage extent*(16-i)//16)]			ifFalse: [nil]]! !!Form class methodsFor: 'instance creation' stamp: 'di 1/14/98 23:56'!dotOfSize: diameter	"Create a form which contains a round black dot."	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |	radius _ diameter//2.	form _ self extent: diameter@diameter offset: (0@0) - (radius@radius).		bb _ (BitBlt toForm: form)		sourceX: 0; sourceY: 0;		combinationRule: Form over;		fillColor: Color black.	rect _ form boundingBox.	centerX _ rect center x.	centerY _ rect center y.	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.	xOverY _ rect width asFloat / rect height asFloat.	maxy _ rect height - 1 // 2.	"First do the inner fill, and collect x values"	0 to: maxy do:		[:dy |		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.		bb	destX: centerX - centerXBias - dx			destY: centerY - centerYBias - dy			width: dx + dx + centerXBias + 1			height: 1;			copyBits.		bb	destY: centerY + dy;			copyBits].	^ form"Time millisecondsToRun:	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]"!]style[(19 836 7 26 11 26 11 25 18 153)f1b,f1,f1b,f1,f1b,f1,f1b,f1,f1b,f1! !!Form class methodsFor: 'instance creation' stamp: 'jm 9/18/97 23:13'!extent: extentPoint depth: bitsPerPixel fromArray: anArray offset: offsetPoint 	"Answer an instance of me with a pixmap of the given depth initialized from anArray."	^ (self basicNew setExtent: extentPoint depth: bitsPerPixel)		offset: offsetPoint;		initFromArray: anArray! !!Form class methodsFor: 'instance creation' stamp: 'di 9/19/97 16:48'!fromBMPFileNamed: fileName	"Form fromBMPFileNamed: 'FulS.bmp'"	| f bfType bfSize bfReserved bfOffBits biSize biWidth biHeight	  biPlanes biBitCount biCompression form pixelLine pixIndex rgb rowBytes line data |	f _ (FileStream oldFileNamed: fileName) binary.	bfType _ f nextLitteEndianNumber: 2.	bfSize _ f nextLitteEndianNumber: 4.	bfReserved _ f nextLitteEndianNumber: 4.	bfOffBits _ f nextLitteEndianNumber: 4.	biSize _ f nextLitteEndianNumber: 4.	biWidth _ f nextLitteEndianNumber: 4.	biHeight _ f nextLitteEndianNumber: 4.	biPlanes _ f nextLitteEndianNumber: 2.	biBitCount _ f nextLitteEndianNumber: 2.	biCompression _ f nextLitteEndianNumber: 4.	f nextLitteEndianNumber: 4.  "biSizeImage"	f nextLitteEndianNumber: 4.  "biXPelsPerMeter"	f nextLitteEndianNumber: 4.  "biYPelsPerMeter"	f nextLitteEndianNumber: 4.  "biClrUsed"	f nextLitteEndianNumber: 4.  "biClrImportant"	((bfType = 19778) & (bfReserved = 0) & (biPlanes = 1) &	 (biSize = 40) & (bfSize <= f size))		ifFalse: [self error: 'Bad BMP file header'].	biCompression = 0		ifFalse: [self error: 'Can currently only read uncompressed BMP files'].	f position: bfOffBits.  "Skip past any color map to the image data"	form _ Form extent: biWidth@biHeight				depth: (biBitCount = 24 ifTrue: [32] ifFalse: [biBitCount]).	rowBytes _ (biBitCount * biWidth + 31 // 32) * 4.	line _ Form extent: biWidth@1 depth: form depth.	data _ line bits.	1 to: biHeight do: [:i |		biBitCount = 24		ifTrue: [pixelLine _ f next: rowBytes.				pixIndex _ 1.				1 to: biWidth do: [:j |					rgb _ (pixelLine at: pixIndex) +						   ((pixelLine at: pixIndex + 1) bitShift: 8) +						   ((pixelLine at: pixIndex + 2) bitShift: 16).					line bits at: j put: rgb.					pixIndex _ pixIndex + 3]]		ifFalse: [f nextInto: data. self halt].		form copy: line boundingBox from: line to: 0@(biHeight-i) rule: Form over].	f close.	^ form! !!Form class methodsFor: 'instance creation' stamp: 'tk 7/16/97 11:49'!fromBMPFileNamed: fileName depth: newDepth	"Reduce the depth from 24 bits if the user wants to.	Form fromBMPFileNamed: 'FulS.bmp' depth: 16"	| pic24Bit picNewBit |	pic24Bit _ self fromBMPFileNamed: fileName.	picNewBit _ Form extent: pic24Bit extent depth: newDepth.	pic24Bit displayOn: picNewBit.	"pic24Bit will get recycled as soon as we return from this method"	^ picNewBit! !!Form class methodsFor: 'instance creation' stamp: 'jm 11/12/97 19:33'!fromFileNamed: fileName	"Read a Form or ColorForm from given file, using the first byte of the file to guess its format. If the desired depth is not nil, convert the resulting Form to the given depth. Currently handles three file formats: GIF, uncompressed BMP, and DisplayObject storeOn:. Return nil if the file could not be read or was of an unknown format."	| f firstByte gifReader |	f _ FileStream readOnlyFileNamed: fileName.	firstByte _ f next.	f close.	firstByte = $G		ifTrue: [			gifReader _ Smalltalk gifReaderClass.			gifReader ifNil:				[^ self inform:					'Sorry, there is no GIF reader available in the current system'].			^ gifReader formFromFileNamed: fileName].	firstByte = $B		ifTrue: [^ self fromBMPFileNamed: fileName].	firstByte asciiValue = 2		ifTrue: [^ self newFromFileNamed: fileName].	^ nil  "unknown format"! !!Form class methodsFor: 'instance creation' stamp: 'jm 12/5/97 19:32'!fromUserWithExtent: anExtent	"Answer an instance of me with bitmap initialized from the area of the 	display screen whose origin is designated by the user and whose size is anExtent"	^ self fromDisplay: (Rectangle originFromUser: anExtent)"(Form fromUserWithExtent: 50@50) displayAt: 10@10"! !!Form class methodsFor: 'mode constants'!erase1bitShape	"Answer the integer denoting mode erase."	^ 26! !!Form class methodsFor: 'mode constants'!oldErase1bitShape	"Answer the integer denoting mode erase."	^ 17! !!Form class methodsFor: 'mode constants'!oldPaint	"Answer the integer denoting the 'paint' combination rule."	^16! !!Form class methodsFor: 'mode constants'!paint	"Answer the integer denoting the 'paint' combination rule."	^25! !!Form class methodsFor: 'examples' stamp: 'jm 8/1/97 11:41'!toothpaste: diam		"Display restoreAfter: [Form toothpaste: 30]"	"Draws wormlike lines by laying down images of spheres.	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.	Draw with mouse button down; terminate by option-click."	| facade ball filter point queue port color q colors colr colr2 |	colors _ Display depth = 1		ifTrue: [Array with: Color black]		ifFalse: [Color red wheel: 12].	facade _ Form extent: diam@diam offset: (diam//-2) asPoint.	(Form dotOfSize: diam) displayOn: facade			at: (diam//2) asPoint clippingBox: facade boundingBox			rule: Form under fillColor: Color white.	#(1 2 3) do:		[:x |  "simulate facade by circles of gray"		(Form dotOfSize: x*diam//5) displayOn: facade			at: (diam*2//5) asPoint clippingBox: facade boundingBox			rule: Form under			fillColor: (Color perform: 					(#(black gray lightGray) at: x)).		"facade displayAt: 50*x@50"].	ball _ Form dotOfSize: diam.	color _ 8.	[ true ] whileTrue:		[port _ BitBlt toForm: Display.		"Expand 1-bit forms to any pixel depth"		port colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		queue _ OrderedCollection new: 32.		16 timesRepeat: [queue addLast: -20@-20].		Sensor waitButton.		Sensor yellowButtonPressed ifTrue: [^ self].		filter _ Sensor cursorPoint.		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"		colr2 _ colr mixed: 0.3 with: Color white.		[Sensor redButtonPressed or: [queue size > 0]] whileTrue:			[filter _ filter * 4 + Sensor cursorPoint // 5.			point _ Sensor redButtonPressed				ifTrue: [filter] ifFalse: [-20@-20].			port copyForm: ball to: point rule: Form paint fillColor: colr.			(q _ queue removeFirst) == nil ifTrue: [^ self].	"exit"			Display depth = 1				ifTrue: [port copyForm: facade to: q rule: Form erase]				ifFalse: [port copyForm: facade to: q rule: Form paint fillColor: colr2].			Sensor redButtonPressed ifTrue: [queue addLast: point]]].! !!FormCanvas methodsFor: 'copying' stamp: 'jm 8/2/97 14:00'!copy	"Make a copy the receiver on the same underlying Form but with its own grafPort."	^ self clone resetGrafPort! !!FormCanvas methodsFor: 'accessing'!depth	^ form depth! !!FormCanvas methodsFor: 'accessing'!extent	^ form extent! !!FormCanvas methodsFor: 'accessing'!form	^ form! !!FormCanvas methodsFor: 'drawing' stamp: 'sw 11/3/97 00:39'!fillColor: c	"Note: This always fills, even if the color is transparent."	port combinationRule: Form over.	port fillRect: form boundingBox color: (self drawColor: c) offset: origin.! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 8/2/97 13:54'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	| rect fillC borderC |	rect _ r.	c isTransparent		ifTrue: [fillC _ nil]		ifFalse: [fillC _ self drawColor: c].	borderColor isTransparent		ifTrue: [			fillC == nil ifTrue: [^ self].  "both border and fill are transparent"			borderC _ nil.			rect _ rect insetBy: borderWidth]		ifFalse: [borderC _ self drawColor: borderColor].	port combinationRule: (self drawRule: Form over).	port fillOval: (rect translateBy: origin)		color: fillC		borderWidth: borderWidth		borderColor: borderC.! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 11/2/97 16:34'!fillRectangle: r color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over).		port fillRect: (r translateBy: origin) color: (self drawColor: c) offset: origin].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 11/2/97 16:35'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	| outerRect |	port combinationRule: (self drawRule: Form over).	outerRect _ r translateBy: origin.	borderColor isTransparent ifFalse: [		"draw border of rectangle"		(r area > 10000 or: [fillColor isTransparent]) ifTrue: [			port frameRect: outerRect				borderWidth: borderWidth				borderColor: (self drawColor: borderColor).		] ifFalse: [			"for small rectangles, it's faster to paint the whole outerRect			 than to compute and fill the border rects"			port fillRect: outerRect color: (self drawColor: borderColor) offset: origin]].	"fill inside of rectangle"	fillColor isTransparent ifFalse: [		port fillRect: (outerRect insetBy: borderWidth)			 color: (self drawColor: fillColor)			 offset: origin].! !!FormCanvas methodsFor: 'drawing'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	| rect |	"First use quick code for fill and top, left borders"	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now use slow code for bevelled bottom, right borders"	borderWidth isInteger		ifTrue: [port width: borderWidth; height: borderWidth]		ifFalse: [port width: borderWidth x; height: borderWidth y].	rect _ r translateBy: origin.	bottomRightColor isTransparent ifFalse: [		port fillColor: (self drawColor: bottomRightColor);			frameRectRight: rect;			frameRectBottom: rect].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 7/24/97 15:04'!frameRectangle: r width: w color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over).		port frameRect: (r translateBy: origin)			borderWidth: w			borderColor: (self drawColor: c)].! !!FormCanvas methodsFor: 'drawing'!image: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form following the convention that zero is the transparent pixel value."	| bb |	bb _ BitBlt destForm: port destForm		sourceForm: aForm		fillColor: nil		combinationRule: Form paint		destOrigin: aPoint + origin		sourceOrigin: 0@0		extent: aForm extent		clipRect: clipRect truncated.	shadowDrawing ifTrue: [		bb colorMap: (Color maskingMap: aForm depth).		bb fillColor: shadowStipple.	] ifFalse: [		bb colorMap:			(aForm colormapIfNeededForDepth: bb destForm depth)].	bb copyBits.! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 8/2/97 13:54'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	| bb |	bb _ BitBlt destForm: port destForm		sourceForm: aForm		fillColor: nil		combinationRule: rule		destOrigin: aPoint + origin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: clipRect truncated.	shadowDrawing ifTrue: [		bb colorMap: (Color maskingMap: aForm depth).		bb fillColor: shadowStipple.	] ifFalse: [		bb colorMap:			(aForm colormapIfNeededForDepth: bb destForm depth)].	bb copyBits.! !!FormCanvas methodsFor: 'drawing' stamp: 'di 12/3/97 15:29'!line: pt1 to: pt2 brushForm: brush	| offset |	offset _ origin.	port sourceForm: brush; fillColor: nil;		combinationRule: (self drawRule: Form paint);		sourceRect: brush boundingBox;		colorMap: (brush colormapIfNeededForDepth: self depth);		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'di 11/29/97 14:33'!line: pt1 to: pt2 width: w color: c	| offset |	offset _ origin - (w // 2) asPoint.	port sourceForm: nil;		fillColor: (self drawColor: c);		combinationRule: (self drawRule: Form over);		width: w; height: w;		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'di 11/26/97 21:51'!newParagraph: para bounds: bounds color: c	| scanner |	scanner _ port displayScannerFor: para		foreground: (self drawColor: c)		background: Color transparent		rule: (self drawRule: Form paint)		halftone: (shadowDrawing ifTrue: [self drawColor: c] ifFalse: [nil]).	para displayOn: self using: scanner at: (bounds topLeft + origin)! !!FormCanvas methodsFor: 'drawing'!paragraph: para bounds: bounds color: c	| paraCopy |	paraCopy _ para copy.  "Because displayOn:at: bashes a para's rectangles"	paraCopy		foregroundColor: (shadowDrawing ifTrue: [Color black] ifFalse: [c])		backgroundColor: Color transparent.	paraCopy displayOn: form		at: (bounds topLeft + origin)		clippingBox: (clipRect intersect: (bounds translateBy: origin))		rule: (self drawRule: Form paint)		fillColor: (shadowDrawing					ifTrue: [self drawColor: c]					ifFalse: [nil])! !!FormCanvas methodsFor: 'drawing'!point: pt color: c	form colorAt: (pt + origin) put: c.! !!FormCanvas methodsFor: 'drawing' stamp: 'di 11/3/97 14:36'!text: s bounds: boundsRect font: fontOrNil color: c	| scanner |	scanner _ QuickPrint newOn: form				box: ((boundsRect translateBy: origin) intersect: clipRect) truncated				font: fontOrNil				color: (shadowDrawing ifTrue: [shadowStipple] ifFalse: [c]).	scanner drawString: s at: boundsRect topLeft + origin! !!FormCanvas methodsFor: 'other'!showAt: pt	^ form displayAt: pt! !!FormCanvas methodsFor: 'other'!showAt: pt invalidRects: updateRects	| blt |	blt _ (BitBlt toForm: Display)		sourceForm: form;		combinationRule: Form over.	updateRects do:		[:rect |		blt sourceRect: rect;			destOrigin: rect topLeft + pt;			copyBits]! !!FormCanvas methodsFor: 'other'!warpFrom: sourceQuad toRect: destRect	^ (WarpBlt toForm: port destForm)		combinationRule: Form paint;		sourceQuad: sourceQuad destRect: (destRect translateBy: origin);		clipRect: clipRect! !!FormCanvas methodsFor: 'private'!drawColor: aColor	^ shadowDrawing		ifTrue: [shadowStipple]		ifFalse: [aColor]! !!FormCanvas methodsFor: 'private'!drawRule: normalRule	^ shadowDrawing ifTrue: [Form paint] ifFalse: [normalRule]! !!FormCanvas methodsFor: 'private' stamp: 'jm 8/2/97 13:54'!resetGrafPort	"Private!! Create a new grafPort for a new copy."	port _ GrafPort toForm: form.	port clipRect: clipRect.! !!FormCanvas methodsFor: 'private'!setForm: aForm	| screen blackWord |	self reset.	form _ aForm.	port _ GrafPort toForm: form.	shadowDrawing _ false.	"Build a 50% stipple of black for the given depth."	screen _ Color pixelScreenForDepth: form depth.	blackWord _ Color black pixelWordForDepth: form depth.	shadowStipple _		(screen collect: [:maskWord | maskWord bitAnd: blackWord]).! !!FormCanvas methodsFor: 'private'!setOrigin: aPoint clipRect: aRectangle	super setOrigin: aPoint clipRect: aRectangle.	port clipRect: aRectangle! !!FormCanvas methodsFor: 'private' stamp: 'di 10/27/97 09:13'!stipple: newStipple	shadowStipple _ newStipple! !!FormCanvas class methodsFor: 'instance creation'!extent: aPoint	^ self extent: aPoint depth: Display depth! !!FormCanvas class methodsFor: 'instance creation'!extent: extent depth: depth	^ self new setForm: (Form extent: extent depth: depth)! !!FormCanvas class methodsFor: 'instance creation' stamp: 'jm 8/2/97 13:54'!on: aForm	^ self new setForm: aForm! !!FormCanvas class methodsFor: 'testing'!test	"FormCanvas test"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: (Color white).	canvas line: 10@10 to: 50@30 width: 1 color: (Color black).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color gray).	canvas point: 90@90 color: (Color black).	canvas text: 'Hello, Roxie' at: 40@40 font: nil color: (Color black).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color lightGray).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color black).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightGray).	canvas showAt: 0@0.! !!FormCanvas class methodsFor: 'testing'!test1	"FormCanvas test1"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: (Color black).	canvas line: 10@10 to: 50@30 width: 1 color: (Color red).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color green).	canvas point: 90@90 color: (Color black).	canvas text: 'Hello, Roxie' at: 40@40 font: nil color: (Color cyan).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color magenta).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color cyan).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightYellow).	canvas showAt: 0@0.! !!FormCanvas class methodsFor: 'testing'!test2	"FormCanvas test2"	| baseCanvas p canvas |	baseCanvas _ FormCanvas extent: 200@200.	p _ Sensor cursorPoint.	[Sensor anyButtonPressed] whileFalse: [		canvas _ baseCanvas copyOffset: (Sensor cursorPoint - p).		canvas fillColor: (Color white).		canvas line: 10@10 to: 50@30 width: 1 color: (Color black).		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color gray).		canvas point: 90@90 color: (Color black).		canvas text: 'Hello, Roxie' at: 40@40 font: nil color: (Color black).		canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color lightGray).		canvas fillOval: ((10@80) corner: (31@121)) color: (Color black).		canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightGray).		canvas showAt: 0@0.	].! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 8/2/97 14:12'!test3	"FormCanvas test3"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillOval: ((10@80) corner: (31@121)) color: (Color cyan).	canvas frameOval: ((40@80) corner: (61@121)) color: (Color blue).	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: (Color red).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightYellow).	canvas showAt: 0@0.! !!FormCanvas class methodsFor: 'testing'!test4	"Time millisecondsToRun: [FormCanvas test4] 1134"	"3762 mSecs -- ParcPlace Smalltalk on Duo 230"	| baseCanvas p canvas |	baseCanvas _ FormCanvas extent: 200@200.	p _ Sensor cursorPoint.	100 timesRepeat: [		canvas _ baseCanvas copyOffset: (Sensor cursorPoint - p).		canvas fillColor: (Color white).		canvas line: 10@10 to: 50@30 width: 1 color: (Color black).		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color gray).		canvas point: 90@90 color: (Color black).		canvas text: 'Hello, Roxie' at: 40@40 font: nil color: (Color black).		canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color lightGray).		canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color black).		canvas showAt: 0@0.	].! !!FormCanvas class methodsFor: 'testing'!test5	"FormCanvas test5"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: (Color yellow).	canvas _ canvas copyForShadowDrawingOffset: 10@10.	canvas line: 10@10 to: 50@30 width: 1 color: (Color blue).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color red).	canvas point: 90@90 color: (Color red).	canvas text: 'Hello, Roxie' at: 40@40 font: nil color: (Color red).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color red).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color red).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color red).	canvas showAt: 0@0.! !!FormEditor methodsFor: 'editing tools'!changeGridding	"Allow the user to change the values of the horizontal and/or vertical 	grid modules. Does not change the primary tool."	| response gridInteger gridX gridY |	gridX _ togglegrid x.	gridY _ togglegrid y.	response _ 		self promptRequest: 'Current horizontal gridding is: ' 						, gridX printString 						, '.Type new horizontal gridding.'.	response isEmpty		ifFalse: 			[gridInteger _ Integer readFromString: response.			gridX _ ((gridInteger max: 1) min: Display extent x)].	response _ 		self promptRequest: 'Current vertical gridding is: ' 						, gridY printString 						, '.Type new vertical gridding.'.	response isEmpty		ifFalse: 			[gridInteger _ Integer readFromString: response.			gridY _ ((gridInteger max: 1) min: Display extent y)].	xgridOn ifTrue: [grid _ gridX @ grid y].	ygridOn ifTrue: [grid _ grid x @ gridY].	togglegrid _ gridX @ gridY.	tool _ previousTool! !!FormEditor methodsFor: 'editing tools'!colorGray	"Set the color to gray. Leaves the tool set in its previous state."	self setColor: Color gray.! !!FormEditor methodsFor: 'editing tools'!colorWhite	"Set the color to white. Leaves the tool set in its previous state."	self setColor: Color white! !!FormEditor methodsFor: 'editing tools' stamp: '6/9/97 10:15 di'!curve	"Conic-section specified by three points designated by: first point--press 	red button second point--release red button third point--click red button. 	The resultant curve on the display is displayed according to the current 	form and mode."	| firstPoint secondPoint thirdPoint curve |	"sensor noButtonPressed ifTrue: [^self]."	firstPoint _ self cursorPoint.	form		displayOn: Display		at: firstPoint		clippingBox: view insetDisplayBox		rule: (Display depth > 1 ifTrue: [Form paint]										ifFalse: [mode])		fillColor: color.	secondPoint _ self trackFormUntil: [sensor noButtonPressed].	form		displayOn: Display		at: secondPoint		clippingBox: view insetDisplayBox		rule: Form reverse		fillColor: color.	thirdPoint _ self trackFormUntil: [sensor redButtonPressed]..	form		displayOn: Display		at: thirdPoint		clippingBox: view insetDisplayBox		rule: (Display depth > 1 ifTrue: [Form paint]										ifFalse: [mode])		fillColor: color.	form		displayOn: Display		at: secondPoint		clippingBox: view insetDisplayBox		rule: Form reverse		fillColor: color.	curve _ CurveFitter new.	curve firstPoint: firstPoint.	curve secondPoint: secondPoint.	curve thirdPoint: thirdPoint.	curve form: form.	curve		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: (Display depth > 1 ifTrue: [Form paint]										ifFalse: [mode])		fillColor: color.	sensor waitNoButton! !!FormEditor methodsFor: 'editing tools'!fileInForm	"Ask the user for a file name and then recalls the Form in that file as 	the current source Form (form). Does not change the tool."	| fileName file |	fileName _ self promptRequest: 'type a name for recalling a source Form . . . '.	file _ FileStream oldFileNamed: fileName.	file binary.	form _ Form new readFrom: file.	file close.	tool _ previousTool.! !!FormEditor methodsFor: 'editing tools'!fileOutForm	"Ask the user for a file name and then save the current source form 	(form) under that name. Does not change the tool."	| fileName file |	fileName _ self promptRequest: 'type a name for saving the source Form . . . '.	file _ FileStream newFileNamed: fileName.	file binary.	form writeOn: file.	file close.	tool _ previousTool.! !!FormEditor methodsFor: 'editing tools'!newSourceForm	"Allow the user to define a new source form for the FormEditor. Copying 	the source form onto the display is the primary graphical operation. 	Resets the tool to be repeatCopy."	| dForm interiorPoint interiorColor |	dForm _ Form fromUser: grid.	"sourceForm must be only 1 bit deep"	interiorPoint _ dForm extent // 2.	interiorColor _ dForm colorAt: interiorPoint.	form _ (dForm makeBWForm: interiorColor) reverse				findShapeAroundSeedBlock:					[:f | f pixelValueAt: interiorPoint put: 1].	form _ form trimToPixelValue: 1 orNot: false.	tool _ previousTool! !!FormEditor methodsFor: 'editing tools'!repeatCopy	"As long as the red button is pressed, copy the source form onto the 	display screen."	[sensor redButtonPressed]		whileTrue: 		[(BitBlt destForm: Display sourceForm: form halftoneForm: color			combinationRule: (Display depth > 1 ifTrue: [Form paint]										ifFalse: [mode])			destOrigin: self cursorPoint sourceOrigin: 0@0 extent: form extent			clipRect: view insetDisplayBox)			colorMap: (Bitmap with: 0 with: 16rFFFFFFFF);			copyBits]! !!FormEditor methodsFor: 'editing tools'!togglexGridding	"Turn x (horizontal) gridding off, if it is on, and turns it on, if it is off. 	Does not change the primary tool."	xgridOn		ifTrue: 			[grid _ 1 @ grid y.			xgridOn _ false]		ifFalse: 			[grid _ togglegrid x @ grid y.			xgridOn _ true].	tool _ previousTool! !!FormEditor methodsFor: 'editing tools'!toggleyGridding	"Turn y (vertical) gridding off, if it is on, and turns it on, if it is off. 	Does not change the primary tool."	ygridOn		ifTrue: 			[grid _ grid x @ 1.			ygridOn _ false]		ifFalse: 			[grid _ grid x @ togglegrid y.			ygridOn _ true].	tool _ previousTool! !!FormEditor methodsFor: 'menu messages'!edit	model edit! !!FormEditor methodsFor: 'private' stamp: 'jm 12/4/97 10:22'!normalizeColor: aColor	color _ aColor.! !!FormEditor methodsFor: 'private'!promptRequest: outputMessage 	"Answers with a string typed by the user on the keyboard. keyboard	input is terminated by a line feed character. Typing feedback happens	in a window that is at least 100 bits wide and 50 bits high."	FillInTheBlank		request: outputMessage		displayAt: view insetDisplayBox topCenter + (0@80)		centered: true		action: [:answer] 		initialAnswer: ''.	^answer! !!FormEditor methodsFor: 'private'!rubberBandFrom: startPoint until: aBlock	| endPoint previousEndPoint |	previousEndPoint _ startPoint.	[aBlock value] whileFalse:		[(endPoint _ self cursorPoint) = previousEndPoint 			ifFalse:			[(Line from: startPoint to: previousEndPoint withForm: form)				displayOn: Display				at: 0 @ 0				clippingBox: view insetDisplayBox				rule: Form reverse				fillColor: Color black.			(Line from: startPoint to: endPoint withForm: form)				displayOn: Display				at: 0 @ 0				clippingBox: view insetDisplayBox				rule: Form reverse				fillColor: Color black.			previousEndPoint  _ endPoint]].	(Line from: startPoint to: previousEndPoint withForm: form)		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: Form reverse		fillColor: Color black.	^endPoint! !!FormEditor methodsFor: 'private'!setVariables	tool _ #repeatCopy.	previousTool _ tool.	grid _ 1 @ 1.	togglegrid _ 8 @ 8.	xgridOn _ false.	ygridOn _ false.	mode _ Form over.	form _ Form extent: 8 @ 8.	form fillBlack.	unNormalizedColor _ color _ Color black.! !!FormEditor class methodsFor: 'class initialization'!initialize	FlashCursor _ false.	self setKeyboardMap.	YellowButtonMenu _ PopUpMenu labels: 'acceptcanceleditfile out' lines: #(2).	YellowButtonMessages _ #(accept cancel edit fileOut)	"FormEditor initialize"! !!FormEditor class methodsFor: 'private' stamp: 'di 1/16/98 15:46'!createFullScreenForm	"Create a StandardSystemView for a FormEditor on the form whole screen."	| formView formEditor menuView topView extent aForm |	aForm _ Form extent: (Display extent x @ (Display extent y - 112)) depth: Display depth.	formView _ FormHolderView new model: aForm.	formView borderWidthLeft: 0 right: 0 top: 0 bottom: 1.	formEditor _ formView controller.	menuView _ FormMenuView new makeFormEditorMenu model: formEditor.	formEditor model: menuView controller.	topView _ StandardSystemView new.	topView backgroundColor: #veryLightGray.	topView model: aForm.	topView addSubView: formView.	topView 		addSubView: menuView		align: menuView viewport topCenter		with: formView viewport bottomCenter + (0@16).	topView window: 		(formView viewport 			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))).	topView label: 'Form Editor'.	extent _ topView viewport extent.	topView minimumSize: extent.	topView maximumSize: extent.	^topView! !!FormEditor class methodsFor: 'private' stamp: 'di 1/16/98 15:47'!createOnForm: aForm	"Create a StandardSystemView for a FormEditor on the form aForm."	| formView formEditor menuView aView topView extent topViewBorder |	topViewBorder _ 2.	formView _ FormHolderView new model: aForm.	formEditor _ formView controller.	menuView _ FormMenuView new makeFormEditorMenu model: formEditor.	formEditor model: aForm.	aView _ View new.	aView model: aForm.	aView addSubView: formView.	aView 		addSubView: menuView		align: menuView viewport topCenter		with: formView viewport bottomCenter + (0@16).	aView window: 		((formView viewport 			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))) 		  expandBy: (0@topViewBorder corner: 0@0)).	aView window extent > formView viewport extent		ifTrue: [formView borderWidthLeft: 1 right: 1 top: 0 bottom: 1]		ifFalse: [formView borderWidthLeft: 0 right: 0 top: 0 bottom: 1].	topView _ StandardSystemView new.	topView backgroundColor: #veryLightGray.	topView addSubView: aView.	topView label: 'Form Editor'.	topView borderWidth: topViewBorder.	extent _ topView viewport extent.	topView minimumSize: extent.	topView maximumSize: extent.	^topView! !FormSetFont comment:'FormSetFonts are designed to capture individual images as character forms for imbedding in normal text.  While most often used to insert an isolated glyph in some text, the code is actually desinged to support an entire user-defined font.  The TextAttribute subclass TextFontReference is specifically designed for such in-line insertion of exceptional fonts in normal text.'!!FormSetFont methodsFor: 'all'!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width x badChar |	type _ 2.	name _ 'aFormFont'.	minAscii _ asciiStart.	maxAscii _ minAscii + formArray size - 1.	ascent _ ascentVal.	subscript _ superscript _ emphasis _ 0.	height _ width _ 0.	maxWidth _ 0.	formArray do:		[:f | width _ width + f width.		maxWidth _ maxWidth max: f width.		height _ height max: f height + f offset y].	badChar _ (Form extent: 7@height) borderWidth: 1.	width _ width + badChar width.	descent _ height - ascent.	pointSize _ height.	glyphs _ Form extent: width @ height depth: formArray first depth.	xTable _ Array new: maxAscii + 3 withAll: 0.	x _ 0.	formArray doWithIndex:		[:f :i | f displayOn: glyphs at: x@0.		xTable at: minAscii + i+1 put: (x _ x + f width)].	badChar displayOn: glyphs at: x@0.	xTable at: maxAscii + 3 put: x + badChar width.	self setStopConditions! !!FormSetFont methodsFor: 'all'!reset  "Ignored by FormSetFonts"! !!FormSetFont class methodsFor: 'examples'!copy: charForm toClipBoardAs: char ascent: ascent	ParagraphEditor new clipboardTextPut:		(Text string: char asString			attribute: (TextFontReference toFont: 				(FormSetFont new					fromFormArray: (Array with: charForm)					asciiStart: char asciiValue					ascent: ascent)))"	The S in the Squeak welcome window was installed by doing the following	in a workspace (where the value of, eg, charForm will persist through BitEdit...	f _ TextStyle default fontAt: 4.	oldS _ f characterFormAt: $S.	charForm _ Form extent: oldS extent depth: 8.	oldS displayOn: charForm.	charForm bitEdit.	...Play around with the BitEditor, then accept and close...	FormSetFont copy: charForm toClipBoardAs: $S ascent: f ascent.	...Then do a paste into the Welcome window"! !!FormSetFont class methodsFor: 'examples'!example    "FormSetFont example"	"Lets the user select a (small) area of the screen to represent the	character A, then copies 'A' to the clipboard with that as the letter form.	Thereafter, a paste operation will imbed that character in any text."	| charForm |	charForm _ Form fromUser.	self copy: charForm toClipBoardAs: $A ascent: charForm height! !!FormView methodsFor: 'displaying'!displayOn: aPort	model displayOnPort: aPort at: self displayBox origin! !!FormView methodsFor: 'displaying' stamp: 'hmm 7/21/97 20:45'!displayView 	"Refer to the comment in View|displayView."	| oldOffset |	super displayView.	insideColor == nil ifFalse: [Display fill: self insetDisplayBox fillColor: insideColor].	oldOffset _ model offset.	model offset: "borderWidth origin" 0@0.	model		displayOn: Display		transformation: self displayTransformation		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor.	model offset: oldOffset! !!FormView methodsFor: 'displaying'!updateDisplay	"overridden by subclass"! !!FormView class methodsFor: 'examples' stamp: 'di 1/16/98 15:47'!open: aForm named: aString	"FormView open: (GIFReadWriter imageFromFileNamed: 'TylerCrop.GIF')named: 'Squeak' "	"Answer a scheduled view whose model is aForm and whose label isaString. 12/11/96 tk"	| topView aView |	topView _ StandardSystemView new.	topView model: aForm.	topView label: aString.	topView minimumSize: 80@80.	aView _ FormView new.	aView model: aForm.	aView window: (0 @ 0 extent: aForm extent + (4@4)).		"compensate for borders.  Should be window:viewport:"	aView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	topView addSubView: aView.	topView controller open! !!Fraction methodsFor: 'arithmetic'!* aNumber	"Answer the result of multiplying the receiver by aNumber."	aNumber isFraction		ifTrue: [^ (Fraction numerator: numerator * aNumber numerator							denominator: denominator * aNumber denominator)						reduced]		ifFalse: [^ (aNumber adaptFraction: self) * aNumber adaptToFraction]! !!Fraction methodsFor: 'arithmetic'!+ aNumber	"Answer the sum of the receiver and aNumber."	| commonDenominator newNumerator |	aNumber isFraction		ifTrue: 			[denominator = aNumber denominator ifTrue: [				^ (Fraction 					numerator: numerator + aNumber numerator					denominator: denominator) reduced].			commonDenominator _ denominator lcm: aNumber denominator.			newNumerator _				(numerator * (commonDenominator / denominator)) +				(aNumber numerator * (commonDenominator / aNumber denominator)).			^ (Fraction 				numerator: newNumerator 				denominator: commonDenominator) reduced]		ifFalse: [^ (aNumber adaptFraction: self) + aNumber adaptToFraction]! !!Fraction methodsFor: 'arithmetic'!- aNumber	"Answer the difference between the receiver and aNumber."	aNumber isFraction		ifTrue: [^ self + aNumber negated]		ifFalse: [^ (aNumber adaptFraction: self) - aNumber adaptToFraction]! !!Fraction methodsFor: 'arithmetic'!/ aNumber	"Answer the result of dividing the receiver by aNumber."	aNumber isFraction		ifTrue: [^self * aNumber reciprocal]		ifFalse: [^ (aNumber adaptFraction: self) / aNumber adaptToFraction]! !!Fraction methodsFor: 'arithmetic'!negated 	"Refer to the comment in Number|negated."	^ Fraction		numerator: numerator negated		denominator: denominator! !!Fraction methodsFor: 'comparing'!< aNumber	aNumber isFraction		ifTrue: [aNumber numerator = 0				ifTrue: [^numerator < 0]				ifFalse: [^self - aNumber < 0]]		ifFalse: [^ (aNumber adaptFraction: self) < aNumber adaptToFraction]! !!Fraction methodsFor: 'comparing'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isFraction		ifTrue: [aNumber numerator = 0				ifTrue: [^numerator = 0]				ifFalse: [^aNumber numerator = numerator 							and: [aNumber denominator = denominator]]]		ifFalse: [^ (aNumber adaptFraction: self) = aNumber adaptToFraction]! !!Fraction methodsFor: 'converting'!adaptFloat: aFloat	"If I am involved in arithmetic with a Float, do not convert the Float."	^ aFloat! !!Fraction methodsFor: 'converting'!adaptInteger: anInteger	"If I am involved in arithmetic with an Integer, convert the Integer."	^ anInteger asFraction! !!Fraction methodsFor: 'converting'!adaptToFloat	"If I am involved in arithmetic with a Float, convert me to a Float."	^ self asFloat! !!Fraction methodsFor: 'converting'!adaptToInteger	"If I am involved in arithmetic with an Integer, do not convert me."	^ self! !!Fraction methodsFor: 'converting'!isFraction	^ true! !!Fraction methodsFor: 'printing'!printOn: aStream	aStream nextPut: $(.	numerator printOn: aStream.	aStream nextPut: $/.	denominator printOn: aStream.	aStream nextPut: $).! !!FrameRateMorph methodsFor: 'all'!initialize	super initialize.	lastDisplayTime _ 0.	framesSinceLastDisplay _ 0.! !!FrameRateMorph methodsFor: 'all'!step	| now mSecs mSecsPerFrame framesPerSec |	framesSinceLastDisplay _ framesSinceLastDisplay + 1.	now _ Time millisecondClockValue.	mSecs _ now - lastDisplayTime.	(mSecs > 500 or: [mSecs < 0 "clock wrap-around"]) ifTrue: [		mSecsPerFrame _ mSecs // framesSinceLastDisplay.		framesPerSec _ (framesSinceLastDisplay * 1000) // mSecs.		self contents: mSecsPerFrame printString, ' mSecs (', framesPerSec printString, ' frames/sec)'.		lastDisplayTime _ now.		framesSinceLastDisplay _ 0]! !!FrameRateMorph methodsFor: 'all'!stepTime	"Answer the desired time between steps in milliseconds."	^ 1! !A minimal FTP client program.  Could store all state in inst vars, and use an instance to represent the full state of a connection in progress.  But simpler to do all that in one method and have it be a complete transaction.Always operates in passive mode (PASV).  All connections are initiated from client in order to get through firewalls.See ServerDirectory openFTP, ServerDirectory getFileNamed:, ServerDirectory putFile:named: for examples of use.See TCP/IP, second edition, by Dr. Sidnie Feit, McGraw-Hill, 1997, Chapter 14, p311.!]style[(259 1 89 23 2 29 2 30 27 6 74)f1,f1-,f1,f1LServerDirectory openFTP;,f1,f1LServerDirectory getFileNamed:;,f1,f1LServerDirectory putFile:named:;,f1,f1b,f1!!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:13'!dataSocket	^ dataSocket! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:13'!dataSocket: dd	dataSocket _ dd! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 21:56'!getAllData	"Reel in all data until the server closes the connection.  Return a RWBinaryOrTextStream.  Don't know how much is coming."	| buf response bytesRead |	buf _ String new: 4000.	response _ RWBinaryOrTextStream on: (String new: 4000).	[(self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | response nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	response reset.	"position: 0."	^ response! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 12:20'!getAllDataWhileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Return a RWBinaryOrTextStream.  Don't know how much is coming."	| buf response bytesRead |	buf _ String new: 4000.	response _ RWBinaryOrTextStream on: (String new: 4000).	[(self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | response nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	response reset.	"position: 0."	^ response! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:12'!portNum	^ portNum! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:12'!portNum: anInteger	portNum _ anInteger! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 11:59'!responseCheck	"If data is waiting, do a responseOK to catch any error reports."	self dataAvailable ifTrue: [^ self responseOK].	^ true	"all OK so far"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 12:28'!responseError	"If data is waiting, Check it to catch any error reports.  Keep all responses in a queue for caller to examine later."	| all what |	self dataAvailable ifTrue: [		all _ self getResponseUpTo: CrLf.		readAhead ifNil: [readAhead _ OrderedCollection new].		readAhead addLast: (all at: 1).	"150 Opening binary mode data conn"		readAhead addAll: ((all at: 3) findBetweenSubStrs: (Array with: CrLf)).		readAhead do: [:resp |			((resp at: 1) == $5) | ((resp at: 1) == $4) ifTrue: [				what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 					startUpWithCaption: 'Server reported this error:\' withCRs, resp.				what = 2 ifTrue: [self halt].				self sendCommand: 'QUIT'.				readAhead _ nil.	"clear queue"				self responseOK.		"221"				self destroy.				^ true]]].	^ false	"all OK so far"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 11:54'!responseOK	"Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog and kill the socket.  Return true if OK, the error string if not."	| resp what all |	readAhead size > 0		ifTrue: [resp _ readAhead removeFirst]	"response already came in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.	"150 Opening binary mode data conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].	Transcript show: resp; cr.	((resp at: 1) == $5) | ((resp at: 1) == $4) ifFalse: [^ true].  "All is well"	what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 		startUpWithCaption: 'Server reported this error:\' withCRs, resp.	what = 2 ifTrue: [self halt].	self destroy.	^ resp! !!GeneralListController methodsFor: 'menu messages' stamp: 'sw 1/15/98 18:23'!shiftedYellowButtonMenu	^ (model respondsTo: #shiftedYellowButtonMenu)		ifTrue:			[model shiftedYellowButtonMenu]		ifFalse:			[super shiftedYellowButtonMenu]! !!GeneralListController methodsFor: 'menu messages' stamp: 'sw 1/15/98 18:24'!shiftedYellowButtonMessages	^ (model respondsTo: #shiftedYellowButtonMessages)		ifTrue:			[model shiftedYellowButtonMessages]		ifFalse:			[super shiftedYellowButtonMessages]! !GIFReadWriter comment:'Copyright (c) Kazuki Yasumatsu, 1995. All rights reserved.Used with permission.  Modified for use in Squeak.'!!GIFReadWriter class methodsFor: 'as yet unclassified' stamp: 'di 1/15/98 13:21'!putForm: ignored onFileNamed: fileName	"This dummy routine will do what Squeak Wiki expects, logically,	producing a GIF image of the text below, so at least it won't crash,	and the client will get some idea of what's up""The bytes below were produced by printing the following expression...	GIFReadWriter putForm: (' Sorry, but GIF conversion is    not currently available '		asText allBold asDisplayText form borderWidth: 1) as8BitColorForm  	onFileNamed: 'Sorry.gif'.(Base64MimeConverter mimeEncode: (ReadStream on: (FileStream fileNamed: 'Sorry.gif') contentsOfEntireFile)) contents"	(FileStream fileNamed: fileName)	nextPutAll: (Base64MimeConverter mimeDecodeToChars: (ReadStream on:'R0lGODdhrgAgAOcAAP///wAAAP///4CAgP8AAAD/AAAA/wD/////AP8A/yAgIEBAQGBgYJ+fn7+/v9/f3wgICBAQEBgYGCgoKDAwMDg4OEhISFBQUFhYWGhoaHBwcHh4eIeHh4+Pj5eXl6enp6+vr7e3t8fHx8/Pz9fX1+fn5+/v7/f39wAAAAAzAABmAACZAADMAAD/AAAAMwAzMwBmMwCZMwDMMwD/MwAAZgAzZgBmZgCZZgDMZgD/ZgAAmQAzmQBmmQCZmQDMmQD/mQAAzAAzzABmzACZzADMzAD/zAAA/wAz/wBm/wCZ/wDM/wD//zMAADMzADNmADOZADPMADP/ADMAMzMzMzNmMzOZMzPMMzP/MzMAZjMzZjNmZjOZZjPMZjP/ZjMAmTMzmTNmmTOZmTPMmTP/mTMAzDMzzDNmzDOZzDPMzDP/zDMA/zMz/zNm/zOZ/zPM/zP//2YAAGYzAGZmAGaZAGbMAGb/AGYAM2YzM2ZmM2aZM2bMM2b/M2YAZmYzZmZmZmaZZmbMZmb/ZmYAmWYzmWZmmWaZmWbMmWb/mWYAzGYzzGZmzGaZzGbMzGb/zGYA/2Yz/2Zm/2aZ/2bM/2b//5kAAJkzAJlmAJmZAJnMAJn/AJkAM5kzM5lmM5mZM5nMM5n/M5kAZpkzZplmZpmZZpnMZpn/ZpkAmZkzmZlmmZmZmZnMmZn/mZkAzJkzzJlmzJmZzJnMzJn/zJkA/5kz/5lm/5mZ/5nM/5n//8wAAMwzAMxmAMyZAMzMAMz/AMwAM8wzM8xmM8yZM8zMM8z/M8wAZswzZsxmZsyZZszMZsz/ZswAmcwzmcxmmcyZmczMmcz/mcwAzMwzzMxmzMyZzMzMzMz/zMwA/8wz/8xm/8yZ/8zM/8z///8AAP8zAP9mAP+ZAP/MAP//AP8AM/8zM/9mM/+ZM//MM///M/8AZv8zZv9mZv+ZZv/MZv//Zv8Amf8zmf9mmf+Zmf/Mmf//mf8AzP8zzP9mzP+ZzP/MzP//zP8A//8z//9m//+Z///M/////ywAAAAArgAgAAAI/gADCBxIsKDBgwgTKlzIsKHDhxAjSiQIoKLFixgzatzIsaPHjyBDihxJsiQAgSZTqlzJsqXLkihfypxJs6bNmDZz6tzJEyPOnkCDCjX58yRFnkVJHlU41GNSkU8t/owZVeZAkEmpBqio1WjTr1K3hvV51ejVhh2XojxbdixZrmI3llU796BZsQXvetV7N+5bvnDJ4h3McG/VwF0N+w389+hbumwZryVsN69Wilkn72X8ePDmz4A5dk2cWW/ijFM9n4as2a3X0Z5Rx74YVe3noo5Fq45dWjHnv5K3rq4LPLjv07Tj4vZ7eXdy2ViF72793Dfo57aR44Q9VjP366+l/leHW3dy8+JPc+f9TZ7yetmU+7ZNbT4+ZrYGBb9n7zI12P8A8tfSYQEWCBSBBiaoYEgILujgg+NBKOGEEVJo4YMNXqjhUBlu6CFSi30YXYg3SUfib20NeKJKHeaE3IEnpgheSh2+d1965pnVnon17dheePnptyN+yvE235E/0riikK1Rh514QC40pHWkhVglYtNhadx3LVaYlnPhQVeddkXeZ9xmuSV35Ha2KUZcmEHCtGRjUDrJ3pWuLXcmmzhy1uaVeHo3Z3RQgWmnlj36t6WRKMY4G5qMhnmcoYPKVal8PQq4ZqaO3bhenFWByhxa+UEWmlKXiqibqnJO5OqrCLDGKuusEwUEADs=')) contents;	close!]style[(38 397 15 2025)f1b,f1,f1b,f1! !GradientFillMorph class comment:'GradientFills cache an array of bitpatterns for the colors across their rectangle.  It costs a bit of space, but makes display fast enough to eschew the use of a bitmap.  The array must be recomputed whenever the colors, dimensions or display depth change.'!!GradientFillMorph methodsFor: 'initialize' stamp: 'di 11/13/97 15:20'!changed	super changed.	self releaseCachedState! !!GradientFillMorph methodsFor: 'initialize' stamp: 'di 1/9/98 22:17'!initialize	super initialize.	borderWidth _ 0.	fillColor2 _ Color black.	gradientDirection _ #vertical! !!GradientFillMorph methodsFor: 'drawing' stamp: 'di 1/9/98 22:23'!drawOn: aCanvas	"Note that this could run about 4 times faster if we got hold of	the canvas's port and just sent it copyBits with new coords and color" 	| r colors step |	super drawOn: aCanvas.	r _ self innerBounds intersect: aCanvas clipRect.	colors _ self colorArrayForDepth: aCanvas depth.	step _ self stepSize.	gradientDirection = #vertical		ifTrue:		[r top to: r bottom-1 by: step do:			[:y | aCanvas fillRectangle: (r left @ y corner: r right @ (y+step min: r bottom))					color: (colors at: y - bounds top //step+1)]]		ifFalse:		[r left to: r right-1 by: step do:			[:x | aCanvas fillRectangle: (x @ r top corner: (x+step min: r right) @ r bottom)					color: (colors at: x - bounds left //step+1)]]! !!GradientFillMorph methodsFor: 'menu' stamp: 'jm 11/5/97 12:41'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'gradient color' action: #setGradientColor:.	gradientDirection == #vertical		ifTrue: [aCustomMenu add: 'horizontal pan' action: #beHorizontal]		ifFalse: [aCustomMenu add: 'vertical pan' action: #beVertical].! !!GradientFillMorph methodsFor: 'menu' stamp: 'di 11/2/97 14:35'!beHorizontal	gradientDirection _ #horizontal.	self changed! !!GradientFillMorph methodsFor: 'menu' stamp: 'di 11/2/97 14:35'!beVertical	gradientDirection _ #vertical.	self changed! !!GradientFillMorph methodsFor: 'private' stamp: 'di 11/3/97 09:09'!colorArrayForDepth: d	| range mix step |	"We need to mix colors so as to minimize Mach bands (visible boundaries due to the fact that there is a sudden quantization change in one or more of the color components.  We use a 2x2 halftone as a simple solution.  On large areas, we only compute every fourth line for a factor of four in speed, and becuse it looks just as good.  The ideal way of doing this is by error propagation -- 1/2 the error to propagate back and forth across a word of pixels, and the other half to propagate down from one scan line to the next.  This will never be good enough with our 8-bit palette, and appears not to be needed in 16 bits."	(colorArray == nil or: [colorDepth ~= d]) ifTrue:		["ColorArray must be recomputed -- we cache the actual bitPatterns"		colorDepth _ d.		step _ self stepSize.		colorArray _ Array new: (gradientDirection = #vertical				ifTrue: [bounds height+(step-1)//step]				ifFalse: [bounds width+(step-1)//step]).		range _ (colorArray size - 1 max: 1) asFloat.		1 to: colorArray size do:			[:i | mix _ fillColor2 mixed: (i-1) / range with: color.			colorArray at: i put: (mix balancedPatternForDepth: colorDepth)]].	^ colorArray! !!GradientFillMorph methodsFor: 'private' stamp: 'di 11/13/97 15:23'!loadCachedState	"Prepare for fast response -- next page of a book?"	self colorArrayForDepth: Display depth "best guess"! !!GradientFillMorph methodsFor: 'private' stamp: 'di 11/13/97 15:21'!releaseCachedState	colorArray _ nil! !!GradientFillMorph methodsFor: 'private' stamp: 'di 11/3/97 09:01'!stepSize	| n |	n _ gradientDirection == # vertical ifTrue: [self height] ifFalse: [self width].	n < 100 ifTrue: [^ 1].	n < 200 ifTrue: [^ 2].	^ 4! !!GradientFillMorph methodsFor: 'all' stamp: 'jm 11/5/97 12:40'!gradientFillColor: aColor	fillColor2 _ aColor.	self changed.! !!GradientFillMorph methodsFor: 'all' stamp: 'jm 11/4/97 15:54'!setGradientColor: evt	evt hand changeColorTarget: self selector: #gradientFillColor:.! !!GrafPort methodsFor: 'all' stamp: 'di 10/12/97 12:14'!clippedBy: aRectangle	^ self copy clipRect: (self clipRect intersect: aRectangle)! !!GrafPort methodsFor: 'all' stamp: 'di 10/21/97 21:27'!displayScannerFor: para foreground: foreColor background: backColor		rule: rule halftone: halftone	^ (DisplayScanner new text: para text textStyle: para textStyle			foreground: foreColor background: backColor fillBlt: self)		setDestForm: destForm sourceForm: destForm			fillColor: halftone combinationRule: rule			destOrigin: 0@0 sourceOrigin: 0@0			extent: 0@0 clipRect: self clipRect! !!GrafPort methodsFor: 'all' stamp: 'di 11/8/97 12:07'!fillOval: rect color: fillColor borderWidth: borderWidth borderColor: borderColor	"Possible future optimizations:	 Compute an inset rectangle - if clipRect inside, then just paint with fillCOlor!!	 Note quadrants of clipRect, and only run code for those quadrants."	| wp fillTone w borderTone centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dxs dx prevLeft left |	rect area <= 0 ifTrue: [^ self].	wp _ borderWidth asPoint.	sourceForm _ nil. 	height _ 1.	fillColor == nil		ifTrue: [fillTone _ nil]		ifFalse: [self fillColor: fillColor.  fillTone _ halftoneForm].	(((w _ wp x) * wp y) = 0 or: [borderColor == nil])		ifTrue: [borderTone _ nil]		ifFalse: [self fillColor: borderColor.  borderTone _ halftoneForm].	centerX _ rect center x.	centerY _ rect center y.	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.	xOverY _ rect width asFloat / rect height asFloat.	maxy _ rect height - 1 // 2.	dxs _ Array new: maxy + 1.	"First do the inner fill, and collect x values"	0 to: maxy do:		[:dy |		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.		dxs at: dy+1 put: dx.		fillTone == nil ifFalse:			[halftoneForm _ fillTone.			height _ 1.			width _ dx + dx + centerXBias + 1.			destX _ centerX - centerXBias - dx.			destY _ centerY - centerYBias - dy.			self copyBits.			destY _ centerY + dy.			self copyBits]].	"Now do the border, using the same x values"	borderTone ifNil: [^ self].	prevLeft _ centerX.	maxy to: 0 by: -1 do: [:dy |		dx _ dxs at: dy+1.		halftoneForm _ borderTone.		height _ wp y.		left _ centerX - centerXBias - dx.		width _ prevLeft - left + w.		destX _ left.		destY _ centerY - centerYBias - dy.		self copyBits.		destX _ centerX + dx + 1 - width.		self copyBits.		destY _ centerY + dy - height + 1.		self copyBits.		destX _ left.		self copyBits.		prevLeft _ left].! !!GrafPort methodsFor: 'all' stamp: 'jm 11/2/97 16:34'!fillRect: rect color: fillColor offset: aPoint	fillColor class == InfiniteForm ifTrue: [		self fillColor: nil.		fillColor displayOnPort: ((self clippedBy: rect) colorMap: nil) at: aPoint.		^ self].	self copy: rect		from: 0@0		in: nil		fillColor: fillColor		rule: combinationRule.! !!GrafPort methodsFor: 'all'!frameRect: rect borderWidth: borderWidth borderColor: borderColor	sourceForm _ nil.	self fillColor: borderColor.	(rect areasOutside: (rect insetBy: borderWidth)) do:		[:edgeStrip | self destRect: edgeStrip; copyBits].! !!GrafPort methodsFor: 'all'!frameRectBottom: rect	| w h |	w _ width.	h _ height.	sourceForm _ nil.	destX _ rect left + 1.	destY _ rect bottom - 1.	width _ rect width - 2.	height _ 1.	1 to: h do: [:i |		self copyBits.		destX _ destX + 1.		destY _ destY - 1.		width _ width - 2].	width _ w.	height _ h.! !!GrafPort methodsFor: 'all'!frameRectRight: rect	| w h |	w _ width.	h _ height.	sourceForm _ nil.	width _ 1.	height _ rect height - 1.	destX _ rect right - 1.	destY _ rect top + 1.	1 to: w do: [:i |		self copyBits.		destX _ destX - 1.		destY _ destY + 1.		height _ height - 2].	width _ w.	height _ h.! !!GraphMorph methodsFor: 'initialization'!initialize	super initialize.	self color: (Color r: 0.8 g: 0.8 b: 0.6).	self extent: 365@80.	self borderWidth: 2.	dataColor _ Color darkGray.	cursor _ 1.0.  "may be fractional"	cursorColor _ Color red.	startIndex _ 1.	self data:		((0 to: 360 - 1) collect:			[:x | (10000.0 * ((4.0 * x) degreesToRadians sin)) asInteger]).! !!GraphMorph methodsFor: 'accessing'!color: aColor	super color: aColor.	self flushCachedForm.! !!GraphMorph methodsFor: 'accessing'!cursor	^ cursor! !!GraphMorph methodsFor: 'accessing'!cursor: aNumber	| truncP |	cursor ~= aNumber ifTrue:  [		cursor _ aNumber.		truncP _ aNumber truncated.		truncP > data size ifTrue: [cursor _ data size].		truncP < 0 ifTrue: [cursor _ 1].		self keepIndexInView: truncP.		self changed].! !!GraphMorph methodsFor: 'accessing'!cursorAtEnd	^ cursor truncated >= data size! !!GraphMorph methodsFor: 'accessing'!cursorColor	^ cursorColor! !!GraphMorph methodsFor: 'accessing'!cursorColor: aColor	cursorColor _ aColor.	self flushCachedForm.! !!GraphMorph methodsFor: 'accessing'!data	^ data! !!GraphMorph methodsFor: 'accessing'!data: aCollection	data _ aCollection.	maxVal _ minVal _ 0.	data do: [:x |		x < minVal ifTrue: [minVal _ x].		x > maxVal ifTrue: [maxVal _ x]].	self flushCachedForm.! !!GraphMorph methodsFor: 'accessing'!dataColor	^ dataColor! !!GraphMorph methodsFor: 'accessing'!dataColor: aColor	dataColor _ aColor.	self flushCachedForm.! !!GraphMorph methodsFor: 'accessing' stamp: 'tk 12/4/97 11:19'!lastAcceptedScript	^ lastAcceptedScript! !!GraphMorph methodsFor: 'accessing' stamp: 'tk 9/21/97 00:05'!lastAcceptedScript: scriptEditor	"Need to do a clean store here."	lastAcceptedScript _ scriptEditor! !!GraphMorph methodsFor: 'accessing' stamp: 'tk 12/4/97 11:20'!lastScriptEditor	^ lastScriptEditor! !!GraphMorph methodsFor: 'accessing' stamp: 'tk 9/21/97 00:04'!lastScriptEditor: scriptEditor	"Need to do a clean store here."	lastScriptEditor _ scriptEditor! !!GraphMorph methodsFor: 'accessing'!parts	"Return an array of part names for use in e-toys."	^ #(position startIndex cursor valueAtCursor)! !!GraphMorph methodsFor: 'accessing'!startIndex	^ startIndex! !!GraphMorph methodsFor: 'accessing'!startIndex: aNumber	startIndex ~= aNumber ifTrue:  [		startIndex _ aNumber asInteger.		self flushCachedForm].! !!GraphMorph methodsFor: 'accessing'!valueAtCursor	data isEmpty ifTrue: [^ 0].	^ data at: ((cursor truncated max: 1) min: data size)! !!GraphMorph methodsFor: 'accessing'!valueAtCursor: aPointOrNumber	data isEmpty ifTrue: [^ 0].	data		at: ((cursor truncated max: 1) min: data size)		put: (self asNumber: aPointOrNumber).	self flushCachedForm.! !!GraphMorph methodsFor: 'drawing'!drawOn: aCanvas	| c |	cachedForm = nil ifTrue:  [		c _ FormCanvas extent: bounds extent.		self drawDataOn: (c copyOffset: bounds origin negated).		cachedForm _ c form].	aCanvas image: cachedForm at: bounds origin.	self drawPointerOn: aCanvas.! !!GraphMorph methodsFor: 'change reporting'!layoutChanged	super layoutChanged.	cachedForm _ nil.! !!GraphMorph methodsFor: 'events' stamp: 'jm 10/18/97 11:32'!handlesMouseDown: evt	evt shiftPressed		ifTrue: [^ super handlesMouseDown: evt]		ifFalse: [^ true].! !!GraphMorph methodsFor: 'events' stamp: 'jm 10/18/97 11:52'!mouseMove: evt	| x w |	x _ evt cursorPoint x - (bounds left + borderWidth).	w _ self width - (2 * borderWidth).	self changed.	x < 0 ifTrue: [		cursor _ startIndex + (3 * x).		cursor _ (cursor max: 1) min: data size.		^ self startIndex: cursor].	x > w ifTrue: [		cursor _ startIndex + w + (3 * (x - w)).		cursor _ (cursor max: 1) min: data size.		^ self startIndex: cursor - w].	cursor _ ((startIndex + x) max: 1) min: data size.! !!GraphMorph methodsFor: 'commands'!appendValue: aPointOrNumber	| newVal |	(data isKindOf: OrderedCollection) ifFalse: [data _ data asOrderedCollection].	newVal _ self asNumber: aPointOrNumber.	data addLast: newVal.	newVal < minVal ifTrue: [minVal _ newVal].	newVal > maxVal ifTrue: [maxVal _ newVal].	self cursor: data size.	self flushCachedForm.! !!GraphMorph methodsFor: 'commands'!clear	self startIndex: 1.	self cursor: 1.	self data: OrderedCollection new.! !!GraphMorph methodsFor: 'commands'!commandsWithDefaultArgs	"Return a list of (command arg1 arg2 ...) arrays where each command is followed by the default values for is parameters."	| r |	r _ OrderedCollection new.	r add: #(appendValue: 1000).	r add: #(processSamples).	r add: #(play).	r add: #(playOnce).	r add: #(playBach).	r add: #(clear).	r add: #(reverse).	^ r! !!GraphMorph methodsFor: 'commands'!loadCoffeeCupClink	SampledSound useCoffeeCupClink.	self data: SampledSound defaultSampleTable.! !!GraphMorph methodsFor: 'commands' stamp: 'jm 12/17/97 22:42'!play	| count |	count _ ((2 * SoundPlayer samplingRate) // data size) max: 1.	SampledSound defaultSamples: data repeated: count.	SampledSound nominalSamplePitch: 250.	Smalltalk garbageCollect.	(SampledSound pitch: 440.0 dur: 1.5 loudness: 0.5) play.! !!GraphMorph methodsFor: 'commands'!playBach	Smalltalk garbageCollect.	SampledSound bachFugue play.! !!GraphMorph methodsFor: 'commands' stamp: 'jm 12/17/97 22:42'!playOnce	SampledSound defaultSamples: data repeated: 1.	SampledSound nominalSamplePitch: 250.	Smalltalk garbageCollect.	(SampledSound pitch: 440.0 dur: 1.5 loudness: 0.5) play.! !!GraphMorph methodsFor: 'commands'!processSamples	| w sel |	w _ self world.	self nameInModel ifNil: [^ self].	sel _ self processSamplesSelector.	(w model respondsTo: sel) ifFalse: [^ self].	self cursor: 1.	[self cursorAtEnd] whileFalse: [		w model perform: sel.		w runStepMethods.		w displayWorld].	w model perform: sel.  "final sample"! !!GraphMorph methodsFor: 'commands'!reverse	data _ data reversed.	self flushCachedForm.! !!GraphMorph methodsFor: 'commands'!stopPlaying	SoundPlayer stopPlayerProcess.! !!GraphMorph methodsFor: 'script support'!acceptScript: aScriptEditorMorph for: ignored	lastAcceptedScript _ aScriptEditorMorph.	self world model class		compile: lastAcceptedScript methodString		classified: 'scripts'		notifying: nil.! !!GraphMorph methodsFor: 'script support'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'read file' action: #readDataFromFile.	aCustomMenu add: 'script' action: #editScript:.! !!GraphMorph methodsFor: 'script support'!hasScript	"Return true if there is already a script for this morph."	^ lastAcceptedScript ~~ nil! !!GraphMorph methodsFor: 'script support'!initScripts	"Used to remove the scripts from a newly made copy of myself."	lastAcceptedScript _ lastScriptEditor _ nil.! !!GraphMorph methodsFor: 'script support'!processSamplesSelector	^ (self nameInModel, 'ProcessSamples') asSymbol! !!GraphMorph methodsFor: 'script support'!readDataFromFile	| fileName |	fileName _ FillInTheBlank		request: 'File name?'		initialAnswer: ''.	fileName isEmpty ifTrue: [^ self].	(StandardFileStream isAFileNamed: fileName) ifFalse: [		^ self inform: 'Sorry, I cannot find that file'].	data _ (SampledSound readTrimmedSamplesFromAIFF: fileName).	self flushCachedForm.! !!GraphMorph methodsFor: 'private'!drawDataOn: aCanvas	| yScale baseLine x start end value left top bottom right |	super drawOn: aCanvas.	data isEmpty ifTrue: [^ self].	maxVal = minVal ifTrue: [		yScale _ 1.	] ifFalse: [		yScale _ (bounds height - (2 * borderWidth)) asFloat / (maxVal - minVal)].	baseLine _ bounds bottom - borderWidth + (minVal * yScale) truncated.	left _ top _ 0. right _ 10. bottom _ 0.	x _ bounds left + borderWidth.	start _ (startIndex asInteger max: 1) min: data size.	end _ (start + bounds width) min: data size.	start to: end do: [:i |		left _ x truncated. right _ x + 1.		right > (bounds right - borderWidth) ifTrue: [^ self].		value _ (data at: i) asFloat.		value >= 0.0 ifTrue: [			top _ baseLine - (yScale * value) truncated.			bottom _ baseLine.		] ifFalse: [			top _ baseLine.			bottom _ baseLine - (yScale * value) truncated].		aCanvas fillRectangle: (left@top corner: right@bottom) color: dataColor.		x _ x + 1].! !!GraphMorph methodsFor: 'private'!drawPointerOn: aCanvas	| ptr x r |	ptr _ (cursor asInteger max: 1) min: data size.	r _ self innerBounds.	x _ r left + ptr - startIndex.	((x >= r left) and: [x <= r right]) ifTrue: [		aCanvas fillRectangle: (x@r top corner: x+1@r bottom) color: cursorColor].! !!GraphMorph methodsFor: 'private'!flushCachedForm	cachedForm _ nil.	self changed.! !!GraphMorph methodsFor: 'private'!keepIndexInView: index	| newStart |	index < startIndex ifTrue: [		newStart _ index - (bounds width - (2 * borderWidth)) + 1.		^ self startIndex: (newStart max: 1)].	index > (startIndex + bounds width - (2 * borderWidth)) ifTrue: [		^ self startIndex: (index min: data size)].! !!GraphMorph methodsFor: 'private'!registerWaveform	"Store my data as the default sample table for SampledSound."	SampledSound defaultSampleTable: (data collect: [:x | x asInteger]).	SampledSound nominalSamplePitch: 153.! !!GraphMorph methodsFor: 'copying' stamp: 'tk 12/4/97 11:18'!copy	| obj |	obj _ super copy.	obj lastScriptEditor: obj lastAcceptedScript.			"lastScriptEditor would not have been copied, as it is owned by the world, not me.  Can't allow mine to creep into the copy." 	^ obj! !!GraphMorph methodsFor: 'copying' stamp: 'sw 9/22/97 08:57'!copyRecordingIn: dict	"Overridden to copy lastAcceptedScript as well."	| new |	new _ super copyRecordingIn: dict.	lastAcceptedScript ifNotNil: [		new lastAcceptedScript: 			((dict includesKey: lastAcceptedScript)				ifTrue: [dict at: lastAcceptedScript]				ifFalse: [lastAcceptedScript copyRecordingIn: dict])].	lastScriptEditor ifNotNil: [		new lastScriptEditor: 			((dict includesKey: lastScriptEditor)				ifTrue: [dict at: lastScriptEditor]				ifFalse: [lastScriptEditor copyRecordingIn: dict])].	^ new! !!GraphMorph methodsFor: 'copying' stamp: 'tk 12/4/97 11:18'!prepareToBeSaved	"SmartRefStream will not write any morph that is owned by someone outside the root being written.  (See DataStream.typeIDFor:)  Open Scripts are like that.  Make a private copy of the scriptEditor."	super prepareToBeSaved.	lastAcceptedScript ifNotNil: [		lastAcceptedScript owner ifNotNil: ["open on the screen"			lastAcceptedScript _ lastAcceptedScript fullCopy setMorph: self.			"lastAcceptedScript privateOwner: nil" "fullCopy does it"]].	"lastScriptEditor will not be written out"! !!GraphMorph methodsFor: 'copying' stamp: 'tk 12/4/97 11:19'!shallowCopy	| obj |	obj _ super shallowCopy.	obj lastScriptEditor: obj lastAcceptedScript.			"lastScriptEditor would not have been copied, as it is owned by the world, not me.  Can't allow mine to creep into the copy." 	^ obj! !HaloMorph comment:'This morph provides a halo of handles for its target morph.Dragging, duplicating, rotating, and resizing to be done bymousing down on the appropriate handle. There are alsohandles for help and for a menu of infrequently used operations.'!!HaloMorph methodsFor: 'initialization' stamp: 'di 9/18/97 08:20'!initialize	super initialize.	self color: (Color r: 0.6 g: 0.8 b: 1.0).	growingOrRotating _ false.! !!HaloMorph methodsFor: 'accessing' stamp: 'jm 7/16/97 06:51'!target	^ target! !!HaloMorph methodsFor: 'accessing' stamp: 'jm 7/30/97 15:52'!target: aMorph	target _ aMorph.	target ifNotNil: [self addHandles].! !!HaloMorph methodsFor: 'drawing' stamp: 'jm 9/27/97 13:33'!drawOn: aCanvas	"Draw this morph only if it has no target."	target ifNil: [super drawOn: aCanvas].	"bordering commented out per Alan's request"	"growingOrRotating" false ifTrue:		["Show border if not otherwise visble during grow and rotate"		((target isKindOf: BorderedMorph) and: [target borderWidth > 0]) ifFalse:			[aCanvas frameRectangle: target bounds width: 1 color: Color black]]! !!HaloMorph methodsFor: 'geometry' stamp: 'jm 7/16/97 22:42'!containsPoint: aPoint	"This method is overridden so that, once up, the handles will stay up as long as the mouse is within the box that encloses all the handles even if it is not over any handle or over its owner."	target == nil		ifTrue: [^ super containsPoint: aPoint]		ifFalse: [^ false].! !!HaloMorph methodsFor: 'events' stamp: 'sw 9/8/97 09:46'!staysUpWhenMouseIsDownIn: aMorph	^ (aMorph == target) or: [submorphs includes: aMorph]! !!HaloMorph methodsFor: 'stepping' stamp: 'di 12/3/97 13:39'!step	| newBounds |	target ifNil: [^ self].	(newBounds _ target bounds) = bounds ifTrue: [^ self].	growingOrRotating ifFalse:		["adjust halo bounds if appropriate"		submorphs size > 1 ifTrue:			[self addHandles "recreates full set with new bounds"].		self bounds: newBounds]! !!HaloMorph methodsFor: 'stepping' stamp: 'jm 7/16/97 06:54'!stepTime	^ 0  "every cycle"! !!HaloMorph methodsFor: 'private' stamp: 'di 9/18/97 08:08'!addHandleAt: aPoint color: aColor	"Add a handle centered at the given point with the given color. Return the handle."	| handle |	handle _ EllipseMorph		newBounds: (Rectangle center: aPoint extent: 16@16)		color: aColor.	self addMorph: handle.	handle on: #mouseUp send: #endInteraction to: self.	handle setBalloonText: (target balloonHelpTextForHandle: handle).	^ handle! !!HaloMorph methodsFor: 'private' stamp: 'sw 11/3/97 13:58'!addHandles	| box worldBounds fullBox |	worldBounds _ self world bounds.	self removeAllMorphs.  "remove old handles, if any"	self bounds: target bounds.  "update my size"	fullBox _ self fullBounds expandBy: 16.	box _ (fullBox topLeft max: (5@5)) corner: (fullBox bottomRight min: (worldBounds bottomRight - (5@5))).	(self addHandleAt: box topLeft color: Color red)		on: #mouseDown send: #doMenu:with: to: self.	(self addHandleAt: box topCenter color: Color black)		on: #mouseDown send: #doGrab:with: to: self.	(self addHandleAt: box topRight color: Color green)		on: #mouseDown send: #doDup:with: to: self.	"(self addHandleAt: box leftCenter color: Color brown)		on: #mouseDown send: #startDrag:with: to: self;		on: #mouseStillDown send: #doDrag:with: to: self.	(self addHandleAt: (box topCenter + ((box width // 4) @ 0)) color: Color lightYellow)		on: #mouseDown send: #openViewer to: self."	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue)			on: #mouseDown send: #mouseDownOnHelpHandle: to: target;			on: #mouseUp send: #deleteBalloon to: target].	target addOptionalHandlesTo: self box: box.  "Rotation handle for SketchMorph, font controls for TextMorph, etc"	(self addHandleAt: box bottomRight color: Color yellow)		on: #mouseDown send: #startGrow:with: to: self;		on: #mouseStillDown send: #doGrow:with: to: self.	self addNameBeneath: box string: target externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'sw 11/1/97 13:11'!addNameBeneath: outerRectangle string: aString	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."	| nameMorph |		nameMorph _ UpdatingStringMorph contents: aString.	nameMorph useStringFormat; target: target; putSelector: #renameTo:.	nameMorph position: outerRectangle bottomCenter - (((nameMorph width + 6) // 2) @ 8 negated).	self addMorph: nameMorph.	^ nameMorph! !!HaloMorph methodsFor: 'private' stamp: 'sw 8/20/97 23:23'!doDrag: evt with: dragHandle	target setConstrainedPositionFrom: evt cursorPoint - positionOffset.! !!HaloMorph methodsFor: 'private' stamp: 'jm 7/30/97 15:18'!doDup: evt with: dupHandle	"Ask hand to duplicate my target."	evt hand setArgument: target; duplicateMorph.	target _ evt hand firstSubmorph.	self removeAllHandlesBut: dupHandle.! !!HaloMorph methodsFor: 'private' stamp: 'jm 8/3/97 11:48'!doGrab: evt with: grabHandle	"Ask hand to grab my target."	self removeAllHandlesBut: grabHandle.  "remove all other handles"	evt hand grabMorph: target.! !!HaloMorph methodsFor: 'private' stamp: 'jm 7/30/97 15:31'!doGrow: evt with: growHandle	| newExtent |	newExtent _ (evt cursorPoint - positionOffset) - target topLeft.	target extent: (newExtent max: minExtent).	growHandle position: evt cursorPoint - (growHandle extent // 2).	self layoutChanged.! !!HaloMorph methodsFor: 'private' stamp: 'jm 11/4/97 11:46'!doMenu: evt with: menuHandle	"Ask hand to invoke the halo menu for my target."	| menu |	self removeAllHandlesBut: nil.  "supp"	self world doOneCycle.	menu _ evt hand buildMorphHandleMenuFor: target.	menu addTitle: target externalName.	evt hand invokeMenu: menu event: evt.! !!HaloMorph methodsFor: 'private' stamp: 'jm 7/30/97 15:31'!doRot: evt with: rotHandle	"Update the rotation of my target if it is a kind of SketchMorph."	| degrees |	(target isKindOf: SketchMorph) ifTrue: [		degrees _ (evt cursorPoint - target referencePosition) degrees.		target rotationDegrees: degrees - angleOffset degrees.		rotHandle position: evt cursorPoint - (rotHandle extent // 2).		self layoutChanged].! !!HaloMorph methodsFor: 'private' stamp: 'sw 9/20/97 15:49'!endInteraction	target isInWorld ifTrue: [owner ifNotNil: [self addHandles]]! !!HaloMorph methodsFor: 'private' stamp: 'di 9/18/97 08:20'!removeAllHandlesBut: h	"Remove all handles except h."	submorphs copy do:		[:m | m == h ifFalse: [m delete]].! !!HaloMorph methodsFor: 'private' stamp: 'jm 7/30/97 15:55'!startDrag: evt with: dragHandle	"Drag my target without removing it from its owner."	self removeAllHandlesBut: dragHandle.	positionOffset _ dragHandle center - self position.! !!HaloMorph methodsFor: 'private' stamp: 'jm 7/30/97 15:31'!startGrow: evt with: growHandle	"Initialize resizing of my target."	growingOrRotating _ true.	self removeAllHandlesBut: growHandle.  "remove all other handles"	positionOffset _ growHandle center - target bottomRight.	target isLayoutMorph		ifTrue: [minExtent _ target minWidth@target minHeight]		ifFalse: [minExtent _ 1@1].! !!HaloMorph methodsFor: 'private' stamp: 'jm 7/30/97 15:31'!startRot: evt with: rotHandle	"Initialize rotation of my target if it is a kind of SketchMorph."	(target isKindOf: SketchMorph) ifTrue: [		growingOrRotating _ true.		self removeAllHandlesBut: rotHandle.  "remove all other handles"		angleOffset _ rotHandle center - target referencePosition.		angleOffset _ Point r: angleOffset r					degrees: angleOffset degrees - target rotationDegrees].! !HandleMorph comment:'A HandleMorph provides mouse-up control behavior.'!!HandleMorph methodsFor: 'initialize' stamp: 'di 11/3/97 16:34'!forEachPointDo: aBlock	pointBlock _ aBlock! !!HandleMorph methodsFor: 'initialize' stamp: 'di 11/3/97 16:48'!initialize	super initialize.	self extent: 8@8.	self color: Color yellow.! !!HandleMorph methodsFor: 'stepping' stamp: 'di 11/3/97 16:34'!step	pointBlock value: self center! !!HandleMorph methodsFor: 'stepping' stamp: 'di 11/3/97 16:54'!stepTime	"Update continuously."	^ 0! !!HandleMorph methodsFor: 'termination' stamp: 'di 11/3/97 16:54'!justDroppedInto: aMorph event: anEvent	"So that when the hand drops me (into the world) I go away"	self delete.! !!HandMorph methodsFor: 'initialization' stamp: 'di 9/18/97 16:16'!initForEvents	eventSubscribers _ Set new.	mouseDownMorph _ nil.	lastEvent _ MorphicEvent new.	eventTransform _ MorphicTransform identity.	self resetClickState.	mouseOverTimes ifNotNil: [mouseOverTimes _ Dictionary new].! !!HandMorph methodsFor: 'initialization' stamp: 'di 1/15/98 13:37'!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	mouseOverMorphs _ OrderedCollection new.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	grid _ 4@4.	gridOn _ false.	remoteConnections _ OrderedCollection new.	lastEventTransmitted _ MorphicEvent new.	mouseOverTimes _ Dictionary new! !!HandMorph methodsFor: 'classification'!isHandMorph	^ true! !!HandMorph methodsFor: 'accessing'!colorForInsets	"Morphs being dragged by the hand use the world's color"	^ owner color! !!HandMorph methodsFor: 'accessing' stamp: 'sw 10/3/97 15:48'!lastEvent	^ lastEvent! !!HandMorph methodsFor: 'accessing'!setArgument: aMorph	argument _ aMorph! !!HandMorph methodsFor: 'accessing' stamp: 'jm 6/11/97 17:26'!showTemporaryCursor: cursorOrNil	"Set the temporary cursor to the given Form. If the argument is nil, revert to the normal cursor."	self showTemporaryCursor: cursorOrNil hotSpotOffset: 0@0.! !!HandMorph methodsFor: 'accessing' stamp: 'jm 11/16/97 09:17'!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset	"Set the temporary cursor to the given Form. If the argument is nil, revert to the normal cursor."	self changed.	cursorOrNil == nil ifTrue: [		temporaryCursor _ nil.		temporaryCursorOffset _ 0@0.		bounds _ self position extent: NormalCursor extent.	] ifFalse: [		temporaryCursor _ ColorForm mappingWhiteToTransparentFrom: cursorOrNil.		temporaryCursorOffset _ hotSpotOffset.		bounds _ self position extent: temporaryCursor extent].	self userInitials: userInitials.	self layoutChanged.	self changed.	UseHardwareCursor ifTrue: [		(cursorOrNil isMemberOf: Cursor)			ifTrue: [cursorOrNil show]			ifFalse: [Cursor normal show]].! !!HandMorph methodsFor: 'accessing'!targetOffset	"Return the offset of the last mouseDown location relative to the origin of the recipient morph. During menu interactions, this is the absolute location of the mouse down event that invoked the menu."	^ targetOffset! !!HandMorph methodsFor: 'accessing'!userInitials	^ userInitials! !!HandMorph methodsFor: 'accessing' stamp: 'jm 11/14/97 11:07'!userInitials: aString	userInitials _ aString.	bounds _ bounds merge: (bounds topRight + (0@4) extent: (userInitials asParagraph extent)).! !!HandMorph methodsFor: 'geometry'!changed	"Needs to be overridden to call superclass's invalidRect:."	super invalidRect: self fullBounds.! !!HandMorph methodsFor: 'geometry'!fullBounds	"Extend my bounds by the shadow offset when carrying morphs."	| bnds |	bnds _ super fullBounds.	submorphs isEmpty		ifTrue: [^ bnds ]		ifFalse: [^ bnds topLeft corner: bnds  bottomRight + self shadowOffset].! !!HandMorph methodsFor: 'geometry'!invalidRect: damageRect	"Extend damage to cover drop-shadow when carrying morphs."	| r |	fullBounds == nil		ifTrue: [damageRecorder recordInvalidRect: damageRect]		ifFalse: [damageRecorder recordInvalidRect: (damageRect translateBy: fullBounds origin negated)].	submorphs isEmpty		ifTrue: [r _ damageRect]		ifFalse: [r _ damageRect topLeft extent: damageRect extent + self shadowOffset].	super invalidRect: r.! !!HandMorph methodsFor: 'geometry' stamp: 'jm 7/5/97 13:41'!position: aPoint	"Overridden to align submorph origins to the grid if gridding is on."	gridOn		ifTrue: [^ super position: (aPoint grid: grid)]		ifFalse: [^ super position: aPoint].! !!HandMorph methodsFor: 'drawing'!drawOn: aCanvas	"Draw the hand itself (i.e., the cursor)."	UseHardwareCursor ifFalse: [		temporaryCursor == nil			ifTrue: [aCanvas image: NormalCursor at: self position]			ifFalse: [aCanvas image: temporaryCursor at: self position]].	userInitials size > 0 ifTrue:		[aCanvas text: userInitials at: (self position + (16@4)) font: nil color: color].! !!HandMorph methodsFor: 'drawing' stamp: 'jm 8/3/97 16:19'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching myBnds shadowCanvas |	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue: [		cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	myBnds _ super fullBounds.  "my full bounds without my shadow"	self updateCacheCanvasDepth: aCanvas depth.	"draw the shadow"	shadowCanvas _ aCanvas copyForShadowDrawingOffset: self shadowOffset.	"Note: it's 3x faster to fill a rectangle rather than draw the shadow of a Form"	cachedCanvasHasHoles		ifTrue: [shadowCanvas image: cacheCanvas form at: myBnds origin]		ifFalse: [shadowCanvas fillRectangle: myBnds color: color].	"draw morphs in front of the shadow using the cached Form"	aCanvas image: cacheCanvas form at: myBnds origin.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing'!nonCachingFullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version does not cache an image of the morphs being held by the hand.	 Thus, it is slower for complex morphs, but consumes less space."	| shadowCanvas |	submorphs isEmpty ifTrue: [^ self drawOn: aCanvas].  "just draw the hand itself"	shadowCanvas _ aCanvas copyForShadowDrawingOffset: self shadowOffset.	submorphs reverseDo: [:m | m fullDrawOn: shadowCanvas].  "draw shadows"	submorphs reverseDo: [:m | m fullDrawOn: aCanvas].  "draw morphs in front of shadows"	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing'!shadowOffset	^ 6@8! !!HandMorph methodsFor: 'drawing' stamp: 'jm 7/30/97 12:44'!updateCacheCanvasDepth: depth	"Update the cached image of the morphs being held by this hand."	| myBnds rectList c |	myBnds _ super fullBounds.  "my full bounds without my shadow"	(cacheCanvas == nil or: [cacheCanvas extent ~= myBnds extent]) ifTrue: [		cacheCanvas _ FormCanvas extent: myBnds extent depth: depth.		c _ cacheCanvas copyOffset: myBnds origin negated.		submorphs reverseDo: [:m | m fullDrawOn: c].		cachedCanvasHasHoles _ (cacheCanvas form tallyPixelValues at: 1) > 0.		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: myBnds extent).	damageRecorder reset.	rectList do: [:r |		c _ cacheCanvas copyOrigin: myBnds origin negated clipRect: r.		c fillColor: Color transparent.  "clear to transparent"		submorphs reverseDo: [:m | m fullDrawOn: c].	].! !!HandMorph methodsFor: 'event dispatching' stamp: 'tk 7/15/97 15:01'!gridPointRaw	"Private!! Returns the nearest grid point to the cursor to be used as the coordinate for the current event.  Do not include a cursor offset"	| where |	where _ Sensor cursorPoint - owner viewBox topLeft.	^ gridOn ifTrue: [where grid: grid]			ifFalse: [where]! !!HandMorph methodsFor: 'event dispatching' stamp: 'jm 7/11/97 12:03'!handleEvent: evt	self position ~= evt cursorPoint		ifTrue: [self position: evt cursorPoint].	temporaryCursor ifNotNil: [		evt setCursorPoint: evt cursorPoint + temporaryCursorOffset].	eventSubscribers do: [:m | m handleEvent: evt].	evt isMouse ifTrue: [		evt isMouseMove ifTrue: [^ self handleMouseMove: evt].		evt isMouseDown ifTrue: [^ self handleMouseDown: evt].		evt isMouseUp ifTrue: [^ self handleMouseUp: evt]].	evt isKeystroke ifTrue: [		keyboardFocus ifNotNil: [keyboardFocus keyStroke: evt].		^ self].! !!HandMorph methodsFor: 'event dispatching' stamp: 'sw 10/3/97 09:15'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown: evt.	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				mouseDownMorph _ m.				eventTransform _ m transformFrom: self.				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				"ensure that at least one mouseMove: is reported				 for each mouse transaction:"				m mouseMove: (localEvt copy setType: #mouseMove)]			ifFalse:				["grab m by the appropriate root"				rootForGrab _ m rootForGrabOf: m.				rootForGrab ifNotNil: [self grabMorph: rootForGrab]].		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: []].		]! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 10/19/97 13:48'!handleMouseMove: evt	"Dispatch a mouseMove event."	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	mouseDownMorph ifNotNil:		[mouseDownMorph mouseMove: (self transformEvent: evt)].	self handleMouseOver: evt.! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 1/13/98 22:07'!handleMouseOver: evt	| p roots mList allMouseOvers leftMorphs enteredMorphs now t oldHalo balloonHelpEnabled mouseOverHalosEnabled |	owner ifNil: [^ self].  "this hand is not in a world"	balloonHelpEnabled _ self world balloonHelpEnabled & evt anyButtonPressed not.	mouseOverHalosEnabled _ self world mouseOverHalosEnabled & evt anyButtonPressed not.	p _ evt cursorPoint.	roots _ owner rootMorphsAt: p.  "root morphs in world"	roots size > 0		ifTrue: [mList _ roots first unlockedMorphsAt: p]		ifFalse: [mList _ EmptyArray].	now _ Time millisecondClockValue.	"Make a list of all potential mouse-overs..."	allMouseOvers _ mList , submorphs select:		[:m | ((mouseOverHalosEnabled and: [m wantsHalo]) or: [balloonHelpEnabled and: [m wantsBalloon]])  "To start a timer"					or: [m handlesMouseOver: evt]  "To send mouseEnter:"].	"Notify and remove any mouse-overs that have just been left..."	leftMorphs _ mouseOverMorphs select: [:m | (allMouseOvers includes: m) not].	leftMorphs do: [:m |		mouseOverMorphs remove: m.	"OK to call me recursively"		m wantsBalloon ifTrue: [m deleteBalloon].		m mouseLeave: (evt transformedBy: (m transformFrom: self)).		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: [] ]].	"Add any new mouse-overs and send mouseEnter: and/or start timers..."	enteredMorphs _ allMouseOvers select: [:m | (mouseOverMorphs includes: m) not].	enteredMorphs do: [:m |		mouseOverMorphs add: m.	"OK to call me recursively"		(m handlesMouseOver: evt) ifTrue:			[m mouseEnter: (evt transformedBy: (m transformFrom: self))].		(m wantsHalo or: [m wantsBalloon]) ifTrue:			[mouseOverTimes ifNotNil: [mouseOverTimes at: m put: now]]].mouseOverTimes ifNotNil:	[mouseOverTimes keys do:		[:m | "Check pending timers for lingering"		t _ mouseOverTimes at: m.		(now < t "rollover" or: [now > (t+800)]) ifTrue:			["Yes we have lingered for 0.8 seconds..."			mouseOverTimes removeKey: m.			m owner ifNotNil:  "Not deleted during linger (--it happens ;--)"				[m wantsHalo					ifTrue: [oldHalo _ m world haloMorphOrNil.							(oldHalo == nil or: [oldHalo target ~~ m])								ifTrue: ["Put up halo for m"										self popUpHalo: evt.										(balloonHelpEnabled and: [m wantsBalloon]) ifTrue:											["...and reschedule balloon after longer linger"											mouseOverTimes at: m put: now]]								ifFalse: ["Halo for m is already up, so show balloon"										(balloonHelpEnabled and: [m wantsBalloon])											ifTrue: [m showBalloon]]]					ifFalse:						[(balloonHelpEnabled and: [m wantsBalloon])							ifTrue: [m showBalloon]]]]]]! !!HandMorph methodsFor: 'event dispatching' stamp: 'jm 11/16/97 11:36'!handleMouseUp: evt	"Dispatch a mouseUp event."	| oldFocus |	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	"drop morphs being carried, if any"	self hasSubmorphs ifTrue: [self dropMorphsEvent: evt].	mouseDownMorph = nil ifTrue: [^ self].	"ensure that at least one mouseMove: is reported for each mouse focus transaction:"	mouseDownMorph mouseMove: (self transformEvent: (evt copy setType: #mouseMove)).	oldFocus := mouseDownMorph.	"make sure that focus becomes nil."	mouseDownMorph _ nil.  "mouse focus transaction ends when mouse goes up"	oldFocus mouseUp: (self transformEvent: evt).! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/29/97 14:24'!keyboardFocus 	^ keyboardFocus! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/26/97 10:39'!mouseDownRecipient: aMorph	"Install a new recipient for mousedown events, namely stillDown and up,	and, in the process, unsubscribe any prior recipient"	mouseDownMorph _ aMorph! !!HandMorph methodsFor: 'event dispatching' stamp: 'jm 11/13/97 15:12'!newKeyboardFocus: aMorphOrNil	"Make the given morph the new keyboard focus, canceling the previous keyboard focus if any. If the argument is nil, the current keyboard focus is cancelled."	| oldFocus |	oldFocus _ keyboardFocus.	keyboardFocus _ aMorphOrNil.	oldFocus ifNotNil: [oldFocus == aMorphOrNil ifFalse: [oldFocus keyboardFocusChange: false]].	aMorphOrNil ifNotNil: [aMorphOrNil keyboardFocusChange: true].! !!HandMorph methodsFor: 'event dispatching' stamp: 'jm 11/4/97 07:15'!newMouseFocus: aMorphOrNil	"Old protocol for compatibility with HMM's MorphicMenu"	mouseDownMorph _ aMorphOrNil! !!HandMorph methodsFor: 'event dispatching' stamp: 'jm 11/19/97 08:37'!processEvents	"Process user input events from the local input devices."	| griddedPoint evt currentExtent |	griddedPoint _ Sensor cursorPoint - owner viewBox topLeft.	gridOn ifTrue: [griddedPoint _ griddedPoint grid: grid].	evt _ MorphicEvent new		setMousePoint: griddedPoint		buttons: Sensor primMouseButtons		lastEvent: lastEvent		hand: self.	remoteConnections size > 0 ifTrue: [		currentExtent _ self worldBounds extent.		lastWorldExtent ~= currentExtent ifTrue: [			self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).			lastWorldExtent _ currentExtent].		self transmitEvent: evt].	(evt yellowButtonPressed and:	 [lastEvent yellowButtonPressed not]) ifTrue: [		lastEvent _ evt.		^ self invokeMetaMenu: evt].	(evt blueButtonPressed and:	 [lastEvent blueButtonPressed not]) ifTrue: [		lastEvent _ evt.		^ self specialGesture: evt].	lastEvent _ evt.	self handleEvent: evt.	[Sensor keyboardPressed] whileTrue: [		evt _ MorphicEvent new			setKeyValue: Sensor keyboard asciiValue			mousePoint: griddedPoint			buttons: Sensor primMouseButtons			hand: self.		lastEvent _ evt.		self handleEvent: evt.		remoteConnections size > 0 ifTrue: [self transmitEvent: evt]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'sw 10/3/97 09:17'!recipientForMouseDown: evt	"Return the morph that should handle the given mouseDown: event."	"Details: To get mouse events, a morph must		a. contain the point at which the mouse went down, and		b. respond true to handlesMouseDown:, and		c1. be in front of all other submorphs that respond true to handlesMouseDown: or		c2. be the outer-most submorph that responds true to preemptsMouseDown:If no morph handles the mouse down, the front-most submorph is grabbed. The complexity in this description arises from the need to resolve conflicts when nested submorphs all want to handle mouse events. The preemptsMouseDown: mechanism allows a morph to intercept mouse events before its submorphs. It is needed only in unusual situations, such as parts bins containing mouse-sensitive objects."	| p roots coreSample |	owner ifNil: [^ nil].  "this hand is not in a world"	p _ evt cursorPoint.	roots _ owner rootMorphsAt: p.  "root morphs in world"	roots size = 0 ifTrue: [		"no morphs at the given point, so world gets it"		^ owner].	"coreSample is submorphs of the front-most root morph in front-to-back order"	coreSample _ roots first unlockedMorphsAt: p.	coreSample do: [:subM | (subM trumpsMouseDown: evt) ifTrue: [^ subM]].	"first, look for an outer-most submorph that preempts mouse events, if any"	coreSample reverseDo: [:subM |		(subM preemptsMouseDown: evt) ifTrue: [^ subM]].	"second, look for the inner-most submorph that handles mouse events, if any"	coreSample do: [:subM |		(subM handlesMouseDown: evt) ifTrue: [^ subM]].	"no enclosing morph wants the event, so return the front-most submorph"	^ coreSample first! !!HandMorph methodsFor: 'event dispatching'!transformEvent: evt	"Transform the given event by the transform recorded when the mouse went down."	^ evt transformedBy: eventTransform! !!HandMorph methodsFor: 'double click support'!checkForDoubleClick: evt	"Process the given mouse event to detect a click, double-click, or drag."	| t |	t _ Time millisecondClockValue - firstClickTime.	clickState = #firstClickDown ifTrue: [		(t > DoubleClickTime or:		 [(evt cursorPoint - firstClickEvent cursorPoint) r > 15]) ifTrue: [			"consider it a drag if hand moves or timeout expires"			clickClient drag: firstClickEvent.			^ self resetClickState].		evt isMouseUp ifTrue: [			clickState _ #firstClickUp.			^ self]].	clickState = #firstClickUp ifTrue: [		evt isMouseDown ifTrue: [			clickClient doubleClick: firstClickEvent.			^ self resetClickState].		t > DoubleClickTime ifTrue: [			clickClient click: firstClickEvent.			^ self resetClickState]].! !!HandMorph methodsFor: 'double click support'!resetClickState	"Reset the double-click detection state to normal (i.e., not waiting for a double-click)."	clickClient _ nil.	clickState _ #idle.	firstClickEvent _ nil.	firstClickTime _ nil.! !!HandMorph methodsFor: 'double click support'!waitForClicksOrDrag: aMorph event: evt	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'singleClick: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its singleClick:, doubleClick:, or drag: methods." 	clickClient _ aMorph.	clickState _ #firstClickDown.	firstClickEvent _ evt.	firstClickTime _ Time millisecondClockValue.! !!HandMorph methodsFor: 'grabbing/dropping'!attachMorph: m	"Position the center of the given morph under this hand, then grab it. This method is used to grab far away or newly created morphs."	m position: self position - (m fullBounds extent // 2).	self grabMorph: m.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jm 7/29/97 13:29'!dropMorphsEvent: evt	"Drop all the morphs this hand is currently holding in response to the given event."	"Details: All submorphs of the front-most composite morph under the hand are given an opportunity to accept the dropping morph. If none of these accepts it, or if there is no morph under the hand, then the morph drop drops into the world."	| targetM |	owner ifNil: [^ self].  "there is no world to drop the morphs into"	self changed.	self submorphsReverseDo: [:m |		"drop in reverse order to maintain back-to-front ordering"		targetM _ self dropTargetFor: m event: evt.		targetM acceptDroppingMorph: m event: evt.		m justDroppedInto: targetM event: evt.		m owner = self ifTrue: [self world addMorphFront: m]].	self layoutChanged.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'sw 8/22/97 23:50'!dropTargetFor: aMorph event: evt	"Return the morph that the given morph is to be dropped onto. Return the world, if no other morph wants the dropping morph."	| root |	"find front-most composite morph"	root _ nil.	owner submorphsReverseDo: [:m |		((m fullContainsPoint: evt cursorPoint) and:		 [(m isKindOf: HaloMorph) not]) ifTrue: [root _ m]].	root == nil ifTrue: [^ self world].	(root unlockedMorphsAt: evt cursorPoint) do: [:m |		(m wantsDroppedMorph: aMorph event: evt) ifTrue: [^ m]].	^ self world! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jm 7/24/97 15:04'!grabMorph: m	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	self addMorphBack: m.! !!HandMorph methodsFor: 'event reporting'!startReportingEventsTo: subscriber	"Start reporting events to the given object. All input events are reported to every event subscriber, in addition to being sent to the current mouse/keyboard focus morph. This allows one to build things like macro recorders, eyes that follow the mouse, etc."	(eventSubscribers includes: subscriber) ifFalse: [eventSubscribers add: subscriber].! !!HandMorph methodsFor: 'event reporting'!stopReportingEventsTo: subscriber	"Stop reporting events to the given object."	eventSubscribers remove: subscriber ifAbsent: [].! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/16/97 01:16'!argumentOrNil	"Answer the root of the front-most morph under the cursor. If the cursor is not over any morph, answer nil."	owner submorphsDo:		[:m | ((m fullContainsPoint: targetOffset) and: [m isLocked not]) ifTrue: [^ m]].	^ nil! !!HandMorph methodsFor: 'meta menu'!beThisWorldsModel	self world setModel: argument.	argument model: nil slotName: nil.	"A world's model cannot have another model"! !!HandMorph methodsFor: 'meta menu'!browseMorphClass	| mClass newBrowser view |	mClass _ argument class.	"Use following to get a simple browser:	Browser newOnClass: mClass."	newBrowser _ HierarchyBrowser new		initHierarchyForClass: mClass		meta: false.	view _ BrowserView systemCategoryBrowser: newBrowser editString: nil.	Browser postOpenSuggestion: (Array with: mClass with: nil).	BrowserView openBrowserView: view		label: mClass name, ' hierarchy'! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 11/17/97 17:04'!buildMorphHandleMenuFor: argMorph	"Build the morph menu for the given morph's halo's menu handle. This menu has two sections. The first section contains commands that are interpreted by the hand; the second contains commands provided by the target morph. This method allows the morph to decide which items should be included in the hand's section of the menu."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	argMorph addAddHandMenuItemsForHalo: menu.	menu defaultTarget: argMorph.	argMorph addCustomHaloMenuItems: menu hand: self.	^ menu! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/13/97 16:13'!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	menu add: 'delete' action: #dismissMorph.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'duplicate' action: #duplicateMorph.	((self world rootMorphsAt: targetOffset) size > 1)		ifTrue: [menu add: 'embed' action: #embedMorph].	menu add: 'resize' action: #resizeMorph.	(argMorph isKindOf: SketchMorph)  ifFalse: [		menu add: 'fill color' action: #changeColor].	(argMorph morphsAt: targetOffset) size > 1 ifTrue: [		menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	menu add: 'inspect' action: #inspectMorph.	menu add: 'browse' action: #browseMorphClass.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'name me' action: #nameMorph.	(argMorph isKindOf: MorphicModel) ifTrue: [		menu add: 'save morph as prototype' action: #saveAsPrototype.		(argMorph ~~ self world modelOrNil) ifTrue: [			 menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveMorphInFile.	menu add: 'show actions' action: #showActions.	menu addLine.	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/12/97 18:23'!buildWorldMenu	"Build the meta menu for the world."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	Project current isTopProject ifFalse:		[menu add: 'exit this world' action: #exitWorld.		menu addLine].	menu add: 'new morph' action: #newMorph.	menu add: 'read morph(s) from file' action: #readMorphFile.	menu addLine.	menu add: 'new drawing' action: #makeNewDrawing.	menu add: 'grab drawing from screen' action: #grabDrawingFromScreen.	menu add: 'read drawing from file' action: #importImageFromDisk.	menu addLine.	menu add: 'change background color' action: #changeBackgroundColor.	menu add: 'inspect world' action: #inspectWorld.	menu addLine.		menu add: 'save world in file' action: #saveWorldInFile.	menu addLine.	menu add: 'add slot to model' action: #newVariable.	menu add: 'write init method for model' action: #writeInitMethodForModel.	menu add: 'grab model for this world' action: #grabModel.	gridOn		ifTrue: [menu add: 'turn gridding off' action: #setGridding]		ifFalse: [menu add: 'turn gridding on' action: #setGridding].	menu addLine.	menu add: 'local host address' action: #reportLocalAddress.	menu add: 'connect remote user' action: #connectRemoteUser.	menu add: 'disconnect remote user' action: #disconnectRemoteUser.	menu add: 'disconnect all remote users' action: #disconnectAllRemoteUsers.	^ menu! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:46'!changeBackgroundColor	| colorPicker |	colorPicker _ self changeColorTarget: self world selector: #color:.	colorPicker updateContinuously: false.! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:15'!changeColor	self changeColorTarget: argument selector: #color:.! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:46'!changeColorTarget: aMorph selector: aSymbol	| m points b |	m _ ColorPickerMorph new		sourceHand: self;		target: aMorph;		selector: aSymbol.	points _ #(topCenter rightCenter bottomCenter leftCenter).  "possible anchors"	1 to: 4 do: [:i |  "Try the four obvious anchor points"		b _ m bounds				align: (m bounds perform: (points at: i))				with: (aMorph bounds perform: (points atWrap: i + 2)).		(self worldBounds containsRect: b) ifTrue: [  "Yes, it fits"			m position: b topLeft.			self world addMorphFront: m.			m changed.			^ self]].	"when all else fails..."	m position: 20@20.	self world addMorphFront: m.	m changed.	^ m! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 12/4/97 10:30'!chooseColor	"Displays a color palette using abstract colors, then waits for a mouse click."	"Copied from Color fromUser, then shrunk. 4/16/97 tk"	| loc d chartExtent transp save pt c feedbackColor |	loc _ Sensor cursorPoint.	d _ Display depth.	chartExtent _ 216@56.	((ColorChart == nil) or: [ColorChart depth ~= Display depth]) 		ifTrue: [ColorChart _ Color oldColorPaletteForDepth: d extent: chartExtent].	transp _ Rectangle origin: chartExtent - (50@19) + loc extent: 50@19.	save _ Form fromDisplay: (loc extent: ColorChart extent).	ColorChart displayAt: loc.	Cursor normal showWhile: [		[Sensor anyButtonPressed] whileFalse: [			pt _ Sensor cursorPoint.			c _ feedbackColor _ Display colorAt: pt.			(transp containsPoint: pt) ifTrue: [				c _ Color transparent.				feedbackColor _ Color white].			Display fill: (loc + (0@37) extent: 73@19) fillColor: feedbackColor].		save displayAt: loc.		Sensor waitNoButton].	^ c! !!HandMorph methodsFor: 'meta menu' stamp: 'di 10/29/97 11:15'!chooseMorphicCategory	"Put up a menu listing all the Morphic categories, and return the one chosen, or nil if none"	| menu prefix categories |	menu _ CustomMenu new.	prefix _ 'Morphic-'.	categories _ SystemOrganization categories select:		[:c | (c beginsWith: prefix) and: [(c endsWith: 'Support') not]].	categories do: [:c | menu add: (c copyFrom: prefix size + 1 to: csize) action: c].	^  menu startUp	"HandMorph new chooseMorphicCategory"! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 9/11/97 16:54'!chooseMorphInCategory: category	| menu class |	menu _ CustomMenu new.	(SystemOrganization listAtCategoryNamed: category)		do: [:c | class _ Smalltalk at: c.			((class inheritsFrom: Morph) and: [classincludeInNewMorphMenu]) ifTrue:				[menu add: class name action: class]].	menu addLine.	menu add: 'categories...' action: #chooseMorphicCategory.	^ menu startUp"HandMorph new chooseMorphInCategory: 'Morphic-Kernel' asSymbol"! !!HandMorph methodsFor: 'meta menu' stamp: 'di 10/29/97 10:21'!chooseTargetSubmorphOf: root caption: caption	"Put up a menu of possible target names, with the given caption"	| possibleTargets menu |	possibleTargets _ root morphsAt: targetOffset.	possibleTargets size = 1 ifTrue: [^ possibleTargets first].	menu _ CustomMenu new.	possibleTargets do: [:m | menu add: (self submorphNameFor: m) action: m].	^ caption size == 0		ifTrue:			[menu startUp]		ifFalse:			[menu startUpWithCaption: caption]! !!HandMorph methodsFor: 'meta menu'!dismissMorph	argument delete.! !!HandMorph methodsFor: 'meta menu' stamp: 'di 1/13/98 10:48'!drawingClass	^ SketchMorph! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/14/97 11:52'!duplicateMorph	| new oldModel |	new _ argument fullCopy.	(oldModel _ argument findA: MorphicModel) ifNotNil: [		oldModel model duplicate: (new findA: MorphicModel) from: oldModel].	self grabMorph: new.! !!HandMorph methodsFor: 'meta menu' stamp: 'dhhi 11/6/97 16:02'!embedMorph 	| rootMorphs morphToEmbed targetRoot targetMorph worldPosition |	rootMorphs _ self world rootMorphsAt: targetOffset.	rootMorphs size < 2 ifTrue: [^ self].	morphToEmbed _ rootMorphs at: 1.	worldPosition _ morphToEmbed position.	targetRoot _ rootMorphs at: 2.	targetMorph _ self chooseTargetSubmorphOf: targetRoot caption: 'Embed in...'.	targetMorph ifNotNil: [		targetMorph addMorphBack: morphToEmbed				fromWorldPosition: worldPosition].! !!HandMorph methodsFor: 'meta menu'!exitWorld	owner exit! !!HandMorph methodsFor: 'meta menu' stamp: 'di 11/16/97 16:28'!goBehind	argument goBehind! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 8/1/97 17:04'!grabDrawingFromScreen	"Allow the user to specify a rectangular area of the Display, capture the pixels from that area, and use them to create a new drawing morph. Attach the result to the hand."	| m |	m _ self drawingClass new form: Form fromUser.	self attachMorph: m.! !!HandMorph methodsFor: 'meta menu'!grabModel	"Attach the root of the world's model to the hand. The user will typically attach some composite morph to this model and then save it as a finished component."	self attachMorph: self world model root.! !!HandMorph methodsFor: 'meta menu'!grabMorph	self position: targetOffset.	self grabMorph: argument.! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/14/97 14:32'!importImageFromDisk	| aName m f |	aName _ Utilities chooseFileWithSuffix: ''.  "all files"	aName ifNil: [^ self].	f _ Form fromFileNamed: aName.	f ifNil: [^ self error: 'unrecognized image file format'].	m _ self drawingClass new form: f.	self attachMorph: m.! !!HandMorph methodsFor: 'meta menu'!inspectMorph	argument inspect.! !!HandMorph methodsFor: 'meta menu'!inspectWorld	owner inspect.! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:46'!invokeMenu: aMenu event: evt	"Invoke the given menu."	aMenu popUpAt: evt cursorPoint event: evt.! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:46'!invokeMetaMenu: evt	"Invoke the meta menu. If the hand is over the background, the world menu is presented. If it is over a morph, a menu of operations for that morph is presented. Each menu entry contains a string to be presented in the menu and a selector. If the selector takes an argument, the mouse-down event that invoked the menu is passed as an argument. This lets the command know which hand invoked it in  order to do things like attaching the result of the command to that hand."	"Shortcut: If the shift key is pressed, the user is given a chance to select a submorph on which to operate."	| menu |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	targetOffset _ self position.	argument _ self argumentOrNil.	argument == nil		ifTrue: [			menu _ self buildWorldMenu.			menu addTitle: 'World']		ifFalse: [			menu _ self buildMorphMenuFor: argument.			menu addTitle: argument class name].	self invokeMenu: menu event: evt.! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/10/97 01:14'!lockMorph	argument lock.	self world abandonAllHalos! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/13/97 11:16'!makeNewDrawing	| rect m aPaintWindow |	self world stopRunningAll.	rect _ self world paintArea.	"Let it tell us"	m _ self drawingClass new		form: (Form extent: rect extent depth: self world canvas depth).	m bounds: rect.	aPaintWindow _ SketchEditorMorph new.	self world addMorphFront: aPaintWindow.	aPaintWindow initializeFor: m inWorld: self world.	aPaintWindow 		afterNewPicDo: [:aForm :aRect |			owner fullRepaintNeeded.			m form: aForm.			m position: aRect origin.			m forwardDirection: aPaintWindow forwardDirection.			m rotationDegrees: aPaintWindow forwardDirection.	"Same orientation as she drew it"			m rotationStyle: aPaintWindow rotationStyle.			self world addMorphFront: m]		ifNoBits: ["If no bits drawn"].! !!HandMorph methodsFor: 'meta menu'!nameMorph	argument choosePartName.! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/19/97 09:01'!newMorph	| morphClassList menu categories subMenu |	menu _ MenuMorph new.	menu addStayUpItem.	menu addTitle: 'Select Morph Class'.	morphClassList _ Morph withAllSubclasses asSortedCollection:		[:m1 :m2 | m1 class name < m2 class name].	morphClassList remove: WorldMorph;		remove: HandMorph;		remove: MorphicModel;		remove: RemoteHandMorph.	morphClassList _ morphClassList select:		[:c | (c inheritsFrom: MorphicModel) not or:			  ["Only include Models that have been saved"			   c includesSelector: #initMorph]].	categories _ (morphClassList collect: [:each | each category]) asSet asSortedCollection.	categories do: [:cat |		subMenu _ MenuMorph new.		morphClassList do: [:each |			each category = cat ifTrue: [				subMenu add: each name					target: self					selector: #newMorphOfClass:event:					argument: each]].		menu add: cat subMenu: subMenu].	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:15'!newMorphOfClass: morphClass	"taken out of the old method #newMorph"	| m |	m _ morphClass new.	m installModelIn: owner.  "A chance to install model pointers"	self attachMorph: m.	owner startSteppingSubmorphsOf: m! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/19/97 09:03'!newMorphOfClass: morphClass event: evt	"Attach a new morph of the given class to the invoking hand."	| m |	m _ morphClass new.	m installModelIn: owner.  "a chance to install model pointers"	evt hand attachMorph: m.	owner startSteppingSubmorphsOf: m.! !!HandMorph methodsFor: 'meta menu'!newVariable	| partName |	partName _ owner model addPartNameLike: 'part' withValue: nil.	partName ifNil: [^ self].  "user chose bad part name"	owner model class compileAccessorsFor: partName! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:46'!operateOnSubmorph: aMorph event: evt	"Invoke the morph menu for the given submorph."	| menu |	menu _ self buildMorphMenuFor: aMorph.	menu addTitle: aMorph class name.	self invokeMenu: menu event: evt.! !!HandMorph methodsFor: 'meta menu' stamp: 'tk 6/26/97 12:07'!readMorphFile	"Retreive a morph or a collection of morphs from a file."	| fileName morphOrList ff |	fileName _ FillInTheBlank request: 'Morph file name?'.	fileName isEmpty ifTrue: [^ self].  "abort"	ff _ FileStream oldFileNamed: fileName, '.morph'.	morphOrList _ ff fileInObjectAndCode.		"code filed in is the Model class"	"the file may contain either a single morph or an array of morphs"	self world addMorphsAndModel: morphOrList.! !!HandMorph methodsFor: 'meta menu' stamp: 'di 11/3/97 16:35'!resizeMorph	| handle minExtent |	argument isLayoutMorph		ifTrue: [minExtent _ argument minWidth @ argument minHeight]		ifFalse: [minExtent _ 1@1].	handle _ HandleMorph new forEachPointDo:		[:newPoint | argument extent: ((newPoint - argument bounds topLeft)										max: minExtent)].	self attachMorph: handle.	handle startStepping.! !!HandMorph methodsFor: 'meta menu'!saveAsPrototype	| m |	m _ argument.	(SelectionMenu confirm: 'Make this morph the prototype for ', m class printString, '?')		ifFalse: [^ self].	m class prototype: m.! !!HandMorph methodsFor: 'meta menu' stamp: 'di 11/14/97 10:24'!saveMorphInFile	"Save the argument morph in a file."	| fileName refStream copyToSave |	fileName _ FillInTheBlank request: 'File name for this morph?'.	fileName isEmpty ifTrue: [^ self].  "abort"	refStream _ SmartRefStream newFileNamed: fileName, '.morph'.	copyToSave _ argument fullCopy.	(copyToSave isKindOf: MorphicModel) ifTrue: [		"don't save this world's model"		copyToSave model: nil slotName: nil].	copyToSave allMorphsDo: [:m | m prepareToBeSaved].	refStream nextPut: copyToSave.	refStream close.	"Warn user if plain morph had behavior that is not saved"	(copyToSave isKindOf: WorldMorph) ifFalse: [		(refStream superclasses includesKey: #MorphicModel) ifTrue: [			PopUpMenu notify: 'An object you have written has behavior in a MorphicModel.\The code for that behavior was not written out.\If you want to preserve the behavior, save this EToy\or save this world.' withCRs]].! !!HandMorph methodsFor: 'meta menu' stamp: 'di 11/14/97 10:25'!saveWorldInFile	"Save the world's submorphs, model, and stepList in a file.  "	| fileName fileStream aClass |	fileName _ FillInTheBlank request: 'File name for this morph?'.	fileName isEmpty ifTrue: [^ self].  "abort"	"Save only model, stepList, submorphs in this world"	self world submorphsDo: [:m |		m allMorphsDo: [:subM | subM prepareToBeSaved]].	"Amen"	fileStream _ FileStream newFileNamed: fileName, '.morph'.	aClass _ self world model ifNil: [nil] ifNotNil: [self world model class].	fileStream fileOutClass: aClass andObject: self world.! !!HandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:46'!selectSubmorphToOperateOn: rootMorph sending: aSymbol event: evt	"Let the user select a submorph of the given root morph. When selected, the given selector is sent with the selected submorph as an argument."	| possibleTargets menu |	possibleTargets _ rootMorph morphsAt: targetOffset.	possibleTargets size = 1 ifTrue: [^ self perform: aSymbol with: possibleTargets first].	menu _ MenuMorph new.	possibleTargets do: [:m |		menu add: (self submorphNameFor: m)			target: self			selector: aSymbol			argumentList: (Array with: m with: evt)].	menu popUpAt: self position event: evt.! !!HandMorph methodsFor: 'meta menu'!setGridding	gridOn ifTrue: [^ gridOn _ false].	FillInTheBlank request: 'Change grid or confirm...' 		displayAt: Sensor cursorPoint centered: true		action: [:answer | grid _ Compiler evaluate: answer] 		initialAnswer: grid printString.	gridOn _ true! !!HandMorph methodsFor: 'meta menu' stamp: 'tk 9/20/97 23:07'!showActions	"Put up a message list browser of all the code that this morphwould run for mouseUp, mouseDown, mouseMove, mouseEnter, mouseLeave, andmouseLinger.  tk 9/13/97"	| list cls selector |	"the eventHandler"	argument eventHandler ifNil: [list _ SortedCollection new]			ifNotNil: [				list _ argument eventHandler messageList.				(argument eventHandler handlesMouseDown: nil)	ifFalse: [					list add: 'HandMorph grabMorph:']].		"default"	"If not those, then non-default raw events"	#(keyStroke: mouseDown: mouseEnter: mouseLeave: mouseMove: mouseUp:	doButtonAction)		do: [:sel |			cls _ argument class classThatUnderstands: sel.			cls ifNotNil: ["want more than default behavior"				cls == Morph ifFalse: [list add: cls name, ' ',sel]]].	"The mechanism on a Button"	(argument respondsTo: #actionSelector) ifTrue: ["A button"		selector _ argument actionSelector.		cls _ argument target class classThatUnderstands: selector.			cls ifNotNil: ["want more than default behavior"				cls == Morph ifFalse: [list add: cls name, ' ',selector]]].	MessageSet openMessageList: list name: 'Actions of ', argument printString.! !!HandMorph methodsFor: 'meta menu'!subclassMorph	"Create a new subclass of this morph's class and make this morph be an instance of it."	| m oldClass newClassName newClass newMorph |	m _ argument.	oldClass _ m class.	newClassName _ FillInTheBlank		request: 'Please give this new class a name'		initialAnswer: oldClass name.	newClassName = '' ifTrue: [^ self].	(Smalltalk includesKey: newClassName)		ifTrue: [^ self inform: 'Sorry, there is already a class of that name'].	newClass _ oldClass subclass: newClassName asSymbol		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: oldClass category asString.	newMorph _ m as: newClass.	m become: newMorph.! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/5/97 21:48'!submorphNameFor: aMorph	| s nameInModel |	(s _ aMorph knownName) ifNotNil: [^ s].	s _ aMorph class name asString.	nameInModel _ aMorph specialNameInModel.	nameInModel ifNotNil: [s _ s, ' "', nameInModel, '"'].	^ s! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/15/97 23:59'!unlockContents	argument unlockContents! !!HandMorph methodsFor: 'meta menu' stamp: 'sw 8/16/97 17:05'!unlockOneSubpart	argument unlockOneSubpart! !!HandMorph methodsFor: 'meta menu'!writeInitMethodForModel	| model |	model _ self world model.	model class chooseNewName.	model fullCopy compileInitMethods.! !!HandMorph methodsFor: 'special gestures' stamp: 'jm 11/13/97 12:39'!specialGesture: evt	"Blue mouse button (cmd-mouse on the Macintosh) gestures that allow a morph to be grabbed without recourse to the meta menu or brings up a halo of handles for the morph."	"Summary:		Cmd-mouse			pop up halo		Cmd-shift-mouse		grab morph (for picking up buttons, etc.)"	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	targetOffset _ self position.	(argument _ self argumentOrNil) ifNil: [^ self].	evt shiftPressed		ifTrue: [self grabMorph]		ifFalse: [self popUpHalo: evt].! !!HandMorph methodsFor: 'halos' stamp: 'di 9/18/97 22:42'!addHalo	| halo |	halo _ HaloMorph new.	self world addMorphFront: halo.	halo target: argument.	halo startStepping.! !!HandMorph methodsFor: 'halos' stamp: 'sw 10/3/97 16:07'!chooseHaloSubmorphOf: root caption: caption	"Answer the submorph of the root that should be given the halo; in etoys, we never prompt the user, but for generic Morphic, we do it Ted's way"	^ self chooseTargetSubmorphOf: root caption: caption! !!HandMorph methodsFor: 'halos' stamp: 'sw 9/14/97 22:54'!mouseOverHalosOff	mouseOverTimes _ nil! !!HandMorph methodsFor: 'halos' stamp: 'sw 9/14/97 22:54'!mouseOverHalosOn	mouseOverTimes _ Dictionary new! !!HandMorph methodsFor: 'halos' stamp: 'jm 11/4/97 15:24'!popUpHalo: evt	"Pop up a halo on the top-most unlocked morph below the hand."	self world abandonAllHalos.	targetOffset _ self position.	(argument _ self argumentOrNil) ifNil: [^ self].	argument submorphCount > 0 ifTrue:		[(argument _ self chooseHaloSubmorphOf: argument caption: 'Who gets halo?')			ifNil: [^ self]].	self addHalo.! !!HandMorph methodsFor: 'remote morphic' stamp: 'jm 11/14/97 11:19'!cleanupDeadConnections	"Clean up any remote connections that have been disconnected or become invalid."	| liveConnections sock |	liveConnections _ OrderedCollection new.	remoteConnections do: [:triple |		sock _ triple first.		sock isConnected			ifTrue: [liveConnections add: triple]			ifFalse: [				(triple at: 2) = #opening					ifTrue: [						Transcript show: 'trying connection again...'; cr.						sock destroy.						sock _ Socket new.						sock connectTo: (triple at: 3) port: 54323.						triple at: 1 put: sock.						liveConnections add: triple]  "try again"					ifFalse: [						sock isUnconnectedOrInvalid							ifTrue: [triple first destroy]							ifFalse: [liveConnections add: triple]]]].  "closing"	remoteConnections _ liveConnections.! !!HandMorph methodsFor: 'remote morphic' stamp: 'jm 9/26/97 15:00'!connectRemoteUser	"Prompt for the initials to be used to identify the cursor of a remote user, then create a cursor for that user and wait for a connection."	| initials addr h |	initials _ FillInTheBlank request: 'Enter initials for remote user''s cursor?'.	initials isEmpty ifTrue: [^ self].  "abort"	addr _ NetNameResolver promptUserForHostAddress.	addr = 0 ifTrue: [^ self].  "abort"	Socket ensureNetworkConnected.	h _ RemoteHandMorph new userInitials: initials.	self world addHand: h.	h changed.	h startListening.	self startTransmittingEventsTo: addr.! !!HandMorph methodsFor: 'remote morphic' stamp: 'jm 9/26/97 14:34'!disconnectAllRemoteUsers	"Disconnect all remote hands and stop transmitting events."	| addr |	self world hands do: [:h |		(h isKindOf: RemoteHandMorph) ifTrue: [			addr _ h remoteHostAddress.			addr = 0 ifFalse: [self stopTransmittingEventsTo: addr].			h withdrawFromWorld]].	remoteConnections do: [:triple | triple first closeAndDestroy: 5].	remoteConnections _ OrderedCollection new.! !!HandMorph methodsFor: 'remote morphic' stamp: 'jm 11/4/97 07:15'!disconnectRemoteUser	"Prompt for the initials of the remote user, then remove the remote hand with those initials, breaking its connection."	"select hand to remove"	| initials handToRemove addr |	initials _ FillInTheBlank request: 'Enter initials for remote user''s cursor?'.	initials isEmpty ifTrue: [^ self].  "abort"	handToRemove _ nil.	self world hands do: [:h |		h userInitials = initials ifTrue: [handToRemove _ h]].	handToRemove ifNil: [^ self].  "no hand with those initials"	addr _ handToRemove remoteHostAddress.	addr = 0 ifFalse: [self stopTransmittingEventsTo: addr].	handToRemove withdrawFromWorld.! !!HandMorph methodsFor: 'remote morphic' stamp: 'jm 11/19/97 08:33'!readyToTransmit	"Return true if all connections are ready to send."	remoteConnections do: [:triple | (triple first) sendDone ifFalse: [^ false]].	^ true! !!HandMorph methodsFor: 'remote morphic' stamp: 'jm 11/4/97 07:15'!reportLocalAddress	"Report the local host address of this computer."	| addrString m s |	Socket initializeNetwork.	addrString _ NetNameResolver localAddressString.	m _ RectangleMorph new		color: (Color r: 0.6 g: 0.8 b: 0.6);		extent: 118@36;		borderWidth: 1.	s _ StringMorph contents: 'Local Host Address:'.	s position: m position + (5@4).	m addMorph: s.	s _ StringMorph contents: addrString.	s position: m position + (5@19).	m addMorph: s.	self attachMorph: m.! !!HandMorph methodsFor: 'remote morphic' stamp: 'jm 9/26/97 14:35'!startTransmittingEventsTo: addr	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	| sock |	remoteConnections do: [:pair |		sock _ pair first.		(sock isConnected and: [sock remoteAddress = addr])			ifTrue: [^ self]].  "don't connect if already connected to the given address"	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: addr), ' ...'; cr.	sock _ SimpleClientSocket new.	sock connectTo: addr port: 54323.	remoteConnections add: (Array with: sock with: #opening with: addr).! !!HandMorph methodsFor: 'remote morphic' stamp: 'jm 9/26/97 14:35'!stopTransmittingEventsTo: addr	"Stop broadcasting events from this world's cursor to a remote cursor on the host with the given address. This method issues a 'close' but does not destroy the socket; it will be destroyed when the other end reads the last data and closes the connection."	| sock |	remoteConnections do: [:triple |		sock _ triple first.		(sock isUnconnectedOrInvalid not and: [sock remoteAddress = addr]) ifTrue: [			sock close.			triple at: 2 put: #closing]].! !!HandMorph methodsFor: 'remote morphic' stamp: 'jm 11/19/97 08:35'!transmitEvent: aMorphicEvent	"Transmit the given event to all remote connections."	| sock status firstEvt |	lastEventTransmitted = aMorphicEvent ifTrue: [^ self].	transmitBuffer ifNil: [		transmitBuffer _ WriteStream on: (String new: 10000)].	transmitBuffer nextPutAll: aMorphicEvent storeString; cr.	lastEventTransmitted _ aMorphicEvent.	self readyToTransmit ifFalse: [^ self].	self cleanupDeadConnections.	remoteConnections do: [:triple |		sock _ triple first.		status _ triple at: 2.		sock isConnected			ifTrue: [				status = #opening ifTrue: [					"connection established; send worldExtent as first event"					firstEvt _ MorphicEvent newWorldExtent: self worldBounds extent.					sock sendData: firstEvt storeString, (String with: Character cr).					Transcript						show: 'Connection established with remote WorldMorph at ';						show: (NetNameResolver stringFromAddress: sock remoteAddress); cr.					triple at: 2 put: #connected].				sock sendData: transmitBuffer contents]			ifFalse: [				status = #connected ifTrue: [					"other end has closed; close our end"					Transcript						show: 'Closing connection with remote WorldMorph at ';						show: (NetNameResolver stringFromAddress: sock remoteAddress); cr.					sock close.					triple at: 2 put: #closing]]].	transmitBuffer reset.! !!HandMorph methodsFor: 'remote morphic' stamp: 'jm 11/4/97 07:15'!worldBounds	^ self world bounds! !!HandMorph class methodsFor: 'all'!doubleClickTime	^ DoubleClickTime! !!HandMorph class methodsFor: 'all'!doubleClickTime: milliseconds	DoubleClickTime _ milliseconds.! !!HandMorph class methodsFor: 'all' stamp: 'di 6/22/97 09:07'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!HandMorph class methodsFor: 'all' stamp: 'jm 11/16/97 09:17'!initialize	"HandMorph initialize"	ColorChart _ nil.	DoubleClickTime _ 280.	NormalCursor _ ColorForm mappingWhiteToTransparentFrom: Cursor normal.	BlankCursor _ ColorForm mappingWhiteToTransparentFrom: Cursor blank.	UseHardwareCursor _ false.! !!HeadingMorph methodsFor: 'initialization'!initialize	super initialize.	self color: (Color r:0.6 g: 1.0 b: 1.0).	degrees _ 90.0.	magnitude _ 1.0.	self borderWidth: 1.	self extent: 160@160.! !!HeadingMorph methodsFor: 'accessing'!degrees	^ (degrees + 90.0) \\ 360.0! !!HeadingMorph methodsFor: 'accessing'!degrees: aNumber	degrees _ (aNumber asFloat + 270.0) \\ 360.0.! !!HeadingMorph methodsFor: 'accessing'!extent: aPoint	"Contrain extent to be square."	| d |	d _ aPoint x min: aPoint y.	super extent: d@d.! !!HeadingMorph methodsFor: 'accessing'!magnitude	^ magnitude! !!HeadingMorph methodsFor: 'accessing'!magnitude: aNumber	magnitude _ (aNumber asFloat max: 0.0) min: 1.0.! !!HeadingMorph methodsFor: 'drawing'!drawArrowFrom: p1 to: p2 width: w color: aColor on: aCanvas	| d p |	d _ (p1 - p2) theta radiansToDegrees.	aCanvas line: p1 to: p2 width: w color: aColor.	p _ p2 + (Point r: 5 degrees: d - 50).	aCanvas line: p to: p2 width: w color: aColor.	p _ p2 + (Point r: 5 degrees: d + 50).	aCanvas line: p to: p2 width: w color: aColor.! !!HeadingMorph methodsFor: 'drawing'!drawOn: aCanvas	| x y r center box |	super drawOn: aCanvas.	box _ self innerBounds.	1 to: 9 do: [:i |		x _ box left + ((box width * i) // 10).		aCanvas line: (x@box top) to: (x@(box bottom - 1)) color: Color black.		y _ box top + ((box height * i) // 10).		aCanvas line: (box left@y) to: ((box right - 1)@y) color: Color black].	r _ ((box width asFloat * magnitude asFloat) / 2.0) - 1.0.	center _ box center.	self drawArrowFrom: center - (1@1)		to: center + ((r * degrees degreesToRadians cos)@0) - (1@1)		width: 3		color: (Color red)		on: aCanvas.	self drawArrowFrom: center - (1@1)		to: center + (0@(r * degrees degreesToRadians sin)) - (1@1)		width: 3		color: (Color red)		on: aCanvas.	self drawArrowFrom: center - (1@1)		to: center + (Point r: r degrees: degrees) - (1@1)		width: 3		color: Color black		on: aCanvas.! !!HeadingMorph methodsFor: 'events'!handlesMouseDown: evt	^ true! !!HeadingMorph methodsFor: 'events'!mouseMove: evt	| v |	self changed.	v _ evt cursorPoint - bounds center.	degrees _ v theta radiansToDegrees.	magnitude _ (v r asFloat / (bounds width asFloat / 2.0)) min: 1.0.! !HierarchicalMenu comment:'Created by Dan Ingalls back in 1985-6, but not currently maintained or used.'!!HierarchicalMenu class methodsFor: 'instance creation'!labelList: labelList lines: lines selections: selections	| topLabels topSelections deeperMenus item |	topLabels _ OrderedCollection new.	topSelections _ OrderedCollection new.	deeperMenus _ OrderedCollection new.	1 to: labelList size do:		[:i | item _ labelList at: i.		(item isMemberOf: Array)			ifTrue: [topLabels addLast: item first.					deeperMenus addLast:					(HierarchicalMenu labelList: item allButFirst									selections: (selections at: i))]			ifFalse: [topLabels addLast: item.					deeperMenus addLast: nil].				topSelections addLast: (selections at: i)].	^ (super labelList: topLabels asArray lines: lines selections: topSelections asArray)		deeperMenus: deeperMenus asArray! !!HierarchyBrowser methodsFor: 'initialization'!classList	^ classList! !!HierarchyBrowser methodsFor: 'initialization'!classListIndex: newIndex	"Cause system organization to reflect appropriate category"	| newClassName |	newIndex ~= 0 ifTrue:		[newClassName _ (classList at: newIndex) copyWithout: $ .		systemCategoryListIndex _			systemOrganizer numberOfCategoryOfElement: newClassName.		self changed: #systemCategorySelectionChanged].	^ super classListIndex: newIndex! !!HierarchyBrowser methodsFor: 'initialization'!initAlphabeticListing	| tab stab index |	self systemOrganizer: SystemOrganization.	metaClassIndicated _ false.	classList _ Smalltalk classNames.! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'sw 11/27/96'!initForClassList: classNames	"Initialize the receiver for use with the provided list of class names.   "	self systemOrganizer: SystemOrganization.	metaClassIndicated _ false.	classList _ classNames! !!HierarchyBrowser methodsFor: 'initialization'!initHierarchyForClass: theClass meta: meta	| tab stab index |	self systemOrganizer: SystemOrganization.	metaClassIndicated _ meta.	classList _ OrderedCollection new.	tab _ ''.	theClass allSuperclasses reverseDo: 		[:aClass | 		classList add: tab , aClass name.		tab _ tab , '  '].	index _ classList size + 1.	theClass allSubclassesWithLevelDo:		[:aClass :level |		stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].		classList add: tab , stab , aClass name]	 	startingLevel: 0.	self classListIndex: index! !!HierarchyBrowser methodsFor: 'initialization'!selectClass: classNotMeta	| name |	name _ classNotMeta name.	self classListIndex: (self classList findFirst:			[:each | (each endsWith: name)					and: [each size = name size							or: [(each at: each size - name size) isSeparator]]])! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'sw 12/4/96'!selectedClassName	"Answer the name of the class currently selected.   di	  bug fix for the case where name cannot be found -- return nil rather than halt"	| aName |	aName _ super selectedClassName.	^ aName == nil		ifTrue:			[aName]		ifFalse:			[(aName copyWithout: $ ) asSymbol]! !!HiPop methodsFor: 'as yet unclassified' stamp: 'jm 10/9/97 04:51'!initialize	super initialize.	sound _ SampledSound		samples: #(230 254 256 242 234 246 206 211 179 175 133 111 106 91 46 53 35 54 17 40 67 98 79 114 127 167 162 133 130 119 91 82 98 90 75 87 45 19 -17 1 -16 -1 8 12 -1 53 71 85 109 117 106 159 138 154 133 161 122 138 85 72 67 51 46 20 6 3 -8 8 -8 -4 -1 22 38 53 43 85 71 103 88 87 45 51 43 59 16 -9 -17 1 -45 -20 -32 -8 -38 3 -20 20 43 53 43 37 24 54 30 58 59 32 20 33 17 8 -30 -56 -72 -111 -133 -127 -122 -111 -129 -111 -108 -112 -108 -111 -135 -100 -130 -111 -158 -125 -121 -104 -96 -111 -135 -106 -111 -104 -133 -111 -143 -137 -140 -130 -109 -103 -119 -62 -59 -67 -62 -33 -41 -12 -43 -46 -43 -38 -71 -87 -100 -80 -125 -124 -145 -132 -145 -111 -148 -106 -95 -79 -51 -14 -17 8 22 85 93 111 116 127 138 133 96 67 53 72 45 -22 -30 -20 -33 16 27 121 177 335 500 756 1023 1362 1738 2131 2465 2769 2932 3032 2951 2609 1980 1102 -43 -1326 -2769 -4181 -5598 -6852 -7906 -8630 -9014 -8982 -8390 -7257 -5645 -3637 -1415 1029 3476 5953 8267 10196 11595 12386 12531 12089 10938 9187 6826 4120 1124 -1933 -4946 -7699 -10138 -12005 -13244 -13719 -13418 -12384 -10706 -8485 -5808 -2796 421 3640 6629 9344 11524 13121 14054 14261 13735 12528 10643 8209 5307 2125 -1265 -4592 -7693 -10426 -12683 -14290 -15200 -15273 -14514 -12881 -10583 -7628 -4171 -448 3303 6911 10154 12921 14914 16133 16383 15750 14259 12040 9164 5772 2083 -1721 -5395 -8751 -11629 -13799 -15261 -15758 -15399 -14104 -11989 -9176 -5801 -2022 1844 5593 9006 11905 14064 15405 15842 15387 13957 11834 9005 5754 2215 -1402 -4888 -8044 -10744 -12739 -14054 -14519 -14216 -13070 -11186 -8680 -5729 -2501 789 4023 6924 9450 11320 12489 12920 12629 11614 9949 7764 5214 2411 -495 -3327 -5845 -8006 -9690 -10820 -11288 -11133 -10271 -8914 -6992 -4820 -2357 174 2643 4910 6853 8361 9360 9729 9537 8811 7573 5908 3939 1799 -448 -2695 -4641 -6343 -7628 -8525 -8926 -8785 -8177 -7118 -5640 -3861 -1943 43 2047 3813 5332 6502 7292 7601 7455 6837 5872 4578 3054 1305 -482 -2228 -3781 -5133 -6187 -6850 -7136 -7039 -6529 -5688 -4489 -3071 -1489 109 1726 3166 4447 5398 6034 6235 6151 5651 4847 3747 2483 997 -464 -1915 -3221 -4323 -5159 -5708 -5929 -5812 -5328 -4601 -3635 -2478 -1165 75 1324 2432 3366 4011 4423 4557 4439 3961 3326 2470 1494 422 -616 -1596 -2506 -3267 -3797 -4124 -4258 -4142 -3740 -3235 -2527 -1702 -832 43 919 1718 2391 2820 3151 3276 3206 2988 2569 1983 1321 587 -125 -837 -1516 -2112 -2554 -2854 -2951 -2883 -2669 -2285 -1771 -1186 -539 119 779 1363 1889 2223 2457 2528 2451 2177 1776 1271 681 88 -500 -1079 -1592 -2009 -2283 -2420 -2354 -2230 -1904 -1460 -942 -385 198 766 1263 1660 1967 2138 2185 2094 1889 1518 1102 577 56 -463 -971 -1423 -1799 -2070 -2222 -2244 -2112 -1910 -1554 -1166 -679 -162 353 797 1195 1505 1733 1844 1863 1696 1489 1144 731 267 -201 -706 -1157 -1525 -1834 -2036 -2089 -2033 -1893 -1644 -1281 -865 -367 85 572 968 1342 1591 1783 1812 1699 1481 1186 811 413 -66 -534 -965 -1333 -1699 -1920 -2046 -2022 -1964 -1721 -1410 -989 -505 -14 471 929 1337 1673 1863 1989 1993 1854 1634 1318 898 477 -50 -484 -940 -1320 -1657 -1852 -1978 -1928 -1778 -1531 -1199 -785 -316 174 634 1092 1470 1789 2022 2107 2081 1999 1715 1374 939 488 -27 -493 -953 -1326 -1644 -1880 -1997 -1960 -1875 -1639 -1345 -927 -511 -85 342 834 1202 1570 1801 1938 1989 1893 1721 1436 1068 663 216 -185 -632 -1040 -1384 -1625 -1783 -1857 -1836 -1659 -1466 -1131 -748 -359 46 476 852 1200 1445 1600 1678 1710 1544 1297 1003 676 246 -175 -621 -990 -1353 -1628 -1855 -1947 -1965 -1851 -1639 -1341 -973 -524 -106 376 776 1160 1492 1715 1815 1838 1738 1589 1279 979 559 106 -285 -731 -1128 -1450 -1731 -1922 -2001 -2005 -1863 -1636 -1316 -948 -545 -137 306 755 1126 1466 1717 1893 1955 1915 1760 1531 1190 844 384 -61 -511 -921 -1299 -1584 -1773 -1889 -1880 -1730 -1520 -1152 -716 -256 156 622 1057 1437 1709 1873 1925 1902 1718 1431 1103 706 272 -164 -563 -915 -1224 -1450 -1592 -1642 -1596 -1441 -1194 -879 -527 -133 274 705 1015 1294 1515 1610 1671 1592 1412 1195 876 556 214 -153 -495 -800 -1037 -1189 -1307 -1308 -1260 -1087 -879 -626 -335 8 321 651 900 1137 1299 1402 1387 1341 1165 950 689 388 50 -266 -572 -823 -1028 -1203 -1287 -1265 -1197 -1052 -847 -539 -253 72 411 708 976 1236 1404 1470 1433 1350 1181 965 679 366 71 -217 -547 -789 -971 -1039 -1082 -1008 -884 -726 -476 -185 104 403 697 939 1097 1232 1247 1257 1124 955 756 534 224 -38 -332 -537 -731 -889 -981 -992 -937 -839 -747 -547 -324 -111 116 343 547 724 847 924 910 902 777 676 482 301 85 -104 -272 -445 -597 -702 -779 -782 -800 -766 -653 -500 -390 -187 -59 114 259 417 508 603 643 676 626 572 463 366 200 54 -119 -237 -398 -501 -637 -698 -731 -722 -714 -624 -519 -369 -246 -82 54 248 372 492 540 592 589 526 426 358 211 56 -90 -206 -372 -476 -592 -640 -666 -661 -598 -487 -367 -211 -66 151 290 430 526 663 695 753 719 724 629 563 430 300 153 20 -85 -158 -251 -296 -309 -301 -269 -217 -153 -51 33 151 230 345 429 495 527 558 568 572 508 421 321 240 111 43 -114 -175 -232 -267 -288 -305 -300 -214 -180 -79 4 104 206 324 403 511 555 580 585 618 563 498 458 382 308 279 198 148 108 95 51 51 50 66 91 104 116 162 183 214 195 253 261 274 279 267 266 285 266 285 254 258 254 243 269 235 180 175 154 179 159 119 164 216 227 274 314 371 398 461 495 532 509 485 498 401 325 271 164 100 -27 -116 -166 -204 -230 -227 -222 -166 -106 -4 127 258 364 485 577 663 708 753 743 718 608 547 440 298 188 75 -71 -153 -204 -227 -246 -208 -198 -140 -85 43 137 254 343 438 524 593 610 631 605 572 511 456 338 250 154 62 -17 -33 -103 -77 -114 -69 -38 59 117 193 288 369 390 429 438 456 408 353 303 235 140 80 -29 -95 -164 -192 -208 -185 -166 -119 -58 95 198 288 371 488 519 563 598 582 547 482 387 277 112 4 -132 -179 -319 -376 -447 -416 -416 -382 -298 -169 -80 69 211 364 490 624 718 774 789 811 768 721 601 509 384 271 154 33 -95 -138 -216 -259 -253 -237 -198 -171 -109 -22 56 167 264 374 450 530 551 584 595 553 500 458 348 275 146 51 -62 -166 -201 -254 -295 -266 -253 -164 -137 -59 11 98 214 343 403 514 550 603 632 593 543 509 405 337 196 111 17 -61 -146 -188 -242 -229 -224 -201 -187 -129 -104 -37 77 112 166 237 275 311 292 292 290 235 162 111 43 4 -59 -72 -124 -140 -140 -117 -108 -61 -24 56 109 158 169 240 264 284 292 275 266 256 185 124 109 64 1 -41 -72 -87 -80 -77 -46 -35 -11 41 43 56 69 101 116 119 133 108 51 56 53 59 9 43 32 67 95 104 109 150 167 171 183 204 213 190 171 172 122 130 98 95 30 16 -20 -46 -88 -83 -74 -56 -19 33 85 119 201 272 279 319 342 364 369 376 335 325 282 213 158 108 8 -30 -116 -130 -169 -182 -164 -140 -137 -82 -54 32 116 175 225 284 317 379 369 377 342 314)		samplingRate: 22050.! !!HolderMorph methodsFor: 'initialization'!initialize	super initialize.	self borderWidth: 1.	self extent: 240@160.	color _ Color r: 0.8 g: 1.0 b: 0.6.	cursorColor _ Color black.	cursor _ 1.	padding _ 3.	openToDragNDrop _ true.! !!HolderMorph methodsFor: 'accessing'!cursor		^ cursor! !!HolderMorph methodsFor: 'accessing'!cursor: aNumber	"Set the cursor to the given number, modulo the number of items I contain. Fractional cursor values are allowed."	| truncP |	cursor ~= aNumber ifTrue:  [		cursor _ self asNumber: aNumber.		truncP _ cursor truncated.		truncP > submorphs size ifTrue: [			submorphs size > 0				ifTrue: [cursor _ cursor \\ submorphs size]				ifFalse: [cursor _ 1]].		truncP < 0 ifTrue: [cursor _ 1].		self changed].! !!HolderMorph methodsFor: 'accessing'!cursorAtEnd	^ cursor truncated >= submorphs size! !!HolderMorph methodsFor: 'accessing'!cursorColor	^ cursorColor! !!HolderMorph methodsFor: 'accessing'!cursorColor: aColor	cursorColor _ aColor.! !!HolderMorph methodsFor: 'accessing' stamp: 'sw 11/17/97 13:30'!cursorDecr: aNumber	self cursor: (self cursor - aNumber)! !!HolderMorph methodsFor: 'accessing' stamp: 'sw 11/17/97 13:29'!cursorIncr: aNumber	self cursor: (self cursor + aNumber)! !!HolderMorph methodsFor: 'accessing' stamp: 'sw 12/12/97 01:29'!cursorMult: aNumber	self cursor: (self cursor * aNumber)! !!HolderMorph methodsFor: 'accessing'!openToDragNDrop	^ openToDragNDrop! !!HolderMorph methodsFor: 'accessing'!openToDragNDrop: aBoolean	openToDragNDrop _ aBoolean.! !!HolderMorph methodsFor: 'accessing'!parts	"Return an array of part names for use in e-toys."	^ #(position cursor valueAtCursor)! !!HolderMorph methodsFor: 'accessing' stamp: 'sw 9/10/97 20:24'!partsAndTypesForViewer	"Return an array of part names and part types for use in a viewer on the receiver"	^ #(		(cursor 			number)		(valueAtCursor	actor)	)! !!HolderMorph methodsFor: 'accessing'!valueAtCursor	submorphs isEmpty ifTrue: [^ 0].	^ submorphs at: ((cursor truncated max: 1) min: submorphs size)! !!HolderMorph methodsFor: 'accessing'!valueAtCursor: aValue	"Ignored for now. To implement this, we need a way to turn arbitrary Smalltalk objects into Morphs."! !!HolderMorph methodsFor: 'drawing'!drawOn: aCanvas	"Draw a border around the item pointed to by the pointer."	super drawOn: aCanvas.	submorphs size > 0 ifTrue: [		aCanvas			frameRectangle: self selectedRect			width: 2			color: Color black].! !!HolderMorph methodsFor: 'geometry' stamp: 'jm 7/30/97 12:38'!fullBounds	"This is the hook that triggers lazy re-layout. See the comment in LayoutMorph."	fullBounds ifNil: [		self fixLayout.		"compute fullBounds before calling changed to avoid infinite recursion!!"		super fullBounds.  "updates cache"		self changed].	^ super fullBounds! !!HolderMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/18/97 18:03'!acceptDroppingMorph: aMorph event: evt	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).	self changed.	self layoutChanged.! !!HolderMorph methodsFor: 'dropping/grabbing'!allowSubmorphExtraction	^ openToDragNDrop! !!HolderMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/13/97 15:10'!droppableOnPlayfield	^ true! !!HolderMorph methodsFor: 'dropping/grabbing'!wantsDroppedMorph: aMorph event: evt	^ openToDragNDrop! !!HolderMorph methodsFor: 'private' stamp: 'jm 11/4/97 10:44'!addAddHandMenuItemsForHalo: aMenu	"Add halo menu items to be handled by the invoking hand."	self colorSettable		ifTrue: [aMenu add: 'fill color' action: #changeColor].! !!HolderMorph methodsFor: 'private'!fixLayout	"Pack my submorphs into rows that fit within my width."	| nextY i morphsForThisRow |	nextY _ bounds top + borderWidth.	i _ 1.	[i <= submorphs size] whileTrue: [		morphsForThisRow _ self rowMorphsStartingAt: i.		nextY _ self layoutRow: morphsForThisRow lastRowBase: nextY.		i _ i + morphsForThisRow size].! !!HolderMorph methodsFor: 'private' stamp: 'jm 11/17/97 17:40'!insertionIndexFor: aMorph	"Find the right place to put the given dropped morph."	| p rowBase i morphsForThisRow |	p _ aMorph center.	rowBase _ bounds top + borderWidth.	i _ 1.	[i <= submorphs size] whileTrue: [		morphsForThisRow _ self rowMorphsStartingAt: i.		rowBase _ self rowBaseFor: morphsForThisRow lastRowBase: rowBase.		rowBase > p y ifTrue: [  "found row"			morphsForThisRow do: [:m |				m center x > p x ifTrue: [^ i].  "found index in row"				i _ i + 1].			^ i].		i _ i + morphsForThisRow size].	^ submorphs size + 1  "insert at end"! !!HolderMorph methodsFor: 'private' stamp: 'jm 11/17/97 15:51'!layoutRow: mList lastRowBase: lastRowBase	| rowBase nextX |	rowBase _ self rowBaseFor: mList lastRowBase: lastRowBase.	nextX _ bounds left + borderWidth + padding.	mList do: [:m |		m position: nextX @ (rowBase - m fullBounds height).		nextX _ nextX + m fullBounds width + padding].	^ rowBase! !!HolderMorph methodsFor: 'private' stamp: 'jm 11/17/97 15:45'!rowBaseFor: mList lastRowBase: lastRowBase	| maxH |	maxH _ 0.	mList do: [:m | maxH _ maxH max: m fullBounds height].	^ lastRowBase + maxH + padding! !!HolderMorph methodsFor: 'private'!rowMorphsStartingAt: startIndex	"Return a collection of morphs for a row starting at the given index. Put at least one morph into the row, even if it sticks out."	| mList nextX lastIndex m |	mList _ OrderedCollection new.	nextX _ bounds left + borderWidth + padding.	lastIndex _ submorphs size.	startIndex to: lastIndex do: [:i |		m _ submorphs at: i.		nextX _ nextX + m fullBounds width + padding.		nextX > bounds right ifTrue: [			mList isEmpty ifTrue: [mList add: m].			^ mList].		mList add: m].	^ mList! !!HolderMorph methodsFor: 'private'!selectedRect	"Return a rectangle enclosing the morph at the current cursor. Note that the cursor may be a float and may be out of range, so pick the nearest morph. Assume there is at least one submorph."	| p |	p _ cursor asInteger.	p > submorphs size ifTrue: [p _ submorphs size].	p < 1 ifTrue: [p _ 1].	^ (submorphs at: p) fullBounds expandBy: 2.! !!HolderMorph class methodsFor: 'all' stamp: 'sw 10/18/97 18:03'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| proto |	proto _ self new markAsPartsDonor.	proto extent: 100@80; color: (Color r: 1.0 g: 0.9 b: 0.7).	^ proto! !!HtmlFileStream methodsFor: 'all' stamp: 'di 6/28/97 08:35'!copyMethodChunkFrom: aStream	"Overridden to bolden the first line (presumably a method header)"	| terminator code firstLine |	terminator _ $!!.	aStream skipSeparators.	code _ aStream upTo: terminator.	firstLine _ code copyUpTo: Character cr.	firstLine size = code size		ifTrue: [self nextPutAll: code]		ifFalse: [self command: 'b'; nextPutAll: firstLine; command: '/b'.				self nextPutAll: (code copyFrom: firstLine size + 1 to: code size)].	self nextPut: terminator.	[aStream peekFor: terminator] whileTrue:   "case of imbedded (doubled) terminators"			[self nextPut: terminator;				nextPutAll: (aStream upTo: terminator);				nextPut: terminator]! !!HtmlFileStream methodsFor: 'all' stamp: 'di 6/28/97 09:21'!copyPreamble: preamble from: aStream	"Make method category preambles bold at category changes."	prevPreamble = preamble		ifTrue: [super copyPreamble: preamble from: aStream]		ifFalse: [self command: 'H3'.				super copyPreamble: preamble from: aStream.				self command: '/H3'.				prevPreamble _ preamble]! !!HtmlFileStream methodsFor: 'all' stamp: 'di 6/28/97 21:49'!header	"append the HTML header.  Be sure to call trailer after you put out the data.	4/4/96 tk"	| cr |	cr _ String with: Character cr.	self command: 'HTML'; verbatim: cr.	self command: 'HEAD'; verbatim: cr.	self command: 'TITLE'.	self nextPutAll: '"', self name, '"'.	self command: '/TITLE'; verbatim: cr.	self command: '/HEAD'; verbatim: cr.	self command: 'BODY'; verbatim: cr.! !!HtmlFileStream methodsFor: 'all' stamp: 'di 6/28/97 21:43'!nextChunk	"Answer the contents of the receiver, up to the next terminator character (!!).  Imbedded terminators are doubled.  Undo and strip out all Html stuff in the stream and convert the characters back.  4/12/96 tk"	| out char did rest |	self skipSeparators.	"Absorb <...><...> also"	out _ WriteStream on: (String new: 500).	[self atEnd] whileFalse: [		self peek = $< ifTrue: [self unCommand].	"Absorb <...><...>"		(char _ self next) = $&			ifTrue: [				rest _ self upTo: $;.				did _ out position.				rest = 'lt' ifTrue: [out nextPut: $<].				rest = 'gt' ifTrue: [out nextPut: $>].				rest = 'amp' ifTrue: [out nextPut: $&].				did = out position ifTrue: [					self error: 'new HTML char encoding'.					"Please add it to this code"]]			ifFalse: [char = $!!	"terminator"				ifTrue: [					self peek = $!! ifFalse: [^ out contents].					out nextPut: self next]	"pass on one $!!"				ifFalse: [char asciiValue = 9							ifTrue: [self next; next; next; next "TabThing"].						out nextPut: char]]		].	^ out contents! !!HtmlFileStream methodsFor: 'all' stamp: 'di 6/28/97 21:59'!nextPut: char	"Put a character on the file, but translate it first. 4/6/96 tk"	char = $< ifTrue: [^ super nextPutAll: '&lt;'].	char = $> ifTrue: [^ super nextPutAll: '&gt;'].	char = $& ifTrue: [^ super nextPutAll: '&amp;'].	char asciiValue = 13 "return" ifTrue: [			self command: 'br'].	char = $	"tab" ifTrue:		[super nextPut: char.  ^ self verbatim: TabThing].	^ super nextPut: char! !!HtmlFileStream class methodsFor: 'as yet unclassified' stamp: 'di 6/28/97 21:31'!initialize   "HtmlFileStream initialize"	TabThing _ String		with: (Character value: 1)		with: (Character value: 32)		with: (Character value: 1)		with: (Character value: 32)! !HTMLformatter class (instances don't know anything) knows alot about HTML formatting: Creating forms, pages, different widgets, etc.  It also knows how to process Smalltalk embedded within an HTML document.!!HTMLformatter class methodsFor: 'pages and forms' stamp: 'mjg 10/31/97 16:00'!endForm	^ '</FORM>'! !!HTMLformatter class methodsFor: 'pages and forms' stamp: 'mjg 10/31/97 15:58'!endPage	| stream |	stream _ WriteStream on: ''.	stream nextPutAll: '</BODY>';cr;	 nextPutAll: '</HTML>';cr.	^stream contents! !!HTMLformatter class methodsFor: 'pages and forms' stamp: 'mjg 10/31/97 15:59'!startForm: action	| stream |	stream _ WriteStream on: ''.	stream nextPutAll: '<FORM METHOD="POST" ACTION="', action, '">';	 cr.	^ stream contents! !!HTMLformatter class methodsFor: 'pages and forms' stamp: 'mjg 10/31/97 15:57'!startPage: title	| stream |	stream _ WriteStream on: ''.	stream nextPutAll: '<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">'; cr;	 nextPutAll: '<HTML>';cr;	 nextPutAll: '<HEAD>';cr;	 nextPutAll: '<TITLE>'; nextPutAll: title; nextPutAll: '</TITLE>';cr;	 nextPutAll: '<BODY>'; cr. 	^ stream contents! !!HTMLformatter class methodsFor: 'translating' stamp: 'mjg 11/4/97 16:23'!evalEmbedded: stringOrStream with: request	| sourceStream targetStream evalStream currentStream evalValue peekValue ch |	(stringOrStream isKindOf: Stream)		ifTrue: [sourceStream := stringOrStream]		ifFalse: [sourceStream := ReadStream on: stringOrStream].	targetStream := WriteStream on: String new.	currentStream := targetStream. 	[sourceStream atEnd] whileFalse: 		[ch := sourceStream next.		ch = $< ifTrue:			[ peekValue := sourceStream peek. (peekValue = $?) ifTrue:				[evalStream := WriteStream on: String new.				currentStream := evalStream.				sourceStream next. "Eat the ?"				ch := sourceStream next.]].		((currentStream = evalStream) and: [ch = $?]) ifTrue:			[ peekValue := sourceStream peek. (peekValue = $>) ifTrue:				[sourceStream next. "Eat the >"				currentStream := targetStream.				evalValue := (Compiler new evaluate: (evalStream contents) 					in: thisContext to: self notifying: nil ifFail: [^nil]).				(evalValue isKindOf: String)				ifFalse: [evalValue := evalValue printString].				currentStream nextPutAll: evalValue.]]			ifFalse: [currentStream nextPut: ch].].	^targetStream contents! !!HTMLformatter class methodsFor: 'translating' stamp: 'mjg 11/25/97 11:50'!fixEndings: aStringOrStream	| sourceStream targetStream aLine |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	targetStream := ReadWriteStream on: String new. 	[sourceStream atEnd] whileFalse:	[aLine := sourceStream upTo: (Character linefeed).	targetStream nextPutAll: aLine.	targetStream nextPut: Character cr.].	^targetStream! !!HTMLformatter class methodsFor: 'translating' stamp: 'tk 1/14/98 10:30'!rangesOfAngleBrackets: sourceStrm	"Return an OrderedCollection of intervals of position within angle brackets < and >.  Caller wants to avoid putting <br> in there."	| list char intervals start |	list _ OrderedCollection new: 10.	[sourceStrm atEnd] whileFalse: [		(char _ sourceStrm next) == $< ifTrue: [list add: sourceStrm position].	"a start"		char == $> ifTrue: [list add: sourceStrm position negated]].	"an end"	sourceStrm reset.	intervals _ OrderedCollection new: 10.	start _ nil.	list do: [:each |		(each > 0) & (start == nil) ifTrue: [start _ each].		(each < 0) & (start ~~ nil) ifTrue: [			intervals add: (start to: each negated). start _ nil]].	^ intervals	"	HTMLformatter rangesOfAngleBrackets: (ReadStream on: '1234 <good> <456 <good> 567> <ok>')	"! !!HTMLformatter class methodsFor: 'translating' stamp: 'mjg 11/10/97 12:38'!simpleProcess: aStringOrStream	| sourceStream targetStream ch |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	targetStream := WriteStream on: String new. 	[sourceStream atEnd] whileFalse:	[ch := sourceStream next.	(ch = Character linefeed) ifTrue:		[(sourceStream peek) = (Character linefeed)		ifTrue: [sourceStream next. targetStream nextPutAll: '<p>']		ifFalse: [targetStream nextPutAll: '<br>']].	targetStream nextPut: ch].	^targetStream contents.! !!HTMLformatter class methodsFor: 'translating' stamp: 'tk 1/14/98 10:49'!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new. 	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character linefeed).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: '*' startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = $* 			ifTrue: [aLine _ aLine copyReplaceFrom: start to: start+1 with: '*'.					start_start + 1.]			ifFalse: [				(end _ aLine indexOfSubCollection: '*' startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom: start to: end						with: (aBlock value: (aLine copyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1 			ifTrue: [targetStream nextPutAll: '<hr>']			ifFalse: [targetStream nextPutAll: aLine].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in a separator"		forbidden do: [:interval | 			(interval includes: sourceStream position) ifTrue: [ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character linefeed)				ifTrue: [sourceStream next. targetStream nextPutAll: '<p>']				ifFalse: [targetStream nextPutAll: '<br>']]].	^targetStream contents.! !!HTMLformatter class methodsFor: 'translating' stamp: 'mjg 12/8/97 11:37'!textToGIF: oneLineString	| form filename |	form _ (Form extent: 400@20 depth: Display depth) fillWhite.	oneLineString displayOn: form at: 2@0. "form display."	filename _ 'f',(SmallInteger maxVal atRandom) printString,'.gif'.	GIFReadWriter putForm: form onFileNamed: filename.	^(FileStream fileNamed: filename) contentsOfEntireFile	! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 10/31/97 15:48'!checkbox: buttonname value: b 	^ '<INPUT TYPE="checkbox" NAME="' , buttonname , '"' , (b			ifTrue: [' CHECKED ']			ifFalse: ['']) , '>'! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 10/24/97 16:56'!formFooter	"Write the standard footer for a form."	self reply: '<hr><input type=reset value="Reset"> <input type=submit value="OK"></form>'! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 10/24/97 16:58'!formHeader: title For: aReference	"Write the standard header for a page and form for editing anObject."	self		title: title;		reply: '<form action="',aReference,'" method=post><table>'! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 10/31/97 15:54'!graphic: f	^self graphic: f standIn: 'Picture' alignment: 'right'! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 10/31/97 15:53'!graphic: f standIn: s alignment: a 	^ '<IMG SRC="' , f , '" ALT="' , s , '" ALIGN=' , a printString , '>'! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 10/31/97 15:55'!hiddenName: n value: v 	^ '<INPUT TYPE="hidden" NAME="' , n , '" VALUE="' , v asString , '">'! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 10/31/97 16:02'!linkTo: url label: label	^'<A HREF="',url,'">',label,'</A>'.! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 10/31/97 15:50'!select: n values: values selection: selection size: size 	^ self		select: n		values: values		selections: (Array with: selection)		size: size		multiple: false! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 10/31/97 15:49'!select: buttonname values: values selections: selections size: size multiple: multiple 	| stream |	stream _ WriteStream on: ''.	stream nextPutAll: '<SELECT NAME="' , buttonname , '"' , (multiple				ifTrue: [' MULTIPLE']				ifFalse: ['']) , ' SIZE=' , size printString , '>';	 cr.	values do: 		[:value | 		stream nextPutAll: '<OPTION'.		(selections includes: value)			ifTrue: [stream nextPutAll: ' SELECTED'].		stream nextPutAll: '>'.		stream nextPutAll: value;		 cr].	stream nextPutAll: '</SELECT>'.	^ stream contents! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 10/31/97 15:53'!submit: label	^ self submit: 'submit' label: label! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 10/31/97 15:52'!submit: buttonName label: v 	^ '<INPUT TYPE="submit" NAME="' , buttonName , '" VALUE="' , v , '">'! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 10/31/97 15:51'!text: fieldName	^ self text: fieldName value: '' length: 80.! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 10/31/97 15:51'!text: fieldName value: v length: l 	^ '<INPUT TYPE="text" NAME="' , fieldName , '" VALUE="' , v , '" MAXLENGTH=' , l printString , '>'! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 11/4/97 14:30'!textArea: fieldName	^ (self textAreaStart: fieldName rows: 15 cols: 70), self textAreaEnd! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 11/4/97 14:30'!textArea: fieldName value: value	^ (self textAreaStart: fieldName rows: 15 cols: 70), value, self textAreaEnd! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 11/4/97 14:28'!textAreaEnd	^ '</TEXTAREA>'! !!HTMLformatter class methodsFor: 'formatting' stamp: 'mjg 11/4/97 14:28'!textAreaStart: fieldName rows: rows cols: cols 	^ '<TEXTAREA NAME="', fieldName, ' ROWS=',rows,' COLS=',cols,'>'! !!HTMLformatter class methodsFor: 'note support' stamp: 'mjg 11/18/97 09:38'!show: aCollection	"Return an HTML list to reference an ordered collection of text. Used in Chat application"	| ret |	ret _ WriteStream on: String new.	ret nextPutAll: '<ul>' ; cr.	1 to: aCollection size do: [:each |		ret nextPutAll: '<li>'.		ret nextPutAll: (aCollection at: each).].	ret nextPutAll: '</ul>'.	^ret contents! !!HTMLformatter class methodsFor: 'note support' stamp: 'mjg 11/19/97 10:48'!showList: aCollection	"Return an HTML list to reference an ordered collection of notes. 	prefix.index will be the reference URL for the note. Used in Comment 	application. "	| ret aNote |	ret _ WriteStream on: String new.	ret nextPutAll: '<ul>';	 cr.	1 to: aCollection size do: 		[:each | 		ret nextPutAll: '<li>'.		aNote _ aCollection at: each.		ret nextPutAll: (self linkTo: (aNote url) label: aNote title).		ret nextPutAll: ' ' , aNote author , ' ' , aNote timestamp;		 cr.		aNote children size > 0 ifTrue: [ret nextPutAll: (self showList: aNote children)]].	ret nextPutAll: '</ul>'.	^ ret contents! !!HTMLformatter class methodsFor: 'note support' stamp: 'mjg 11/18/97 09:38'!showList: aCollection parentPrefix: prefix	"Return an HTML list to reference an ordered collection of notes. prefix.parent.index will be the reference URL for the note."	| ret aNote |	ret _ WriteStream on: String new.	ret nextPutAll: '<ul>' ; cr.	1 to: aCollection size do: [:each |		ret nextPutAll: '<li>'.		aNote := aCollection at: each.		ret nextPutAll: (self linkTo: (prefix , aNote parent, '.', each printString) label: (aNote title)), '-'.		ret nextPutAll: (self linkTo: (aNote author homepage) label: aNote author name)			,'-',aNote timestamp ; cr.		aNote children size > 0 ifTrue: 			[ret nextPutAll: (self showList: aNote children prefix: (prefix , each printString))].].	ret nextPutAll: '</ul>'.	^ret contents! !!HTMLformatter class methodsFor: 'note support' stamp: 'mjg 11/18/97 09:38'!showList: aCollection prefix: prefix	"Return an HTML list to reference an ordered collection of notes. prefix.index will be the reference URL for the note. Used in Comment application."	| ret aNote |	ret _ WriteStream on: String new.	ret nextPutAll: '<ul>' ; cr.	1 to: aCollection size do: [:each |		ret nextPutAll: '<li>'.		aNote := aCollection at: each.		ret nextPutAll: (self linkTo: (prefix , each printString) label: (aNote title)).		ret nextPutAll: ' ',aNote author,' ',aNote timestamp ; cr.		aNote children size > 0 ifTrue: 			[ret nextPutAll: (self showList: aNote children prefix: (prefix , each printString))].].	ret nextPutAll: '</ul>'.	^ret contents! !!HTMLformatter class methodsFor: 'note support' stamp: 'mjg 11/19/97 10:48'!showListWithAuthors: aCollection	"Return an HTML list to reference an ordered collection of notes. 	prefix.index will be the reference URL for the note. Special version for 	linking to author's homepage, if any."	| ret aNote |	ret _ WriteStream on: String new.	ret nextPutAll: '<ul>';	 cr.	1 to: aCollection size do: 		[:each | 		ret nextPutAll: '<li>'.		aNote _ aCollection at: each.		ret nextPutAll: (self linkTo: (aNote url) label: aNote title)				, '-'.		ret nextPutAll: (self linkTo: aNote author homepage label: aNote author name)				, '-' , aNote timestamp;		 cr.		aNote children size > 0 ifTrue: [ret nextPutAll: (self showListWithAuthors: aNote children)]].	ret nextPutAll: '</ul>'.	^ ret contents! !!HTMLformatter class methodsFor: 'note support' stamp: 'mjg 11/18/97 09:38'!showListWithAuthors: aCollection prefix: prefix	"Return an HTML list to reference an ordered collection of notes. prefix.index will be the reference URL for the note. Special version for linking to author's homepage, if any."	| ret aNote |	ret _ WriteStream on: String new.	ret nextPutAll: '<ul>' ; cr.	1 to: aCollection size do: [:each |		ret nextPutAll: '<li>'.		aNote := aCollection at: each.		ret nextPutAll: (self linkTo: (prefix , each printString) label: (aNote title)),'-'.		ret nextPutAll: (self linkTo: (aNote author homepage) label: aNote author name)			,'-',aNote timestamp ; cr.		aNote children size > 0 ifTrue: 			[ret nextPutAll: (self showList: aNote children prefix: (prefix , each printString))].].	ret nextPutAll: '</ul>'.	^ret contents! !HTTPSockets support HTTP requests, either directly or via an HTTP proxy server. An HTTPSocket saves the parse of the last ASCII header it saw, to avoid having to parse it repeatedly.The real action is in httpGet:accept:.  See the examples in the class, especially httpFileInNewChangeSet: and httpShowGif:.!]style[(206 15 45 23 5 13)f1,f1LHTTPSocket class httpGet:accept:;,f1,f1LHTTPSocket class httpFileInNewChangeSet:;,f1,f1LHTTPSocket class httpShowGif:;!!HTTPSocket methodsFor: 'all' stamp: 'jm 9/15/97 11:35'!contentsLength: header	"extract the data length from the header.  Content-length: 1234<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens _ header findTokens: ParamDelimiters keep: (String with: CR).	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $c and: [this asLowercase = 'content-length:']) ifTrue: [			^ (headerTokens at: ii+1) asNumber]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'jm 9/27/97 13:28'!getResponseUpTo: markerString	"Keep reading until the marker is seen.  Return three parts: header, marker, beginningOfData.  Fails if no marker in first 2000 chars." 	| buf response bytesRead tester mm |	buf _ String new: 2000.	response _ WriteStream on: buf.	tester _ 1. mm _ 1.	[tester to: response position do: [:tt |		(buf at: tt) = (markerString at: mm) ifTrue: [mm _ mm + 1] ifFalse: [mm _ 1].			"Not totally correct for markers like xx0xx"		mm > markerString size ifTrue: ["got it"			^ Array with: (buf copyFrom: 1 to: tt+1-mm)				with: markerString				with: (buf copyFrom: tt+1 to: response position)]].	 tester _ 1 max: response position.	"OK if mm in the middle"	 (response position < buf size) & (self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: response position + 1 count: buf size - response position.		"response position+1 to: response position+bytesRead do: [:ii | 			response nextPut: (buf at: ii)].	totally redundant, but needed to advance position!!"		response instVarAt: 2 "position" put: 			(response position + bytesRead)].	"horrible, but fast"	^ Array with: response contents		with: ''		with: ''		"Marker not found and connection closed"! !!HTTPSocket methodsFor: 'all' stamp: 'jm 9/27/97 13:28'!getRestOfBuffer: beginning totalLength: length	"Reel in a string of a fixed length.  Part of it has already been received.  Close the connection after all chars are received.  We do not strip out linefeed chars.  tk 6/16/97 22:32" 	| buf response bytesRead |	length isInteger ifFalse: [self error: 'header parsed wrongly'].	buf _ String new: length.	response _ RWBinaryOrTextStream on: buf.	response nextPutAll: beginning.	[(response position < length) & (self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: response position + 1 count: buf size - response position.		"bytesRead = 0 ifTrue: [self error: 'why no data?']."		"response position+1 to: response position+bytesRead do: [:ii | 			response nextPut: (buf at: ii)].	totally redundant, but needed to advance position!!"		response instVarAt: 2 "position" put: 			(response position + bytesRead)].	"horrible, but fast"	Transcript cr; show: 'data byte count: ', response position printString.	Transcript cr; show: ((self isConnected) ifTrue: ['Over length by: ', bytesRead printString] 		ifFalse: ['Socket closed']). 	"response text.	is already a text stream"	response reset.	"position: 0."	^ response! !!HTTPSocket methodsFor: 'all' stamp: 'jm 9/26/97 18:28'!redirect	"See if the header has a 'Location: url CrLf' in it.  If so, return the new URL of this page.  tk 6/24/97 18:03"	| this |	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $l and: [this asLowercase = 'location:']) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'jm 9/15/97 11:30'!initialize	"HTTPSocket initialize"	ParamDelimiters _ ' ', CrLf.	HTTPPort _ 80.	HTTPProxy _ nil.	HTTPBlabEmail _ ''.  "	'From: tedk@disney.com', CrLf	"! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 10/4/97 16:11'!httpFileIn: url	"Do a regular file-in of a file that is served from a web site.  If the file contains an EToy, then open it.  Might just be code instead.  tk 7/23/97 17:10"	"Notes: To store a file on an HTTP server, use the program 'Fetch'.  After indicating what file to store, choose 'Raw Data' from the popup menu that has MacBinary/Text/etc.  Use any file extension as long as it is not one of the common ones.  The server does not have to know about the .sqo extension in order to send your file.  (We do not need a new MIME type and .sqo does not have to be registered with the server.)"	"	HTTPSocket httpFileIn: 'www.webPage.com/~kaehler2/sample.etoy'	 "	"	HTTPSocket httpFileIn: '206.18.68.12/squeak/car.sqo'	 "	"	HTTPSocket httpFileIn: 'jumbo/tedk/sample.etoy'	 "	| doc eToyHolder |	doc _ self httpGet: url accept: 'application/octet-stream'.	doc class == String ifTrue: [			PopUpMenu notify: 'Cannot seem to contact the web site'].	doc reset.	eToyHolder _ doc fileInObjectAndCode.	eToyHolder ifNotNil: [eToyHolder open].	"Later may want to return it, instead of open it"! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 12/17/97 22:16'!httpFileInNewChangeSet: url	"Do a regular file-in of a file that is served from a web site.  Put it into a new changeSet."	"Notes: To store a file on an HTTP server, use the program 'Fetch'.  After indicating what file to store, choose 'Raw Data' from the popup menu that has MacBinary/Text/etc.  Use any file extension as long as it is not one of the common ones."	"	HTTPSocket httpFileInNewChangeSet: '206.18.68.12/squeak/updates/83tk_test.cs'	 "	| doc |	doc _ self httpGet: url accept: 'application/octet-stream'.	doc class == String ifTrue: [			PopUpMenu notify: 'Cannot seem to contact the web site'].	doc reset.	ChangeSorter newChangesFromStream: doc				named: (url findTokens: '/') last.! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 11/4/97 08:25'!httpGet: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGet: url accept: 'application/octet-stream'! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 10/23/97 14:28'!httpGet: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	| serverName serverAddr s header length bare page list firstData aStream newURL |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	"For now, may not put :80 or other port number in a url.  Use setHTTPPort:"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxy ifNotNil: [		page _ 'http://', serverName, page.		"put back together"		serverName _ HTTPProxy].		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: HTTPPort.  "80 is normal"	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: serverName; cr.	s sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		'User-Agent: Squeak 1.19', 		CrLf.	"blank line"	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: header; cr.	firstData _ list at: 3.	"Find the length"	length _ s contentsLength: header.	"saves the headerTokens"	length ifNil: [		(newURL _ s redirect) ifNotNil: [^ self httpGet: newURL accept: mimeType].		Transcript cr; show: 'Some kind of Error'.		s destroy.   ^ header].		aStream _ s getRestOfBuffer: firstData totalLength: length.	s destroy.	"Always OK to destroy!!"	^ aStream	"String with just the data"! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 10/15/97 12:07'!httpGif: url	"Fetch the given URL, parse it using the GIF reader, and return the resulting Form."	"	HTTPSocket httpShowGif: 'www.altavista.digital.com/av/pix/default/av-adv.gif'	 "	"	HTTPSocket httpShowGif: 'www.webPage.com/~kaehler2/ainslie.gif'	 "	| doc ggg |	doc _ self httpGet: url accept: 'image/gif'.	doc class == String ifTrue: [		self inform: 'The server with that GIF is not responding'.		^ ColorForm extent: 20@20 depth: 8].	doc binary; reset.	(ggg _ Smalltalk gifReaderClass new) setStream: doc.	^ ggg nextImage.! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 9/15/97 12:18'!httpShowGif: url	"Display the picture retrieved from the given URL, which is assumed to be a GIF file. See examples in httpGif:."	| nameTokens |	nameTokens _ url findTokens: '/'.	FormView open: (self httpGif: url) named: nameTokens last.! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 9/26/97 18:32'!httpShowPage: url	"Display the exact contents of the given URL as text. See examples in httpGet:"	| doc |	doc _ (self httpGet: url accept: 'application/octet-stream') contents.	doc size = 0 ifTrue: [^ self error: 'Document could not be fetched'].	StringHolderView		open: (StringHolder new contents: doc)		label: url.! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 9/15/97 12:06'!proxyTestingComment	"Test Kevin's SmartCache on this machine"	"	HTTPSocket useProxyServerNamed: '127.0.0.1' port: 8080.		HTTPSocket httpShowPage: 'http://www.disneyblast.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test getting to outside world from DOL"	"	HTTPSocket useProxyServerNamed: 'web-proxy.online.disney.com' port: 8080.		HTTPSocket httpShowPage: 'http://www.apple.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test Windows Machine in our cubicle at DOL"	"	HTTPSocket useProxyServerNamed: '206.18.67.150' port: 8080.		HTTPSocket httpShowPage: 'http://kids.online.disney.com/~kevin/squeak/k_t.morph'.		HTTPSocket stopUsingProxyServer.	"	"	HTTPSocket httpShowPage: 'kids.online.disney.com/'	"	"	HTTPSocket httpShowGif: 'kids.online.disney.com/~kevin/images/dlogo.gif'	"! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'tk 10/21/97 13:01'!setProxyIfInDOL	"Test to see if we are inside DOL.  If so, set the proxy server."| me myNet |NetNameResolver initializeNetwork.NetNameResolver addressForName: 'www.disney.com' timeout: 5.	"Just to make sure the ISND line is started"me _ NetNameResolver localHostAddress.myNet _ (me copyFrom: 1 to: 3) asArray.#( (204 128 192) (206 18 91) ) do: [:dolNet |		myNet = dolNet ifTrue: ["We are inside DOL"			^ self useProxyServerNamed: 'web-proxy.online.disney.com' port: 8080]]."We are not inside DOL"HTTPProxy = 'web-proxy.online.disney.com' ifTrue: [	"No longer there, stop the proxy"	^ self stopUsingProxyServer].! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'jm 9/15/97 12:06'!stopUsingProxyServer	"Stop directing HTTP request through a proxy server."	HTTPProxy _ nil.	HTTPPort _ 80.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'jm 9/15/97 12:06'!useProxyServerNamed: proxyServerName port: portNum	"Direct all HTTP requests to the HTTP proxy server with the given name and port number."	proxyServerName ifNil: [  "clear proxy settings"		HTTPProxy _ nil.		HTTPPort _ 80.		^ self].	proxyServerName class == String		ifFalse: [self error: 'Server name must be a String or nil'].	HTTPProxy _ proxyServerName.	HTTPPort _ portNum.	HTTPPort class == String ifTrue: [HTTPPort _ portNum asNumber].	HTTPPort ifNil: [HTTPPort _ 80].! !!HTTPSocket class methodsFor: 'utilities' stamp: 'jm 9/15/97 11:10'!retry: tryBlock asking: troubleString ifGiveUp: abortActionBlock	"Execute the given block. If it evaluates to true, return true. If it evaluates to false, prompt the user with the given string to see if he wants to try again. If not, evaluate the abortActionBlock and return false."	| response |	[tryBlock value] whileFalse: [		response _ (PopUpMenu labels: 'Retry\Give Up' withCRs)			startUpWithCaption: troubleString.		response = 2 ifTrue: [abortActionBlock value. ^ false]].	^ true! !!IdentityDictionary methodsFor: 'private' stamp: 'di 10/1/97 20:51'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet _ IdentitySet new: self size.	self keysDo: [:key | aSet add: key].	^ aSet! !!IdentityDictionary methodsFor: 'private'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject identityHash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!IdentitySet methodsFor: 'private'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject identityHash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!ImageMorph methodsFor: 'all' stamp: 'di 11/4/97 09:03'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'read from file' action: #readFromFile.	aCustomMenu add: 'grab from screen' action: #grabFromScreen.! !!ImageMorph methodsFor: 'all'!drawOn: aCanvas	aCanvas image: image at: bounds origin! !!ImageMorph methodsFor: 'all'!extent	^ image extent! !!ImageMorph methodsFor: 'all'!extent: aPoint	super extent: image extent! !!ImageMorph methodsFor: 'all'!grabFromScreen	self image: Form fromUser! !!ImageMorph methodsFor: 'all' stamp: 'jm 9/27/97 20:16'!image	^ image! !!ImageMorph methodsFor: 'all' stamp: 'jm 12/2/97 15:30'!image: anImage	| oldExtent |	image == nil		ifTrue: [oldExtent _ nil]		ifFalse: [oldExtent _ image extent].	self changed.	anImage depth = 1		ifTrue: [image _ ColorForm mappingWhiteToTransparentFrom: anImage]		ifFalse: [image _ anImage].	oldExtent = anImage extent		ifFalse: [super extent: image extent].! !!ImageMorph methodsFor: 'all'!initialize	| d h p |	super initialize.	self image: (Form extent: 80@40 depth: Display depth).	h _ image height // 2.	0 to: h-1 do: 		[:i | p _ (i*2)@i.  d _ i asFloat / h asFloat.		image fill: (p corner: image extent - p) fillColor: (Color r: d g: 0.5 b: 1.0-d)]! !!ImageMorph methodsFor: 'all' stamp: 'sw 11/5/97 12:08'!partNamesAndTypesForViewer	"Return an array of part names and part types for use in a viewer on the receiver""		name		type		r/w			get selector			put selector		-----------	---------		-----------	---------------------	-------------   "	^ #(		(name		string		readWrite	externalName		renameTo:)		(x 			number		readWrite	x					x:)		(y			number		readWrite	y					y:)		(colorUnder	color		readOnly	colorUnder			unused))! !!ImageMorph methodsFor: 'all'!readFromFile	self readFromFileNamed:		(FillInTheBlank request: 'Please enter the image file name'					initialAnswer: 'fileName')! !!ImageMorph methodsFor: 'all'!readFromFileNamed: fName	| file fileCode form |	file _ FileStream readOnlyFileNamed: fName.	fileCode _ file next asciiValue.	file close.	form _ (fileCode = 2		ifTrue: [Form newFromFileNamed: fName]		ifFalse: [Smalltalk gifReaderClass formFromFileNamed: fName]).	self image: form.! !!InfiniteForm methodsFor: 'accessing' stamp: 'di 9/2/97 20:21'!dominantColor	^ patternForm dominantColor! !!InfiniteForm methodsFor: 'displaying' stamp: 'jm 10/18/97 12:34'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"This is the real display message, but it doesn't get used until the new	display protocol is installed."	| targetBox patternBox bb |	(patternForm isKindOf: Form) ifFalse:		[^ aDisplayMedium fill: clipRectangle rule: ruleInteger fillColor: patternForm].	"Do it iteratively"	targetBox _ aDisplayMedium boundingBox intersect: clipRectangle.	patternBox _ patternForm boundingBox.	bb _ BitBlt destForm: aDisplayMedium sourceForm: patternForm fillColor: aForm		combinationRule: ruleInteger destOrigin: 0@0 sourceOrigin: 0@0		extent: patternBox extent clipRect: clipRectangle.	bb colorMap:		(patternForm colormapIfNeededForDepth: aDisplayMedium depth).	(targetBox left truncateTo: patternBox width)		to: targetBox right - 1 by: patternBox width do:		[:x |		(targetBox top truncateTo: patternBox height)			to: targetBox bottom - 1 by: patternBox height do:			[:y |			bb destOrigin: x@y; copyBits]]! !!InfiniteForm methodsFor: 'displaying' stamp: 'jm 11/2/97 17:08'!displayOnPort: aPort at: offset	| targetBox patternBox savedMap top left |	(patternForm isKindOf: Form) ifFalse: [		"patternForm is a Pattern or Color; just use it as a mask for BitBlt"		^ aPort fill: aPort clipRect fillColor: patternForm rule: Form over].	"do it iteratively"	targetBox _ aPort clipRect.	patternBox _ patternForm boundingBox.	savedMap _ aPort colorMap.	aPort		sourceForm: patternForm;		fillColor: nil;		combinationRule: Form over;		sourceRect: (0@0 extent: patternBox extent);		colorMap: (patternForm colormapIfNeededForDepth: aPort destForm depth).	top _ (targetBox top truncateTo: patternBox height) - (offset y \\ patternBox height).	left _  (targetBox left truncateTo: patternBox width) - (offset x \\ patternBox width).	left to: (targetBox right - 1) by: patternBox width do: [:x |		top to: (targetBox bottom - 1) by: patternBox height do: [:y |			aPort				destOrigin: x@y;				copyBits]].	aPort colorMap: savedMap.! !!InputSensor methodsFor: 'keyboard' stamp: 'di 10/29/97 20:20'!kbdTest    "Sensor kbdTest"	"This test routine will print the unmodified character, its keycode,	and the OR of all its modifier bits, until the character x is typed"	| char |	char _ nil.	[char = $x] whileFalse: 		[[self keyboardPressed] whileFalse: [].		char _ self characterForKeycode: self keyboard.		(String streamContents: 			[:s | s nextPut: char; space; print: char asciiValue;					space; print: self primMouseButtons; nextPutAll: '     '])			displayAt: 10@10]! !!InputSensor methodsFor: 'joystick'!joystickButtons: index	^ ((self primReadJoystick: index) bitShift: -22) bitAnd: 16r71F	! !!InputSensor methodsFor: 'joystick'!joystickOn: index	^ (((self primReadJoystick: index) bitShift: -27) bitAnd: 1) ~= 0	! !!InputSensor methodsFor: 'joystick'!joystickXY: index	| inputWord x y |	inputWord _ self primReadJoystick: index.	x _ (inputWord bitAnd: 16r7FF) - 16r400.	y _ ((inputWord bitShift: -11) bitAnd: 16r7FF) - 16r400.	^ x@y	! !!InputSensor methodsFor: 'user interrupts' stamp: 'sw 9/29/97 17:14'!userInterruptWatcher	"Wait for user interrupts and open a notifier on the active process when one occurs."	[true] whileTrue:		[InterruptSemaphore wait.		Smalltalk shutDownSound.		ScheduledControllers maybeForkInterrupt]! !!InspectListController methodsFor: 'menu messages' stamp: 'sw 7/29/97 18:22'!browseClassRefs	"Inspect all instances of the selected class and all its subclasses"	| aClass |	self controlTerminate.	(aClass _ self classOfSelection) == nil ifFalse:		[aClass _ aClass theNonMetaClass.		 Smalltalk browseAllCallsOn: (Smalltalk associationAt: aClass name)].	self controlInitialize! !!InspectListController methodsFor: 'menu messages' stamp: 'sw 7/29/97 18:20'!browseClassVariables	"Request a browser on the class variables of the selected class.  2/1/96 sw"	| aClass |	self controlTerminate.	(aClass _ self classOfSelection) notNil ifTrue: 		[aClass browseClassVariables].	self controlInitialize! !!InspectListController methodsFor: 'menu messages' stamp: 'sw 7/29/97 18:19'!browseInstVarDefs	"Request a browser of methods that store into a chosen instance variable"	| aClass |	self controlTerminate.	(aClass _  self classOfSelection) notNil ifTrue: 		[aClass browseInstVarDefs].	self controlInitialize! !!InspectListController methodsFor: 'menu messages' stamp: 'sw 7/29/97 17:12'!browseInstVarRefs	"Request a browser of methods that access a chosen instance variable"	| aClass |	self controlTerminate.	(aClass _  self classOfSelection) notNil ifTrue: 		[aClass browseInstVarRefs].	self controlInitialize! !!InspectListController methodsFor: 'menu messages' stamp: 'sw 7/29/97 18:19'!classVarRefs	"Request a browser of methods that store into a chosen instance variable"	| aClass |	self controlTerminate.	(aClass _  self classOfSelection) notNil ifTrue: 		[aClass browseClassVarRefs].	self controlInitialize! !!InspectListController methodsFor: 'menu messages' stamp: 'tk 4/14/97'!copyName	"Copy the name of the current variable, so the user can paste it into the window below and work with is.  If collection, do (xxx at: 1). "	| sel aClass |	model selectionUnmodifiable ifTrue: [^ view flash].	(aClass _ model object class) isVariable ifTrue: [^ view flash].	sel _ aClass allInstVarNames at: model selectionIndex - 2.	(model selection isKindOf: Collection) ifTrue: [sel _ '(',sel,' at: 1)'].	ParagraphEditor new clipboardTextPut: sel asText.	"no undo allowed"! !!InspectListController methodsFor: 'menu messages' stamp: 'sw 7/28/97 17:15'!inspectSelection	"Create and schedule an Inspector on the receiver's model's currently 	selected object."	model selectionIndex = 0		ifTrue: [^view flash].	self controlTerminate.	^model selection smartInspect  "eliminate annoyance of 1-element collections"! !!InspectListController methodsFor: 'menu messages' stamp: 'sw 9/27/96'!objectReferencesToSelection	"Open a list inspector on all the objects that point to the value of the selected instance variable, if any.  "	model selectionIndex == 0 ifTrue: [^ view flash].	self controlTerminate.	Smalltalk		browseAllObjectReferencesTo: model selection		except: (Array with: model object)		ifNone: [:obj | view topView flash].! !!InspectListController methodsFor: 'menu mechanics' stamp: 'sw 7/29/97 17:34'!classOfSelection	"Answer the class of the receiver's current selection"	model selectionUnmodifiable ifTrue: [^ model object class].	^ model selection class! !!InspectListController methodsFor: 'menu mechanics' stamp: 'sw 7/29/97 17:26'!initializeYellowButtonMenu	self yellowButtonMenu: InspectListYellowButtonMenu		yellowButtonMessages: InspectListYellowButtonMessages! !!InspectListController methodsFor: 'menu mechanics' stamp: 'sw 7/29/97 17:29'!shiftedYellowButtonActivity: shiftMenu	"Present the alternate (shifted) menu and take action accordingly.  If we get here, shiftMenu is known to be non-nil.  "	| index  |	(index _ shiftMenu startUpWithCaption: self classOfSelection name) ~= 0		ifTrue:			[self menuMessageReceiver performMenuMessage: (self shiftedYellowButtonMessages at: index)]		ifFalse:			[super controlActivity]! !!InspectListController methodsFor: 'menu mechanics' stamp: 'sw 7/29/97 17:26'!shiftedYellowButtonMenu	^ ShiftedMenu! !!InspectListController methodsFor: 'menu mechanics' stamp: 'sw 7/29/97 17:26'!shiftedYellowButtonMessages	^ ShiftedMessages! !!InspectListController methodsFor: 'menu mechanics' stamp: 'sw 9/12/97 21:47'!startUpYellowButtonMenu	| object |	object _ model object.	^ (model selectionUnmodifiable or: [object isKindOf: Array])		ifTrue:			[super startUpYellowButtonMenu]		ifFalse:			[yellowButtonMenu startUpWithCaption: (model selectedSlotName, '(', model selection class name, ')')]! !!InspectListController class methodsFor: 'class initialization' stamp: 'sw 9/30/97 10:15'!initialize	"Initialize the menu associated with the upper-left pane of an Inspector"	InspectListYellowButtonMenu _ PopUpMenu labels: 'inspectmethod refs to this inst varobjects pointing to this valuecopy namebrowse fullbrowse classinst var refs...inst var defs...class var refs...class variablesclass refs'	lines: #(1 3 4     6 8 10 11 ).	InspectListYellowButtonMessages _ 		#(inspectSelection referencesToSelection objectReferencesToSelection copyName  browseFull browseClass  browseInstVarRefs browseInstVarDefs classVarRefs browseClassVariables browseClassRefs unshiftedYellowButtonActivity).	"InspectListController initialize"! !!Inspector methodsFor: 'accessing' stamp: 'sw 5/22/96'!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  "	^ 250 @ 200! !!Inspector methodsFor: 'accessing' stamp: 'sw 9/12/97 21:46'!selectedSlotName	^ object class allInstVarNames at: (self selectionIndex - 2)! !!Inspector class methodsFor: 'instance creation'!openOn: anObject withEvalPane: withEval 	"Create and schedule an instance of me on the model, anInspector. "	^ self openOn: anObject withEvalPane: withEval withLabel: anObject defaultLabelForInspector! !!Inspector class methodsFor: 'instance creation'!openOn: anObject withEvalPane: withEval withLabel: label	^ self openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: InspectCodeView! !!Inspector class methodsFor: 'instance creation'!openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	| topView inspector listView valueView evalView |	inspector _ self inspect: anObject.	topView _ StandardSystemView new model: inspector.	listView _ InspectListView new model: inspector.		(inspector isMemberOf: DictionaryInspector)			ifTrue: [listView controller: DictionaryListController new].		listView window: (0 @ 0 extent: 40 @ 40).		listView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.		topView addSubView: listView.	valueView _ valueViewClass new model: inspector.		valueView window: (0 @ 0 extent: 75 @ 40).		valueView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.		topView addSubView: valueView toRightOf: listView.withEval ifTrue:	[evalView _ StringHolderView new					model: (InspectorTrash for: inspector object).		evalView window: (0 @ 0 extent: 115 @ 20).		evalView borderWidthLeft: 2 right: 2 top: 0 bottom: 2.		topView addSubView: evalView below: listView].	topView label: label.	topView minimumSize: 180 @ 120.	topView controller open! !!InstructionStream methodsFor: 'testing' stamp: 'sn 8/22/97 21:55'!willReallySend	"Answer whether the next bytecode is a real message-send,	not blockCopy:."	| byte |	byte _ self method at: pc.	byte < 128 ifTrue: [^false].	byte == 200 ifTrue: [^false].	byte >= 176 ifTrue: [^true].	"special send or short send"	^byte between: 131 and: 134	"long sends"! !!InstructionStream methodsFor: 'scanning'!addSelectorTo: set 	"If this instruction is a send, add its selector to set."	| byte literalNumber byte2 |	byte _ self method at: pc.	byte < 128 ifTrue: [^self].	byte >= 176		ifTrue: 			["special byte or short send"			byte >= 208				ifTrue: [set add: (self method literalAt: (byte bitAnd: 15) + 1)]				ifFalse: [set add: (Smalltalk specialSelectorAt: byte - 176 + 1)]]		ifFalse: 			[(byte between: 131 and: 134)				ifTrue: 					[byte2 _ self method at: pc + 1.					byte = 131 ifTrue: [set add: (self method literalAt: byte2 \\ 32 + 1)].					byte = 132 ifTrue: [byte2 < 64 ifTrue: [set add: (self method literalAt: (self method at: pc + 2) + 1)]].					byte = 133 ifTrue: [set add: (self method literalAt: byte2 \\ 32 + 1)].					byte = 134 ifTrue: [set add: (self method literalAt: byte2 \\ 64 + 1)]]]! !!InstructionStream methodsFor: 'scanning'!scanFor: scanBlock 	"Answer the index of the first bytecode for which scanBlock answer true 	when supplied with that bytecode."	| method end byte type |	method _ self method.	end _ method endPC.	[pc <= end]		whileTrue: 			[(scanBlock value: (byte _ method at: pc)) ifTrue: [^true].			type _ byte // 16.			pc _ 				type = 8					ifTrue: ["extensions"							pc + (#(2 2 2 2 3 2 2 1 1 1 ) at: byte \\ 16 + 1)]					ifFalse: [type = 10								ifTrue: [pc + 2"long jumps"]								ifFalse: [pc + 1]]].	^false! !!InstructionStream methodsFor: 'scanning'!thirdByte	"Answer the next bytecode."	^self method at: pc + 2! !!InstructionStream methodsFor: 'private'!interpretExtension: offset in: method for: client	| type offset2 byte2 byte3 |	offset <=6 ifTrue: 		["Extended op codes 128-134"		byte2 _ method at: pc.		pc _ pc + 1.		offset <= 2 ifTrue:			["128-130:  extended pushes and pops"			type _ byte2 // 64.			offset2 _ byte2 \\ 64.			offset = 0 ifTrue: 				[type = 0 ifTrue: [^ client pushReceiverVariable: offset2].				type = 1 ifTrue: [^ client pushTemporaryVariable: offset2].				type = 2  ifTrue: [^ client pushConstant: (method literalAt: offset2 + 1)].				type = 3 ifTrue: [^ client pushLiteralVariable: (method literalAt: offset2 + 1)]].			offset = 1 ifTrue: 				[type = 0 ifTrue: [^ client storeIntoReceiverVariable: offset2].				type = 1 ifTrue: [^ client storeIntoTemporaryVariable: offset2].				type = 2 ifTrue: [self error: 'illegalStore'].				type = 3 ifTrue: [^ client storeIntoLiteralVariable: (method literalAt: offset2 + 1)]].			offset = 2 ifTrue: 				[type = 0 ifTrue: [^ client popIntoReceiverVariable: offset2].				type = 1 ifTrue: [^ client popIntoTemporaryVariable: offset2].				type = 2 ifTrue: [self error: 'illegalStore'].				type = 3  ifTrue: [^ client popIntoLiteralVariable: (method literalAt: offset2 + 1)]]].		"131-134: extended sends"		offset = 3 ifTrue:  "Single extended send"			[^ client send: (method literalAt: byte2 \\ 32 + 1)					super: false numArgs: byte2 // 32].		offset = 4 ifTrue:    "Double extended do-anything"			[byte3 _ method at: pc.  pc _ pc + 1.			type _ byte2 // 32.			type = 0 ifTrue: [^ client send: (method literalAt: byte3 + 1)									super: false numArgs: byte2 \\ 32].			type = 1 ifTrue: [^ client send: (method literalAt: byte3 + 1)									super: true numArgs: byte2 \\ 32].			type = 2 ifTrue: [^ client pushReceiverVariable: byte3].			type = 3 ifTrue: [^ client pushConstant: (method literalAt: byte3 + 1)].			type = 4 ifTrue: [^ client pushLiteralVariable: (method literalAt: byte3 + 1)].			type = 5 ifTrue: [^ client storeIntoReceiverVariable: byte3].			type = 6 ifTrue: [^ client popIntoReceiverVariable: byte3].			type = 7 ifTrue: [^ client storeIntoLiteralVariable: (method literalAt: byte3 + 1)]].		offset = 5 ifTrue:  "Single extended send to super"			[^ client send: (method literalAt: byte2 \\ 32 + 1)					super: true numArgs: byte2 // 32].		offset = 6 ifTrue:   "Second extended send"			[^ client send: (method literalAt: byte2 \\ 64 + 1)					super: false numArgs: byte2 // 64]].	offset = 7 ifTrue: [^ client doPop].	offset = 8 ifTrue: [^ client doDup].	offset = 9 ifTrue: [^ client pushActiveContext].	self error: 'unusedBytecode'! !!Integer methodsFor: 'testing'!benchFib  "Handy send-heavy benchmark"	"(result // seconds to run) = approx calls per second"	" | r t | t _ Time millisecondsToRun: [r _ 26 benchFib].			r//t*1000 "	"138000 on a Mac 8100/100"	^ self < 2		ifTrue: [1] 		ifFalse: [(self-1) benchFib + (self-2) benchFib + 1]! !!Integer methodsFor: 'testing'!benchmark  "Handy bytecode-heavy benchmark"	"(500000 // time to run) = approx bytecodes per second"	"5000000 // (Time millisecondsToRun: [10 benchmark]) * 1000"	"3059000 on a Mac 8100/100"    | size flags prime k count |    size _ 8190.    1 to: self do:        [:iter |        count _ 0.        flags _ (Array new: size) atAllPut: true.        1 to: size do:            [:i | (flags at: i) ifTrue:                [prime _ i+1.                k _ i + prime.                [k <= size] whileTrue:                    [flags at: k put: false.                    k _ k + prime].                count _ count + 1]]].    ^ count! !!Integer methodsFor: 'arithmetic'!* aNumber	"Refer to the comment in Number * " 	aNumber isInteger		ifTrue: [^ self digitMultiply: aNumber 					neg: self negative ~~ aNumber negative]		ifFalse: [^ (aNumber adaptInteger: self) * aNumber adaptToInteger]! !!Integer methodsFor: 'arithmetic'!+ aNumber	"Refer to the comment in Number + "	aNumber isInteger		ifTrue: [self negative == aNumber negative					ifTrue: [^(self digitAdd: aNumber) normalize]					ifFalse: [^self digitSubtract: aNumber]]		ifFalse: [^ (aNumber adaptInteger: self) + aNumber adaptToInteger]! !!Integer methodsFor: 'arithmetic'!- aNumber	"Refer to the comment in Number - "	aNumber isInteger		ifTrue: [self negative == aNumber negative					ifTrue: [^ self digitSubtract: aNumber]					ifFalse: [^ (self digitAdd: aNumber) normalize]]		ifFalse: [^ (aNumber adaptInteger: self) - aNumber adaptToInteger]! !!Integer methodsFor: 'arithmetic'!/ aNumber	"Refer to the comment in Number / "	| quoRem |	aNumber isInteger		ifTrue: [quoRem _ self digitDiv: aNumber 								neg: self negative ~~ aNumber negative.				(quoRem at: 2) = 0					ifTrue: [^(quoRem at: 1) normalize]					ifFalse: [^(Fraction numerator: self denominator: aNumber) reduced]]		ifFalse: [^ (aNumber adaptInteger: self) / aNumber adaptToInteger]! !!Integer methodsFor: 'arithmetic'!quo: aNumber 	"Refer to the comment in Number quo: "	| ng quo |	aNumber isInteger		ifTrue: 			[ng _ self negative == aNumber negative == false.			quo _ (self digitDiv: aNumber neg: ng) at: 1.			^ quo normalize]		ifFalse: [^ (aNumber adaptInteger: self) quo: aNumber adaptToInteger]! !!Integer methodsFor: 'comparing'!< aNumber	aNumber isInteger		ifTrue: [self negative == aNumber negative					ifTrue: [self negative								ifTrue: [^(self digitCompare: aNumber) > 0]								ifFalse: [^(self digitCompare: aNumber) < 0]]					ifFalse: [^self negative]]		ifFalse: [^ (aNumber adaptInteger: self) < aNumber adaptToInteger]! !!Integer methodsFor: 'comparing'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isInteger		ifTrue: [aNumber negative == self negative					ifTrue: [^ (self digitCompare: aNumber) = 0]					ifFalse: [^ false]]		ifFalse: [^ (aNumber adaptInteger: self) = aNumber adaptToInteger]! !!Integer methodsFor: 'comparing'!> aNumber	aNumber isInteger		ifTrue: [self negative == aNumber negative					ifTrue: [self negative								ifTrue: [^(self digitCompare: aNumber) < 0]								ifFalse: [^(self digitCompare: aNumber) > 0]]					ifFalse: [^ aNumber negative]]		ifFalse: [^ (aNumber adaptInteger: self) > aNumber adaptToInteger]! !!Integer methodsFor: 'mathematical functions'!degreeCos	"Answer the cosine of the receiver taken as an angle in degrees."	^ (90 + self) degreeSin! !!Integer methodsFor: 'mathematical functions'!degreeSin	"Answer the sine of the receiver taken as an angle in degrees."	^ self asFloat degreesToRadians sin! !!Integer methodsFor: 'mathematical functions' stamp: 'tk 7/30/97 13:08'!take: kk	"Return the number of combinations of (self) elements taken kk at a time.  For 6 take 3, this is 6*5*4 / (1*2*3).  Zero outside of Pascal's triangle.  Use a trick to go faster."	" 6 take: 3  "	| num denom |	kk < 0 ifTrue: [^ 0].	kk > self ifTrue: [^ 0].	num _ 1.	self to: (kk max: self-kk) + 1 by: -1 do: [:factor | num _ num * factor].	denom _ 1.	1 to: (kk min: self-kk) do: [:factor | denom _ denom * factor].	^ num // denom! !!Integer methodsFor: 'converting'!adaptFloat: aFloat	"If I am involved in arithmetic with a Float, do not convert the Float."	^ aFloat! !!Integer methodsFor: 'converting'!adaptFraction: aFraction	"If I am involved in arithmetic with a Fraction, do not convert the Fraction."	^ aFraction! !!Integer methodsFor: 'converting'!adaptToFloat	"If I am involved in arithmetic with a Float, convert me to a Float."	^ self asFloat! !!Integer methodsFor: 'converting'!adaptToFraction	"If I am involved in arithmetic with a Fraction, convert me to a Fraction."	^ self asFraction! !!Integer methodsFor: 'private'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	l _ self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^Array with: 0 with: self].	d _ 8 - arg lastDigit highBit.	div _ arg digitLshift: d.  div _ div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem _ self digitLshift: d.	rem digitLength = self digitLength ifTrue:		[rem _ rem growto: self digitLength + 1].	"makes a copy and shifts"	quo _ Integer new: l neg: ng.	dl _ div digitLength - 1.	"Last actual byte of data"	ql _ l.	dh _ div digitAt: dl.	dnh _		 dl = 1			ifTrue: [0]			ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j _ rem digitLength + 1 - k.		"r1 _ rem digitAt: j."		(rem digitAt: j) = dh			ifTrue: [qhi _ qlo _ 15"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  				Note that r1,r2 are bytes, not nibbles.  				Be careful not to generate intermediate results exceeding 13 bits."				"r2 _ (rem digitAt: j - 1)."				t _ ((rem digitAt: j) bitShift: 4) + ((rem digitAt: j - 1) bitShift: -4).				qhi _ t // dh.				t _ (t \\ dh bitShift: 4) + ((rem digitAt: j - 1) bitAnd: 15).				qlo _ t // dh.				t _ t \\ dh.				"Next compute (hi,lo) _ q*dnh"				hi _ qhi * dnh.				lo _ qlo * dnh + ((hi bitAnd: 15) bitShift: 4).				hi _ (hi bitShift: -4) + (lo bitShift: -8).				lo _ lo bitAnd: 255.				"Correct overestimate of q.  				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 _ 					j < 3 ifTrue: [0]						 ifFalse: [rem digitAt: j - 2].				[(t < hi or: [t = hi and: [r3 < lo]]) and: 						["i.e. (t,r3) < (hi,lo)"						qlo _ qlo - 1.						lo _ lo - dnh.						lo < 0							ifTrue: 								[hi _ hi - 1.								lo _ lo + 256].						hi >= dh]]					whileTrue: [hi _ hi - dh].				qlo < 0					ifTrue: 						[qhi _ qhi - 1.						qlo _ qlo + 16]].		"Subtract q*div from rem"		l _ j - dl.		a _ 0.		1 to: div digitLength do: 			[:i | 			hi _ (div digitAt: i) * qhi.			lo _ 				a + (rem digitAt: l) 					- ((hi bitAnd: 15) bitShift: 4) 					- ((div digitAt: i) * qlo).			rem digitAt: l put: (lo bitAnd: 255).			a _ (lo bitShift: -8) - (hi bitShift: -4).			l _ l + 1].		a < 0			ifTrue: 				["Add div back into rem, decrease q by 1"				qlo _ qlo - 1.				l _ j - dl.				a _ 0.				1 to: div digitLength do: 					[:i | 					a _ (a bitShift: -8) + (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l _ l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4) + qlo].	rem _ rem digitRshift: d bytes: 0 lookfirst: dl.	^Array with: quo with: rem! !!Integer methodsFor: 'private'!digitLogic: arg op: op length: len	| result neg1 neg2 rneg z1 z2 rz b1 b2 b |	neg1 _ self negative.	neg2 _ arg negative.	rneg _ 		((neg1 ifTrue: [-1] ifFalse: [0])			perform: op 			with: (neg2					ifTrue: [-1]					ifFalse: [0])) < 0.	result _ Integer new: len neg: rneg.	rz _ z1 _ z2 _ true.	1 to: result digitLength do: 		[:i | 		b1 _ self digitAt: i.		neg1 			ifTrue: [b1 _ z1						ifTrue: [b1 = 0									ifTrue: [0]									ifFalse: 										[z1 _ false.										256 - b1]]						ifFalse: [255 - b1]].		b2 _ arg digitAt: i.		neg2 			ifTrue: [b2 _ z2						ifTrue: [b2 = 0									ifTrue: [0]									ifFalse: 										[z2 _ false.										256 - b2]]						ifFalse: [255 - b2]].		b _ b1 perform: op with: b2.		b = 0			ifTrue: 				[result digitAt: i put: 0]			ifFalse: 				[result 					digitAt: i 					put: (rneg							ifTrue: [rz ifTrue: 											[rz _ false.											256 - b]										ifFalse: [255 - b]]						ifFalse: [b])]].	^ result normalize! !!Integer methodsFor: 'private'!digitMultiply: arg neg: ng	| prod prodLen carry digit k ab |	(arg digitLength = 1 and: [(arg digitAt: 1) = 0]) ifTrue: [^ 0].	prodLen _ self digitLength + arg digitLength.	prod _ Integer new: prodLen neg: ng.	"prod starts out all zero"	1 to: self digitLength do: 		[:i | 		(digit _ self digitAt: i) ~= 0			ifTrue: 				[k _ i.				carry _ 0.				"Loop invariant: 0<=carry<=0377, k=i+j-1"				1 to: arg digitLength do: 					[:j | 					ab _ ((arg digitAt: j) * digit) + carry							+ (prod digitAt: k).					carry _ ab bitShift: -8.					prod digitAt: k put: (ab bitAnd: 255).					k _ k + 1].				prod digitAt: k put: carry]].	^ prod normalize! !!Integer methodsFor: 'private'!digitRshift: anInteger bytes: b lookfirst: a 	 "Shift right 8*b+anInteger bits, 0<=n<8.	Discard all digits beyond a, and all zeroes at or below a."	| n x r f m digit count i |	n _ 0 - anInteger.	x _ 0.	f _ n + 8.	i _ a.	m _ 255 bitShift: 0 - f.	digit _ self digitAt: i.	[((digit bitShift: n) bitOr: x) = 0 and: [i ~= 1]] whileTrue:		[x _ digit bitShift: f "Can't exceed 8 bits".		i _ i - 1.		digit _ self digitAt: i].	i <= b ifTrue: [^Integer new: 0 neg: self negative].  "All bits lost"	r _ Integer new: i - b neg: self negative.	count _ i.	x _ (self digitAt: b + 1) bitShift: n.	b + 1 to: count do:		[:j | digit _ self digitAt: j + 1.		r digitAt: j - b put: (((digit bitAnd: m) bitShift: f) bitOr: x) 			"Avoid values > 8 bits".		x _ digit bitShift: n].	^r! !!InterimSoundMorph methodsFor: 'all' stamp: 'jm 9/18/97 15:25'!addGraphic	graphic _ SketchMorph new form: self speakerGraphic.	graphic position: bounds center - (graphic extent // 2).	self addMorph: graphic.! !!InterimSoundMorph methodsFor: 'all' stamp: 'jm 9/18/97 15:26'!handlesMouseDown: evt	(graphic containsPoint: evt cursorPoint)		ifTrue: [^ true]		ifFalse: [^ super handlesMouseDown: evt].! !!InterimSoundMorph methodsFor: 'all' stamp: 'jm 12/17/97 22:43'!initialize	super initialize.	borderWidth _ 1.	color _ Color r: 0 g: 0.8 b: 0.6.	self extent: 30@30.	self addGraphic.	sound _ PluckedSound pitch: 880.0 dur: 2.0 loudness: 0.5.! !!InterimSoundMorph methodsFor: 'all' stamp: 'jm 9/18/97 18:56'!mouseDown: evt	(graphic containsPoint: evt cursorPoint)		ifTrue: [sound copy play]		ifFalse: [super mouseDown: evt].! !!InterimSoundMorph methodsFor: 'all' stamp: 'jm 9/18/97 15:02'!sound	^ sound! !!InterimSoundMorph methodsFor: 'all' stamp: 'jm 9/18/97 15:01'!sound: aSound	sound _ aSound.! !!InterimSoundMorph methodsFor: 'all' stamp: 'jm 9/18/97 15:20'!speakerGraphic	^ Form		extent: 19@18		depth: 8		fromArray: #(0 0 1493172224 2816 0 0 0 1493172224 11 0 0 138 1493172224 184549376 184549376 0 35509 2315255808 720896 720896 0 9090522 2315255808 2816 720896 0 2327173887 2315255819 2816 720896 138 3051028442 2315255819 2816 2816 1505080590 4294957786 2315255808 184549387 2816 3053453311 4292532917 1493172224 184549387 2816 1505080714 3048584629 1493172224 184549387 2816 9079434 3048584629 1493172224 184549387 2816 138 2327164341 1493172235 2816 2816 0 2324346293 1493172235 2816 720896 0 9079477 1493172224 2816 720896 0 35466 1493172224 720896 720896 0 138 0 184549376 184549376 0 0 0 11 0 0 0 0 2816 0)		offset: 0@0! !Interpreter comment:'This class is a complete implementation of the Smalltalk-80 virtual machine, derived originally from the Blue Book specification.It has been modernized with 32-bit pointers, better management of Contexts, and attention to variable use that allows the CCodeGenerator (qv) to keep, eg, the instruction pointer and stack pointer in registers.In addition to SmallInteger arithmetic and Floats, it supports logic on 32-bit PositiveLargeIntegers, thus allowing it to simulate itself much more effectively than would otherwise be the case.'!!Interpreter methodsFor: 'initialization' stamp: 'di 12/29/97 20:07'!initializeInterpreter: bytesToShift	"Initialize Interpreter state before starting execution of a new image."	self initializeObjectMemory: bytesToShift.	self initBBOpTable.	activeContext	_ nilObj.	theHomeContext	_ nilObj.	method			_ nilObj.	receiver		_ nilObj.	messageSelector	_ nilObj.	newMethod		_ nilObj.	self flushMethodCache.	self loadInitialContext.	interruptCheckCounter _ 0.	nextPollTick _ 0.	nextWakeupTick _ 0.	lastTick _ 0.	interruptKeycode _ 2094.  "cmd-."	interruptPending _ false.	semaphoresToSignalCount _ 0.! !!Interpreter methodsFor: 'initialization'!loadInitialContext	| sched proc |	sched _ self fetchPointer: ValueIndex ofObject: (self splObj: SchedulerAssociation).	proc _ self fetchPointer: ActiveProcessIndex ofObject: sched.	activeContext _ self fetchPointer: SuspendedContextIndex ofObject: proc.	(activeContext < youngStart) ifTrue: [ self beRootIfOld: activeContext ].	self fetchContextRegisters: activeContext.	reclaimableContextCount _ 0.! !!Interpreter methodsFor: 'utilities'!areIntegers: oop1 and: oop2	^ ((oop1 bitAnd: oop2) bitAnd: 1) ~= 0! !!Interpreter methodsFor: 'utilities'!arrayValueOf: arrayOop	"Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."	"Note: May be called by translated primitive code."	self returnTypeC: 'void *'.	((self isIntegerObject: arrayOop) not and:	 [self isWordsOrBytes: arrayOop]) ifTrue: [		^ self cCode: '(void *) (arrayOop + 4)'	].	self primitiveFail.! !!Interpreter methodsFor: 'utilities'!assertClassOf: oop is: classOop	"Succeed if the given (non-integer) object is an instance of the given class. Fail if the object is an integer."	| ccIndex cl |	self inline: true.	(self isIntegerObject: oop)		ifTrue: [ successFlag _ false. ^ nil ].	ccIndex _ ((self baseHeader: oop) >> 12) bitAnd: 16r1F.	ccIndex = 0		ifTrue: [ cl _ ((self classHeader: oop) bitAnd: AllButTypeMask) ]		ifFalse: [			"look up compact class"			cl _ (self fetchPointer: (ccIndex - 1)					ofObject: (self fetchPointer: CompactClasses ofObject: specialObjectsOop))].	self success: cl = classOop.! !!Interpreter methodsFor: 'utilities'!assertFloat: oop1 and: oop2	"Fail unless both arguments are floats."	| floatClass |	((oop1 bitOr: oop2) bitAnd: 1) ~= 0 ifTrue: [		successFlag _ false.	] ifFalse: [		floatClass _ self splObj: ClassFloat.		self assertClassOf: oop1 is: floatClass.		self assertClassOf: oop2 is: floatClass.	].! !!Interpreter methodsFor: 'utilities'!booleanCheat: cond	| bytecode offset |	self inline: true.	bytecode _ self fetchByte.  "assume next bytecode is jumpIfFalse (99%)"	self internalPop: 2.	(bytecode < 160 and: [bytecode > 151]) ifTrue: [  "short jumpIfFalse"		cond			ifTrue: [^ nil]			ifFalse: [^ self jump: bytecode - 151]].	bytecode = 172 ifTrue: [  "long jumpIfFalse"		offset _ self fetchByte.		cond			ifTrue: [^ nil]			ifFalse: [^ self jump: offset]].	"not followed by a jumpIfFalse; undo instruction fetch and push boolean result"	localIP _ localIP - 1.	cond		ifTrue: [self internalPush: trueObj]		ifFalse: [self internalPush: falseObj].! !!Interpreter methodsFor: 'utilities'!booleanValueOf: obj	obj = trueObj ifTrue: [ ^ true ].	obj = falseObj ifTrue: [ ^ false ].	successFlag _ false.	^ nil! !!Interpreter methodsFor: 'utilities'!checkedIntegerValueOf: intOop	"Note: May be called by translated primitive code."	(self isIntegerObject: intOop)		ifTrue: [ ^ self integerValueOf: intOop ]		ifFalse: [ self primitiveFail. ^ 0 ]! !!Interpreter methodsFor: 'utilities'!externalizeIPandSP	"Copy the local instruction and stack pointer to global variables for use in primitives and other functions outside the interpret loop."	instructionPointer _ self cCoerce: localIP to: 'int'.	stackPointer _ self cCoerce: localSP to: 'int'.! !!Interpreter methodsFor: 'utilities'!fetchArray: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."	"Note: May be called by translated primitive code."	| arrayOop |	self returnTypeC: 'void *'.	arrayOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self arrayValueOf: arrayOop! !!Interpreter methodsFor: 'utilities'!fetchFloat: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."	"Note: May be called by translated primitive code."	| floatOop |	self returnTypeC: 'double'.	floatOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self floatValueOf: floatOop! !!Interpreter methodsFor: 'utilities'!fetchInteger: fieldIndex ofObject: objectPointer	"Note: May be called by translated primitive code."	| intOop |	self inline: false.	intOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	(self isIntegerObject: intOop)		ifTrue: [ ^ self integerValueOf: intOop ]		ifFalse: [ self primitiveFail. ^ 0 ]! !!Interpreter methodsFor: 'utilities'!fetchIntegerOrTruncFloat: fieldIndex ofObject: objectPointer	"Return the integer value of the given field of the given object. If the field contains a Float, truncate it and return its integral part. Fail if the given field does not contain a small integer or Float, or if the truncated Float is out of the range of small integers."	"Note: May be called by translated primitive code."	| intOrFloat floatVal frac trunc |	self inline: false.	self var: #floatVal declareC: 'double floatVal'.	self var: #frac declareC: 'double frac'.	self var: #trunc declareC: 'double trunc'.	intOrFloat _ self fetchPointer: fieldIndex ofObject: objectPointer.	(self isIntegerObject: intOrFloat) ifTrue: [^ self integerValueOf: intOrFloat].	self assertClassOf: intOrFloat is: (self splObj: ClassFloat).	successFlag ifTrue: [		self fetchFloatAt: intOrFloat + BaseHeaderSize into: floatVal.		self cCode: 'frac = modf(floatVal, &trunc)'.		"the following range check is for C ints, with range -2^31..2^31-1"		self cCode: 'success((-2147483648.0 <= trunc) && (trunc <= 2147483647.0))'].	successFlag		ifTrue: [^ self cCode: '((int) trunc)']		ifFalse: [^ 0].! !!Interpreter methodsFor: 'utilities'!floatValueOf: oop	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."	"Note: May be called by translated primitive code."	| result |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	self assertClassOf: oop is: (self splObj: ClassFloat).	successFlag		ifTrue: [self fetchFloatAt: oop + BaseHeaderSize into: result]		ifFalse: [result _ 0.0].	^ result! !!Interpreter methodsFor: 'utilities'!internalizeIPandSP	"Copy the local instruction and stack pointer to local variables for rapid access within the interpret loop."	localIP _ self cCoerce: instructionPointer to: 'char *'.	localSP _ self cCoerce: stackPointer to: 'char *'.! !!Interpreter methodsFor: 'utilities'!makePointwithxValue: xValue yValue: yValue	| pointResult |	pointResult _ self instantiateSmallClass: (self splObj: ClassPoint)							   sizeInBytes: 12									   fill: nilObj.	self storePointer: XIndex ofObject: pointResult withValue: (self integerObjectOf: xValue).	self storePointer: YIndex ofObject: pointResult withValue: (self integerObjectOf: yValue).	^ pointResult! !!Interpreter methodsFor: 'utilities'!quickFetchInteger: fieldIndex ofObject: objectPointer	"Return the integer value of the field without verifying that it is an integer value!! For use in time-critical places where the integer-ness of the field can be guaranteed."	^ self integerValueOf:		(self fetchPointer: fieldIndex ofObject: objectPointer).! !!Interpreter methodsFor: 'utilities'!signExtend16: int16	"Convert a signed 16-bit integer into a signed 32-bit integer value. The integer bit is not added here."	(int16 bitAnd: 16r8000) = 0		ifTrue: [ ^ int16 ]		ifFalse: [ ^ int16 - 16r10000 ].! !!Interpreter methodsFor: 'utilities'!storeInteger: fieldIndex ofObject: objectPointer withValue: integerValue	"Note: May be called by translated primitive code."	(self isIntegerValue: integerValue) ifTrue: [		self storeWord: fieldIndex			ofObject: objectPointer			withValue: (self integerObjectOf: integerValue).	] ifFalse: [		self primitiveFail	].! !!Interpreter methodsFor: 'utilities'!transfer: count	fromIndex: firstFrom ofObject: fromOop	toIndex: firstTo ofObject: toOop	"Assume: beRootIfOld: will be called on toOop."	| fromIndex toIndex lastFrom |	self inline: true.	fromIndex _ fromOop + (firstFrom * 4).	toIndex _ toOop + (firstTo * 4).	lastFrom _ fromIndex + (count * 4).	[fromIndex < lastFrom] whileTrue: [		fromIndex _ fromIndex + 4.		toIndex _ toIndex + 4.		self longAt: toIndex put: (self longAt: fromIndex).	].! !!Interpreter methodsFor: 'object memory support'!mapInterpreterOops	"Map all oops in the interpreter's state to their new values during garbage collection or a become: operation."	"Assume: All traced variables contain valid oops."	| oop |	nilObj				_ self remap: nilObj.	falseObj				_ self remap: falseObj.	trueObj				_ self remap: trueObj.	specialObjectsOop	_ self remap: specialObjectsOop.	stackPointer 		_ stackPointer - activeContext.	"*rel to active"	activeContext		_ self remap: activeContext.	stackPointer 		_ stackPointer + activeContext.	"*rel to active"	theHomeContext		_ self remap: theHomeContext.	instructionPointer 	_ instructionPointer - method.	"*rel to method"	method				_ self remap: method.	instructionPointer 	_ instructionPointer + method.	"*rel to method"	receiver				_ self remap: receiver.	messageSelector		_ self remap: messageSelector.	newMethod			_ self remap: newMethod.	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			remapBuffer at: i put: (self remap: oop).		].	].	"The method cache uses oops as hashes -- toss the whole thing."	self flushMethodCache.! !!Interpreter methodsFor: 'object memory support'!markAndTraceInterpreterOops	"Mark and trace all oops in the interpreter's state."	"Assume: All traced variables contain valid oops."	| oop |	self markAndTrace: specialObjectsOop.		"also covers nilObj, trueObj, falseObj, and compact classes"	self markAndTrace: activeContext.  "traces entire stack"		"also covers theHomeContext, receiver, method"	self markAndTrace: messageSelector.	self markAndTrace: newMethod.	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			self markAndTrace: oop.		].	].! !!Interpreter methodsFor: 'object memory support'!postGCAction	"Mark the active and home contexts as roots if old. This allows the interpreter to use storePointerUnchecked to store into them."	(activeContext    < youngStart) ifTrue: [ self beRootIfOld: activeContext ].	(theHomeContext < youngStart) ifTrue: [ self beRootIfOld: theHomeContext ].! !!Interpreter methodsFor: 'object memory support' stamp: 'ikp 1/14/98 01:11'!preGCAction: fullGCFlag	"no-op"! !!Interpreter methodsFor: 'compiled methods'!argumentCountOf: methodPointer	^ ((self headerOf: methodPointer) >> 25) bitAnd: 16r1F! !!Interpreter methodsFor: 'compiled methods'!headerOf: methodPointer	^self fetchPointer: HeaderIndex		ofObject: methodPointer! !!Interpreter methodsFor: 'compiled methods'!literal: offset	^self literal: offset		ofMethod: method! !!Interpreter methodsFor: 'compiled methods'!literal: offset ofMethod: methodPointer	^ self fetchPointer: offset + LiteralStart ofObject: methodPointer! !!Interpreter methodsFor: 'compiled methods'!literalCountOf: methodPointer	^self literalCountOfHeader: (self headerOf: methodPointer)! !!Interpreter methodsFor: 'compiled methods'!literalCountOfHeader: headerPointer	^ (headerPointer >> 10) bitAnd: 16rFF! !!Interpreter methodsFor: 'compiled methods'!methodClassOf: methodPointer	^ self fetchPointer: ValueIndex ofObject:		(self literal: (self literalCountOf: methodPointer) - 1			ofMethod: methodPointer)! !!Interpreter methodsFor: 'compiled methods' stamp: 'jm 9/18/97 21:06'!primitiveIndexOf: methodPointer	"Note: We now have 11 bits of primitive index, but they are in two places	for temporary backward compatibility.  The time to unpack is negligible,	since the reconstituted full index is stored in the method cache."	| primBits |	primBits _ ((self headerOf: methodPointer) >> 1) bitAnd: 16r300001FF.	primBits > 16r1FF		ifTrue: [^ (primBits bitAnd: 16r1FF) + (primBits >> 19)]		ifFalse: [^ primBits]! !!Interpreter methodsFor: 'compiled methods'!primitiveNewMethod	| header bytecodeCount class size theMethod literalCount |	header _ self popStack.	bytecodeCount _ self popInteger.	self success: (self isIntegerObject: header).	successFlag ifFalse: [self unPop: 2].	class _ self popStack.	size _ (self literalCountOfHeader: header) + 1 * 4 + bytecodeCount.	theMethod _ self instantiateClass: class indexableSize: size.	self storePointer: HeaderIndex ofObject: theMethod withValue: header.	literalCount _ self literalCountOfHeader: header.	1 to: literalCount do:		[:i | self storePointer: i ofObject: theMethod withValue: nilObj].	self push: theMethod! !!Interpreter methodsFor: 'contexts'!argumentCountOfBlock: blockPointer	| argCount |	argCount _ self fetchPointer: BlockArgumentCountIndex							ofObject: blockPointer.	(self isIntegerObject: argCount)		ifTrue: [ ^ self integerValueOf: argCount ]		ifFalse: [ self primitiveFail. ^0 ].! !!Interpreter methodsFor: 'contexts'!caller	^self fetchPointer: CallerIndex		ofObject: activeContext! !!Interpreter methodsFor: 'contexts'!fetchContextRegisters: activeCntx	"Note: internalFetchContextRegisters: should track changes to this method."	| tmp |	self inline: true.	tmp _ self fetchPointer: MethodIndex ofObject: activeCntx.	(self isIntegerObject: tmp) ifTrue: [		"if the MethodIndex field is an integer, activeCntx is a block context"		tmp _ self fetchPointer: HomeIndex ofObject: activeCntx.		(tmp < youngStart) ifTrue: [ self beRootIfOld: tmp ].	] ifFalse: [		"otherwise, it is a method context and is its own home context"		tmp _ activeCntx.	].	theHomeContext _ tmp.	receiver _ self fetchPointer: ReceiverIndex ofObject: tmp.	method _ self fetchPointer: MethodIndex ofObject: tmp.	"the instruction pointer is a pointer variable equal to		method oop + ip + BaseHeaderSize		  -1 for 0-based addressing of fetchByte		  -1 because it gets incremented BEFORE fetching currentByte"	tmp _ self quickFetchInteger: InstructionPointerIndex ofObject: activeCntx.	instructionPointer _ method + tmp + BaseHeaderSize - 2.	"the stack pointer is a pointer variable also..."	tmp _ self quickFetchInteger: StackPointerIndex ofObject: activeCntx.	stackPointer _ activeCntx + BaseHeaderSize + ((TempFrameStart + tmp - 1) * 4).! !!Interpreter methodsFor: 'contexts'!internalFetchContextRegisters: activeCntx	"Inlined into return bytecodes. The only difference between this method and fetchContextRegisters: is that this method sets the local IP and SP."	| tmp |	self inline: true.	tmp _ self fetchPointer: MethodIndex ofObject: activeCntx.	(self isIntegerObject: tmp) ifTrue: [		"if the MethodIndex field is an integer, activeCntx is a block context"		tmp _ self fetchPointer: HomeIndex ofObject: activeCntx.		(tmp < youngStart) ifTrue: [ self beRootIfOld: tmp ].	] ifFalse: [		"otherwise, it is a method context and is its own home context"		tmp _ activeCntx.	].	theHomeContext _ tmp.	receiver _ self fetchPointer: ReceiverIndex ofObject: tmp.	method _ self fetchPointer: MethodIndex ofObject: tmp.	"the instruction pointer is a pointer variable equal to		method oop + ip + BaseHeaderSize		  -1 for 0-based addressing of fetchByte		  -1 because it gets incremented BEFORE fetching currentByte"	tmp _ self quickFetchInteger: InstructionPointerIndex ofObject: activeCntx.	localIP _ self cCoerce: method + tmp + BaseHeaderSize - 2 to: 'char *'.	"the stack pointer is a pointer variable also..."	tmp _ self quickFetchInteger: StackPointerIndex ofObject: activeCntx.	localSP _ self cCoerce: activeCntx + BaseHeaderSize + ((TempFrameStart + tmp - 1) * 4) to: 'char *'.! !!Interpreter methodsFor: 'contexts'!internalPop: nItems	localSP _ localSP - (nItems * 4).! !!Interpreter methodsFor: 'contexts'!internalPop: nItems thenPush: oop	self longAt: (localSP _ localSP - ((nItems - 1) * 4)) put: oop.! !!Interpreter methodsFor: 'contexts'!internalPush: object	self longAt: (localSP _ localSP + 4) put: object.! !!Interpreter methodsFor: 'contexts'!internalStackTop	^ self longAt: localSP! !!Interpreter methodsFor: 'contexts'!internalStackValue: offset	^ self longAt: localSP - (offset * 4)! !!Interpreter methodsFor: 'contexts'!newActiveContext: aContext	self storeContextRegisters: activeContext.	(aContext < youngStart) ifTrue: [ self beRootIfOld: aContext ].	activeContext _ aContext.	self fetchContextRegisters: aContext.! !!Interpreter methodsFor: 'contexts'!pop: nItems	"Note: May be called by translated primitive code."	stackPointer _ stackPointer - (nItems*4).! !!Interpreter methodsFor: 'contexts'!pop: nItems thenPush: oop	| sp |	self longAt: (sp _ stackPointer - ((nItems - 1) * 4)) put: oop.	stackPointer _ sp.! !!Interpreter methodsFor: 'contexts'!popInteger	| integerPointer |	integerPointer _ self popStack.	(self isIntegerObject: integerPointer)		ifTrue: [^ self integerValueOf: integerPointer]		ifFalse: [successFlag _ false.				^ 1  "in case need SOME integer prior to fail"]! !!Interpreter methodsFor: 'contexts'!popPos32BitInteger	"May set successFlag, and return false if not valid"	| top |	top _ self popStack.	^ self positive32BitValueOf: top! !!Interpreter methodsFor: 'contexts'!popStack	| top |	top _ self longAt: stackPointer.	stackPointer _ stackPointer - 4.	^ top! !!Interpreter methodsFor: 'contexts'!push: object	| sp |	self longAt: (sp _ stackPointer + 4) put: object.	stackPointer _ sp.! !!Interpreter methodsFor: 'contexts'!pushBool: trueOrFalse	trueOrFalse		ifTrue: [ self push: trueObj ]		ifFalse: [ self push: falseObj ].! !!Interpreter methodsFor: 'contexts'!pushInteger: integerValue	self push: (self integerObjectOf: integerValue).! !!Interpreter methodsFor: 'contexts'!sender	^ self fetchPointer: SenderIndex ofObject: theHomeContext! !!Interpreter methodsFor: 'contexts'!stackIntegerValue: offset	| integerPointer |	integerPointer _ self longAt: stackPointer - (offset*4).	(self isIntegerObject: integerPointer)		ifTrue: [ ^self integerValueOf: integerPointer ]		ifFalse: [ self primitiveFail. ^0 ]! !!Interpreter methodsFor: 'contexts'!stackPointerIndex	"Return the 0-based index rel to the current context.	(This is what stackPointer used to be before conversion to pointer"	^ (stackPointer - activeContext - BaseHeaderSize) >> 2! !!Interpreter methodsFor: 'contexts'!stackTop	^self longAt: stackPointer! !!Interpreter methodsFor: 'contexts'!stackValue: offset	^ self longAt: stackPointer - (offset*4)! !!Interpreter methodsFor: 'contexts'!storeContextRegisters: activeCntx	"InstructionPointer is a pointer variable equal to	method oop + ip + BaseHeaderSize		-1 for 0-based addressing of fetchByte		-1 because it gets incremented BEFORE fetching currentByte"	self inline: true.	self storeWord: InstructionPointerIndex ofObject: activeCntx		withValue: (self integerObjectOf: 			(instructionPointer - method - (BaseHeaderSize - 2))).	self storeWord: StackPointerIndex		  ofObject: activeCntx		withValue: (self integerObjectOf:			(self stackPointerIndex - TempFrameStart + 1)).! !!Interpreter methodsFor: 'contexts'!storeInstructionPointerValue: value inContext: contextPointer	"Assume: value is an integerValue"	self storeWord: InstructionPointerIndex		ofObject: contextPointer		withValue: (self integerObjectOf: value).! !!Interpreter methodsFor: 'contexts'!storeStackPointerValue: value inContext: contextPointer	"Assume: value is an integerValue"	self storeWord: StackPointerIndex		ofObject: contextPointer		withValue: (self integerObjectOf: value).! !!Interpreter methodsFor: 'contexts'!temporary: offset	^ self fetchPointer: offset + TempFrameStart ofObject: theHomeContext! !!Interpreter methodsFor: 'contexts'!unPop: nItems	stackPointer _ stackPointer + (nItems*4)! !!Interpreter methodsFor: 'object format'!fixedFieldsOf: oop format: fmt length: wordLength"	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ (classFormat >> 2 bitAnd: 16rFF) - 1"	| class classFormat |	self inline: true.	((fmt > 3) or: [fmt = 2]) ifTrue: [^ 0].  "indexable fields only"	fmt < 2 ifTrue: [^ wordLength].  "fixed fields only (zero or more)"		"fmt = 3: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!Interpreter methodsFor: 'object format'!formatOfClass: classPointer	"**should be in-lined**"	"Note that, in Smalltalk, the instSpec will be equal to the inst spec	part of the base header of an instance (without hdr type) shifted left 1.	In this way, apart from the smallInt bit, the bits	are just where you want them for the first header word."	"Callers expect low 2 bits (header type) to be zero!!"	^ (self fetchPointer: InstanceSpecificationIndex ofObject: classPointer) - 1! !!Interpreter methodsFor: 'message sending'!activateNewMethod	| newContext fromIndex toIndex lastIndex methodHeader smallContext initialIP tempCount nilOop |	self inline: false.	self var: #fromIndex declareC: 'char * fromIndex'.	self var: #toIndex declareC: 'char * toIndex'.	self var: #lastIndex declareC: 'char * lastIndex'.	methodHeader _ self headerOf: newMethod.	smallContext _ ((methodHeader >> 18) bitAnd: 1) = 0.	newContext _ self allocateOrRecycleContext: smallContext.	initialIP _		((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1.	tempCount _		(methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf: initialIP).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	fromIndex _ (self cCoerce: activeContext to: 'char *') + ((self stackPointerIndex - argumentCount) * 4).	toIndex _ (self cCoerce: newContext to: 'char *') + (ReceiverIndex * 4).	lastIndex _ fromIndex + ((argumentCount + 1) * 4).	[fromIndex < lastIndex] whileTrue: [		fromIndex _ fromIndex + 4.		toIndex _ toIndex + 4.		self longAt: toIndex put: (self longAt: fromIndex).	].	"clear remaining context fields to nil in case it has been recycled"	nilOop _ nilObj.	smallContext		ifTrue: [lastIndex _ (self cCoerce: newContext to: 'char *') + SmallContextSize - BaseHeaderSize]		ifFalse: [lastIndex _ (self cCoerce: newContext to: 'char *') + LargeContextSize - BaseHeaderSize].	[toIndex < lastIndex] whileTrue: [		toIndex _ toIndex + 4.		self longAt: toIndex put: nilOop.	].	self pop: argumentCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self newActiveContext: newContext.! !!Interpreter methodsFor: 'message sending'!argCount	^ argumentCount! !!Interpreter methodsFor: 'message sending'!createActualMessage	| argumentArray message |	argumentArray _		self instantiateClass: (self splObj: ClassArray) indexableSize: argumentCount.	"remap argumentArray in case GC happens during allocation"	self pushRemappableOop: argumentArray.	message _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	argumentArray _ self popRemappableOop.	(argumentArray < youngStart) ifTrue: [ self beRootIfOld: argumentArray ].	self storePointer: MessageSelectorIndex		ofObject: message		withValue: messageSelector.	self storePointer: MessageArgumentsIndex		ofObject: message		withValue: argumentArray.	self transfer: argumentCount		fromIndex: self stackPointerIndex - (argumentCount - 1)		ofObject: activeContext		toIndex: 0		ofObject: argumentArray.	self pop: argumentCount.	self push: message.	argumentCount _ 1.! !!Interpreter methodsFor: 'message sending'!executeNewMethod	(primitiveIndex = 0 or: [self primitiveResponse not]) ifTrue: [		"if not primitive, or primitive failed, activate the method"		self activateNewMethod.		"check for possible interrupts at each real send"		self quickCheckForInterrupts.	].! !!Interpreter methodsFor: 'message sending'!findNewMethodInClass: class	"Find the compiled method to be run when the current messageSelector is sent to the given class, setting the values of 'newMethod' and 'primitiveIndex'."	| ok |	self inline: true.	ok _ self lookupInMethodCacheSel: messageSelector class: class.	ok ifFalse: [		"entry was not found in the cache; look it up the hard way"		self lookupMethodInClass: class.		primitiveIndex _ self primitiveIndexOf: newMethod.		self addToMethodCacheSel: messageSelector			class: class			method: newMethod			primIndex: primitiveIndex.	].! !!Interpreter methodsFor: 'message sending' stamp: 'jm 9/24/97 22:52'!lookupMethodInClass: class	| currentClass dictionary found rclass |	currentClass _ class.	[currentClass ~= nilObj]		whileTrue:		[dictionary _ self fetchPointer: MessageDictionaryIndex ofObject: currentClass.		found _ self lookupMethodInDictionary: dictionary.		found ifTrue: [^ currentClass].		currentClass _ self superclassOf: currentClass].	messageSelector = (self splObj: SelectorDoesNotUnderstand) ifTrue:		[self error: 'Recursive not understood error encountered'].	self pushRemappableOop: class.	self createActualMessage.  "may cause GC!!"	rclass _ self popRemappableOop.	messageSelector _ self splObj: SelectorDoesNotUnderstand.	^ self lookupMethodInClass: rclass! !!Interpreter methodsFor: 'message sending'!lookupMethodInDictionary: dictionary	"This method lookup tolerates integers as Dictionary keys to support	execution of images in which Symbols have been compacted out" 	| length index mask wrapAround nextSelector methodArray |	self inline: true.	length _ self fetchWordLengthOf: dictionary.	mask _ length - SelectorStart - 1.	(self isIntegerObject: messageSelector)		ifTrue:		[index _ (mask bitAnd: (self integerValueOf: messageSelector)) + SelectorStart]		ifFalse:		[index _ (mask bitAnd: (self hashBitsOf: messageSelector)) + SelectorStart].	"It is assumed that there are some nils in this dictionary, and search will	stop when one is encountered.  However, if there are no nils, then wrapAround	will be detected the second time the loop gets to the end of the table."	wrapAround _ false.	[true] whileTrue:		[nextSelector _ self fetchPointer: index					ofObject: dictionary.		nextSelector=nilObj ifTrue: [^false].		nextSelector=messageSelector			ifTrue: [methodArray _ self fetchPointer: MethodArrayIndex							ofObject: dictionary.				newMethod _ self fetchPointer:  index - SelectorStart							ofObject: methodArray.				primitiveIndex _ self primitiveIndexOf: newMethod.				^true].		index _ index + 1.		index = length			ifTrue: [wrapAround ifTrue: [^false].				wrapAround _ true.				index _ SelectorStart]]! !!Interpreter methodsFor: 'message sending'!normalSend	"Send a message, starting lookup with the receiver's class."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| rcvrClass |	self inline: true.	self sharedCodeNamed: 'commonSend' inCase: 131.	rcvrClass _ self fetchClassOf: (self internalStackValue: argumentCount).	self externalizeIPandSP.	self sendSelectorToClass: rcvrClass.	self internalizeIPandSP.! !!Interpreter methodsFor: 'message sending'!sendSelectorToClass: classPointer	"Note: Requires that instructionPointer and stackPointer be externalized."	self inline: true.	self findNewMethodInClass: classPointer.	self executeNewMethod.! !!Interpreter methodsFor: 'message sending'!specialSelector: index	^ self fetchPointer: (index * 2) ofObject: (self splObj: SpecialSelectors)! !!Interpreter methodsFor: 'message sending'!superclassOf: classPointer	^ self fetchPointer: SuperclassIndex ofObject: classPointer! !!Interpreter methodsFor: 'message sending'!superclassSend	"Send a message to self, starting lookup with the superclass of the class containing the currently executing method."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| superClass |	self inline: true.	self sharedCodeNamed: 'commonSupersend' inCase: 133.	superClass _ self superclassOf: (self methodClassOf: method).	self externalizeIPandSP.	self sendSelectorToClass: superClass.	self internalizeIPandSP.! !!Interpreter methodsFor: 'method lookup cache'!addToMethodCacheSel: selector class: class method: meth primIndex: primIndex	"Add the given entry to the method cache."	| probe |	self inline: false.	"select one of the CacheProbeMax possible entries for replacement..."	mcProbe _ (mcProbe + 1) \\ CacheProbeMax.  "in range 0..CacheProbeMax-1"	probe _ (((selector bitXor: class) >> (mcProbe + 2)) bitAnd: MethodCacheMask) + 1.	"...and replace the entry at that probe addresses"	methodCache at: probe put: selector.	methodCache at: probe + MethodCacheEntries put: class.	methodCache at: probe + (MethodCacheEntries * 2) put: meth.	methodCache at: probe + (MethodCacheEntries * 3) put: primIndex.! !!Interpreter methodsFor: 'method lookup cache'!flushMethodCache	"Flush the method cache. The method cache is flushed on every programming change and garbage collect."	1 to: MethodCacheSize do: [ :i | methodCache at: i put: 0 ].	mcProbe _ 0.! !!Interpreter methodsFor: 'method lookup cache'!lookupInMethodCacheSel: selector class: class	"This method implements a simple method lookup cache. If an entry for the given selector and class is found in the cache, set the values of 'newMethod' and 'primitiveIndex' and return true. Otherwise, return false."	"About the re-probe scheme: The hash is the low bits of the XOR of two large addresses, minus their useless lowest two bits. If a probe doesn't get a hit, the hash is shifted right one bit to compute the next probe, introducing a new randomish bit. The cache is probed CacheProbeMax times before giving up."	"WARNING: Since the hash computation is based on the object addresses of the class and selector, we must rehash or flush when compacting storage. We've chosen to flush, since that also saves the trouble of updating the addresses of the objects in the cache."	| hash probe |	self inline: true.	hash _ (selector bitXor: class) >> 2.  "shift drops two low-order zeros from addresses"	probe _ (hash bitAnd: MethodCacheMask) + 1.  "initial probe"	1 to: CacheProbeMax do: [ :p |		(((methodCache at: probe) = selector) and:		 [(methodCache at: probe + MethodCacheEntries) = class]) ifTrue: [			newMethod _ methodCache at: probe + (MethodCacheEntries * 2).			primitiveIndex _ methodCache at: probe + (MethodCacheEntries * 3).			^ true	"found entry in cache; done"		].		probe _ ((hash >> p) bitAnd: MethodCacheMask) + 1	].	^ false! !!Interpreter methodsFor: 'interpreter shell'!fetchByte	"This method uses the preIncrement builtin function which has no Smalltalk equivalent. Thus, it must be overridden in the simulator."	^ self byteAt: localIP preIncrement! !!Interpreter methodsFor: 'interpreter shell'!getCurrentBytecode	"currentBytecode will be private to the main dispatch loop in the generated code. This method allows the currentBytecode to be retrieved from global variables."	^ self byteAt: instructionPointer! !!Interpreter methodsFor: 'interpreter shell'!interpret	self internalizeIPandSP.	[true] whileTrue: [		currentBytecode _ self fetchByte.		self dispatchOn: currentBytecode in: BytecodeTable.	].	self externalizeIPandSP.! !!Interpreter methodsFor: 'interpreter shell'!unknownBytecode	"This should never get called; it means that an unimplemented bytecode appears in a CompiledMethod."	self error: 'Unknown bytecode'.! !!Interpreter methodsFor: 'stack bytecodes'!duplicateTopBytecode	self internalPush: self internalStackTop.! !!Interpreter methodsFor: 'stack bytecodes'!experimentalBytecode	"Note: This bytecode is not currently generated by the compiler."	"This range of six bytecodes can replace the pushTemporaryVariable[0..5] bytecode at the beginning of a sequence of either the form:		pushTemp		pushTemp | pushConstantOne | pushLiteralConstant		<=		longJumpIfFalseor the form:		pushTemp		pushTemp | pushConstantOne | pushLiteralConstant		+		popIntoTemp (optional)If two values pushed are not small integers, this bytecode acts like the pushTemp bytecode it replaces. However, if they are small integers, then the given arithmetic or comparison operation is performed. The result of that operation is either pushed onto the stack or, if one of the expected bytecodes follows it, then that bytecode is performed immediately. In such cases, the entire four instruction sequence is performed without doing any stack operations."	| arg1 byte2 byte3 byte4 arg1Val arg2Val result offset |	arg1 _ self temporary: currentBytecode - 138.	byte2 _ self byteAt: localIP + 1.  "fetch ahead"	byte3 _ self byteAt: localIP + 2.  "fetch ahead"	byte4 _ self byteAt: localIP + 3.  "fetch ahead"	"check first arg"	(self isIntegerObject: arg1) ifTrue: [		arg1Val _ self integerValueOf: arg1.	] ifFalse: [		^ self internalPush: arg1.  "abort; first arg is not an integer"	].	"get and check second arg"	byte2 < 32 ifTrue: [		arg2Val _ self temporary: (byte2 bitAnd: 16rF).		(self isIntegerObject: arg2Val) ifTrue: [			arg2Val _ self integerValueOf: arg2Val.		] ifFalse: [			^ self internalPush: arg1.  "abort; second arg is not an integer"		].	] ifFalse: [		byte2 > 64 ifTrue: [			arg2Val _ 1.		] ifFalse: [			arg2Val _ self literal: (byte2 bitAnd: 16r1F).			(self isIntegerObject: arg2Val) ifTrue: [				arg2Val _ self integerValueOf: arg2Val.			] ifFalse: [				^ self internalPush: arg1.  "abort; second arg is not an integer"			].		].	].	byte3 < 178 ifTrue: [		"do addition, possibly followed by a storeAndPopTemp"		result _ arg1Val + arg2Val.		(self isIntegerValue: result) ifTrue: [			((byte4 > 103) and: [byte4 < 112]) ifTrue: [				"next instruction is a storeAndPopTemp"				localIP _ localIP + 3.				self storePointerUnchecked: (byte4 bitAnd: 7) + TempFrameStart					ofObject: theHomeContext					withValue: (self integerObjectOf: result).			] ifFalse: [				localIP _ localIP + 2.				self internalPush: (self integerObjectOf: result).			].		] ifFalse: [			^ self internalPush: arg1.  "abort; result is not an integer"		].	] ifFalse: [		"do comparison operation, followed by a longJumpIfFalse"		offset _ self byteAt: localIP + 4.		arg1Val <= arg2Val			ifTrue: [localIP _ localIP + 3 + 1]  "jump not taken; skip extra instruction byte"			ifFalse: [localIP _ localIP + 3 + 1 + offset].	].! !!Interpreter methodsFor: 'stack bytecodes'!extendedPushBytecode	| descriptor variableType variableIndex |	descriptor _ self fetchByte.	variableType _ (descriptor >> 6) bitAnd: 16r3.	variableIndex _ descriptor bitAnd: 16r3F.	variableType=0 ifTrue: [^self pushReceiverVariable: variableIndex].	variableType=1 ifTrue: [^self pushTemporaryVariable: variableIndex].	variableType=2 ifTrue: [^self pushLiteralConstant: variableIndex].	variableType=3 ifTrue: [^self pushLiteralVariable: variableIndex].! !!Interpreter methodsFor: 'stack bytecodes'!extendedStoreAndPopBytecode	self extendedStoreBytecode.	self popStackBytecode.! !!Interpreter methodsFor: 'stack bytecodes'!extendedStoreBytecode	| descriptor variableType variableIndex association |	self inline: true.	descriptor _ self fetchByte.	variableType _ (descriptor >> 6) bitAnd: 16r3.	variableIndex _ descriptor bitAnd: 16r3F.	variableType = 0 ifTrue:		[^self storePointer: variableIndex			ofObject: receiver			withValue: self internalStackTop].	variableType = 1 ifTrue:		[^self storePointerUnchecked: variableIndex + TempFrameStart			ofObject: theHomeContext			withValue: self internalStackTop].	variableType = 2 ifTrue:		[self error: 'illegal store'].	variableType = 3 ifTrue:		[association _ self literal: variableIndex.		^self storePointer: ValueIndex			ofObject: association			withValue: self internalStackTop].! !!Interpreter methodsFor: 'stack bytecodes'!popStackBytecode	self internalPop: 1.! !!Interpreter methodsFor: 'stack bytecodes'!pushActiveContextBytecode	"Puts reclaimability of this context in question."	reclaimableContextCount _ 0.	self internalPush: activeContext.! !!Interpreter methodsFor: 'stack bytecodes'!pushConstantFalseBytecode	self internalPush: falseObj.! !!Interpreter methodsFor: 'stack bytecodes'!pushConstantMinusOneBytecode	self internalPush: ConstMinusOne.! !!Interpreter methodsFor: 'stack bytecodes'!pushConstantNilBytecode	self internalPush: nilObj.! !!Interpreter methodsFor: 'stack bytecodes'!pushConstantOneBytecode	self internalPush: ConstOne.! !!Interpreter methodsFor: 'stack bytecodes'!pushConstantTrueBytecode	self internalPush: trueObj.! !!Interpreter methodsFor: 'stack bytecodes'!pushConstantTwoBytecode	self internalPush: ConstTwo.! !!Interpreter methodsFor: 'stack bytecodes'!pushConstantZeroBytecode	self internalPush: ConstZero.! !!Interpreter methodsFor: 'stack bytecodes'!pushLiteralConstant: literalIndex	self internalPush: (self literal: literalIndex).! !!Interpreter methodsFor: 'stack bytecodes'!pushLiteralConstantBytecode	self pushLiteralConstant: (currentBytecode bitAnd: 16r1F).! !!Interpreter methodsFor: 'stack bytecodes'!pushLiteralVariable: literalIndex	self internalPush:		(self fetchPointer: ValueIndex ofObject: (self literal: literalIndex)).! !!Interpreter methodsFor: 'stack bytecodes'!pushLiteralVariableBytecode	self pushLiteralVariable: (currentBytecode bitAnd: 16r1F).! !!Interpreter methodsFor: 'stack bytecodes'!pushReceiverBytecode	self internalPush: receiver.! !!Interpreter methodsFor: 'stack bytecodes'!pushReceiverVariable: fieldIndex	self internalPush:		(self fetchPointer: fieldIndex ofObject: receiver).! !!Interpreter methodsFor: 'stack bytecodes'!pushReceiverVariableBytecode	self pushReceiverVariable: (currentBytecode bitAnd: 16rF).! !!Interpreter methodsFor: 'stack bytecodes'!pushTemporaryVariable: temporaryIndex	self internalPush: (self temporary: temporaryIndex).! !!Interpreter methodsFor: 'stack bytecodes'!pushTemporaryVariableBytecode	self pushTemporaryVariable: (currentBytecode bitAnd: 16rF).! !!Interpreter methodsFor: 'stack bytecodes'!storeAndPopReceiverVariableBytecode	"Note: This code uses storePointerUnchecked:ofObject:withValue: and does the store check explicitely in order to help the translator produce better code."	| rcvr top |	rcvr _ receiver.	top _ self internalStackTop.	(rcvr < youngStart) ifTrue: [		self possibleRootStoreInto: rcvr value: top.	].	self storePointerUnchecked: (currentBytecode bitAnd: 7)		ofObject: rcvr		withValue: top.	self internalPop: 1.! !!Interpreter methodsFor: 'stack bytecodes'!storeAndPopTemporaryVariableBytecode	self storePointerUnchecked: (currentBytecode bitAnd: 7) + TempFrameStart		ofObject: theHomeContext		withValue: self internalStackTop.	self internalPop: 1.! !!Interpreter methodsFor: 'jump bytecodes'!jump: offset	localIP _ localIP + offset.! !!Interpreter methodsFor: 'jump bytecodes'!jumplfFalseBy: offset	| boolean |	boolean _ self internalStackTop.	boolean = falseObj ifTrue: [		self jump: offset.	] ifFalse: [		boolean = trueObj ifFalse: [			messageSelector _ self splObj: SelectorMustBeBoolean.			argumentCount _ 0.			^ self normalSend		].	].	self internalPop: 1.! !!Interpreter methodsFor: 'jump bytecodes'!jumplfTrueBy: offset	| boolean |	boolean _ self internalStackTop.	boolean = trueObj ifTrue: [		self jump: offset.	] ifFalse: [		boolean = falseObj ifFalse: [			messageSelector _ self splObj: SelectorMustBeBoolean.			argumentCount _ 0.			^ self normalSend		].	].	self internalPop: 1.! !!Interpreter methodsFor: 'jump bytecodes'!longJumpIfFalse	self jumplfFalseBy:		((currentBytecode bitAnd: 3) * 256) + self fetchByte.! !!Interpreter methodsFor: 'jump bytecodes'!longJumpIfTrue	self jumplfTrueBy:		((currentBytecode bitAnd: 3) * 256) + self fetchByte.! !!Interpreter methodsFor: 'jump bytecodes'!longUnconditionalJump	| offset |	offset _ (((currentBytecode bitAnd: 7) - 4) * 256) + self fetchByte.	localIP _ localIP + offset.	offset < 0 ifTrue: [		"backward jump means we're in a loop; check for possible interrupts"		self internalQuickCheckForInterrupts.	].! !!Interpreter methodsFor: 'jump bytecodes'!shortConditionalJump	self jumplfFalseBy: (currentBytecode bitAnd: 7) + 1.! !!Interpreter methodsFor: 'jump bytecodes'!shortUnconditionalJump	self jump: (currentBytecode bitAnd: 7) + 1.! !!Interpreter methodsFor: 'send bytecodes'!doubleExtendedDoAnythingBytecode	"Replaces the Blue Book double-extended send [132], in which	the first byte was wasted on 8 bits of argument count.	Here we use 3 bits for the operation sub-type (opType),	and the remaining 5 bits for argument count where needed.	The last byte give access to 256 instVars or literals.	See also secondExtendedSendBytecode"	| byte2 byte3 opType top |	byte2 _ self fetchByte.	byte3 _ self fetchByte.	opType _ byte2 >> 5.	opType = 0 ifTrue: [		messageSelector _ self literal: byte3.		argumentCount _ byte2 bitAnd: 16r1F.		^ self normalSend	].	opType = 1 ifTrue: [		messageSelector _ self literal: byte3.		argumentCount _ byte2 bitAnd: 16r1F.		^ self superclassSend	].	opType = 2 ifTrue: [^ self pushReceiverVariable: byte3].	opType = 3 ifTrue: [^ self pushLiteralConstant: byte3].	opType = 4 ifTrue: [^ self pushLiteralVariable: byte3].	opType = 5 ifTrue: [		top _ self internalStackTop.		^ self storePointer: byte3 ofObject: receiver withValue: top	].	opType = 6 ifTrue: [		top _ self internalStackTop.		self internalPop: 1.		^ self storePointer: byte3 ofObject: receiver withValue: top	].	opType = 7 ifTrue: [		top _ self internalStackTop.		^ self storePointer: ValueIndex ofObject: (self literal: byte3) withValue: top	].! !!Interpreter methodsFor: 'send bytecodes'!secondExtendedSendBytecode	"This replaces the Blue Book double-extended super-send [134],	which is subsumed by the new double-extended do-anything [132].	It offers a 2-byte send of 0-3 args for up to 63 literals, for which 	the Blue Book opcode set requires a 3-byte instruction."	| descriptor |	descriptor _ self fetchByte.	messageSelector _ self literal: (descriptor bitAnd: 16r3F).	argumentCount _ descriptor >> 6.	self normalSend.! !!Interpreter methodsFor: 'send bytecodes'!sendLiteralSelectorBytecode	"Can use any of the first 16 literals for the selector and pass up to 2 arguments."	messageSelector _ self literal: (currentBytecode bitAnd: 16rF).	argumentCount _ ((currentBytecode >> 4) bitAnd: 3) - 1.	self normalSend.! !!Interpreter methodsFor: 'send bytecodes'!singleExtendedSendBytecode	"Can use any of the first 32 literals for the selector and pass up to 7 arguments."	| descriptor |	descriptor _ self fetchByte.	messageSelector _ self literal: (descriptor bitAnd: 16r1F).	argumentCount _ descriptor >> 5.	self normalSend.! !!Interpreter methodsFor: 'send bytecodes'!singleExtendedSuperBytecode	"Can use any of the first 32 literals for the selector and pass up to 7 arguments."	| descriptor |	descriptor _ self fetchByte.	messageSelector _ self literal: (descriptor bitAnd: 16r1F).	argumentCount _ descriptor >> 5.	self superclassSend.! !!Interpreter methodsFor: 'return bytecodes'!returnFalse	| cntx val |	cntx _ self sender.	val _ falseObj.	self returnValue: val to: cntx.! !!Interpreter methodsFor: 'return bytecodes'!returnNil	| cntx val |	cntx _ self sender.	val _ nilObj.	self returnValue: val to: cntx.! !!Interpreter methodsFor: 'return bytecodes'!returnReceiver	| cntx val |	cntx _ self sender.	val _ receiver.	self returnValue: val to: cntx.! !!Interpreter methodsFor: 'return bytecodes'!returnTopFromBlock	"Return to the caller of the method containing the block."	| cntx val |	cntx _ self caller.  "Note: caller, not sender!!"	val _ self internalStackTop.	self returnValue: val to: cntx.! !!Interpreter methodsFor: 'return bytecodes'!returnTopFromMethod	| cntx val |	cntx _ self sender.	val _ self internalStackTop.	self returnValue: val to: cntx.! !!Interpreter methodsFor: 'return bytecodes'!returnTrue	| cntx val |	cntx _ self sender.	val _ trueObj.	self returnValue: val to: cntx.! !!Interpreter methodsFor: 'return bytecodes'!returnValue: resultObj to: returnContext	"Note: Assumed to be inlined into the dispatch loop."	| nilOop thisCntx methodContextClass contextOfCaller |	self inline: true.	self sharedCodeNamed: 'commonReturn' inCase: 120.	nilOop _ nilObj. "keep in a register"	thisCntx _ activeContext.	methodContextClass _ self splObj: ClassMethodContext.	"make sure we can return to the given context"	((returnContext = nilOop) or:	 [(self fetchPointer: InstructionPointerIndex ofObject: returnContext) = nilOop]) ifTrue: [		"error: sender's instruction pointer or context is nil; cannot return"		self internalPush: activeContext.		self internalPush: resultObj.		messageSelector _ self splObj: SelectorCannotReturn.		argumentCount _ 1.		^ self normalSend	].	[thisCntx = returnContext] whileFalse: [		"climb up stack to returnContext"		contextOfCaller _ self fetchPointer: SenderIndex ofObject: thisCntx.		"zap exited contexts so any future attempted use will be caught"		self storePointerUnchecked: SenderIndex ofObject: thisCntx withValue: nilOop.		self storePointerUnchecked: InstructionPointerIndex ofObject: thisCntx withValue: nilOop.		reclaimableContextCount > 0 ifTrue: [			"try to recycle this context"			reclaimableContextCount _ reclaimableContextCount - 1.			self recycleContextIfPossible: thisCntx methodContextClass: methodContextClass.		].		thisCntx _ contextOfCaller.	].	activeContext _ thisCntx.	(thisCntx < youngStart) ifTrue: [ self beRootIfOld: thisCntx ].	self internalFetchContextRegisters: thisCntx.  "updates local IP and SP"	self internalPush: resultObj.	self internalQuickCheckForInterrupts.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimAdd	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).		(self isIntegerValue: result) ifTrue: [			self longAt: (localSP _ localSP - 4)					put: (self integerObjectOf: result).			^ nil		].	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatAdd.	successFlag ifFalse: [		successFlag _ true.		self primitiveAdd.	].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimAt	| index rcvr result rcvrClass stringy |	index _ self internalStackTop.	rcvr _ self internalStackValue: 1.	successFlag _ self isIntegerObject: index.	successFlag ifTrue: [		rcvrClass _ self fetchClassOf: rcvr.		stringy _ rcvrClass = (self splObj: ClassString).		(stringy or: [self okArrayClass: rcvrClass])			ifFalse: [successFlag _ false]].	successFlag ifTrue: [		index _ self integerValueOf: index.self externalizeIPandSP.		result _ self stObject: rcvr at: index.self internalizeIPandSP.		(stringy and: [successFlag]) ifTrue: [result _ self characterForAscii: result]].	successFlag ifTrue: [		self internalPop: 2 thenPush: result.	] ifFalse: [		messageSelector _ self specialSelector: 16.		argumentCount _ 1.		self normalSend.	].! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 6/21/97 08:58'!bytecodePrimAtEnd	messageSelector _ self specialSelector: 21.	argumentCount _ 0.	self normalSend.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimAtPut	| value valToStore index rcvr rcvrClass stringy |	value _ valToStore _ self internalStackTop.	index _ self internalStackValue: 1.	rcvr _ self internalStackValue: 2.	successFlag _ self isIntegerObject: index.	successFlag ifTrue: [		rcvrClass _ self fetchClassOf: rcvr.		stringy _ rcvrClass = (self splObj: ClassString).		(stringy or: [self okArrayClass: rcvrClass])			ifFalse: [successFlag _ false]].	successFlag ifTrue: [		index _ self integerValueOf: index.		stringy ifTrue: [valToStore _ self asciiOfCharacter: value].		self stObject: rcvr at: index put: valToStore.	].	successFlag ifTrue: [		self internalPop: 3 thenPush: value.	] ifFalse: [		messageSelector _ self specialSelector: 17.		argumentCount _ 2.		self normalSend.	].! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimBitAnd	self externalizeIPandSP.	self primitiveBitAnd.	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimBitOr	self externalizeIPandSP.	self primitiveBitOr.	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimBitShift	self externalizeIPandSP.	self primitiveBitShift.	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimBlockCopy	| rcvrClass |	rcvrClass _ self fetchClassOf: (self internalStackValue: 1).	successFlag _ true.	self success:		((rcvrClass = (self splObj: ClassBlockContext)) or:		 [rcvrClass = (self splObj: ClassMethodContext)]).	successFlag ifTrue: [		self externalizeIPandSP.		self primitiveBlockCopy.		self internalizeIPandSP.	].	successFlag ifFalse: [		messageSelector _ self specialSelector: 24.		argumentCount _ 1.		^ self normalSend	].! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimClass	self externalizeIPandSP.	self primitiveClass.	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimDiv	self externalizeIPandSP.	self primitiveDiv.	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimDivide	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		rcvr _ self integerValueOf: rcvr.		arg _ self integerValueOf: arg.		((arg ~= 0) and: [(rcvr \\ arg) = 0]) ifTrue: [			result _ rcvr // arg.  "generates C / operation"			(self isIntegerValue: result) ifTrue: [				self longAt: (localSP _ localSP - 4)						put: (self integerObjectOf: result).				^ nil			].		].	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatDivide.	successFlag ifFalse: [		successFlag _ true.		self primitiveDivide.	].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimDo	messageSelector _ self specialSelector: 27.	argumentCount _ 1.	self normalSend.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimEqual	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr = arg	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatEqual.	successFlag ifFalse: [		successFlag _ true.		self primitiveEqual.	].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimEquivalent	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	self booleanCheat: rcvr = arg.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimGreaterOrEqual	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr >= arg	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatGreaterOrEqual.	successFlag ifFalse: [		successFlag _ true.		self primitiveGreaterOrEqual.	].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimGreaterThan	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr > arg	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatGreaterThan.	successFlag ifFalse: [		successFlag _ true.		self primitiveGreaterThan.	].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimLessOrEqual	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr <= arg	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatLessOrEqual.	successFlag ifFalse: [		successFlag _ true.		self primitiveLessOrEqual.	].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimLessThan	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr < arg	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatLessThan.	successFlag ifFalse: [		successFlag _ true.		self primitiveLessThan.	].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimMakePoint	self externalizeIPandSP.	self primitiveMakePoint.	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimMod	self externalizeIPandSP.	self primitiveMod.	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimMultiply	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		rcvr _ self integerValueOf: rcvr.		arg _ self integerValueOf: arg.		result _ rcvr * arg.		((arg = 0 or: [(result // arg) = rcvr]) and:		 [self isIntegerValue: result]) ifTrue: [			self longAt: (localSP _ localSP - 4)					put: (self integerObjectOf: result).			^ nil		].	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatMultiply.	successFlag ifFalse: [		successFlag _ true.		self primitiveMultiply.	].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimNew	messageSelector _ self specialSelector: 28.	argumentCount _ 0.	self normalSend.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimNewWithArg	messageSelector _ self specialSelector: 29.	argumentCount _ 1.	self normalSend.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 6/21/97 08:58'!bytecodePrimNext	messageSelector _ self specialSelector: 19.	argumentCount _ 0.	self normalSend.! !!Interpreter methodsFor: 'common selector sends' stamp: 'di 6/21/97 10:12'!bytecodePrimNextPut	messageSelector _ self specialSelector: 20.	argumentCount _ 1.	self normalSend.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimNotEqual	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr ~= arg	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatNotEqual.	successFlag ifFalse: [		successFlag _ true.		self primitiveNotEqual.	].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimPointX	self externalizeIPandSP.	self primitivePointX.	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimPointY	self externalizeIPandSP.	self primitivePointY.	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimSize	"See the comment in bytePrimitiveAt"	| arrayClass |	self externalizeIPandSP.	successFlag _ true.	arrayClass _ self fetchClassOf: (self stackValue: 0).	(self okStreamArrayClass: arrayClass)		ifTrue: [self primitiveSize]		ifFalse: [self failSpecialPrim: 0].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimSubtract	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		result _ (self integerValueOf: rcvr) - (self integerValueOf: arg).		(self isIntegerValue: result) ifTrue: [			self longAt: (localSP _ localSP - 4)					put: (self integerObjectOf: result).			^ nil		].	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatSubtract.	successFlag ifFalse: [		successFlag _ true.		self primitiveSubtract.	].	self internalizeIPandSP.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimValue	| block |	block _ self internalStackTop.	successFlag _ true.	argumentCount _ 0.	self assertClassOf: block is: (self splObj: ClassBlockContext).	successFlag ifTrue: [		self externalizeIPandSP.		self primitiveValue.		self internalizeIPandSP.	].	successFlag ifFalse: [		messageSelector _ self specialSelector: 25.		argumentCount _ 0.		^ self normalSend	].! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimValueWithArg	| block |	block _ self internalStackValue: 1.	successFlag _ true.	argumentCount _ 1.	self assertClassOf: block is: (self splObj: ClassBlockContext).	successFlag ifTrue: [		self externalizeIPandSP.		self primitiveValue.		self internalizeIPandSP.	].	successFlag ifFalse: [		messageSelector _ self specialSelector: 26.		argumentCount _ 1.		^ self normalSend	].! !!Interpreter methodsFor: 'primitive support'!failed	^successFlag not! !!Interpreter methodsFor: 'primitive support'!failSpecialPrim: primIndex	"Used only for failing from a primitive that was entered as a special	bytecode.  This routine will look up the real method and, only if its	primitiveIndex is different, then it will run that primitive, otherwise	it will simply activate to run the fail code"	| bytecode selectorIndex newReceiver rcvrClass |	bytecode _ self getCurrentBytecode.	(bytecode < 176 or: [bytecode > 207])		ifTrue: ["Primitive was not running as a special bytecode"				^ self primitiveFail].	selectorIndex _ (bytecode - 176) * 2.	messageSelector _ self fetchPointer: selectorIndex				ofObject: (self splObj: SpecialSelectors).	argumentCount _ self quickFetchInteger: selectorIndex + 1				ofObject: (self splObj: SpecialSelectors)."	self sendSelector: messageSelector argumentCount: count"	"The above line of code must be expanded and altered, because we only	want to run the ST code, not re-run the primitive and get into a loop"	newReceiver _ self stackValue: argumentCount.	rcvrClass _ self fetchClassOf: newReceiver.	self findNewMethodInClass: rcvrClass.	(primitiveIndex > 37 and: [primitiveIndex ~= primIndex])		ifTrue: [self executeNewMethod]		ifFalse: [self activateNewMethod]! !!Interpreter methodsFor: 'primitive support'!positive32BitIntegerFor: integerValue	| newLargeInteger |	"Note - integerValue is interpreted as POSITIVE, eg, as the result of		Bitmap>at:, or integer>bitAnd:."	(integerValue >= 0 and: [self isIntegerValue: integerValue])		ifTrue: [^ self integerObjectOf: integerValue].	newLargeInteger _		self instantiateSmallClass: (self splObj: ClassLargePositiveInteger)				sizeInBytes: 8						 fill: 0.	self storeByte: 3 ofObject: newLargeInteger		withValue: ((integerValue >> 24) bitAnd: 16rFF).	self storeByte: 2 ofObject: newLargeInteger		withValue: ((integerValue >> 16) bitAnd: 16rFF).	self storeByte: 1 ofObject: newLargeInteger		withValue: ((integerValue >> 8) bitAnd: 16rFF).	self storeByte: 0 ofObject: newLargeInteger		withValue: (integerValue bitAnd: 16rFF).	^ newLargeInteger! !!Interpreter methodsFor: 'primitive support'!positive32BitValueOf: oop	"Convert the given object into an integer value.	The object may be either a positive ST integer or a four-byte LargePositiveInteger."	| sz value |	(self isIntegerObject: oop) ifTrue: [		value _ self integerValueOf: oop.		value < 0 ifTrue: [^ self primitiveFail].		^ value].	self assertClassOf: oop is: (self splObj: ClassLargePositiveInteger).	successFlag ifTrue: [		sz _ self lengthOf: oop.		sz = 4 ifFalse: [^ self primitiveFail]].	successFlag ifTrue: [		^ (self fetchByte: 0 ofObject: oop) +		  ((self fetchByte: 1 ofObject: oop) <<  8) +		  ((self fetchByte: 2 ofObject: oop) << 16) +		  ((self fetchByte: 3 ofObject: oop) << 24) ].! !!Interpreter methodsFor: 'primitive support'!primIndex	^ primitiveIndex! !!Interpreter methodsFor: 'primitive support'!primitiveFail	successFlag _ false.! !!Interpreter methodsFor: 'primitive support' stamp: 'jm 9/18/97 21:06'!primitiveResponse	primitiveIndex > MaxPrimitiveIndex ifTrue: [^ false].	successFlag _ true.	self dispatchOn: primitiveIndex in: PrimitiveTable.	"check for possible timer interrupts after each primitive"	(successFlag and:	 [(nextWakeupTick ~= 0) and:	 [self ioMSecs >= nextWakeupTick]]) ifTrue: [		interruptCheckCounter _ 1000.		self checkForInterrupts].	^ successFlag! !!Interpreter methodsFor: 'primitive support'!success: successValue	successFlag _ successValue & successFlag.! !!Interpreter methodsFor: 'arithmetic primitives'!checkBooleanResult: result from: primIndex	successFlag		ifTrue: [self pushBool: result]		ifFalse: [self unPop: 2.  self failSpecialPrim: primIndex]! !!Interpreter methodsFor: 'arithmetic primitives'!checkIntegerResult: integerResult from: primIndex	(successFlag and: [self isIntegerValue: integerResult])		ifTrue: [self pushInteger: integerResult]		ifFalse: [self unPop: 2.  self failSpecialPrim: primIndex]! !!Interpreter methodsFor: 'arithmetic primitives'!compare31or32Bits: obj1 equal: obj2	"May set success to false"	"First compare two ST integers..."	((self isIntegerObject: obj1)		and: [self isIntegerObject: obj2])		ifTrue: [^ obj1 = obj2].	"Now compare, assuming positive integers, but setting fail if not"	^ (self positive32BitValueOf: obj1) = (self positive32BitValueOf: obj2)! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveAdd	| rcvr arg result |	rcvr _ self stackValue: 1.	arg _ self stackValue: 0.	self pop: 2.	self success: (self areIntegers: rcvr and: arg).	successFlag ifTrue: [		result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).	].	self checkIntegerResult: result from: 1.! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveBitAnd	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitAnd: integerArgument))]		ifFalse: [self unPop: 2.  self failSpecialPrim: 14]! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveBitOr	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitOr: integerArgument))]		ifFalse: [self unPop: 2.  self failSpecialPrim: 15]! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveBitShift 	| integerReceiver integerArgument shifted |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popPos32BitInteger.	successFlag ifTrue: [		integerArgument >= 0 ifTrue: [			"Left shift -- must fail if we lose bits beyond 32"			self success: integerArgument <= 31.			shifted _ integerReceiver << integerArgument.			self success: (shifted >> integerArgument) = integerReceiver.		] ifFalse: [			"Right shift -- OK to lose bits"			self success: integerArgument >= -31.			shifted _ integerReceiver bitShift: integerArgument.		].	].	successFlag		ifTrue: [self push: (self positive32BitIntegerFor: shifted)]		ifFalse: [self unPop: 2.  self failSpecialPrim: 17]! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveBitXor	"Note: unlike all the other arithmetic primitives, this is called as	a real send, not as a special byte.  Thus successFlag has already	been set, and failure is normal, not through failSpecialPrim."	| integerReceiver integerArgument |	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitXor: integerArgument))]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveDiv	"Rounds negative results towards negative infinity, rather than zero."	| rcvr arg result posArg posRcvr |	successFlag _ true.	arg _ self popInteger.	rcvr _ self popInteger.	self success: arg ~= 0.	successFlag ifTrue: [		rcvr > 0 ifTrue: [			arg > 0 ifTrue: [				result _ rcvr // arg.			] ifFalse: [				"round negative result toward negative infinity"				posArg _ 0 - arg.				result _ 0 - ((rcvr + (posArg - 1)) // posArg).			].		] ifFalse: [			posRcvr _ 0 - rcvr.			arg > 0 ifTrue: [				"round negative result toward negative infinity"				result _ 0 - ((posRcvr + (arg - 1)) // arg).			] ifFalse: [				posArg _ 0 - arg.				result _ posRcvr // posArg.			].		].		self checkIntegerResult: result from: 12]	ifFalse:		[self checkIntegerResult: 0 from: 12 "will fail"]! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveDivide	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self success: integerArgument ~= 0.	successFlag ifFalse: [integerArgument _ 1].  "fall through to fail"	self success: integerReceiver \\ integerArgument = 0.	self checkIntegerResult: integerReceiver // integerArgument from: 10! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveEqual	| integerReceiver integerArgument result |	successFlag _ true.	integerArgument _ self popStack.	integerReceiver _ self popStack.	result _ self compare31or32Bits: integerReceiver equal: integerArgument.	self checkBooleanResult: result from: 7! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveGreaterOrEqual	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver >= integerArgument from: 6! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveGreaterThan	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver > integerArgument from: 4! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveLessOrEqual	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver <= integerArgument from: 5! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveLessThan	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver < integerArgument from: 3! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveMakePoint	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	successFlag		ifTrue: [self push: (self makePointwithxValue: integerReceiver yValue: integerArgument)]		ifFalse: [self checkIntegerResult: 0 from: 18  "will fail"]! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveMod	| integerReceiver integerArgument integerResult |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self success: integerArgument ~= 0.	successFlag ifFalse: [integerArgument _ 1].  "fall through to fail"	integerResult _ integerReceiver \\ integerArgument.	integerResult < 0 ifTrue: [integerResult _ integerResult + integerArgument].	self checkIntegerResult: integerResult from: 11! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveMultiply	| rcvr arg result |	rcvr _ self stackValue: 1.	arg _ self stackValue: 0.	self pop: 2.	self success: (self areIntegers: rcvr and: arg).	successFlag ifTrue: [		rcvr _ self integerValueOf: rcvr.		arg _ self integerValueOf: arg.		result _ rcvr * arg.		"check for C overflow by seeing if computation is reversible"		self success: ((arg = 0) or: [(result // arg) = rcvr]).	].	self checkIntegerResult: result from: 9.! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveNotEqual	| integerReceiver integerArgument result |	successFlag _ true.	integerArgument _ self popStack.	integerReceiver _ self popStack.	result _ (self compare31or32Bits: integerReceiver equal: integerArgument) not.	self checkBooleanResult: result from: 8! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveQuo	"Rounds negative results towards zero."	"Note: unlike the other arithmetic primitives, this is called as	a real send, not as a special byte.  Thus successFlag has already	been set, and failure is normal, not through failSpecialPrim."	| rcvr arg result |	arg _ self popInteger.	rcvr _ self popInteger.	self success: arg ~= 0.	successFlag ifTrue: [		rcvr > 0 ifTrue: [			arg > 0 ifTrue: [				result _ rcvr // arg.			] ifFalse: [				result _ 0 - (rcvr // (0 - arg)).			].		] ifFalse: [			arg > 0 ifTrue: [				result _ 0 - ((0 - rcvr) // arg).			] ifFalse: [				result _ (0 - rcvr) // (0 - arg).			].		].		self success: (self isIntegerValue: result)].	successFlag		ifTrue: [self pushInteger: result]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'arithmetic primitives'!primitiveSubtract	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkIntegerResult: integerReceiver - integerArgument from: 2! !!Interpreter methodsFor: 'float primitives'!popFloat	"Note: May be called by translated primitive code."	| top result |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	top _ self popStack.	self assertClassOf: top is: (self splObj: ClassFloat).	successFlag		ifTrue: [self fetchFloatAt: top + BaseHeaderSize into: result].	^ result! !!Interpreter methodsFor: 'float primitives'!primitiveArctan	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'atan(rcvr)')]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives'!primitiveAsFloat	| arg |	arg _ self popInteger.	successFlag		ifTrue: [ self pushFloat: (self cCode: '((double) arg)') ]		ifFalse: [ self unPop: 1 ].! !!Interpreter methodsFor: 'float primitives'!primitiveExp	"Computes E raised to the receiver power."	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'exp(rcvr)')]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives'!primitiveExponent	"Exponent part of this float."	| rcvr frac pwr |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	rcvr _ self popFloat.	successFlag		ifTrue: [			self cCode: 'frac = frexp(rcvr, &pwr)'.  "rcvr = frac * 2^pwr, where frac is in [0.5..1.0)"			(pwr = 0)				ifTrue: [self pushInteger: 0]				ifFalse: [self pushInteger: pwr - 1]]		ifFalse: [self unPop: 1].! !!Interpreter methodsFor: 'float primitives'!primitiveFloatAdd	| rcvr rcvrOop arg argOop result resultOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	self var: #result declareC: 'double result'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		result _ rcvr + arg.		resultOop _ self clone: rcvrOop.		self storeFloatAt: resultOop + BaseHeaderSize from: result.		self pop: 2 thenPush: resultOop].! !!Interpreter methodsFor: 'float primitives'!primitiveFloatDivide	| rcvr rcvrOop arg argOop result resultOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	self var: #result declareC: 'double result'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self success: arg ~= 0.0.		successFlag ifTrue: [			result _ rcvr // arg.  "generates C / operation"			resultOop _ self clone: rcvrOop.			self storeFloatAt: resultOop + BaseHeaderSize from: result.			self pop: 2 thenPush: resultOop]].! !!Interpreter methodsFor: 'float primitives'!primitiveFloatEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr = arg].! !!Interpreter methodsFor: 'float primitives'!primitiveFloatGreaterOrEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr >= arg].! !!Interpreter methodsFor: 'float primitives'!primitiveFloatGreaterThan	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr > arg].! !!Interpreter methodsFor: 'float primitives'!primitiveFloatLessOrEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr <= arg].! !!Interpreter methodsFor: 'float primitives'!primitiveFloatLessThan	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr < arg].! !!Interpreter methodsFor: 'float primitives'!primitiveFloatMultiply	| rcvr rcvrOop arg argOop result resultOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	self var: #result declareC: 'double result'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		result _ rcvr * arg.		resultOop _ self clone: rcvrOop.		self storeFloatAt: resultOop + BaseHeaderSize from: result.		self pop: 2 thenPush: resultOop].! !!Interpreter methodsFor: 'float primitives'!primitiveFloatNotEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr ~= arg].! !!Interpreter methodsFor: 'float primitives'!primitiveFloatSubtract	| rcvr rcvrOop arg argOop result resultOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	self var: #result declareC: 'double result'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		result _ rcvr - arg.		resultOop _ self clone: rcvrOop.		self storeFloatAt: resultOop + BaseHeaderSize from: result.		self pop: 2 thenPush: resultOop].! !!Interpreter methodsFor: 'float primitives'!primitiveFractionalPart	| rcvr frac trunc |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	self var: #trunc declareC: 'double trunc'.	rcvr _ self popFloat.	successFlag		ifTrue: [			self cCode: 'frac = modf(rcvr, &trunc)'.			self pushFloat: frac]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives'!primitiveLogN	"Natural log."	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'log(rcvr)')]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives'!primitiveSine	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'sin(rcvr)')]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives'!primitiveSquareRoot	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	self success: rcvr >= 0.0.	successFlag		ifTrue: [self pushFloat: (self cCode: 'sqrt(rcvr)')]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives'!primitiveTimesTwoPower	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	arg _ self popInteger.	rcvr _ self popFloat.	successFlag		ifTrue: [ self pushFloat: (self cCode: 'ldexp(rcvr, arg)') ]		ifFalse: [ self unPop: 2 ].! !!Interpreter methodsFor: 'float primitives' stamp: '6/7/97 09:59 di'!primitiveTruncated 	| rcvr frac trunc |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	self var: #trunc declareC: 'double trunc'.	rcvr _ self popFloat.	successFlag ifTrue: [		self cCode: 'frac = modf(rcvr, &trunc)'.		self cCode: 'success((-1073741824.0 <= trunc) && (trunc <= 1073741823.0))'.	].	successFlag		ifTrue: [self cCode: 'pushInteger((int) trunc)']		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'float primitives'!pushFloat: f	| newFloatObj |	self var: #f declareC: 'double f'.	newFloatObj _ self instantiateSmallClass: (self splObj: ClassFloat) sizeInBytes: 12 fill: 0.	self storeFloatAt: newFloatObj + BaseHeaderSize from: f.	self push: newFloatObj.! !!Interpreter methodsFor: 'array and stream primitives'!asciiOfCharacter: characterObj  "Returns an integer object"	self inline: false.	self assertClassOf: characterObj is: (self splObj: ClassCharacter).	successFlag		ifTrue: [^ self fetchPointer: CharacterValueIndex ofObject: characterObj]		ifFalse: [^ ConstZero]  "in case some code needs an int"! !!Interpreter methodsFor: 'array and stream primitives'!byteLengthOf: oop	"Return the number of indexable bytes in the given object. This is basically a special copy of lengthOf: for BitBlt."	| header sz fmt |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: 16rFC ].	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize)]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3)]  "bytes"! !!Interpreter methodsFor: 'array and stream primitives'!characterForAscii: integerObj  "Arg must lie in range 0-255!!"	^ self fetchPointer: (self integerValueOf: integerObj)			ofObject: (self splObj: CharacterTable)! !!Interpreter methodsFor: 'array and stream primitives'!commonAt: stringy	"This version of at: is called from the special byteCode, from	primitiveAt, and from primStringAt.  The boolean 'stringy'	indicates that the result should be converted to a Character."	| index rcvr result |	self inline: true.	index _ self stackTop.	rcvr _ self stackValue: 1.	(self isIntegerObject: index) & (self isIntegerObject: rcvr) not ifTrue: [		index _ self integerValueOf: index.		result _ self stObject: rcvr at: index.		(stringy and: [successFlag]) ifTrue: [result _ self characterForAscii: result].	] ifFalse: [		successFlag _ false.	].	successFlag ifTrue: [		self pop: 2 thenPush: result.	] ifFalse: [		stringy			ifTrue: [self failSpecialPrim: 63]			ifFalse: [self failSpecialPrim: 60].	].! !!Interpreter methodsFor: 'array and stream primitives'!commonAtPut: stringy	"See the comment in commonAt:."	| value valToStore index rcvr |	self inline: true.	value _ valToStore _ self stackTop.	index _ self stackValue: 1.	rcvr _ self stackValue: 2.	(self isIntegerObject: index) & (self isIntegerObject: rcvr) not ifTrue: [		index _ self integerValueOf: index.		stringy ifTrue: [valToStore _ self asciiOfCharacter: value].		self stObject: rcvr at: index put: valToStore.	] ifFalse: [		successFlag _ false.	].	successFlag ifTrue: [		self pop: 3 thenPush: value.	] ifFalse: [		stringy			ifTrue: [self failSpecialPrim: 64]			ifFalse: [self failSpecialPrim: 61].	].! !!Interpreter methodsFor: 'array and stream primitives'!lengthOf: oop	"Return the number of indexable bytes or words in the given object. Assume the argument is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result."	| header sz fmt |	self inline: true.	"from ObjectMemory>sizeBitsOf:..."	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: 16rFC ].	"from ObjectMemory>formatOf:..."	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"! !!Interpreter methodsFor: 'array and stream primitives'!lengthOf: oop baseHeader: hdr format: fmt	"Return the number of indexable bytes or words in the given object. Assume the given oop is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result of this method."	| sz |	self inline: true.	(hdr bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ hdr bitAnd: 16rFC ].	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"! !!Interpreter methodsFor: 'array and stream primitives'!okArrayClass: cl	^(cl = (self splObj: ClassArray) or:	  [cl = (self splObj: ClassBitmap) or:	  [cl = (self splObj: ClassByteArray)]])! !!Interpreter methodsFor: 'array and stream primitives'!okStreamArrayClass: cl	^(cl = (self splObj: ClassString) or:	  [cl = (self splObj: ClassArray) or:	  [cl = (self splObj: ClassByteArray) or:	  [cl = (self splObj: ClassBitmap)]]])! !!Interpreter methodsFor: 'array and stream primitives'!primitiveAt	self commonAt: false.! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 6/21/97 10:13'!primitiveAtEnd	| stream array index limit arrayClass size |	stream _ self popStack.	successFlag _ ((self isPointers: stream)			and: [(self lengthOf: stream) >= (StreamReadLimitIndex+1)]). 	successFlag ifTrue: [		array _ self fetchPointer: StreamArrayIndex ofObject: stream.		index _ self fetchInteger: StreamIndexIndex ofObject: stream.		limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.		arrayClass _ self fetchClassOf: array.		self success: (self okStreamArrayClass: arrayClass).		size _ self stSizeOf: array]. 	successFlag		ifTrue: [self pushBool: (index >= limit) | (index >= size)]		ifFalse: [self unPop: 1].! !!Interpreter methodsFor: 'array and stream primitives'!primitiveAtPut	self commonAtPut: false.! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 6/21/97 10:13'!primitiveNext	| stream array index limit arrayClass stringy result |	stream _ self popStack.	successFlag _		((self isPointers: stream) and:		 [(self lengthOf: stream) >= (StreamReadLimitIndex + 1)]). 	successFlag ifTrue: [		array _ self fetchPointer: StreamArrayIndex ofObject: stream.		index _ self fetchInteger: StreamIndexIndex ofObject: stream.		limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.		arrayClass _ self fetchClassOf: array.		stringy _ arrayClass = (self splObj: ClassString).		stringy ifFalse: [			self success: (self okStreamArrayClass: arrayClass)].		self success: index < limit].	successFlag ifTrue: [		index _ index + 1.		self pushRemappableOop: stream.		result _ self stObject: array at: index.  "may cause GC!!"		stream _ self popRemappableOop].	successFlag ifTrue: [		self storeInteger: StreamIndexIndex			ofObject: stream			withValue: index].	successFlag ifTrue: [		stringy			ifTrue: [self push: (self characterForAscii: result)]			ifFalse: [self push: result].	] ifFalse: [		self unPop: 1].! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'di 6/21/97 10:13'!primitiveNextPut	| value stream index limit array arrayClass storeVal |	value _ self popStack.	stream _ self popStack.	successFlag _ ((self isPointers: stream)			and: [(self lengthOf: stream) >= (StreamWriteLimitIndex+1)]). 	successFlag ifTrue: [		array _ self fetchPointer: StreamArrayIndex ofObject: stream.		index _ self fetchInteger: StreamIndexIndex ofObject: stream.		limit _ self fetchInteger: StreamWriteLimitIndex ofObject: stream.		arrayClass _ self fetchClassOf: array.		self success: (self okStreamArrayClass: arrayClass).		self success: index < limit].	successFlag ifTrue:		[index _ index + 1.		arrayClass = (self splObj: ClassString)			ifTrue: [storeVal _ self asciiOfCharacter: value]			ifFalse: [storeVal _ value].		self stObject: array at: index put: storeVal].	successFlag ifTrue:		[self storeInteger: StreamIndexIndex ofObject: stream			withValue: index].	successFlag		ifTrue: [self push: value]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'array and stream primitives'!primitiveSize	| rcvr sz |	rcvr _ self stackTop.	(self isIntegerObject: rcvr)		ifTrue: [sz _ 0]  "integers have no indexable fields"		ifFalse: [sz _ self stSizeOf: rcvr].	successFlag		ifTrue: [self pop: 1. self pushInteger: sz]		ifFalse: [self failSpecialPrim: 62].! !!Interpreter methodsFor: 'array and stream primitives'!primitiveStringAt	self commonAt: true.! !!Interpreter methodsFor: 'array and stream primitives'!primitiveStringAtPut	self commonAtPut: true.! !!Interpreter methodsFor: 'array and stream primitives'!primitiveStringReplace"<array> primReplaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>"	| array start stop repl replStart hdr arrayFmt totalLength arrayInstSize replFmt replInstSize srcIndex |	array _ self stackValue: 4.	start _ self stackIntegerValue: 3.	stop _ self stackIntegerValue: 2.	repl _ self stackValue: 1.	replStart _ self stackIntegerValue: 0.	successFlag ifFalse: [^ self primitiveFail].	(self isIntegerObject: repl)  "can happen in LgInt copy"		ifTrue: [^ self primitiveFail].	hdr _ self baseHeader: array.	arrayFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: arrayFmt.	arrayInstSize _ self fixedFieldsOf: array format: arrayFmt length: totalLength.	((start >= 1) and: [(start <= stop) and: [stop + arrayInstSize <= totalLength]])		ifFalse: [^ self primitiveFail].	hdr _ self baseHeader: repl.	replFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: repl baseHeader: hdr format: replFmt.	replInstSize _ self fixedFieldsOf: repl format: replFmt length: totalLength.	((replStart >= 1) and: [stop - start + replStart + replInstSize <= totalLength])		ifFalse: [^ self primitiveFail].	"Array formats (without byteSize bits, if bytes array) must be same"	arrayFmt < 8		ifTrue: [arrayFmt = replFmt ifFalse: [^ self primitiveFail]]		ifFalse: [(arrayFmt bitAnd: 16rC) = (replFmt bitAnd: 16rC) ifFalse: [^ self primitiveFail]].	srcIndex _ replStart + replInstSize - 1.   " - 1 for 0-based access"	start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 		arrayFmt < 4 ifTrue: [  "pointer type objects"			self storePointer: i ofObject: array withValue:				(self fetchPointer: srcIndex ofObject: repl)]		ifFalse: [			arrayFmt < 8 ifTrue: [  "long-word type objects"				self storeWord: i ofObject: array withValue:					(self fetchWord: srcIndex ofObject: repl)]			ifFalse: [  "byte-type objects"				self storeByte: i ofObject: array withValue:					(self fetchByte: srcIndex ofObject: repl)]].		srcIndex _ srcIndex + 1.	].	self pop: 4.  "leave rcvr on stack"! !!Interpreter methodsFor: 'array and stream primitives'!stObject: array at: index	"Return what ST would return for <obj> at: index."	| hdr fmt totalLength fixedFields |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	((index >= 1) and: [index <= (totalLength - fixedFields)]) ifFalse: [successFlag _ false].	successFlag		ifTrue: [^ self subscript: array with: (index + fixedFields) format: fmt]		ifFalse: [^ 0 ].! !!Interpreter methodsFor: 'array and stream primitives'!stObject: array at: index put: value	"Do what ST would return for <obj> at: index put: value."	| hdr fmt totalLength fixedFields |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	((index >= 1) and: [index <= (totalLength - fixedFields)]) ifFalse: [successFlag _ false].	successFlag ifTrue:		[self subscript: array with: (index + fixedFields) storing: value format: fmt].! !!Interpreter methodsFor: 'array and stream primitives'!stSizeOf: oop	"Return the number of indexable fields in the given object. (i.e., what Smalltalk would return for <obj> size)."	"Note: Assume oop is not a SmallInteger!!"	| hdr fmt totalLength fixedFields |	self inline: true.	hdr _ self baseHeader: oop.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: oop baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: oop format: fmt length: totalLength.	^ totalLength - fixedFields! !!Interpreter methodsFor: 'array and stream primitives'!subscript: array with: index format: fmt	"Note: This method assumes that the index is within bounds!!"	self inline: true.	fmt < 4 ifTrue: [  "pointer type objects"		^ self fetchPointer: index - 1 ofObject: array].	fmt < 8 ifTrue: [  "long-word type objects"		^ self positive32BitIntegerFor:			(self fetchWord: index - 1 ofObject: array)	] ifFalse: [  "byte-type objects"		^ self integerObjectOf:			(self fetchByte: index - 1 ofObject: array)	].! !!Interpreter methodsFor: 'array and stream primitives'!subscript: array with: index storing: oopToStore format: fmt	"Note: This method assumes that the index is within bounds!!"	| valueToStore |	self inline: true.	fmt < 4 ifTrue: [  "pointer type objects"		self storePointer: index - 1 ofObject: array withValue: oopToStore.	] ifFalse: [		fmt < 8 ifTrue: [  "long-word type objects"			valueToStore _ self positive32BitValueOf: oopToStore.			successFlag ifTrue:				[self storeWord: index - 1 ofObject: array withValue: valueToStore].		] ifFalse: [  "byte-type objects"			(self isIntegerObject: oopToStore) ifFalse: [successFlag _ false].			valueToStore _ self integerValueOf: oopToStore.			((valueToStore >= 0) and: [valueToStore <= 255]) ifFalse: [successFlag _ false].			successFlag ifTrue:				[self storeByte: index - 1 ofObject: array withValue: valueToStore].		].	].! !!Interpreter methodsFor: 'object access primitives' stamp: 'ikp 1/3/98 23:10'!primitiveArrayBecome	"We must flush the method cache here, to eliminate stale references	to mutated classes and/or selectors."	| arg rcvr |	arg _ self popStack.	rcvr _ self stackTop.	self success: (self become: rcvr with: arg).	self flushMethodCache.	successFlag ifFalse: [ self unPop: 1 ].! !!Interpreter methodsFor: 'object access primitives'!primitiveAsOop	| thisReceiver |	thisReceiver _ self popStack.	self success: (self isIntegerObject: thisReceiver) not.	successFlag		ifTrue: [self pushInteger: (self hashBitsOf: thisReceiver)]		ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'object access primitives'!primitiveClass	| instance |	instance _ self popStack.	self push: (self fetchClassOf: instance)! !!Interpreter methodsFor: 'object access primitives'!primitiveClone	"Return a shallow copy of the receiver."	| newCopy |	newCopy _ self clone: (self stackTop).	self pop: 1 thenPush: newCopy.! !!Interpreter methodsFor: 'object access primitives'!primitiveEquivalent	| thisObject otherObject |	otherObject _ self popStack.	thisObject _ self popStack.	self pushBool: thisObject = otherObject! !!Interpreter methodsFor: 'object access primitives'!primitiveInstVarAt	| index rcvr hdr fmt totalLength fixedFields value |	index _ self popInteger.	rcvr _ self popStack.	successFlag ifTrue: [		hdr _ self baseHeader: rcvr.		fmt _ (hdr >> 8) bitAnd: 16rF.		totalLength _ self lengthOf: rcvr baseHeader: hdr format: fmt.		fixedFields _ self fixedFieldsOf: rcvr format: fmt length: totalLength.		((index >= 1) and: [index <= fixedFields])			ifFalse: [successFlag _ false]].	successFlag		ifTrue: [value _ self subscript: rcvr with: index format: fmt].	successFlag		ifTrue: [self push: value]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'object access primitives'!primitiveInstVarAtPut	| newValue index rcvr hdr fmt totalLength fixedFields |	newValue _ self popStack.	index _ self popInteger.	rcvr _ self popStack.	successFlag ifTrue: [		hdr _ self baseHeader: rcvr.		fmt _ (hdr >> 8) bitAnd: 16rF.		totalLength _ self lengthOf: rcvr baseHeader: hdr format: fmt.		fixedFields _ self fixedFieldsOf: rcvr format: fmt length: totalLength.		((index >= 1) and: [index <= fixedFields])			ifFalse: [successFlag _ false]].	successFlag		ifTrue: [self subscript: rcvr with: index storing: newValue format: fmt].	successFlag		ifTrue: [self push: newValue]		ifFalse: [self unPop: 3]! !!Interpreter methodsFor: 'object access primitives'!primitiveNew	"Allocate a new fixed-size instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free."	| class spaceOkay |	class _ self popStack.	spaceOkay _ self sufficientSpaceToInstantiate: class indexableSize: 0.	self success: spaceOkay.	successFlag		ifTrue: [ self push: (self instantiateClass: class indexableSize: 0) ]		ifFalse: [ self unPop: 1 ].! !!Interpreter methodsFor: 'object access primitives'!primitiveNewWithArg	"Allocate a new indexable instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free."	| size class spaceOkay |	size _ self popInteger.	class _ self popStack.	self success: size >= 0.	successFlag ifTrue: [		spaceOkay _ self sufficientSpaceToInstantiate: class indexableSize: size.		self success: spaceOkay.	].	successFlag		ifTrue: [ self push: (self instantiateClass: class indexableSize: size) ]		ifFalse: [ self unPop: 2 ].! !!Interpreter methodsFor: 'object access primitives'!primitiveNextInstance	| object instance |	object _ self popStack.	instance _ self instanceAfter: object.	instance = nilObj		ifTrue: [self unPop: 1. self primitiveFail]		ifFalse: [self push: instance]! !!Interpreter methodsFor: 'object access primitives'!primitiveNextObject	"Return the object following the receiver in the heap. Return the SmallInteger zero when there are no more objects."	| object instance |	object _ self popStack.	instance _ self accessibleObjectAfter: object.	instance = nil		ifTrue: [ self pushInteger: 0 ]		ifFalse: [ self push: instance ].! !!Interpreter methodsFor: 'object access primitives'!primitiveObjectAt  "Defined for CompiledMethods only"	| thisReceiver index |	index  _ self popInteger.	thisReceiver _ self popStack.	self success: index > 0.	self success: index <= ((self literalCountOf: thisReceiver) + LiteralStart).	successFlag		ifTrue: [self push: (self fetchPointer: index - 1					ofObject: thisReceiver)]		ifFalse: [self unPop: 2]! !!Interpreter methodsFor: 'object access primitives'!primitiveObjectAtPut  "Defined for CompiledMethods only"	| thisReceiver index newValue |	newValue _ self popStack.	index _ self popInteger.	thisReceiver _ self popStack.	self success: index > 0.	self success: index <= ((self literalCountOf: thisReceiver) + LiteralStart).	successFlag		ifTrue: [self storePointer: index - 1				ofObject: thisReceiver				withValue: newValue.			self push: newValue]		ifFalse: [self unPop: 3]! !!Interpreter methodsFor: 'object access primitives'!primitiveObjectPointsTo	| rcvr thang lastField |	thang _ self popStack.	rcvr _ self popStack.	(self isIntegerObject: rcvr) ifTrue: [^ self pushBool: false].	lastField _ self lastPointerOf: rcvr.	BaseHeaderSize to: lastField by: 4 do:		[:i | (self longAt: rcvr + i) = thang			ifTrue: [^ self pushBool: true]].	self pushBool: false.! !!Interpreter methodsFor: 'object access primitives'!primitivePointX	| rcvr | 	successFlag _ true.	rcvr _ self popStack.	self assertClassOf: rcvr is: (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: XIndex ofObject: rcvr)]		ifFalse: [self unPop: 1.  self failSpecialPrim: 0  "will fail"]! !!Interpreter methodsFor: 'object access primitives'!primitivePointY	| rcvr | 	successFlag _ true.	rcvr _ self popStack.	self assertClassOf: rcvr is: (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: YIndex ofObject: rcvr)]		ifFalse: [self unPop: 1.  self failSpecialPrim: 0  "will fail"]! !!Interpreter methodsFor: 'object access primitives' stamp: 'jm 1/6/98 18:44'!primitiveSomeInstance	| class instance |	class _ self popStack.	instance _ self initialInstanceOf: class.	instance = nilObj		ifTrue: [self unPop: 1. self primitiveFail]		ifFalse: [self push: instance]! !!Interpreter methodsFor: 'object access primitives'!primitiveSomeObject	"Return the first object in the heap."	self pop: 1.	self push: self firstAccessibleObject.! !!Interpreter methodsFor: 'object access primitives'!sufficientSpaceToInstantiate: classOop indexableSize: size	"Return the number of bytes required to allocate an instance of the given class with the given number of indexable fields."	"Details: For speed, over-estimate space needed for fixed fields or literals; the low space threshold is a blurry line."	| format okay |	self inline: true.	format _ ((self formatOfClass: classOop) >> 8) bitAnd: 16rF.	"fail if attempting to call new: on non-indexable class"	(size > 0 and: [format < 2]) ifTrue: [ ^ false ].	format < 8 ifTrue: [		"indexable fields are words or pointers"		okay _ self sufficientSpaceToAllocate: (2500 + (size * 4)).	] ifFalse: [		"indexable fields are bytes"		okay _ self sufficientSpaceToAllocate: (2500 + size).	].	^ okay! !!Interpreter methodsFor: 'control primitives'!primitiveBlockCopy	| context methodContext contextSize newContext initialIP |	context _ self stackValue: 1.	(self isIntegerObject: (self fetchPointer: MethodIndex ofObject: context)) ifTrue: [		"context is a block; get the context of its enclosing method"		methodContext _ self fetchPointer: HomeIndex ofObject: context.	] ifFalse: [		methodContext _ context.	].	contextSize _ self sizeBitsOf: methodContext.  "in bytes, including header"	context _ nil.  "context is no longer needed and is not preserved across allocation"	"remap methodContext in case GC happens during allocation"	self pushRemappableOop: methodContext.	newContext _ self instantiateSmallClass: (self splObj: ClassBlockContext)							   sizeInBytes: contextSize									   fill: nilObj.	methodContext _ self popRemappableOop.	initialIP _ self integerObjectOf: instructionPointer - method.	"Was instructionPointer + 3, but now it's greater by 		methodOop + 4 (headerSize) and less by 1 due to preIncrement"	"Assume: have just allocated a new context; it must be young.	 Thus, can use uncheck stores. See the comment in fetchContextRegisters."	self storeWord: InitialIPIndex					ofObject: newContext		withValue: initialIP.	self storeWord: InstructionPointerIndex		ofObject: newContext		withValue: initialIP.	self storeStackPointerValue: 0				inContext: newContext.	self storePointerUnchecked: BlockArgumentCountIndex	ofObject: newContext		withValue: (self stackValue: 0).	self storePointerUnchecked: HomeIndex		ofObject: newContext		withValue: methodContext.	self pop: 2.  "block argument count, rcvr"	self push: newContext.! !!Interpreter methodsFor: 'control primitives' stamp: 'di 1/12/98 09:39'!primitiveDoPrimitiveWithArgs	| argumentArray arraySize index cntxSize primIdx |	argumentArray _ self stackTop.	arraySize _ self fetchWordLengthOf: argumentArray.	cntxSize _ self fetchWordLengthOf: activeContext.	self success: (self stackPointerIndex + arraySize) < cntxSize.	self assertClassOf: argumentArray is: (self splObj: ClassArray).	primIdx _ self stackIntegerValue: 1.	successFlag ifFalse: [^ self primitiveFail].  "invalid args"	"Pop primIndex and argArray, then push args in place..."	self pop: 2.	primitiveIndex _ primIdx.	argumentCount _ arraySize.	index _ 1.	[index <= argumentCount]		whileTrue:		[self push: (self fetchPointer: index - 1 ofObject: argumentArray).		index _ index + 1].	"Run the primitive (sets successFlag)"	self pushRemappableOop: argumentArray.	"prim might alloc/gc"	self primitiveResponse.	argumentArray _ self popRemappableOop.	successFlag ifFalse:		["If primitive failed, then restore state for failure code"		self pop: arraySize.		self pushInteger: primIdx.		self push: argumentArray.		argumentCount _ 2.		"... caller (execNewMeth) will run failure code"]!]style[(28 334 18 742)f1b,f1,f1b,f1! !!Interpreter methodsFor: 'control primitives'!primitivePerform	| performSelector newReceiver selectorIndex |	performSelector _ messageSelector.	messageSelector _ self stackValue: argumentCount - 1.	newReceiver _ self stackValue: argumentCount.	"NOTE: the following lookup may fail and be converted to #doesNotUnderstand:,		so we must adjust argument count now, so that would work."	argumentCount _ argumentCount - 1.	self lookupMethodInClass: (self fetchClassOf: newReceiver).	self success: (self argumentCountOf: newMethod) = argumentCount.	successFlag		ifTrue: [selectorIndex _ self stackPointerIndex - argumentCount.				self transfer: argumentCount					fromIndex: selectorIndex + 1					ofObject: activeContext					toIndex: selectorIndex					ofObject: activeContext.				self pop: 1.				self executeNewMethod.  "Recursive xeq affects successFlag"				successFlag _ true]		ifFalse: [argumentCount _ argumentCount + 1.				messageSelector _ performSelector]! !!Interpreter methodsFor: 'control primitives' stamp: 'jm 9/18/97 21:36'!primitivePerformWithArgs	| thisReceiver performSelector argumentArray arraySize index cntxSize |	argumentArray _ self popStack.	arraySize _ self fetchWordLengthOf: argumentArray.	cntxSize _ self fetchWordLengthOf: activeContext.	self success: (self stackPointerIndex + arraySize) < cntxSize.	self assertClassOf: argumentArray is: (self splObj: ClassArray).	successFlag		ifTrue: [performSelector _ messageSelector.				messageSelector _ self popStack.				thisReceiver _ self stackTop.				argumentCount _ arraySize.				index _ 1.				[index <= argumentCount]					whileTrue:					[self push: (self fetchPointer: index - 1 ofObject: argumentArray).					index _ index + 1].				self lookupMethodInClass: (self fetchClassOf: thisReceiver).				self success: (self argumentCountOf: newMethod) = argumentCount.				successFlag					ifTrue: [self executeNewMethod.  "Recursive xeq affects successFlag"							successFlag _ true]					ifFalse: [self pop: argumentCount.							self push: messageSelector.							self push: argumentArray.							argumentCount _ 2.							messageSelector _ performSelector]]	ifFalse: [self unPop: 1]! !!Interpreter methodsFor: 'control primitives'!primitiveValue	| blockContext blockArgumentCount initialIP |	blockContext _ self stackValue: argumentCount.	blockArgumentCount _ self argumentCountOfBlock: blockContext.	self success: (argumentCount = blockArgumentCount			and: [(self fetchPointer: CallerIndex ofObject: blockContext) = nilObj]).	successFlag		ifTrue: [self transfer: argumentCount				fromIndex: self stackPointerIndex - argumentCount + 1				ofObject: activeContext				toIndex: TempFrameStart				ofObject: blockContext.			"Assume: The call to transfer:... makes blockContext a root if necessary,			 allowing use to use unchecked stored in the following code."			self pop: argumentCount + 1.			initialIP _ self fetchPointer: InitialIPIndex	ofObject: blockContext.			self storePointerUnchecked: InstructionPointerIndex ofObject: blockContext				withValue: initialIP.			self storeStackPointerValue: argumentCount	inContext: blockContext.			self storePointerUnchecked: CallerIndex		ofObject: blockContext				withValue: activeContext.			self newActiveContext: blockContext]! !!Interpreter methodsFor: 'control primitives'!primitiveValueWithArgs	| argumentArray blockContext blockArgumentCount arrayArgumentCount initialIP |	argumentArray _ self popStack.	blockContext _ self popStack.	blockArgumentCount _ self argumentCountOfBlock: blockContext.	self assertClassOf: argumentArray is: (self splObj: ClassArray).	successFlag ifTrue: [		arrayArgumentCount _ self fetchWordLengthOf: argumentArray.		self success: (arrayArgumentCount = blockArgumentCount			and: [(self fetchPointer: CallerIndex ofObject: blockContext) = nilObj])].	successFlag ifTrue: [		self transfer: arrayArgumentCount			fromIndex: 0			ofObject: argumentArray			toIndex: TempFrameStart			ofObject: blockContext.		"Assume: The call to transfer:... makes blockContext a root if necessary,		 allowing use to use unchecked stored in the following code."		initialIP _ self fetchPointer: InitialIPIndex			ofObject: blockContext.		self storePointerUnchecked: InstructionPointerIndex	ofObject: blockContext			withValue: initialIP.		self storeStackPointerValue: arrayArgumentCount	inContext: blockContext.		self storePointerUnchecked: CallerIndex				ofObject: blockContext			withValue: activeContext.		self newActiveContext: blockContext.	] ifFalse: [self unPop: 2].! !!Interpreter methodsFor: 'processes'!addLastLink: proc toList: aList	"Add the given process to the given linked list and set the backpointer	of process to its new list."	| lastLink |	(self isEmptyList: aList) ifTrue: [		self storePointer: FirstLinkIndex ofObject: aList withValue: proc.	] ifFalse: [		lastLink _ self fetchPointer: LastLinkIndex ofObject: aList.		self storePointer: NextLinkIndex ofObject: lastLink withValue: proc.	].	self storePointer: LastLinkIndex ofObject: aList withValue: proc.	self storePointer: MyListIndex   ofObject:  proc withValue: aList.! !!Interpreter methodsFor: 'processes' stamp: 'jm 9/10/97 20:00'!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now index externalObjects semaClass |	self inline: false.	now _ self ioMSecs.	now < lastTick ifTrue: [		"millisecond clock wrapped"		nextPollTick _ now + (nextPollTick - lastTick).		nextWakeupTick ~= 0			ifTrue: [nextWakeupTick _ now + (nextWakeupTick - lastTick)]].	lastTick _ now.  "used to detect millisecond clock wrapping"	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [^ self synchronousSignal: sema]].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500].  "msecs to wait before next call to ioProcessEvents"	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [^ self synchronousSignal: sema]].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [^ self synchronousSignal: sema]].	"signal all semaphores in semaphoresToSignal" 	semaphoresToSignalCount > 0 ifTrue: [		externalObjects _ self splObj: ExternalObjectsArray.		semaClass _ self splObj: ClassSemaphore.		1 to: semaphoresToSignalCount do: [:i |			index _ semaphoresToSignal at: i.			sema _ self fetchPointer: index - 1 ofObject: externalObjects.				"Note: semaphore indices are 1-based"			(self fetchClassOf: sema) = semaClass				ifTrue: [self synchronousSignal: sema]].		semaphoresToSignalCount _ 0].! !!Interpreter methodsFor: 'processes'!internalQuickCheckForInterrupts	"Internal version of quickCheckForInterrupts for use within jumps."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		interruptCheckCounter _ 1000.		self externalizeIPandSP.		self checkForInterrupts.		self internalizeIPandSP.	].! !!Interpreter methodsFor: 'processes'!isEmptyList: aLinkedList	^ (self fetchPointer: FirstLinkIndex ofObject: aLinkedList) = nilObj! !!Interpreter methodsFor: 'processes'!primitiveResume	| proc |	proc _ self stackTop.  "rcvr"	"self success: ((self fetchClassOf: proc) = (self splObj: ClassProcess))."	successFlag ifTrue: [ self resume: proc ].! !!Interpreter methodsFor: 'processes'!primitiveSignal	| sema |	sema _ self stackTop.  "rcvr"	self assertClassOf: sema is: (self splObj: ClassSemaphore).	successFlag ifTrue: [ self synchronousSignal: sema ].! !!Interpreter methodsFor: 'processes'!primitiveSuspend	| activeProc |	activeProc _ self fetchPointer: ActiveProcessIndex						 ofObject: self schedulerPointer.	self success: self stackTop = activeProc.	successFlag ifTrue: [		self pop: 1.		self push: nilObj.		self transferTo: self wakeHighestPriority.	].! !!Interpreter methodsFor: 'processes'!primitiveWait	| sema excessSignals activeProc |	sema _ self stackTop.  "rcvr"	self assertClassOf: sema is: (self splObj: ClassSemaphore).	successFlag ifTrue: [		excessSignals _			self fetchInteger: ExcessSignalsIndex ofObject: sema.		excessSignals > 0 ifTrue: [			self storeInteger: ExcessSignalsIndex				ofObject: sema withValue: excessSignals - 1.		] ifFalse: [			activeProc _ self fetchPointer: ActiveProcessIndex								 ofObject: self schedulerPointer.			self addLastLink: activeProc toList: sema.			self transferTo: self wakeHighestPriority.		].	].! !!Interpreter methodsFor: 'processes'!putToSleep: aProcess	"Save the given process on the scheduler process list for its priority."	| priority processLists processList |	priority _ self quickFetchInteger: PriorityIndex ofObject: aProcess.	processLists _ self fetchPointer: ProcessListsIndex ofObject: self schedulerPointer.	processList _ self fetchPointer: priority - 1 ofObject: processLists.	self addLastLink: aProcess toList: processList.! !!Interpreter methodsFor: 'processes'!quickCheckForInterrupts	"Quick check for possible user or timer interrupts. Decrement a counter and only do a real check when counter reaches zero or when a low space or user interrupt is pending."	"Note: Clients who set signalLowSpace or interruptPending should also set interruptCheckCounter to zero to get immediate results."	"Note: Requires that instructionPointer and stackPointer be external."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		interruptCheckCounter _ 1000.		self checkForInterrupts.	].! !!Interpreter methodsFor: 'processes'!removeFirstLinkOfList: aList	"Remove the first process from the given linked list."	| first last next |	first _ self fetchPointer: FirstLinkIndex ofObject: aList.	last  _ self fetchPointer: LastLinkIndex ofObject: aList.	first = last ifTrue: [		self storePointer: FirstLinkIndex ofObject: aList withValue: nilObj.		self storePointer:  LastLinkIndex ofObject: aList withValue: nilObj.	] ifFalse: [		next _ self fetchPointer: NextLinkIndex ofObject: first.		self storePointer: FirstLinkIndex ofObject: aList withValue: next.	].	self storePointer: NextLinkIndex ofObject: first withValue: nilObj.	^ first! !!Interpreter methodsFor: 'processes'!resume: aProcess	| activeProc activePriority newPriority |	self inline: false.	activeProc _ self fetchPointer: ActiveProcessIndex						 ofObject: self schedulerPointer.	activePriority _ self quickFetchInteger: PriorityIndex ofObject: activeProc.	newPriority   _ self quickFetchInteger: PriorityIndex ofObject: aProcess.	newPriority > activePriority ifTrue: [		self putToSleep: activeProc.		self transferTo: aProcess.	] ifFalse: [		self putToSleep: aProcess.	].! !!Interpreter methodsFor: 'processes'!schedulerPointer	^ self fetchPointer: ValueIndex		ofObject: (self splObj: SchedulerAssociation)! !!Interpreter methodsFor: 'processes' stamp: 'jm 8/24/97 22:55'!signalSemaphoreWithIndex: index	"If it is not there already, record the given semaphore index in the list of semaphores to be signaled at the next convenient moment. Set the interruptCheckCounter to zero to force a real interrupt check as soon as possible."	index <= 0 ifTrue: [^ nil].  "bad index; ignore it"	interruptCheckCounter _ 0.	1 to: semaphoresToSignalCount do: [:i |		(semaphoresToSignal at: i) = index ifTrue: [^ nil]].	semaphoresToSignalCount < SemaphoresToSignalSize ifTrue: [		semaphoresToSignalCount _ semaphoresToSignalCount + 1.		semaphoresToSignal at: semaphoresToSignalCount put: index].! !!Interpreter methodsFor: 'processes'!synchronousSignal: aSemaphore	"Signal the given semaphore from within the interpreter."	| excessSignals |	self inline: false.	(self isEmptyList: aSemaphore) ifTrue: [		"no process is waiting on this semaphore"		excessSignals _			self fetchInteger: ExcessSignalsIndex ofObject: aSemaphore.		self storeInteger: ExcessSignalsIndex			ofObject: aSemaphore withValue: excessSignals + 1.	] ifFalse: [		self resume: (self removeFirstLinkOfList: aSemaphore).	].! !!Interpreter methodsFor: 'processes'!transferTo: newProc	"Record a process to be awoken on the next interpreter cycle."	| sched oldProc |	sched _ self schedulerPointer.	oldProc _ self fetchPointer: ActiveProcessIndex ofObject: sched.	self storePointer: SuspendedContextIndex ofObject: oldProc withValue: activeContext.	self storePointer: ActiveProcessIndex      ofObject:   sched withValue: newProc.	self newActiveContext:		(self fetchPointer: SuspendedContextIndex ofObject: newProc).	reclaimableContextCount _ 0.! !!Interpreter methodsFor: 'processes'!wakeHighestPriority	"Return the highest priority process that is ready to run."	"Note: It is a fatal VM error if there is no runnable process."	| schedLists p processList |	schedLists _ self fetchPointer: ProcessListsIndex				ofObject: self schedulerPointer.	p _ self fetchWordLengthOf: schedLists.	p _ p - 1.  "index of last indexable field"	processList _ self fetchPointer: p ofObject: schedLists.	[self isEmptyList: processList] whileTrue: [		p _ p - 1.		p < 0 ifTrue: [ self error: 'scheduler could not find a runnable process' ].		processList _ self fetchPointer: p ofObject: schedLists.	].	^ self removeFirstLinkOfList: processList! !!Interpreter methodsFor: 'I/O primitives'!fullDisplayUpdate	"Repaint the entire smalltalk screen, ignoring the affected rectangle. Used when the Smalltalk window is brought to the front or uncovered."	| displayObj dispBits w h dispBitsIndex d |	displayObj _ self splObj: TheDisplay.	((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]) ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, 0, w, 0, h)'.	].! !!Interpreter methodsFor: 'I/O primitives'!primitiveBeCursor	"Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk."	| cursorObj bitsObj extentX extentY offsetObj offsetX offsetY cursorBitsIndex |	cursorObj _ self stackTop.	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 5]).	successFlag ifTrue: [		bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		extentX _ self fetchInteger: 1 ofObject: cursorObj.		extentY _ self fetchInteger: 2 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj.		self success: ((self isPointers: offsetObj) and: [(self lengthOf: offsetObj) >= 2]).	].	successFlag ifTrue: [		offsetX _ self fetchInteger: 0 ofObject: offsetObj.		offsetY _ self fetchInteger: 1 ofObject: offsetObj.		self success: ((extentX = 16) and: [extentY = 16]).		self success: ((offsetX >= -16) and: [offsetX <= 0]).		self success: ((offsetY >= -16) and: [offsetY <= 0]).		self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).		cursorBitsIndex _ bitsObj + BaseHeaderSize.	].	successFlag ifTrue: [		self cCode: 'ioSetCursor(cursorBitsIndex, offsetX, offsetY)'.	].! !!Interpreter methodsFor: 'I/O primitives'!primitiveBeDisplay	"Record the system Display object."	| rcvr |	rcvr _ self stackTop.	self success: ((self isPointers: rcvr) and: [(self lengthOf: rcvr) >= 4]).	successFlag ifTrue: [		"record the display object both in a variable and in the specialObjectsOop"		self storePointer: TheDisplay ofObject: specialObjectsOop withValue: rcvr.	].! !!Interpreter methodsFor: 'I/O primitives'!primitiveBeep	self ioBeep.! !!Interpreter methodsFor: 'I/O primitives'!primitiveCopyBits	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackTop.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self copyBits.		self showDisplayBits.	].! !!Interpreter methodsFor: 'I/O primitives'!primitiveDrawLoop	"Invoke the line drawing primitive."	| rcvr xDelta yDelta |	rcvr _ self stackValue: 2.	xDelta _ self stackIntegerValue: 1.	yDelta _ self stackIntegerValue: 0.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self drawLoopX: xDelta Y: yDelta.		self showDisplayBits.		self pop: 2].! !!Interpreter methodsFor: 'I/O primitives'!primitiveInputSemaphore	"Register the input semaphore. If the argument is not a Semaphore, unregister the current input semaphore."	| arg |	arg _ self popStack.	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [		self storePointer: TheInputSemaphore ofObject: specialObjectsOop withValue: arg.	] ifFalse: [		self storePointer: TheInputSemaphore ofObject: specialObjectsOop withValue: nilObj.	].! !!Interpreter methodsFor: 'I/O primitives'!primitiveInputWord	"Return an integer indicating the reason for the most recent input interrupt."	self pop: 1.	self pushInteger: 0.	"noop for now"! !!Interpreter methodsFor: 'I/O primitives'!primitiveInterruptSemaphore	"Register the user interrupt semaphore. If the argument is not a Semaphore, unregister the current interrupt semaphore."	| arg |	arg _ self popStack.	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [		self storePointer: TheInterruptSemaphore ofObject: specialObjectsOop withValue: arg.	] ifFalse: [		self storePointer: TheInterruptSemaphore ofObject: specialObjectsOop withValue: nilObj.	].! !!Interpreter methodsFor: 'I/O primitives'!primitiveKbdNext	"Return the next keycode and remove it from the input buffer. The low byte is the 8-bit ISO character. The next four bits are the Smalltalk modifier bits <cmd><option><ctrl><shift>."	| keystrokeWord |	self pop: 1.	keystrokeWord _ self ioGetKeystroke.	keystrokeWord >= 0		ifTrue: [self pushInteger: keystrokeWord]		ifFalse: [self push: nilObj].! !!Interpreter methodsFor: 'I/O primitives'!primitiveKbdPeek	"Return the next keycode and without removing it from the input buffer. The low byte is the 8-bit ISO character. The next four bits are the Smalltalk modifier bits <cmd><option><ctrl><shift>."	| keystrokeWord |	self pop: 1.	keystrokeWord _ self ioPeekKeystroke.	keystrokeWord >= 0		ifTrue: [self pushInteger: keystrokeWord]		ifFalse: [self push: nilObj].! !!Interpreter methodsFor: 'I/O primitives'!primitiveMouseButtons	"Return the mouse button state. The low three bits encode the state of the <red><yellow><blue> mouse buttons. The next four bits encode the Smalltalk modifier bits <cmd><option><ctrl><shift>."	| buttonWord |	self pop: 1.	buttonWord _ self ioGetButtonState.	self pushInteger: buttonWord.! !!Interpreter methodsFor: 'I/O primitives'!primitiveMousePoint	"Return a Point indicating current position of the mouse. Note that mouse coordinates may be negative if the mouse moves above or to the left of the top-left corner of the Smalltalk window."	| pointWord x y |	self pop: 1.	pointWord _ self ioMousePoint.	x _ self signExtend16: ((pointWord >> 16) bitAnd: 16rFFFF).	y _ self signExtend16: (pointWord bitAnd: 16rFFFF).	self push: (self makePointwithxValue: x  yValue: y).! !!Interpreter methodsFor: 'I/O primitives'!primitiveScanCharacters	"Invoke the scanCharacters primitive."	| rcvr start stop string rightX stopArray displayFlag |	rcvr _ self stackValue: 6.	start _ self stackIntegerValue: 5.	stop _ self stackIntegerValue: 4.	string _ self stackValue: 3.	rightX _ self stackIntegerValue: 2.	stopArray _ self stackValue: 1.	displayFlag _ self booleanValueOf: (self stackValue: 0).	successFlag ifFalse: [^ nil].	self success: (self loadScannerFrom: rcvr					start: start stop: stop string: string rightX: rightX					stopArray: stopArray displayFlag: displayFlag).	successFlag		ifTrue: [self scanCharacters].	successFlag		ifTrue: [			displayFlag ifTrue: [self showDisplayBits].			self pop: 7.			self push: self stopReason].! !!Interpreter methodsFor: 'I/O primitives'!primitiveScreenSize	"Return a point indicating the current size of the Smalltalk window."	| pointWord |	self pop: 1.	pointWord _ self ioScreenSize.	self push:		(self makePointwithxValue: ((pointWord >>16) bitAnd: 16rFFFF)						   yValue: (pointWord bitAnd: 16rFFFF)).! !!Interpreter methodsFor: 'I/O primitives'!primitiveSetInterruptKey	"Set the user interrupt keycode. The keycode is an integer whose encoding is described in the comment for primitiveKbdNext."	| keycode |	keycode _ self popInteger.	successFlag		ifTrue: [ interruptKeycode _ keycode ]		ifFalse: [ self unPop: 1 ].! !!Interpreter methodsFor: 'I/O primitives'!primitiveWarpBits	"Invoke the warpBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackValue: self argCount.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self warpBits.		self showDisplayBits.	].! !!Interpreter methodsFor: 'I/O primitives'!showDisplayBits	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h affectedRectL affectedRectR affectedRectT affectedRectB dispBitsIndex d |	displayObj _ self splObj: TheDisplay.	self targetForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	successFlag ifTrue: [		affectedRectL _ self affectedLeft.		affectedRectR _ self affectedRight.		affectedRectT _ self affectedTop.		affectedRectB _ self affectedBottom.		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.	].! !!Interpreter methodsFor: 'file primitives'!asciiDirectoryDelimiter	^ self cCode: 'dir_Delimitor()'! !!Interpreter methodsFor: 'file primitives'!fileRecordSize	"Return the size of a Smalltalk file record in bytes."	^ self cCode: 'sizeof(SQFile)'.! !!Interpreter methodsFor: 'file primitives'!fileValueOf: objectPointer	"Return a pointer to the first byte of of the file record within the given Smalltalk object, or nil if objectPointer is not a file record."	| fileIndex |	self returnTypeC: 'SQFile *'.	self success:		((self isBytes: objectPointer) and:		 [(self lengthOf: objectPointer) = self fileRecordSize]).	successFlag ifTrue: [		fileIndex _ objectPointer + BaseHeaderSize.		^ self cCode: '(SQFile *) fileIndex'	] ifFalse:  [		^ nil	].! !!Interpreter methodsFor: 'file primitives'!makeDirEntryName: entryName size: entryNameSize	createDate: createDate modDate: modifiedDate	isDir: dirFlag fileSize: fileSize	| modDateOop createDateOop nameString results |	self var: 'entryName' declareC: 'char *entryName'.	"allocate storage for results, remapping newly allocated	 oops in case GC happens during allocation"	self pushRemappableOop:		(self instantiateClass: (self splObj: ClassArray) indexableSize: 5).	self pushRemappableOop:		(self instantiateClass: (self splObj: ClassString) indexableSize: entryNameSize)..	self pushRemappableOop: (self positive32BitIntegerFor: createDate).	self pushRemappableOop: (self positive32BitIntegerFor: modifiedDate).	modDateOop   _ self popRemappableOop.	createDateOop _ self popRemappableOop.	nameString    _ self popRemappableOop.	results         _ self popRemappableOop.	"copy name into Smalltalk string"	0 to: entryNameSize - 1 do: [ :i |		self storeByte: i ofObject: nameString withValue: (entryName at: i).	].	self storePointer: 0 ofObject: results withValue: nameString.	self storePointer: 1 ofObject: results withValue: createDateOop.	self storePointer: 2 ofObject: results withValue: modDateOop.	dirFlag		ifTrue: [ self storePointer: 3 ofObject: results withValue: trueObj ]		ifFalse: [ self storePointer: 3 ofObject: results withValue: falseObj ].	self storePointer: 4 ofObject: results		withValue: (self integerObjectOf: fileSize).	^ results! !!Interpreter methodsFor: 'file primitives'!primitiveDirectoryCreate	| dirName dirNameIndex dirNameSize |	dirName _ self stackTop.	self success: (self isBytes: dirName).	successFlag ifTrue: [		dirNameIndex _ dirName + BaseHeaderSize.		dirNameSize _ self lengthOf: dirName.	].	successFlag ifTrue: [		self success:			(self cCode: 'dir_Create((char *) dirNameIndex, dirNameSize)').	].	successFlag ifTrue: [		self pop: 1.  "pop dirName; leave rcvr on stack"	].! !!Interpreter methodsFor: 'file primitives'!primitiveDirectoryDelimitor	| ascii |	ascii _ self asciiDirectoryDelimiter.	self success: ((ascii >= 0) and: [ascii <= 255]).	successFlag ifTrue: [		self pop: 1.  "pop rcvr"		self push: (self fetchPointer: ascii ofObject: (self splObj: CharacterTable)).	].! !!Interpreter methodsFor: 'file primitives'!primitiveDirectoryLookup	| index pathName pathNameIndex pathNameSize status entryName entryNameSize createDate modifiedDate dirFlag fileSize |	self var: 'entryName' declareC: 'char entryName[256]'.	index _ self stackIntegerValue: 0.	pathName _ self stackValue: 1.	self success: (self isBytes: pathName).	successFlag ifTrue: [		pathNameIndex _ pathName + BaseHeaderSize.		pathNameSize _ self lengthOf: pathName.	].	successFlag ifTrue: [		status _ self cCode:			'dir_Lookup(				(char *) pathNameIndex, pathNameSize, index,				entryName, &entryNameSize, &createDate, &modifiedDate,				&dirFlag, &fileSize)'.		status = DirNoMoreEntries ifTrue: [			"no more entries; return nil"			self pop: 3.  "pop pathName, index, rcvr"			self push: nilObj.			^ nil		].		status = DirBadPath ifTrue: [ ^ self primitiveFail ].  "bad path"	].	successFlag ifTrue: [		self pop: 3.  "pop pathName, index, rcvr"		self push:			(self makeDirEntryName: entryName size: entryNameSize				createDate: createDate modDate: modifiedDate				isDir: dirFlag fileSize: fileSize).	].! !!Interpreter methodsFor: 'file primitives'!primitiveDirectorySetMacTypeAndCreator	| creatorString typeString fileName creatorStringIndex typeStringIndex fileNameIndex fileNameSize |	creatorString _ self stackTop.	typeString _ self stackValue: 1.	fileName _ self stackValue: 2.	self success: ((self isBytes: creatorString) and: [(self lengthOf: creatorString) = 4]).	self success: ((self isBytes: typeString) and: [(self lengthOf: typeString) = 4]).	self success: (self isBytes: fileName).	successFlag ifTrue: [		creatorStringIndex _ creatorString + BaseHeaderSize.		typeStringIndex _ typeString + BaseHeaderSize.		fileNameIndex _ fileName + BaseHeaderSize.		fileNameSize _ self lengthOf: fileName.	].	successFlag ifTrue: [		self success:			(self cCode: 'dir_SetMacFileTypeAndCreator(				(char *) fileNameIndex, fileNameSize,				(char *) typeStringIndex, (char *) creatorStringIndex)').	].	successFlag ifTrue: [		self pop: 3.  "pop filename, type, creator; leave rcvr on stack"	].! !!Interpreter methodsFor: 'file primitives'!primitiveFileAtEnd	| file atEnd |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: self stackTop.	successFlag ifTrue: [ atEnd _ self sqFileAtEnd: file ].	successFlag ifTrue: [		self pop: 2.  "rcvr, file"		self pushBool: atEnd.	].! !!Interpreter methodsFor: 'file primitives'!primitiveFileClose	| file |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: self stackTop.	successFlag ifTrue: [ self sqFileClose: file ].	successFlag ifTrue: [ self pop: 1  "pop file; leave rcvr on stack" ].! !!Interpreter methodsFor: 'file primitives'!primitiveFileDelete	| namePointer nameIndex nameSize |	namePointer _ self stackTop.	self success: (self isBytes: namePointer).	successFlag ifTrue: [		nameIndex _ namePointer + BaseHeaderSize.		nameSize _ self lengthOf: namePointer.	].	successFlag ifTrue: [		self sqFileDeleteName: nameIndex Size: nameSize.	].	successFlag ifTrue: [ self pop: 1. "pop name, leave rcvr on stack" ].! !!Interpreter methodsFor: 'file primitives'!primitiveFileGetPosition	| file position |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: (self stackTop).	successFlag ifTrue: [ position _ self sqFileGetPosition: file ].	successFlag ifTrue: [		self pop: 2.  "rcvr, file"		self pushInteger: position.	].! !!Interpreter methodsFor: 'file primitives'!primitiveFileOpen	| writeFlag namePointer filePointer file nameIndex nameSize |	self var: 'file' declareC: 'SQFile *file'.	writeFlag _ self booleanValueOf: (self stackTop).	namePointer _ self stackValue: 1.	self success: (self isBytes: namePointer).	successFlag ifTrue: [		filePointer _ self instantiateClass: (self splObj: ClassByteArray)						   indexableSize: self fileRecordSize.		file _ self fileValueOf: filePointer.		nameIndex _ namePointer + BaseHeaderSize.		nameSize _ self lengthOf: namePointer.	].	successFlag ifTrue: [		self cCode: 'sqFileOpen(file, nameIndex, nameSize, writeFlag)'.	].	successFlag ifTrue: [		self pop: 3.  "rcvr, name, writeFlag"		self push: filePointer.	].! !!Interpreter methodsFor: 'file primitives'!primitiveFileRead	| count startIndex array file byteSize arrayIndex bytesRead |	self var: 'file' declareC: 'SQFile *file'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	file			_ self fileValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [ byteSize _ 4 ]		ifFalse: [ byteSize _ 1 ].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= (self lengthOf: array)]).	successFlag ifTrue: [		arrayIndex _ array + BaseHeaderSize.		"Note: adjust startIndex for zero-origin indexing"		bytesRead _ self sqFile: file Read: (count * byteSize)						 Into: arrayIndex						   At: ((startIndex - 1) * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, file, array, startIndex, count"		self pushInteger: bytesRead // byteSize.  "push # of elements read"	].! !!Interpreter methodsFor: 'file primitives'!primitiveFileRename	| oldNamePointer newNamePointer oldNameIndex oldNameSize newNameIndex newNameSize |	newNamePointer _ self stackTop.	oldNamePointer _ self stackValue: 1.	self success: (self isBytes: newNamePointer).	self success: (self isBytes: oldNamePointer).	successFlag ifTrue: [		newNameIndex _ newNamePointer + BaseHeaderSize.		newNameSize _ self lengthOf: newNamePointer.		oldNameIndex _ oldNamePointer + BaseHeaderSize.		oldNameSize _ self lengthOf: oldNamePointer.	].	successFlag ifTrue: [		self sqFileRenameOld: oldNameIndex Size: oldNameSize New: newNameIndex Size: newNameSize.	].	successFlag ifTrue: [		self pop: 2.  "pop new and old names, leave rcvr on stack"	].! !!Interpreter methodsFor: 'file primitives'!primitiveFileSetPosition	| newPosition file |	self var: 'file' declareC: 'SQFile *file'.	newPosition _ self stackIntegerValue: 0.	file _ self fileValueOf: (self stackValue: 1).	successFlag ifTrue: [ self sqFile: file SetPosition: newPosition ].	successFlag ifTrue: [ self pop: 2 "pop position, file; leave rcvr on stack" ].! !!Interpreter methodsFor: 'file primitives'!primitiveFileSize	| file size |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: (self stackTop).	successFlag ifTrue: [ size _ self sqFileSize: file ].	successFlag ifTrue: [		self pop: 2.  "rcvr, file"		self pushInteger: size.	].! !!Interpreter methodsFor: 'file primitives'!primitiveFileWrite	| count startIndex array file byteSize arrayIndex bytesWritten |	self var: 'file' declareC: 'SQFile *file'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	file			_ self fileValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [ byteSize _ 4 ]		ifFalse: [ byteSize _ 1 ].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= (self lengthOf: array)]).	successFlag ifTrue: [		arrayIndex _ array + BaseHeaderSize.		"Note: adjust startIndex for zero-origin indexing"		bytesWritten _			self sqFile: file				Write: (count * byteSize)				From: arrayIndex At: ((startIndex - 1) * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, file, array, startIndex, count"		self pushInteger: bytesWritten // byteSize.  "push # of elements written"	].! !!Interpreter methodsFor: 'memory space primitives'!primitiveBytesLeft	"Reports bytes available at this moment. For more meaningful results, calls to this primitive should be preceeded by a full or incremental garbage collection."	self pop: 1.	self pushInteger: (self sizeOfFree: freeBlock).! !!Interpreter methodsFor: 'memory space primitives'!primitiveFullGC	"Do a quick, incremental garbage collection and return the number of bytes available."	self pop: 1.	self incrementalGC.  "maximimize space for forwarding table"	self fullGC.	self pushInteger: (self sizeOfFree: freeBlock).! !!Interpreter methodsFor: 'memory space primitives'!primitiveIncrementalGC	"Do a quick, incremental garbage collection and return the number of bytes immediately available. (Note: more space may be made available by doing a full garbage collection."	self pop: 1.	self incrementalGC.	self pushInteger: (self sizeOfFree: freeBlock).! !!Interpreter methodsFor: 'memory space primitives'!primitiveLowSpaceSemaphore	"Register the low-space semaphore. If the argument is not a Semaphore, unregister the current low-space Semaphore."	| arg |	arg _ self popStack.	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [		self storePointer: TheLowSpaceSemaphore ofObject: specialObjectsOop withValue: arg.	] ifFalse: [		self storePointer: TheLowSpaceSemaphore ofObject: specialObjectsOop withValue: nilObj.	].! !!Interpreter methodsFor: 'memory space primitives'!primitiveSignalAtBytesLeft	"Set the low-water mark for free space. When the free space falls below this level, the new and new: primitives fail and system attempts to allocate space (e.g., to create a method context) cause the low-space semaphore (if one is registered) to be signalled."	| bytes |	bytes _ self popInteger.	successFlag		ifTrue: [ lowSpaceThreshold _ bytes ]		ifFalse: [			lowSpaceThreshold _ 0.			self unPop: 1.		].! !!Interpreter methodsFor: 'socket primitives' stamp: 'jm 9/3/97 11:57'!primitiveInitializeNetwork	| resolverSemaIndex err |	resolverSemaIndex _ self stackIntegerValue: 0.	successFlag ifTrue: [		err _ self sqNetworkInit: resolverSemaIndex.		self success: err = 0.	].	successFlag ifTrue: [		self pop: 1.  "pop resolverSemaIndex, leave rcvr on stack"	].! !!Interpreter methodsFor: 'socket primitives'!primitiveSocketAbortConnection	| s |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		self sqSocketAbortConnection: s.	].	successFlag ifTrue: [		self pop: 1.  "pop s; leave rcvr on stack"	].! !!Interpreter methodsFor: 'socket primitives'!primitiveSocketCloseConnection	| s |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		self sqSocketCloseConnection: s.	].	successFlag ifTrue: [		self pop: 1.  "pop s; leave rcvr on stack"	].! !!Interpreter methodsFor: 'socket primitives'!primitiveSocketConnectionStatus	| s status |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		status _ self sqSocketConnectionStatus: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self integerObjectOf: status).	].! !!Interpreter methodsFor: 'socket primitives' stamp: 'jm 9/3/97 11:57'!primitiveSocketConnectToPort	| port addr s |	self var: #s declareC: 'SocketPtr s'.	port _ self stackIntegerValue: 0.	addr _ self netAddressToInt: (self stackValue: 1).	s _ self socketValueOf: (self stackValue: 2).	successFlag ifTrue: [		self sqSocket: s ConnectTo: addr Port: port.	].	successFlag ifTrue: [		self pop: 3.  "pop s, addr, port; leave rcvr on stack"	].! !!Interpreter methodsFor: 'socket primitives' stamp: 'jm 9/3/97 11:58'!primitiveSocketCreate	| semaIndex sendBufSize recvBufSize socketType netType socketOop s |	self var: #s declareC: 'SocketPtr s'.	semaIndex	_ self stackIntegerValue: 0.	sendBufSize	_ self stackIntegerValue: 1.	recvBufSize	_ self stackIntegerValue: 2.	socketType	_ self stackIntegerValue: 3.	netType		_ self stackIntegerValue: 4.	successFlag ifTrue: [		socketOop _ self instantiateClass: (self splObj: ClassByteArray)						indexableSize: self socketRecordSize.		s _ self socketValueOf: socketOop.		self sqSocket: s CreateNetType: netType SocketType: socketType			RecvBytes: recvBufSize SendBytes: sendBufSize SemaID: semaIndex.		successFlag ifTrue: [			self pop: 6  "netType, socketType, recvBufSize, sendBufSize, semaIndex, rcvr"				thenPush: socketOop.		].	].! !!Interpreter methodsFor: 'socket primitives'!primitiveSocketDestroy	| s |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		self sqSocketDestroy: s.	].	successFlag ifTrue: [		self pop: 1.  "pop s; leave rcvr on stack"	].! !!Interpreter methodsFor: 'socket primitives'!primitiveSocketError	| s err |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		err _ self sqSocketError: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self integerObjectOf: err).	].! !!Interpreter methodsFor: 'socket primitives' stamp: 'jm 9/3/97 11:58'!primitiveSocketListenOnPort	| port s |	self var: #s declareC: 'SocketPtr s'.	port _ self stackIntegerValue: 0.	s _ self socketValueOf: (self stackValue: 1).	successFlag ifTrue: [		self sqSocket: s ListenOnPort: port.	].	successFlag ifTrue: [		self pop: 2.  "pop s, port; leave rcvr on stack"	].! !!Interpreter methodsFor: 'socket primitives'!primitiveSocketLocalAddress	| s addr |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		addr _ self sqSocketLocalAddress: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self intToNetAddress: addr).	].! !!Interpreter methodsFor: 'socket primitives'!primitiveSocketLocalPort	| s port |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		port _ self sqSocketLocalPort: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self integerObjectOf: port).	].! !!Interpreter methodsFor: 'socket primitives'!primitiveSocketReceiveDataAvailable	| s dataIsAvailable |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		dataIsAvailable _ self sqSocketReceiveDataAvailable: s.	].	successFlag ifTrue: [		self pop: 2.  "pop s, rcvr"		self pushBool: dataIsAvailable.	].! !!Interpreter methodsFor: 'socket primitives'!primitiveSocketReceiveDataBufCount	| count startIndex array s byteSize arrayBase bufStart bytesReceived |	self var: #s declareC: 'SocketPtr s'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	s			_ self socketValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [byteSize _ 4]		ifFalse: [byteSize _ 1].	self success: (		(startIndex >= 1) and:		[(count >= 0) and:		[(startIndex + count - 1) <= (self lengthOf: array)]]).	successFlag ifTrue: [		"Note: adjust bufStart for zero-origin indexing"		arrayBase _ array + BaseHeaderSize.		bufStart _ arrayBase + ((startIndex - 1) * byteSize).		bytesReceived _			self sqSocket: s				ReceiveDataBuf: bufStart				Count: (count * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, s, array, startIndex, count"		self pushInteger: bytesReceived // byteSize.  "push # of elements"	].! !!Interpreter methodsFor: 'socket primitives'!primitiveSocketRemoteAddress	| s addr |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		addr _ self sqSocketRemoteAddress: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self intToNetAddress: addr).	].! !!Interpreter methodsFor: 'socket primitives'!primitiveSocketRemotePort	| s port |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		port _ self sqSocketRemotePort: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self integerObjectOf: port).	].! !!Interpreter methodsFor: 'socket primitives'!primitiveSocketSendDataBufCount	| count startIndex array s byteSize arrayBase bufStart bytesSent |	self var: #s declareC: 'SocketPtr s'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	s			_ self socketValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [byteSize _ 4]		ifFalse: [byteSize _ 1].	self success: (		(startIndex >= 1) and:		[(count >= 0) and:		[(startIndex + count - 1) <= (self lengthOf: array)]]).	successFlag ifTrue: [		"Note: adjust bufStart for zero-origin indexing"		arrayBase _ array + BaseHeaderSize.		bufStart _ arrayBase + ((startIndex - 1) * byteSize).		bytesSent _			self sqSocket: s				SendDataBuf: bufStart				Count: (count * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, s, array, startIndex, count"		self pushInteger: bytesSent // byteSize.  "push # of elements"	].! !!Interpreter methodsFor: 'socket primitives'!primitiveSocketSendDone	| s done |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		done _ self sqSocketSendDone: s.	].	successFlag ifTrue: [		self pop: 2.  "pop s, rcvr"		self pushBool: done.	].! !!Interpreter methodsFor: 'socket primitives'!socketRecordSize	"Return the size of a Smalltalk socket record in bytes."	^ self cCode: 'sizeof(SQSocket)'.! !!Interpreter methodsFor: 'socket primitives'!socketValueOf: socketOop	"Return a pointer to the first byte of of the socket record within the given Smalltalk object, or nil if socketOop is not a socket record."	| socketIndex |	self returnTypeC: 'SQSocket *'.	self success:		((self isBytes: socketOop) and:		 [(self lengthOf: socketOop) = self socketRecordSize]).	successFlag ifTrue: [		socketIndex _ socketOop + BaseHeaderSize.		^ self cCode: '(SQSocket *) socketIndex'	] ifFalse:  [		^ nil	].! !!Interpreter methodsFor: 'resolver primitives'!intToNetAddress: addr	"Convert the given 32-bit integer into an internet network address represented as a four-byte ByteArray."	| netAddressOop |	netAddressOop _		self instantiateSmallClass: (self splObj: ClassByteArray)			sizeInBytes: 8			fill: 0.	self storeByte: 0 ofObject: netAddressOop		withValue: ((addr >> 24) bitAnd: 16rFF).	self storeByte: 1 ofObject: netAddressOop		withValue: ((addr >> 16) bitAnd: 16rFF).	self storeByte: 2 ofObject: netAddressOop		withValue: ((addr >> 8) bitAnd: 16rFF).	self storeByte: 3 ofObject: netAddressOop		withValue: (addr bitAnd: 16rFF).	^ netAddressOop! !!Interpreter methodsFor: 'resolver primitives'!netAddressToInt: oop	"Convert the given internet network address (represented as a four-byte ByteArray) into a 32-bit integer. Fail if the given oop is not a four-byte ByteArray."	| sz |	self assertClassOf: oop is: (self splObj: ClassByteArray).	successFlag ifTrue: [		sz _ self lengthOf: oop.		sz = 4 ifFalse: [^ self primitiveFail]].	successFlag ifTrue: [		^ (self fetchByte: 3 ofObject: oop) +		  ((self fetchByte: 2 ofObject: oop) << 8) +		  ((self fetchByte: 1 ofObject: oop) << 16) +		  ((self fetchByte: 0 ofObject: oop) << 24) ].! !!Interpreter methodsFor: 'resolver primitives'!primitiveResolverAbortLookup	self sqResolverAbort.! !!Interpreter methodsFor: 'resolver primitives'!primitiveResolverAddressLookupResult	| sz s |	sz _ self sqResolverAddrLookupResultSize.	successFlag ifTrue: [		s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.		self sqResolverAddrLookup: (self cCoerce: (s + BaseHeaderSize) to: 'char *')			Result: sz.	].	successFlag ifTrue: [		self pop: 1 thenPush: s.	].! !!Interpreter methodsFor: 'resolver primitives'!primitiveResolverError	| err |	err _ self sqResolverError.	successFlag ifTrue: [		self pop: 1 thenPush: (self integerObjectOf: err).	].! !!Interpreter methodsFor: 'resolver primitives'!primitiveResolverLocalAddress	| addr |	addr _ self sqResolverLocalAddress.	successFlag ifTrue: [		self pop: 1 thenPush: (self intToNetAddress: addr).	].! !!Interpreter methodsFor: 'resolver primitives'!primitiveResolverNameLookupResult	| addr |	addr _ self sqResolverNameLookupResult.	successFlag ifTrue: [		self pop: 1 thenPush: (self intToNetAddress: addr).	].! !!Interpreter methodsFor: 'resolver primitives'!primitiveResolverStartAddressLookup	| addr |	addr _ self netAddressToInt: self stackTop.	successFlag ifTrue: [		self sqResolverStartAddrLookup: addr.	].	successFlag ifTrue: [		self pop: 1.  "pop addr, leave rcvr on stack"	].! !!Interpreter methodsFor: 'resolver primitives'!primitiveResolverStartNameLookup	| name sz |	name _ self stackTop.	self assertClassOf: name is: (self splObj: ClassString).	successFlag ifTrue: [		sz _ self lengthOf: name.		self sqResolverStartName: (self cCoerce: (name + BaseHeaderSize) to: 'char *')			Lookup: sz.	].	successFlag ifTrue: [		self pop: 1.  "pop name, leave rcvr on stack"	].! !!Interpreter methodsFor: 'resolver primitives'!primitiveResolverStatus	| status |	status _ self sqResolverStatus.	successFlag ifTrue: [		self pop: 1 thenPush: (self integerObjectOf: status).	].! !!Interpreter methodsFor: 'sound primitives' stamp: '6/7/97 09:59 di'!primitiveConstantFill	"Fill the receiver, which must be an indexable bytes or words objects, with the given integer value."	| fillValue rcvr rcvrIsBytes end i |	fillValue _ self positive32BitValueOf: self stackTop. 	rcvr _ self stackValue: 1.	self success: (self isWordsOrBytes: rcvr).	rcvrIsBytes _ self isBytes: rcvr.	rcvrIsBytes ifTrue: [		self success: ((fillValue >= 0) and: [fillValue <= 255]).	].	successFlag ifTrue: [		end _ rcvr + (self sizeBitsOf: rcvr).		i _ rcvr + BaseHeaderSize.		rcvrIsBytes ifTrue: [			[i < end] whileTrue: [				self byteAt: i put: fillValue.				i _ i + 1.			].		] ifFalse: [			[i < end] whileTrue: [				self longAt: i put: fillValue.				i _ i + 4.			].		].		self pop: 1.  "pop fillValue; leave rcvr on stack"	].! !!Interpreter methodsFor: 'sound primitives'!primitiveShortAt	"Treat the receiver, which can be indexible by either bytes or words, as an array of signed 16-bit values. Return the contents of the given index. Note that the index specifies the i-th 16-bit entry, not the i-th byte or word."	| index rcvr sz addr value |	index _ self stackIntegerValue: 0.	rcvr _ self stackValue: 1.	self success: ((self isIntegerObject: rcvr) not and: [self isWordsOrBytes: rcvr]).	successFlag ifFalse: [ ^ nil ].	sz _ ((self sizeBitsOf: rcvr) - BaseHeaderSize) // 2.  "number of 16-bit fields"	self success: ((index >= 1) and: [index <= sz]).	successFlag ifTrue: [		addr _ rcvr + BaseHeaderSize + (2 * (index - 1)).		value _ self cCode: '*((short int *) addr)'.		self pop: 2.  "pop rcvr, index"		self pushInteger: value.  "push element value"	].! !!Interpreter methodsFor: 'sound primitives'!primitiveShortAtPut	"Treat the receiver, which can be indexible by either bytes or words, as an array of signed 16-bit values. Set the contents of the given index to the given value. Note that the index specifies the i-th 16-bit entry, not the i-th byte or word."	| index rcvr sz addr value |	value _ self stackIntegerValue: 0.	index _ self stackIntegerValue: 1.	rcvr _ self stackValue: 2.	self success: ((self isIntegerObject: rcvr) not and: [self isWordsOrBytes: rcvr]).	successFlag ifFalse: [ ^ nil ].	sz _ ((self sizeBitsOf: rcvr) - BaseHeaderSize) // 2.  "number of 16-bit fields"	self success: ((index >= 1) and: [index <= sz]).	self success: ((value >= -32768) and: [value <= 32767]).	successFlag ifTrue: [		addr _ rcvr + BaseHeaderSize + (2 * (index - 1)).		self cCode: '*((short int *) addr) = value'.		self pop: 2.  "pop index and value; leave rcvr on stack"	].! !!Interpreter methodsFor: 'sound primitives'!primitiveSoundAvailableSpace	"Returns the number of sample frames of available sound output buffer space."	| frames |	frames _ self cCode: 'snd_AvailableSpace()'.  "-1 if sound output not started"	self success: frames >= 0.	successFlag ifTrue: [		self pop: 1.  "rcvr"		self push: (self positive32BitIntegerFor: frames).	].! !!Interpreter methodsFor: 'sound primitives' stamp: 'jm 8/22/97 16:27'!primitiveSoundGetRecordingSampleRate	"Return a float representing the actual sampling rate during recording. Fail if not currently recording."	| rate |	self var: #rate declareC: 'double rate'.	rate _ self cCode: 'snd_GetRecordingSampleRate()'.  "fail if not recording"	successFlag ifTrue: [		self pop: 1.  "rcvr"		self pushFloat: rate.	].! !!Interpreter methodsFor: 'sound primitives' stamp: 'jm 9/10/97 08:15'!primitiveSoundInsertSamples	"Insert a buffer's worth of sound samples into the currently playing buffer. Used to make a sound start playing as quickly as possible. The new sound is mixed with the previously buffered sampled."	"Details: Unlike primitiveSoundPlaySamples, this primitive always starts with the first sample the given sample buffer. Its third argument specifies the number of samples past the estimated sound output buffer position the inserted sound should start. If successful, it returns the number of samples inserted."	| leadTime buf frameCount framesPlayed |	leadTime _ self stackIntegerValue: 0.	buf _ self stackValue: 1.	frameCount _ self stackIntegerValue: 2.	self success: (self isWords: buf).	self success: (frameCount <= (self lengthOf: buf)).	successFlag ifTrue: [		framesPlayed _			self cCode: 'snd_InsertSamplesFromLeadTime(frameCount, buf + 4, leadTime)'.		self success: framesPlayed >= 0].	successFlag ifTrue: [		self pop: 4.  "pop frameCount, buf, leadTime, rcvr"		self push: (self positive32BitIntegerFor: framesPlayed)].! !!Interpreter methodsFor: 'sound primitives'!primitiveSoundPlaySamples	"Output a buffer's worth of sound samples."	| startIndex buf frameCount framesPlayed |	startIndex _ self stackIntegerValue: 0.	buf _ self stackValue: 1.	frameCount _ self stackIntegerValue: 2.	self success: (self isWords: buf).	self success: (		(startIndex >= 1) and:		[(startIndex + frameCount - 1) <= (self lengthOf: buf)]).	successFlag ifTrue: [		framesPlayed _			self cCode: 'snd_PlaySamplesFromAtLength(frameCount, buf + 4, startIndex - 1)'.		self success: framesPlayed >= 0.	].	successFlag ifTrue: [		self pop: 4.  "pop frameCount, buf, startIndex, rcvr"		self push: (self positive32BitIntegerFor: framesPlayed).	].! !!Interpreter methodsFor: 'sound primitives'!primitiveSoundPlaySilence	"Output a buffer's worth of silence. Returns the number of sample frames played."	| framesPlayed |	framesPlayed _ self cCode: 'snd_PlaySilence()'.  "-1 if sound output not started"	self success: framesPlayed >= 0.	successFlag ifTrue: [		self pop: 1.  "rcvr"		self push: (self positive32BitIntegerFor: framesPlayed).	].! !!Interpreter methodsFor: 'sound primitives' stamp: 'jm 8/22/97 21:59'!primitiveSoundRecordSamples	"Record a buffer's worth of 16-bit sound samples."	| startWordIndex buf bufSizeInBytes samplesRecorded |	startWordIndex _ self stackIntegerValue: 0.	buf _ self stackValue: 1.	self success: (self isWords: buf).	successFlag ifTrue: [		bufSizeInBytes _ (self lengthOf: buf) * 4.		self success: ((startWordIndex >= 1) and: [((startWordIndex - 1) * 2) < bufSizeInBytes]).	].	successFlag ifTrue: [		samplesRecorded _			self cCode: 'snd_RecordSamplesIntoAtLength(buf + 4, startWordIndex - 1, bufSizeInBytes)'.	].	successFlag ifTrue: [		self pop: 3.  "pop rcvr, startWordIndex, buf"		self push: (self integerObjectOf: samplesRecorded).	].! !!Interpreter methodsFor: 'sound primitives' stamp: 'jm 9/18/97 13:15'!primitiveSoundSetRecordLevel	"Set the sound input recording level."	| level |	level _ self stackIntegerValue: 0.	successFlag ifTrue: [		self cCode: 'snd_SetRecordLevel(level)'.	].	successFlag ifTrue: [		self pop: 1.  "pop level; leave rcvr on stack"	].! !!Interpreter methodsFor: 'sound primitives' stamp: 'jm 8/23/97 20:18'!primitiveSoundStart	"Start the double-buffered sound output with the given buffer size, sample rate, and stereo flag."	| stereoFlag samplesPerSec bufFrames |	stereoFlag		_ self booleanValueOf: (self stackValue: 0).	samplesPerSec	_ self stackIntegerValue: 1.	bufFrames		_ self stackIntegerValue: 2.	successFlag ifTrue: [		self success: (self cCode: 'snd_Start(bufFrames, samplesPerSec, stereoFlag, 0)').	].	successFlag ifTrue: [		self pop: 3.  "pop bufFrames, samplesPerSec, stereoFlag; leave rcvr on stack"	].! !!Interpreter methodsFor: 'sound primitives' stamp: 'jm 9/18/97 13:15'!primitiveSoundStartRecording	"Start recording sound with the given parameters."	| semaIndex stereoFlag desiredSamplesPerSec |	semaIndex				_ self stackIntegerValue: 0.	stereoFlag				_ self booleanValueOf: (self stackValue: 1).	desiredSamplesPerSec	_ self stackIntegerValue: 2.	successFlag ifTrue: [		self cCode: 'snd_StartRecording(desiredSamplesPerSec, stereoFlag, semaIndex)'.	].	successFlag ifTrue: [		self pop: 3.  "pop desiredSamplesPerSec, stereoFlag, and semaIndex; leave rcvr on stack"	].! !!Interpreter methodsFor: 'sound primitives' stamp: 'jm 8/23/97 20:17'!primitiveSoundStartWithSemaphore	"Start the double-buffered sound output with the given buffer size, sample rate, stereo flag, and semaphore index."	| semaIndex stereoFlag samplesPerSec bufFrames |	semaIndex		_ self stackIntegerValue: 0.	stereoFlag		_ self booleanValueOf: (self stackValue: 1).	samplesPerSec	_ self stackIntegerValue: 2.	bufFrames		_ self stackIntegerValue: 3.	successFlag ifTrue: [		self success: (self cCode: 'snd_Start(bufFrames, samplesPerSec, stereoFlag, semaIndex)').	].	successFlag ifTrue: [		self pop: 4.  "pop bufFrames, samplesPerSec, stereoFlag, semaIndex; leave rcvr on stack"	].! !!Interpreter methodsFor: 'sound primitives'!primitiveSoundStop	"Stop double-buffered sound output."	self cCode: 'snd_Stop()'.  "leave rcvr on stack"	! !!Interpreter methodsFor: 'sound primitives' stamp: 'jm 8/22/97 16:22'!primitiveSoundStopRecording	"Stop recording sound."	self cCode: 'snd_StopRecording()'.  "leave rcvr on stack"! !!Interpreter methodsFor: 'other primitives'!primitiveClipboardText	"When called with a single string argument, post the string to the clipboard. When called with zero arguments, return a string containing the current clipboard contents."	| s sz |	argumentCount = 1 ifTrue: [		s _ self stackTop.		self assertClassOf: s is: (self splObj: ClassString).		successFlag ifTrue: [			sz _ self stSizeOf: s.			self clipboardWrite: sz From: (s + BaseHeaderSize) At: 0.			self pop: 1.  "pop s, leave rcvr on stack"		].	] ifFalse: [		sz _ self clipboardSize.		s _ self instantiateClass: (self splObj: ClassString)					  indexableSize: sz.		self clipboardRead: sz Into: (s + BaseHeaderSize) At: 0.		self pop: 1.  "rcvr"		self push: s.	].! !!Interpreter methodsFor: 'other primitives'!primitiveExitToDebugger	self error: 'Exit to debugger at user request'.! !!Interpreter methodsFor: 'other primitives'!primitiveFlushCache	"Clear the method lookup cache. This must be done after every programming change."	self flushMethodCache.! !!Interpreter methodsFor: 'other primitives' stamp: 'di 12/25/97 15:02'!primitiveFlushCacheSelective	"The receiver is a message selector.  Clear all entries in the method lookup cache with this selector, presumably because an associated method has been redefined."	| selector nCols |	selector _ self stackTop.	"Flush all entries of the method cache that refer to the given selector."	nCols _ MethodCacheSize // MethodCacheEntries.	1 to: MethodCacheEntries do:		[:i | (methodCache at: i) = selector ifTrue:			[0 to: nCols-1 do:				[:col | methodCache at: i+(MethodCacheEntries*col) put: 0]]]! !!Interpreter methodsFor: 'other primitives' stamp: 'jm 10/30/97 05:47'!primitiveForceDisplayUpdate	"On some platforms, this primitive forces enqueued display updates to be processed immediately. On others, it does nothing."	self ioForceDisplayUpdate.! !!Interpreter methodsFor: 'other primitives' stamp: 'jm 10/30/97 07:47'!primitiveFormPrint	"On platforms that support it, this primitive prints the receiver, assumed to be a Form, to the default printer."	| landscapeFlag vScale hScale rcvr bitsArray w h	 depth pixelsPerWord wordsPerLine bitsArraySize ok |	self var: #vScale declareC: 'double vScale'.	self var: #hScale declareC: 'double hScale'.	landscapeFlag _ self booleanValueOf: self stackTop.	vScale _ self floatValueOf: (self stackValue: 1).	hScale _ self floatValueOf: (self stackValue: 2).	rcvr _ self stackValue: 3.	(rcvr isIntegerObject: rcvr) ifTrue: [self success: false].	successFlag ifTrue: [		((self  isPointers: rcvr) and: [(self lengthOf: rcvr) >= 4])			ifFalse: [self success: false]].	successFlag ifTrue: [		bitsArray _ self fetchPointer: 0 ofObject: rcvr.		w _ self fetchInteger: 1 ofObject: rcvr.		h _ self fetchInteger: 2 ofObject: rcvr.		depth _ self fetchInteger: 3 ofObject: rcvr.		(w > 0 and: [h > 0]) ifFalse: [self success: false].		pixelsPerWord _ 32 // depth.		wordsPerLine _ (w + (pixelsPerWord - 1)) // pixelsPerWord.		((rcvr isIntegerObject: rcvr) not and: [self isWordsOrBytes: bitsArray])			ifTrue: [				bitsArraySize _ self byteLengthOf: bitsArray.				self success: (bitsArraySize = (wordsPerLine * h * 4))]			ifFalse: [self success: false]].		successFlag ifTrue: [		ok _ self cCode:			'ioFormPrint(bitsArray + 4, w, h, depth, hScale, vScale, landscapeFlag)'.		self success: ok].	successFlag ifTrue: [		self pop: 3].  "pop hScale, vScale, and landscapeFlag; leave rcvr on stack"! !!Interpreter methodsFor: 'other primitives' stamp: 'jm 9/3/97 11:54'!primitiveGetAttribute	"Fetch the system attribute with the given integer ID. The result is a string, which will be empty if the attribute is not defined."	| attr sz s |	attr _ self stackIntegerValue: 0.	successFlag ifTrue: [		sz _ self attributeSize: attr.		s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.		self getAttribute: attr Into: (s + BaseHeaderSize) Length: sz.		self pop: 2.  "rcvr, attr"		self push: s].! !!Interpreter methodsFor: 'other primitives'!primitiveImageName	"When called with a single string argument, record the string as the current image file name. When called with zero arguments, return a string containing the current image file name."	| s sz |	argumentCount = 1 ifTrue: [		s _ self stackTop.		self assertClassOf: s is: (self splObj: ClassString).		successFlag ifTrue: [			sz _ self stSizeOf: s.			self imageNamePut: (s + BaseHeaderSize) Length: sz.			self pop: 1.  "pop s, leave rcvr on stack"		].	] ifFalse: [		sz _ self imageNameSize.		s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.		self imageNameGet: (s + BaseHeaderSize) Length: sz.		self pop: 1.  "rcvr"		self push: s.	].! !!Interpreter methodsFor: 'other primitives' stamp: 'jm 9/14/97 10:53'!primitiveMillisecondClock	"Return the value of the millisecond clock as an integer. Note that the millisecond clock wraps around periodically. On some platforms it can wrap daily. The range is limited to SmallInteger maxVal / 2 to allow delays of up to that length without overflowing a SmallInteger."	self pop: 1.  "pop rcvr"	self push: (self integerObjectOf: (self ioMSecs bitAnd: 16r1FFFFFFF)).! !!Interpreter methodsFor: 'other primitives'!primitiveNoop	"A placeholder for primitives that haven't been implemented or are being withdrawn gradually. Just absorbs any arguments and returns the receiver."	self pop: argumentCount.  "pop args, leave rcvr on stack"! !!Interpreter methodsFor: 'other primitives'!primitiveQuit	self ioExit.! !!Interpreter methodsFor: 'other primitives'!primitiveReadJoystick	"Read an input word from the joystick with the given index."	| index |	index _ self stackIntegerValue: 0.	successFlag ifTrue: [		self pop: 2.  "index, rcvr"		self push: (self positive32BitIntegerFor: (self joystickRead: index)).	].! !!Interpreter methodsFor: 'other primitives' stamp: 'jm 9/3/97 11:57'!primitiveRelinquishProcessor	"Relinquish the processor for up to the given number of microseconds. The exact behavior of this primitive is platform dependent."	| microSecs |	microSecs _ self stackIntegerValue: 0.	successFlag ifTrue: [		self ioRelinquishProcessorForMicroseconds: microSecs.		self pop: 1].  "microSecs; leave rcvr on stack"! !!Interpreter methodsFor: 'other primitives'!primitiveSecondsClock	"Return the number of seconds since January 1, 1901 as an integer."	self pop: 1.  "pop rcvr"	self push: (self positive32BitIntegerFor: self ioSeconds).! !!Interpreter methodsFor: 'other primitives'!primitiveSignalAtMilliseconds	"Cause the time semaphore, if one has been registered, to be signalled when the millisecond clock is greater than or equal to the given tick value. A tick value of zero turns off timer interrupts."	| tick sema |	tick _ self popInteger.	sema _ self popStack.	successFlag ifTrue: [		(self fetchClassOf: sema) = (self splObj: ClassSemaphore) ifTrue: [			self storePointer: TheTimerSemaphore ofObject: specialObjectsOop withValue: sema.			nextWakeupTick _ tick.		] ifFalse: [			self storePointer: TheTimerSemaphore ofObject: specialObjectsOop withValue: nilObj.			nextWakeupTick _ 0.		].	] ifFalse: [		self unPop: 2.  "sema, tick"	].! !!Interpreter methodsFor: 'other primitives'!primitiveSnapshot	| activeProc dataSize rcvr |	"save the state of the current process and save it on the scheduler queue"	self storeContextRegisters: activeContext.	activeProc _		self fetchPointer: ActiveProcessIndex ofObject: self schedulerPointer.	self storePointer: SuspendedContextIndex		    ofObject: activeProc		  withValue: activeContext.	"compact memory and compute the size of the memory actually in use"	self incrementalGC.  "maximimize space for forwarding table"	self fullGC.	dataSize _ freeBlock - (self startOfMemory).	"Assume: all objects are below the start of the free block"	successFlag ifTrue: [		rcvr _ self popStack.  "pop rcvr"		self push: trueObj.		self writeImageFile: dataSize.		self pop: 1.  "pop true"	].	successFlag		ifTrue: [ self push: falseObj ]		ifFalse: [ self push: rcvr ].! !!Interpreter methodsFor: 'other primitives'!primitiveSpecialObjectsOop	"Return the oop of the SpecialObjectsArray."	self pop: 1.	self push: specialObjectsOop.! !!Interpreter methodsFor: 'other primitives' stamp: 'jm 9/14/97 12:53'!primitiveVMParameter	"Behaviour depends on argument count:		0 args:	return an Array of VM parameter values;		1 arg:	return the indicated VM parameter;		2 args:	set the VM indicated parameter.	VM parameters are numbered as follows:		1	end of old-space (0-based, read-only)		2	end of young-space (read-only)		3	end of memory (read-only)		4	allocationCount (read-only)		5	allocations between GCs (read-write, but read-only for now)		6	survivor count tenuring threshold (read-write, but read-only for now)		7	full GCs since startup (read-only)		8	total milliseconds in full GCs since startup (read-only)		9	incremental GCs since startup (read-only)		10	total milliseconds in incremental GCs since startup (read-only)		11	tenures of surving objects since startup (read-only)"	"Note: Thanks to Ian Piumarta for this primitive."	| result mem |	mem _ self cCoerce: memory to: 'int'.	argumentCount = 0 ifTrue: [		result _ self instantiateClass: (self splObj: ClassArray) indexableSize: 11.		self stObject: result at: 1 put: (self integerObjectOf: youngStart - mem).		self stObject: result at: 2 put: (self integerObjectOf: freeBlock - mem).		self stObject: result at: 3 put: (self integerObjectOf: endOfMemory - mem).		self stObject: result at: 4 put: (self integerObjectOf: allocationCount).		self stObject: result at: 5 put: (self integerObjectOf: allocationsBetweenGCs).		self stObject: result at: 6 put: (self integerObjectOf: tenuringThreshold).		self stObject: result at: 7 put: (self integerObjectOf: statFullGCs).		self stObject: result at: 8 put: (self integerObjectOf: statFullGCMSecs).		self stObject: result at: 9 put: (self integerObjectOf: statIncrGCs).		self stObject: result at: 10 put: (self integerObjectOf: statIncrGCMSecs).		self stObject: result at: 11 put: (self integerObjectOf: statTenures).		self pop: 1 thenPush: result.		^ nil].	self primitiveFail.! !!Interpreter methodsFor: 'other primitives'!primitiveVMPath	"Return a string containing the path name of VM's directory."	| s sz |	sz _ self vmPathSize.	s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.	self vmPathGet: (s + BaseHeaderSize) Length: sz.	self pop: 1.  "rcvr"	self push: s.! !!Interpreter methodsFor: 'debug printing'!cr	"For testing in Smalltalk, this method should be overridden in a subclass."	self printf: '\n'.! !!Interpreter methodsFor: 'debug printing'!print: s	"For testing in Smalltalk, this method should be overridden in a subclass."	self var: #s declareC: 'char *s'.	self cCode: 'printf("%s", s)'.! !!Interpreter methodsFor: 'debug printing'!printChar: aByte	"For testing in Smalltalk, this method should be overridden in a subclass."	self putchar: aByte.! !!Interpreter methodsFor: 'debug printing'!printNum: n	"For testing in Smalltalk, this method should be overridden in a subclass."	self cCode: 'printf("%ld", (long) n)'.! !!Interpreter methodsFor: 'debug support'!allAccessibleObjectsOkay	"Ensure that all accessible objects in the heap are okay."	| oop |	oop _ self firstAccessibleObject.	[oop = nil] whileFalse: [		self okayFields: oop.		oop _ self accessibleObjectAfter: oop.	].! !!Interpreter methodsFor: 'debug support'!findClassOfMethod: meth forReceiver: rcvr	| currClass classDict classDictSize methodArray i done |	currClass _ self fetchClassOf: rcvr.	done _ false.	[done] whileFalse: [		classDict _ self fetchPointer: MessageDictionaryIndex ofObject: currClass.		classDictSize _ self fetchWordLengthOf: classDict.		methodArray _ self fetchPointer: MethodArrayIndex ofObject: classDict.		i _ 0.		[i < (classDictSize - SelectorStart)] whileTrue: [			meth = (self fetchPointer: i ofObject: methodArray) ifTrue: [ ^currClass ].			i _ i + 1.		].		currClass _ self fetchPointer: SuperclassIndex ofObject: currClass.		done _ currClass = nilObj.	].	^self fetchClassOf: rcvr    "method not found in superclass chain"! !!Interpreter methodsFor: 'debug support'!findSelectorOfMethod: meth forReceiver: rcvr	| currClass done classDict classDictSize methodArray i |	currClass _ self fetchClassOf: rcvr.	done _ false.	[done] whileFalse: [		classDict _ self fetchPointer: MessageDictionaryIndex ofObject: currClass.		classDictSize _ self fetchWordLengthOf: classDict.		methodArray _ self fetchPointer: MethodArrayIndex ofObject: classDict.		i _ 0.		[i <= (classDictSize - SelectorStart)] whileTrue: [			meth = (self fetchPointer: i ofObject: methodArray) ifTrue: [				^(self fetchPointer: i + SelectorStart ofObject: classDict)			].			i _ i + 1.		].		currClass _ self fetchPointer: SuperclassIndex ofObject: currClass.		done _ currClass = nilObj.	].	^self splObj: SelectorDoesNotUnderstand    "method not found in superclass chain"! !!Interpreter methodsFor: 'debug support'!okayActiveProcessStack	| cntxt |	cntxt _ activeContext.		[cntxt = nilObj] whileFalse: [		self okayFields: cntxt.		cntxt _ (self fetchPointer: SenderIndex ofObject: cntxt).	].! !!Interpreter methodsFor: 'debug support'!okayFields: oop	"If this is a pointers object, check that its fields are all okay oops."	| i fieldOop |	(oop = nil or: [oop = 0]) ifTrue: [ ^true ].	(self isIntegerObject: oop) ifTrue: [ ^true ].	self okayOop: oop.	self oopHasOkayClass: oop.	(self isPointers: oop) ifFalse: [ ^true ].	i _ (self lengthOf: oop) - 1.	[i >= 0] whileTrue: [		fieldOop _ self fetchPointer: i ofObject: oop.		(self isIntegerObject: fieldOop) ifFalse: [			self okayOop: fieldOop.			self oopHasOkayClass: fieldOop.		].		i _ i - 1.	].! !!Interpreter methodsFor: 'debug support'!okayInterpreterObjects	| oopOrZero oop |	self okayFields: nilObj.	self okayFields: falseObj.	self okayFields: trueObj.	self okayFields: specialObjectsOop.	self okayFields: activeContext.	self okayFields: method.	self okayFields: receiver.	self okayFields: theHomeContext.	self okayFields: messageSelector.	self okayFields: newMethod.	1 to: MethodCacheEntries do: [ :i |		oopOrZero _ methodCache at: i.		oopOrZero = 0 ifFalse: [			self okayFields: (methodCache at: i).							"selector"			self okayFields: (methodCache at: i + MethodCacheEntries).		"class"			self okayFields: (methodCache at: i + (2 * MethodCacheEntries)).	"method"		].	].	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			self okayFields: oop.		].	].	self okayActiveProcessStack.! !!Interpreter methodsFor: 'debug support'!okayOop: oop	"Verify that the given oop is legitimate. Check address, header, and size but not class."	| sz type fmt |	"address and size checks"	(self isIntegerObject: oop) ifTrue: [ ^true ].	((0 < oop) & (oop < endOfMemory))		ifFalse: [ self error: 'oop is not a valid address' ].	((oop \\ 4) = 0)		ifFalse: [ self error: 'oop is not a word-aligned address' ].	sz _ self sizeBitsOf: oop.	(oop + sz) < endOfMemory		ifFalse: [ self error: 'oop size would make it extend beyond the end of memory' ].	"header type checks"	type _ self headerType: oop.	type = HeaderTypeFree		ifTrue:  [ self error: 'oop is a free chunk, not an object' ].	type = HeaderTypeShort ifTrue: [		(((self baseHeader: oop) >> 12) bitAnd: 16r1F) = 0			ifTrue:  [ self error: 'cannot have zero compact class field in a short header' ].	].	type = HeaderTypeClass ifTrue: [		((oop >= 4) and: [(self headerType: oop - 4) = type])			ifFalse: [ self error: 'class header word has wrong type' ].	].	type = HeaderTypeSizeAndClass ifTrue: [		((oop >= 8) and:		 [(self headerType: oop - 8) = type and:		 [(self headerType: oop - 4) = type]])			ifFalse: [ self error: 'class header word has wrong type' ].	].	"format check"	fmt _ self formatOf: oop.	((fmt = 4) | (fmt = 5) | (fmt = 7))		ifTrue:  [ self error: 'oop has an unknown format type' ].	"mark and root bit checks"	((self longAt: oop) bitAnd: 16r20000000) = 0		ifFalse: [ self error: 'unused header bit 30 is set; should be zero' ]."xxx	((self longAt: oop) bitAnd: MarkBit) = 0		ifFalse: [ self error: 'mark bit should not be set except during GC' ].xxx"	(((self longAt: oop) bitAnd: RootBit) = 1 and:	 [oop >= youngStart])		ifTrue: [ self error: 'root bit is set in a young object' ].	^true! !!Interpreter methodsFor: 'debug support'!oopHasOkayClass: oop	"Attempt to verify that the given oop has a reasonable behavior. The class must be a valid, non-integer oop and must not be nilObj. It must be a pointers object with three or more fields. Finally, the instance specification field of the behavior must match that of the instance."	| oopClass formatMask behaviorFormatBits oopFormatBits |	self okayOop: oop.	oopClass _ self fetchClassOf: oop.	(self isIntegerObject: oopClass)		ifTrue: [ self error: 'a SmallInteger is not a valid class or behavior' ].	self okayOop: oopClass.	((self isPointers: oopClass) and: [(self lengthOf: oopClass) >= 3])		ifFalse: [ self error: 'a class (behavior) must be a pointers object of size >= 3' ].	(self isBytes: oop)		ifTrue: [ formatMask _ 16rC00 ]  "ignore extra bytes size bits"		ifFalse: [ formatMask _ 16rF00 ].	behaviorFormatBits _ (self formatOfClass: oopClass) bitAnd: formatMask.	oopFormatBits _ (self baseHeader: oop) bitAnd: formatMask.	behaviorFormatBits = oopFormatBits		ifFalse: [ self error: 'object and its class (behavior) formats differ' ].	^true! !!Interpreter methodsFor: 'debug support'!printCallStack	| ctxt home methodClass methodSel |	ctxt _ activeContext.	[ctxt = nilObj] whileFalse: [		(self fetchClassOf: ctxt) = (self splObj: ClassBlockContext)			ifTrue: [ home _ self fetchPointer: HomeIndex ofObject: ctxt ]			ifFalse: [ home _ ctxt ].		methodClass _			self findClassOfMethod: (self fetchPointer: MethodIndex ofObject: home)					   forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		methodSel _			self findSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)						 forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		self printNum: ctxt.		self print: ' '.		ctxt = home ifFalse: [ self print: '[] in ' ].		self printNameOfClass: methodClass count: 5.		self print: '>'.		self printStringOf: methodSel.		self cr.		ctxt _ (self fetchPointer: SenderIndex ofObject: ctxt).	].! !!Interpreter methodsFor: 'debug support'!printNameOfClass: classOop count: cnt	"Details: The count argument is used to avoid a possible infinite recursion if classOop is a corrupted object."	cnt <= 0 ifTrue: [ ^ self print: 'bad class' ].	(self sizeBitsOf: classOop) = 16r20 ifTrue: [		self printNameOfClass: (self fetchPointer: 6 "thisClass" ofObject: classOop) count: cnt - 1.		self print: ' class'.	] ifFalse: [		self printStringOf: (self fetchPointer: 6 "name" ofObject: classOop).	].! !!Interpreter methodsFor: 'debug support'!printStringOf: oop	| fmt cnt i |	fmt _ self formatOf: oop.	fmt < 8 ifTrue: [ ^nil ].	cnt _ 100 min: (self lengthOf: oop).	i _ 0.	[i < cnt] whileTrue: [		self printChar: (self fetchByte: i ofObject: oop).		i _ i + 1.	].! !!Interpreter methodsFor: 'debug support'!reportContexts	| cntxt big small |	big _ 0.	cntxt _ freeLargeContexts.	[cntxt = NilContext] whileFalse: [		big _ big + 1.		cntxt _ self fetchWord: 0 ofObject: cntxt.	].	small _ 0.	cntxt _ freeSmallContexts.	[cntxt = NilContext] whileFalse: [		small _ small + 1.		cntxt _ self fetchWord: 0 ofObject: cntxt.	].	self print: 'Recycled contexts: '.	self printNum: small; print: ' small, '.	self printNum: big; print: ' large ('.	self printNum: (big * LargeContextSize) + (small * SmallContextSize).	self print: ' bytes)'.	self cr.! !!Interpreter methodsFor: 'image save/restore' stamp: 'di 9/23/97 15:22'!byteSwapByteObjects	"Byte-swap the words of all bytes objects in the image, including Strings, ByteArrays, and CompiledMethods. This returns these objects to their original byte ordering after blindly byte-swapping the entire image. For compiled methods, byte-swap only their bytecodes part."	| oop fmt wordAddr methodHeader |	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifFalse: [			fmt _ self formatOf: oop.			fmt >= 8 ifTrue: [  "oop contains bytes"				wordAddr _ oop + BaseHeaderSize.				fmt >= 12 ifTrue: [					"compiled method; start after methodHeader and literals"					methodHeader _ self longAt: oop + BaseHeaderSize.					wordAddr _ wordAddr + 4 + (((methodHeader >> 10) bitAnd: 16rFF) * 4).				].				self reverseBytesFrom: wordAddr to: oop + (self sizeBitsOf: oop).			]. 		].		oop _ self objectAfter: oop.	].! !!Interpreter methodsFor: 'image save/restore'!byteSwapped: w	"Return the given integer with its bytes in the reverse order."	^ ((w bitShift: -24) bitAnd: 16rFF) +	  ((w bitShift: -8) bitAnd: 16rFF00) +	  ((w bitShift: 8) bitAnd: 16rFF0000) +	  ((w bitShift: 24) bitAnd: 16rFF000000)! !!Interpreter methodsFor: 'image save/restore'!checkImageVersionFrom: f	"Read and verify the image file version number and return true if the the given image file needs to be byte-swapped. As a side effect, position the file stream just after the version number of the image header. This code prints a warning and does a hard-exit if it cannot find a valid version number."	"This code is based on C code by Ian Piumarta."	| expectedVersion version firstVersion |	self var: #f declareC: 'FILE *f'.	expectedVersion _ self imageFormatVersion.	"check the version number"	self fileSeek: f position: 0.	version _ firstVersion _ self getLongFromFile: f swap: false.	(version = expectedVersion) ifTrue: [^ false].	"try with byte reversal"	self fileSeek: f position: 0.	version _ self getLongFromFile: f swap: true.	(version = expectedVersion) ifTrue: [^ true].	"try skipping the first 512 bytes (prepended by certain Mac file transfer utilities)"	self fileSeek: f position: 512.	version _ self getLongFromFile: f swap: false.	(version = expectedVersion) ifTrue: [^ false].	"try skipping the first 512 bytes with byte reversal"	self fileSeek: f position: 512.	version _ self getLongFromFile: f swap: true.	(version = expectedVersion) ifTrue: [^ true].	"hard failure; abort"	self print: 'This interpreter (vers. '.	self printNum: expectedVersion.	self print: ' cannot read image file (vers. '.	self printNum: firstVersion.	self cr.	self ioExit.! !!Interpreter methodsFor: 'image save/restore'!fileSeek: f position: pos	"Position the given file stream to the given offset from the start of the file."	self var: #f declareC: 'FILE *f'.	self cCode: 'fseek(f, pos, SEEK_SET)'.! !!Interpreter methodsFor: 'image save/restore'!getLongFromFile: f swap: swapFlag	"Return the next 4-byte word of the given file, byte-swapped according to the given flag."	| w |	self var: #f declareC: 'FILE *f'.	self cCode: 'fread(&w, sizeof(char), 4, f)'.	swapFlag		ifTrue: [^ self byteSwapped: w]		ifFalse: [^ w].! !!Interpreter methodsFor: 'image save/restore'!imageFormatVersion	"Return a magic constant that changes when the image format changes. Since the image reading code uses this to detect byte ordering, one must avoid version numbers that are invariant under byte reversal."	^ 6502! !!Interpreter methodsFor: 'image save/restore'!positionOfFile: f	"Return the current position of the given file stream."	self var: #f declareC: 'FILE *f'.	^ self cCode: 'ftell(f)'! !!Interpreter methodsFor: 'image save/restore'!putLong: n toFile: f	"Append the given 4-byte long word to the given file in this platforms 'natural' byte order. (Bytes will be swapped, if necessary, when the image is read on a different platform.) Set successFlag to false if the write fails."	| wordsWritten |	self var: #f declareC: 'FILE *f'.	wordsWritten _ self cCode: 'fwrite(&n, sizeof(int), 1, f)'.	self success: wordsWritten = 1.! !!Interpreter methodsFor: 'image save/restore'!readImageFromFile: f HeapSize: desiredHeapSize	"Read an image from the given file stream, allocating the given amount of memory to its object heap. Fail if the image has an unknown format or requires more than the given amount of memory."	"Details: This method detects when the image was stored on a machine with the opposite byte ordering from this machine and swaps the bytes automatically. Furthermore, it allows the header information to start 512 bytes into the file, since some file transfer programs for the Macintosh apparently prepend a Mac-specific header of this size. Note that this same 512 bytes of prefix area could also be used to store an exec command on Unix systems, allowing one to launch Smalltalk by invoking the image name as a command."	"This code is based on C code by Ian Piumarta and Smalltalk code by Tim Rowledge. Many thanks to both of you!!!!"	| swapBytes headerStart headerSize dataSize oldBaseAddr minimumMemory memStart bytesRead bytesToShift |	self var: #f declareC: 'FILE *f'.	swapBytes _ self checkImageVersionFrom: f.	headerStart _ (self positionOfFile: f) - 4.  "record header start position"	headerSize			_ self getLongFromFile: f swap: swapBytes.	dataSize				_ self getLongFromFile: f swap: swapBytes.	oldBaseAddr			_ self getLongFromFile: f swap: swapBytes.	specialObjectsOop		_ self getLongFromFile: f swap: swapBytes.	lastHash			_ self getLongFromFile: f swap: swapBytes.	savedWindowSize	_ self getLongFromFile: f swap: swapBytes.	lastHash = 0 ifTrue: [		"lastHash wasn't stored (e.g. by the cloner); use 999 as the seed"		lastHash _ 999].	"compare memory requirements with availability".	minimumMemory _ dataSize + 80000.  "need at least 80K of breathing room"	desiredHeapSize < minimumMemory		ifTrue: [ self error: 'Insufficient memory for this image' ].	"allocate a contiguous block of memory for the Squeak heap"	memory _ self cCode: '(unsigned char *) malloc(desiredHeapSize)'.	memory = nil		ifTrue: [ self error: 'Failed to allocate memory for the heap' ].	memStart _ self startOfMemory.	memoryLimit _ (memStart + desiredHeapSize) - 24.  "decrease memoryLimit a tad for safety"	endOfMemory _ memStart + dataSize.	"position file after the header"	self fileSeek: f position: headerStart + headerSize.	"read in the image in bulk, then swap the bytes if necessary"	bytesRead _ self cCode: 'fread(memory, sizeof(unsigned char), dataSize, f)'.	bytesRead ~= dataSize		ifTrue: [ self error: 'Read failed or premature end of image file' ].	swapBytes ifTrue: [self reverseBytesInImage].	"compute difference between old and new memory base addresses"	bytesToShift _ memStart - oldBaseAddr.	self initializeInterpreter: bytesToShift.  "adjusts all oops to new location"	^ dataSize! !!Interpreter methodsFor: 'image save/restore' stamp: 'di 9/23/97 15:20'!reverseBytesFrom: startAddr to: stopAddr	"Byte-swap the given range of memory (not inclusive!!)."	| addr |	addr _ startAddr.	[addr < stopAddr] whileTrue:		[self longAt: addr put: (self byteSwapped: (self longAt: addr)).		addr _ addr + 4].! !!Interpreter methodsFor: 'image save/restore' stamp: 'di 10/2/97 00:31'!reverseBytesInImage	"Byte-swap all words in memory after reading in the entire image file with bulk read. Contributed by Tim Rowledge."	"First, byte-swap every word in the image. This fixes objects headers."	self reverseBytesFrom: self startOfMemory to: endOfMemory.	"Second, return the bytes of bytes-type objects to their orginal order."	self byteSwapByteObjects.! !!Interpreter methodsFor: 'image save/restore' stamp: 'jm 8/2/97 19:58'!writeImageFile: imageBytes	| headerStart headerSize f bytesWritten |	self var: #f declareC: 'FILE *f'.	"local constants"	headerStart _ 0.  "change to 512 to leave room for a Unix exec string"	headerSize _ 64.  "header size in bytes; do not change!!"	f _ self cCode: 'fopen(imageName, "wb")'.	f = nil ifTrue: [		"could not open the image file for writing"		self success: false.		^ nil ].	self cCode: '/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */'.	"position file to start of header"	self fileSeek: f position: headerStart.	self putLong: (self imageFormatVersion) toFile: f.	self putLong: headerSize toFile: f.	self putLong: imageBytes toFile: f.	self putLong: (self startOfMemory) toFile: f.	self putLong: specialObjectsOop toFile: f.	self putLong: lastHash toFile: f.	self putLong: (self ioScreenSize) toFile: f.	1 to: 9 do: [:i | self putLong: 0 toFile: f].  "fill remaining header words with zeros"	successFlag ifFalse: [		"write or seek failure"		self cCode: 'fclose(f)'.		^ nil ].	"position file after the header"	self fileSeek: f position: headerStart + headerSize.	"write the image data"	bytesWritten _ self cCode: 'fwrite(memory, sizeof(unsigned char), imageBytes, f)'.	self success: bytesWritten = imageBytes.	self cCode: 'fclose(f)'.	"set Mac file type and creator; this is a noop on other platforms"	self cCode: 'dir_SetMacFileTypeAndCreator(imageName, strlen(imageName), "STim", "FAST")'.! !!Interpreter methodsFor: 'quick primitives' stamp: 'jm 9/18/97 21:06'!primitiveLoadInstVar	| thisReceiver |	thisReceiver _ self popStack.	self push: (self fetchPointer: primitiveIndex-264 ofObject: thisReceiver)! !!Interpreter methodsFor: 'quick primitives' stamp: 'jm 9/18/97 21:06'!primitivePushFalse	self popStack.	self push: falseObj! !!Interpreter methodsFor: 'quick primitives' stamp: 'jm 9/18/97 21:06'!primitivePushMinusOne	self popStack.	self push: ConstMinusOne! !!Interpreter methodsFor: 'quick primitives' stamp: 'jm 9/18/97 21:06'!primitivePushNil	self popStack.	self push: nilObj! !!Interpreter methodsFor: 'quick primitives' stamp: 'jm 9/18/97 21:06'!primitivePushOne	self popStack.	self push: ConstOne! !!Interpreter methodsFor: 'quick primitives' stamp: 'jm 9/18/97 21:06'!primitivePushSelf"	no-op, really...	thisReceiver _ self popStack.	self push: thisReceiver"! !!Interpreter methodsFor: 'quick primitives' stamp: 'jm 9/18/97 21:06'!primitivePushTrue	self popStack.	self push: trueObj! !!Interpreter methodsFor: 'quick primitives' stamp: 'jm 9/18/97 21:06'!primitivePushTwo	self popStack.	self push: ConstTwo! !!Interpreter methodsFor: 'quick primitives' stamp: 'jm 9/18/97 21:06'!primitivePushZero	self popStack.	self push: ConstZero! !!Interpreter class methodsFor: 'initialization' stamp: 'jm 8/22/97 12:57'!initialize	"Interpreter initialize"	super initialize.  "initialize ObjectMemory constants"	self initializeAssociationIndex.	self initializeBytecodeTable.	self initializeCharacterIndex.	self initializeClassIndices.	self initializeContextIndices.	self initializeDirectoryLookupResultCodes.	self initializeMessageIndices.	self initializeMethodIndices.	self initializePointIndices.	self initializePrimitiveTable.	self initializeSchedulerIndices.	self initializeSmallIntegers.	self initializeStreamIndices.	MethodCacheEntries _ 512. 	MethodCacheMask _ MethodCacheEntries - 1.	(MethodCacheEntries bitAnd: MethodCacheMask) = 0		ifFalse: [ self error: 'MethodCacheEntries must be a power of two' ].	MethodCacheSize _ MethodCacheEntries * 4.	CacheProbeMax _ 3.	SemaphoresToSignalSize _ 25.! !!Interpreter class methodsFor: 'initialization'!initializeAssociationIndex	ValueIndex _ 1! !!Interpreter class methodsFor: 'initialization'!initializeBytecodeTable	"Interpreter initializeBytecodeTable"	"Note: This table will be used to generate a C switch statement."	BytecodeTable _ Array new: 256.	self table: BytecodeTable from:	#(		(  0  15 pushReceiverVariableBytecode)		( 16  31 pushTemporaryVariableBytecode)		( 32  63 pushLiteralConstantBytecode)		( 64  95 pushLiteralVariableBytecode)		( 96 103 storeAndPopReceiverVariableBytecode)		(104 111 storeAndPopTemporaryVariableBytecode)		(112 pushReceiverBytecode)		(113 pushConstantTrueBytecode)		(114 pushConstantFalseBytecode)		(115 pushConstantNilBytecode)		(116 pushConstantMinusOneBytecode)		(117 pushConstantZeroBytecode)		(118 pushConstantOneBytecode)		(119 pushConstantTwoBytecode)		(120 returnReceiver)		(121 returnTrue)		(122 returnFalse)		(123 returnNil)		(124 returnTopFromMethod)		(125 returnTopFromBlock)		(126 unknownBytecode)		(127 unknownBytecode)		(128 extendedPushBytecode)		(129 extendedStoreBytecode)		(130 extendedStoreAndPopBytecode)		(131 singleExtendedSendBytecode)		(132 doubleExtendedDoAnythingBytecode)		(133 singleExtendedSuperBytecode)		(134 secondExtendedSendBytecode)		(135 popStackBytecode)		(136 duplicateTopBytecode)		(137 pushActiveContextBytecode)		(138 143 experimentalBytecode)		(144 151 shortUnconditionalJump)		(152 159 shortConditionalJump)		(160 167 longUnconditionalJump)		(168 171 longJumpIfTrue)		(172 175 longJumpIfFalse)		"176-191 were sendArithmeticSelectorBytecode"		(176 bytecodePrimAdd)		(177 bytecodePrimSubtract)		(178 bytecodePrimLessThan)		(179 bytecodePrimGreaterThan)		(180 bytecodePrimLessOrEqual)		(181 bytecodePrimGreaterOrEqual)		(182 bytecodePrimEqual)		(183 bytecodePrimNotEqual)		(184 bytecodePrimMultiply)		(185 bytecodePrimDivide)		(186 bytecodePrimMod)		(187 bytecodePrimMakePoint)		(188 bytecodePrimBitShift)		(189 bytecodePrimDiv)		(190 bytecodePrimBitAnd)		(191 bytecodePrimBitOr)			"192-207 were sendCommonSelectorBytecode"		(192 bytecodePrimAt)		(193 bytecodePrimAtPut)		(194 bytecodePrimSize)		(195 bytecodePrimNext)		(196 bytecodePrimNextPut)		(197 bytecodePrimAtEnd)		(198 bytecodePrimEquivalent)		(199 bytecodePrimClass)		(200 bytecodePrimBlockCopy)		(201 bytecodePrimValue)		(202 bytecodePrimValueWithArg)		(203 bytecodePrimDo)		(204 bytecodePrimNew)		(205 bytecodePrimNewWithArg)		(206 bytecodePrimPointX)		(207 bytecodePrimPointY)		(208 255 sendLiteralSelectorBytecode)	).! !!Interpreter class methodsFor: 'initialization'!initializeCharacterIndex	CharacterValueIndex _ 0! !!Interpreter class methodsFor: 'initialization'!initializeClassIndices	"Class Class"	SuperclassIndex _ 0.	MessageDictionaryIndex _ 1.	InstanceSpecificationIndex _ 2.	"Fields of a message dictionary"	MethodArrayIndex _ 1.	SelectorStart _ 2! !!Interpreter class methodsFor: 'initialization'!initializeContextIndices	"Class MethodContext"	SenderIndex _ 0.	InstructionPointerIndex _ 1.	StackPointerIndex _ 2.	MethodIndex _ 3.	ReceiverIndex _ 5.	TempFrameStart _ 6.	"Class BlockContext"	CallerIndex _ 0.	BlockArgumentCountIndex _ 3.	InitialIPIndex _ 4.	HomeIndex _ 5! !!Interpreter class methodsFor: 'initialization'!initializeDirectoryLookupResultCodes	DirEntryFound _ 0.	DirNoMoreEntries _ 1.	DirBadPath _ 2.! !!Interpreter class methodsFor: 'initialization'!initializeMessageIndices	MessageSelectorIndex _ 0.	MessageArgumentsIndex _ 1.	MessageSize _ 2! !!Interpreter class methodsFor: 'initialization'!initializeMethodIndices	"Class CompiledMethod"	HeaderIndex _ 0.	LiteralStart _ 1! !!Interpreter class methodsFor: 'initialization'!initializePointIndices	XIndex _ 0.	YIndex _ 1! !!Interpreter class methodsFor: 'initialization' stamp: 'ikp 1/14/98 21:00'!initializePrimitiveTable	"Interpreter initializePrimitiveTable"	"This table generates a C switch statement."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex+1.	self table: PrimitiveTable from: 	#(		"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveFail)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		(126 primitiveFail)		(127 primitiveFail)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"Unassigned Primitives"		(520 primitiveBeep) "test of new primitive indices"		(521 700 primitiveFail)	).! !!Interpreter class methodsFor: 'initialization'!initializeSchedulerIndices	"Class ProcessorScheduler"	ProcessListsIndex _ 0.	ActiveProcessIndex _ 1.	"Class LinkedList"	FirstLinkIndex _ 0.	LastLinkIndex _ 1.	"Class Semaphore"	ExcessSignalsIndex _ 2.	"Class Link"	NextLinkIndex _ 0.	"Class Process"	SuspendedContextIndex _ 1.	PriorityIndex _ 2.	MyListIndex _ 3! !!Interpreter class methodsFor: 'initialization'!initializeSmallIntegers	"SmallIntegers"	ConstMinusOne _ Interpreter new integerObjectOf: -1.	ConstZero _ Interpreter new integerObjectOf: 0.	ConstOne _ Interpreter new integerObjectOf: 1.	ConstTwo _ Interpreter new integerObjectOf: 2! !!Interpreter class methodsFor: 'initialization'!initializeStreamIndices	StreamArrayIndex _ 0.	StreamIndexIndex _ 1.	StreamReadLimitIndex _ 2.	StreamWriteLimitIndex _ 3.! !!Interpreter class methodsFor: 'initialization'!table: anArray from: specArray	"SpecArray is an array of either (index selector) or (index1 index2 selector)."	| contiguous |	contiguous _ 0.	specArray do: [ :spec |		(spec at: 1) = contiguous ifFalse: [ self error: 'Non-contiguous table entry' ].		spec size = 2 ifTrue: [			anArray at: ((spec at: 1) + 1) put: (spec at: 2).			contiguous _ contiguous + 1.		] ifFalse: [			(spec at: 1) to: (spec at: 2) do: [ :i | anArray at: (i + 1) put: (spec at: 3) ].			contiguous _ contiguous + ((spec at: 2) - (spec at: 1)) + 1.		].	].! !!Interpreter class methodsFor: 'constants'!bytecodeTable	^ BytecodeTable! !!Interpreter class methodsFor: 'constants'!primitiveTable	^ PrimitiveTable! !!Interpreter class methodsFor: 'translation' stamp: 'jm 8/22/97 15:27'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'methodCache'		declareC: 'int methodCache[', (MethodCacheSize + 1) printString, ']'.	aCCodeGenerator var: 'localIP' declareC: 'char * localIP'.	aCCodeGenerator var: 'localSP' declareC: 'char * localSP'.	aCCodeGenerator var: 'semaphoresToSignal'		declareC: 'int semaphoresToSignal[', (SemaphoresToSignalSize + 1) printString, ']'.! !!Interpreter class methodsFor: 'translation'!patchInterp: fileName	"Interpreter patchInterp: 'Squeak VM PPC'"	"This will patch out the unneccesary range check (a compare	 and branch) in the inner interpreter dispatch loop."	"NOTE: You must edit in the Interpeter file name, and the	 number of instructions (delta) to count back to find the compare	 and branch that we want to get rid of."	| delta f code len remnant i |	delta _ 6.	f _ FileStream fileNamed: fileName.	f binary.	code _ Bitmap new: (len _ f size) // 4.	f nextInto: code.	remnant _ f next: len - (code size * 4).	i _ 0.	["Look for a BCTR instruction"	(i _ code indexOf: 16r4E800420 startingAt: i + 1 ifAbsent: [0]) > 0] whileTrue: [		"Look for a CMPLWI FF, 6 instrs back"	       ((code at: i - delta) bitAnd: 16rFFE0FFFF) = 16r280000FF ifTrue: [	       	"Copy dispatch instrs back over the compare"			SelectionMenu notify: 'Patching at ', i hex.			0 to: delta - 2 do: [ :j |				code at: (i - delta) + j put: (code at: (i - delta) + j + 2).			].		].	].	f position: 0; nextPutAll: code; nextPutAll: remnant.	f close.! !!Interpreter class methodsFor: 'translation' stamp: 'ikp 1/7/98 04:11'!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep]"	| cg |	BitBltSimulation initialize.	Interpreter initialize.	ObjectMemory initialize.	cg _ CCodeGenerator new initialize.	cg addClass: BitBltSimulation.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	BitBltSimulation declareCVarsIn: cg.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !InterpreterSimulator comment:'This class defines basic memory access and primitive simulation so that the Interpreter can run simulated in the Squeak environment.  It also defines a number of handy object viewing methods to facilitate pawing around in the object memory.To see the thing actually run, you could (after backing up this image and changes), execute	(InterpreterSimulator new openOn: Smalltalk imageName) testand be patient both to wait for things to happen, and to accept various things that may go wrong depending on how large or unusual your image may be.  We usually do this with a small and simple benchmark image.'!!InterpreterSimulator methodsFor: 'initialization'!close  "close any files that ST may have opened"	filesOpen do: [:f | f setToEnd; close]! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'di 12/30/97 09:24'!initialize	"Initialize the InterpreterSimulator when running the interpreter inside	Smalltalk. The primary responsibility of this method is to allocate	Smalltalk Arrays for variables that will be declared as statically-allocated	global arrays in the translated code."	"initialize class variables"	ObjectMemory initialize.	Interpreter initialize.	methodCache _ Array new: MethodCacheSize.	rootTable _ Array new: RootTableSize.	remapBuffer _ Array new: RemapBufferSize.	semaphoresToSignal _ Array new: SemaphoresToSignalSize.	"initialize InterpreterSimulator variables used for debugging"	byteCount _ 0.	sendCount _ 0.	traceOn _ true.	myBitBlt _ BitBltSimulator new setInterpreter: self.	displayForm _ nil.  "displayForm is created in response to primitiveBeDisplay"	filesOpen _ OrderedCollection new.! !!InterpreterSimulator methodsFor: 'initialization'!nextLongFrom: aStream	"Read a 32-bit quantity from the given (binary) stream."	| bytes |	bytes _ aStream nextInto: (ByteArray new: 4).	^ Integer		byte1: (bytes at: 4)		byte2: (bytes at: 3)		byte3: (bytes at: 2)		byte4: (bytes at: 1)! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'di 9/23/97 15:51'!nextLongFrom: aStream swap: swapFlag	swapFlag 		ifTrue: [^ self byteSwapped: (self nextLongFrom: aStream)]		ifFalse: [^ self nextLongFrom: aStream]! !!InterpreterSimulator methodsFor: 'initialization'!openOn: fileName	"(InterpreterSimulator new openOn: 'clonex.image') test"	self openOn: fileName extraMemory: 500000.! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'di 9/27/97 09:24'!openOn: fileName extraMemory: extraBytes	"InterpreterSimulator new openOn: 'clone.im' extraMemory: 100000"	| f version headerSize count oldBaseAddr bytesToShift swapBytes |	"open image file and read the header"	checkAssertions _ false.	f _ FileStream oldFileNamed: fileName.	imageName _ f fullName.	f binary; readOnly.	version _ self nextLongFrom: f.  "current version: 16r1966 (=6502)"	version = self imageFormatVersion		ifTrue: [swapBytes _ false]		ifFalse: [(version _ self byteSwapped: version) = self imageFormatVersion					ifTrue: [swapBytes _ true]					ifFalse: [self error: 'incomaptible image format']].	headerSize _ self nextLongFrom: f swap: swapBytes.	endOfMemory _ self nextLongFrom: f swap: swapBytes.  "first unused location in heap"	oldBaseAddr _ self nextLongFrom: f swap: swapBytes.  "object memory base address of image"	specialObjectsOop _ self nextLongFrom: f swap: swapBytes.	lastHash _ self nextLongFrom: f swap: swapBytes.  "Should be loaded from, and saved to the image header"	savedWindowSize _ self nextLongFrom: f swap: swapBytes.	lastHash = 0 ifTrue: [lastHash _ 999].	"allocate interpreter memory"	memoryLimit _ endOfMemory + extraBytes.	"read in the image in bulk, then swap the bytes if necessary"	f position: headerSize.	memory _ Bitmap new: memoryLimit // 4.	count _ f readInto: memory startingAt: 1 count: endOfMemory // 4.	count ~= (endOfMemory // 4) ifTrue: [self halt].	f close.	swapBytes ifTrue: [Utilities informUser: 'Swapping bytes of foreign image...'								during: [self reverseBytesInImage]].	self initialize.	bytesToShift _ 0 - oldBaseAddr.  "adjust pointers for zero base address"	endOfMemory _ endOfMemory.	Utilities informUser: 'Relocating object pointers...'				during: [self initializeInterpreter: bytesToShift].	checkAssertions _ false.! !!InterpreterSimulator methodsFor: 'initialization' stamp: 'di 10/2/97 00:32'!reverseBytesFrom: begin to: end	"Byte-swap the given range of memory (not inclusive!!)."	| wordAddr |	wordAddr _ begin.	memory swapBytesFrom: wordAddr // 4 + 1 to: end // 4! !!InterpreterSimulator methodsFor: 'initialization'!startOfMemory	"Return the start of object memory."	^ 0! !!InterpreterSimulator methodsFor: 'testing' stamp: 'di 9/28/97 03:02'!findNewMethodInClass: class"	| cName |	traceOn ifTrue:		[cName _ (self sizeBitsOf: class) = 16r20			ifTrue: ['class ' , (self nameOfClass: (self fetchPointer: 6 ofObject: class))]			ifFalse: [(self nameOfClass: class)].		self cr; print: cName , '>>' , (self stringOf: messageSelector)].""(self stringOf: messageSelector) = 'raisedToInteger:' ifTrue: [self halt]."	sendCount _ sendCount + 1.(false "sendCount > 1090" "and: [sendCount\\10 = 0]") ifTrue:		[Transcript print: sendCount; space.		self validate].	super findNewMethodInClass: class.! !!InterpreterSimulator methodsFor: 'testing' stamp: 'di 10/1/97 23:36'!objectBefore: addr	| oop prev |	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		prev _ oop.  "look here if debugging prev obj overlapping this one"		oop _ self objectAfter: oop.		oop >= addr ifTrue: [^ prev]	]! !!InterpreterSimulator methodsFor: 'testing'!profile: nBytecodes	"(InterpreterSimulator new openOn: 'clonex.image') profile: 60000"	Transcript clear.	byteCount _ 0.	MessageTally spyOn: [		self internalizeIPandSP.		[byteCount < nBytecodes] whileTrue: [			currentBytecode _ self fetchByte.			self dispatchOn: currentBytecode in: BytecodeTable.			byteCount _ byteCount + 1.		].		self externalizeIPandSP.	].! !!InterpreterSimulator methodsFor: 'testing'!profileSends: nBytecodes	"(InterpreterSimulator new openOn: 'clonex.image') profileSends: 5000"	Transcript clear.	byteCount _ 0.	MessageTally tallySendsTo: self inBlock: [		self internalizeIPandSP.		[byteCount < nBytecodes] whileTrue: [			currentBytecode _ self fetchByte.			self dispatchOn: currentBytecode in: BytecodeTable.			byteCount _ byteCount + 1.		].		self externalizeIPandSP.	] showTree: true.! !!InterpreterSimulator methodsFor: 'testing' stamp: 'jm 9/24/97 22:52'!stats	| oop fieldAddr fieldOop last ints ints100 ints1000 fields ints10 spl v intsM100 intsM1000 rel100 rel1000 relM100 relM1000 d |	Transcript show: 'Taking stats...'.	ints _ fields _ 0.	ints10 _ ints100 _ ints1000 _ intsM100 _ intsM1000 _ 0.	rel100 _ rel1000 _ relM100 _ relM1000 _ 0.	spl _ Bag new.	oop _ self firstObject.	[oop < endOfMemory] whileTrue:		[(self isFreeObject: oop) ifFalse:			[fieldAddr _ oop + (self lastPointerOf: oop).			[fieldAddr > oop] whileTrue:				[fieldOop _ self longAt: fieldAddr.				fields _ fields + 1.				(self isIntegerObject: fieldOop)					ifTrue: [v _ self integerValueOf: fieldOop.							ints _ ints + 1.							(v between: 0 and: 10) ifTrue: [ints10 _ ints10 + 1].							(v between: 0 and: 100) ifTrue: [ints100 _ ints100 + 1].							(v between: 0 and: 1000) ifTrue: [ints1000 _ ints1000 + 1].							(v between: -100 and: -1) ifTrue: [intsM100 _ intsM100 + 1].							(v between: -1000 and: -1) ifTrue: [intsM1000 _ intsM1000 + 1]]					ifFalse: [fieldOop = nilObj ifTrue: [spl add: fieldOop].							fieldOop = falseObj ifTrue: [spl add: fieldOop].							fieldOop = trueObj ifTrue: [spl add: fieldOop].							d _ fieldOop - oop.							(d between: 0 and: 100) ifTrue: [rel100 _ rel100 + 1].							(d between: 0 and: 1000) ifTrue: [rel1000 _ rel1000 + 1].							(d between: -100 and: -1) ifTrue: [relM100 _ relM100 + 1].							(d between: -1000 and: -1) ifTrue: [relM1000 _ relM1000 + 1]].				fieldAddr _ fieldAddr - 4]].		last _ oop.		oop _ self objectAfter: oop].	Transcript show: 'done.'; cr.	^ (Array with: fields with: ints with: ints10) ,		(Array with: ints100 with: ints1000 with: intsM100 with: intsM1000) ,		(Array with: rel100 with: rel1000 with: relM100 with: relM1000) ,		(Array with: spl sortedElements)! !!InterpreterSimulator methodsFor: 'testing'!test	Transcript clear.	byteCount _ 0.	self internalizeIPandSP.	[true] whileTrue: [		currentBytecode _ self fetchByte.		self dispatchOn: currentBytecode in: BytecodeTable.		byteCount _ byteCount + 1.	].	self externalizeIPandSP.! !!InterpreterSimulator methodsFor: 'testing'!testBecome	"Become some young things.  AA testBecome    "	| array list1 list2 p1 p2 p3 p4 |	array _ self splObj: ClassArray.	list1 _ self instantiateClass: array indexableSize: 2.	list2 _ self instantiateClass: array indexableSize: 2.	p1 _ self instantiateClass: (self splObj: ClassPoint) indexableSize: 0.	self push: p1.	self storePointer: 0 ofObject: list1 withValue: p1.	p2 _ self instantiateClass: (self splObj: ClassPoint) indexableSize: 0.	self push: p2.	self storePointer: 1 ofObject: list1 withValue: p2.	p3 _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	self push: p3.	self storePointer: 0 ofObject: list2 withValue: p3.	p4 _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	self push: p4.	self storePointer: 1 ofObject: list2 withValue: p4.	(self become: list1 with: list2) ifFalse: [self error: 'failed'].	self popStack = p2 ifFalse: [self halt].	self popStack = p1 ifFalse: [self halt].	self popStack = p4 ifFalse: [self halt].	self popStack = p3 ifFalse: [self halt].	(self fetchPointer: 0 ofObject: list1) = p3 ifFalse: [self halt].	(self fetchPointer: 1 ofObject: list1) = p4 ifFalse: [self halt].	(self fetchPointer: 0 ofObject: list2) = p1 ifFalse: [self halt].	(self fetchPointer: 1 ofObject: list2) = p2 ifFalse: [self halt].! !!InterpreterSimulator methodsFor: 'testing' stamp: 'jm 9/24/97 22:52'!validate	| oop prev |	Transcript show: 'Validating...'.	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		self validate: oop.		prev _ oop.  "look here if debugging prev obj overlapping this one"		oop _ self objectAfter: oop.	].	Transcript show: 'done.'; cr! !!InterpreterSimulator methodsFor: 'testing' stamp: 'jm 9/24/97 22:52'!validate: oop	| header type cc sz fmt nextChunk | 	header _ self longAt: oop.	type _ header bitAnd: 3.	type = 2 ifFalse: [type = (self rightType: header) ifFalse: [self halt]].	sz _ (header >> 2) bitAnd: 16r3F.	(self isFreeObject: oop)		ifTrue: [ nextChunk _ oop + (self sizeOfFree: oop) ]		ifFalse: [  nextChunk _ oop + (self sizeBitsOf: oop) ].	nextChunk > endOfMemory		ifTrue: [oop = endOfMemory ifFalse: [self halt]].	(self headerType: nextChunk) = 0 ifTrue: [		(self headerType: (nextChunk + 8)) = 0 ifFalse: [self halt]].	(self headerType: nextChunk) = 1 ifTrue: [		(self headerType: (nextChunk + 4)) = 1 ifFalse: [self halt]].	type = 2 ifTrue:		["free block" ^ self].	fmt _ (header >> 8) bitAnd: 16rF.	cc _ (header >> 12) bitAnd: 31.	cc > 15 ifTrue: [self halt].	type = 0 ifTrue:		["three-word header"		((self longAt: oop-4) bitAnd: 3) = type ifFalse: [self halt].		((self longAt: oop-8) bitAnd: 3) = type ifFalse: [self halt].		((self longAt: oop-4) = type) ifTrue: [self halt].	"Class word is 0"		sz = 0 ifFalse: [self halt]].	type = 1 ifTrue:		["two-word header"		((self longAt: oop-4) bitAnd: 3) = type ifFalse: [self halt].		cc > 0 ifTrue: [sz = 1 ifFalse: [self halt]].		sz = 0 ifTrue: [self halt]].	type = 3 ifTrue:		["one-word header"		cc = 0 ifTrue: [self halt]].	fmt = 4 ifTrue: [self halt].	fmt = 5 ifTrue: [self halt].	fmt = 7 ifTrue: [self halt].	fmt >= 12 ifTrue:		["CompiledMethod -- check for integer header"		(self isIntegerObject: (self longAt: oop + 4)) ifFalse: [self halt]].! !!InterpreterSimulator methodsFor: 'testing'!validateActiveContext	self validateOopsIn: activeContext.	"debug -- test if messed up"! !!InterpreterSimulator methodsFor: 'testing'!validateOopsIn: object	| fieldPtr limit former header | 	"for each oop in me see if it is legal"	fieldPtr _ object + BaseHeaderSize.	"first field"	limit _ object + (self lastPointerOf: object).	"a good field"	[fieldPtr > limit] whileFalse: [		former _ self longAt: fieldPtr.		self validOop: former.		fieldPtr _ fieldPtr + 4].	"class"	header _ self baseHeader: object.	(header bitAnd: 16r1F000 "compact class bits") = 0 ifTrue: [			former _ (self classHeader: object) bitAnd: 16rFFFFFFFC.		self validOop: former].! !!InterpreterSimulator methodsFor: 'testing'!validOop: oop	"halt if invalid active object"	(oop bitAnd: 1) = 1 ifTrue: [^ self].	(oop bitAnd: 3) = 0 ifFalse: [self halt].	oop >= endOfMemory ifTrue: [self halt].	"could test if within the first large freeblock"	(self longAt: oop) = 4 ifTrue: [self halt].	(self headerType: oop) = 2 ifTrue: [self halt].	"free object"! !!InterpreterSimulator methodsFor: 'debug printing'!cr	traceOn ifTrue: [ Transcript cr; endEntry ].! !!InterpreterSimulator methodsFor: 'debug printing'!print: s	traceOn ifTrue: [ Transcript show: s ]! !!InterpreterSimulator methodsFor: 'debug printing'!printChar: aByte	traceOn ifTrue: [ Transcript nextPut: aByte asCharacter ].! !!InterpreterSimulator methodsFor: 'debug printing'!printNum: anInteger	traceOn ifTrue: [ Transcript show: anInteger printString ].! !!InterpreterSimulator methodsFor: 'debug support'!charsOfLong: long	^ (4 to: 1 by: -1) collect:		[:i | ((long digitAt: i) between: 14 and: 126)					ifTrue: [(long digitAt: i) asCharacter]					ifFalse: [$?]]! !!InterpreterSimulator methodsFor: 'debug support'!classAndSelectorOfMethod: meth forReceiver: rcvr	| mClass dict length methodArray |	mClass _ self fetchClassOf: rcvr.	[dict _ self fetchPointer: MessageDictionaryIndex ofObject: mClass.	length _ self fetchWordLengthOf: dict.	methodArray _ self fetchPointer: MethodArrayIndex ofObject: dict.	0 to: length-SelectorStart-1 do: 		[:index | 		meth = (self fetchPointer: index ofObject: methodArray) 			ifTrue: [^ Array				with: mClass				with: (self fetchPointer: index + SelectorStart ofObject: dict)]].	mClass _ self fetchPointer: SuperclassIndex ofObject: mClass.	mClass = nilObj]		whileFalse: [].	^ Array		with: (self fetchClassOf: rcvr)		with: (self splObj: SelectorDoesNotUnderstand)! !!InterpreterSimulator methodsFor: 'debug support'!compactClassAt: ccIndex	"Index must be between 1 and compactClassArray size. (A zero compact class index in the base header indicate that the class is in the class header word.)"	| classArray |	classArray _ self fetchPointer: CompactClasses ofObject: specialObjectsOop.	^ self fetchPointer: (ccIndex - 1) ofObject: classArray! !!InterpreterSimulator methodsFor: 'debug support'!dumpHeader: hdr	| cc |	^ String streamContents:		[:strm |		strm nextPutAll: '<cc=', (cc_ (hdr >> 12) bitAnd: 16r1F) hex.			cc > 0 ifTrue:				[strm nextPutAll: ':' , (self nameOfClass: (self compactClassAt: cc))].			strm nextPutAll: '>'.		strm nextPutAll: '<ft=', ((hdr bitShift: -8) bitAnd: 16rF) hex , '>'.		strm nextPutAll: '<sz=', (hdr bitAnd: 16rFC) hex , '>'.		strm nextPutAll: '<hdr=', (#(big class gcMark short) at: (hdr bitAnd: 3) +1) , '>'.		]! !!InterpreterSimulator methodsFor: 'debug support'!dumpMethodHeader: hdr	^ String streamContents:		[:strm |		strm nextPutAll: '<nArgs=', ((hdr >> 25) bitAnd: 16r1F) printString , '>'.		strm nextPutAll: '<nTemps=', ((hdr >> 19) bitAnd: 16r3F) printString , '>'.		strm nextPutAll: '<lgCtxt=', ((hdr >> 18) bitAnd: 16r1) printString , '>'.		strm nextPutAll: '<nLits=', ((hdr >> 10) bitAnd: 16rFF) printString , '>'.		strm nextPutAll: '<prim=', ((hdr >> 1) bitAnd: 16r1FF) printString , '>'.		]! !!InterpreterSimulator methodsFor: 'debug support'!headerStart: oop	^ (self extraHeaderBytes: oop) negated! !!InterpreterSimulator methodsFor: 'debug support'!hexDump100: oop	| byteSize val |	^ String streamContents:		[:strm |		byteSize _ 256.		(self headerStart: oop) to: byteSize by: 4 do:			[:a | val _ self longAt: oop+a.			strm cr; nextPutAll: (oop+a) hex8; space; space; 				nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8;				space; space.			strm nextPutAll: (self charsOfLong: val).			strm space; space; nextPutAll: (oop+a) printString]]! !!InterpreterSimulator methodsFor: 'debug support'!hexDump: oop	| byteSize val |	(self isIntegerObject: oop) ifTrue: [^ self shortPrint: oop].	^ String streamContents:		[:strm |		byteSize _ 256 min: (self sizeBitsOf: oop)-4.		(self headerStart: oop) to: byteSize by: 4 do:			[:a | val _ self longAt: oop+a.			strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8;				space; space.			a=0				ifTrue: [strm nextPutAll: (self dumpHeader: val)]				ifFalse: [strm nextPutAll: (self charsOfLong: val)]]]! !!InterpreterSimulator methodsFor: 'debug support'!longPrint: oop	| lastPtr val lastLong hdrType prevVal |	(self isIntegerObject: oop) ifTrue: [^ self shortPrint: oop].	^ String streamContents:		[:strm |		lastPtr _ 256 min: (self lastPointerOf: oop).		hdrType _ self headerType: oop.		hdrType = 2 ifTrue: [lastPtr _ 0].		prevVal _ 0.		(self headerStart: oop) to: lastPtr by: 4 do:			[:a | val _ self longAt: oop+a.			(a > 0 and: [(val = prevVal) & (a ~= lastPtr)])			ifTrue:			[prevVal = (self longAt: oop+a-8) ifFalse: [strm cr; nextPutAll: '        ...etc...']]			ifFalse:			[strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8; space; space.			a=-8 ifTrue: [strm nextPutAll: 'size = ' , (val - hdrType) hex].			a=-4 ifTrue: [strm nextPutAll: '<' , (self nameOfClass: (val - hdrType)) , '>'].			a=0 ifTrue: [strm cr; tab; nextPutAll: (self dumpHeader: val)].			a>0 ifTrue: [strm nextPutAll: (self shortPrint: val)].			a=4 ifTrue: [(self fetchClassOf: oop) = (self splObj: ClassCompiledMethod) ifTrue:							[strm cr; tab; nextPutAll: (self dumpMethodHeader: val)]]].			prevVal _ val].		lastLong _ 256 min: (self sizeBitsOf: oop) - 4.		hdrType = 2			ifTrue: ["free" strm cr; nextPutAll: (oop+(self longAt: oop)-2) hex;				space; space; nextPutAll: (oop+(self longAt: oop)-2) printString]			ifFalse: [lastPtr+4 to: lastLong by: 4 do:				[:a | val _ self longAt: oop+a.				strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 					space; space; space.				strm nextPutAll: val hex8; space; space;						nextPutAll: (self charsOfLong: val)]].	]! !!InterpreterSimulator methodsFor: 'debug support'!nameOfClass: classOop	(self sizeBitsOf: classOop) = 16r20 ifTrue:		[^ (self nameOfClass:				(self fetchPointer: 6 "thisClass" ofObject: classOop)) , ' class'].	^ self stringOf: (self fetchPointer: 6 "name" ofObject: classOop)! !!InterpreterSimulator methodsFor: 'debug support'!printStack	| ctxt classAndSel home |	ctxt _ activeContext.	^ String streamContents:		[:strm |			[home _ (self fetchClassOf: ctxt) = (self splObj: ClassBlockContext)				ifTrue: [self fetchPointer: HomeIndex ofObject: ctxt]				ifFalse: [ctxt].			classAndSel _ self				classAndSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)				forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).			strm cr; nextPutAll: ctxt hex8.			ctxt = home ifFalse: [strm nextPutAll: ' [] in'].			strm space; nextPutAll: (self nameOfClass: classAndSel first).			strm nextPutAll: '>>'; nextPutAll: (self shortPrint: classAndSel last).			(ctxt _ (self fetchPointer: SenderIndex ofObject: ctxt)) = nilObj]				whileFalse: [].		]! !!InterpreterSimulator methodsFor: 'debug support'!shortPrint: oop	| name classOop |	(self isIntegerObject: oop) ifTrue: [^ '=' , (self integerValueOf: oop) printString , ' (' , (self integerValueOf: oop) hex , ')'].	classOop _ self fetchClassOf: oop.	(self sizeBitsOf: classOop) =16r20 ifTrue: [^ 'class ' , (self nameOfClass: oop)].	name _ self nameOfClass: classOop.	name size = 0 ifTrue: [name _ '??'].	name = 'String' ifTrue: [^ (self stringOf: oop) printString].	name = 'Symbol' ifTrue: [^ '#' , (self stringOf: oop)].	name = 'Character' ifTrue: [^ '=' ,			(Character value: (self integerValueOf: (self fetchPointer: 0 ofObject: oop))) printString].	name = 'UndefinedObject' ifTrue: [^ 'nil'].	name = 'False' ifTrue: [^ 'false'].	name = 'True' ifTrue: [^ 'true'].	name = 'Float' ifTrue: [^ '=' , (self floatValueOf: oop) printString].	name = 'Association' ifTrue: [^ '(' ,				(self shortPrint: (self longAt: oop + BaseHeaderSize)) ,				' -> ' ,				(self longAt: oop + BaseHeaderSize + 4) hex8 , ')'].	('AEIOU' includes: name first)		ifTrue: [^ 'an ' , name]		ifFalse: [^ 'a ' , name]! !!InterpreterSimulator methodsFor: 'debug support'!stringOf: oop	| size long nLongs chars |	^ String streamContents:		[:strm |		size _ 100 min: (self stSizeOf: oop).		nLongs _ size-1//4+1.		1 to: nLongs do:			[:i | long _ self longAt: oop + BaseHeaderSize + (i-1*4).			chars _ self charsOfLong: long.			strm nextPutAll: (i=nLongs							ifTrue: [chars copyFrom: 1 to: size-1\\4+1]							ifFalse: [chars])]]! !!InterpreterSimulator methodsFor: 'interpreter shell'!dispatchOn: anInteger in: selectorArray	"Simulate a case statement via selector table lookup.	The given integer must be between 0 and selectorArray size-1, inclusive.	For speed, no range test is done, since it is done by the at: operation."	"assert: (anInteger >= 0) | (anInteger < selectorArray size)""Transcript cr; show: anInteger hex , '  ' , (selectorArray at: (anInteger + 1)).Sensor waitButton.Sensor yellowButtonPressed ifTrue: [self halt]."	self perform: (selectorArray at: (anInteger + 1)).! !!InterpreterSimulator methodsFor: 'interpreter shell'!fetchByte	^ self byteAt: (localIP _ localIP + 1).! !!InterpreterSimulator methodsFor: 'interpreter shell'!fetchIntegerOrTruncFloat: fieldIndex ofObject: objectPointer	"Overridden to support the simulator."	| intOrFloat |	intOrFloat _ self fetchPointer: fieldIndex ofObject: objectPointer.	(self isIntegerObject: intOrFloat) ifTrue: [^ self integerValueOf: intOrFloat].	self assertClassOf: intOrFloat is: (self splObj: ClassFloat).	successFlag ifTrue: [^ (self floatValueOf: intOrFloat) truncated].! !!InterpreterSimulator methodsFor: 'interpreter shell'!isIntegerValue: valueWord 	^ valueWord >= 16r-40000000 and: [valueWord <= 16r3FFFFFFF]! !!InterpreterSimulator methodsFor: 'I/O primitives'!ioProcessEvents! !!InterpreterSimulator methodsFor: 'I/O primitives'!primitiveBeCursor	"Take note of the current cursor"	| cursorObj bitsObj offsetObj ourCursor |	cursorObj _ self stackTop.	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 4]).	successFlag ifTrue:		[bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj.		ourCursor _ Cursor			extent: (self fetchInteger: 1 ofObject: cursorObj)@(self fetchInteger: 2 ofObject: cursorObj)			fromArray: ((1 to: 16) collect: [:i |					((self fetchWord: i-1 ofObject: bitsObj) >> 16) bitAnd: 16rFFFF])			offset: (self fetchInteger: 0 ofObject: offsetObj)@(self fetchInteger: 1 ofObject: offsetObj)].	successFlag		ifTrue: [ourCursor show]		ifFalse: [self primitiveFail].! !!InterpreterSimulator methodsFor: 'I/O primitives'!primitiveBeDisplay	"Extended to create a scratch Form for use by showDisplayBits."	| rcvr destWidth destHeight destDepth |	rcvr _ self stackTop.	self success: ((self isPointers: rcvr) and: [(self lengthOf: rcvr) >= 4]).	successFlag ifTrue: [		destWidth _ self fetchInteger: 1 ofObject: rcvr.		destHeight _ self fetchInteger: 2 ofObject: rcvr.		destDepth _ self fetchInteger: 3 ofObject: rcvr.	].	successFlag ifTrue: [		"create a scratch form the same size as Smalltalk displayObj"		displayForm _ Form extent: destWidth @ destHeight							depth: destDepth.	].	super primitiveBeDisplay.! !!InterpreterSimulator methodsFor: 'I/O primitives' stamp: 'di 9/23/97 12:54'!primitiveKbdNext	self pop: 1.	Sensor keyboardPressed		ifTrue: [self pushInteger: Sensor primKbdNext]		ifFalse: [self push: nilObj]! !!InterpreterSimulator methodsFor: 'I/O primitives' stamp: 'di 9/23/97 12:54'!primitiveKbdPeek	self pop: 1.	Sensor keyboardPressed		ifTrue: [self pushInteger: Sensor primKbdPeek]		ifFalse: [self push: nilObj]! !!InterpreterSimulator methodsFor: 'I/O primitives' stamp: 'di 9/23/97 12:54'!primitiveMouseButtons	| buttons |	self pop: 1.	buttons _ Sensor primMouseButtons.	self pushInteger: buttons! !!InterpreterSimulator methodsFor: 'I/O primitives'!primitiveMousePoint	| relPt |	self pop: 1.	displayForm == nil		ifTrue: [self push: (self makePointwithxValue: 99 yValue: 66)]		ifFalse: [relPt _ Sensor cursorPoint - (Display extent - displayForm extent - (10@10)).				self push: (self makePointwithxValue: relPt x yValue: relPt y)]! !!InterpreterSimulator methodsFor: 'I/O primitives'!primitiveScreenSize  "Dummied for now"	self pop: 1.	self push: (self makePointwithxValue: 640 yValue: 480).! !!InterpreterSimulator methodsFor: 'I/O primitives' stamp: 'di 9/23/97 15:26'!showDisplayBits	| displayObj destBits raster destDepth pixPerWord simDisp realDisp top bottom rect |	displayObj _ self splObj: TheDisplay.	self targetForm = displayObj ifFalse: [^ self].	destBits _ self fetchPointer: 0 ofObject: displayObj.	destDepth _ self fetchInteger: 3 ofObject: displayObj.	pixPerWord _ 32 // destDepth.	raster _ displayForm width + (pixPerWord - 1) // pixPerWord.	simDisp _ Form new hackBits: memory.	realDisp _ Form new hackBits: displayForm bits.	top _ myBitBlt affectedTop.	bottom _ myBitBlt affectedBottom.	realDisp		copy: (0 @ (top * raster) extent: 4 @ (bottom - top * raster))		from: 0 @ (destBits + 4 // 4 + (top * raster))		in: simDisp		rule: Form over.	rect _ 0 @ top corner: displayForm width @ bottom.	Display		copy: (rect translateBy: self displayLocation)		from: rect topLeft		in: displayForm		rule: Form over! !!InterpreterSimulator methodsFor: 'I/O primitives support'!copyBits	^ myBitBlt copyBits! !!InterpreterSimulator methodsFor: 'I/O primitives support'!displayLocation	^ Display extent - displayForm extent - (10@10)! !!InterpreterSimulator methodsFor: 'I/O primitives support'!drawLoopX: xDelta Y: yDelta	^ myBitBlt drawLoopX: xDelta Y: yDelta! !!InterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'di 12/29/97 20:09'!initBBOpTable	^ myBitBlt initBBOpTable! !!InterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'jm 9/24/97 22:52'!ioMicroMSecs	"Return the value of the microsecond clock (dummied here)."	^ 0! !!InterpreterSimulator methodsFor: 'I/O primitives support'!ioMSecs	"Return the value of the millisecond clock."	^ Time millisecondClockValue! !!InterpreterSimulator methodsFor: 'I/O primitives support'!ioProcessEventsEveryMSecs: mSecs	"Noop during simulation."! !!InterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'jm 9/24/97 22:52'!ioScreenSize	"Return the screen extent packed into 32 bits."	^ (displayForm width << 16) + displayForm height! !!InterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'jm 9/24/97 22:52'!ioSeconds	"Return the value of the second clock."	^ Time primSecondsClock! !!InterpreterSimulator methodsFor: 'I/O primitives support'!loadBitBltFrom: bbObj	^ myBitBlt loadBitBltFrom: bbObj! !!InterpreterSimulator methodsFor: 'I/O primitives support'!loadScannerFrom: bbObj	start: start stop: stop string: string rightX: rightX	stopArray: stopArray displayFlag: displayFlag	^ myBitBlt loadScannerFrom: bbObj		start: start stop: stop string: string rightX: rightX		stopArray: stopArray displayFlag: displayFlag! !!InterpreterSimulator methodsFor: 'I/O primitives support' stamp: 'jm 9/24/97 22:52'!primitiveRelinquishProcessor	"No-op in simulator"	^ self! !!InterpreterSimulator methodsFor: 'I/O primitives support'!scanCharacters	^ myBitBlt scanCharacters! !!InterpreterSimulator methodsFor: 'I/O primitives support'!stopReason	^ myBitBlt stopReason! !!InterpreterSimulator methodsFor: 'I/O primitives support'!targetForm	^ myBitBlt targetForm! !!InterpreterSimulator methodsFor: 'file primitives'!asciiDirectoryDelimiter	^ FileDirectory pathNameDelimiter asciiValue! !!InterpreterSimulator methodsFor: 'file primitives'!fileValueOf: integerPointer	"Convert the (integer) fileID to the actual fileStream it uses"	self success: (self isIntegerObject: integerPointer).	successFlag		ifTrue: [^ filesOpen at: (self integerValueOf: integerPointer)]		ifFalse: [^ nil]! !!InterpreterSimulator methodsFor: 'file primitives' stamp: 'jm 12/5/97 15:08'!primitiveFileDelete	| namePointer |	namePointer _ self stackTop.	self success: (self isBytes: namePointer).	self success: (StandardFileStream isAFileNamed: (self stringOf: namePointer)).	successFlag ifTrue: [		FileDirectory removeKey: (self stringOf: namePointer) ifAbsent: []].	successFlag ifTrue: [		self pop: 1].  "pop fileName; leave rcvr on stack"! !!InterpreterSimulator methodsFor: 'file primitives' stamp: 'jm 12/5/97 15:09'!primitiveFileOpen	| namePointer writeFlag fileName |	writeFlag _ self booleanValueOf: self stackTop.	namePointer _ self stackValue: 1.	self success: (self isBytes: namePointer).	successFlag ifTrue:		[fileName _ self stringOf: namePointer.		filesOpen addLast: (writeFlag			ifTrue: [(FileStream fileNamed: fileName) binary]			ifFalse: [(StandardFileStream isAFileNamed: fileName)				ifTrue: [(FileStream oldFileNamed: fileName) readOnly; binary]				ifFalse: [^ self primitiveFail]]).		self pop: 3.  "rcvr, name, write"		self pushInteger: filesOpen size]! !!InterpreterSimulator methodsFor: 'file primitives' stamp: 'jm 12/5/97 15:10'!primitiveFileRename	| oldNamePointer newNamePointer f |	oldNamePointer _ self stackTop.	newNamePointer _ self stackValue: 1.	self success: (self isBytes: oldNamePointer).	self success: (self isBytes: newNamePointer).	self success: (StandardFileStream isAFileNamed: (self stringOf: oldNamePointer)).	self success: (StandardFileStream isAFileNamed: (self stringOf: newNamePointer)) not.	successFlag ifTrue: [		f _ FileStream oldFileNamed: (self stringOf: oldNamePointer).		f rename: (self stringOf: newNamePointer).		f close.	].	successFlag ifTrue: [		self pop: 2.  "oldName, newName; leave rcvr on stack"	].! !!InterpreterSimulator methodsFor: 'file primitives'!primitiveImageName	"Note: For now, this only implements getting, not setting, the image file name."	| result imageNameSize |	self pop: 1.	imageNameSize _ imageName size.	result _ self instantiateClass: (self splObj: ClassString)				   indexableSize: imageNameSize.	1 to: imageNameSize do:		[:i | self storeByte: i-1 ofObject: result			withValue: (imageName at: i) asciiValue].	self push: result.! !!InterpreterSimulator methodsFor: 'file primitives'!sqFile: file Read: count Into: byteArrayIndex At: startIndex	startIndex to: (startIndex + count - 1) do: [ :i |		file atEnd ifTrue: [ ^ i - startIndex ].		self byteAt: byteArrayIndex + i put: file next.	].	^ count! !!InterpreterSimulator methodsFor: 'file primitives'!sqFile: file SetPosition: newPosition	file position: newPosition.! !!InterpreterSimulator methodsFor: 'file primitives'!sqFile: file Write: count From: byteArrayIndex At: startIndex	startIndex to: (startIndex + count - 1) do: [ :i |		file nextPut: (self byteAt: byteArrayIndex + i).	].	^ count! !!InterpreterSimulator methodsFor: 'file primitives'!sqFileAtEnd: file	^ file atEnd! !!InterpreterSimulator methodsFor: 'file primitives'!sqFileClose: file	file close.! !!InterpreterSimulator methodsFor: 'file primitives'!sqFileGetPosition: file	^ file position! !!InterpreterSimulator methodsFor: 'file primitives'!sqFileSize: file	^ file size! !!InterpreterSimulator methodsFor: 'file primitives'!vmPathGet: stringBase Length: stringSize	| pathName stringOop |	pathName _ Smalltalk vmPath.	stringOop _ stringBase - BaseHeaderSize. "Due to C call in Interp"	1 to: stringSize do:		[:i | self storeByte: i-1 ofObject: stringOop			withValue: (pathName at: i) asciiValue].! !!InterpreterSimulator methodsFor: 'file primitives'!vmPathSize	^ Smalltalk vmPath size! !!InterpreterSimulator methodsFor: 'float primitives'!floatObjectOf: float	| result sign exponent mantissa mantSize long0 long1 |true ifTrue: [	"No conversion needed in Apple ST"	long0 _ float at: 1.	long1 _ float at: 2.] ifFalse: ["Following code useful when porting to different formats"	((float at: 1) = 0 and: [(float at: 2) = 0])		ifTrue: [long0 _ 0. long1 _ 0]		ifFalse: 	["Read from the PPS 32-bit format"	sign _ ((float at: 1) bitAnd: 16r8000) bitShift: -15.				"1-bit sign"	exponent _ (((float at: 1) bitShift: -7) bitAnd: 16rFF) - 16r80. 		"8-bit expt"	mantissa _ (((float at: 1) bitAnd: 16r7F) bitShift: 16) + (float at: 2).	"23 bit mantissa"	mantSize _ 23.	"Convert to first 32 bits of 64-bit IEEE format"	long0 _ (sign bitShift: 31)										"1-bit sign"			+ (exponent + 16r400 bitShift: 20)						"11-bit expt"			+ ((mantissa bitShift: 20 - mantSize) bitAnd: 16rFFFFF).	"20 bit mantissa"	]. ]. "end of porting code"	result _ self instantiateClass: (self splObj: ClassFloat) indexableSize: 2.	self storeWord: 0 ofObject: result withValue: long0.	self storeWord: 1 ofObject: result withValue: long1.	^ result! !!InterpreterSimulator methodsFor: 'float primitives'!floatValueOf: objectPointer	| float len long0 long1 sign exponent mantissa mantSize |	(self isIntegerObject: objectPointer)		ifTrue: [^ (self integerValueOf: objectPointer) asFloat].	(self fetchClassOf: objectPointer) = (self splObj: ClassFloat)		ifFalse: [self success: false.  ^0.0].	len _ self fetchWordLengthOf: objectPointer.	(len between: 2 and: 3)		ifFalse: [self success: false.  ^0.0].	"FIRST convert image formats to sign/exponent/mantissa"	len = 2 ifTrue:  		["Normal 64-bit IEEE format"		long0 _ self fetchWord: 0 ofObject: objectPointer.		long1 _ self fetchWord: 1 ofObject: objectPointer.true ifTrue: [float _ Float new: 2.  "No conversion needed for AST"			float at: 1 put: long0.			float at: 2 put: long1.			^ float].		long0 = 0 ifTrue: [^ 0.0].		sign _ (long0 bitAnd: 16r80000000) bitShift: -31.				"1-bit sign"		exponent _ ((long0 bitShift: -20) bitAnd: 16r7FF) - 16r400.		"11-bit exponent"		mantissa _ ((long0 bitAnd: 16rFFFFF) bitShift: 32) + long1.		"52-bit mantissa"		mantSize _ 52]		ifFalse:  		["Weird 80-bit Apple format -- will go away soon"		long0 _ self fetchWord: 0 ofObject: objectPointer.		long1 _ self fetchWord: 1 ofObject: objectPointer.		long0 = 0 ifTrue: [^ 0.0].		sign _ (long0 bitAnd: 16r80000000) bitShift: -31.				"1-bit sign"		exponent _ ((long0 bitShift: -16) bitAnd: 16r7FFF) - 16r4000. 	"15-bit exponent"		"Note: drop the (redundant) high bit (16r8000) of mantissa"		mantissa _ ((long0 bitAnd: 16r7FFF) bitShift: 32) + long1.		"47-bit mantissa"		mantSize _ 47].	"THEN convert sign/exponent/mantissa to host format"	float _ Float new: 2.  "PPSST FP uses 2 16-bit words"	float at: 1 put: (sign bitShift: 15)							"1-bit sign"				+ (exponent + 16r80 bitShift: 7)				"8-bit expt"				+ ((mantissa bitShift: 7 - mantSize) bitAnd: 16r7F).	"7 bits of mantissa"	float at: 2 put: ((mantissa bitShift: 16 - (mantSize - 7)) bitAnd: 16rFFFF).  "16 more bits of mantissa"	^ float! !!InterpreterSimulator methodsFor: 'float primitives'!popFloat	^ self floatValueOf: (self popStack)! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'jm 9/24/97 22:52'!popFloatOnly	| number |	(self isIntegerObject: (number _ self popStack)) ifTrue: [		self success: false.		^0.0.	].	^ self floatValueOf: number! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveArctan	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr arcTan]		ifFalse: [self unPop: 1].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveAsFloat	"Use host Smalltalk's native function."	| arg |	arg _ self popInteger.	successFlag		ifTrue: [self pushFloat: arg asFloat]		ifFalse: [self unPop: 1].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveExp	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr exp]		ifFalse: [self unPop: 1].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveExponent	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushInteger: rcvr exponent]		ifFalse: [self unPop: 1].! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'jm 9/24/97 22:52'!primitiveFloatAdd	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloatOnly.	rcvr _ self popFloatOnly.	successFlag		ifTrue: [self pushFloat: rcvr + arg]		ifFalse: [self unPop: 2].! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'jm 9/24/97 22:52'!primitiveFloatDivide	"Note: This method overridden here because the translator (intentionally) doesn't translate the / operator (since the semantics of C / are the semantics of Smalltalk //). This allows the version of this method to be translated to express division as //, which translates to the float division operator /."	| rcvr arg |	arg _ self popFloatOnly.	rcvr _ self popFloatOnly.	successFlag ifTrue: [self success: arg ~= 0.0].	successFlag		ifTrue: [self pushFloat: rcvr / arg]		ifFalse: [self unPop: 2].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveFloatEqual	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr = arg]		ifFalse: [self unPop: 2].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveFloatGreaterOrEqual	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr >= arg]		ifFalse: [self unPop: 2].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveFloatGreaterThan	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr > arg]		ifFalse: [self unPop: 2].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveFloatLessOrEqual	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr <= arg]		ifFalse: [self unPop: 2].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveFloatLessThan	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr < arg]		ifFalse: [self unPop: 2].! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'jm 9/24/97 22:52'!primitiveFloatMultiply	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloatOnly.	rcvr _ self popFloatOnly.	successFlag		ifTrue: [self pushFloat: rcvr * arg]		ifFalse: [self unPop: 2].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveFloatNotEqual	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr ~= arg]		ifFalse: [self unPop: 2].! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'jm 9/24/97 22:52'!primitiveFloatSubtract	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloatOnly.	rcvr _ self popFloatOnly.	successFlag		ifTrue: [self pushFloat: rcvr - arg]		ifFalse: [self unPop: 2].! !!InterpreterSimulator methodsFor: 'float primitives' stamp: 'jm 9/24/97 22:52'!primitiveFractionalPart	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloatOnly.	successFlag		ifTrue: [self pushFloat: rcvr fractionPart]		ifFalse: [self unPop: 1].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveLogN	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr ln]		ifFalse: [self unPop: 1].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveSine	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr sin]		ifFalse: [self unPop: 1].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveSquareRoot	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr sqrt]		ifFalse: [self unPop: 1].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveTimesTwoPower	"Use Smalltalk's native function (tho could just fail)"	| rcvr arg |	arg _ self popInteger.	rcvr _ self popFloat.	successFlag		ifTrue: [ self pushFloat: (rcvr timesTwoPower: arg) ]		ifFalse: [ self unPop: 2 ].! !!InterpreterSimulator methodsFor: 'float primitives'!primitiveTruncated	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushInteger: rcvr truncated]		ifFalse: [self unPop: 1].! !!InterpreterSimulator methodsFor: 'float primitives'!pushFloat: f	self push: (self floatObjectOf: f).! !!InterpreterSimulator methodsFor: 'memory access'!byteAt: byteAddress	| lowBits |	lowBits _ byteAddress bitAnd: 3.	^((self longAt: byteAddress - lowBits)		bitShift: (lowBits - 3) * 8)		bitAnd: 16rFF! !!InterpreterSimulator methodsFor: 'memory access'!byteAt: byteAddress put: byte	| longWord shift lowBits |	lowBits _ byteAddress bitAnd: 3.	longWord _ self longAt: byteAddress - lowBits.	shift _ (3 - lowBits) * 8.	longWord _ longWord - (longWord bitAnd: (16rFF bitShift: shift)) + (byte bitShift: shift).	self longAt: byteAddress put: longWord! !!InterpreterSimulator methodsFor: 'memory access'!longAt: byteAddress	"Note: Adjusted for Smalltalk's 1-based array indexing."	^memory at: (byteAddress // 4) + 1! !!InterpreterSimulator methodsFor: 'memory access'!longAt: byteAddress put: a32BitValue	"Note: Adjusted for Smalltalk's 1-based array indexing."	^memory at: (byteAddress // 4) + 1 put: a32BitValue! !!InterpreterSimulator methodsFor: 'arithmetic'!bytecodePrimGreaterOrEqual	"Must be overridden from Interpreter because simulator doesn't have		32-bit signed ints to work with"	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [ ^ self booleanCheat:			(self integerValueOf: rcvr) >= (self integerValueOf: arg)].	^ super bytecodePrimGreaterOrEqual! !!InterpreterSimulator methodsFor: 'arithmetic'!bytecodePrimGreaterThan	"Must be overridden from Interpreter because simulator doesn't have		32-bit signed ints to work with"	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [ ^ self booleanCheat:			(self integerValueOf: rcvr) > (self integerValueOf: arg)].	^ super bytecodePrimGreaterThan! !!InterpreterSimulator methodsFor: 'arithmetic'!bytecodePrimLessOrEqual	"Must be overridden from Interpreter because simulator doesn't have		32-bit signed ints to work with"	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [ ^ self booleanCheat:			(self integerValueOf: rcvr) <= (self integerValueOf: arg)].	^ super bytecodePrimLessOrEqual! !!InterpreterSimulator methodsFor: 'arithmetic'!bytecodePrimLessThan	"Must be overridden from Interpreter because simulator doesn't have		32-bit signed ints to work with"	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [ ^ self booleanCheat:			(self integerValueOf: rcvr) < (self integerValueOf: arg)].	^ super bytecodePrimLessThan! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'tao 9/29/97 16:29'!primitiveGetAttribute	"return nil as if attribute isn't defined"		self pop: 2.  "rcvr, attr"		self push: (self splObj: NilObject).! !InterpreterSupportCode comment:'This class is a shell that includes all the ancillary C code for supporting Squeak in the Macintosh operating environment.  Executing	InterpreterSupportCode writeMacSourceFileswill cause the creation of a number of files in your working directory which, together with the one large interpreter file (see CCodeGenerator) should be adequate to compile a complete running interpreter.'!!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 1/6/98 12:01'!archiveBinaryFileBytes	"Convert the Mac CodeWarrier Project archive data into a ByteArray."	| data b |	data _ self macArchiveBinaryFile.	b _ ByteArray new: data size.	1 to: data size do: [ :i | b at: i put: (data at: i)].	^ b! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 1/6/98 14:07'!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Black Uhuru:Desktop Folder:CW Test Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode archiveBinaryFileBytes		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMachDep.h') contentsOfEntireFile =	InterpreterSupportCode squeakMachDepFile		ifFalse: [self inform: 'File sqMachDep.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystick.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickFile		ifFalse: [self inform: 'File sqMacJoystick.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqOldSoundPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakOldSoundPrimsFile		ifFalse: [self inform: 'File sqOldSoundPrims.c differs from the version stored in this image.'].	dir _ dir directoryNamed: 'MacTCP'.	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 1/6/98 12:01'!storeProjectArchiveOnFileNamed: fileName	"Store into this image's folder a StuffIt archive file containing the CodeWarrier project files for the virtual machine. You will need to use a StuffIt unpacking utility such as StuffIt Expander to unpack the file. The result will be two project files for CodeWarrier, version 8."	| f |	f _ (FileStream newFileNamed: fileName) binary.	self macArchiveBinaryFile do: [:byte | f nextPut: byte].	f close.	FileDirectory default setMacFileNamed: fileName type: 'SITD' creator: 'SIT!!'.! !!InterpreterSupportCode class methodsFor: 'source file exporting'!storeString: s onFileNamed: fileName	"Store the given string in a file of the given name."	| f |	f _ FileStream newFileNamed: fileName.	f nextPutAll: s.	f close.! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'di 1/8/98 23:17'!writeMacSourceFiles	"Store into this image's folder the C sources files required to support the interpreter on the Macintosh. It also generates the code for the sound synthesis primitives. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate that code, use the method 'translate:doInlining:' in Interpreter class."	"InterpreterSupportCode writeMacSourceFiles"	self storeString: self readmeFile			onFileNamed: 'readme'.	self storeString: self squeakHeaderFile	onFileNamed: 'sq.h'.	self storeString: self squeakConfigFile	onFileNamed: 'sqConfig.h'.	self storeString: self squeakMachDepFile	onFileNamed: 'sqMachDep.h'.	self storeString: self squeakFilePrimsFile	onFileNamed: 'sqFilePrims.c'.	self storeString: self macDirectoryFile	onFileNamed: 'sqMacDirectory.c'.	self storeString: self macJoystickFile		onFileNamed: 'sqMacJoystick.c'.	self storeString: self macNetworkFile		onFileNamed: 'sqMacNetwork.c'.	self storeString: self macSoundFile		onFileNamed: 'sqMacSound.c'.	self storeString: self macWindowFile		onFileNamed: 'sqMacWindow.c'.	self storeString: self macTCPFile			onFileNamed: 'MacTCP.h'.	self storeString: self macAddressXlationFile		onFileNamed: 'AddressXlation.h'.	self storeString: self macDNRFile					onFileNamed: 'dnr.c'.	self storeString: AbstractSound cCodeForSoundPrimitives													onFileNamed: 'sqSoundPrims.c'.	self storeString: self squeakOldSoundPrimsFile	onFileNamed: 'sqOldSoundPrims.c'.	self storeProjectArchiveOnFileNamed: 'projectArchive.sit'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/6/98 11:52'!macAddressXlationFile	^ '/* 	File:		AddressXlation.h  	Contains:	TCP Manager interfaces for dnr.c  	Version:	Use with MacTCP 2.0.6 and Universal Interfaces 2.1b1					in MPW Prerelease on ETO #17  	Copyright:	 1984-1995 by Apple Computer, Inc. 				All rights reserved.  	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS */#ifndef __ADDRESSXLATION__#define __ADDRESSXLATION__#ifndef __TYPES__#include <Types.h>#endif/*	#include <ConditionalMacros.h>								*/#ifndef __MACTCP__#include <MacTCP.h>#endif/*	#include <AppleTalk.h>										*//*		#include <OSUtils.h>									*//*			#include <MixedMode.h>								*//*			#include <Memory.h>									*/#ifdef __cplusplusextern "C" {#endif#if STRUCTALIGNMENTSUPPORTED#pragma options align=mac68k#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import on#endif/*	Developer Notes:			When the various calls are made to the dnr code, you must set up 			a NewRoutineDescriptor for every non-nil completion routine and/or 			notifyProc parameter.  Otherwise, the 68K dnr code, will not 			correctly call your routine.		1. For the call to EnumCache, use NewEnumResultProc to set up a 			universal procptr to pass as the enumResultProc parameter.		2. For the calls to StrToAddr and AddrToName, use NewResultProc to 			set up a ResultUPP universal procptr to pass as the ResultProc 			parameter.		3. For the calls to HInfo and MXInfo, use NewResultProc2Proc to			set up a ResultProc2UPP universal procptr to pass as the ResultProc			parameter.		4. The DNR selector symbol HINFO has been changed to HXINFO due to			conflict with the same symbol in the AddressXLation.h header*/enum {	NUM_ALT_ADDRS				= 4};struct hostInfo {	long							rtnCode;	char							cname[255];	SInt8							filler;						/* Filler for proper byte alignment	 */	unsigned long					addr[NUM_ALT_ADDRS];};typedef struct hostInfo hostInfo;enum {	A							= 1,	NS							= 2,	CNAME						= 5,	HINFO						= 13,	MX							= 15,	lastClass					= 32767};typedef unsigned short AddrClasses;/* Domain Name Resolver code selectors */enum {	OPENRESOLVER				= 1,	CLOSERESOLVER				= 2,	STRTOADDR					= 3,	ADDRTOSTR					= 4,	ENUMCACHE					= 5,	ADDRTONAME					= 6,	HXINFO						= 7,							/* changed from HINFO due to symbol conflict*/	MXINFO						= 8};struct HInfoRec {	char							cpuType[30];	char							osType[30];};typedef struct HInfoRec HInfoRec;struct MXRec {	unsigned short					preference;	char							exchange[255];};typedef struct MXRec MXRec;struct returnRec {	long							rtnCode;	char							cname[255];	SInt8							filler;						/* Filler for proper byte alignment	 */	union {		unsigned long					addr[NUM_ALT_ADDRS];		struct HInfoRec					hinfo;		struct MXRec					mx;	}								rdata;};typedef struct returnRec returnRec;struct cacheEntryRecord {	char							*cname;	unsigned short					ctype;	unsigned short					cacheClass;	unsigned long					ttl;	union {		char							*name;		ip_addr							addr;	}								rdata;};typedef struct cacheEntryRecord cacheEntryRecord;typedef pascal void (*EnumResultProcPtr)(struct cacheEntryRecord *cacheEntryRecordPtr, Ptr userDataPtr);typedef pascal void (*ResultProcPtr)(struct hostInfo *hostInfoPtr, Ptr userDataPtr);typedef pascal void (*ResultProc2ProcPtr)(struct returnRec *returnRecPtr, Ptr userDataPtr);#if GENERATINGCFMtypedef UniversalProcPtr EnumResultUPP;typedef UniversalProcPtr ResultUPP;typedef UniversalProcPtr ResultProc2UPP;#elsetypedef EnumResultProcPtr EnumResultUPP;typedef ResultProcPtr ResultUPP;typedef ResultProc2ProcPtr ResultProc2UPP;#endifenum {	uppEnumResultProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct cacheEntryRecord*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr))),	uppResultProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct hostInfo*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr))),	uppResultProc2ProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct returnRec*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))};#if GENERATINGCFM#define NewEnumResultProc(userRoutine)		\		(EnumResultUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppEnumResultProcInfo, GetCurrentArchitecture())#define NewResultProc(userRoutine)		\		(ResultUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppResultProcInfo, GetCurrentArchitecture())#define NewResultProc2Proc(userRoutine)		\		(ResultProc2UPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppResultProc2ProcInfo, GetCurrentArchitecture())#else#define NewEnumResultProc(userRoutine)		\		((EnumResultUPP) (userRoutine))#define NewResultProc(userRoutine)		\		((ResultUPP) (userRoutine))#define NewResultProc2Proc(userRoutine)		\		((ResultProc2UPP) (userRoutine))#endif#if GENERATINGCFM#define CallEnumResultProc(userRoutine, cacheEntryRecordPtr, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppEnumResultProcInfo, (cacheEntryRecordPtr), (userDataPtr))#define CallResultProc(userRoutine, hostInfoPtr, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppResultProcInfo, (hostInfoPtr), (userDataPtr))#define CallResultProc2Proc(userRoutine, returnRecPtr, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppResultProc2ProcInfo, (returnRecPtr), (userDataPtr))#else#define CallEnumResultProc(userRoutine, cacheEntryRecordPtr, userDataPtr)		\		(*(userRoutine))((cacheEntryRecordPtr), (userDataPtr))#define CallResultProc(userRoutine, hostInfoPtr, userDataPtr)		\		(*(userRoutine))((hostInfoPtr), (userDataPtr))#define CallResultProc2Proc(userRoutine, returnRecPtr, userDataPtr)		\		(*(userRoutine))((returnRecPtr), (userDataPtr))#endifextern OSErr OpenResolver(char *fileName);extern OSErr StrToAddr(char *hostName, struct hostInfo *hostInfoPtr, ResultUPP ResultProc, char *userDataPtr);extern OSErr AddrToStr(unsigned long addr, char *addrStr);extern OSErr EnumCache(EnumResultUPP enumResultProc, Ptr userDataPtr);extern OSErr AddrToName(ip_addr addr, struct hostInfo *hostInfoPtr, ResultUPP ResultProc, Ptr userDataPtr);extern OSErr HInfo(char *hostName, struct returnRec *returnRecPtr, ResultProc2UPP resultProc, Ptr userDataPtr);extern OSErr MXInfo(char *hostName, struct returnRec *returnRecPtr, ResultProc2UPP resultProc, Ptr userDataPtr);extern OSErr CloseResolver(void);/*	Universal ProcPtrs declaration for each of the dnr selector code calls.*/typedef OSErr (*OpenResolverProcPtr)(UInt32 selector, char *filename);typedef OSErr (*CloseResolverProcPtr)(UInt32 selector);typedef OSErr (*StrToAddrProcPtr)(UInt32 selector, char *hostName, struct hostInfo *rtnStruct, ResultUPP resultproc, Ptr userDataPtr);typedef OSErr (*AddrToStrProcPtr)(UInt32 selector, unsigned long addr, char *addrStr);typedef OSErr (*EnumCacheProcPtr)(UInt32 selector, EnumResultUPP resultproc, Ptr userDataPtr);typedef OSErr (*AddrToNameProcPtr)(UInt32 selector, UInt32 addr, struct hostInfo *rtnStruct, ResultUPP resultproc, Ptr userDataPtr);typedef OSErr (*HInfoProcPtr)(UInt32 selector, char *hostName, struct returnRec *returnRecPtr, ResultProc2UPP resultProc, Ptr userDataPtr);typedef OSErr (*MXInfoProcPtr)(UInt32 selector, char *hostName, struct returnRec *returnRecPtr, ResultProc2UPP resultProc, Ptr userDataPtr);#if GENERATINGCFMtypedef UniversalProcPtr OpenResolverUPP;typedef UniversalProcPtr CloseResolverUPP;typedef UniversalProcPtr StrToAddrUPP;typedef UniversalProcPtr AddrToStrUPP;typedef UniversalProcPtr EnumCacheUPP;typedef UniversalProcPtr AddrToNameUPP;typedef UniversalProcPtr HInfoUPP;typedef UniversalProcPtr MXInfoUPP;#elsetypedef OpenResolverProcPtr OpenResolverUPP;typedef CloseResolverProcPtr CloseResolverUPP;typedef StrToAddrProcPtr StrToAddrUPP;typedef AddrToStrProcPtr AddrToStrUPP;typedef EnumCacheProcPtr EnumCacheUPP;typedef AddrToNameProcPtr AddrToNameUPP;typedef HInfoProcPtr HInfoUPP;typedef MXInfoProcPtr MXInfoUPP;#endifenum {	uppOpenResolverProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char*))),	uppCloseResolverProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32))),	uppStrToAddrProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char*)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(struct hostInfo*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(ResultUPP)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(Ptr))),	uppAddrToStrProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(unsigned long)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(char*))),	uppEnumCacheProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(EnumResultUPP)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr))),	uppAddrToNameProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(struct hostInfo*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(ResultUPP)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(Ptr))),	uppHInfoProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char*)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(struct returnRec*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(ResultProc2UPP)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(Ptr))),	uppMXInfoProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char*)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(struct returnRec*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(ResultProc2UPP)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(Ptr)))};#if GENERATINGCFM#define CallOpenResolverProc(userRoutine, selector, filename)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppOpenResolverProcInfo, (selector), (filename))#define CallCloseResolverProc(userRoutine, selector)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppCloseResolverProcInfo, (selector))#define CallStrToAddrProc(userRoutine, selector, hostName, rtnStruct, resultproc, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppStrToAddrProcInfo, (selector), (hostName), (rtnStruct), (resultproc), (userDataPtr))#define CallAddrToStrProc(userRoutine, selector, addr, addrStr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppAddrToStrProcInfo, (selector), (addr), (addrStr))#define CallEnumCacheProc(userRoutine, selector, resultproc, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppEnumCacheProcInfo, (selector), (resultproc), (userDataPtr))#define CallAddrToNameProc(userRoutine, selector, addr, rtnStruct, resultproc, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppAddrToNameProcInfo, (selector), (addr), (rtnStruct), (resultproc), (userDataPtr))#define CallHInfoProc(userRoutine, selector, hostName, returnRecPtr, resultProc, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppHInfoProcInfo, (selector), (hostName), (returnRecPtr), (resultProc), (userDataPtr))#define CallMXInfoProc(userRoutine, selector, hostName, returnRecPtr, resultProc, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppMXInfoProcInfo, (selector), (hostName), (returnRecPtr), (resultProc), (userDataPtr))#else#define CallOpenResolverProc(userRoutine, selector, filename)		\		(*(userRoutine))((selector), (filename))#define CallCloseResolverProc(userRoutine, selector)		\		(*(userRoutine))((selector))#define CallStrToAddrProc(userRoutine, selector, hostName, rtnStruct, resultproc, userDataPtr)		\		(*(userRoutine))((selector), (hostName), (rtnStruct), (resultproc), (userDataPtr))#define CallAddrToStrProc(userRoutine, selector, addr, addrStr)		\		(*(userRoutine))((selector), (addr), (addrStr))#define CallEnumCacheProc(userRoutine, selector, resultproc, userDataPtr)		\		(*(userRoutine))((selector), (resultproc), (userDataPtr))#define CallAddrToNameProc(userRoutine, selector, addr, rtnStruct, resultproc, userDataPtr)		\		(*(userRoutine))((selector), (addr), (rtnStruct), (resultproc), (userDataPtr))#define CallHInfoProc(userRoutine, selector, hostName, returnRecPtr, resultProc, userDataPtr)		\		(*(userRoutine))((selector), (hostName), (returnRecPtr), (resultProc), (userDataPtr))#define CallMXInfoProc(userRoutine, selector, hostName, returnRecPtr, resultProc, userDataPtr)		\		(*(userRoutine))((selector), (hostName), (returnRecPtr), (resultProc), (userDataPtr))#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import off#endif#if STRUCTALIGNMENTSUPPORTED#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __ADDRESSXLATION__ */'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/6/98 23:21'!macArchiveBinaryFile	^ #(83 73 84 33 0 2 0 0 32 254 114 76 97 117 2 210 0 0 0 22 2 76 13 13 14 83 113 117 101 97 107 54 56 75 46 112 114 111 106 46 99 67 0 0 0 0 0 0 0 0 0 0 0 0 0 0 86 217 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 15 160 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 90 110 176 216 106 77 0 0 37 198 0 0 25 66 0 0 7 229 0 0 7 53 141 84 136 34 0 0 0 0 0 0 60 100 13 192 248 235 154 216 203 204 86 126 244 184 132 159 135 103 231 241 8 235 104 173 236 178 35 140 80 66 9 79 138 167 39 167 151 157 39 161 114 250 157 207 9 55 195 83 79 154 50 13 255 12 255 180 104 131 188 53 78 152 252 9 39 199 143 80 126 132 147 231 70 88 70 35 199 34 92 194 9 139 242 151 240 39 207 159 60 39 156 48 194 9 229 3 194 9 35 252 108 32 225 132 70 24 57 126 132 19 38 57 126 18 70 56 225 3 59 194 8 91 129 187 26 196 105 242 35 199 143 54 136 242 149 175 17 78 56 161 71 88 228 248 73 88 100 198 9 127 138 39 28 24 111 64 0 122 157 93 0 12 0 228 241 0 179 241 100 111 231 244 91 100 174 69 20 124 26 215 38 10 18 167 183 8 58 167 201 109 162 44 137 156 24 208 236 181 171 219 69 161 117 97 97 165 83 81 229 85 149 44 102 119 187 61 53 174 250 197 101 12 44 201 63 129 126 142 183 191 141 93 55 221 32 1 92 84 10 112 233 203 34 215 20 16 188 173 156 220 174 7 252 72 144 80 214 12 206 122 139 95 227 240 208 91 68 206 39 54 11 237 1 29 255 181 86 93 86 56 69 245 75 186 168 58 23 215 209 203 67 151 56 175 32 73 178 206 53 33 27 121 141 232 227 228 230 230 48 9 35 79 147 232 21 218 53 145 243 235 132 30 10 194 66 18 86 129 149 22 130 25 76 228 143 215 65 50 176 152 200 130 72 55 254 153 1 212 14 139 44 108 38 2 42 46 33 138 100 185 5 47 87 93 203 45 44 108 229 92 243 92 5 5 206 103 78 100 193 142 7 96 13 255 132 255 151 50 221 76 26 187 126 40 143 19 82 195 200 132 206 25 195 153 28 192 48 253 236 195 22 176 188 77 224 20 17 32 243 40 101 150 196 64 40 20 73 19 10 49 36 8 52 195 248 37 177 101 11 64 113 136 124 97 101 211 146 221 178 36 120 229 81 5 172 48 7 108 204 75 108 48 250 63 28 132 222 180 107 32 137 84 9 45 146 74 174 202 47 181 138 234 119 76 194 25 60 30 215 201 12 185 37 30 79 213 100 201 222 140 103 137 162 4 204 1 120 184 221 85 232 47 226 97 175 242 55 113 139 219 20 89 213 137 180 63 228 112 123 170 202 77 2 120 212 187 174 51 7 208 181 166 182 102 132 224 31 60 234 202 26 234 88 167 55 222 194 220 245 70 215 60 173 170 193 195 234 244 22 20 152 2 240 176 56 189 63 9 242 27 15 197 52 64 87 101 148 200 89 30 98 199 79 130 252 18 70 189 182 252 93 175 89 81 30 113 53 50 145 135 71 208 188 66 224 140 176 134 174 138 160 153 5 240 240 142 42 155 208 149 24 27 194 35 153 240 248 177 19 77 240 96 157 223 249 155 161 176 212 136 235 18 245 218 224 170 30 243 13 89 36 73 121 220 57 248 100 111 251 191 173 131 246 123 85 83 227 205 126 156 135 214 18 104 74 228 177 123 202 126 86 21 121 232 237 38 1 60 72 88 157 88 37 127 233 234 33 181 152 240 192 38 32 14 23 165 253 33 199 57 135 123 154 135 105 128 195 173 46 93 66 102 114 113 61 220 158 250 132 30 102 13 78 249 148 26 231 156 114 156 199 89 167 60 198 99 220 41 143 233 58 238 148 19 60 204 23 156 242 136 30 127 58 229 211 194 254 225 148 19 60 198 157 242 8 141 243 78 57 206 195 28 192 41 155 127 56 220 83 5 123 206 225 158 233 140 166 1 14 183 222 47 93 181 128 235 40 92 120 210 225 218 126 119 58 72 228 100 142 223 157 78 156 199 89 135 50 166 199 184 67 73 240 152 232 192 35 60 206 119 224 56 15 139 51 222 245 82 145 7 22 254 152 21 158 236 48 49 30 1 255 104 219 251 102 146 112 166 210 8 15 185 105 213 40 143 234 166 85 9 30 105 238 83 235 10 209 226 112 187 42 76 1 68 255 117 70 144 138 106 208 138 254 153 7 118 170 192 168 87 156 74 120 4 4 77 227 92 114 155 226 15 124 171 110 164 51 96 69 139 205 166 0 186 78 118 134 152 151 142 123 242 9 30 137 14 156 168 179 88 231 212 71 203 108 60 172 185 116 109 136 1 11 99 195 13 159 34 104 68 124 249 241 109 208 120 249 33 3 3 120 17 160 145 15 190 127 28 207 195 124 144 15 246 191 119 233 114 220 248 153 2 251 48 243 109 248 15 203 8 133 42 190 243 161 215 161 241 138 10 88 254 197 205 16 60 176 23 130 93 29 124 240 65 27 189 19 220 140 237 144 48 49 248 113 89 124 39 201 199 119 110 61 0 55 238 191 243 4 23 68 130 119 236 28 20 220 248 255 208 144 140 242 27 12 190 243 201 25 124 231 19 120 59 204 15 178 111 130 125 120 14 241 233 250 16 26 139 15 226 255 179 148 75 31 229 252 41 108 161 74 103 99 86 100 140 27 69 236 244 34 99 148 90 219 174 144 238 76 208 10 220 38 20 85 173 200 97 239 131 169 59 230 68 137 51 115 13 69 48 43 227 123 124 62 56 150 30 196 115 95 75 232 75 30 241 203 240 94 8 28 23 204 69 236 40 158 89 144 221 89 135 249 95 204 7 171 21 113 110 48 63 32 238 49 240 185 58 83 240 90 143 230 85 253 144 131 3 73 204 79 183 170 124 189 88 7 168 15 205 159 138 249 119 237 5 71 110 108 39 42 255 190 221 252 253 79 235 136 96 17 16 62 189 189 224 152 185 139 185 54 41 11 177 119 144 95 55 173 243 169 59 54 24 249 81 15 146 223 49 43 98 43 115 97 22 217 134 35 53 112 209 112 13 160 233 81 5 213 47 106 69 96 106 81 3 204 255 175 255 204 52 160 6 82 129 205 25 174 129 72 19 0 232 201 131 129 202 61 48 80 211 193 119 221 250 106 53 153 170 91 32 13 63 128 15 24 223 90 194 49 68 110 195 161 71 123 224 240 235 15 0 51 111 51 227 91 135 122 172 237 238 15 7 189 63 160 109 68 38 111 240 247 163 166 52 127 79 30 230 56 82 10 179 75 33 253 173 6 152 86 200 210 30 150 157 110 24 134 67 219 95 72 244 115 228 57 63 2 25 248 250 92 200 238 223 138 103 55 98 77 244 126 246 192 49 176 63 223 23 194 64 156 191 14 107 129 223 158 150 15 71 25 172 215 77 33 96 246 211 73 56 107 195 189 210 244 90 127 155 18 16 185 82 81 156 156 108 154 118 4 3 140 25 76 17 96 56 192 138 11 179 116 169 147 110 120 146 197 105 18 118 72 137 173 138 82 100 15 238 214 66 166 177 103 205 45 115 147 209 32 217 183 30 27 31 12 69 121 73 109 157 177 179 146 163 100 209 126 254 79 20 99 68 193 239 119 100 33 101 239 112 202 5 168 227 249 189 96 91 180 50 72 61 188 67 55 140 135 27 138 25 80 172 88 161 233 130 74 172 158 137 67 56 168 83 196 98 30 174 103 236 126 102 0 237 170 216 4 66 95 198 65 94 21 48 165 137 231 200 132 41 177 153 79 220 134 225 94 24 50 179 192 147 236 234 55 152 2 248 152 68 217 14 250 156 239 93 142 225 77 108 198 99 1 225 148 120 198 222 207 96 222 214 61 211 29 120 229 98 70 2 86 89 70 231 179 211 21 21 135 177 57 240 191 218 186 154 60 204 56 180 113 151 215 79 135 155 232 249 112 139 229 99 184 4 239 219 9 86 243 10 224 220 134 161 195 237 69 119 67 33 98 244 189 130 10 15 224 56 159 33 19 63 80 222 132 106 100 61 155 96 109 155 96 5 98 117 4 187 172 30 240 113 0 214 71 176 170 199 96 35 98 27 8 38 93 13 93 136 245 82 121 175 132 187 16 59 70 176 252 44 184 23 224 194 107 8 182 166 21 182 161 100 13 4 187 118 55 60 130 82 210 65 242 213 247 194 83 136 33 23 28 19 238 4 156 165 92 76 102 53 80 62 7 250 0 46 161 249 82 151 194 187 136 221 67 176 180 29 240 17 98 91 9 150 185 8 62 1 152 185 134 96 243 190 134 175 16 163 57 86 167 225 187 27 192 209 33 227 140 157 76 6 192 44 124 27 4 3 167 43 88 81 11 8 100 57 66 49 172 5 128 41 30 124 115 68 244 234 28 214 149 230 151 165 12 220 48 138 14 194 237 116 211 33 10 167 147 93 23 151 236 19 23 137 146 45 182 247 66 175 133 105 76 9 111 93 69 82 70 240 122 65 149 252 210 74 205 30 161 91 214 161 171 130 150 92 230 243 235 178 106 45 151 37 61 185 78 80 87 138 122 70 137 215 43 226 48 222 35 232 45 120 159 166 73 167 102 61 76 60 182 82 74 175 133 9 217 141 229 142 168 114 6 28 161 157 236 42 119 99 178 116 242 224 66 132 71 236 241 133 20 2 225 230 16 189 30 230 243 31 0 12 0 235 49 59 223 206 203 178 51 123 123 155 121 245 244 123 51 251 252 181 214 62 143 31 181 147 223 90 29 229 132 147 227 42 91 79 118 226 9 53 45 252 211 124 194 146 48 9 127 201 241 1 57 78 56 121 78 158 147 1 39 156 112 114 252 40 225 132 31 189 90 57 57 78 70 140 60 35 92 194 8 39 156 76 248 73 248 235 241 35 156 28 39 19 22 225 146 227 228 57 57 70 56 57 46 225 79 56 5 238 141 230 117 248 106 224 57 232 186 149 19 150 209 227 146 1 39 168 96 132 227 201 10 124 43 22 176 223 229 83 148 0 33 196 4 191 249 132 228 13 194 239 69 232 185 225 55 5 126 223 32 115 72 41 49 147 194 84 143 210 169 250 36 141 152 6 191 38 71 72 117 235 240 175 14 146 10 4 250 165 97 77 63 51 231 89 93 94 95 65 189 124 64 245 170 50 80 247 50 222 60 100 8 46 255 24 207 86 217 224 169 187 12 60 150 224 209 25 11 9 41 11 19 203 51 118 98 250 238 117 66 142 13 155 158 206 190 64 182 16 55 212 239 93 65 209 25 24 15 63 170 31 171 75 94 49 219 72 138 201 183 160 217 152 142 152 119 154 119 31 27 38 63 129 246 36 221 78 178 72 45 115 8 245 200 232 103 173 11 234 146 26 82 37 168 138 125 145 25 70 191 26 172 95 37 175 65 101 25 159 67 235 168 145 3 146 91 149 219 181 233 57 54 96 109 25 176 228 60 3 83 100 66 189 31 106 43 214 54 168 91 160 206 194 126 6 212 94 168 211 195 67 171 63 134 186 58 60 244 197 16 212 187 195 67 103 215 64 253 41 249 12 166 201 142 232 97 215 58 192 187 85 178 42 249 116 69 237 137 75 34 92 191 160 127 101 239 105 152 98 233 192 111 223 252 0 181 208 103 9 254 111 33 214 139 177 142 234 230 192 255 11 253 114 250 229 95 46 222 209 241 4 9 131 10 182 136 142 89 76 199 71 148 30 77 151 125 109 9 103 137 148 17 58 206 135 250 147 81 29 133 126 73 191 205 234 245 57 57 11 211 206 143 232 101 99 122 53 72 122 151 162 78 201 69 30 194 186 4 117 201 197 218 62 96 122 247 45 168 179 7 50 22 127 57 170 95 233 140 126 43 145 35 244 91 241 193 201 159 75 161 94 246 225 247 239 119 198 245 52 53 152 232 182 176 42 162 103 38 211 19 214 134 160 127 58 214 200 3 88 151 225 252 203 177 222 132 181 240 229 54 172 119 96 189 5 235 124 195 7 209 28 218 110 228 209 86 35 151 202 177 22 126 89 132 117 30 214 27 251 159 168 92 4 245 102 204 135 168 159 30 158 204 177 10 195 95 81 63 217 76 118 112 195 146 235 123 2 248 233 73 57 232 87 186 166 13 245 160 225 39 145 19 194 55 149 88 175 186 157 27 194 47 194 31 123 176 222 213 255 199 133 231 160 118 254 151 231 59 209 55 107 240 127 51 126 136 238 77 144 151 44 92 254 90 156 138 239 59 176 55 77 234 145 173 117 52 6 252 119 36 169 186 239 128 30 127 50 33 242 34 122 204 245 7 111 237 165 226 19 219 181 200 93 145 183 209 92 45 196 254 106 35 71 138 176 94 143 117 116 255 139 228 106 1 214 235 176 94 139 181 200 9 177 151 136 28 141 236 37 53 164 118 206 143 80 155 47 239 248 180 200 117 121 245 86 56 40 148 87 60 90 80 88 38 151 84 248 139 138 161 125 77 127 122 231 224 123 250 205 57 210 33 117 27 61 197 129 27 232 43 159 224 70 245 8 169 202 65 88 244 213 242 138 182 66 79 187 55 16 40 154 24 10 174 14 87 230 16 125 156 195 234 169 107 220 215 92 12 178 78 200 121 149 22 159 35 151 93 92 208 25 5 206 248 64 115 199 102 114 192 20 105 111 38 53 24 200 200 127 209 212 235 114 215 215 208 14 49 51 234 75 73 39 13 100 20 157 17 212 162 51 100 14 163 190 144 244 13 108 35 39 57 149 118 72 10 163 246 38 221 15 19 58 70 102 117 144 185 140 122 36 233 137 1 171 245 91 164 66 7 46 7 224 113 235 165 228 165 225 196 185 179 207 155 122 155 170 155 155 104 7 242 22 168 182 188 100 62 135 143 154 193 13 148 74 59 112 109 97 179 38 175 51 225 103 127 255 8 169 208 33 233 212 235 214 75 41 90 71 113 107 34 42 232 102 129 84 186 99 88 28 144 137 169 47 207 107 7 15 37 184 108 127 97 84 214 201 224 212 212 158 195 222 128 22 199 178 109 70 80 189 36 19 169 154 238 151 149 105 234 254 17 234 126 98 229 212 52 160 66 22 196 176 6 213 54 66 85 229 224 161 41 106 203 8 181 133 100 161 27 116 185 93 186 229 134 177 89 237 14 240 107 218 219 153 224 214 90 201 235 151 212 9 75 176 221 155 83 105 39 155 83 233 245 20 169 16 65 55 146 18 54 245 94 151 203 89 203 58 243 153 66 131 233 85 146 214 182 167 51 230 61 182 127 179 89 89 39 135 83 83 155 122 66 82 194 175 108 235 226 84 218 89 192 169 57 78 37 232 151 117 89 9 122 3 32 150 170 24 19 176 157 77 204 122 154 44 228 212 12 151 220 45 249 93 138 127 210 72 6 53 151 83 211 170 15 75 65 61 46 145 65 93 132 179 62 214 9 105 236 87 189 93 119 103 205 227 212 172 17 106 147 212 173 95 35 27 212 197 232 188 70 207 62 93 142 167 158 65 93 130 186 186 164 118 154 225 51 186 46 69 191 210 107 241 84 190 210 45 157 39 10 237 228 11 15 169 170 50 153 65 215 103 93 198 119 148 52 176 118 147 211 29 163 210 13 156 239 13 108 23 95 142 206 171 12 133 2 82 147 55 208 118 215 121 43 248 172 246 74 191 95 149 52 173 185 222 75 99 101 28 77 183 126 62 43 237 144 2 156 245 113 73 227 47 19 238 206 186 82 100 158 234 13 77 101 222 85 234 42 116 249 94 73 211 189 129 235 169 112 147 186 26 169 53 74 32 22 255 215 168 107 80 215 38 120 152 145 200 20 131 186 86 80 33 180 238 81 215 97 54 120 124 170 28 138 201 26 161 174 199 164 132 247 15 129 132 251 12 106 161 112 131 220 77 87 243 25 55 20 161 95 235 124 74 240 158 95 55 240 93 57 249 178 34 156 250 84 61 110 189 208 129 59 52 163 38 239 214 225 193 65 59 82 161 3 215 86 49 235 244 117 54 60 212 103 17 27 118 159 5 110 248 140 154 188 249 135 143 182 20 33 21 58 112 201 20 212 233 51 99 120 240 212 113 161 208 169 227 164 100 100 59 60 44 199 114 114 220 67 165 152 40 110 85 1 168 54 147 175 27 209 175 220 62 113 191 210 75 58 167 210 206 38 78 205 116 42 237 33 37 24 219 245 140 89 55 35 149 205 90 23 12 117 78 36 152 177 245 150 113 170 149 237 40 241 197 210 152 117 11 167 206 171 118 187 157 137 27 128 65 45 71 133 0 74 227 252 128 210 253 183 174 91 57 213 214 160 232 242 65 217 55 177 13 141 83 43 208 229 60 130 102 93 190 141 83 45 176 205 235 170 18 91 96 13 234 118 116 185 75 10 198 175 13 227 212 29 34 135 100 111 64 57 52 171 208 195 168 16 221 108 170 225 226 240 143 66 59 197 158 7 55 27 117 90 161 177 108 216 197 168 95 89 196 197 49 58 43 125 255 192 169 180 179 155 223 216 50 88 150 183 86 73 161 9 44 189 214 139 13 0 238 246 14 116 131 135 221 162 102 221 80 41 110 0 224 215 123 206 219 131 84 183 210 117 219 13 99 84 167 200 114 31 44 203 255 82 171 248 142 146 124 13 17 30 58 223 39 220 112 190 143 84 115 15 89 180 14 72 162 131 114 244 54 71 95 62 8 42 188 129 168 193 221 235 206 75 60 78 29 237 195 107 71 98 118 123 164 67 195 195 35 127 130 255 152 8 253 15 85 195 116 78 127 7 170 229 244 13 160 187 94 211 25 245 156 14 111 205 44 240 162 196 118 198 93 19 208 232 127 254 7 13 13 14 83 113 117 101 97 107 80 80 67 46 112 114 111 106 77 114 67 0 0 0 0 0 0 0 0 0 0 0 0 0 0 60 229 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 22 0 0 0 0 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 176 216 106 143 0 0 42 109 0 0 26 134 0 0 9 109 0 0 7 129 212 27 198 183 0 0 0 0 0 0 72 200 13 192 213 101 131 214 46 175 91 247 73 57 221 44 111 141 211 203 228 71 187 149 29 97 69 24 97 155 146 205 54 195 211 179 207 220 212 206 6 157 207 207 207 53 195 115 122 118 230 243 213 218 210 182 23 35 107 93 103 70 110 147 77 219 18 70 110 31 43 59 66 9 39 140 108 194 158 176 158 238 35 108 123 233 126 178 25 217 30 217 82 194 221 71 142 145 103 155 17 126 29 147 19 182 201 113 194 182 71 248 69 185 132 17 126 110 74 158 118 43 240 85 131 58 175 206 119 179 143 182 178 181 125 100 75 35 108 147 219 186 217 38 179 77 246 139 39 27 24 111 64 0 122 157 93 0 12 0 230 124 30 32 7 79 205 23 92 129 247 150 60 196 32 112 194 3 243 196 192 32 158 67 13 221 243 77 129 119 148 191 138 148 154 251 59 36 91 155 213 106 54 121 188 238 86 179 128 217 45 22 107 181 185 110 121 49 131 178 236 17 244 61 63 94 31 141 221 107 154 51 1 50 54 1 220 217 158 181 212 20 56 186 243 137 178 226 251 116 43 186 119 62 155 63 11 145 140 82 87 160 103 190 9 82 241 212 227 153 80 177 247 164 174 242 93 72 93 171 95 209 77 119 61 186 93 213 181 149 11 226 202 7 102 12 6 60 21 107 42 58 22 0 196 113 110 113 252 211 70 200 146 184 35 161 141 195 128 138 149 0 165 127 96 233 57 120 67 224 201 181 248 207 239 131 198 240 60 254 183 6 113 188 31 239 177 217 219 108 205 210 135 90 42 49 37 120 223 36 175 107 63 127 63 185 102 157 236 147 218 205 78 155 44 75 242 5 10 217 231 148 58 31 58 16 48 145 6 145 45 248 247 113 206 241 16 144 69 146 10 0 139 80 148 145 34 169 22 155 221 88 89 99 196 22 97 52 207 55 231 229 153 126 52 146 69 84 202 76 249 9 254 175 96 91 88 162 240 224 153 60 73 192 144 14 158 92 102 66 35 176 137 87 167 16 174 209 137 96 90 85 128 106 81 7 9 108 168 161 146 152 204 168 31 205 100 192 34 60 32 188 162 1 205 97 40 7 136 199 190 152 60 200 153 197 161 113 8 132 210 4 2 88 176 84 178 0 51 149 95 138 109 219 0 150 6 232 11 246 139 68 157 197 237 178 217 221 227 10 104 33 23 146 216 47 4 127 248 255 108 117 147 44 171 32 142 122 79 176 245 148 59 92 109 146 247 3 38 19 25 50 10 172 86 84 245 191 177 22 207 2 143 199 169 14 192 195 98 41 47 140 229 73 41 119 52 26 151 183 123 220 94 31 73 123 33 135 197 90 94 162 18 192 163 206 92 164 14 160 107 117 77 245 24 193 79 120 212 22 215 215 106 76 141 45 246 254 254 126 96 191 220 202 47 190 253 184 143 126 197 71 91 223 64 187 84 164 47 180 57 157 110 183 203 88 42 57 61 116 113 250 98 1 222 238 238 133 158 57 139 97 103 254 1 186 66 60 4 147 61 218 10 45 117 138 167 185 84 29 10 15 173 201 158 151 167 10 192 67 99 178 95 17 228 239 60 184 236 170 0 186 122 198 137 92 231 33 117 94 17 228 175 161 212 107 203 127 234 53 53 204 35 170 70 50 242 176 218 100 187 205 121 89 88 69 87 143 109 204 224 255 147 135 125 92 217 152 174 100 144 136 135 142 120 124 212 137 174 241 16 76 31 248 164 51 161 169 150 190 250 113 189 202 87 250 180 14 101 40 144 219 121 159 230 247 207 245 233 122 115 229 132 143 73 165 36 37 81 39 211 228 182 119 252 175 5 113 255 225 149 189 81 211 48 201 67 110 113 54 198 242 164 88 139 175 170 138 60 124 29 42 1 60 40 180 38 172 146 127 235 106 165 90 84 28 247 162 197 95 86 47 113 220 40 237 133 28 55 28 247 37 30 170 1 142 187 178 176 204 56 161 135 197 90 23 211 67 237 195 185 95 84 245 134 115 143 242 184 238 220 39 120 76 58 247 9 93 39 157 123 140 135 250 130 115 31 211 227 95 206 253 146 176 159 56 247 24 143 73 231 62 70 227 166 115 143 242 80 15 112 238 90 147 44 53 127 212 167 1 122 238 56 133 211 248 92 40 204 198 254 188 111 164 79 151 240 62 173 254 225 184 47 22 254 13 199 125 185 195 170 6 56 238 58 135 235 174 133 198 206 197 139 254 236 184 147 254 225 152 144 200 149 206 112 205 49 69 121 92 119 58 19 122 76 58 157 24 143 107 157 124 140 199 205 78 30 229 161 49 69 187 94 2 242 192 194 159 176 230 159 118 152 8 15 167 99 188 237 157 158 108 92 174 52 226 225 110 108 29 231 81 217 216 26 227 145 104 185 184 206 17 46 14 139 185 84 21 64 244 191 205 26 18 80 13 94 209 87 121 96 167 114 142 123 206 52 226 65 75 99 70 179 187 221 227 112 158 85 55 212 25 176 162 165 251 84 1 116 253 180 51 68 60 121 212 219 95 227 17 235 192 177 58 139 116 78 223 120 153 77 134 206 200 151 213 4 208 50 218 69 203 135 6 196 87 159 250 30 52 220 249 166 130 1 236 3 104 16 253 191 59 133 231 128 232 23 253 253 175 206 94 141 27 81 83 225 32 102 222 128 255 128 123 135 192 202 197 174 239 254 10 26 230 149 194 234 19 107 193 255 250 1 240 63 210 41 250 159 72 226 119 252 15 99 59 36 38 10 63 99 170 216 69 249 196 174 39 95 135 85 175 109 30 225 130 136 255 209 29 195 130 43 255 232 201 49 48 63 242 27 14 177 171 119 166 216 245 44 222 14 242 131 105 107 224 32 158 103 248 60 242 6 52 44 61 130 255 207 113 46 125 156 243 113 216 198 149 158 134 89 145 49 195 237 67 33 63 127 163 184 241 165 250 32 57 6 154 153 69 204 85 187 9 79 100 26 127 218 132 205 227 9 148 187 79 130 240 238 171 132 27 181 34 230 55 26 196 141 187 148 185 109 226 194 94 214 252 29 69 59 202 87 245 66 167 184 113 71 9 36 21 239 129 161 31 28 98 85 47 247 97 174 245 16 223 246 117 120 236 253 33 86 245 252 22 28 73 240 192 28 71 88 220 55 31 135 147 247 236 16 55 29 175 224 234 195 83 107 105 38 1 236 181 34 86 245 99 16 154 211 111 135 161 95 207 80 216 61 240 51 174 217 120 12 157 164 86 196 139 63 172 49 215 229 231 123 1 214 239 98 135 65 200 206 87 198 219 53 29 30 114 40 249 165 146 173 73 242 202 249 5 21 53 203 113 102 169 128 56 37 249 201 41 58 217 146 253 71 88 83 175 15 207 92 182 132 202 107 250 33 206 168 233 105 107 33 36 232 65 159 101 8 179 55 20 28 142 245 36 246 197 117 111 114 160 41 200 131 112 84 156 248 176 47 77 255 203 52 252 40 200 48 8 125 152 107 43 213 11 107 122 102 51 105 130 249 123 249 125 253 237 155 33 237 91 59 178 33 65 203 245 120 138 165 241 83 137 116 200 196 130 16 50 70 107 0 209 144 242 134 148 62 72 219 158 27 17 108 110 168 186 5 214 250 199 5 96 88 113 4 207 131 45 129 63 137 136 223 129 247 2 96 248 204 92 196 6 241 76 133 105 93 181 152 127 95 54 104 181 136 27 135 243 3 226 86 5 159 235 99 121 251 123 100 187 215 1 183 224 32 10 243 243 237 195 214 1 236 135 168 15 207 159 128 249 223 57 0 134 244 200 238 96 214 241 13 226 214 61 52 197 194 102 72 124 6 158 1 195 172 221 172 72 111 69 236 16 242 219 194 43 62 109 251 67 74 126 212 131 242 27 50 67 157 13 245 167 93 92 170 129 91 71 107 0 205 175 215 230 117 72 88 252 170 15 53 32 110 189 92 3 172 237 247 63 85 19 168 129 169 163 53 64 187 160 34 114 34 206 234 40 125 0 197 76 10 46 162 171 189 68 112 101 91 5 38 12 56 43 8 151 196 112 164 64 60 150 8 63 130 55 95 34 135 57 177 57 127 53 150 98 40 187 84 204 95 127 238 229 133 27 65 124 194 224 249 13 125 228 57 154 114 33 234 120 179 246 147 208 5 132 151 197 217 33 165 151 142 52 20 53 160 184 247 94 217 103 243 242 165 13 245 134 48 128 70 8 62 234 16 121 17 0 131 119 63 53 16 125 153 65 37 198 253 125 24 123 105 182 148 172 188 28 99 92 105 33 131 67 47 200 224 251 49 195 73 74 10 106 106 21 247 114 11 250 234 120 218 24 234 65 79 196 61 185 218 65 217 14 251 156 243 46 71 121 99 36 233 236 179 50 145 55 115 216 111 124 165 25 52 183 155 193 158 3 193 179 146 207 233 51 60 94 28 202 223 6 57 53 181 213 89 152 241 27 167 41 37 22 240 33 55 239 122 119 191 8 52 239 72 33 172 234 65 200 199 223 207 18 86 246 24 189 174 1 15 19 214 113 43 220 131 191 187 9 75 174 133 102 252 165 225 33 100 206 6 228 202 202 8 171 153 11 235 17 251 54 97 139 188 208 141 216 247 9 43 248 33 213 17 219 67 216 170 52 120 26 177 163 132 197 31 195 186 4 97 128 176 175 245 195 43 168 36 223 14 173 191 13 126 139 24 190 169 131 26 188 12 111 33 198 55 39 220 14 56 134 24 223 22 51 188 0 239 35 214 199 239 45 131 33 28 129 240 217 78 238 139 44 17 159 251 32 221 96 86 47 67 141 141 119 19 246 149 207 49 156 186 26 249 254 130 46 135 205 65 140 235 186 76 100 119 161 138 60 95 230 126 134 91 183 153 27 8 171 104 102 85 136 209 220 5 238 247 49 156 48 103 241 86 33 181 178 38 196 120 14 243 91 12 31 13 201 230 218 203 219 217 3 0 179 149 117 148 62 154 59 229 208 203 62 160 57 198 49 174 235 84 43 246 27 201 238 51 98 125 202 14 183 43 221 98 107 118 216 141 102 155 103 116 201 2 109 120 232 162 178 83 146 22 185 16 228 144 194 23 109 194 25 167 208 170 149 217 221 36 45 147 92 73 145 181 43 126 45 152 49 149 246 159 139 28 50 18 149 218 27 137 37 185 252 211 23 244 202 238 59 110 25 186 36 167 30 215 242 194 244 166 6 23 15 207 226 117 54 175 203 225 106 150 83 66 202 22 119 250 188 54 89 87 220 228 240 185 189 218 18 183 203 167 171 181 121 155 37 159 190 192 110 151 80 98 171 205 215 130 247 121 154 41 164 72 72 180 200 118 54 191 22 146 89 217 75 10 241 14 194 33 218 58 115 137 5 147 77 225 227 138 32 143 200 187 42 241 4 225 210 27 191 30 228 243 127 0 12 0 197 6 190 157 215 164 51 51 123 27 228 219 192 108 98 179 244 90 251 60 238 122 157 220 245 216 27 25 176 19 79 61 105 226 9 53 45 252 199 206 122 9 95 9 63 143 28 127 194 8 39 140 140 56 25 112 9 127 242 236 200 115 189 110 229 228 24 225 100 192 143 28 35 44 194 9 39 156 112 242 252 36 199 8 253 200 132 19 70 158 69 56 229 132 147 231 228 56 225 228 25 225 30 225 2 55 89 153 183 197 211 235 200 166 231 215 218 73 184 25 189 36 3 78 80 193 8 199 119 192 135 199 2 246 50 188 71 81 124 8 33 1 254 11 17 42 40 128 255 50 232 57 225 127 58 252 127 13 85 41 50 193 187 90 107 17 97 92 158 119 11 106 132 46 221 57 64 234 135 15 230 173 120 14 2 15 157 61 67 186 194 93 119 228 205 195 232 148 105 229 185 190 255 209 186 225 159 240 132 70 83 195 185 48 230 9 5 200 14 111 229 161 92 120 235 155 27 27 209 172 7 56 211 52 248 223 105 218 245 250 125 244 51 130 94 90 31 202 70 53 196 33 216 35 253 143 165 214 175 75 106 64 149 160 42 241 140 104 133 31 76 199 207 187 232 44 84 230 161 57 180 246 106 217 39 57 85 185 77 75 204 129 253 129 159 101 93 230 220 195 48 197 10 168 143 64 93 204 234 149 80 55 66 189 138 245 151 67 45 66 253 66 184 119 201 21 168 171 194 189 223 245 66 93 30 238 189 190 20 234 175 192 221 8 212 53 244 200 210 218 29 162 167 82 86 37 143 174 168 39 226 146 44 100 117 90 231 162 208 23 48 69 86 215 239 55 127 128 154 235 147 201 222 51 179 218 202 234 168 110 21 236 125 174 95 106 167 252 219 175 79 116 188 132 194 160 130 117 80 199 76 162 227 75 202 9 77 151 61 173 163 206 122 209 208 113 23 212 215 250 117 228 250 37 253 54 169 215 183 232 58 76 155 51 168 151 149 232 85 39 233 199 21 245 177 92 104 9 171 75 152 46 233 172 94 221 37 156 255 0 234 53 93 233 115 251 250 245 91 59 161 95 30 227 112 253 102 93 252 236 151 82 168 115 46 127 255 113 48 174 167 80 39 224 180 176 120 80 207 12 162 167 75 9 250 189 137 181 134 22 177 122 3 155 63 151 213 235 88 205 125 185 133 213 219 88 189 145 213 217 134 15 162 123 104 171 177 143 202 140 189 180 137 213 220 47 25 172 182 176 186 180 243 64 197 28 168 215 179 253 16 245 211 246 145 61 182 217 240 87 212 79 86 33 11 220 80 240 40 39 128 159 14 202 126 175 114 60 97 168 197 134 159 248 158 224 190 217 205 234 57 227 123 131 251 133 251 195 198 234 157 157 247 250 222 128 186 242 223 125 190 131 249 102 46 123 111 194 15 209 220 148 173 181 215 251 188 100 191 140 101 167 234 231 14 228 166 17 61 96 127 63 17 3 158 165 207 29 208 227 15 34 68 254 160 30 51 188 254 177 92 202 159 20 86 243 189 203 247 109 116 175 206 103 253 124 99 143 44 96 117 33 171 163 249 111 112 175 206 102 245 60 86 23 176 154 239 9 158 75 248 30 29 204 37 213 168 102 218 143 80 155 34 138 18 39 88 43 234 92 181 69 182 18 167 211 86 98 151 155 226 250 115 223 140 204 97 113 213 214 239 111 248 107 12 52 195 152 3 174 7 3 115 100 144 123 65 179 232 145 198 198 136 204 63 50 71 102 64 85 154 225 96 160 98 69 124 163 163 204 28 155 35 197 33 234 45 227 82 144 135 115 71 230 176 58 14 218 246 5 253 186 220 38 141 25 4 223 147 240 3 251 147 204 193 251 60 223 184 218 131 146 216 90 116 192 81 84 182 101 239 168 30 123 34 227 151 195 63 92 127 132 22 161 251 198 173 139 56 83 227 203 85 218 142 70 83 203 167 159 135 222 34 144 28 100 139 56 10 95 98 240 127 22 252 166 69 252 74 149 4 85 83 95 77 238 140 46 203 222 87 132 144 195 105 175 198 29 152 11 83 223 78 58 187 179 254 124 185 16 210 90 124 77 184 3 76 76 13 37 253 119 241 253 67 152 170 7 155 112 7 220 130 169 103 146 110 235 202 182 231 48 133 160 3 26 99 234 185 228 14 235 74 47 124 143 81 161 3 155 3 83 79 37 55 77 231 189 159 86 83 42 238 64 142 0 159 89 243 147 185 35 124 210 244 165 16 114 87 53 184 113 7 165 150 131 15 83 122 82 220 39 2 146 86 210 18 165 146 221 79 168 164 147 70 169 185 54 197 239 149 117 89 241 139 62 8 199 170 98 76 64 146 3 165 226 142 153 82 211 29 114 135 228 117 40 94 105 120 94 131 154 78 169 169 85 199 36 191 30 151 200 160 102 176 89 95 14 194 245 201 171 138 199 159 206 106 161 212 204 8 213 45 117 232 15 201 6 213 74 169 105 245 174 253 186 236 139 73 100 80 51 153 174 14 169 13 223 249 38 116 205 98 126 197 55 203 81 191 146 172 72 168 164 147 205 61 164 170 138 250 204 67 57 116 163 164 130 181 221 54 103 140 138 115 32 221 40 36 17 230 50 231 85 4 2 62 201 45 250 90 159 58 111 22 157 53 171 194 235 85 37 77 107 176 139 120 173 12 161 113 246 164 179 146 20 58 155 205 186 79 210 148 160 234 137 58 194 152 53 143 239 60 85 12 60 222 121 127 82 231 48 151 239 145 52 93 244 61 218 10 255 167 230 51 106 181 226 243 74 113 235 25 212 185 76 87 55 124 30 48 186 83 12 106 1 167 194 210 154 162 206 99 187 193 229 81 229 64 76 214 65 106 33 219 148 144 189 124 163 238 51 168 243 185 27 228 14 28 191 38 220 176 128 249 181 214 163 248 167 252 186 16 111 20 203 157 228 61 61 252 218 221 79 88 30 130 14 92 249 9 53 249 85 64 56 229 144 157 81 161 3 55 84 66 77 222 92 195 61 61 89 140 10 29 184 20 242 89 19 151 197 112 239 5 51 163 66 7 238 207 132 154 188 87 135 79 54 22 243 156 215 88 12 87 47 78 77 92 201 194 61 87 79 115 133 174 158 70 47 224 27 131 229 206 116 173 61 110 59 162 208 146 43 92 33 184 145 45 43 135 89 83 222 153 217 54 106 113 156 81 240 253 141 102 20 220 89 78 169 41 39 142 137 241 12 69 168 98 132 42 162 21 140 170 233 94 89 73 80 143 68 168 71 80 49 165 166 2 21 130 117 12 107 80 87 70 168 170 236 63 250 152 218 24 161 54 162 85 204 13 228 102 144 112 195 192 172 171 203 241 13 224 163 12 240 120 141 36 198 162 3 185 29 83 42 238 172 161 84 203 3 42 220 14 30 81 241 165 57 228 112 216 106 72 167 132 109 229 74 233 152 28 203 80 67 251 117 45 75 27 78 85 1 168 54 145 189 74 217 46 167 75 50 190 203 241 173 159 82 113 103 29 165 102 216 148 182 128 226 143 221 1 140 89 215 51 42 153 181 214 31 8 14 167 27 114 23 231 212 107 104 3 165 90 72 126 141 31 29 140 89 55 82 234 204 42 124 172 137 187 220 160 110 98 10 1 20 71 189 38 165 227 111 93 203 40 213 90 167 232 114 179 236 25 78 202 67 212 205 204 229 52 104 76 186 124 11 165 154 225 210 163 171 74 108 49 27 212 173 204 229 14 201 31 156 74 108 219 248 30 146 69 159 114 116 82 161 237 76 33 156 122 171 224 26 245 143 66 59 248 13 0 182 178 154 80 104 96 55 236 36 212 27 102 126 153 139 206 138 191 208 160 84 220 121 145 102 175 228 23 81 151 186 175 191 73 83 20 238 160 93 145 173 172 181 238 142 187 200 80 168 156 38 182 116 50 107 75 165 20 24 230 226 111 23 120 98 131 175 24 42 216 172 46 146 108 38 157 183 155 223 162 96 55 76 185 220 198 168 78 229 248 184 243 6 168 149 60 55 120 224 104 243 140 90 69 221 96 214 218 97 127 53 203 209 204 134 191 232 224 110 128 111 59 170 169 95 147 95 184 132 123 111 95 224 212 219 23 224 46 78 211 252 248 29 61 124 83 206 19 66 21 78 167 29 119 224 30 78 169 79 190 102 164 179 246 247 225 139 81 100 114 186 164 163 247 239 71 94 130 119 4 132 223 193 202 11 221 58 124 99 40 44 192 223 81 58 237 154 78 168 221 250 135 8 165 195 215 9 153 165 206 106 159 134 223 249 15).! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/6/98 12:17'!macDirectoryFile	^ '#include <Files.h>#include <Strings.h>#include "sq.h"/***	The interface to the directory primitive is path based.	That is, the client supplies a Squeak string describing	the path to the directory on every call. To avoid traversing	this path on every call, a cache is maintained of the last	path seen, along with the Mac volume and folder reference	numbers corresponding to that path.***//*** Constants ***/#define ENTRY_FOUND     0#define NO_MORE_ENTRIES 1#define BAD_PATH        2#define DELIMITOR '':''#define MAX_PATH 2000/*** Variables ***/char lastPath[MAX_PATH + 1];int  lastPathValid = false;int  lastRefNum = 0;int  lastVolNum = 0;/*** Functions ***/int convertToSqueakTime(int macTime);int equalsLastPath(char *pathString, int pathStringLength);int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr);int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr);int lookupVolume(char *volName, int *refNumPtr);int prefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);int recordPath(char *pathString, int pathStringLength, int refNum, int volNum);int convertToSqueakTime(int macTime) {	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than Mac one */	return macTime + (3 * 365 * 24 * 60 * 60);}int dir_Create(char *pathString, int pathStringLength) {	/* Create a new directory with the given path. By default, this	   directory is created in the current directory. Use	   a full path name such as "MyDisk:Working:New Folder" to	   create folders elsewhere. */	Str255 name;	HParamBlockRec pb;	int i;	for (i = 0; i < pathStringLength; i++) {		name[i] = pathString[i];	}	name[i] = 0; /* string terminator */	c2pstr((char *) name);	pb.fileParam.ioNamePtr = name;	pb.fileParam.ioVRefNum = 0;	pb.fileParam.ioDirID = 0;	return PBDirCreateSync(&pb) == noErr;}int dir_Delimitor(void) {	return DELIMITOR;}int dir_Lookup(char *pathString, int pathStringLength, int index,  /* outputs: */  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile) {	/* Lookup the index-th entry of the directory with the given path, starting	   at the root of the file system. Set the name, name length, creation date,	   creation time, directory flag, and file size (if the entry is a file).	   Return:	0 	if a entry is found at the given index	   			1	if the directory has fewer than index entries	   			2	if the given path has bad syntax or does not reach a directory	*/	int okay, newRefNum, newVolNum;	HVolumeParam volumeParams;	CInfoPBRec dirParams;	/* default return values */	*name             = 0;	*nameLength       = 0;	*creationDate     = 0;	*modificationDate = 0;	*isDirectory      = false;	*sizeIfFile       = 0;	if ((pathStringLength == 0)) {		/* get volume info */		volumeParams.ioNamePtr = (unsigned char *) name;		volumeParams.ioVRefNum = 0;		volumeParams.ioVolIndex = index;		okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;		if (okay) {			p2cstr((unsigned char *) name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(volumeParams.ioVCrDate);			*modificationDate = convertToSqueakTime(volumeParams.ioVLsMod);			*isDirectory      = true;			*sizeIfFile       = 0;			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	} else {		/* get file or directory info */		if (!!equalsLastPath(pathString, pathStringLength)) {			/* lookup and cache the refNum for this path */			okay = lookupPath(pathString, pathStringLength, &newRefNum, &newVolNum);			if (okay) {				recordPath(pathString, pathStringLength, newRefNum, newVolNum);			} else {				return BAD_PATH;			}		}		dirParams.hFileInfo.ioNamePtr = (unsigned char *) name;		dirParams.hFileInfo.ioFVersNum = 0;		dirParams.hFileInfo.ioFDirIndex = index;		if (lastRefNum < 0) {			dirParams.hFileInfo.ioVRefNum = lastRefNum;			dirParams.hFileInfo.ioDirID = 0;		} else {			dirParams.hFileInfo.ioVRefNum = lastVolNum;			dirParams.hFileInfo.ioDirID = lastRefNum;		}		okay = PBGetCatInfoSync(&dirParams) == noErr;		if (okay) {			p2cstr((unsigned char *) name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(dirParams.hFileInfo.ioFlCrDat);			*modificationDate = convertToSqueakTime(dirParams.hFileInfo.ioFlMdDat);			if ((dirParams.hFileInfo.ioFlAttrib & 16) !!= 0) {				*isDirectory  = true;				*sizeIfFile   = 0;			} else {				*isDirectory  = false;				*sizeIfFile   = dirParams.hFileInfo.ioFlLgLen;			}			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	}}int dir_PathToWorkingDir(char *pathName, int pathNameMax) {	/* Fill in the given string with the full path from a root volume to	   to current working directory. (At startup time, the working directory	   is set to the application''s directory. Fails if the given string is not	   long enough to hold the entire path. (Use at least 1000 characters to	   be safe.)	*/	char thisName[256];	CInfoPBRec pb;	int nextDirRefNum, pathLen;	/* initialize string copying state */	pathName[0] = 0;	pathLen = 0;	/* get refNum of working directory */	strcpy(thisName, ":");	pb.hFileInfo.ioNamePtr = c2pstr(thisName);	pb.hFileInfo.ioVRefNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	if (PBGetCatInfoSync(&pb) !!= noErr) {		nextDirRefNum = 0;	}	nextDirRefNum = pb.hFileInfo.ioDirID;	while (true) {		thisName[0] = 0;		pb.hFileInfo.ioFDirIndex = -1; /* map ioDirID -> name */		pb.hFileInfo.ioVRefNum = 0;		pb.hFileInfo.ioDirID = nextDirRefNum;		if (PBGetCatInfoSync(&pb) !!= noErr) {			break;  /* we''ve reached the root */		}		p2cstr((unsigned char *) thisName);		pathLen = prefixPathWith(pathName, pathLen, pathNameMax, thisName);		nextDirRefNum = pb.dirInfo.ioDrParID;	}	return pathLen;}dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Set the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */	Str255 name;	FInfo finderInfo;	int i;	/* copy file name into a Pascal string */	if (filenameSize > 255) return false;	name[0] = filenameSize;	for (i = 1; i <= filenameSize; i++) {		name[i] = filename[i - 1];	}	if (GetFInfo(name, 0, &finderInfo) !!= noErr) return false;	finderInfo.fdType = *((int *) fType);	finderInfo.fdCreator = *((int *) fCreator);	if (SetFInfo(name, 0, &finderInfo) !!= noErr) return false;	return true;}int equalsLastPath(char *pathString, int pathStringLength) {	/* Return true if the lastPath cache is valid and the	   given Squeak string equals it. */	int i, ch;	if (!!lastPathValid ||		(pathStringLength > MAX_PATH)) {			return false;	}	for (i = 0; i < pathStringLength; i++) {		ch = lastPath[i];		if ((ch == 0) || (ch !!= pathString[i])) return false;	}	return lastPath[i] == 0;}int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr) {	/* Look up the next directory in a path starting from the folder and volume	   with the given reference numbers and setting *refNumPtr to the reference	   number of the resulting folder. Return true if this succeeds. */	CInfoPBRec pb;	c2pstr((char *) name);	pb.hFileInfo.ioNamePtr = (unsigned char *) name;	pb.hFileInfo.ioFVersNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioVRefNum = volRefNum;	pb.hFileInfo.ioDirID = folderRefNum;	if (PBGetCatInfoSync(&pb) == noErr) {		p2cstr((unsigned char *) name);		*refNumPtr = pb.hFileInfo.ioDirID;		return true;	}	p2cstr((unsigned char *) name);	return false;}int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr) {	/* Resolve the given path and return the resulting folder or volume	   reference number in *refNumPtr. Return false if the path is bad. */	char chunk[100];	int stIndex, chunkIndex, ch;	int okay, thisVolNum = 0, thisRefNum = 0;	int firstChunk = true, hasLeadingDelimitors = false;	stIndex = 0;	while (stIndex < pathStringLength) {		chunkIndex = 0;		while ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {			/* copy any leading delimitors */			chunk[chunkIndex++] = pathString[stIndex++];			hasLeadingDelimitors = true;		}		while ((stIndex < pathStringLength) && (pathString[stIndex] !!= DELIMITOR)) {			/* copy up to the next delimitor */			ch = chunk[chunkIndex++] = pathString[stIndex++];		}		if (firstChunk && (chunk[chunkIndex] !!= DELIMITOR)) {			/* Add a trailing delimiter to the first chunk of the			   path to indicate that it is a volume name. If the			   path starts with an initial delimitor, it will be			   interpreted as a path relative to the current working			   directory even with a trailing delimitor, which is			   exactly the behavior we want. */			chunk[chunkIndex++] = DELIMITOR;			if ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {				stIndex++;			}			firstChunk = false;		}		chunk[chunkIndex] = 0;  /* terminate this chunk */		if ((thisVolNum == 0) && !!hasLeadingDelimitors) {			okay = lookupVolume(chunk, &thisVolNum);			thisRefNum = 0;		} else {			okay = lookupDirectory(thisVolNum, thisRefNum, chunk, &thisRefNum);		}		if (!!okay) {			*refNumPtr = 0;			*volNumPtr = 0;			return false;		}	}	*refNumPtr = thisRefNum;	*volNumPtr = thisVolNum;	return true;}int lookupVolume(char *volName, int *refNumPtr) {	/* Look up the volume with the given name and set *refNumPtr	   to the reference number of the resulting volume.	   Return true if this succeeds. */	int okay;	HVolumeParam volumeParams;	volumeParams.ioNamePtr = c2pstr(volName);	volumeParams.ioVRefNum = 0;	volumeParams.ioVolIndex = -1;	okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;	p2cstr((unsigned char *) volName);	if (okay) {		*refNumPtr = volumeParams.ioVRefNum;		return true;	}	return false;}int prefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {	/* Insert the given prefix C string plus a delimitor character at the	   beginning of the given C string. Return the new pathName size. Fails	   if pathName is does not have sufficient space for the result.	   Assume: pathName is null terminated.	*/	int offset, i;	offset = strlen(prefix) + 1;	if ((pathNameSize + offset) > pathNameMax) {		error("path name to working directory is too long for available space");	}	for (i = pathNameSize; i >= 0; i--) {		/* make room in pathName for prefix (moving string terminator, too) */		pathName[i + offset] = pathName[i];	}	for (i = 0; i < offset; i++) {		/* make room in pathName for prefix */		pathName[i] = prefix[i];	}	pathName[offset - 1] = DELIMITOR;  /* insert delimitor */	return pathNameSize + offset;}int recordPath(char *pathString, int pathStringLength, int refNum, int volNum) {	/* Copy the given Squeak string into the lastPath cache. */	int i;	if (pathStringLength > MAX_PATH) {		lastPath[0] = 0; /* set to empty string */		lastPathValid = false;		lastRefNum = 0;		lastVolNum = 0;		return;	}	for (i = 0; i < pathStringLength; i++) {		lastPath[i] = pathString[i];	}	lastPath[i] = 0; /* string terminator */	lastPathValid = true;	lastRefNum = refNum;	lastVolNum = volNum;}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/6/98 12:05'!macDNRFile	^ '/* 		File:		DNR.c 		Contains:	DNR library for MPW  	Copyright:	 1989-1995 by Apple Computer, Inc., all rights reserved	Version:	Technology:			Networking				Package:			Use with MacTCP 2.0.6 and the Universal									Interfaces 2.1b1				Change History (most recent first):		<3>	 1/23/95	rrk  	implemented use of universal procptrs		 						Changed selector name HINFO to HXINFO		 						due to conflict of name in MacTCP header		 						Removed use of TrapAvailable and exchanged		 						for the TrapExists call.								Changed symbol codeHandle to gDNRCodeHndl								Changed symbol dnr to gDNRCodePtr	Further modifications by Steve Falkenburg, Apple MacDTS 8/91	Modifications by Jim Matthews, Dartmouth College, 5/91	*/#ifndef __OSUTILS__#include <OSUtils.h>#endif#ifndef __ERRORS__#include <Errors.h>#endif#ifndef __FILES__#include <Files.h>#endif#ifndef __RESOURCES__#include <Resources.h>#endif#ifndef __MEMORY__#include <Memory.h>#endif#ifndef __TRAPS__#include <Traps.h>#endif#ifndef __GESTALT__#include <Gestalt.h>#endif#ifndef __FOLDERS__#include <Folders.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif#ifndef __MACTCP__#include "MacTCP.h"#endif#ifndef __ADDRESSXLATION__#include "AddressXlation.h"#endif// think C compatibility stuff#ifndef	_GestaltDispatch#define	_GestaltDispatch	_Gestalt#endif/* RRK Modification 1/95 - commenting out the following defines as they are	defined in the DNRCalls.h header file*/void GetSystemFolder(short *vRefNumP, long *dirIDP);void GetCPanelFolder(short *vRefNumP, long *dirIDP);short SearchFolderForDNRP(long targetType, long targetCreator, short vRefNum, long dirID);short OpenOurRF(void);short	NumToolboxTraps(void);TrapType	GetTrapType(short theTrap);Boolean TrapExists(short theTrap);static Handle 			gDNRCodeHndl = nil;static ProcPtr			gDNRCodePtr = nil;/*	Check the bits of a trap number to determine its type. *//* InitGraf is always implemented (trap $A86E).  If the trap table is big** enough, trap $AA6E will always point to either Unimplemented or some other** trap, but will never be the same as InitGraf.  Thus, you can check the size** of the trap table by asking if the address of trap $A86E is the same as** $AA6E. */#pragma segment UtilMainshort	NumToolboxTraps(void){	if (NGetTrapAddress(_InitGraf, ToolTrap) == NGetTrapAddress(0xAA6E, ToolTrap))		return(0x200);	else		return(0x400);}#pragma segment UtilMainTrapType	GetTrapType(short theTrap){	/* OS traps start with A0, Tool with A8 or AA. */	if ((theTrap & 0x0800) == 0)					/* per D.A. */		return(OSTrap);	else		return(ToolTrap);}Boolean TrapExists(short theTrap){	TrapType	theTrapType;	theTrapType = GetTrapType(theTrap);	if ((theTrapType == ToolTrap) && ((theTrap &= 0x07FF) >= NumToolboxTraps()))		theTrap = _Unimplemented;	return(NGetTrapAddress(_Unimplemented, ToolTrap) !!= NGetTrapAddress(theTrap, theTrapType));}void GetSystemFolder(short *vRefNumP, long *dirIDP){	SysEnvRec info;	long wdProcID;		SysEnvirons(1, &info);	if (GetWDInfo(info.sysVRefNum, vRefNumP, dirIDP, &wdProcID) !!= noErr) 	{		*vRefNumP = 0;		*dirIDP = 0;	}}void GetCPanelFolder(short *vRefNumP, long *dirIDP){	Boolean hasFolderMgr = false;	long feature;		if (TrapExists(_GestaltDispatch)) if (Gestalt(gestaltFindFolderAttr, &feature) == noErr) hasFolderMgr = true;	if (!!hasFolderMgr) 	{		GetSystemFolder(vRefNumP, dirIDP);		return;	}	else 	{		if (FindFolder(kOnSystemDisk, kControlPanelFolderType, kDontCreateFolder, vRefNumP, dirIDP) !!= noErr) 		{			*vRefNumP = 0;			*dirIDP = 0;		}	}}	/* SearchFolderForDNRP is called to search a folder for files that might 	contain the ''dnrp'' resource */short SearchFolderForDNRP(long targetType, long targetCreator, short vRefNum, long dirID){	HParamBlockRec fi;	Str255 filename;	short refnum;		fi.fileParam.ioCompletion = nil;	fi.fileParam.ioNamePtr = filename;	fi.fileParam.ioVRefNum = vRefNum;	fi.fileParam.ioDirID = dirID;	fi.fileParam.ioFDirIndex = 1;		while (PBHGetFInfo(&fi, false) == noErr) 	{		/* scan system folder for driver resource files of specific type & creator */		if (fi.fileParam.ioFlFndrInfo.fdType == targetType &&			fi.fileParam.ioFlFndrInfo.fdCreator == targetCreator) 		{			/* found the MacTCP driver file? */			refnum = HOpenResFile(vRefNum, dirID, filename, fsRdPerm);			if (GetIndResource(''dnrp'', 1) == NULL)				CloseResFile(refnum);			else				return refnum;		}		/* check next file in system folder */		fi.fileParam.ioFDirIndex++;		fi.fileParam.ioDirID = dirID;	/* PBHGetFInfo() clobbers ioDirID */	}	return(-1);}	/* OpenOurRF is called to open the MacTCP driver resources */short OpenOurRF(void){	short refnum;	short vRefNum;	long dirID;		/* first search Control Panels for MacTCP 1.1 */	GetCPanelFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP(''cdev'', ''ztcp'', vRefNum, dirID);	if (refnum !!= -1) return(refnum);			/* next search System Folder for MacTCP 1.0.x */	GetSystemFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP(''cdev'', ''mtcp'', vRefNum, dirID);	if (refnum !!= -1) return(refnum);			/* finally, search Control Panels for MacTCP 1.0.x */	GetCPanelFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP(''cdev'', ''mtcp'', vRefNum, dirID);	if (refnum !!= -1) return(refnum);			return -1;}	OSErr OpenResolver(char *fileName){	short 			refnum;	OSErr 			rc;		if (gDNRCodePtr !!= nil)		/* resolver already loaded in */		return(noErr);			/* open the MacTCP driver to get DNR resources. Search for it based on	   creator & type rather than simply file name */		refnum = OpenOurRF();	/* ignore failures since the resource may have been installed in the 	   System file if running on a Mac 512Ke */	   	/* load in the DNR resource package */	gDNRCodeHndl = GetIndResource(''dnrp'', 1);	if (gDNRCodeHndl == nil)	{		/* can''t open DNR */		return(ResError());	}		DetachResource(gDNRCodeHndl);	if (refnum !!= -1) 	{		CloseResFile(refnum);	}			/* lock the DNR resource since it cannot be reloated while opened */	MoveHHi(gDNRCodeHndl);	HLock(gDNRCodeHndl);		gDNRCodePtr = (ProcPtr)*gDNRCodeHndl;		/* call open resolver */	// RRK modification 1/95 use CallOpenResolverProc define to call UPP		rc = CallOpenResolverProc(gDNRCodePtr, OPENRESOLVER, fileName);	if (rc !!= noErr) 	{		/* problem with open resolver, flush it */		HUnlock(gDNRCodeHndl);		DisposeHandle(gDNRCodeHndl);		gDNRCodePtr = nil;	}	return(rc);}OSErr CloseResolver(void){		if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			/* call close resolver */	// RRK modification 1/95 use CallCloseResolverProc define to call UPP	// (void) (*dnr)(CLOSERESOLVER);	CallCloseResolverProc(gDNRCodePtr, CLOSERESOLVER);		/* release the DNR resource package */	HUnlock(gDNRCodeHndl);	DisposeHandle(gDNRCodeHndl);	gDNRCodePtr = nil;	return(noErr);}	// RRK modification 1/95 declare parameter resultProc to be of type 	// ResultProcUPP instead of a long	OSErr StrToAddr(char *hostName, struct hostInfo *rtnStruct, 			ResultUPP resultproc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallStrToAddrProc define to call UPP	// return((*dnr)(STRTOADDR, hostName, rtnStruct, resultproc, userDataPtr));				return (CallStrToAddrProc(gDNRCodePtr, STRTOADDR, hostName, rtnStruct, resultproc, userDataPtr));}	OSErr AddrToStr(unsigned long addr, char *addrStr){	OSErr	err;	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallAddrToStrProc define to call UPP	// (*dnr)(ADDRTOSTR, addr, addrStr);		err = CallAddrToStrProc(gDNRCodePtr, ADDRTOSTR, addr, addrStr);	return(noErr);}	OSErr EnumCache(EnumResultUPP resultproc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallEnumCacheProc define to call UPP	// return((*dnr)(ENUMCACHE, resultproc, userDataPtr));	return (CallEnumCacheProc(gDNRCodePtr, ENUMCACHE, resultproc, userDataPtr));}		OSErr AddrToName(unsigned long addr, struct hostInfo *rtnStruct, 			ResultUPP resultproc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallAddrToNameProc define to call UPP	// return((*dnr)(ADDRTONAME, addr, rtnStruct, resultproc, userDataPtr));	return(CallAddrToNameProc(gDNRCodePtr, ADDRTONAME, addr, rtnStruct, resultproc, userDataPtr));}extern OSErr HInfo(char *hostName, struct returnRec *returnRecPtr, 			ResultProc2UPP resultProc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallHInfoProc define to call UPP	// return((*dnr)(HINFO, hostName, returnRecPtr, resultProc, userDataPtr));	return(CallHInfoProc(gDNRCodePtr, HXINFO, hostName, returnRecPtr, resultProc, userDataPtr));}	extern OSErr MXInfo(char *hostName, struct returnRec *returnRecPtr, 			ResultProc2UPP resultProc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallHInfoProc define to call UPP	// return((*dnr)(MXINFO, hostName, returnRecPtr, resultProc, userDataPtr));	return(CallMXInfoProc(gDNRCodePtr, MXINFO, hostName, returnRecPtr, resultProc, userDataPtr));}	/* removed ; (causes syntax err in Think C 5.0 */	'.! !!InterpreterSupportCode class methodsFor: 'source files'!macJoystickFile	^ '#include <DeskBus.h>#include "sq.h"#define MOUSESTICK_SIGNATURE 0x4A656666#define MAX_STICKS 4typedef struct {	short			rawX;				/* absolute stick position */	short			rawY;	unsigned char	buttons;	char			private1;	short			cursorX;			/* cursor position */	short			cursorY;	char			oldStickType;	char			private2;	char			stickOn;			/* true if stick is connected */	char			private3;	char			stickControlsCursor;	char			applicationAware;	/* settings change with application changes */	char			private4[152];} MouseStickRec;typedef struct {	long			signature;	char			private1[18];	short			stickCount;	char			private2[22];	MouseStickRec	stick[MAX_STICKS];} MouseStickSetRec, *MouseStickSetPtr;/*** Variables ***/MouseStickSetPtr joySticks = nil;  /* pointer to a joystick set or nil */int joystickInit(void) {	/* If a joystick is plugged in and its control panel is installed,	   initialize the global pointer ''joySticks'' to the joystick set	   data structure. Otherwise, set it to nil.	*/	ADBDataBlock adbGetInfo;	MouseStickSetPtr sticks;	int count, i;	joySticks = nil;  /* set to nil in case we don''t find any joysticks */	count = CountADBs();	for (i = 1; i <= count; i++) {		GetADBInfo(&adbGetInfo, GetIndADB(&adbGetInfo, i));		sticks = (MouseStickSetPtr) adbGetInfo.dbDataAreaAddr;		if ((sticks !!= nil) && (sticks->signature == MOUSESTICK_SIGNATURE)) {			joySticks = sticks;			return;		}	}}int joystickRead(int stickIndex) {	/* Return input word for the joystick with the given index (in range [1..2]	   on the Macintosh; other platforms may vary). This word is encoded as follows:		<onFlag (1 bit)><buttonFlags (5 bits)><x-value (11 bits)><y-value (11 bits)>	   The highest four bits of the input word are zero. If the onFlag bit is zero,	   there is no joystick at the given index. This may be because no joystick	   is connected or the joystick control panel is not installed. In such,	   cases, the entire word will be zero. A maximum of two joysticks are supported	   by Gravis''s current version of the control panel. The x and y values are	   11-bit signed values in the range [-1024..1023] representing the raw (unencoded)	   joystick position. The MouseStick II only uses the approximate range [-650..650].	   The range and center values of poorly adjusted joysticks may vary; the client	   software should provide a way to adjust the center and scaling to correct.	*/	MouseStickRec stickData;	int buttons, xBits, yBits;	if ((joySticks == nil) || (stickIndex < 1) || (stickIndex > 2) ||		(stickIndex > joySticks->stickCount)) {			return 0;  /* no joystick at the given index */	}	stickData = joySticks->stick[stickIndex - 1];  /* 1-based index */	buttons = ~stickData.buttons & 0x1F;	xBits = (0x400 + stickData.rawX) & 0x7FF;	yBits = (0x400 + stickData.rawY) & 0x7FF;	return (1 << 27) | (buttons << 22) | (yBits << 11) | xBits;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/6/98 12:18'!macNetworkFile	^ '#include <MacHeaders.h>#include <Events.h>#include <Devices.h>#include <Processes.h>#include <Traps.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "MacTCP.h"#include "AddressXLation.h"#include "sq.h"/*** Socket TYpe Constants ***/#define TCPSocketType 0#define UDPSocketType 1/*** Resolver Status Constants ***/#define RESOLVER_UNINITIALIZED	0#define RESOLVER_SUCCESS		1#define RESOLVER_BUSY			2#define RESOLVER_ERROR			3/* Resolver State */typedef struct {	int				semaIndex;	int				status;	int				error;	int				localAddress;	int				remoteAddress;	struct hostInfo	hostInfo;} ResolverStatusRec, *ResolverStatusPtr;/*** TCP Socket Status Constants ***/#define Unconnected				0#define WaitingForConnection	1#define Connected				2#define OtherEndClosed			3#define ThisEndClosed			4/*** TCP Socket State ***/#define SendBufferSize	( 8 * 1024)#define RecvBufferSize	(16 * 1024)typedef struct {	TCPiopb		tcpPB;				/* TCP parameter block for open/send (must be first) */	TCPiopb		closePB;			/* TCP parameter block for close */	StreamPtr	tcpStream;			/* TCP stream */	void *		next;				/* next socket in a linked list of sockets */	int			semaIndex;	int			connectStatus;	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;//xxx	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} TCPSockRec, *TCPSockPtr;typedef struct {	TCPiopb		tcpPB;	TCPSockPtr	mySocket;	struct wdsEntry wds[2];	char		data[SendBufferSize];} TCPSendBuf, *TCPSendBufPtr;#define SendBufCount 2TCPSendBuf sendBufPool[SendBufCount];int nextSendBuf = 0;/*** UDP Socket Status Constants ***/#define UnknowRemoteAddrAndPort	0#define Ready					1/*** UDP Socket State ***/typedef struct {	void *		next;				/* next socket in a linked list of sockets */	int			remoteAddress;	int			remotePort;	int			semaIndex;	int			connectStatus;	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} UDPSockRec, *UDPSockPtr;/*** Variables ***/short				macTCPRefNum = 0;int					mtuSize = 1024;TCPSockPtr 			openTCPSockets = nil;UDPSockPtr			openUDPSockets = nil;ResolverStatusRec 	resolver = {0, 0, 0, 0, 0, 0, 0};UniversalProcPtr	myExitHandlerProc = nil;UniversalProcPtr	oldExitHandlerProc = nil;ResultUPP			resolverDoneProc = nil;TCPIOCompletionUPP	tcpCloseDoneProc = nil;TCPIOCompletionUPP	tcpConnectDoneProc = nil;TCPNotifyUPP		tcpNotifyProc = nil;TCPIOCompletionUPP	tcpSendDoneProc = nil;UDPNotifyUPP		udpNotifyProc = nil;UDPIOCompletionUPP	udpSendDoneProc = nil;int					thisNetSession = 0;/*** Private TCP Socket Functions ***/void *		TCPSockCreate(void);void		TCPSockDestroy(TCPSockPtr s);void		TCPSockRemoveFromOpenList(TCPSockPtr s);int			TCPSockLocalAddress(TCPSockPtr s);int			TCPSockLocalPort(TCPSockPtr s);int			TCPSockRemoteAddress(TCPSockPtr s);int			TCPSockRemotePort(TCPSockPtr s);void		TCPSockConnectTo(TCPSockPtr s, int addr, int port);void		TCPSockListenOn(TCPSockPtr s, int port);void		TCPSockAbortConnection(TCPSockPtr s);void		TCPSockCloseConnection(TCPSockPtr s);int			TCPSockDataAvailable(TCPSockPtr s);int			TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize);int			TCPSockSendData(TCPSockPtr s, char *buf, int bufSize);/*** Private UDP Socket Functions ***/void *		UDPSockCreate(void);void		UDPSockDestroy(UDPSockPtr s);void		UDPSockRemoveFromOpenList(UDPSockPtr s);int			UDPSockLocalAddress(UDPSockPtr s);int			UDPSockLocalPort(UDPSockPtr s);int			UDPSockRemoteAddress(UDPSockPtr s);int			UDPSockRemotePort(UDPSockPtr s);void		UDPSockConnectTo(UDPSockPtr s, int addr, int port);void		UDPSockListenOn(UDPSockPtr s, int port);int			UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize);int			UDPSockSendData(UDPSockPtr s, char *buf, int bufSize);/*** Other Private Functions ***/void		DestroyAllOpenSockets(void);void		InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr);void		InstallExitHandler(void);void		MyExitHandler(void);int			PortNumberValid(int port);pascal void	ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr);int			ResolverInitialize(int resolverSemaIndex);void		ResolverTerminate(void);int			SocketValid(SocketPtr s);void		TCPCloseCompletionRoutine(struct TCPiopb *s);void		TCPConnectCompletionRoutine(struct TCPiopb *s);pascal void	TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg);void		TCPSendCompletionRoutine(struct TCPiopb *s);/*** Network Functions ***/int sqNetworkInit(int resolverSemaIndex) {	/* initialize the network and return 0 if successful */	int localAddr;	UDPiopb paramBlock;	OSErr err = noErr;	if (thisNetSession !!= 0) return 0;  /* noop if network is already initialized */	/* Create a session ID that is unlikely to be repeated.	   Zero is never used for a valid session number.	   Should be called once at startup time.	*/	/* open resolver */	err = ResolverInitialize(resolverSemaIndex);	if (err !!= noErr) {		return -1;	}	/* get local address */	localAddr = sqResolverLocalAddress();	if (sqResolverError() !!= noErr) {		ResolverTerminate();		return -1;	}	/* compute MTU (maximum transfer unit) size */	memset(&paramBlock, 0, sizeof(paramBlock));	paramBlock.csCode = UDPMaxMTUSize;	paramBlock.csParam.mtu.remoteHost = localAddr;	paramBlock.ioCRefNum = macTCPRefNum;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err == noErr) {		mtuSize = paramBlock.csParam.mtu.mtuSize;		} else {		mtuSize = 1024;  /* guess */		return -1;	}	resolverDoneProc	= NewResultProc(ResolverCompletionRoutine);	tcpCloseDoneProc 	= NewTCPIOCompletionProc(TCPCloseCompletionRoutine);	tcpConnectDoneProc	= NewTCPIOCompletionProc(TCPConnectCompletionRoutine);	tcpNotifyProc		= NewTCPNotifyProc(TCPNotificationRoutine);	tcpSendDoneProc		= NewTCPIOCompletionProc(TCPSendCompletionRoutine);	InstallExitHandler();	/* success!! */	thisNetSession = clock() + time(NULL);	if (thisNetSession == 0) thisNetSession = 1;  /* don''t use 0 */	return 0;}void sqNetworkShutdown(void) {	/* shut down the network */	if (thisNetSession == 0) return;  /* noop if network is already shut down */	ResolverTerminate();	DestroyAllOpenSockets();	thisNetSession = 0;}/*** Squeak Generic Socket Functions ***/void sqSocketAbortConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockAbortConnection((TCPSockPtr) s->privateSocketPtr);	} else {		success(false);	}}void sqSocketCloseConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockCloseConnection((TCPSockPtr) s->privateSocketPtr);	} else {		success(false);	}}int sqSocketConnectionStatus(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->connectStatus;	} else {		return ((UDPSockPtr) s->privateSocketPtr)->connectStatus;	}}void sqSocketConnectToPort(SocketPtr s, int addr, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockConnectTo((TCPSockPtr) s->privateSocketPtr, addr, port);	} else {		UDPSockConnectTo((UDPSockPtr) s->privateSocketPtr, addr, port);	}}void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex) {	TCPSockPtr tcpSock = nil;	UDPSockPtr udpSock = nil;	/* reference args to suppress compiler warnings about unused variables */	s; netType; recvBufSize; sendBufSize;	s->sessionID = 0;	if (socketType == TCPSocketType) {		tcpSock = TCPSockCreate();		if (tcpSock == nil) {			success(false);		} else {			tcpSock->semaIndex = semaIndex;			tcpSock->next = openTCPSockets;			openTCPSockets = tcpSock;			s->sessionID = thisNetSession;			s->socketType = TCPSocketType;			s->privateSocketPtr = tcpSock;		}	} else {		udpSock = UDPSockCreate();		if (udpSock == nil) {			success(false);		} else {			udpSock->semaIndex = semaIndex;			udpSock->next = openUDPSockets;			openUDPSockets = udpSock;			s->sessionID = thisNetSession;			s->socketType = UDPSocketType;			s->privateSocketPtr = udpSock;		}	}}void sqSocketDestroy(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockDestroy((TCPSockPtr) s->privateSocketPtr);	} else {		UDPSockDestroy((UDPSockPtr) s->privateSocketPtr);	}	s->sessionID = 0;	s->socketType = -1;	s->privateSocketPtr = nil;}int sqSocketError(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->lastError;	} else {		return ((UDPSockPtr) s->privateSocketPtr)->lastError;	}}void sqSocketListenOnPort(SocketPtr s, int port) {	if (!!SocketValid(s)) return;	if (!!PortNumberValid(port)) return;	if (s->socketType == TCPSocketType) {		TCPSockListenOn((TCPSockPtr) s->privateSocketPtr, port);	} else {		UDPSockListenOn((UDPSockPtr) s->privateSocketPtr, port);	}}int sqSocketLocalAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalAddress((TCPSockPtr) s->privateSocketPtr);	} else {		return UDPSockLocalAddress((UDPSockPtr) s->privateSocketPtr);	}}int sqSocketLocalPort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalPort((TCPSockPtr) s->privateSocketPtr);	} else {		return UDPSockLocalPort((UDPSockPtr) s->privateSocketPtr);	}}int sqSocketReceiveDataAvailable(SocketPtr s) {	if (!!SocketValid(s)) return 0;	if (s->socketType == TCPSocketType) {		return TCPSockDataAvailable((TCPSockPtr) s->privateSocketPtr);	} else {		return ((UDPSockPtr) s->privateSocketPtr)->dataAvailable;	}}int sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRecvData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	} else {		return UDPSockRecvData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}}int sqSocketRemoteAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemoteAddress((TCPSockPtr) s->privateSocketPtr);	} else {		return UDPSockRemoteAddress((UDPSockPtr) s->privateSocketPtr);	}}int sqSocketRemotePort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemotePort((TCPSockPtr) s->privateSocketPtr);	} else {		return UDPSockRemotePort((UDPSockPtr) s->privateSocketPtr);	}}int sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize) {	int adjustedBufSize = bufSize > 0xFFFF ? 0xFFFF : bufSize;	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockSendData((TCPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	} else {		return UDPSockSendData((UDPSockPtr) s->privateSocketPtr, (char *) buf, adjustedBufSize);	}}int sqSocketSendDone(SocketPtr s) {	if (!!SocketValid(s)) return 1;	if (s->socketType == TCPSocketType) {		return !!((TCPSockPtr) s->privateSocketPtr)->sendInProgress;	} else {		return !!((UDPSockPtr) s->privateSocketPtr)->sendInProgress;	}}/*** Resolver Functions ***/void sqResolverAbort(void) {	int semaIndex;	/* abort the current request */	if (resolver.status == RESOLVER_BUSY) {		semaIndex = resolver.semaIndex;		ResolverTerminate();		ResolverInitialize(semaIndex);	}}void sqResolverAddrLookupResult(char *nameForAddress, int nameSize) {	/* copy the name found by the last address lookup into the given string */	memcpy(nameForAddress, resolver.hostInfo.cname, nameSize);}int sqResolverAddrLookupResultSize(void) {	return strlen(resolver.hostInfo.cname);}int sqResolverError(void) {	return resolver.error;}int sqResolverLocalAddress(void) {	struct GetAddrParamBlock paramBlock;	OSErr err = noErr;	if (resolver.localAddress == 0) {		resolver.remoteAddress = 0;		memset(&paramBlock, 0, sizeof(struct GetAddrParamBlock));		paramBlock.ioResult = 1;		paramBlock.csCode = ipctlGetAddr;		paramBlock.ioCRefNum = macTCPRefNum;		PBControlSync((ParmBlkPtr) &paramBlock);		if (paramBlock.ioResult == noErr) {			resolver.status = RESOLVER_SUCCESS;			resolver.localAddress = paramBlock.ourAddress;			resolver.error = noErr;		} else {			resolver.status = RESOLVER_ERROR;			resolver.error = paramBlock.ioResult;		}	}	return resolver.localAddress;}int sqResolverNameLookupResult(void) {	/* return the result of the last successful lookup */	return resolver.remoteAddress;}void sqResolverStartAddrLookup(int address) {	OSErr err;	resolver.status = RESOLVER_BUSY;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = AddrToName(address, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;	} else {		if (err !!= cacheFault) {			/* unexpected error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}void sqResolverStartNameLookup(char *hostName, int nameSize) {	char name[501];	int len; 	OSErr err;	len = ((nameSize <= 500) ? nameSize : 500);	memcpy(name, hostName, len);	name[len] = ''\0'';	resolver.status = RESOLVER_BUSY;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = StrToAddr(name, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;		resolver.remoteAddress = resolver.hostInfo.addr[0];	} else {		if (err !!= cacheFault) {			/* unexpected error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}int sqResolverStatus(void) {	return resolver.status;}/*** Private Resolver Functions ***/int ResolverInitialize(int resolverSemaIndex) {	OSErr err = noErr;	if (resolver.status !!= RESOLVER_UNINITIALIZED) {		ResolverTerminate();	}	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;//xxx move to network init:	macTCPRefNum = 0;	err = OpenDriver("\p.IPP", &macTCPRefNum);	if (err !!= noErr) {		resolver.error = err;		resolver.status = RESOLVER_ERROR;		return err;	}	err = OpenResolver(nil);	if (err !!= noErr) {		resolver.error = err;		resolver.status = RESOLVER_ERROR;		return err;	}	resolver.semaIndex = resolverSemaIndex;	resolver.status = RESOLVER_SUCCESS;	return noErr;}static pascal void ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr) {	ResolverStatusPtr r = (ResolverStatusPtr) userDataPtr;	/* completion routine */	if (r->hostInfo.rtnCode == noErr) {		r->status = RESOLVER_SUCCESS;		r->remoteAddress = hostInfoPtr->addr[0];	} else {		r->status = RESOLVER_ERROR;		r->error = hostInfoPtr->rtnCode;	}	signalSemaphoreWithIndex(r->semaIndex);}void ResolverTerminate(void) {	CloseResolver();	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;}/*** Private TCP Socket Functions ***/void * TCPSockCreate(void) {	TCPiopb paramBlock;	TCPSockPtr s = nil;	int minRcvBufSize, rcvBufSize;	OSErr err = noErr;	rcvBufSize = RecvBufferSize;	minRcvBufSize = (4 * mtuSize) + 1024;	if (rcvBufSize < minRcvBufSize) rcvBufSize = minRcvBufSize;		s = (TCPSockPtr) malloc(sizeof(TCPSockRec) + rcvBufSize);	if (s == nil) return nil;  /* allocation failed */	memset(s, 0, sizeof(TCPSockRec) + rcvBufSize);	InitTCPCmd(TCPCreate, nil, &paramBlock);	paramBlock.csParam.create.rcvBuff = s->rcvBuf;	paramBlock.csParam.create.rcvBuffLen = rcvBufSize;	paramBlock.csParam.create.notifyProc = tcpNotifyProc;	paramBlock.csParam.create.userDataPtr = (Ptr) s;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		free(s);		return nil;	}	s->tcpStream = paramBlock.tcpStream;	return s;}int TCPSockDataAvailable(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return false;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.amtUnreadData > 0;}void TCPSockDestroy(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return;  /* already destroyed */	}	InitTCPCmd(TCPRelease, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	TCPSockRemoveFromOpenList(s);	s->tcpStream = nil;	free(s);}int TCPSockLocalAddress(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localHost;}int TCPSockLocalPort(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localPort;}int TCPSockRemoteAddress(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remoteHost;}int TCPSockRemotePort(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remotePort;}void TCPSockRemoveFromOpenList(TCPSockPtr s) {	TCPSockPtr thisSock, nextSock, previousSock;	previousSock = nil;	for (thisSock = openTCPSockets; thisSock !!= nil; thisSock = nextSock) {		nextSock = thisSock->next;		if (thisSock == s) {			if (previousSock == nil) {				openTCPSockets = nextSock;			} else {				previousSock->next = nextSock;			}			break;		}		previousSock = thisSock;	}}void TCPSockConnectTo(TCPSockPtr s, int addr, int port) {	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPActiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.remoteHost = addr;	s->tcpPB.csParam.open.remotePort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	err = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (err !!= noErr) {		s->connectStatus = Unconnected;		s->lastError = err;	}}void TCPSockListenOn(TCPSockPtr s, int port) {	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPPassiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.localPort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	err = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (err !!= noErr) {		s->connectStatus = Unconnected;		s->lastError = err;	}}void TCPSockCloseConnection(TCPSockPtr s) {	/* Note: This operation uses a dedicated parameter block so that it	   can be invoked even in the previous send is not yet complete.	   It will eventually use a completion routine to delete the	   socket automatically. For now, this is the client''s responsibility.	*/	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPClose, s->tcpStream, &s->closePB);//	s->closePB.ioCompletion = tcpCloseDoneProc;	s->connectStatus = ThisEndClosed; // xxx remove when making this async	s->lastError = PBControlSync((ParmBlkPtr) &s->closePB);}void TCPSockAbortConnection(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPAbort, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	s->connectStatus = Unconnected;}int TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize) {	TCPiopb paramBlock;  /* use local parameter block since send may be using one in socket */	OSErr err = noErr;	int bytesRead;	if (!!TCPSockDataAvailable(s)) return 0;  /* no data available */	InitTCPCmd(TCPRcv, s->tcpStream, &paramBlock);	paramBlock.csParam.receive.commandTimeoutValue = 1; /* finish in one second, data or not */	paramBlock.csParam.receive.rcvBuff = buf;	paramBlock.csParam.receive.rcvBuffLen = bufSize;	err = PBControlSync((ParmBlkPtr) &paramBlock);  /* synchronous */	if (err == noErr) {		bytesRead = paramBlock.csParam.receive.rcvBuffLen;	} else {		/* if err == commandTimeout, no data was available */		bytesRead = 0;		if (!!((err == commandTimeout) || (err == connectionClosing))) {			s->lastError = err;		}	}	s->dataAvailable = (bytesRead !!= 0);  /* if we got data, there may be more */	return bytesRead;}int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize);int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	int sendCount;	OSErr err = noErr;	struct wdsEntry wds[2];	buf;  /* xxx avoid compiler complaint about unreferenced vars */	/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;//xxx	memcpy(s->sendBuf, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	wds[0].length = sendCount;//xxx		wds[0].ptr = s->sendBuf;	wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.send.wdsPtr = (Ptr) &wds;	s->tcpPB.csParam.send.pushFlag = true;	s->sendInProgress = true;	s->tcpPB.ioCompletion = tcpSendDoneProc;	err = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (err !!= noErr) {		s->sendInProgress = false;		s->lastError = err;		return 0;	}	return sendCount;}int TCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	TCPSendBufPtr sendBuf;	OSErr err = noErr;	int sendCount;	sendBuf = &sendBufPool[nextSendBuf++];	if (nextSendBuf >= SendBufCount) nextSendBuf = 0;	sendBuf->mySocket = s;		/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;	memcpy(sendBuf->data, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	sendBuf->wds[0].length = sendCount;	sendBuf->wds[0].ptr = sendBuf->data;	sendBuf->wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &sendBuf->tcpPB);	sendBuf->tcpPB.csParam.send.wdsPtr = (Ptr) &sendBuf->wds;	sendBuf->tcpPB.csParam.send.pushFlag = true;	sendBuf->tcpPB.ioCompletion = tcpSendDoneProc;	s->sendInProgress = true;	err = PBControlAsync((ParmBlkPtr) &sendBuf->tcpPB);	if (err !!= noErr) {		s->sendInProgress = false;		s->lastError = err;		return 0;	}	return sendCount;}/*** Private General Utilities ***/void DestroyAllOpenSockets(void) {	while (openTCPSockets !!= nil) {		TCPSockDestroy(openTCPSockets);  /* removes socket from the list */	}	while (openUDPSockets !!= nil) {		UDPSockDestroy(openUDPSockets);  /* removes socket from the list */	}}void InstallExitHandler(void) {	/* Install a handler to release all open sockets when terminating this	   application. The handler will be called even if you type ''es'' to	   MacsBug or use Command-Option-Escape for force the program to exit.	   The handler is only installed the first time the network is initialized.	*/	if (oldExitHandlerProc == nil) {		oldExitHandlerProc = GetToolTrapAddress(_ExitToShell);		myExitHandlerProc = 			NewRoutineDescriptor((ProcPtr) MyExitHandler, kPascalStackBased, GetCurrentISA());		SetToolTrapAddress(myExitHandlerProc, _ExitToShell);	}}void MyExitHandler(void) {	SetCurrentA5();	SetToolTrapAddress(oldExitHandlerProc, _ExitToShell);	DestroyAllOpenSockets();	ExitToShell();}int PortNumberValid(int port) {	if (port < 0xFFFF) {		return true;	}	success(false);	return false;}int SocketValid(SocketPtr s) {	if ((s !!= NULL) &&		(s->privateSocketPtr !!= NULL) &&		(s->sessionID == thisNetSession)) {			if (s->socketType == TCPSocketType) {				if (((TCPSockPtr) s->privateSocketPtr)->tcpStream !!= nil) {					return true;				}			}	}	success(false);	return false;}/*** Private TCP Utilities ***/void InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr) {	memset(paramBlkPtr, 0, sizeof(TCPiopb));	paramBlkPtr->csCode = cmd;	paramBlkPtr->tcpStream = tcpStream;	paramBlkPtr->ioCRefNum = macTCPRefNum;	paramBlkPtr->ioResult = 1;}void TCPCloseCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		if (s->connectStatus == OtherEndClosed) {			s->connectStatus = Unconnected;		} else {			s->connectStatus = ThisEndClosed;		}	}	signalSemaphoreWithIndex(s->semaIndex);}void TCPConnectCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		s->connectStatus = Connected;	} else {		s->connectStatus = Unconnected;	}	signalSemaphoreWithIndex(s->semaIndex);}pascal void TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg) {	/* called when data arrives or stream status changes */	/* reference args to suppress compiler warnings about unused variables */	s; terminReason; icmpMsg;		if (eventCode == TCPDataArrival) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->dataAvailable = true;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPClosing) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		if (tcpSock->connectStatus == ThisEndClosed) {			tcpSock->connectStatus = Unconnected;		} else {			tcpSock->connectStatus = OtherEndClosed;		}		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}	if (eventCode == TCPTerminate) {		TCPSockPtr tcpSock = (TCPSockPtr) userDataPtr;		tcpSock->connectStatus = Unconnected;		signalSemaphoreWithIndex(tcpSock->semaIndex);		return;	}}void TCPSendCompletionRoutine(struct TCPiopb *pbPtr) {//xxx	TCPSockPtr s = (TCPSockPtr) pbPtr;TCPSockPtr s = ((TCPSendBufPtr) pbPtr)->mySocket;		s->lastError = s->tcpPB.ioResult;	s->sendInProgress = false;	signalSemaphoreWithIndex(s->semaIndex);}/*** Private UDP Socket Functions ***/void *		UDPSockCreate(void) {	// xxx	return nil;}void		UDPSockDestroy(UDPSockPtr s) {	// xxx	s;}int			UDPSockLocalAddress(UDPSockPtr s) {	// xxx	s;}int			UDPSockLocalPort(UDPSockPtr s) {	// xxx	s;}int			UDPSockRemoteAddress(UDPSockPtr s) {	// xxx	s;}int			UDPSockRemotePort(UDPSockPtr s) {	// xxx	s;}void		UDPSockConnectTo(UDPSockPtr s, int addr, int port) {	// xxx	s; addr; port;}void		UDPSockListenOn(UDPSockPtr s, int port) {	// xxx	s; port;}int			UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize) {	// xxx	s; buf; bufSize;}int			UDPSockSendData(UDPSockPtr s, char *buf, int bufSize) {	// xxx	s; buf; bufSize;}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/6/98 12:16'!macSoundFile	^ '#include "sq.h"#include <Sound.h>#include <SoundInput.h>/******  Mac Sound Output Notes:	The Squeak sound code produces 16-bit, stereo sound buffers. The was	arrived at after experimentation on a PPC 601 at 110 MHz on which I	found that:	  a. using 16-bit sound only slightly increased the background CPU burden and	  b. 16-bit sound yielded vastly superior sound quality.	My understanding is that SoundManager 3.0 or later supports the 16-bit	sound interface an all Macs, even if the hardware only supports 8-bits.	If this is not true, however, change BYTES_PER_SAMPLE to 1. Then, either	the Squeak code will need to be changed to use 8-bit sound buffers,	or (preferrably) snd_PlaySamplesFromAtLength will need to do the conversion	from 16 to 8 bits. I plan to cross that bridge if and when we need to.	The code as currently written was to support Squeak code that generated	8-bit sound buffers.	In earlier versions, I experimented with other sound buffer formats. Here	are all the sound buffer formats that were used at one point or another:		1. mono,    8-bits -- packed array of bytes (not currently used)		2. stereo,  8-bits -- as above, with L and R channels in alternate bytes (not currently used)		3. stereo, 16-bits -- array of 32-bit words; with L and R channels in high and low half-words	Note:  8-bit samples are encoded with 0x80 as the center (zero) value	Note: 16-bit samples are encoded as standard, signed integers (i.e., 2''s-complement)	Note: When the sound drive is operating in "mono", the two stereo channels are mixed	      together. This feature was added in January, 1998.	-- John Maloney, July 28, 1996	-- edited: John Maloney, January 5, 1998  Mac Sound Input Notes:	Squeak sound input is currently defined to provide a single (mono) stream	of signed 16-bit samples for all platforms. Platforms that only support	8-bit sound input should convert samples to signed 16 bit values, leaving	the low order bits zero. Since the available sampling rates differ from	platform to platform, the client may not get the requested sampling rate;	however, the call snd_GetRecordingSampleRate returns the sampling rate.	On many platforms, simultaneous record and playback is permitted only if	the input and output sampling rates are the same.	-- John Maloney, Aug 22, 1997******/#define BYTES_PER_SAMPLE 2/*** double-buffer state record ***/typedef struct {	int open;	int stereo;	int frameCount;	int sampleRate;	int lastFlipTime;	int playSemaIndex;	int bufSizeInBytes;	int bufState0;	int bufState1;	int done;} PlayStateRec;/*** possible buffer states ***/#define BUF_EMPTY	0#define BUF_FULL	1#define BUF_PLAYING	2/*** record buffer state record ***//* Note: RECORD_BUFFER_SIZE should be a multiple of 4096 bytes to avoid clicking.   (The clicking was observed on a Mac 8100; the behavior of other Macs could differ.)*/#define RECORD_BUFFER_SIZE (4096 * 1)typedef struct {	SPB paramBlock;	int stereo;	int bytesPerSample;	int recordSemaIndex;	int readIndex;  /* index of the next sample to read */	char samples[RECORD_BUFFER_SIZE];} RecordBufferRec, *RecordBuffer;/*** sound output variables ***/SndChannelPtr chan;PlayStateRec bufState = {false, false, 0, 0, NULL, NULL, true, 0};SndDoubleBufferHeader dblBufHeader;/*** sound input variables ***/RecordBufferRec recordBuffer1, recordBuffer2;int recordingInProgress;long soundInputRefNum;/*** local functions ***/pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf);int FillBufferWithSilence(SndDoubleBufferPtr buf);pascal void FlipRecordBuffers(SPBPtr pb);int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex);pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf) {	PlayStateRec *state;	chan;  /* reference argument to avoid compiler warnings */	/* insert a click to help user detect failure to fill buffer in time */	*(unsigned int *) &buf->dbSoundData[0] = 0;	*(unsigned int *) &buf->dbSoundData[4] = 0xFFFFFFFF;	state = (PlayStateRec *) buf->dbUserInfo[0];	if (buf->dbUserInfo[1] == 0) {		state->bufState0 = BUF_EMPTY;		state->bufState1 = BUF_PLAYING;	} else {		state->bufState0 = BUF_PLAYING;		state->bufState1 = BUF_EMPTY;	}	buf->dbNumFrames = state->frameCount;	buf->dbFlags = buf->dbFlags | dbBufferReady;	if (state->done) {		FillBufferWithSilence(buf);		buf->dbFlags = buf->dbFlags | dbLastBuffer;	} else {		signalSemaphoreWithIndex(state->playSemaIndex);	}	state->lastFlipTime = ioMicroMSecs();}int FillBufferWithSilence(SndDoubleBufferPtr buf) {	unsigned int *sample, *lastSample;	sample		= (unsigned int *) &buf->dbSoundData[0];	lastSample	= (unsigned int *) &buf->dbSoundData[bufState.bufSizeInBytes];	/* word-fill buffer with silence */	if (BYTES_PER_SAMPLE == 1) {		while (sample < lastSample) {			*sample++ = 0x80808080;  /* Note: 0x80 is zero value for 8-bit samples */		}	} else {		while (sample < lastSample) {			*sample++ = 0;		}	}}pascal void FlipRecordBuffers(SPBPtr pb) {	/* called at interrupt time to exchange the active and inactive record buffers */	RecordBuffer thisBuffer = (RecordBuffer) pb;	RecordBuffer nextBuffer = (RecordBuffer) pb->userLong;	if (pb->error == 0) {		/* restart recording using the other buffer */		SPBRecord(&nextBuffer->paramBlock, true);		/* reset the read pointer for the buffer that has just been filled */		thisBuffer->readIndex = 0;		signalSemaphoreWithIndex(nextBuffer->recordSemaIndex);	}}/*** exported sound output functions ***/int snd_AvailableSpace(void) {	if (!!bufState.open) return -1;	if ((bufState.bufState0 == BUF_EMPTY) ||		(bufState.bufState1 == BUF_EMPTY)) {			return bufState.bufSizeInBytes;	}	return 0;}int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex) {	SndDoubleBufferPtr buf;	int framesWritten;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		buf = dblBufHeader.dbhBufferPtr[0];		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			buf = dblBufHeader.dbhBufferPtr[1];			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	if (bufState.frameCount < frameCount) {		framesWritten = bufState.frameCount;	} else {		framesWritten = frameCount;	}	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) (arrayIndex + startIndex);		end = (unsigned char *) src + (framesWritten * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) &buf->dbSoundData[0];		while (src < end) {			*dst++ = *src++;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (arrayIndex + (startIndex * 4));		end = (short int *) (arrayIndex + ((startIndex + framesWritten) * 4));		dst = (short int *) &buf->dbSoundData[0];		if (bufState.stereo) {  /* stereo */			while (src < end) {				*dst++ = *src++;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			while (src < end) {				*dst++ = (*src++ + *src++) / 2;			}		}	}	return framesWritten;}int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex) {	int sample;	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) srcBufPtr + srcStartIndex;		end = (unsigned char *) srcBufPtr + (count * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) dstBufPtr + dstStartIndex;		while (src < end) {			sample = *dst + (*src++ - 128);			if (sample > 255) sample = 255;			if (sample < 0) sample = 0;			*dst++ = sample;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (srcBufPtr + (srcStartIndex * 4));		end = (short int *) (srcBufPtr + ((srcStartIndex + count) * 4));		if (bufState.stereo) {  /* stereo */			dst = (short int *) (dstBufPtr + (dstStartIndex * 4));			while (src < end) {				sample = *dst + *src++;				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			dst = (short int *) (dstBufPtr + (dstStartIndex * 2));			while (src < end) {				sample = *dst + ((*src++ + *src++) / 2);				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		}	}}int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime) {	SndDoubleBufferPtr bufPlaying, otherBuf;	int samplesInserted, startSample, count;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_PLAYING) {		bufPlaying = dblBufHeader.dbhBufferPtr[0];		otherBuf = dblBufHeader.dbhBufferPtr[1];	} else {		bufPlaying = dblBufHeader.dbhBufferPtr[1];		otherBuf = dblBufHeader.dbhBufferPtr[0];	}	samplesInserted = 0;	/* mix as many samples as can fit into the remainder of the currently playing buffer */	startSample =		((bufState.sampleRate * (ioMicroMSecs() - bufState.lastFlipTime)) / 1000) + samplesOfLeadTime;	if (startSample < bufState.frameCount) {		count = bufState.frameCount - startSample;		if (count > frameCount) count = frameCount;		MixInSamples(count, (char *) srcBufPtr, 0, &bufPlaying->dbSoundData[0], startSample);		samplesInserted = count;	}	/* mix remaining samples into the inactive buffer */	count = bufState.frameCount;	if (count > (frameCount - samplesInserted)) {		count = frameCount - samplesInserted;	}	MixInSamples(count, (char *) srcBufPtr, samplesInserted, &otherBuf->dbSoundData[0], 0);	return samplesInserted + count;}int snd_PlaySilence(void) {	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		FillBufferWithSilence(dblBufHeader.dbhBufferPtr[0]);		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			FillBufferWithSilence(dblBufHeader.dbhBufferPtr[1]);			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	return bufState.bufSizeInBytes;}int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex) {	OSErr				err;	SndDoubleBufferPtr	buffer;	int					bytesPerFrame, bufferBytes, i;	bytesPerFrame			= stereo ? 2 * BYTES_PER_SAMPLE : BYTES_PER_SAMPLE;	bufferBytes				= ((frameCount * bytesPerFrame) / 8) * 8;		/* Note: Must round bufferBytes down to an 8-byte boundary to avoid clicking!!!!!! */	if (bufState.open) {		/* still open from last time; clean up before continuing */		snd_Stop();	}	bufState.open			= false;  /* set to true if successful */	bufState.stereo			= stereo;	bufState.frameCount		= bufferBytes / bytesPerFrame;	bufState.sampleRate		= samplesPerSec;	bufState.lastFlipTime	= ioMicroMSecs();	bufState.playSemaIndex	= semaIndex;	bufState.bufSizeInBytes	= bufferBytes;	bufState.bufState0		= BUF_EMPTY;	bufState.bufState1		= BUF_EMPTY;	bufState.done			= false;	dblBufHeader.dbhNumChannels		= stereo ? 2 : 1;	dblBufHeader.dbhSampleSize		= BYTES_PER_SAMPLE * 8;	dblBufHeader.dbhCompressionID	= 0;	dblBufHeader.dbhPacketSize		= 0;	dblBufHeader.dbhSampleRate		= samplesPerSec << 16; /* convert to fixed point */	dblBufHeader.dbhDoubleBack		= NewSndDoubleBackProc(DoubleBack);	chan = NULL;	err = SndNewChannel(&chan, sampledSynth, 0, NULL);	if (err !!= noErr) return false; /* could not open sound channel */	for (i = 0; i < 2; i++) {		buffer = (SndDoubleBufferPtr) NewPtrClear(sizeof(SndDoubleBuffer) + bufState.bufSizeInBytes);		if (buffer == NULL) return false; /* could not allocate memory for a buffer */		buffer->dbNumFrames		= bufState.frameCount;		buffer->dbFlags			= dbBufferReady;		buffer->dbUserInfo[0]	= (long) &bufState;		buffer->dbUserInfo[1]	= i;		FillBufferWithSilence(buffer);		dblBufHeader.dbhBufferPtr[i] = buffer;	}	err = SndPlayDoubleBuffer(chan, &dblBufHeader);	if (err !!= noErr) return false; /* could not play double buffer */	bufState.open = true;	return true;}int snd_Stop(void) {	OSErr				err;	SndDoubleBufferPtr	buffer;	SCStatus			status;	long				i, junk;	if (!!bufState.open) return;	bufState.open = false;	bufState.done = true;	while (true) {		err = SndChannelStatus(chan, sizeof(status), &status);		if (err !!= noErr) break; /* could not get channel status */		if (!!status.scChannelBusy) break;		Delay(1, &junk);	}	SndDisposeChannel(chan, true);	DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);	for (i = 0; i < 2; i++) {		buffer = dblBufHeader.dbhBufferPtr[i];		if (buffer !!= NULL) {			DisposePtr((char *) buffer);		}		dblBufHeader.dbhBufferPtr[i] = NULL;	}	bufState.open = false;}/*** exported sound input functions ***/int snd_SetRecordLevel(int level) {	/* set the recording level to a value between 0 (minimum gain) and 1000. */	Fixed inputGainArg;	int err;	if (!!recordingInProgress || (level < 0) || (level > 1000)) {		success(false);		return;  /* noop if not recording */	}	inputGainArg = ((500 + level) << 16) / 1000;  /* gain is Fixed between 0.5 and 1.5 */	err = SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	/* don''t fail on error; hardware may not support setting the gain */}int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex) {	/* turn on sound recording, trying to use a sampling rate close to	   the one specified. semaIndex is the index in the exportedObject	   array of a semaphore to be signalled when input data is available. */	Str255 deviceName = "";	short automaticGainControlArg;	Fixed inputGainArg;	long  compressionTypeArg;	short continuousArg;	short sampleSizeArg;	short channelCountArg;	UnsignedFixed sampleRateArg;	int err;	err = SPBOpenDevice(deviceName, siWritePermission, &soundInputRefNum);	if (err !!= noErr) {		success(false);		return;	}	/* try to initialize some optional parameters, but don''t fail if we can''t */	automaticGainControlArg = false;	SPBSetDeviceInfo(soundInputRefNum, siAGCOnOff, &automaticGainControlArg);	inputGainArg = 1 << 16;  /* 1.0 in Fixed */	SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	compressionTypeArg = ''NONE'';	SPBSetDeviceInfo(soundInputRefNum, siCompressionType, &compressionTypeArg);	continuousArg = true;	err = SPBSetDeviceInfo(soundInputRefNum, siContinuous, &continuousArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	sampleSizeArg = 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);	if (err !!= noErr) {		/* use 8-bit samples */		sampleSizeArg = 8;		err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);		if (err !!= noErr) {			success(false);			SPBCloseDevice(soundInputRefNum);			return;		}	}	channelCountArg = stereo ? 2 : 1;	err = SPBSetDeviceInfo(soundInputRefNum, siNumberChannels, &channelCountArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	/* try to set the client''s desired sample rate */	sampleRateArg = desiredSamplesPerSec << 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		/* if client''s rate fails, try the nearest common sampling rates in {11025, 22050, 44100} */		if (desiredSamplesPerSec <= 16538) {			sampleRateArg = 11025 << 16;		} else {			if (desiredSamplesPerSec <= 33075) {				sampleRateArg = 22050 << 16;			} else {				sampleRateArg = 44100 << 16;			}		}		/* even if following fails, recording can go on at the default sample rate */		SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	}	recordBuffer1.paramBlock.inRefNum = soundInputRefNum;	recordBuffer1.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.milliseconds = 0;	recordBuffer1.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.bufferPtr = recordBuffer1.samples;	recordBuffer1.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer1.paramBlock.interruptRoutine = nil;	recordBuffer1.paramBlock.userLong = (long) &recordBuffer2;  /* pointer to other buffer */	recordBuffer1.paramBlock.error = noErr;	recordBuffer1.paramBlock.unused1 = 0;	recordBuffer1.stereo = stereo;	recordBuffer1.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer1.recordSemaIndex = semaIndex;	recordBuffer1.readIndex = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.inRefNum = soundInputRefNum;	recordBuffer2.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.milliseconds = 0;	recordBuffer2.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.bufferPtr = recordBuffer2.samples;	recordBuffer2.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer2.paramBlock.interruptRoutine = nil;	recordBuffer2.paramBlock.userLong = (long) &recordBuffer1;  /* pointer to other buffer */	recordBuffer2.paramBlock.error = noErr;	recordBuffer2.paramBlock.unused1 = 0;	recordBuffer2.stereo = stereo;	recordBuffer2.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer2.recordSemaIndex = semaIndex;	recordBuffer2.readIndex = RECORD_BUFFER_SIZE;	err = SPBRecord(&recordBuffer1.paramBlock, true);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	recordingInProgress = true;}int snd_StopRecording(void) {	/* turn off sound recording */	int err;	if (!!recordingInProgress) return;  /* noop if not recording */	err = SPBStopRecording(soundInputRefNum);	if (err !!= noErr) success(false);	SPBCloseDevice(soundInputRefNum);	DisposeRoutineDescriptor(recordBuffer1.paramBlock.completionRoutine);	recordBuffer1.paramBlock.completionRoutine = nil;	DisposeRoutineDescriptor(recordBuffer2.paramBlock.completionRoutine);	recordBuffer2.paramBlock.completionRoutine = nil;	recordBuffer1.recordSemaIndex = 0;	recordBuffer2.recordSemaIndex = 0;	recordingInProgress = false;}double snd_GetRecordingSampleRate(void) {	/* return the actual recording rate; fail if not currently recording */	UnsignedFixed sampleRateArg;	int err;	if (!!recordingInProgress) {		success(false);		return 0.0;	}	err = SPBGetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		success(false);		return 0.0;	}	return  (double) ((sampleRateArg >> 16) & 0xFFFF) +			((double) (sampleRateArg & 0xFFFF) / 65536.0);}int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes) {	/* if data is available, copy as many sample slices as possible into the	   given buffer starting at the given slice index. do not write past the	   end of the buffer, which is buf + bufferSizeInBytes. return the number	   of slices (not bytes) copied. a slice is one 16-bit sample in mono	   or two 16-bit samples in stereo. */	int bytesPerSlice = (recordBuffer1.stereo ? 4 : 2);	char *nextBuf = (char *) buf + (startSliceIndex * bytesPerSlice);	char *bufEnd = (char *) buf + bufferSizeInBytes;	char *src, *srcEnd;	RecordBuffer recBuf = nil;	int bytesCopied;	if (!!recordingInProgress) {		success(false);		return 0;	}	/* select the buffer with unread samples, if any */	recBuf = nil;	if (recordBuffer1.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer1;	if (recordBuffer2.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer2;	if (recBuf == nil) return 0;  /* no samples available */	/* copy samples into the client''s buffer */	src = &recBuf->samples[0] + recBuf->readIndex;	srcEnd = &recBuf->samples[RECORD_BUFFER_SIZE];	if (recBuf->bytesPerSample == 1) {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			/* convert 8-bit sample to 16-bit sample */			*nextBuf++ = (*src++) - 128;  /* convert from [0-255] to [-128-127] */			*nextBuf++ = 0;  /* low-order byte is zero */		}	} else {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			*nextBuf++ = *src++;		}	}	recBuf->readIndex = src - &recBuf->samples[0];  /* update read index */	/* return the number of slices copied */	bytesCopied = (int) nextBuf - (buf + (startSliceIndex * bytesPerSlice));	return bytesCopied / bytesPerSlice;}'.! !!InterpreterSupportCode class methodsFor: 'source files'!macTCPFile	^ '/* 	File:		MacTCP.h  	Contains:	TCP Manager Interfaces.  	Version:	Technology:	MacTCP 2.0.6 				Package:	Universal Interfaces 2.11 in MPW Prerelease on ETO #17  	Copyright:	 1984-1995 by Apple Computer, Inc. 				All rights reserved.  	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter 				stack.  Include the file and version information (from above) 				in the problem description and send to: 					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS */#ifndef __MACTCP__#define __MACTCP__#ifndef __TYPES__#include <Types.h>#endif/*	#include <ConditionalMacros.h>								*/#ifndef __APPLETALK__#include <AppleTalk.h>#endif/*	#include <OSUtils.h>										*//*		#include <MixedMode.h>									*//*		#include <Memory.h>										*/#ifdef __cplusplusextern "C" {#endif#if PRAGMA_ALIGN_SUPPORTED#pragma options align=mac68k#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import on#endif/*Developer Notes:		0. This MacTCP header replaces what used to be defined in the following header files			MacTCPCommonTypes.h			GetMyIPAddr.h			MiscIPPB.h			TCPPB.h			UDPPB.h 						When the various control calls are made to the ip driver, you must set up a 			NewRoutineDescriptor for every non-nil completion routine and/or notifyProc parameter.  			Otherwise, the 68K driver code, will not correctly call your routine.		1. For ipctlGetAddr Control calls, use NewGetIPIOCompletionProc			to set up a GetIPIOCompletionUPP universal procptr to pass as			the ioCompletion parameter.		2. For the ipctlEchoICMP and ipctlLAPStats Control calls, use 			NewIPIOCompletion to set up a IPIOCompletionUPP universal procptr			to pass in the ioCompletion field of the parameter block.		3. For TCPCreatePB Control calls, use NewTCPNotifyProc to set up a			TCPNotifyUPP universal procptr to pass in the notifyProc field			of the parameter block		4. For all of the TCP Control calls using the TCPiopb parameter block,			use NewTCPIOCompletionProc to set up a TCPIOCompletionUPP			universal procptr to pass in the ioCompletion field of the paramter			block.		5. For UDBCreatePB Control calls, use NewUDPNotifyProc to set up a			UDPNotifyUPP universal procptr to pass in the notifyProc field			of the parameter block		6. For all of the UDP Control calls using the UDPiopb parameter block,			use NewUDPIOCompletionProc to set up a UDPIOCompletionUPP			universal procptr to pass in the ioCompletion field of the paramter			block.		7. For all calls implementing a notifyProc or ioCompletion routine			which was set up using a NewTCPRoutineProc call, do not call			DisposeRoutineSDescriptor on the universal procptr until			after the completion or notify proc has completed.*//* MacTCP return Codes in the range -23000 through -23049 */enum {	inProgress					= 1,							/* I/O in progress */	ipBadLapErr					= -23000,						/* bad network configuration */	ipBadCnfgErr				= -23001,						/* bad IP configuration error */	ipNoCnfgErr					= -23002,						/* missing IP or LAP configuration error */	ipLoadErr					= -23003,						/* error in MacTCP load */	ipBadAddr					= -23004,						/* error in getting address */	connectionClosing			= -23005,						/* connection is closing */	invalidLength				= -23006,	connectionExists			= -23007,						/* request conflicts with existing connection */	connectionDoesntExist		= -23008,						/* connection does not exist */	insufficientResources		= -23009,						/* insufficient resources to perform request */	invalidStreamPtr			= -23010,	streamAlreadyOpen			= -23011,	connectionTerminated		= -23012,	invalidBufPtr				= -23013,	invalidRDS					= -23014,	invalidWDS					= -23014,	openFailed					= -23015,	commandTimeout				= -23016,	duplicateSocket				= -23017};/* Error codes from internal IP functions */enum {	ipDontFragErr				= -23032,						/* Packet too large to send w/o fragmenting */	ipDestDeadErr				= -23033,						/* destination not responding */	icmpEchoTimeoutErr			= -23035,						/* ICMP echo timed-out */	ipNoFragMemErr				= -23036,						/* no memory to send fragmented pkt */	ipRouteErr					= -23037,						/* can''t route packet off-net */	nameSyntaxErr				= -23041,	cacheFault					= -23042,	noResultProc				= -23043,	noNameServer				= -23044,	authNameErr					= -23045,	noAnsErr					= -23046,	dnrErr						= -23047,	outOfMemory					= -23048};enum {	BYTES_16WORD				= 2,							/* bytes per = 16, bit ip word */	BYTES_32WORD				= 4,							/* bytes per = 32, bit ip word */	BYTES_64WORD				= 8								/* bytes per = 64, bit ip word */};/* 8-bit quantity */typedef UInt8 b_8;/* 16-bit quantity */typedef UInt16 b_16;/* 32-bit quantity */typedef UInt32 b_32;/* IP address is 32-bits */typedef b_32 ip_addr;struct ip_addrbytes {	union {		b_32							addr;		UInt8							byte[4];	}								a;};typedef struct ip_addrbytes ip_addrbytes;struct wdsEntry {	unsigned short					length;						/* length of buffer */	Ptr								ptr;						/* pointer to buffer */};typedef struct wdsEntry wdsEntry;struct rdsEntry {	unsigned short					length;						/* length of buffer */	Ptr								ptr;						/* pointer to buffer */};typedef struct rdsEntry rdsEntry;typedef unsigned long BufferPtr;typedef unsigned long StreamPtr;enum {	netUnreach					= 0,	hostUnreach					= 1,	protocolUnreach				= 2,	portUnreach					= 3,	fragReqd					= 4,	sourceRouteFailed			= 5,	timeExceeded				= 6,	parmProblem					= 7,	missingOption				= 8,	lastICMPMsgType				= 32767};typedef unsigned short ICMPMsgType;typedef b_16 ip_port;struct ICMPReport {	StreamPtr						streamPtr;	ip_addr							localHost;	ip_port							localPort;	ip_addr							remoteHost;	ip_port							remotePort;	short							reportType;	unsigned short					optionalAddlInfo;	unsigned long					optionalAddlInfoPtr;};typedef struct ICMPReport ICMPReport;/* csCode to get our IP address */enum {	ipctlGetAddr				= 15};typedef void (*GetIPIOCompletionProcPtr)(struct GetAddrParamBlock *iopb);#if GENERATINGCFMtypedef UniversalProcPtr GetIPIOCompletionUPP;#elsetypedef GetIPIOCompletionProcPtr GetIPIOCompletionUPP;#endif#define GetIPParamBlockHeader 	\	struct QElem*	qLink; 		\	short	qType; 				\	short	ioTrap; 				\	Ptr	ioCmdAddr; 				\	GetIPIOCompletionUPP	ioCompletion;  \	OSErr	ioResult; 			\	StringPtr	ioNamePtr; 		\	short	ioVRefNum;				\	short	ioCRefNum;				\	short	csCodestruct GetAddrParamBlock {	struct QElem					*qLink;	short							qType;	short							ioTrap;	Ptr								ioCmdAddr;	GetIPIOCompletionUPP			ioCompletion;	OSErr							ioResult;	StringPtr						ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;						/* standard I/O header */	ip_addr							ourAddress;					/* our IP address */	long							ourNetMask;					/* our IP net mask */};typedef struct GetAddrParamBlock GetAddrParamBlock;/* control codes */enum {	ipctlEchoICMP				= 17,							/* send icmp echo */	ipctlLAPStats				= 19							/* get lap stats */};typedef void (*IPIOCompletionProcPtr)(struct ICMPParamBlock *iopb);#if GENERATINGCFMtypedef UniversalProcPtr IPIOCompletionUPP;#elsetypedef IPIOCompletionProcPtr IPIOCompletionUPP;#endif#define IPParamBlockHeader 		\	struct QElem*	qLink; 		\	short	qType; 				\	short	ioTrap; 				\	Ptr	ioCmdAddr; 				\	IPIOCompletionUPP	ioCompletion;  \	OSErr	ioResult; 			\	StringPtr	ioNamePtr; 		\	short	ioVRefNum;				\	short	ioCRefNum;				\	short	csCodestruct ICMPParamBlock {	struct QElem					*qLink;	short							qType;	short							ioTrap;	Ptr								ioCmdAddr;	IPIOCompletionUPP				ioCompletion;	OSErr							ioResult;	StringPtr						ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;						/* standard I/O header */	short							params[11];	struct {		unsigned long					echoRequestOut;			/* time in ticks of when the echo request went out */		unsigned long					echoReplyIn;			/* time in ticks of when the reply was received */		struct rdsEntry					echoedData;				/* data received in responce */		Ptr								options;		unsigned long					userDataPtr;	}								icmpEchoInfo;};typedef pascal void (*ICMPEchoNotifyProcPtr)(struct ICMPParamBlock *iopb);#if GENERATINGCFMtypedef UniversalProcPtr ICMPEchoNotifyUPP;#elsetypedef ICMPEchoNotifyProcPtr ICMPEchoNotifyUPP;#endifstruct IPParamBlock {	struct QElem					*qLink;	short							qType;	short							ioTrap;	Ptr								ioCmdAddr;	IPIOCompletionUPP				ioCompletion;	OSErr							ioResult;	StringPtr						ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;						/* standard I/O header */	union {		struct {			ip_addr							dest;				/* echo to IP address */			wdsEntry						data;			short							timeout;			Ptr								options;			unsigned short					optLength;			ICMPEchoNotifyUPP				icmpCompletion;			unsigned long					userDataPtr;		}								IPEchoPB;		struct {			struct LAPStats					*lapStatsPtr;		}								LAPStatsPB;	}								csParam;};union LAPStatsAddrXlation {	struct arp_entry				*arp_table;	struct nbp_entry				*nbp_table;};struct LAPStats {	short							ifType;	char							*ifString;	short							ifMaxMTU;	long							ifSpeed;	short							ifPhyAddrLength;	char							*ifPhysicalAddress;	union LAPStatsAddrXlation		AddrXlation;	short							slotNumber;};typedef struct LAPStats LAPStats;struct nbp_entry {	ip_addr							ip_address;					/* IP address */	AddrBlock						at_address;					/* matching AppleTalk address */	Boolean							gateway;					/* TRUE if entry for a gateway */	Boolean							valid;						/* TRUE if LAP address is valid */	Boolean							probing;					/* TRUE if NBP lookup pending */	SInt8							afiller;					/* Filler for proper byte alignment	 */	long							age;						/* ticks since cache entry verified */	long							access;						/* ticks since last access */	SInt8							filler[116];				/* for internal use only !!!!!! */};struct Enet_addr {	b_16							en_hi;	b_32							en_lo;};typedef struct Enet_addr Enet_addr;struct arp_entry {	short							age;						/* cache aging field */	b_16							protocol;					/* Protocol type */	ip_addr							ip_address;					/* IP address */	Enet_addr						en_address;					/* matching Ethernet address */};typedef struct arp_entry arp_entry;/* number of ARP table entries */enum {	ARP_TABLE_SIZE				= 20};enum {	NBP_TABLE_SIZE				= 20,							/* number of NBP table entries */	NBP_MAX_NAME_SIZE			= 16 + 10 + 2};/* Command codes */enum {	TCPCreate					= 30,	TCPPassiveOpen				= 31,	TCPActiveOpen				= 32,	TCPSend						= 34,	TCPNoCopyRcv				= 35,	TCPRcvBfrReturn				= 36,	TCPRcv						= 37,	TCPClose					= 38,	TCPAbort					= 39,	TCPStatus					= 40,	TCPExtendedStat				= 41,	TCPRelease					= 42,	TCPGlobalInfo				= 43,	TCPCtlMax					= 49};enum {	TCPClosing					= 1,	TCPULPTimeout				= 2,	TCPTerminate				= 3,	TCPDataArrival				= 4,	TCPUrgent					= 5,	TCPICMPReceived				= 6,	lastEvent					= 32767};typedef unsigned short TCPEventCode;enum {	TCPRemoteAbort				= 2,	TCPNetworkFailure			= 3,	TCPSecPrecMismatch			= 4,	TCPULPTimeoutTerminate		= 5,	TCPULPAbort					= 6,	TCPULPClose					= 7,	TCPServiceError				= 8,	lastReason					= 32767};typedef unsigned short TCPTerminationReason;typedef pascal void (*TCPNotifyProcPtr)(StreamPtr tcpStream, unsigned short eventCode, Ptr userDataPtr, unsigned short terminReason, struct ICMPReport *icmpMsg);#if GENERATINGCFMtypedef UniversalProcPtr TCPNotifyUPP;#elsetypedef TCPNotifyProcPtr TCPNotifyUPP;#endiftypedef unsigned short tcp_port;/* ValidityFlags */enum {	timeoutValue				= 0x80,	timeoutAction				= 0x40,	typeOfService				= 0x20,	precedence					= 0x10};/* TOSFlags */enum {	lowDelay					= 0x01,	throughPut					= 0x02,	reliability					= 0x04};struct TCPCreatePB {	Ptr								rcvBuff;	unsigned long					rcvBuffLen;	TCPNotifyUPP					notifyProc;	Ptr								userDataPtr;};typedef struct TCPCreatePB TCPCreatePB;struct TCPOpenPB {	SInt8							ulpTimeoutValue;	SInt8							ulpTimeoutAction;	SInt8							validityFlags;	SInt8							commandTimeoutValue;	ip_addr							remoteHost;	tcp_port						remotePort;	ip_addr							localHost;	tcp_port						localPort;	SInt8							tosFlags;	SInt8							precedence;	Boolean							dontFrag;	SInt8							timeToLive;	SInt8							security;	SInt8							optionCnt;	SInt8							options[40];	Ptr								userDataPtr;};typedef struct TCPOpenPB TCPOpenPB;struct TCPSendPB {	SInt8							ulpTimeoutValue;	SInt8							ulpTimeoutAction;	SInt8							validityFlags;	Boolean							pushFlag;	Boolean							urgentFlag;	SInt8							filler;						/* Filler for proper byte alignment	 */	Ptr								wdsPtr;	unsigned long					sendFree;	unsigned short					sendLength;	Ptr								userDataPtr;};typedef struct TCPSendPB TCPSendPB;/* for receive and return rcv buff calls *//*   Note: the filler in the following structure is in a different location than *//*         that specified in the Programmer''s Guide.  */struct TCPReceivePB {	SInt8							commandTimeoutValue;	Boolean							markFlag;	Boolean							urgentFlag;	SInt8							filler;						/* Filler for proper byte alignment  */	Ptr								rcvBuff;	unsigned short					rcvBuffLen;	Ptr								rdsPtr;	unsigned short					rdsLength;	unsigned short					secondTimeStamp;	Ptr								userDataPtr;};typedef struct TCPReceivePB TCPReceivePB;struct TCPClosePB {	SInt8							ulpTimeoutValue;	SInt8							ulpTimeoutAction;	SInt8							validityFlags;	SInt8							filler;						/* Filler for proper byte alignment	 */	Ptr								userDataPtr;};typedef struct TCPClosePB TCPClosePB;struct HistoBucket {	unsigned short					value;	unsigned long					counter;};typedef struct HistoBucket HistoBucket;enum {	NumOfHistoBuckets			= 7};struct TCPConnectionStats {	unsigned long					dataPktsRcvd;	unsigned long					dataPktsSent;	unsigned long					dataPktsResent;	unsigned long					bytesRcvd;	unsigned long					bytesRcvdDup;	unsigned long					bytesRcvdPastWindow;	unsigned long					bytesSent;	unsigned long					bytesResent;	unsigned short					numHistoBuckets;	struct HistoBucket				sentSizeHisto[NumOfHistoBuckets];	unsigned short					lastRTT;	unsigned short					tmrSRTT;	unsigned short					rttVariance;	unsigned short					tmrRTO;	SInt8							sendTries;	SInt8							sourchQuenchRcvd;};typedef struct TCPConnectionStats TCPConnectionStats;struct TCPStatusPB {	SInt8							ulpTimeoutValue;	SInt8							ulpTimeoutAction;	long							unused;	ip_addr							remoteHost;	tcp_port						remotePort;	ip_addr							localHost;	tcp_port						localPort;	SInt8							tosFlags;	SInt8							precedence;	SInt8							connectionState;	SInt8							filler;						/* Filler for proper byte alignment	 */	unsigned short					sendWindow;	unsigned short					rcvWindow;	unsigned short					amtUnackedData;	unsigned short					amtUnreadData;	Ptr								securityLevelPtr;	unsigned long					sendUnacked;	unsigned long					sendNext;	unsigned long					congestionWindow;	unsigned long					rcvNext;	unsigned long					srtt;	unsigned long					lastRTT;	unsigned long					sendMaxSegSize;	struct TCPConnectionStats		*connStatPtr;	Ptr								userDataPtr;};typedef struct TCPStatusPB TCPStatusPB;struct TCPAbortPB {	Ptr								userDataPtr;};typedef struct TCPAbortPB TCPAbortPB;struct TCPParam {	unsigned long					tcpRtoA;	unsigned long					tcpRtoMin;	unsigned long					tcpRtoMax;	unsigned long					tcpMaxSegSize;	unsigned long					tcpMaxConn;	unsigned long					tcpMaxWindow;};typedef struct TCPParam TCPParam;struct TCPStats {	unsigned long					tcpConnAttempts;	unsigned long					tcpConnOpened;	unsigned long					tcpConnAccepted;	unsigned long					tcpConnClosed;	unsigned long					tcpConnAborted;	unsigned long					tcpOctetsIn;	unsigned long					tcpOctetsOut;	unsigned long					tcpOctetsInDup;	unsigned long					tcpOctetsRetrans;	unsigned long					tcpInputPkts;	unsigned long					tcpOutputPkts;	unsigned long					tcpDupPkts;	unsigned long					tcpRetransPkts;};typedef struct TCPStats TCPStats;typedef StreamPtr *StreamPPtr;struct TCPGlobalInfoPB {	struct TCPParam					*tcpParamPtr;	struct TCPStats					*tcpStatsPtr;	StreamPPtr						tcpCDBTable[1];	Ptr								userDataPtr;	unsigned short					maxTCPConnections;};typedef struct TCPGlobalInfoPB TCPGlobalInfoPB;typedef void (*TCPIOCompletionProcPtr)(struct TCPiopb *iopb);#if GENERATINGCFMtypedef UniversalProcPtr TCPIOCompletionUPP;#elsetypedef TCPIOCompletionProcPtr TCPIOCompletionUPP;#endifstruct TCPiopb {	SInt8							fill12[12];	TCPIOCompletionUPP				ioCompletion;	short							ioResult;	Ptr								ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;	StreamPtr						tcpStream;	union {		struct TCPCreatePB				create;		struct TCPOpenPB				open;		struct TCPSendPB				send;		struct TCPReceivePB				receive;		struct TCPClosePB				close;		struct TCPAbortPB				abort;		struct TCPStatusPB				status;		struct TCPGlobalInfoPB			globalInfo;	}								csParam;};typedef struct TCPiopb TCPiopb;enum {	UDPCreate					= 20,	UDPRead						= 21,	UDPBfrReturn				= 22,	UDPWrite					= 23,	UDPRelease					= 24,	UDPMaxMTUSize				= 25,	UDPStatus					= 26,	UDPMultiCreate				= 27,	UDPMultiSend				= 28,	UDPMultiRead				= 29,	UDPCtlMax					= 29};enum {	UDPDataArrival				= 1,	UDPICMPReceived				= 2,	lastUDPEvent				= 32767};typedef unsigned short UDPEventCode;typedef pascal void (*UDPNotifyProcPtr)(StreamPtr udpStream, unsigned short eventCode, Ptr userDataPtr, struct ICMPReport *icmpMsg);#if GENERATINGCFMtypedef UniversalProcPtr UDPNotifyUPP;#elsetypedef UDPNotifyProcPtr UDPNotifyUPP;#endiftypedef unsigned short udp_port;/* for create and release calls */struct UDPCreatePB {	Ptr								rcvBuff;	unsigned long					rcvBuffLen;	UDPNotifyUPP					notifyProc;	unsigned short					localPort;	Ptr								userDataPtr;	udp_port						endingPort;};typedef struct UDPCreatePB UDPCreatePB;struct UDPSendPB {	unsigned short					reserved;	ip_addr							remoteHost;	udp_port						remotePort;	Ptr								wdsPtr;	Boolean							checkSum;	SInt8							filler;						/* Filler for proper byte alignment	 */	unsigned short					sendLength;	Ptr								userDataPtr;	udp_port						localPort;};typedef struct UDPSendPB UDPSendPB;/* for receive and buffer return calls */struct UDPReceivePB {	unsigned short					timeOut;	ip_addr							remoteHost;	udp_port						remotePort;	Ptr								rcvBuff;	unsigned short					rcvBuffLen;	unsigned short					secondTimeStamp;	Ptr								userDataPtr;	ip_addr							destHost;					/* only for use with multi rcv */	udp_port						destPort;					/* only for use with multi rcv */};typedef struct UDPReceivePB UDPReceivePB;struct UDPMTUPB {	unsigned short					mtuSize;	ip_addr							remoteHost;	Ptr								userDataPtr;};typedef struct UDPMTUPB UDPMTUPB;typedef void (*UDPIOCompletionProcPtr)(struct UDPiopb *iopb);#if GENERATINGCFMtypedef UniversalProcPtr UDPIOCompletionUPP;#elsetypedef UDPIOCompletionProcPtr UDPIOCompletionUPP;#endifstruct UDPiopb {	SInt8							fill12[12];	UDPIOCompletionUPP				ioCompletion;	short							ioResult;	Ptr								ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;	StreamPtr						udpStream;	union {		struct UDPCreatePB				create;		struct UDPSendPB				send;		struct UDPReceivePB				receive;		struct UDPMTUPB					mtu;	}								csParam;};typedef struct UDPiopb UDPiopb;#if GENERATINGCFM#else#endifenum {	uppGetIPIOCompletionProcInfo = kCStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct GetAddrParamBlock*))),	uppIPIOCompletionProcInfo = kCStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct ICMPParamBlock*))),	uppICMPEchoNotifyProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct ICMPParamBlock*))),	uppTCPNotifyProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(StreamPtr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(unsigned short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(unsigned short)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(struct ICMPReport*))),	uppTCPIOCompletionProcInfo = kCStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct TCPiopb*))),	uppUDPNotifyProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(StreamPtr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(unsigned short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(struct ICMPReport*))),	uppUDPIOCompletionProcInfo = kCStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct UDPiopb*)))};#if GENERATINGCFM#define NewGetIPIOCompletionProc(userRoutine)		\		(GetIPIOCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppGetIPIOCompletionProcInfo, GetCurrentArchitecture())#define NewIPIOCompletionProc(userRoutine)		\		(IPIOCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppIPIOCompletionProcInfo, GetCurrentArchitecture())#define NewICMPEchoNotifyProc(userRoutine)		\		(ICMPEchoNotifyUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppICMPEchoNotifyProcInfo, GetCurrentArchitecture())#define NewTCPNotifyProc(userRoutine)		\		(TCPNotifyUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppTCPNotifyProcInfo, GetCurrentArchitecture())#define NewTCPIOCompletionProc(userRoutine)		\		(TCPIOCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppTCPIOCompletionProcInfo, GetCurrentArchitecture())#define NewUDPNotifyProc(userRoutine)		\		(UDPNotifyUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppUDPNotifyProcInfo, GetCurrentArchitecture())#define NewUDPIOCompletionProc(userRoutine)		\		(UDPIOCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppUDPIOCompletionProcInfo, GetCurrentArchitecture())#else#define NewGetIPIOCompletionProc(userRoutine)		\		((GetIPIOCompletionUPP) (userRoutine))#define NewIPIOCompletionProc(userRoutine)		\		((IPIOCompletionUPP) (userRoutine))#define NewICMPEchoNotifyProc(userRoutine)		\		((ICMPEchoNotifyUPP) (userRoutine))#define NewTCPNotifyProc(userRoutine)		\		((TCPNotifyUPP) (userRoutine))#define NewTCPIOCompletionProc(userRoutine)		\		((TCPIOCompletionUPP) (userRoutine))#define NewUDPNotifyProc(userRoutine)		\		((UDPNotifyUPP) (userRoutine))#define NewUDPIOCompletionProc(userRoutine)		\		((UDPIOCompletionUPP) (userRoutine))#endif#if GENERATINGCFM#define CallGetIPIOCompletionProc(userRoutine, iopb)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppGetIPIOCompletionProcInfo, (iopb))#define CallIPIOCompletionProc(userRoutine, iopb)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppIPIOCompletionProcInfo, (iopb))#define CallICMPEchoNotifyProc(userRoutine, iopb)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppICMPEchoNotifyProcInfo, (iopb))#define CallTCPNotifyProc(userRoutine, tcpStream, eventCode, userDataPtr, terminReason, icmpMsg)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppTCPNotifyProcInfo, (tcpStream), (eventCode), (userDataPtr), (terminReason), (icmpMsg))#define CallTCPIOCompletionProc(userRoutine, iopb)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppTCPIOCompletionProcInfo, (iopb))#define CallUDPNotifyProc(userRoutine, udpStream, eventCode, userDataPtr, icmpMsg)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppUDPNotifyProcInfo, (udpStream), (eventCode), (userDataPtr), (icmpMsg))#define CallUDPIOCompletionProc(userRoutine, iopb)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppUDPIOCompletionProcInfo, (iopb))#else#define CallGetIPIOCompletionProc(userRoutine, iopb)		\		(*(userRoutine))((iopb))#define CallIPIOCompletionProc(userRoutine, iopb)		\		(*(userRoutine))((iopb))#define CallICMPEchoNotifyProc(userRoutine, iopb)		\		(*(userRoutine))((iopb))#define CallTCPNotifyProc(userRoutine, tcpStream, eventCode, userDataPtr, terminReason, icmpMsg)		\		(*(userRoutine))((tcpStream), (eventCode), (userDataPtr), (terminReason), (icmpMsg))#define CallTCPIOCompletionProc(userRoutine, iopb)		\		(*(userRoutine))((iopb))#define CallUDPNotifyProc(userRoutine, udpStream, eventCode, userDataPtr, icmpMsg)		\		(*(userRoutine))((udpStream), (eventCode), (userDataPtr), (icmpMsg))#define CallUDPIOCompletionProc(userRoutine, iopb)		\		(*(userRoutine))((iopb))#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import off#endif#if PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __MACTCP__ */'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/6/98 12:15'!macWindowFile	^ '#include <MacHeaders.h>#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Fonts.h>#include <Gestalt.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern unsigned char *memory;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document or image file */#define SHORTDOCUMENT_NAME_SIZE 100char shortDocumentName[SHORTDOCUMENT_NAME_SIZE + 1];  /* just the document file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;Handle			clipboardBuffer = nil;MenuHandle		editMenu = nil;MenuHandle		fileMenu = nil;int				runningOnPowerbook = false;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowSize(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "squeak.image");	return noErr;}pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) goto done;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;	if (numFiles !!= 1) {		error("You may only open one Squeak image or document file at a time.");	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;	strcpy(shortImageName, p2cstr(fileSpec.name));	if (!!IsImageName(shortImageName)) {		/* record the document name, but run the default image in VM directory */		strcpy(shortDocumentName, shortImageName);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);	if (shortDocumentName[0] !!= 0) {		/* record the document''s full name */		StoreFullPathForLocalNameInto(shortDocumentName, documentName, DOCUMENT_NAME_SIZE);	}done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetItem(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	long powerManagerAttributes;	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();	/* find out if processor is a PowerBook */	if (!!Gestalt(gestaltPowerMgrAttr, &powerManagerAttributes)) {		if (powerManagerAttributes & (1 << gestaltPMgrDispatchExists)) {//xxx PowerManager library is not available//			if (PMSelectorCount() >= 0x24) {//				runningOnPowerbook = true;//			}		}	}}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AddResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = { 44, 8, 408, 648 };  /* default window bounds */	Rect screen;	int right, bottom;	if (savedWindowSize !!= 0) {		right  = windowBounds.left + ((unsigned) savedWindowSize >> 16);		bottom = windowBounds.top  + (savedWindowSize & 0xFFFF);	} else {		right  = windowBounds.right;		bottom = windowBounds.bottom;	}	/* minimum size is 64 x 64 */	right  = ( right > (windowBounds.left + 64)) ?  right : (windowBounds.left + 64);	bottom = (bottom > (windowBounds.top  + 64)) ? bottom : (windowBounds.top  + 64);	/* maximum bottom-right is screen bottom-right */	screen = qd.screenBits.bounds;	right  = ( right <= screen.right)  ?  right : (screen.right  - 8);	bottom = (bottom <= screen.bottom) ? bottom : (screen.bottom - 8);	windowBounds.right = right;	windowBounds.bottom = bottom;	stWindow = NewCWindow(0L, &windowBounds, "\pWelcome to Squeak!!", true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowSize(void) {	Rect screen;	int width, height, maxWidth, maxHeight;	if (savedWindowSize !!= 0) {		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;	} else {		width  = 640;		height = 480;	}	/* minimum size is 64 x 64 */	width  = ( width > 64) ?   width : 64;	height = (height > 64) ?  height : 64;	/* maximum size is screen size */	screen = qd.screenBits.bounds;	maxWidth  = (screen.right  - screen.left) - 16;	maxHeight = (screen.bottom - screen.top)  - 52;	width  = ( width <= maxWidth)  ?  width : maxWidth;	height = (height <= maxHeight) ? height : maxHeight;	SizeWindow(stWindow, width, height, true);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	sqNetworkShutdown();	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than ioMSecs!!!!) */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		if (runningOnPowerbook && windowActive) {//			UpdateSystemActivity(UsrActivity);		}		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * HandleEvents(), which gives other applications a chance to run.	 */	while (HandleEvents()) {		/* process all pending events */	}	return microSeconds;}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	Cursor macCursor;	int i;	for (i = 0; i < 16; i++) {		macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length) {	int offset, sz, i;	offset = dir_PathToWorkingDir(fullName, length);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	if (memory == nil) {		return;	/* failed to read image */	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	strcpy(imageName, fullImagePath);	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	SetUpClipboard();	SetUpPixmap();	sqFileInit();	joystickInit();}int plugInShutdown(void) {	snd_Stop();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   could be reported this way as well.	*/	switch (id) {	case 1:		return documentName;		break;	default:		success(false);		return "";		break;	}}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	FILE *f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	sqFileInit();	joystickInit();	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 400000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = fopen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	// setvbuf(f, NULL, _IONBF, 0);  // speeds up image reading, but does not work under CW8	readImageFromFileHeapSize(f, availableMemory);	fclose(f);	SetWindowTitle(shortImageName);	SetWindowSize();	/* run Squeak */	interpret();}#endif'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'ikp 1/3/98 23:36'!oldSqueakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C *//* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#ifdef DOUBLE_WORD_ALIGNMENT/* word-based copy for machines that require doubles to be double-word aligned */#define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);#else/* for machines that allow doubles to be on any word boundary */#define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);#define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/*** increment this version number when the image file format changes ***/#define CURRENT_VERSION 6502/* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMicroMSecs(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);/* millisecond clock */#define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFromFileHeapSize(FILE *f, int desiredHeapSize);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* sound output */int snd_AvailableSpace(void);int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex);int snd_Stop(void);/* sound input */int snd_SetRecordLevel(int level);int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex);int snd_StopRecording(void);double snd_GetRecordingSampleRate(void);int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes);/* joystick support */int joystickInit(void);int joystickRead(int stickIndex);/* netscape plug-in support */int plugInInit(char *imageName);int plugInShutdown(void);int plugInInterpretCycles(int cycleCount);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* sound generation primitives */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);/* squeak socket record; see sqMacNetwork.c for details */typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/6/98 11:48'!readmeFile	^ 'Building the Squeak Virtual MachineThe virtual machine is built from three header and nine source files:	sq.h				-- shared definitions included in all .c files	sqConfig.h			-- platform configuration settings	sqMachDep.h		-- machine dependent macros to support threaded code	sqFilePrims.c		-- file primitives	sqMacDirectory.c	-- Mac directory enumerations	sqMacJoystick.c		-- primitives to support Gravis MouseStickII joystick	sqMacNetwork.c		-- Mac networking primitives	sqMacSound.c		-- Mac audio output primitives	sqMacWindow.c		-- Mac window and event handling; main program	sqSoundPrims.c		-- automatically generated sound synthesis primitives	sqOldSoundPrims.c	-- old versions of sound primitives for backward compatibility	interpreter.c		-- automatically generated code for the virtual machineThe platform specific files are sqMacWindow.c, sqMacDirectory.c, sqMacJoystick.c, sqMacNetwork.c, and sqMacSound.c, totaling about 1800 lines of code when this document was written. All other code is written to standard ANSI libraries and should port easily to other C environments. When doing the initial port to a new system, the functions in sqMacJoystick.c, sqMacNetwork.c, and sqMacSound.c can be replaced by stub functions that do nothing. Thanks to Ian Piumarta, the C header files are identical on the Macintosh and all Unix platforms.The code assumes that C ints and pointers are 4 bytes and double floats are 8 bytes; these assumptions are checked at start up time. Floats are always stored in PowerPC byte order (which I believe is the same as the IEEE standard byte ordering for double-precision floats); macros in sq.h can be defined to swap bytes into and out of the platform native float format if necessary.The files interpreter.c and sqSoundPrims.c are generated automatically, so changes to these files will be lost when they are next generated. It is fine to make ephemeral changes to these file for the purpose of debugging or statistics gathering. To generate the interpreter, see the "translation" category in Interpreter class. To generate sqSoundPrims.c, see the class method "cCodeForSoundPrimitives" in AbstractSound.The current VM was compiled with Metrowerks CodeWarrier 8. Earlier, I used Semantec Think C 6.0, but discovered a few bugs in their libraries having to do with 8-byte versus 4-byte integers. These bugs could probably be worked around if one really wanted to use that environment.This code has also been compiled under the MPW "Mr. C" Macintosh compiler by Hans-Martin Mosner (hmm@heeg.de) with only one minor change: you will need to create an empty "MacHeaders.h" file. You may get some harmless compiler warnings and, for peak performance, the method that patches the dispatch loop must also be changed. Hans-Martin says: "The whole VM seems to be marginally slower than the delivered VM, but itis significantly smaller."The virtual machine uses the following libraries:	Libraries for 68K Project:		MathLib68K (4i/8d).Lib		MacOS.lib		profiler68k(Small).lib		SIOUX.68K.Lib		ANSI (4i/8d) C.68K.lib	Libraries for PowerPC Project:		ANSI C.PPC.Lib		SIOUX.PPC.Lib		InterfaceLib		profilerPPC.lib		MathLib		MWCRuntime.LibThe Mac networking code also requires three files from Apple''s MacTCP developer''s kit:	MacTCP.h	AddressXlation.h	dnr.cFor convenience, these files are included.To build a fat binary, build the 68K version first, and make sure that the file "Squeak VM 68K" is included in the PowerPC project. Then build the PowerPC version. CodeWarrier will include the 68K interpreter in the resource fork of the output file, resulting in an interpreter that runs on either 68K or PowerPC Macs. To get an additional speedup, the object code for the bytecode dispatch loop of the PPC version can be patched using the method "patchInterp:" in Interpreter class.	-- John Maloney, January 6, 1998'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/8/98 14:32'!squeakConfigFile	^ '/* Identification of, and configuration for, various types of platform. */#if defined(__MWERKS__) && !!defined(macintosh)  /* CodeWarrior 8 neglects to define "macintosh" */# define macintosh#endif#if defined(macintosh)# define USE_CLOCK_MSECS#else /*!!macintosh*//* this file must define the following symbols as appropriate:   HAS_D_NAMLEN      defined if struct dirent has d_namlen field and hence directory names      are not null terminated.  if underfined then directory names are null      terminated.   HAS_TIMEZONE      defined if the external variable timezone is available, containing the      local offset from GMT in seconds.  if  undefined then the tm structure      must contain the same information in the tm_gmtoff field.  (Consider      defining NEED_TZSET too!!)   HAS_ON_EXIT      defined if cleanup functions are declared with on_exit().  If      undefined then cleanup functions are declared with atexit().   HAS_MSB_FIRST      defined if the most significant byte is first in an int.   HAS_LSB_FIRST      defined if the least significant byte is first in an int.      (Complains if neither of the last two are defined.)   HAS_SUN_AUDIO      defined if the platform supports the Sun /dev/audio device.   DOUBLE_WORD_ALIGNMENT      defined if the platform CANNOT support double-word accesses at an      arbitrary word address.         DOUBLE_WORD_ORDER      defined if the platform stores floats in the opposite order      to the Squeak image (the image is always PowerPC order).   SUN_FUN_KEYS      defined for Sun type 3 or 4 keyboards to enable the editing keys      (Again, Undo, Copy, Paste, Cut, Find, Stop on the "left keypad",      and PgUp, PgDn, Home, End keys on the right keypad).   NEED_FILIO      defined if the platform requires <sys/filio.h> to be included      to get a definition for FIONBIO.   NEED_SELECT      defined if the platform requires <sys/select.h> to be included      to get definitions for select().   NEED_TZSET      defined if the platform required tzset() to be called explicitly      before reading the local wall clock.   JUMP_ALIGN_BYTE      defined if the platform has no instruction alignment restrictions      (e.g. Pentium).   JUMP_ALIGN_STRICT      defined if the platform has word-aligned instructions, and cannot      tolerate the low two bits of an address being non-zero (e.g.      Sparc).*/#if defined(sun) && (defined(sparc) || defined(__sparc))# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# include <errno.h># ifdef ECHRNG					/* Sparc/Solaris */#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_FILIO#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# else						/* Sparc/SunOS */#   include <unistd.h>#   define HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   define HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# endif#endif#if defined(sun) && defined(i386)		/* iX86/Solaris */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_TZSET# define JUMP_ALIGN_BYTE# define SQ_CONFIG_DONE#endif#if defined(mips) || defined(__mips)# if defined(_SYSTYPE_SVR4)			/* (SGI)/IRIX */#  if defined(SQ_CONFIG_DONE)#    error configuration conflict#  endif#  undef  HAS_D_NAMLEN#  define HAS_TIMEZONE#  undef  HAS_ON_EXIT#  define HAS_MSB_FIRST#  undef  HAS_SUN_AUDIO#  undef  DOUBLE_WORD_ALIGNMENT#  undef  DOUBLE_WORD_ORDER#  define SQ_CONFIG_DONE# endif#endif#if defined(linux)# if defined(i386)				/* iX86/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define NEED_TZSET#   define JUMP_ALIGN_BYTE#  define SQ_CONFIG_DONE# endif# if defined(powerpc)				/* PPC/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define NEED_TZSET#   define SQ_CONFIG_DONE# endif#endif#if defined(__FreeBSD__)# if defined(i386)				/* iX86/FreeBSD */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define JUMP_ALIGN_BYTE#   define SQ_CONFIG_DONE# endif#endif#if defined(__alpha)				/* Alpha/OSF1 */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# undef  HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# define DOUBLE_WORD_ORDER# define NEED_TZSET# define SQ_CONFIG_DONE#endif#if defined(hpux) || defined (__hpux)		/* HPPA/HP-UX */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_TZSET  extern int h_errno;	/* loser!! */# define SQ_CONFIG_DONE#endif#if defined(_AIX) || defined(_M_UNIX)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN				/* IBM RS6000/AIX */# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_SELECT# define SQ_CONFIG_DONE#endif#if !!defined(SQ_CONFIG_DONE)# error test for, and describe, your architecture here.#endif/* unix-specific prototypes, for want of a better place to put them */void aioPollForIO(int microSeconds, int extraFd);#endif /*!!macintosh*/'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/6/98 11:56'!squeakFilePrimsFile	^ '#include "sq.h"/***	The state of a file is kept in the following structure,	which is stored directly in a Squeak bytes object.	NOTE: The Squeak side is responsible for creating an	object with enough room to store sizeof(SQFile) bytes.	The session ID is used to detect stale file objects--	files that were still open when an image was written.	The file pointer of such files is meaningless.	Files are always opened in binary mode; Smalltalk code	does (or someday will do) line-end conversion if needed.	Writeable files are opened read/write. The stdio spec	requires that a positioning operation be done when	switching between reading and writing of a read/write	filestream. The lastOp field records whether the last	operation was a read or write operation, allowing this	positioning operation to be done automatically if needed.	typedef struct {		File	*file;		int		sessionID;		int		writable;		int		fileSize;		int		lastOp;  // 0 = uncommitted, 1 = read, 2 = write //	} SQFile;***//*** Constants ***/#define UNCOMMITTED	0#define READ_OP		1#define WRITE_OP	2#ifndef SEEK_SET#define SEEK_SET	0#define SEEK_CUR	1#define SEEK_END	2#endif/*** Variables ***/int thisSession = 0;int sqFileAtEnd(SQFile *f) {	/* Return true if the file''s read/write head is at the end of the file. */	if (!!sqFileValid(f)) return success(false);	return ftell(f->file) == f->fileSize;}int sqFileClose(SQFile *f) {	/* Close the given file. */	if (!!sqFileValid(f)) return success(false);	fclose(f->file);	f->file = NULL;	f->sessionID = 0;	f->writable = false;	f->fileSize = 0;	f->lastOp = UNCOMMITTED;}int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize) {	char cFileName[1000];	int i, err;	if (sqFileNameSize >= 1000) {		return success(false);	}	/* copy the file name into a null-terminated C string */	for (i = 0; i < sqFileNameSize; i++) {		cFileName[i] = *((char *) (sqFileNameIndex + i));	}	cFileName[sqFileNameSize] = 0;	err = remove(cFileName);	if (err) {		return success(false);	}}int sqFileGetPosition(SQFile *f) {	/* Return the current position of the file''s read/write head. */	int position;	if (!!sqFileValid(f)) return success(false);	position = ftell(f->file);	if (position < 0) return success(false);	return position;}int sqFileInit(void) {	/* Create a session ID that is unlikely to be repeated.	   Zero is never used for a valid session number.	   Should be called once at startup time.	*/	thisSession = clock() + time(NULL);	if (thisSession == 0) thisSession = 1;	/* don''t use 0 */}int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag) {	/* Opens the given file using the supplied sqFile structure	   to record its state. Fails with no side effects if f is	   already open. Files are always opened in binary mode;	   Squeak must take care of any line-end character mapping.	*/	char cFileName[1001];	int i;	/* don''t open an already open file */	if (sqFileValid(f)) return success(false);	/* copy the file name into a null-terminated C string */	if (sqFileNameSize > 1000) {		return success(false);	}	for (i = 0; i < sqFileNameSize; i++) {		cFileName[i] = *((char *) (sqFileNameIndex + i));	}	cFileName[sqFileNameSize] = 0;	if (writeFlag) {		/* First try to open an existing file read/write: */		f->file = fopen(cFileName, "r+b");		if (f->file == NULL) {			/* Previous call fails if file does not exist. In that case,			   try opening it in write mode to create a new, empty file.			*/			f->file = fopen(cFileName, "w+b");			if (f->file !!= NULL) {				/* set the type and creator of newly created Mac files */				dir_SetMacFileTypeAndCreator(cFileName, strlen(cFileName), "TEXT", "R*ch");				}		}		f->writable = true;	} else {		f->file = fopen(cFileName, "rb");		f->writable = false;	}	if (f->file == NULL) {		f->sessionID = 0;		f->fileSize = 0;		return success(false);	} else {		f->sessionID = thisSession;		/* compute and cache file size */		fseek(f->file, 0, SEEK_END);		f->fileSize = ftell(f->file);		fseek(f->file, 0, SEEK_SET);	}	f->lastOp = UNCOMMITTED;}int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Read count bytes from the given file into byteArray starting at	   startIndex. byteArray is the address of the first byte of a	   Squeak bytes object (e.g. String or ByteArray). startIndex	   is a zero-based index; that is a startIndex of 0 starts writing	   at the first byte of byteArray.	*/	char *dst;	int bytesRead;	if (!!sqFileValid(f)) return success(false);	if (f->writable && (f->lastOp == WRITE_OP)) fseek(f->file, 0, SEEK_CUR);  /* seek between writing and reading */	dst = (char *) (byteArrayIndex + startIndex);	bytesRead = fread(dst, 1, count, f->file);	f->lastOp = READ_OP;	return bytesRead;}int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize) {	char cOldName[1000], cNewName[1000];	int i, err;	if ((oldNameSize >= 1000) || (newNameSize >= 1000)) {		return success(false);	}	/* copy the file names into null-terminated C strings */	for (i = 0; i < oldNameSize; i++) {		cOldName[i] = *((char *) (oldNameIndex + i));	}	cOldName[oldNameSize] = 0;	for (i = 0; i < newNameSize; i++) {		cNewName[i] = *((char *) (newNameIndex + i));	}	cNewName[newNameSize] = 0;	err = rename(cOldName, cNewName);	if (err) {		return success(false);	}}int sqFileSetPosition(SQFile *f, int position) {	/* Set the file''s read/write head to the given position. */	if (!!sqFileValid(f)) return success(false);	fseek(f->file, position, SEEK_SET);	f->lastOp = UNCOMMITTED;}int sqFileSize(SQFile *f) {	/* Return the length of the given file. */	if (!!sqFileValid(f)) return success(false);	return f->fileSize;}int sqFileValid(SQFile *f) {	return (		(f !!= NULL) &&		(f->file !!= NULL) &&		(f->sessionID == thisSession));}int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Write count bytes to the given writable file starting at startIndex	   in the given byteArray. (See comment in sqFileReadIntoAt for interpretation	   of byteArray and startIndex).	*/	char *src;	int bytesWritten, position;	if (!!(sqFileValid(f) && f->writable)) return success(false);	if (f->lastOp == READ_OP) fseek(f->file, 0, SEEK_CUR);  /* seek between reading and writing */	src = (char *) (byteArrayIndex + startIndex);	bytesWritten = fwrite(src, 1, count, f->file);	position = ftell(f->file);	if (position > f->fileSize) {		f->fileSize = position;  /* update file size */	}	if (bytesWritten !!= count) {		success(false);	}	f->lastOp = WRITE_OP;	return bytesWritten;}'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/6/98 12:08'!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqMachDep.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C *//* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/*** increment this version number when the image file format changes ***/#define CURRENT_VERSION 6502/* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMicroMSecs(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);/* millisecond clock */#ifdef USE_CLOCK_MSECS# define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)#else  int ioMSecs(void);#endif/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFromFileHeapSize(FILE *f, int desiredHeapSize);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* sound output */int snd_AvailableSpace(void);int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex);int snd_Stop(void);/* sound input */int snd_SetRecordLevel(int level);int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex);int snd_StopRecording(void);double snd_GetRecordingSampleRate(void);int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes);/* joystick support */int joystickInit(void);int joystickRead(int stickIndex);/* netscape plug-in support */int plugInInit(char *imageName);int plugInShutdown(void);int plugInInterpretCycles(int cycleCount);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* squeak socket record; see sqMacNetwork.c for details */typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/8/98 14:32'!squeakMachDepFile	^ '/* Platform/compiler dependent support for dynamic translation. */#include "sqConfig.h"#if defined(__GNUC__)  /* GNU C on any platform */# define initOp(O)	(opcodeAddress= (int)(&&_op_##O) + 1)# if defined(JUMP_ALIGN_BYTE)    /* guarantee an even address for opcode start, then 1-byte no-op */#   define beginOp(O)	asm (".align 2"); _op_##O: asm("nop")# else#   define beginOp(O)	_op_##O:# endif# if defined(JUMP_ALIGN_STRICT)#   define nextOp()	({ goto *(void *)(*(int *)(localIP+= 4)-1); 0; })# else#   define nextOp()	({ goto *(void *)(*(int *)(localIP+= 4)); 0; })# endif# define endOp(O)	nextOp()#elif defined (macintosh)# if defined (__POWERPC__)    /* PowerMac: assumes CodeWarrior 8 or later (other compilers might barf) */#   pragma internal on    static asm int _setLabel(register int *ap, register int tmp)    {      mflr tmp			// address of insn after call site      addi tmp, tmp, 9	// address of opcode start + tag bit      stw  tmp, 0(ap)	// &opcode -> *store      li   r3, 1		// answer "true"      blr    }    static asm int _gotoLabel(register int ip)    {      mtlr ip	// destination address      blr		// dispatch    }#   pragma internal off# else /*!!__POWERPC__*/    /* 68K Mac: assumes CodeWarrior 8 or later (other compilers might barf) */    static asm int _setLabel(register int *ap, int ignored)    {      // the following is gross, but the 68K has a short branch range      // that is just large enough to be used in a few cases.  we have      // to find the opcode start address by "disassembling" the code      // following the call to _setLabel.  (efficiency is irrelevant.)      move.l	(sp), a0	// insn after call site	l:move.w	(a0)+, d0	// next insn	  and.w		#0xFF00, d0	// lose disp8	  cmp.w		#0x6600, d0	// BNE[.S]?	  bne.s		l			// not yet	  move.w	-2(a0), d0	// BNE[.S]	  tst.b		d0			// disp = 0?	  bne.s		s			// no [disp8]	  addq.l	#2, a0		// yes [disp16]	s:move.l	a0, d0		// opcode	  addq.l	#1, d0		// + tag	  move.l	4(sp), a0	// &store      move.l	d0, (a0)	// op -> *store      rts					// ^true    }    static asm int _gotoLabel(register int ip)    {      // I think this is optimal (speedwise), but my 68k is very rusty.      // (the 68020 can probably do the double indirection with index in      // a single instruction, but I''m not convinced it''s any faster.)      // please submit a better (i.e. faster) solution if you have one!!      addq.l	#4, sp		// drop ret addr      move.l	(sp)+, a0	// pop ip      jmp		-1(a0)		// dispatch = ip - tag    }# endif /*!!__POWERPC__*/# define initOp(O)	_setLabel(&opcodeAddress, 0)# define beginOp(O)# define nextOp()	_gotoLabel(*(int *)(localIP+= 4))# define endOp(O)	nextOp()#else# error your platform/compiler is not supported#endif'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 1/6/98 13:48'!squeakOldSoundPrimsFile	^ '/* Automatically generated from Squeak on (4 January 1998 3:05:25 am ) */#include "sq.h"/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Imported Functions/Variables ***/extern int stackValue(int);extern int successFlag;/*** Variables ***//*** Function Prototypes ***/int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void) {    int rcvr;    int n;    short int *aSoundBuffer;    int startIndex;    int pan;    int mySample;    int sample;    int lastIndex;    int channelIndex;    int i;    short int *waveTable;    int waveTableSize;    int count;    int amplitude;    int increment;    int index;    int modulation;    int offsetIncrement;    int offsetIndex;	rcvr = stackValue(4);	n = checkedIntegerValueOf(stackValue(3));	aSoundBuffer = arrayValueOf(stackValue(2));	startIndex = checkedIntegerValueOf(stackValue(1));	pan = checkedIntegerValueOf(stackValue(0));	waveTable = fetchArrayofObject(1, rcvr);	waveTableSize = fetchIntegerofObject(2, rcvr);	count = fetchIntegerofObject(4, rcvr);	amplitude = fetchIntegerofObject(6, rcvr);	increment = fetchIntegerofObject(8, rcvr);	index = fetchIntegerofObject(9, rcvr);	modulation = fetchIntegerofObject(11, rcvr);	offsetIncrement = fetchIntegerofObject(14, rcvr);	offsetIndex = fetchIntegerofObject(15, rcvr);	if (!!(successFlag)) {		return null;	}	lastIndex = (startIndex + n) - 1;	for (i = startIndex; i <= lastIndex; i += 1) {		mySample = (amplitude * (waveTable[index - 1])) / 1000;		if (pan > 0) {			channelIndex = 2 * i;			sample = (aSoundBuffer[channelIndex - 1]) + ((mySample * pan) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		if (pan < 1000) {			channelIndex = (2 * i) - 1;			sample = (aSoundBuffer[channelIndex - 1]) + ((mySample * (1000 - pan)) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		index = (index + increment) + ((modulation * (waveTable[offsetIndex - 1])) / 1000000);		if (index > waveTableSize) {			index -= waveTableSize;		}		if (index < 1) {			index += waveTableSize;		}		offsetIndex += offsetIncrement;		if (offsetIndex > waveTableSize) {			offsetIndex -= waveTableSize;		}	}	count -= n;	storeIntegerofObjectwithValue(4, rcvr, count);	storeIntegerofObjectwithValue(9, rcvr, index);	storeIntegerofObjectwithValue(15, rcvr, offsetIndex);	pop(4);}int primPluckedSoundmixSampleCountintostartingAtpan(void) {    int rcvr;    int n;    short int *aSoundBuffer;    int startIndex;    int pan;    int lastIndex;    int channelIndex;    int i;    int sample;    int mySample;    int thisIndex;    int nextIndex;    int count;    short int *ring;    int ringSize;    int ringIndx;	rcvr = stackValue(4);	n = checkedIntegerValueOf(stackValue(3));	aSoundBuffer = arrayValueOf(stackValue(2));	startIndex = checkedIntegerValueOf(stackValue(1));	pan = checkedIntegerValueOf(stackValue(0));	count = fetchIntegerofObject(2, rcvr);	ring = fetchArrayofObject(4, rcvr);	ringSize = fetchIntegerofObject(5, rcvr);	ringIndx = fetchIntegerofObject(6, rcvr);	if (!!(successFlag)) {		return null;	}	lastIndex = (startIndex + n) - 1;	thisIndex = ringIndx;	for (i = startIndex; i <= lastIndex; i += 1) {		nextIndex = (thisIndex % ringSize) + 1;		mySample = ((ring[thisIndex - 1]) + (ring[nextIndex - 1])) / 2;		ring[thisIndex - 1] = mySample;		thisIndex = nextIndex;		if (pan > 0) {			channelIndex = 2 * i;			sample = (aSoundBuffer[channelIndex - 1]) + ((mySample * pan) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		if (pan < 1000) {			channelIndex = (2 * i) - 1;			sample = (aSoundBuffer[channelIndex - 1]) + ((mySample * (1000 - pan)) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}	}	ringIndx = nextIndex;	count -= n;	storeIntegerofObjectwithValue(2, rcvr, count);	storeIntegerofObjectwithValue(6, rcvr, ringIndx);	pop(4);}int primSampledSoundmixSampleCountintostartingAtpan(void) {    int rcvr;    int n;    short int *aSoundBuffer;    int startIndex;    int pan;    int lastIndex;    int i;    int channelIndex;    int sample;    int sampleIndex;    int thisSample;    short int *samples;    int samplesSize;    int incrementTimes1000;    int count;    int indexTimes1000;	rcvr = stackValue(4);	n = checkedIntegerValueOf(stackValue(3));	aSoundBuffer = arrayValueOf(stackValue(2));	startIndex = checkedIntegerValueOf(stackValue(1));	pan = checkedIntegerValueOf(stackValue(0));	samples = fetchArrayofObject(1, rcvr);	samplesSize = fetchIntegerofObject(2, rcvr);	incrementTimes1000 = fetchIntegerofObject(3, rcvr);	count = fetchIntegerofObject(5, rcvr);	indexTimes1000 = fetchIntegerofObject(6, rcvr);	if (!!(successFlag)) {		return null;	}	lastIndex = (startIndex + n) - 1;	i = startIndex;	sampleIndex = indexTimes1000 / 1000;	while ((sampleIndex <= samplesSize) && (i <= lastIndex)) {		thisSample = samples[sampleIndex - 1];		if (pan > 0) {			channelIndex = 2 * i;			sample = (aSoundBuffer[channelIndex - 1]) + ((thisSample * pan) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		if (pan < 1000) {			channelIndex = (2 * i) - 1;			sample = (aSoundBuffer[channelIndex - 1]) + ((thisSample * (1000 - pan)) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		indexTimes1000 += incrementTimes1000;		sampleIndex = indexTimes1000 / 1000;		i += 1;	}	count -= n;	storeIntegerofObjectwithValue(5, rcvr, count);	storeIntegerofObjectwithValue(6, rcvr, indexTimes1000);	pop(4);}int primWaveTableSoundmixSampleCountintostartingAtpan(void) {    int rcvr;    int n;    short int *aSoundBuffer;    int startIndex;    int pan;    int lastIndex;    int channelIndex;    int i;    int mySample;    int sample;    short int *waveTable;    int waveTableSize;    int count;    int amplitude;    int increment;    int index;	rcvr = stackValue(4);	n = checkedIntegerValueOf(stackValue(3));	aSoundBuffer = arrayValueOf(stackValue(2));	startIndex = checkedIntegerValueOf(stackValue(1));	pan = checkedIntegerValueOf(stackValue(0));	waveTable = fetchArrayofObject(1, rcvr);	waveTableSize = fetchIntegerofObject(2, rcvr);	count = fetchIntegerofObject(4, rcvr);	amplitude = fetchIntegerofObject(6, rcvr);	increment = fetchIntegerofObject(8, rcvr);	index = fetchIntegerofObject(9, rcvr);	if (!!(successFlag)) {		return null;	}	lastIndex = (startIndex + n) - 1;	for (i = startIndex; i <= lastIndex; i += 1) {		mySample = (amplitude * (waveTable[index - 1])) / 1000;		if (pan > 0) {			channelIndex = 2 * i;			sample = (aSoundBuffer[channelIndex - 1]) + ((mySample * pan) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		if (pan < 1000) {			channelIndex = (2 * i) - 1;			sample = (aSoundBuffer[channelIndex - 1]) + ((mySample * (1000 - pan)) / 1000);			if (sample > 32767) {				sample = 32767;			}			if (sample < -32767) {				sample = -32767;			}			aSoundBuffer[channelIndex - 1] = sample;		}		index += increment;		if (index > waveTableSize) {			index -= waveTableSize;		}	}	count -= n;	storeIntegerofObjectwithValue(4, rcvr, count);	storeIntegerofObjectwithValue(9, rcvr, index);	pop(4);}'.! !!Interval methodsFor: 'accessing' stamp: 'di 11/10/97 12:22'!includes: aNumber	^ aNumber between: self first and: self last! !!KeyboardBuffer methodsFor: 'all' stamp: 'di 9/30/97 19:53'!commandKeyPressed	^ event commandKeyPressed! !!KeyboardBuffer methodsFor: 'all' stamp: 'di 9/30/97 19:54'!controlKeyPressed	^ event controlKeyPressed! !!KeyboardBuffer methodsFor: 'all' stamp: 'di 9/29/97 12:34'!flushKeyboard	eventUsed ifFalse: [^ eventUsed _ true].! !!KeyboardBuffer methodsFor: 'all' stamp: 'di 9/29/97 12:34'!keyboard	eventUsed ifFalse: [eventUsed _ true.  ^ event keyCharacter].	^ nil! !!KeyboardBuffer methodsFor: 'all' stamp: 'di 9/29/97 12:34'!keyboardPeek	eventUsed ifFalse: [^ event keyCharacter].	^ nil! !!KeyboardBuffer methodsFor: 'all' stamp: 'di 9/29/97 12:34'!keyboardPressed	^ eventUsed not! !!KeyboardBuffer methodsFor: 'all' stamp: 'di 9/30/97 19:54'!leftShiftDown	^ event shiftPressed! !!KeyboardBuffer methodsFor: 'all'!startingEvent: evt	event _ evt.	eventUsed _ false! !LargeNegativeInteger comment:'Just like LargePositiveInteger, but represents a negative number.'!LargePositiveInteger comment:'I represent a positive large integer, integers greater than 2-to-the-30th (1073741824).  These are beyond the range of SmallInteger, encoded as an array of 8-bit digits.  Care must be taken, when new results are computed, that any value that COULD BE a SmallInteger IS a SmallInteger (see normalize).'!!LargePositiveInteger methodsFor: 'arithmetic'!* anInteger 	"Primitive. Multiply the receiver by the argument and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive. "	<primitive: 29>	^super * anInteger! !!LargePositiveInteger methodsFor: 'arithmetic'!+ anInteger 	"Primitive. Add the receiver to the argument and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."	<primitive: 21>	^super + anInteger! !!LargePositiveInteger methodsFor: 'arithmetic'!- anInteger 	"Primitive. Subtract the argument from the receiver and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."	<primitive: 22>	^super - anInteger! !!LargePositiveInteger methodsFor: 'arithmetic'!/ anInteger 	"Primitive. Divide the receiver by the argument and answer with the	result if the division is exact. Fail if the result is not a whole integer.	Fail if the argument is 0. Fail if either the argument or the result is not	a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive. "	<primitive: 30>	^super / anInteger! !!LargePositiveInteger methodsFor: 'arithmetic'!// anInteger 	"Primitive. Divide the receiver by the argument and return the result.	Round the result down towards negative infinity to make it a whole	integer. Fail if the argument is 0. Fail if either the argument or the	result is not a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824).	Optional. See Object documentation whatIsAPrimitive. "	<primitive: 32>	^super // anInteger! !!LargePositiveInteger methodsFor: 'arithmetic'!quo: anInteger 	"Primitive. Divide the receiver by the argument and return the result.	Round the result down towards zero to make it a whole integer. Fail if	the argument is 0. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."	<primitive: 33>	^super quo: anInteger! !!LargePositiveInteger methodsFor: 'arithmetic'!\\ anInteger 	"Primitive. Take the receiver modulo the argument. The result is the	remainder rounded towards negative infinity, of the receiver divided	by the argument. Fail if the argument is 0. Fail if either the argument	or the result is not a SmallInteger or a LargePositiveInteger less than	2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 31>	^super \\ anInteger! !!LargePositiveInteger methodsFor: 'comparing'!< anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than the argument. Otherwise answer false. Fail if the	argument is not a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824).	Optional. See Object documentation whatIsAPrimitive."	<primitive: 23>	^super < anInteger! !!LargePositiveInteger methodsFor: 'comparing'!<= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than or equal to the argument. Otherwise answer false.	Fail if the argument is not a SmallInteger or a LargePositiveInteger less	than 2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 25>	^super <= anInteger! !!LargePositiveInteger methodsFor: 'comparing'!= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is equal to the argument. Otherwise answer false. Fail if the	receiver or argument is negative or greater than 32 bits.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 7>	^ super = anInteger! !!LargePositiveInteger methodsFor: 'comparing'!> anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than the argument. Otherwise answer false. Fail if	the argument is not a SmallInteger or a LargePositiveInteger less than	2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 24>	^super > anInteger! !!LargePositiveInteger methodsFor: 'comparing'!>= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than or equal to the argument. Otherwise answer	false. Fail if the argument is not a SmallInteger or a LargePositiveInteger	less than 2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 26>	^super >= anInteger! !!LayoutMorph methodsFor: 'initialization' stamp: 'sw 9/10/97 14:47'!initialize	super initialize.	borderWidth _ 0.	orientation _ #horizontal.	"#horizontal or #vertical  or #free"	centering _ #topLeft.		"#topLeft, #center, or #bottomRight"	hResizing _ #spaceFill.		"#spaceFill, #shrinkWrap, or #rigid"	vResizing _ #spaceFill.		"#spaceFill, #shrinkWrap, or #rigid"	inset _ 2.					"pixels inset within owner's bounds"	minCellSize _ 0.				"minimum space between morphs; useful for tables"	openToDragNDrop _ false.	"objects can be dropped in or dragged out"	layoutNeeded _ true.	color _ Color r: 0.8 g: 1.0 b: 0.8.! !!LayoutMorph methodsFor: 'classification' stamp: 'sw 10/3/97 18:24'!demandsBoolean	self flag: #deferred.	"Answer whether the receiver insists on a boolean-valued droppee"	(submorphs size < 2 or: [(submorphs second isKindOf: StringMorph) not]) ifTrue:		[^ false].	^ submorphs second contents = 'Test'! !!LayoutMorph methodsFor: 'classification'!isLayoutMorph	^ true! !!LayoutMorph methodsFor: 'accessing'!centering	^ centering! !!LayoutMorph methodsFor: 'accessing'!centering: aSymbol	"Set the minor dimension alignment to #topLeft, #center, or #bottomRight."	centering _ aSymbol.! !!LayoutMorph methodsFor: 'accessing' stamp: 'sw 9/11/97 16:27'!chooseOrientation	| aMenu emphases reply |	emphases _ #(vertical horizontal free).	aMenu _ EmphasizedMenu selections: emphases.	aMenu onlyBoldItem: (emphases indexOf: orientation).	reply _ aMenu startUpWithCaption: 'Choose orientation'.	(reply == nil or: [reply == orientation]) ifTrue: [^ self].	self orientation: reply.	self layoutChanged! !!LayoutMorph methodsFor: 'accessing' stamp: 'sw 10/19/97 23:39'!configureForKids	self openToDragNDrop: false.	super configureForKids! !!LayoutMorph methodsFor: 'accessing'!hResizing	^ hResizing! !!LayoutMorph methodsFor: 'accessing'!hResizing: aSymbol	"Set the horizontal resizing style to #spaceFill, #shrinkWrap, or #rigid."	hResizing _ aSymbol.! !!LayoutMorph methodsFor: 'accessing'!inset	^ inset! !!LayoutMorph methodsFor: 'accessing'!inset: anInteger	"Set the amount of padding within my bounds to the given amount."	inset _ anInteger.! !!LayoutMorph methodsFor: 'accessing'!minCellSize	^ minCellSize! !!LayoutMorph methodsFor: 'accessing'!minCellSize: anInteger	"Set the minium space per submorph to the given size. Useful for making tables."	minCellSize _ anInteger.! !!LayoutMorph methodsFor: 'accessing'!openCloseDragNDrop	"Toggle this morph's ability to add and remove morphs via drag-n-drop."	openToDragNDrop _ openToDragNDrop not.! !!LayoutMorph methodsFor: 'accessing'!openToDragNDrop	^ openToDragNDrop! !!LayoutMorph methodsFor: 'accessing'!openToDragNDrop: aBoolean	"Set this morph's ability to add and remove morphs via drag-n-drop."	openToDragNDrop _ aBoolean.! !!LayoutMorph methodsFor: 'accessing'!orientation	^ orientation! !!LayoutMorph methodsFor: 'accessing' stamp: 'sw 9/10/97 14:55'!orientation: aSymbol	"Set the major layout dimension to #horizontal or #vertical or #free"	orientation _ aSymbol.! !!LayoutMorph methodsFor: 'accessing'!vResizing	^ vResizing! !!LayoutMorph methodsFor: 'accessing'!vResizing: aSymbol	"Set the vertical resizing style to #spaceFill, #shrinkWrap, or #rigid."	vResizing _ aSymbol.! !!LayoutMorph methodsFor: 'geometry' stamp: 'jm 7/8/97 08:26'!layoutChanged	"invalidate old fullBounds in case we shrink"	fullBounds ifNotNil: [self invalidRect: fullBounds].	super layoutChanged.	layoutNeeded _ true.! !!LayoutMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/18/97 18:03'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add submorphs just by dropping them on this morph."	self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).	self changed.	self layoutChanged.! !!LayoutMorph methodsFor: 'dropping/grabbing'!allowSubmorphExtraction	^ openToDragNDrop! !!LayoutMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/18/97 18:19'!rootForGrabOf: aMorph	| root |	openToDragNDrop ifFalse: [^ super rootForGrabOf: aMorph].	root _ aMorph.	[root == self] whileFalse:		[root owner = self ifTrue: [^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!LayoutMorph methodsFor: 'dropping/grabbing'!wantsDroppedMorph: aMorph event: evt	"Supports adding morphs by dropping."	^ openToDragNDrop! !!LayoutMorph methodsFor: 'layout'!fullBounds	"This is the hook that triggers lazy re-layout of layout morphs. It works because layoutChanged clears the fullBounds cache. Once per cycle, the fullBounds is requested from every morph in the world, and that request gets propagated through the entire submorph hierarchy, causing re-layout where needed. Note that multiple layoutChanges to the same morph can be done with little cost, since the layout is only done when the morph needs to be displayed."	fullBounds ifNil: [		layoutNeeded ifTrue: [			self resizeIfNeeded.			self fixLayout.			"compute fullBounds before calling changed to avoid infinite recursion"			super fullBounds.  "updates cache"			self changed.  "report change due to layout"			layoutNeeded _ false]].	^ super fullBounds! !!LayoutMorph methodsFor: 'layout' stamp: 'sw 9/11/97 16:25'!maxWidth	"Return the minimum width for this morph."	| spaceNeeded minW |	hResizing = #rigid ifTrue: [^ self fullBounds width].	submorphs isEmpty ifTrue: [^ self minWidthWhenEmpty].	orientation == #horizontal ifTrue:		[spaceNeeded _ 2 * (inset + borderWidth).		submorphs do: [:m | spaceNeeded _ spaceNeeded + (m minWidth max: minCellSize)]].	orientation == #vertical ifTrue:		[minW _ 0.		submorphs do: [:m | minW _ minW max: m minWidth].		spaceNeeded _ minW + (2 * (inset + borderWidth))].	orientation == #free ifTrue:		[spaceNeeded _ 0.		submorphs do: [:m | spaceNeeded _ spaceNeeded max: m x]].	^ spaceNeeded! !!LayoutMorph methodsFor: 'layout' stamp: 'sw 9/11/97 16:39'!minHeight	"Return the minimum height for this morph."	| minH spaceNeeded |	vResizing = #rigid ifTrue: [^ self fullBounds height].	submorphs isEmpty ifTrue: [^ self minHeightWhenEmpty].	orientation == #horizontal ifTrue:		[minH _ 0.		submorphs do: [:m | minH _ minH max: m minHeight].		spaceNeeded _ minH + (2 * (inset + borderWidth))].	orientation == #vertical ifTrue:		[spaceNeeded _ 2 * (inset + borderWidth).		submorphs do: [:m | spaceNeeded _ spaceNeeded + (m minHeight max: minCellSize)]].	orientation == #free ifTrue:		[minH _ 0.		submorphs do: [:m | minH _ minH max: m bounds bottom.		spaceNeeded _ minH + (2 * inset)]].	^ spaceNeeded! !!LayoutMorph methodsFor: 'layout'!minHeightWhenEmpty	^ 5! !!LayoutMorph methodsFor: 'layout' stamp: 'sw 9/11/97 16:37'!minWidth	"Return the minimum width for this morph."	| spaceNeeded minW |	hResizing = #rigid ifTrue: [^ self fullBounds width].	submorphs isEmpty ifTrue: [^ self minWidthWhenEmpty].	orientation == #horizontal ifTrue:		[spaceNeeded _ 2 * (inset + borderWidth).		submorphs do: [:m | spaceNeeded _ spaceNeeded + (m minWidth max: minCellSize)]].	orientation == #vertical ifTrue:		[minW _ 0.		submorphs do: [:m | minW _ minW max: m minWidth].		spaceNeeded _ minW + (2 * (inset + borderWidth))].	orientation == #free ifTrue:		[minW _ 0.		submorphs do: [:m | minW _ minW max: m bounds right.			spaceNeeded _ minW + (2 * inset)]].	^ spaceNeeded! !!LayoutMorph methodsFor: 'layout'!minWidthWhenEmpty	^ 5! !!LayoutMorph methodsFor: 'menu' stamp: 'sw 9/11/97 16:07'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'orientation...' action: #chooseOrientation.	aCustomMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.! !!LayoutMorph methodsFor: 'private'!extraSpacePerMorph	| spaceFillingMorphs spaceNeeded extra |	spaceFillingMorphs _ 0.	spaceNeeded _ 2 * (inset + borderWidth).	orientation = #horizontal ifTrue: [		submorphs do: [:m |			spaceNeeded _ spaceNeeded + (m minWidth max: minCellSize).			(m isLayoutMorph and: [m hResizing = #spaceFill])				ifTrue: [spaceFillingMorphs _ spaceFillingMorphs + 1]].		extra _ (bounds width - spaceNeeded) max: 0.	] ifFalse: [		submorphs do: [:m |			spaceNeeded _ spaceNeeded + (m minHeight max: minCellSize).			(m isLayoutMorph and: [m vResizing = #spaceFill])				ifTrue: [spaceFillingMorphs _ spaceFillingMorphs + 1]].		extra _ (bounds height - spaceNeeded) max: 0].	(submorphs size <= 1 or: [spaceFillingMorphs <= 1]) ifTrue: [^ extra].	^ extra // spaceFillingMorphs! !!LayoutMorph methodsFor: 'private' stamp: 'sw 9/10/97 14:57'!fixLayout	| extraPerMorph nextPlace space |	orientation == #free ifTrue: [^ self].	extraPerMorph _ self extraSpacePerMorph.	orientation = #horizontal		ifTrue: [nextPlace _ bounds left + inset + borderWidth]		ifFalse: [nextPlace _ bounds top + inset + borderWidth].	submorphs do: [:m |		space _ self placeAndSize: m at: nextPlace padding: extraPerMorph.		nextPlace _ nextPlace + space].! !!LayoutMorph methodsFor: 'private' stamp: 'sw 9/10/97 14:54'!insertionIndexFor: aMorph	"Return the index at which the given morph should be inserted into the submorphs of the receiver."	| newCenter |	newCenter _ aMorph fullBounds center.	orientation == #horizontal ifTrue:		[submorphs doWithIndex: [:m :i |			newCenter x < m fullBounds center x ifTrue: [^ i]]].	orientation == #vertical ifTrue:		[submorphs doWithIndex: [:m :i |			newCenter y < m fullBounds center y ifTrue: [^ i]]].	^ submorphs size + 1  "insert after the last submorph"! !!LayoutMorph methodsFor: 'private'!layoutInWidth: w height: h	"Adjust the size of the receiver in its space-filling dimensions during layout. This message is sent to only to layout submorphs."	((hResizing = #spaceFill) and: [bounds width ~= w]) ifTrue: [		bounds _ bounds origin extent: (w @ bounds height).		fullBounds _ nil.		layoutNeeded _ true].	((vResizing = #spaceFill) and: [bounds height ~= h]) ifTrue: [		bounds _ bounds origin extent: (bounds width @ h).		fullBounds _ nil.		layoutNeeded _ true].! !!LayoutMorph methodsFor: 'private'!placeAndSize: m at: nextPlace padding: padding	| space totalInset fullBnds left top |	totalInset _ inset + borderWidth.	orientation = #horizontal ifTrue: [		space _ m minWidth max: minCellSize.		m isLayoutMorph ifTrue: [			(m hResizing = #spaceFill) ifTrue: [space _ space + padding].			m layoutInWidth: space height: (bounds height - (2 * totalInset))].	] ifFalse: [		space _ m minHeight max: minCellSize.		m isLayoutMorph ifTrue: [			(m vResizing = #spaceFill) ifTrue: [space _ space + padding].			m layoutInWidth: (bounds width - (2 * totalInset)) height: space]].	fullBnds _ m fullBounds.	orientation = #horizontal ifTrue: [		left _ nextPlace.		centering = #topLeft			ifTrue: [top _ bounds top + totalInset].		centering = #bottomRight			ifTrue: [top _ bounds bottom - totalInset - fullBnds height].		centering = #center			ifTrue: [top _ bounds top + ((bounds height - fullBnds height) // 2)].	] ifFalse: [		top _ nextPlace.		centering = #topLeft			ifTrue: [left _ bounds left + totalInset].		centering = #bottomRight			ifTrue: [left _ bounds right - totalInset - fullBnds width].		centering = #center			ifTrue: [left _ bounds left + ((bounds width - fullBnds width) // 2)]].	m position: (left + (m bounds left - fullBnds left)) @ (top + (m bounds top - fullBnds top)).	^ space! !!LayoutMorph methodsFor: 'private'!resizeIfNeeded	"Resize this morph if it is space-filling or shrink-wrap and its owner is not a layout morph."	| newWidth newHeight |	newWidth _ bounds width.	newHeight _ bounds height.	(owner == nil or: [owner isLayoutMorph not]) ifTrue: [		"if spaceFill and not in a LayoutMorph, grow to enclose submorphs"		hResizing = #spaceFill ifTrue: [newWidth _ self minWidth max: self bounds width].		vResizing = #spaceFill ifTrue: [newHeight _ self minHeight max: self bounds height]].	"if shrinkWrap, adjust size to just fit around submorphs"	hResizing = #shrinkWrap ifTrue: [newWidth _ self minWidth].	vResizing = #shrinkWrap ifTrue: [newHeight _ self minHeight].	((newWidth ~= bounds width) or: [newHeight ~= bounds height]) ifTrue: [		"bounds really changed; flush fullBounds cache and fix submorph layouts"		bounds _ bounds origin extent: newWidth@newHeight.		fullBounds _ nil].! !!LayoutMorph class methodsFor: 'instance creation'!newColumn	^ self new		orientation: #vertical;		hResizing: #spaceFill;		vResizing: #spaceFill! !!LayoutMorph class methodsFor: 'instance creation'!newRow	^ self new		orientation: #horizontal;		hResizing: #spaceFill;		vResizing: #spaceFill;		borderWidth: 0! !!LayoutMorph class methodsFor: 'instance creation'!newRowHeight: h	^ self new		orientation: #horizontal;		hResizing: #spaceFill;		vResizing: #rigid;		extent: (3*h)@h! !LeafNode comment:'I represent a leaf node of the compiler parse tree. I am abstract.	Types (defined in class ParseNode):	1 LdInstType (which uses class VariableNode)	2 LdTempType (which uses class VariableNode)	3 LdLitType (which uses class LiteralNode)	4 LdLitIndType (which uses class VariableNode)	5 SendType (which uses class SelectorNode).Note that Squeak departs slightly from the Blue Book bytecode spec.In order to allow access to more than 63 literals and instance variables,bytecode 132 has been redefined as DoubleExtendedDoAnything:		byte2				byte3			Operation(hi 3 bits)  (lo 5 bits)	0		nargs			lit index			Send Literal Message 0-255	1		nargs			lit index			Super-Send Lit Msg 0-255	2		ignored			rcvr index		Push Receiver Variable 0-255	3		ignored			lit index			Push Literal Constant 0-255	4		ignored			lit index			Push Literal Variable 0-255	5		ignored			rcvr index		Store Receiver Variable 0-255	6		ignored			rcvr index		Store-pop Receiver Variable 0-255	7		ignored			lit index			Store Literal Variable 0-255	This has allowed bytecode 134 also to be redefined as a second extended send	that can access literals up to 64 for nargs up to 3 without needing three bytes.	It is just like 131, except that the extension byte is aallllll instead of aaalllll,	where aaa are bits of argument count, and lll are bits of literal index.'!!LeafNode methodsFor: 'code generation'!emitLong: mode on: aStream 	"Emit extended variable access."	| type index |	code < 256		ifTrue:			[code < 16			ifTrue: [type _ 0.					index _ code]			ifFalse: [code < 32					ifTrue: [type _ 1.							index _ code - 16]					ifFalse: [code < 96							ifTrue: [type _ code // 32 + 1.									index _ code \\ 32]							ifFalse: [self error: 									'Sends should be handled in SelectorNode']]]]		ifFalse: 			[index _ code \\ 256.			type _ code // 256 - 1].	index <= 63 ifTrue:		[aStream nextPut: mode.		^ aStream nextPut: type * 64 + index].	"Compile for Double-exetended Do-anything instruction..."	mode = LoadLong ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(64 0 96 128) at: type+1).  "Cant be temp (type=1)"		^ aStream nextPut: index].	mode = Store ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(160 0 0 224) at: type+1).  "Cant be temp or const (type=1 or 2)"		^ aStream nextPut: index].	mode = StorePop ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(192 0 0 0) at: type+1).  "Can only be inst"		^ aStream nextPut: index].! !!LeafNode methodsFor: 'code generation'!sizeForValue: encoder	self reserve: encoder.	code < 256 ifTrue: [^ 1].	(code \\ 256) <= 63 ifTrue: [^ 2].	^ 3! !!LimitedWriteStream methodsFor: 'all' stamp: 'di 6/20/97 08:55'!pastEndPut: anObject	collection size >= limit ifTrue: [limitBlock value].  "Exceptional return"	collection _ collection ,		(collection class new: ((collection size max: 20) min: limit)).	writeLimit _ collection size.	collection at: (position _ position + 1) put: anObject! !!LimitedWriteStream methodsFor: 'all' stamp: 'di 6/20/97 09:07'!setLimit: sizeLimit limitBlock: aBlock	"Limit the numer of elements this stream will write..."	limit _ sizeLimit.	"Execute this (typically ^ contents) when that limit is exceded"	limitBlock _ aBlock! !LinkedMessageSet comment:'An instance of me holds a list of methods (or class comment, class defintion, class hierarchy).  When a user clicks on a HyperText link, the place referred to is displayed in me.  The non-method contents are not meant to be edited and accepted.To create a link to a class comment:In any piece of text, type the name of a class.Select it.Command-6.Choose ''go to comment of class''Then a user can click on that text later and she will be transported to the class''s comment.To create a link to a method, class definition, or class hierarchy: Do the same as above, but choose the appropriate menu item. '!!LinkedMessageSet methodsFor: 'as yet unclassified' stamp: 'tk 1/16/98 16:25'!contents: aText notifying: aController	"override to handle class dfn and comment"	self setClassAndSelectorIn: [:class :selector | 		selector first isUppercase ifFalse: [			^ super contents: aText notifying: aController].		selector = #Comment ifTrue: [			class comment: aText. 			self unlock.  ^ false].		selector = #Definition ifTrue: [			"self defineClass: aText notifying: aController."			class subclassDefinerClass				evaluate: aText				notifying: aController				logged: true.			self unlock. 			^ false].		selector = #Hierarchy ifTrue: [			self inform: 'To change the hierarchy, edit the class definitions'. ^ false].		].! !!LinkedMessageSet methodsFor: 'as yet unclassified' stamp: 'di 1/15/98 23:43'!linkMethod: classAndMethod	"Make a linked message list and put this method in it.  For example, click here: LinkedMessageSet linkMethod:."	"Do some checks here on the user's text!!!!!!"	self okToChange ifFalse: [^ self].	messageList add: classAndMethod.	self changed: #messageListChanged.	self messageListIndex: messageList size.! !!LinkedMessageSet methodsFor: 'as yet unclassified' stamp: 'di 1/15/98 23:36'!selectedMessage	"Answer the source method for the currently selected message.  Allow class comment, definition, and hierarchy."	self setClassAndSelectorIn: [:class :selector | 		selector first isUppercase ifFalse: [^ class sourceMethodAt: selector].		selector = #Comment ifTrue: [^ class comment].		selector = #Definition ifTrue: [^ class definition].		selector = #Hierarchy ifTrue: [^ class printHierarchy].		^ class sourceMethodAt: selector].! !!LinkedMessageSet methodsFor: 'as yet unclassified' stamp: 'tk 1/16/98 16:45'!wantsBoldSelector	"Only when a message selected, and not a class definition, hierarchy, or comment."	^ (self messageListIndex ~= 0) and: [		self setClassAndSelectorIn: [:class :selector | selector first isUppercase not]]! !!ListController methodsFor: 'marker adjustment'!computeMarkerRegion 	"Refer to the comment in ScrollController|computeMarkerRegion."	| viewList |	viewList _ view list.	viewList compositionRectangle height = 0		ifTrue: [^ 0@0 extent: Preferences scrollBarWidth@scrollBar inside height].	^ 0@0 extent: Preferences scrollBarWidth@			((viewList clippingRectangle height asFloat /						viewList compositionRectangle height *							scrollBar inside height)					rounded min: scrollBar inside height)! !!ListPane methodsFor: 'initialization'!extent: newExtent	super extent: newExtent.	self setScrollDeltas ! !!ListPane methodsFor: 'initialization' stamp: '6/11/97 09:05 di'!list: listOfStrings	| morphList handler h loc |	scroller removeAllMorphs.	scrollBar setValue: 0.0.	listOfStrings isEmpty ifTrue: [^ self setSelectedMorph: nil].	"NOTE: we will want a quick StringMorph init message, possibly even		combined with event install and positioning"	morphList _ listOfStrings collect: [:item | StringMorph contents: item].	"Sensitize first morph and copy handler to all the rest"	morphList first on: #mouseDown send: #mouseDown:onItem: to: self.	handler _ morphList first eventHandler.	morphList do: [:m | m eventHandler: handler].	"Lay items out vertically and install them in the scroller"	h _ morphList first height "self listItemHeight".	loc _ 0@0.	morphList do: [:m | m bounds: (loc extent: 9999@h).  loc _ loc + (0@h)].	scroller addAllMorphs: morphList.	self setSelectedMorph: nil.	self setScrollDeltas! !!ListPane methodsFor: 'initialization'!setScrollDeltas	| range |	scroller hasSubmorphs ifFalse: [^ self].	range _ self totalScrollRange.	range = 0 ifTrue: [^ scrollBar scrollDelta: 0.02 pageDelta: 0.2].	scrollBar scrollDelta: (scroller firstSubmorph height / range) asFloat 			pageDelta: (self innerBounds height / range) asFloat ! !!ListPane methodsFor: 'drawing'!drawOn: aCanvas	super drawOn: aCanvas.	selectedMorph ifNotNil:		[aCanvas fillRectangle:			(((scroller transformFrom: self) invertRect: selectedMorph bounds)						intersect: scroller bounds)				color: color darker]! !!ListPane methodsFor: 'drawing'!highlightSelection	selectedMorph ifNotNil: [selectedMorph color: Color red]! !!ListPane methodsFor: 'drawing'!unhighlightSelection	selectedMorph ifNotNil: [selectedMorph color: Color black]! !!ListPane methodsFor: 'events'!mouseDown: event onItem: aMorph	self setSelectedMorph: (aMorph == selectedMorph ifTrue: [nil] ifFalse: [aMorph])! !!ListPane methodsFor: 'selection'!selectedMorph: aMorph	self unhighlightSelection.	selectedMorph _ aMorph.	selection _ aMorph ifNil: [nil] ifNotNil: [aMorph contents].	self highlightSelection! !!ListPane methodsFor: 'selection'!selection 	^ selection! !!ListPane methodsFor: 'selection'!selection: item	"Called from outside to request setting a new selection.	Assumes scroller submorphs is exactly our list"	| index theMorph |	index _ scroller submorphs findFirst: [:m | m contents = item].	index = 0 ifTrue: [^ self selectedMorph: nil].	theMorph _ scroller submorphs at: index.		"Scroll into view -- should be elsewhere"		scrollBar value: (((index-1 * theMorph height) / self totalScrollRange)								truncateTo: scrollBar scrollDelta).		scroller offset: -3 @ (self totalScrollRange * scrollBar value).	self selectedMorph: theMorph! !!ListPane methodsFor: 'selection'!setSelectedMorph: aMorph	self selectedMorph: aMorph.	self use: hitSelector orMakeModelSelectorFor: 'NewSelection:'		in: [:sel | hitSelector _ sel.  model perform: sel with: selection]! !!ListParagraph methodsFor: 'private' stamp: 'di 7/13/97 16:56'!withArray: anArray 	"Modifies self to contain the list of strings in anArray"	| startOfLine endOfLine lineIndex aString |	lines _ Array new: 20.	lastLine _ 0.	startOfLine _ 1.	endOfLine _ 1.	lineIndex _ 0.	anArray do: 		[:item | 		endOfLine _ startOfLine + item size.		"this computation allows for a cr after each line..."												"...but later we will adjust for no cr after last line"		lineIndex _ lineIndex + 1.		self lineAt: lineIndex put:			((TextLineInterval start: startOfLine stop: endOfLine				internalSpaces: 0 paddingWidth: 0)				lineHeight: textStyle lineGrid baseline: textStyle baseline).		startOfLine _ endOfLine + 1].	endOfLine _ endOfLine - 1.		"endOfLine is now the total size of the text"	self trimLinesTo: lineIndex.	aString _ String new: endOfLine.	anArray with: lines do: 		[:item :interval | 		aString			replaceFrom: interval first			to: interval last - 1			with: item asString			startingAt: 1.		interval last <= endOfLine ifTrue: [aString at: interval last put: Character cr]].	lineIndex > 0 ifTrue: [(lines at: lineIndex) stop: endOfLine].	"adjust for no cr after last line"	self text: aString asText.	anArray with: lines do: 		[:item :interval |  item isText ifTrue:			[text replaceFrom: interval first to: interval last - 1 with: item]].	self updateCompositionHeight! !!ListParagraph class methodsFor: 'instance creation'!withArray: anArray	"Convert an array of strings into a ListParagraph."	^ (super withText: Text new style: ListStyle) withArray: anArray! !!ListParagraph class methodsFor: 'initialization'!initialize  "ListParagraph initialize"	"Allow different line spacing for lists"	ListStyle _ TextStyle default copy gridForFont: 1 withLead: 1! !!ListView methodsFor: 'initialize-release'!initialize 	"Refer to the comment in View|initialize."	super initialize.	topDelimiter _ '------------'.	bottomDelimiter _ '------------'.	isEmpty _ true.	self list: Array new! !!ListView methodsFor: 'list access'!list: anArray 	"Set the list of items the receiver displays to be anArray."	| arrayCopy i |	isEmpty _ anArray isEmpty.	arrayCopy _ Array new: (anArray size + 2).	arrayCopy at: 1 put: topDelimiter.	arrayCopy at: arrayCopy size put: bottomDelimiter.	i _ 2.	anArray do: [:el | arrayCopy at: i put: el. i _ i+1].	arrayCopy _ arrayCopy copyWithout: nil.	list _ ListParagraph withArray: arrayCopy.	selection _ 0.	self positionList! !!ListView methodsFor: 'displaying'!scrollSelectionIntoView	"Selection is assumed to be on and clipped out of view.	Uses controller scrollView to keep selection right"	| delta |	(delta _ self insetDisplayBox bottom - self selectionBox bottom) < 0		ifTrue: [^ self controller scrollView: delta - (list lineGrid-1)]. "up"	(delta _ self insetDisplayBox top - self selectionBox top) > 0		ifTrue: [^ self controller scrollView: delta + 1] "down"! !!LiteralDictionary methodsFor: 'as yet unclassified'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil					or: [(element key class == anObject class) and: [element key = anObject]])					ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil					or: [(element key class == anObject class) and: [element key = anObject]])					ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!LiteralNode methodsFor: 'code generation'!emitForValue: stack on: strm	code < 256		ifTrue: [strm nextPut: code]		ifFalse: [self emitLong: LoadLong on: strm].	stack push: 1! !!LiteralNode methodsFor: 'C translation'!asTranslatorNode 	^TConstantNode new setValue: key! !Logger comment:'I am a simple stream wrapper that is used by the DynamicInterpreterSimulator to record execution traces.  I implement stream-like protocol, and either:	- forward the output to the Transcript;	- forward the output to a file;	- throw the output away.I have a unique instance, bound to the global variable InterpreterLog.'!!Logger methodsFor: 'control'!close	(stream notNil and: [stream ~~ Transcript])		ifTrue: [stream close].	stream _ nil.! !!Logger methodsFor: 'control'!logToFile: fileName	self close.	stream _ FileStream newFileNamed: fileName! !!Logger methodsFor: 'control'!logToTranscript	self close.	stream _ Transcript! !!Logger methodsFor: 'testing' stamp: 'ikp 8/10/97 08:29'!isActive	^stream ~~ nil! !!Logger methodsFor: 'testing' stamp: 'ikp 8/10/97 08:29'!isTranscript	^stream == Transcript! !!Logger methodsFor: 'logging'!cr	stream notNil ifTrue: [stream cr]! !!Logger methodsFor: 'logging' stamp: 'ikp 8/8/97 14:08'!crtab	stream notNil ifTrue: [stream crtab]! !!Logger methodsFor: 'logging' stamp: 'ikp 8/8/97 14:09'!endEntry	stream == Transcript ifTrue: [stream endEntry]! !!Logger methodsFor: 'logging'!nextPut: character	stream notNil ifTrue: [stream nextPut: character]! !!Logger methodsFor: 'logging'!nextPutAll: string	stream notNil ifTrue: [stream nextPutAll: string]! !!Logger methodsFor: 'logging'!show: string	stream notNil ifTrue:		[stream nextPutAll: string.		stream == Transcript ifTrue: [stream endEntry]]! !!Logger methodsFor: 'logging'!space	stream notNil ifTrue: [stream space]! !!Logger methodsFor: 'logging'!tab	stream notNil ifTrue: [stream tab]! !!Logger class methodsFor: 'class initialization' stamp: 'ikp 8/8/97 14:04'!initialize	"Logger initialize"	(Smalltalk at: #InterpreterLog put: self new) logToTranscript! !!LookupKey methodsFor: 'comparing' stamp: 'di 9/27/97 20:45'!identityHashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^ key identityHashMappedBy: map! !!LoPop methodsFor: 'initialize' stamp: 'jm 10/9/97 04:48'!initialize	super initialize.	sound _ SampledSound		samples: #(-37 -24 -30 -30 -25 -23 -11 -8 -38 -40 -34 -21 -18 -27 -34 -20 2 11 8 10 5 7 10 14 34 28 34 54 59 47 54 25 27 43 33 48 23 40 59 63 47 46 27 47 43 41 46 50 64 57 46 57 44 48 12 17 24 28 18 23 27 -7 -17 2 4 1 -4 18 12 11 34 25 43 18 11 20 43 43 11 12 31 -5 -11 -43 -41 -17 -23 -28 -38 -33 -48 -64 -61 -53 -61 -54 -56 -73 -73 -48 -48 -63 -92 -102 -90 -92 -115 -93 -90 -109 -120 -112 -119 -141 -136 -128 -146 -143 -141 -129 -118 -139 -132 -120 -103 -100 -96 -79 -71 -83 -79 -77 -87 -73 -73 -43 -24 -5 -10 20 23 -5 -4 0 28 20 -11 20 4 -11 -23 20 27 7 8 -2 -7 -15 -27 4 0 -8 -34 -31 -38 -34 -50 -40 -64 -46 -59 -51 -82 -80 -82 -80 -89 -95 -122 -89 -97 -67 -64 -31 -21 -34 -56 -25 -35 -48 -63 -37 -54 -34 8 40 82 161 306 503 921 1638 2549 3458 4074 4290 3947 2988 1528 -293 -2417 -4592 -6693 -8734 -10727 -12641 -14255 -15466 -16249 -16383 -15965 -15159 -14019 -12574 -10934 -9124 -7214 -5191 -3092 -856 1418 3639 5667 7543 9156 10532 11608 12361 12795 12922 12755 12307 11574 10473 8964 7129 5084 2911 596 -1773 -4103 -6374 -8593 -10593 -12355 -13748 -14599 -14866 -14527 -13593 -12109 -10146 -7697 -4933 -2022 881 3689 6302 8638 10580 12067 13052 13602 13774 13543 13046 12276 11271 9965 8426 6677 4771 2731 607 -1469 -3420 -5217 -6790 -8196 -9401 -10377 -11001 -11242 -11095 -10600 -9729 -8581 -7114 -5423 -3563 -1566 488 2577 4556 6448 8234 9786 11143 12136 12756 13034 12936 12489 11744 10678 9320 7673 5775 3813 1813 -182 -2113 -3924 -5606 -7123 -8439 -9477 -10213 -10688 -10855 -10663 -10109 -9278 -8125 -6682 -5004 -3147 -1171 791 2762 4655 6386 7944 9222 10201 10800 11120 11163 10885 10313 9434 8363 7050 5604 4048 2395 711 -872 -2376 -3707 -4894 -5875 -6667 -7214 -7489 -7480 -7251 -6739 -6039 -5102 -3987 -2754 -1475 -207 1094 2392 3590 4686 5639 6469 7178 7758 8142 8273 8187 7883 7398 6803 6056 5188 4152 3075 1968 866 -184 -1197 -2143 -2964 -3615 -4163 -4572 -4907 -5100 -5141 -5018 -4723 -4288 -3725 -3031 -2198 -1246 -276 704 1661 2529 3377 4140 4835 5333 5721 5941 6098 6048 5846 5498 5047 4467 3816 3131 2444 1659 856 57 -636 -1301 -1946 -2549 -3099 -3548 -3871 -4057 -4143 -4153 -3999 -3753 -3380 -2893 -2338 -1742 -1098 -391 380 1111 1822 2543 3206 3784 4283 4638 4868 4955 4894 4713 4385 3938 3365 2679 1910 1089 272 -564 -1379 -2145 -2902 -3583 -4127 -4562 -4866 -5010 -4949 -4785 -4468 -4026 -3463 -2817 -2070 -1256 -398 462 1297 2147 2922 3613 4211 4732 5178 5449 5617 5608 5456 5168 4727 4120 3404 2561 1646 706 -218 -1212 -2160 -3018 -3688 -4293 -4726 -5015 -5195 -5231 -5096 -4788 -4321 -3754 -3057 -2240 -1363 -433 515 1446 2340 3118 3820 4401 4851 5133 5256 5195 5011 4696 4209 3627 2934 2168 1334 434 -475 -1357 -2211 -2981 -3669 -4285 -4771 -5116 -5322 -5382 -5315 -5067 -4701 -4169 -3518 -2775 -1937 -1036 -165 735 1626 2440 3115 3681 4154 4467 4625 4681 4589 4344 4008 3583 3008 2353 1615 777 -57 -872 -1713 -2486 -3206 -3843 -4391 -4840 -5116 -5273 -5277 -5128 -4831 -4418 -3868 -3252 -2533 -1744 -898 -67 780 1570 2300 2913 3463 3874 4159 4331 4353 4248 4028 3668 3184 2633 1949 1216 426 -341 -1109 -1852 -2512 -3102 -3597 -3983 -4224 -4349 -4339 -4183 -3910 -3520 -3065 -2510 -1885 -1242 -588 54 685 1249 1839 2352 2777 3106 3327 3466 3488 3417 3234 2948 2617 2185 1671 1117 564 -15 -608 -1174 -1700 -2196 -2650 -3039 -3296 -3481 -3587 -3568 -3460 -3273 -2983 -2614 -2156 -1658 -1154 -626 -89 421 921 1413 1865 2266 2602 2818 3004 3090 3036 2944 2824 2565 2214 1837 1422 954 469 -15 -490 -960 -1413 -1806 -2139 -2421 -2703 -2877 -2949 -2974 -2964 -2820 -2608 -2340 -1972 -1592 -1154 -680 -190 267 745 1183 1592 1947 2225 2473 2624 2696 2723 2692 2565 2408 2219 1916 1579 1200 797 368 -115 -549 -994 -1408 -1767 -2037 -2241 -2394 -2469 -2497 -2427 -2317 -2150 -1887 -1551 -1197 -778 -346 103 544 942 1390 1766 2077 2353 2535 2657 2697 2700 2615 2473 2257 1980 1677 1287 871 466 21 -377 -757 -1134 -1464 -1713 -1932 -2096 -2208 -2243 -2235 -2168 -2051 -1854 -1566 -1229 -888 -499 -100 319 719 1124 1481 1801 2084 2306 2434 2469 2476 2431 2287 2101 1825 1527 1194 836 483 123 -231 -593 -931 -1251 -1541 -1796 -1978 -2122 -2188 -2162 -2106 -1903 -1717 -1467 -1140 -814 -463 -115 254 617 950 1284 1550 1753 1880 1992 1988 1930 1829 1695 1475 1226 924 603 293 -27 -345 -640 -954 -1217 -1471 -1687 -1832 -1917 -1985 -1960 -1900 -1750 -1546 -1356 -1092 -771 -469 -135 200 555 895 1176 1429 1628 1786 1920 1968 1966 1924 1842 1704 1464 1200 922 600 285 -21 -348 -614 -840 -1073 -1266 -1397 -1501 -1595 -1635 -1638 -1585 -1464 -1311 -1151 -971 -735 -501 -267 -43 210 398 643 865 1050 1206 1333 1419 1418 1410 1383 1281 1147 996 803 621 437 226 23 -148 -309 -466 -611 -748 -849 -912 -964 -1016 -1039 -1032 -990 -868 -757 -621 -440 -256 -118 43 194 354 470 564 653 718 780 809 793 748 672 587 453 321 151 8 -142 -308 -499 -647 -819 -950 -1073 -1169 -1243 -1276 -1282 -1262 -1219 -1140 -1016 -921 -809 -624 -475 -335 -142 25 182 339 483 613 702 796 856 899 898 902 858 826 735 656 529 395 263 146 -14 -167 -346 -480 -633 -715 -806 -878 -955 -958 -978 -930 -891 -794 -705 -616 -477 -336 -243 -112 4 109 205 276 332 430 480 519 508 521 513 518 463 384 319 227 112 -8 -100 -202 -348 -505 -596 -725 -833 -906 -951 -940 -927 -883 -806 -692 -542 -365 -207 -60 80 249 400 483 584 626 650 657 634 585 493 443 351 238 158 63 -30 -123 -185 -279 -359 -400 -470 -529 -570 -561 -594 -601 -588 -570 -524 -477 -414 -328 -236 -141 -37 48 99 204 287 391 441 472 495 516 476 418 371 292 204 99 -10 -43 -118 -207 -253 -303 -341 -349 -359 -342 -338 -305 -264 -227 -164 -119 -46 38 99 138 174 227 234 215 231 262 234 227 237 273 218 198 192 192 135 119 90 44 -27 -40 -73 -99 -132 -149 -154 -128 -92 -46 -23 38 59 59 51 57 50 28 17 37 -10 2 -4 -40 -71 -96 -126 -142 -194 -227 -274 -300 -345 -362 -369 -357 -345 -335 -303 -256 -223 -191 -141 -116 -71 -80 -96 -74 -86 -120 -141 -181 -249 -315 -372 -388 -397 -430 -449 -460 -462 -417 -391 -357 -299 -253 -175 -119 -34 43 128 198 241 282 357 410 436 444 472 473 441 413 358 260 191 96 -12 -74 -164 -270 -346 -437 -513 -594 -652 -704 -728 -750 -735 -668 -626 -544 -456 -341 -244 -138 -34 89 195 293 381 459 476 549 597 600 620 601 572 532 475 417 351 233 135 63 -44 -142 -230 -295 -385 -405 -450 -472 -492 -463 -482 -477 -460 -440 -393 -339 -326 -257 -190 -126 -35 63 146 201 283 355 393 401 427 441 411 382 335 282 241 200 133 90 30 -8 -64 -116 -142 -175 -213 -223 -244 -274 -280 -272 -280 -264 -241 -262 -249 -228 -211 -156 -128 -64 -21 43 80 129 142 187 215 227 230 237 243 254 266 267 273 256 254 251 253 236 208 164 128 69 54 30 -18 -69 -86 -106 -143 -167 -188 -218 -246 -247 -233 -220 -169 -138 -95 -44 -23 18 69 116 188 236 298 380 440 503 516 538 544 516 485 475 427 374 310 292 220 109 57 5 -100 -184 -276 -362 -436 -480 -512 -539 -531 -524 -511 -452 -371 -302 -260 -169 -95 -46 59 156 208 262 336 397 421 436 441 427 427 414 368 332 298 237 197 145 93 46 0 -48 -89 -112 -138 -132 -118 -73 -23 0)		samplingRate: 22050.! !I represent a Macintosh FileDirectory.!!MacFileDirectory class methodsFor: 'platform specific' stamp: 'jm 12/4/97 22:57'!pathNameDelimiter	^ $:! !!MenuItemMorph methodsFor: 'initialization' stamp: 'jm 11/4/97 07:46'!initialize	super initialize.	bounds _ 0@0 extent: 10@10.	color _ Color black.	font _ nil.	contents _ ''.	hasFocus _ false.	isEnabled _ true.	subMenu _ nil.	isSelected _ false.	target _ nil.	selector _ nil.	arguments _ nil.! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!arguments	^ arguments! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!arguments: aCollection	arguments _ aCollection.! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!isEnabled	^ isEnabled! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!isEnabled: aBoolean	isEnabled = aBoolean ifTrue: [^ self].	isEnabled _ aBoolean.	self color: (aBoolean ifTrue: [Color black] ifFalse: [Color gray]).! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!selector	^ selector! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!selector: aSymbol	selector _ aSymbol.! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!subMenu	^ subMenu! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!subMenu: aMenuMorph	subMenu _ aMenuMorph.	self changed.! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!target	^ target! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!target: anObject	target _ anObject.! !!MenuItemMorph methodsFor: 'drawing' stamp: 'jm 11/4/97 07:46'!drawOn: aCanvas	(isSelected & isEnabled) ifTrue: [		aCanvas fillRectangle: self bounds color: owner color darker].	super drawOn: aCanvas.	subMenu == nil ifFalse: [		aCanvas			image: SubMenuMarker			at: (self right - 8 @ ((self top + self bottom - SubMenuMarker height) // 2))].! !!MenuItemMorph methodsFor: 'events' stamp: 'jm 11/4/97 07:15'!handlesMouseDown: evt	^ true! !!MenuItemMorph methodsFor: 'events' stamp: 'jm 11/4/97 07:46'!mouseDown: evt	"Handle a mouse down event. Menu items get activated when the mouse is over them."	self isInMenu ifFalse: [^ super mouseDown: evt].	evt shiftPressed ifTrue: [^ super mouseDown: evt].  "enable label editing" 	self selectFromHand: evt hand.! !!MenuItemMorph methodsFor: 'events' stamp: 'jm 11/4/97 07:46'!mouseMove: evt	| m |	m _ evt hand recipientForMouseDown: evt.	m == self		ifTrue: [isSelected ifFalse: [self isSelected: true]]		ifFalse: [			self deselectForNewMorph: m.			((m isKindOf: MenuItemMorph) and: [m isInMenu]) ifTrue: [				m selectFromHand: evt hand]]."xxx	m == self ifFalse: [		((m isKindOf: MenuItemMorph) and: [m isInMenu]) ifTrue: [			m owner == subMenu				ifFalse: [self isSelected: false hand: evt hand].			m isSelected: true hand: evt hand.			evt hand newMouseFocus: m]].xxx""xxx	m == self ifTrue: [^ self].	((m isKindOf: MenuItemMorph) and: [m isInMenu]) ifTrue: [		m isSelected: true hand: evt hand.		menu _ m owner.		(menu == self owner or: [		 menu == subMenu or: [		 menu hasSubMenu: owner]]) ifTrue: [			menu == subMenu ifFalse: [self hideSubmenu].			(menu == self owner or: [m subMenu == owner or: [menu == subMenu]])				ifFalse: [owner delete].			evt hand newMouseFocus: m]].xxx"! !!MenuItemMorph methodsFor: 'events' stamp: 'jm 11/4/97 07:46'!mouseUp: evt	"Handle a mouse up event. Menu items get activated when the mouse is over them."	| mouseInMe w |	self deselectItem.	mouseInMe _ self bounds containsPoint: evt cursorPoint.	self isInMenu ifTrue: [		(mouseInMe and: [self selector = #toggleStayUp:]) ifFalse: [			w _ owner world.			owner deleteIfPopUp].		subMenu ifNil: [			mouseInMe ifTrue: [				w ifNotNil: [w displayWorld].				owner invokeItem: self]]].! !!MenuItemMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!hResizing	^ #spaceFill! !!MenuItemMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!isLayoutMorph	^ true! !!MenuItemMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!layoutInWidth: w height: h	| scanner |	scanner _ QuickPrint newOn: Display box: Display boundingBox font: font.	self extent: ((scanner stringWidth: contents) @ (scanner lineHeight) max: w@h).! !!MenuItemMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!minHeight	^ self extent y! !!MenuItemMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!minWidth	| scanner |	scanner _ QuickPrint newOn: Display box: Display boundingBox font: font.	^ (scanner stringWidth: contents) + (subMenu == nil ifTrue: [0] ifFalse: [10])! !!MenuItemMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!vResizing	^ #shrinkWrap! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:46'!deletePopupBackToCommonMenuWith: menuOrMenuItem	| m menuToKeepUp owningItem |	(menuOrMenuItem isKindOf: MenuMorph)		ifTrue: [m _ menuOrMenuItem]		ifFalse: [			(menuOrMenuItem isKindOf: MenuItemMorph)				ifTrue: [m _ menuOrMenuItem owner]				ifFalse: [^ self]].	menuToKeepUp _ IdentitySet new.	[m isKindOf: MenuMorph] whileTrue: [		menuToKeepUp add: m.		owningItem _ m popUpOwner.		(owningItem isKindOf: MenuItemMorph)			ifTrue: [m _ owningItem owner]			ifFalse: [m _ nil]].	m _ self owner.	[m isKindOf: MenuMorph] whileTrue: [		(menuToKeepUp includes: m) ifTrue: [^ self].		m stayUp ifFalse: [m delete].		(m popUpOwner isKindOf: MenuItemMorph) ifTrue: [m popUpOwner isSelected: false].		owningItem _ m popUpOwner.		(owningItem isKindOf: MenuItemMorph)			ifTrue: [m _ owningItem owner]			ifFalse: [m _ nil]].! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:46'!deselectForNewMorph: aMorph	aMorph == owner ifTrue: [^ self].   "in my menu but not over any item"	(aMorph == subMenu or: [aMorph owner == subMenu])		ifTrue: [^ self].  "selecting my submenu or an item in it, leave me selected"	isSelected _ false.	self changed.	subMenu ifNotNil: [subMenu stayUp ifFalse: [subMenu delete]].	self deletePopupBackToCommonMenuWith: aMorph.	aMorph owner ~= self owner ifFalse: [		self deletePopupBackToCommonMenuWith: aMorph].! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:46'!deselectItem	| item |	isSelected _ false.	self changed.	subMenu ifNotNil: [subMenu deleteIfPopUp].	(owner isKindOf: MenuMorph) ifTrue: [		item _ owner popUpOwner.		(item isKindOf: MenuItemMorph) ifTrue: [item deselectItem]].! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:46'!hideSubmenu	subMenu ifNotNil: [subMenu deleteIfPopUp].	(owner isKindOf: MenuMorph) ifTrue: [owner deleteIfPopUp].! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:46'!isInMenu	^ owner isKindOf: MenuMorph! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:46'!isSelected: aBoolean	isSelected _ aBoolean.	self changed.! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:46'!selectFromHand: aHand	isSelected _ true.	self changed.	aHand newMouseFocus: self.	subMenu ifNotNil: [		subMenu delete.		subMenu popUpAt: self bounds topRight forHand2: aHand.		subMenu popUpOwner: self].! !!MenuItemMorph class methodsFor: 'class initialization' stamp: 'jm 11/16/97 09:17'!initialize	"MenuItemMorph initialize"	| f |	f _ Form		extent: 5@9		fromArray: #(2147483648 3221225472 3758096384 4026531840 4160749568 4026531840 3758096384 3221225472 2147483648)		offset: 0@0.	SubMenuMarker _ ColorForm mappingWhiteToTransparentFrom: f.! !!MenuLineMorph methodsFor: 'drawing' stamp: 'jm 11/4/97 07:46'!drawOn: aCanvas	aCanvas		fillRectangle: (bounds topLeft corner: bounds rightCenter)		color: owner color darker.	aCanvas		fillRectangle: (bounds leftCenter corner: bounds bottomRight)		color: owner color lighter.! !!MenuLineMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!hResizing	^ #spaceFill! !!MenuLineMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!isLayoutMorph	^ true! !!MenuLineMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!layoutInWidth: w height: h	self extent: w@h.! !!MenuLineMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!minHeight	^ 2! !!MenuLineMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!minWidth	^ 10! !!MenuLineMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!vResizing	^ #shrinkWrap! !!MenuMorph methodsFor: 'initialization' stamp: 'sw 11/17/97 13:17'!droppableOnPlayfield	^ false! !!MenuMorph methodsFor: 'initialization' stamp: 'jm 11/4/97 07:46'!initialize	super initialize.	self setColor: (Color r: 0.8 g: 0.8 b: 0.8) borderWidth: 2 borderColor: #raised.	inset _ 3.	orientation _ #vertical.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	defaultTarget _ nil.	lastSelection _ nil.	stayUp _ false.	originalEvent _ nil.	popUpOwner _ nil.! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!hasSubMenu: aMenuMorph	| sub |	self items do: [:each |		sub _ each subMenu.		sub ifNotNil: [			sub == aMenuMorph ifTrue: [^ true].			(sub hasSubMenu: aMenuMorph) ifTrue: [^ true]]].	^ false! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!items	^ submorphs select: [:m | m isKindOf: MenuItemMorph]! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!lastSelection	"Return the label of the last selected item or nil."	lastSelection == nil		ifTrue: [^ lastSelection selector]		ifFalse: [^ nil].! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!lastSelection: aString	"Set the last selection so that it is selected by default when this menu first pops up."	lastSelection _ self items		detect: [:each | each selector == aString] ifNone: [nil].! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!popUpOwner	^ popUpOwner! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!popUpOwner: aMenuItemMorph	popUpOwner _ aMenuItemMorph.! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!stayUp	^ stayUp! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!stayUp: aBoolean	stayUp _ aBoolean.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!add: aString action: aSymbol	"Append a menu item with the given label. If the item is selected, it will send the given selector to the default target object."	"Details: Note that the menu item added captures the default target object at the time the item is added; the default target can later be changed before added additional items without affecting the targets of previously added entries. The model is that each entry is like a button that knows everything it needs to perform its action."	self add: aString		target: defaultTarget		selector: aSymbol		argumentList: EmptyArray.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!add: aString subMenu: aMenuMorph	"Append the given submenu with the given label."	| item |	item _ MenuItemMorph new.	item contents: aString;		subMenu: aMenuMorph.	self addMorphBack: item.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!add: aString target: anObject selector: aSymbol	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object."	self add: aString		target: anObject		selector: aSymbol		argumentList: EmptyArray.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!add: aString target: target selector: aSymbol argument: arg	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given argument."	self add: aString		target: target		selector: aSymbol		argumentList: (Array with: arg)! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!add: aString target: target selector: aSymbol argumentList: argList	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument."	| item |	item _ MenuItemMorph new		contents: aString;		target: target;		selector: aSymbol;		arguments: argList asArray.	self addMorphBack: item.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!addLine	"Append a divider line to this menu. Suppress duplicate lines."	(self lastSubmorph isKindOf: MenuLineMorph)		ifFalse: [self addMorphBack: MenuLineMorph new].! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 10:13'!addList: listOfPairs	"Add the given items to this menu, where each item is a pair (<string> <actionSelector>)."	listOfPairs do:		[:aPair | self add: aPair first action: aPair last].! !!MenuMorph methodsFor: 'construction'!addStayUpItem	"Append a menu item that can be used to toggle this menu's persistent."	self add: 'stay up'		target: self		selector: #toggleStayUp:		argumentList: EmptyArray.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!addTitle: aString	"Add a title line at the top of this menu."	| title |	title _ LayoutMorph new setColor: (Color r: 0.5 g: 1 b: 0.75) borderWidth: 1 borderColor: #inset.	title vResizing: #shrinkWrap.	title orientation: #vertical.	title centering: #center.	title addMorph: (StringMorph new contents: aString).	self addMorphFront: title.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!defaultTarget: anObject	"Set the default target for adding menu items."	defaultTarget _ anObject.! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'add title...' action: #addTitle.	aCustomMenu add: 'set target...' action: #setTarget:.	defaultTarget ifNotNil: [		aCustomMenu add: 'add item...' action: #addItem].	aCustomMenu add: 'remove item' action: #removeItem:.	aCustomMenu add: 'add line' action: #addLine.	(self canDetachSubMenu: aHandMorph)		ifTrue: [aCustomMenu add: 'detach submenu' action: #detachSubMenu:].! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!addItem	| string sel |	string _ FillInTheBlank request: 'Label for new item?'.	string isEmpty ifTrue: [^ self].	sel _ FillInTheBlank request: 'Selector?'.	sel isEmpty ifFalse: [sel _ sel asSymbol].	self add: string action: sel.! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!addTitle	| string |	string _ FillInTheBlank request: 'Title for this menu?'.	string isEmpty ifTrue: [^ self].	self addTitle: string.! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!canDetachSubMenu: hand	| possibleTargets item |	possibleTargets _ hand argumentOrNil morphsAt: hand targetOffset.	item _ possibleTargets		detect: [:each | each isKindOf: MenuItemMorph]		ifNone: [^ false].	^ item subMenu notNil! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!detachSubMenu: evt	| possibleTargets item subMenu |	possibleTargets _ evt hand argumentOrNil morphsAt: evt hand targetOffset.	item _ possibleTargets detect: [:each | each isKindOf: MenuItemMorph] ifNone: [^ self].	subMenu _ item subMenu.	subMenu ifNotNil: [		item subMenu: nil.		item delete.		subMenu stayUp: true.		subMenu popUpOwner: nil.		subMenu addTitle: item contents.		evt hand attachMorph: subMenu].! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!removeItem: evt	| possibleTargets item |	possibleTargets _ evt hand argumentOrNil morphsAt: evt hand targetOffset.	item _ possibleTargets		detect: [:each |					(each isKindOf: MenuItemMorph) or:					 [each isKindOf: MenuLineMorph]]		ifNone: [^ self].	item delete.! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!setTarget: evt	"Set the default target object to be used for add item commands, and re-target all existing items to the new target or the the invoking hand."	| rootMorphs old |	rootMorphs _ self world rootMorphsAt: evt hand targetOffset.	rootMorphs size > 1		ifTrue: [defaultTarget _ rootMorphs at: 2]		ifFalse: [^ self].	"re-target all existing items"	self items do: [:item |		old _ item target.		old isHandMorph			ifTrue: [item target: evt hand. evt hand setArgument: defaultTarget]			ifFalse: [item target: defaultTarget]].! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!toggleStayUp: evt	"Toggle my 'stayUp' flag and adjust the menu item to reflect its new state."	stayUp _ stayUp not.	self items do: [:item |		item selector = #toggleStayUp: ifTrue: [			stayUp				ifTrue: [item contents: 'dismiss this menu']				ifFalse: [item contents: 'stay up']]].	stayUp ifFalse: [self delete].! !!MenuMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:15'!minHeightWhenEmpty	^ 10! !!MenuMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:15'!minWidthWhenEmpty	^ 20! !!MenuMorph methodsFor: 'control' stamp: 'jm 11/4/97 07:46'!deleteIfPopUp	"Remove this menu from the screen if stayUp is not true. If it is a submenu, also remove its owning menu."	stayUp ifFalse: [self delete].	(popUpOwner notNil and: [popUpOwner isKindOf: MenuItemMorph]) ifTrue: [		popUpOwner isSelected: false.		(popUpOwner owner isKindOf: MenuMorph)			ifTrue: [popUpOwner owner deleteIfPopUp]].! !!MenuMorph methodsFor: 'control' stamp: 'jm 11/4/97 07:46'!invokeItem: aMenuItem	"Perform the action associated with the given menu item."	| sel target args selArgCount |	aMenuItem isEnabled ifFalse: [^ self].	lastSelection _ aMenuItem.	"to do: report lastSelection"	sel _ aMenuItem selector.	target _ aMenuItem target.	args _ aMenuItem arguments.	selArgCount _ sel numArgs.	Cursor normal showWhile: [  "show cursor in case item opens a new MVC window"		selArgCount = 0			ifTrue: [target perform: sel]			ifFalse: [				selArgCount = args size					ifTrue: [target perform: sel withArguments: args]					ifFalse: [target perform: sel withArguments: (args copyWith: originalEvent)]]].! !!MenuMorph methodsFor: 'control' stamp: 'jm 11/4/97 07:46'!popUpAt: aPoint event: evt	"Present this menu at the given point in response to the given event."	originalEvent _ evt.	self popUpAt: aPoint forHand: evt hand.! !!MenuMorph methodsFor: 'control' stamp: 'jm 11/19/97 09:11'!popUpAt: aPoint forHand2: hand	"Present this menu at the given point under control of the given hand."	| selectedItem delta |	popUpOwner _ hand.	originalEvent _ MorphicEvent new setHand: hand.	selectedItem _ self items detect: [:each | each == lastSelection] ifNone: [self items first].	self position: aPoint - selectedItem position + self position.	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self.	self changed.! !!MenuMorph methodsFor: 'control' stamp: 'jm 11/4/97 07:46'!popUpAt: aPoint forHand: hand	"Present this menu at the given point under control of the given hand."	| selectedItem delta |	popUpOwner _ hand.	selectedItem _ self items detect: [:each | each == lastSelection] ifNone: [self items first].	self position: aPoint - selectedItem position + self position.	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self.	hand newMouseFocus: selectedItem.	self changed.! !!MenuMorph class methodsFor: 'example' stamp: 'jm 11/4/97 07:46'!example	"MenuMorph example"	| menu |	menu _ MenuMorph new.	menu addStayUpItem.	menu add: 'apples' action: #apples.	menu add: 'oranges' action: #oranges.	menu addLine.	menu addLine.  "extra lines ignored"	menu add: 'peaches' action: #peaches.	menu addLine.	menu add: 'pears' action: #pears.	menu addLine.	^ menu! !!MessageCategoryListController methodsFor: 'menu messages' stamp: 'di 6/28/97 19:16'!printOut	"Make a file with the description of the selected mesage category in Html format."	self controlTerminate.	Cursor write showWhile:		[model printOutMessageCategories].	self controlInitialize! !!MessageCategoryListView methodsFor: 'updating' stamp: 'di 1/14/98 14:04'!getList 	"Refer to the comment in BrowserListView|getList."	model classCommentIndicated ifTrue: [^ Array new].	singleItemMode		ifTrue: [^Array with: model selectedMessageCategoryName asSymbol]		ifFalse: [^model messageCategoryList]! !!MessageCategoryListView methodsFor: 'updating' stamp: 'jhm 10/15/97 17:16'!list: anArray	super list: anArray.	((Preferences valueOfFlag: #browserAutoSelect) and:	 [list numberOfLines = 3]) ifTrue: [		controller isNil ifFalse: [controller changeModelSelection: 1]].! !!MessageListController methodsFor: 'menu messages' stamp: 'sw 8/7/97 11:59'!classHierarchy	"Create and schedule a class list browser on the receiver's hierarchy."	| aSel aClass |	self controlTerminate.	aSel _ model selectedMessageName..	aClass _ model selectedClassOrMetaClass.	((aSel ~~ nil) & (aClass ~~ nil)) ifTrue:		[Utilities spawnHierarchyForClass: aClass selector: aSel].	self controlInitialize! !!MessageListController methodsFor: 'menu messages' stamp: 'sw 8/5/97 12:10'!implementors	"Create and schedule a message set browser on the implementations of the 	selected message."	self controlTerminate.	model browseImplementors.	self controlInitialize! !!MessageListController methodsFor: 'menu messages' stamp: 'sw 8/7/97 10:16'!methodHierarchy	"Create and schedule a message browser on the hierarchical implementors."	| aSel aClass |	self controlTerminate.	aSel _ model selectedMessageName..	aClass _ model selectedClassOrMetaClass.	((aSel ~~ nil) & (aClass ~~ nil)) ifTrue:		[Utilities methodHierarchyBrowserForClass: aClass selector: aSel].	self controlInitialize! !!MessageListController methodsFor: 'menu messages' stamp: 'di 6/28/97 15:45'!printOut	"Write a description of the selected message on an external file."	self controlTerminate.	Cursor write showWhile:		[model printOutMessage].	self controlInitialize! !!MessageListController methodsFor: 'menu messages' stamp: 'sw 8/11/97 14:36'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	self controlTerminate.	Smalltalk changes removeSelectorChanges: model selectedMessageName class: model selectedClassOrMetaClass.	Transcript cr; show: 'Method ', model selectedClass name, '.', model selectedMessage name, ' removed from current Change Set, at ', Time dateAndTimeNow printString.	self controlInitialize! !!MessageListController methodsFor: 'menu messages' stamp: 'sw 8/6/97 22:32'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self controlTerminate.	self revertToPreviousVersion.	Smalltalk changes removeSelectorChanges: model selectedMessageName class: model selectedClassOrMetaClass.	Transcript cr; show: 'Method ', model selectedClass name, '.', model selectedMessage name, ' reverted to previous version and removed from current Change Set, at ', Time dateAndTimeNow printString.	self controlInitialize! !!MessageListController methodsFor: 'menu messages' stamp: 'sw 8/6/97 22:36'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords codeController |	self controlTerminate.	aClass _ model selectedClassOrMetaClass.	aClass ifNil: [^ view flash].	aSelector _ model selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	changeRecords size <= 1 ifTrue: [view flash.  ^ self beep].	codeController _ (view superView subViews detect: [:v | v isKindOf: StringHolderView]) controller.	model contents: (changeRecords at: 2) string notifying: codeController.	codeController view updateDisplayContents.	self controlInitialize! !!MessageListController methodsFor: 'menu messages' stamp: 'sw 8/7/97 12:04'!shiftedYellowButtonMenu	"Answer the menu to be put up when shift key is down.  "	^ PopUpMenu labels: 'browse method inheritancebrowse class hierarchybrowse classbrowse methodimplementors of sent messagesinspect instancesinspect subinstancesremove from this browserrevert to previous versionremove from current change setrevert and forgetmore...' lines: #(5 7 11)! !!MessageListController methodsFor: 'menu messages' stamp: 'sw 8/7/97 12:03'!shiftedYellowButtonMessages	"Answer the messages corresponding to the shifted-yellow-button menu, to be put up when shift key is down."	^ #(methodHierarchy classHierarchy browseClass browse allImplementorsOf inspectInstances inspectSubInstances removeMessageFromBrowser revertToPreviousVersion removeFromCurrentChanges revertAndForget unshiftedYellowButtonActivity)! !!MessageListController class methodsFor: 'class initialization' stamp: 'sw 8/7/97 10:01'!initialize	"Initialize the yellow button menu for message lists.  2/1/96 sw	 7/30/96 sw: added browseInstVarDefs"	MessageListYellowButtonMenu _ 		PopUpMenu 			labels:'browse fullfileOutprintOutsendersimplementorssenders of...implementors of...versionsinst var refs...inst var defs...class var refs...class variablesclass refsremovemore...'			lines: #(3 8 13).	MessageListYellowButtonMessages _		#(browseFull fileOut printOut		senders implementors  browseSendersOfMessages messages versions		browseInstVarRefs browseInstVarDefs classVarRefs browseClassVariables browseClassRefs		remove shiftedYellowButtonActivity )"	MessageListController initialize.	MessageListController allInstancesDo:		[:x | x initializeYellowButtonMenu]."! !!MessageListView methodsFor: 'updating' stamp: 'sw 1/15/98 17:33'!displayView 	"Refer to the comment in View|displayView."	| aClass sel index baseClass |	Browser postOpenSuggestion == nil ifFalse:		["Set the class and message"		aClass _ Browser postOpenSuggestion first.		sel _ Browser postOpenSuggestion last.		Browser postOpenSuggestion: nil.		baseClass _ aClass theNonMetaClass.		model systemCategoryListIndex:			(SystemOrganization numberOfCategoryOfElement: baseClass name).		model selectClass: baseClass.		model metaClassIndicated: aClass isMeta.		(sel notNil and: [aClass includesSelector: sel]) ifTrue:			[model messageCategoryListIndex:				(index _ aClass organization numberOfCategoryOfElement: sel).			model messageListIndex: 				((aClass organization listAtCategoryNumber: index) indexOf: sel)].		self topView deEmphasize.		^ self   "a redisplay has already been done"].	super displayView! !!MessageListView methodsFor: 'updating' stamp: 'sw 3/8/97'!update: aSymbol	"What to do to the message list when Browser changes. If there is only one item, select and show it.	 : as part of adding a new feature that was subsequently removed, simplified the code here enough to justify using it"	aSymbol == #messageSelectionChanged		ifTrue: [^ self updateMessageSelection].	(#(systemCategorySelectionChanged editSystemCategories editClass editMessageCategories) includes: aSymbol)		ifTrue: [^ self resetAndDisplayView].	(aSymbol == #messageCategorySelectionChanged) | (aSymbol == #messageListChanged) 		ifTrue: [^ self updateMessageList.].	(aSymbol == #classSelectionChanged) ifTrue:		[model messageCategoryListIndex = 1			ifTrue: ["self updateMessageList."]			ifFalse: [^ self resetAndDisplayView]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'di 7/13/97 10:48'!toDoFromWhileWithInit: initStmt	"Return nil, or a to:do: expression equivalent to this whileTrue:"	| variable increment limit toDoBlock body test |	(selector key == #whileTrue:		and: [(initStmt isMemberOf: AssignmentNode) and:				[initStmt variable isTemp]])		ifFalse: [^ nil].	body _ arguments last statements.	variable _ initStmt variable.	increment _ body last toDoIncrement: variable.	(increment == nil or: [receiver statements size ~= 1])		ifTrue: [^ nil].	test _ receiver statements first.	"Note: test chould really be checked that <= or >= comparison	jibes with the sign of the (constant) increment"	((test isMemberOf: MessageNode)		and: [(limit _ test toDoLimit: variable) notNil])		ifFalse: [^ nil].	toDoBlock _ BlockNode new			statements: body allButLast			returns: false.	toDoBlock arguments: (Array with: variable).	^ MessageNode new		receiver: initStmt value		selector: (SelectorNode new key: #to:by:do: code: #macro)		arguments: (Array with: limit with: increment with: toDoBlock)		precedence: precedence! !!MessageNode methodsFor: 'macro transformations'!toDoWithLimit: limitStmt	"The receiver is a to:do: statement, preceded by a statement	that might be of the form {iLimiT _ expr}.  If so, replace the	limit argument by the given expr and return a new to:do: node.	Otherwise, return nil"	((limitStmt isMemberOf: AssignmentNode)		and: [limitStmt variable = arguments first])		ifFalse: [^ nil].	limitStmt variable key = (arguments last firstArgument key , 'LimiT')		ifFalse: [^ nil].  "Must be a generated temp"	arguments at: 1 put: (limitStmt value)! !!MessageNode methodsFor: 'macro transformations'!transformToDo: encoder	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)			and: [arguments last numberOfArguments = 1])		ifFalse: [^ false].	arguments last firstArgument isVariableReference		ifFalse: [^ false]. "As with debugger remote vars"	arguments size = 3		ifTrue: [increment _ arguments at: 2.				increment isConstantNumber ifFalse: [^ false]]		ifFalse: [increment _ encoder encodeLiteral: 1].	arguments size < 3 ifTrue:   "transform to full form"		[selector _ SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	block _ arguments last.	blockVar _ block firstArgument.	initStmt _ AssignmentNode new variable: blockVar value: receiver.	limit _ arguments at: 1.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit _ nil]		ifFalse:  "Need to store limit in a var"			[limit _ encoder autoBind: blockVar key , 'LimiT'.			limit scope: -2.  "Already done parsing block"			limitInit _ AssignmentNode new					variable: limit					value: (arguments at: 1)].	test _ MessageNode new receiver: blockVar			selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])			arguments: (Array with: limit)			precedence: precedence from: encoder.	incStmt _ AssignmentNode new			variable: blockVar			value: (MessageNode new				receiver: blockVar selector: #+				arguments: (Array with: increment)				precedence: precedence from: encoder).	arguments _ (Array with: limit with: increment with: block)		, (Array with: initStmt with: test with: incStmt with: limitInit).	^ true! !!MessageNode methodsFor: 'code generation' stamp: 'tao 8/20/97 22:24'!emitCase: stack on: strm value: forValue	| braceNode sizeStream thenSize elseSize |	forValue not		ifTrue: [^super emitForEffect: stack on: strm].	braceNode _ arguments first.	sizeStream _ ReadStream on: sizes.	receiver emitForValue: stack on: strm.	braceNode casesForwardDo:		[:keyNode :valueNode :last |		thenSize _ sizeStream next.		elseSize _ sizeStream next.		last ifFalse: [strm nextPut: Dup. stack push: 1].		keyNode emitForEvaluatedValue: stack on: strm.		equalNode emit: stack args: 1 on: strm.		self emitBranchOn: false dist: thenSize pop: stack on: strm.		last ifFalse: [strm nextPut: Pop. stack pop: 1].		valueNode emitForEvaluatedValue: stack on: strm.		last ifTrue: [stack pop: 1].		valueNode returns ifFalse: [self emitJump: elseSize on: strm]].	arguments size = 2		ifTrue:			[arguments last emitForEvaluatedValue: stack on: strm] "otherwise: [...]"		ifFalse:			[NodeSelf emitForValue: stack on: strm.			caseErrorNode emit: stack args: 0 on: strm]! !!MessageNode methodsFor: 'code generation'!emitForValue: stack on: strm	special > 0		ifTrue: 			[self perform: (MacroEmitters at: special) with: stack with: strm with: true.			pc _ 0]		ifFalse: 			[receiver ~~ nil ifTrue: [receiver emitForValue: stack on: strm].			arguments do: [:argument | argument emitForValue: stack on: strm].			selector				emit: stack				args: arguments size				on: strm				super: receiver == NodeSuper.			pc _ strm position]! !!MessageNode methodsFor: 'code generation' stamp: 'tao 8/20/97 22:25'!sizeCase: encoder value: forValue	| braceNode sizeIndex thenSize elseSize |	forValue not		ifTrue: [^super sizeForEffect: encoder].	equalNode _ encoder encodeSelector: #=.	braceNode _ arguments first.	sizes _ Array new: 2 * braceNode numElements.	sizeIndex _ sizes size.	elseSize _ arguments size = 2		ifTrue:			[arguments last sizeForEvaluatedValue: encoder] "otherwise: [...]"		ifFalse:			[caseErrorNode _ encoder encodeSelector: #caseError.			 1 + (caseErrorNode size: encoder args: 0 super: false)]. "self caseError"	braceNode casesReverseDo:		[:keyNode :valueNode :last |		sizes at: sizeIndex put: elseSize.		thenSize _ valueNode sizeForEvaluatedValue: encoder.		last ifFalse: [thenSize _ thenSize + 1]. "Pop"		valueNode returns ifFalse: [thenSize _ thenSize + (self sizeJump: elseSize)].		sizes at: sizeIndex-1 put: thenSize.		last ifFalse: [elseSize _ elseSize + 1]. "Dup"		elseSize _ elseSize + (keyNode sizeForEvaluatedValue: encoder) +			(equalNode size: encoder args: 1 super: false) +			(self sizeBranchOn: false dist: thenSize) + thenSize.		sizeIndex _ sizeIndex - 2].	^(receiver sizeForValue: encoder) + elseSize! !!MessageNode methodsFor: 'code generation'!sizeForValue: encoder	| total argSize |	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: true].	receiver == NodeSuper		ifTrue: [selector _ selector copy "only necess for splOops"].	total _ selector size: encoder args: arguments size super: receiver == NodeSuper.	receiver == nil 		ifFalse: [total _ total + (receiver sizeForValue: encoder)].	sizes _ arguments collect: 					[:arg | 					argSize _ arg sizeForValue: encoder.					total _ total + argSize.					argSize].	^total! !!MessageNode methodsFor: 'printing' stamp: 'di 7/13/97 14:50'!printCaseOn: aStream indent: level	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"	| braceNode otherwise extra |	braceNode _ arguments first.	otherwise _ arguments last.	((arguments size = 1) or: [otherwise isJustCaseError])		ifTrue: [otherwise _ nil].	receiver printOn: aStream indent: level precedence: 3.	aStream nextPutAll: ' caseOf: '.	braceNode isVariableReference		ifTrue: [braceNode printOn: aStream indent: level]		ifFalse:	[aStream nextPutAll: '{'; crtab: level+1.	braceNode casesForwardDo:		[:keyNode :valueNode :last |		keyNode printOn: aStream indent: level+1.	 	aStream nextPutAll: ' -> '.		extra _ valueNode isComplex ifTrue: [aStream crtab: level+2. 1] ifFalse: [0].	 	valueNode printOn: aStream indent: level+1+extra.	 	last ifTrue: [aStream nextPut: $}] ifFalse: [aStream nextPut: $.; crtab: level+1]]].	otherwise isNil		ifFalse:			[aStream crtab: level+1; nextPutAll: 'otherwise: '.			 extra _ otherwise isComplex ifTrue: [aStream crtab: level+2. 1] ifFalse: [0].			 otherwise printOn: aStream indent: level+1+extra]! !!MessageNode methodsFor: 'printing' stamp: 'di 11/4/97 20:11'!printKeywords: key arguments: args on: aStream indent: level	| keywords prev arg indent thisKey |	args size = 0 		ifTrue: [aStream space; nextPutAll: key. ^ self].	keywords _ key keywords.	prev _ receiver.	1 to: keywords size do:		[:part | arg _ args at: part.		thisKey _ keywords at: part.		(prev isMemberOf: BlockNode)		 | ((prev isMemberOf: MessageNode) and: [prev precedence >= 3])		 | ((arg isMemberOf: BlockNode) and: [arg isComplex and: [thisKey ~= #do:]])		 | (args size > 2)		 | (key = #ifTrue:ifFalse:)			ifTrue: [aStream crtab: level+1. indent _ 1] "newline after big args"			ifFalse: [aStream space. indent _ 0].		aStream nextPutAll: thisKey; space.		arg  printOn: aStream indent: level + 1 + indent			 precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence]).		prev _ arg]! !!MessageNode methodsFor: 'printing'!printToDoOn: aStream indent: level	| limitNode |	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode _ arguments first]		ifFalse: [limitNode _ arguments last value].	(selector key = #to:by:do:			and: [(arguments at: 2) isConstantNumber				and: [(arguments at: 2) key = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!MessageNode methodsFor: 'C translation'!asTranslatorNode	"selector is sometimes a Symbol, sometimes a SelectorNode!!	On top of this, numArgs is needed due to the (truly grody) use of	arguments as a place to store the extra expressions needed to generate	code for in-line to:by:do:, etc.  see below, where it is used."	| sel args |	sel _ (selector isMemberOf: Symbol) ifTrue: [selector] ifFalse: [selector key].	args _ (1 to: sel numArgs) collect:			[:i | (arguments at: i) asTranslatorNode].	(sel = #to:by:do: and: [arguments size = 7 and: [(arguments at: 7) notNil]])		ifTrue: ["Restore limit expr that got moved by transformToDo:"				args at: 1 put: (arguments at: 7) value asTranslatorNode].	(sel = #or: and: [arguments size = 2 and: [(arguments at: 2) notNil]])		ifTrue: ["Restore argument block that got moved by transformOr:"				args at: 1 put: (arguments at: 2) asTranslatorNode].	(sel = #ifFalse: and: [arguments size = 2 and: [(arguments at: 2) notNil]])		ifTrue: ["Restore argument block that got moved by transformIfFalse:"				args at: 1 put: (arguments at: 2) asTranslatorNode].	^ TSendNode new		setSelector: sel		receiver: ((receiver == nil)					ifTrue: [nil]					ifFalse: [receiver asTranslatorNode])		arguments: args! !!MessageNode class methodsFor: 'class initialization' stamp: 'di 7/13/97 10:31'!initialize		"MessageNode initialize"	MacroSelectors _ 		#(ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:			and: or:			whileFalse: whileTrue: whileFalse whileTrue			to:do: to:by:do:			caseOf: caseOf:otherwise: as: ).	MacroTransformers _ 		#(transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:			transformAnd: transformOr:			transformWhile: transformWhile: transformWhile: transformWhile:			transformToDo: transformToDo:			transformCase: transformCase: transformAs: ).	MacroEmitters _ 		#(emitIf:on:value: emitIf:on:value: emitIf:on:value: emitIf:on:value:			emitIf:on:value: emitIf:on:value:			emitWhile:on:value: emitWhile:on:value: emitWhile:on:value: emitWhile:on:value:			emitToDo:on:value: emitToDo:on:value:			emitCase:on:value: emitCase:on:value: emitAs:on:value: ).	MacroSizers _ 		#(sizeIf:value: sizeIf:value: sizeIf:value: sizeIf:value:			sizeIf:value: sizeIf:value:			sizeWhile:value: sizeWhile:value: sizeWhile:value: sizeWhile:value:			sizeToDo:value: sizeToDo:value:			sizeCase:value: sizeCase:value: sizeAs:value: ).	MacroPrinters _ 		#(printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:			printIfOn:indent: printIfOn:indent:			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:			printToDoOn:indent: printToDoOn:indent:			printCaseOn:indent: printCaseOn:indent: printAsOn:indent: )! !!MessageSet methodsFor: 'message list' stamp: 'sw 11/3/97 00:11'!selectedMessage	"Answer the source method for the currently selected message."	self setClassAndSelectorIn:			[:class :selector | ^ class sourceMethodAt: selector ifAbsent: [^ 'Missing']]! !!MessageSet methodsFor: 'message functions' stamp: 'jm 7/30/97 16:48'!removeMessage	"Remove the selected message from the system. 1/15/96 sw"	| messageName confirmation |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self selectedClassOrMetaClass confirmRemovalOf: messageName.	confirmation == 3 ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self initializeMessageList: (messageList copyWithout: self selection).	self messageListIndex: 0.	self changed: #messageListChanged.	confirmation == 2 ifTrue:		[Smalltalk browseAllCallsOn: messageName]! !!MessageSet methodsFor: 'contents' stamp: 'di 7/13/97 11:15'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Create an error if the category of the selected message is unknown. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector |	messageListIndex = 0 ifTrue: [^ false].	self setClassAndSelectorIn: [:class :oldSelector].	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^false].	selector == oldSelector ifFalse: [self messageListIndex: 0].	^ true! !!MessageSet class methodsFor: 'instance creation' stamp: 'di 10/17/97 20:47'!parse: messageString toClassAndSelector: csBlock	"Decode strings of the form <className> [class] <selectorName>."	| tuple cl |	tuple _ messageString findTokens: ' '.	cl _ Smalltalk at: tuple first asSymbol.	(tuple size = 2 or: [tuple size > 2 and: [(tuple at: 2) ~= 'class']])		ifTrue: [^ csBlock value: cl value: (tuple at: 2) asSymbol]		ifFalse: [^ csBlock value: cl class value: (tuple at: 3) asSymbol]! !!MessageTally methodsFor: 'initialize-release'!spyEvery: millisecs on: aBlock 	"Create a spy and spy on the given block at the specified rate."	| myDelay value startTime |	(aBlock isMemberOf: BlockContext)		ifFalse: [self error: 'spy needs a block here'].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	ObservedProcess _ Processor activeProcess.	myDelay _ Delay forMilliseconds: millisecs.	Timer _		[[true] whileTrue: 			[startTime _ Time millisecondClockValue.			myDelay wait.			self tally: ObservedProcess suspendedContext				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor userInterruptPriority.		"activate the probe and evaluate the block"	Timer resume.	value _ aBlock value.		"cancel the probe and return the value"	Timer terminate.	^value! !!MessageTally methodsFor: 'tallying'!bumpBy: count	tally _ tally + count! !!MessageTally methodsFor: 'tallying'!tally: context by: count	"Explicitly tally the specified context and its stack."	| root |	context method == method ifTrue: [^self bumpBy: count].	(root _ context home sender) == nil		ifTrue: [^ (self bumpBy: count) tallyPath: context by: count].	^ (self tally: root by: count) tallyPath: context by: count! !!MessageTally methodsFor: 'tallying'!tallyPath: context by: count	| aMethod path |	aMethod _ context method.	receivers do: 		[:aMessageTally | 		aMessageTally method == aMethod ifTrue: [path _ aMessageTally]].	path == nil ifTrue: 		[path _ MessageTally new class: context receiver class method: aMethod.		receivers _ receivers copyWith: path].	^ path bumpBy: count! !!MessageTally methodsFor: 'printing'!printOn: aStream total: total tallyExact: isExact	| aSelector className myTally |	isExact ifTrue:		[myTally _ tally.		receivers == nil			ifFalse: [receivers do: [:r | myTally _ myTally - r tally]].		aStream print: myTally; space]		ifFalse:		[aStream print: (tally asFloat / total * 100.0 roundTo: 0.1); space].	receivers == nil		ifTrue: [aStream nextPutAll: 'primitives'; cr]		ifFalse: 			[aSelector _ class selectorAtMethod: method setClass: [:aClass].			className _ aClass name contractTo: 30.			aStream nextPutAll: className; space;				nextPutAll: (aSelector contractTo: 60-className size); cr]! !!MessageTally class methodsFor: 'spying' stamp: 'di 12/26/97 10:45'!tallySendsTo: receiver inBlock: aBlock showTree: treeOption	"MessageTally tallySends: [3.14159 printString]"	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. If receiver is not nil, then only sends	to that receiver are tallied.	Results are presented as leaves, sorted by frequency,	preceded, optionally, by the whole tree."	| prev tallies startTime totalTime |	startTime _ Time millisecondClockValue.	tallies _ MessageTally new class: aBlock receiver class							method: aBlock method.	prev _ aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			current == prev ifFalse: 				["call or return"				prev sender == nil ifFalse: 					["call only"					(receiver == nil or: [current receiver == receiver])						ifTrue: [tallies tally: current by: 1]].				prev _ current]].	totalTime _ Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.	StringHolderView open: (StringHolder new contents:		(String streamContents:			[:s |			s nextPutAll: 'This simulation took ' , totalTime printString							, ' seconds.'; cr.			treeOption				ifTrue: [tallies fullPrintOn: s tallyExact: true orThreshold: 0]				ifFalse: [tallies leavesPrintOn: s tallyExact: true orThreshold: 0].			tallies close]))		label: 'Spy Results'! !!MessageTally class methodsFor: 'spying'!time: aBlock	^ Time millisecondsToRun: aBlock! !!Metaclass methodsFor: 'initialize-release'!instanceVariableNames: instVarString 	"Declare additional named variables for my instance."	| newMeta invalid |	newMeta _ self copyForValidation.	invalid _ newMeta				subclassOf: superclass				oldClass: self				instanceVariableNames: instVarString				variable: false				words: true				pointers: true				ifBad: [^false].	(invalid or: [instVarString ~= self instanceVariablesString])		ifTrue: [newMeta validateFrom: self					in: Smalltalk					instanceVariableNames: true					methods: true.				Smalltalk changes changeClass: self]! !!Metaclass methodsFor: 'compiling'!scopeHas: name ifTrue: assocBlock  	^thisClass scopeHas: name ifTrue: assocBlock! !!Metaclass methodsFor: 'fileIn/Out'!definition 	"Refer to the comment in ClassDescription|definition."	| aStream names |	aStream _ WriteStream on: (String new: 300).	self printOn: aStream.	names _ self instVarNames."	names isEmpty ifTrue: [^  aStream contents]."	aStream nextPutAll: '	instanceVariableNames: '''.	1 to: names size do: [:i | aStream nextPutAll: (names at: i); space].	aStream nextPut: $'.	^ aStream contents! !!MethodDictionary methodsFor: 'enumeration' stamp: 'to 1/14/98 10:13'!do: aBlock 	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (self basicAt: i) == nil ifFalse:			[aBlock value: (array at: i)]]! !!MethodDictionary methodsFor: 'private' stamp: 'tk 8/21/97 16:26'!copy	^ self shallowCopy withArray: array shallowCopy! !!MethodDictionary methodsFor: 'private' stamp: 'di 11/4/97 20:11'!grow 	| newSelf key |	newSelf _ self species new: self basicSize.  "This will double the size"	1 to: self basicSize do:		[:i | key _ self basicAt: i.		key == nil ifFalse: [newSelf at: key put: (array at: i)]].	self become: newSelf! !!MethodDictionary methodsFor: 'private'!rehash 	| newSelf key |	newSelf _ self species new: self size.	1 to: self basicSize do:		[:i | key _ self basicAt: i.		key == nil ifFalse: [newSelf at: key put: (array at: i)]].	self become: newSelf! !!MethodDictionary methodsFor: 'private'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject identityHash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ self basicAt: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ self basicAt: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!MethodDictionary class methodsFor: 'instance creation' stamp: 'di 11/4/97 20:11'!new: nElements	"Create a Dictionary large enough to hold nElements without growing.	Note that the basic size must be a power of 2.	It is VITAL (see grow) that size gets doubled if nElements is a power of 2"	| size |	size _ 1 bitShift: nElements highBit.	^ (self basicNew: size) init: size! !!MethodNode methodsFor: 'code generation'!generate: trailer	"The receiver is the root of a parse tree. Answer a CompiledMethod. The 	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs |	self generateIfQuick: 		[:method | 		1 to: trailer size do: [:i | method at: method size - trailer size + i put: (trailer at: i)].		method cacheTempNames: self tempNames.		^method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	encoder maxTemp > 31		ifTrue: [^self error: 'Too many temporary variables'].		literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stack discrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	1 to: trailer size do: [:i | method at: method size - trailer size + i put: (trailer at: i)].	method cacheTempNames: self tempNames.	^ method! !!MethodNode methodsFor: 'code generation'!sourceMap	"Answer a SortedCollection of associations of the form: pc (byte offset in 	me) -> sourceRange (an Interval) in source text."	self generate: #(0 0 0 0).	^encoder sourceMap! !!MethodNode methodsFor: 'converting'!decompileString 	"Answer a string description of the parse tree whose root is the receiver."	^ String streamContents: [:strm | self printOn: strm]! !!MethodNode methodsFor: 'converting'!decompileText 	"Answer a string description of the parse tree whose root is the receiver."	^ Text streamContents: [:strm | self printOn: strm]! !!MethodNode methodsFor: 'printing'!printOn: aStream 	| args |	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[args _ ReadStream on: arguments.			self selector keywords do: 				[:s | 				aStream nextPutAll: s; space.				aStream withAttribute: (TextColor color: Color green)					do: [aStream nextPutAll: args next key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '| '.			aStream withAttribute: (TextColor color: Color green)				do: [temporaries do: 					[:temp | 					aStream nextPutAll: temp key.					aStream space]].			aStream nextPut: $|].	primitive > 0 ifTrue:			[primitive < 256 ifTrue:  " Dont decompile <prim> for, eg, ^ self "				[aStream crtab: 1.				self printPrimitiveOn: aStream]].	aStream crtab: 1.	^block printStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'C translation'!asTMethodFromClass: aClass 	^ TMethod new		setSelector: selectorOrFalse		args: arguments		locals: encoder tempsAndBlockArgs		block: block! !A reader for Standard 1.0 format MIDI files.MIDI File Types:	type 0 -- one multi-channel track	type 1 -- one or more simultaneous tracks	type 2 -- a number on independent single-track patternsInstance variables:	stream			source of MIDI data	fileType			MIDI file type	trackCount		number of tracks in file	ticksPerQuarter	number of ticks per quarter note for all tracks in this file	tracks			collects track data for non-empty tracks	strings			collects all strings in the MIDI file	tempoMap		nil or a MIDITrack consisting only of tempo change events	trackStream		stream on buffer containing track chunk	track			track being read	activeEvents 	notes that have been turned on but not off!!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 1/6/98 23:20'!asScore	^ MIDIScore new		tracks: tracks;		trackInfo: trackInfo;		tempoMap: tempoMap;		ticksPerQuarterNote: ticksPerQuarter! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 12/31/97 12:45'!readHeaderChunk	| chunkType chunkSize division |	chunkType _ self readChunkType.	chunkType = 'MThd' ifFalse: [^ self error: 'missing MIDI file header chunk'].	chunkSize _ self readChunkSize.	fileType _ self next16BitWord.	trackCount _ self next16BitWord.	division _ self next16BitWord.	(division anyMask: 16r8000)		ifTrue: [self error: 'SMPTE time formats are not yet supported']		ifFalse: [ticksPerQuarter _ division].	"sanity checks"	chunkSize = 6		ifFalse: [self report: 'unusual MIDI header size ', chunkSize printString].	(#(0 1 2) includes: fileType)		ifFalse: [self report: 'unusual MIDI file type ', fileType printString].	Transcript		show: 'Reading Type ', fileType printString, ' MIDI File (';		show: trackCount printString, ' tracks, ';		show: ticksPerQuarter printString, ' ticks per quarter note)';		cr.! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 1/6/98 23:20'!readMIDIFrom: aBinaryStream	"Read one or more MIDI tracks from the given binary stream."	stream _ aBinaryStream.	tracks _ OrderedCollection new.	trackInfo _ OrderedCollection new.	self readHeaderChunk.	trackCount timesRepeat: [self readTrackChunk].	stream atEnd ifFalse: [self report: 'data beyond final track'].! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 12/31/97 10:41'!readTrackChunk	| chunkType chunkSize |	chunkType _ self readChunkType.	[chunkType = 'MTrk'] whileFalse: [		self report: 'skipping unexpected chunk type "', chunkType, '"'.		stream skip: (self readChunkSize).  "skip it"		chunkType _ (stream next: 4) asString].	chunkSize _ self readChunkSize.	chunkSize < 10000000 ifFalse: [		self error: 'suspiciously large track chunk; this may not be MIDI file'].	self readTrackContents: chunkSize.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 12/31/97 12:59'!endAllNotesAt: endTicks	activeEvents do: [:evt | evt duration: (endTicks - evt time)].	activeEvents _ activeEvents species new.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 12/31/97 11:36'!endNote: midiKey chan: channel at: endTicks	| evt |	evt _ activeEvents		detect: [:e | (e midiKey = midiKey) and: [e channel = channel]]		ifNone: [^ self].	evt duration: (endTicks - evt time).	activeEvents remove: evt ifAbsent: [].! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 1/3/98 09:45'!isTempoTrack: anEventList	"Return true if the given event list is non-empty and contains only tempo change events."	anEventList isEmpty ifTrue: [^ false].	anEventList do: [:evt | evt isTempoEvent ifFalse: [^ false]].	^ true! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 1/3/98 09:44'!metaEventAt: ticks	"Read a meta event. Event types appear roughly in order of expected frequency."	| type length tempo |	type _ trackStream next.	length _ self readVarLengthIntFrom: trackStream.	type = 16r51 ifTrue: [  "tempo"		tempo _ 0.		length timesRepeat: [tempo _ (tempo bitShift: 8) + trackStream next].		track add: (TempoEvent new tempo: tempo; time: ticks).		^ self].	type = 16r2F ifTrue: [  "end of track"		length = 0 ifFalse: [self error: 'length of end-of-track chunk should be zero'].		self endAllNotesAt: ticks.		trackStream skip: length.		^ self].	type = 16r58 ifTrue: [  "time signature"		length = 4 ifFalse: [self error: 'length of time signature chunk should be four'].		trackStream skip: length.		^ self].	type = 16r59 ifTrue: [  "key signature"		length = 2 ifFalse: [self error: 'length of key signature chunk should be two'].		trackStream skip: length.		^ self].	((type >= 1) and: [type <= 7]) ifTrue: [  "string"		strings add: (trackStream next: length) asString.		^ self].	(  type = 16r21 or:   "mystery; found in MIDI files but not in MIDI File 1.0 Spec"	 [(type = 16r7F) or:  "sequencer specific meta event"	 [(type = 16r00) or:  "sequence number"	 [(type = 16r20)]]])  "MIDI channel prefix"		ifTrue: [			trackStream skip: length.			^ self].	type = 16r54 ifTrue: [		"SMPTE offset"		self report: 'Warning: SMPTE offsets are not implemented'.		trackStream skip: length.		^ self].	"skip unrecognized meta event"	self report:		'skipping unrecognized meta event: ', (type printStringBase: 16),		' (', length printString, ' bytes)'.	trackStream skip: length.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 1/6/98 23:20'!readTrackContents: byteCount	| info |	strings _ OrderedCollection new.	track _ OrderedCollection new.	trackStream _ ReadStream on: (stream next: byteCount).	activeEvents _ OrderedCollection new.	self readTrackEvents.	(tracks isEmpty and: [self isTempoTrack: track])		ifTrue: [tempoMap _ track asArray]		ifFalse: [			track size > 0 ifTrue: [			tracks add: track asArray.			info _ WriteStream on: (String new: 100).			strings do: [:s | info nextPutAll: s; cr].			trackInfo add: info contents]].	strings _ track _ trackStream _ activeEvents _ nil.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 12/31/97 14:44'!readTrackEvents	"Read the events of the current track."	| cmd chan key vel ticks byte length |	cmd _ #unknown.	chan _ key _ vel _ 0.	ticks _ 0.	[trackStream atEnd] whileFalse: [		ticks _ ticks + (self readVarLengthIntFrom: trackStream).		byte _ trackStream next.		byte >= 16rF0			ifTrue: [  "meta or system exclusive event"				byte = 16rFF ifTrue: [self metaEventAt: ticks].				((byte = 16rF0) or: [byte = 16rF7]) ifTrue: [  "system exclusive data"					length _ self readVarLengthIntFrom: trackStream.					trackStream skip: length].				cmd _ #unknown]			ifFalse: [  "channel message event"				byte >= 16r80					ifTrue: [  "new command"						cmd _ byte bitAnd: 16rF0.						chan _ byte bitAnd: 16r0F.						key _ trackStream next]					ifFalse: [  "use running status"						cmd == #unknown							ifTrue: [self error: 'undefined running status; bad MIDI file?'].						key _ byte].				((cmd = 16rC0) or: [cmd = 16rD0]) ifFalse: [					"all but program change and channel pressure have two data bytes"					vel _ trackStream next].				cmd = 16r90 ifTrue: [  "note on"					vel = 0						ifTrue: [self endNote: key chan: chan at: ticks]						ifFalse: [self startNote: key vel: vel chan: chan at: ticks]].				cmd = 16r80 ifTrue: [  "note off"					self endNote: key chan: chan at: ticks]]].! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 1/3/98 09:44'!startNote: midiKey vel: vel chan: chan at: startTicks	| noteOnEvent |	noteOnEvent _ NoteEvent new key: midiKey velocity: vel channel: chan.	noteOnEvent time: startTicks.	track add: noteOnEvent.	activeEvents add: noteOnEvent.! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 12/31/97 10:30'!next16BitWord	"Read a 16-bit positive integer from the input stream, most significant byte first."	"Assume: Stream has at least two bytes left."	| n |	n _ stream next.	^ (n bitShift: 8) + stream next! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 12/31/97 10:29'!readChunkSize	"Read a 32-bit positive integer from the next 4 bytes, most significant byte first."	"Assume: Stream has at least four bytes left."	| n |	n _ 0.	1 to: 4 do: [:ignore | n _ (n bitShift: 8) + stream next].	^ n! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 12/31/97 10:40'!readChunkType	"Read a 32-bit positive integer from the next 4 bytes, most significant byte first."	"Assume: Stream has at least four bytes left."	| s |	s _ String new: 4.	1 to: 4 do: [:i | s at: i put: (stream next) asCharacter].	^ s! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 12/31/97 11:33'!readVarLengthIntFrom: aBinaryStream	"Read a one to four byte positive integer from the given stream, most significant byte first. Use only the lowest seven bits of each byte. The highest bit of a byte is set for all bytes except the last."	| n byte |	n _ 0.	1 to: 4 do: [:ignore |		byte _ aBinaryStream next.		byte < 128 ifTrue: [			n = 0				ifTrue: [^ byte]  "optimization for one-byte lengths"				ifFalse: [^ (n bitShift: 7) + byte]].		n _ (n bitShift: 7) + (byte bitAnd: 16r7F)].	self error: 'variable length quantity must not exceed four bytes'.! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 12/30/97 06:36'!report: aString	Transcript show: aString; cr.! !!MIDIFileReader class methodsFor: 'all' stamp: 'jm 1/4/98 11:35'!playFileNamed: fileName	(self scoreFromFileNamed: fileName) playRate: 1.0.! !!MIDIFileReader class methodsFor: 'all' stamp: 'jm 1/6/98 18:36'!playURLNamed: urlString	"MIDIFileReader playURLNamed: 'http://www.midiworld.com/mid/c2/wtellovr.mid'"	"MIDIFileReader playURLNamed: 'http://www.midiworld.com/mid/c2/barbero.mid'"	(self scoreFromURL: urlString) playRate: 1.0.! !!MIDIFileReader class methodsFor: 'all' stamp: 'jm 1/3/98 09:58'!scoreFromFileNamed: fileName	| f score |	f _ (FileStream readOnlyFileNamed: fileName) binary.	score _ (self new readMIDIFrom: f) asScore.	f close.	^ score! !!MIDIFileReader class methodsFor: 'all' stamp: 'jm 1/4/98 12:52'!scoreFromURL: urlString	| data score |	data _ (HTTPSocket httpGet: urlString) contents asByteArray.	score _ (self new readMIDIFrom: (ReadStream on: data)) asScore.	^ score! !!MIDIScore methodsFor: 'all' stamp: 'jm 1/7/98 10:49'!playRate: rate	^ (ScorePlayer new onScore: self) rate: rate; play! !!MIDIScore methodsFor: 'all' stamp: 'jm 1/4/98 11:20'!soundForTrack: trackIndex after: eventIndex ticks: ticks instrument: soundProto secsPerTick: secsPerTick	| track evt |	track _ tracks at: trackIndex.	eventIndex > track size ifTrue: [^ nil].	evt _ track at: eventIndex.	evt time <= ticks ifTrue: [		^ (soundProto copy			setPitch: evt pitch			dur: secsPerTick * evt duration			loudness: evt velocity asFloat / 127.0)].	^ nil! !!MIDIScore methodsFor: 'all' stamp: 'jm 1/3/98 07:36'!tempoMap	^ tempoMap! !!MIDIScore methodsFor: 'all' stamp: 'jm 1/3/98 08:16'!tempoMap: tempoEventList	tempoMap _ tempoEventList asArray.! !!MIDIScore methodsFor: 'all' stamp: 'jm 1/3/98 07:37'!ticksPerQuarterNote	^ ticksPerQuarterNote! !!MIDIScore methodsFor: 'all' stamp: 'jm 1/3/98 07:37'!ticksPerQuarterNote: anInteger	ticksPerQuarterNote _ anInteger.! !!MIDIScore methodsFor: 'all' stamp: 'jm 1/6/98 23:20'!trackInfo: trackInfoList	trackInfo _ trackInfoList asArray.! !!MIDIScore methodsFor: 'all' stamp: 'jm 1/3/98 08:15'!tracks	^ tracks! !!MIDIScore methodsFor: 'all' stamp: 'jm 1/3/98 08:17'!tracks: trackList	tracks _ trackList asArray collect: [:trackEvents | trackEvents asArray].! !!MixedSound methodsFor: 'initialization' stamp: 'jm 12/8/97 17:01'!initialize	sounds _ Array new.	leftVols _ Array new.	rightVols _ Array new.! !!MixedSound methodsFor: 'sound generation' stamp: 'jm 11/25/97 13:40'!doControl	super doControl.	1 to: sounds size do: [:i | (sounds at: i) doControl].! !!MixedSound methodsFor: 'sound generation' stamp: 'jm 1/5/98 13:42'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a number of sounds concurrently. The level of each sound can be set independently for the left and right channels."	| snd left right |	1 to: sounds size do: [:i |		(soundDone at: i) ifFalse: [			snd _ sounds at: i.			left _ (leftVol * (leftVols at: i)) // ScaleFactor.			right _ (rightVol * (rightVols at: i)) // ScaleFactor.			snd samplesRemaining > 0				ifTrue: [					snd mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: left rightVol: right]				ifFalse: [soundDone at: i put: true]]].! !!MixedSound methodsFor: 'sound generation' stamp: 'jm 12/8/97 17:07'!reset	super reset.	sounds do: [:snd | snd reset].	soundDone _ (Array new: sounds size) atAllPut: false.! !!MixedSound methodsFor: 'sound generation' stamp: 'jm 12/8/97 17:08'!samplesRemaining	| remaining r |	remaining _ 0.	1 to: sounds size do: [:i |		r _ (sounds at: i) samplesRemaining.		r > remaining ifTrue: [remaining _ r]].	^ remaining! !!MixedSound methodsFor: 'composition' stamp: 'jm 1/5/98 13:47'!add: aSound	"Add the given sound with a pan setting of centered and no attenuation."	self add: aSound pan: 0.5 volume: 1.0.! !!MixedSound methodsFor: 'composition' stamp: 'jm 1/5/98 13:47'!add: aSound pan: leftRightPan	"Add the given sound with the given left-right panning and no attenuation."	self add: aSound pan: leftRightPan volume: 1.0.! !!MixedSound methodsFor: 'composition' stamp: 'jm 1/5/98 17:33'!add: aSound pan: leftRightPan volume: volume	"Add the given sound with the given left-right pan, where 0.0 is full left, 1.0 is full right, and 0.5 is centered. The loudness of the sound will be scaled by volume, which ranges from 0 to 1.0."	| pan vol |	pan _ ((leftRightPan * ScaleFactor) asInteger max: 0) min: ScaleFactor.	vol _ ((volume * ScaleFactor) asInteger max: 0) min: ScaleFactor.	sounds _ sounds copyWith: aSound.	leftVols _ leftVols copyWith: ((ScaleFactor - pan) * vol) // ScaleFactor.	rightVols _ rightVols copyWith: (pan * vol) // ScaleFactor.! !!MixedSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:13'!copy	"Copy my component sounds."	^ super copy copySounds! !!MixedSound methodsFor: 'copying' stamp: 'jm 12/15/97 22:33'!copySounds	"Private!! Support for copying. Copy my component sounds and settings array."	sounds _ sounds collect: [:s | s copy].	leftVols _ leftVols copy.	rightVols _ rightVols copy.! !!Model methodsFor: 'dependents'!addDependent: anObject	"Make the given object one of the receiver's dependents."	dependents == nil		ifTrue: [dependents _ Array with: anObject]		ifFalse: [			"done if anObject is already a dependent"			dependents do: [:o | o == anObject ifTrue: [^ self]].			"otherwise, add it"			dependents _ dependents copyWith: anObject].! !!Model methodsFor: 'dependents'!breakDependents	"Remove all of the receiver's dependents."	dependents _ nil.! !!Model methodsFor: 'dependents'!dependents	"Answer a collection of objects that are 'dependent' on the receiver;	 that is, all objects that should be notified if the receiver changes."	dependents == nil ifTrue: [^ #()].	^ dependents! !!Model methodsFor: 'dependents' stamp: 'sw 10/30/96'!removeDependent: anObject	"Remove the given object as one of the receiver's dependents.	: if dependents nil on entry, simply exit; workaround for confusing bug encountered in bringing Fabrik up on Squeak."	| newDependents |	dependents == nil ifTrue: [^ self].	newDependents _ dependents select: [ :d | (d == anObject) not].	newDependents isEmpty		ifTrue: [dependents _ nil]		ifFalse: [dependents _ newDependents]! !!Model methodsFor: 'text links' stamp: 'di 1/15/98 23:32'!linkMethod: classAndMethod	"Make a linked message list and put this method in it"	| list |	list _ OrderedCollection new.	list add: classAndMethod.	LinkedMessageSet openMessageList: list name: 'Linked by HyperText'.! !!MonotonicFunctionMorph methodsFor: 'all' stamp: 'di 12/4/97 14:40'!dragVertex: evt fromHandle: handle vertIndex: ix	| p r |	"Constrain to owner bounds"	r _ owner innerBounds.	"Constrain between adjacent points"	ix > 1 ifTrue: [r _ r withLeft: (vertices at: ix-1) x].	ix < vertices size ifTrue: [r _ r withRight: (vertices at: ix+1) x].	owner isWorldOrHandMorph ifFalse:		["Constrain first and last points to sides"		ix = 1 ifTrue: [r _ r withRight: r left].		ix = vertices size ifTrue: [r _ r withLeft: r right]].	p _ evt cursorPoint adhereTo: r.	vertices at: ix put: p.	handle position: p - (handle extent//2).	self computeBounds! !!MonotonicFunctionMorph methodsFor: 'all' stamp: 'di 12/4/97 14:33'!initialize	super initialize.	borderWidth _ 2.	borderColor _ Color green darker.	closed _ false.	quickFill _ true.	arrows _ #none.	self setVertices: (Array with: 20@40 with: 40@30 with: 60@40).! !Morph comment:'A morph (from the Greek "shape" or "form") is an interactive graphical object.'!!Morph methodsFor: 'initialization'!initialize	bounds _ 0@0 corner: 50@40.	owner _ nil.	submorphs _ EmptyArray.	color _ Color blue.	! !!Morph methodsFor: 'classification'!isHandMorph	^ false! !!Morph methodsFor: 'classification'!isLayoutMorph	^ false! !!Morph methodsFor: 'classification'!isMorph	^ true! !!Morph methodsFor: 'classification'!isWorldMorph	^ false! !!Morph methodsFor: 'classification'!isWorldOrHandMorph	^ self isWorldMorph or: [self isHandMorph]! !!Morph methodsFor: 'accessing' stamp: 'di 9/18/97 08:08'!balloonHelpTextForHandle: aHandle	^ 'If you click on the ' , aHandle color name , ' handle,it will ' , (#('probably not do anything.'		'let you pick up this object.'		'let you rotate this object.'		'bring up a menu for this object.'		'let you resize this object.'		'let you duplicate this object.'		'show information about this object.'		'let you drag this object'		'let you change the font'		'let you change the style'		'let you change the emphasis'		'let you look inside this object'		'repaint this object')	at: (#(none black blue red yellow green lightBlue brown lightGreen lightRed lightBrown lightYellow lightGray) indexOf: aHandlecolor name ifAbsent: [1]))! !!Morph methodsFor: 'accessing' stamp: 'sw 9/9/97 17:12'!balloonHelpTextForHandle: aHandle inHalo: aHalo	^ 'If you click on the ' , aHandle color name , ' handle,it will ' , (#('probably not do anything.'		'let you pick up this object.'		'let you rotate this object.'		'bring up a menu for this object.'		'let you resize this object.'		'let you duplicate this object.'		'show information about this object.'		'let you drag this object'		'let you change the font'		'let you change the style'		'let you change the emphasis'		'let you look inside this object'		'repaint this object')	at: (#(none black blue red yellow green lightBlue brown lightGreen lightRed lightBrown lightYellow lightGray) indexOf: aHandlecolor name ifAbsent: [1]))! !!Morph methodsFor: 'accessing'!color	^ color! !!Morph methodsFor: 'accessing' stamp: 'jm 8/24/97 21:26'!color: aColor	color = aColor ifFalse: [		color _ aColor.		self changed].! !!Morph methodsFor: 'accessing'!colorForInsets	"Return the color to be used for shading inset borders.  The default is my own color, but it might want to be, eg, my owner's color."	^ color! !!Morph methodsFor: 'accessing'!eventHandler	^ eventHandler! !!Morph methodsFor: 'accessing' stamp: 'tk 5/22/97'!eventHandler: anEventHandler	"Note that morphs can share eventHandlers and all is OK.  "	eventHandler _ anEventHandler.! !!Morph methodsFor: 'accessing' stamp: '6/6/97 12:39 di'!paneColor: aColor	"May be overridden to color certain morphs in, eg, a browser"! !!Morph methodsFor: 'copying'!copy	^ self copyWithoutSubmorphs! !!Morph methodsFor: 'copying' stamp: 'tk 8/21/97 15:05'!fullCopy	"Produce a copy of me with my entire tree of submorphs.  Morphsmentioned more than once are all directed to a single new copy.  Simpleinst vars are not copied, so you must override to copy Arrays, etc.  "	| dict new |	dict _ IdentityDictionary new: 1000.	new _ self copyRecordingIn: dict.	new allMorphsDo: [:m | m updateReferencesUsing: dict].	^ new! !!Morph methodsFor: 'copying' stamp: 'tk 8/21/97 15:50'!updateReferencesUsing: aDictionary	"Update intra-morph references within a composite morph that hasbeen copied. For example, if a button refers to morph X in the orginalcomposite then the copy of that button in the new composite should refer tothe copy of X in new composite, not the original X. This defaultimplementation updates the contents of any morph-bearing slot. It may beoverridden to avoid this behavior if so desired."	| old |	Morph instSize + 1 to: self class instSize do:		[:i | old _ self instVarAt: i.		old isMorph ifTrue:			[self instVarAt: i put: (aDictionary at: oldifAbsent: [old])]].	eventHandler ifNotNil:		[eventHandler _ eventHandler copy.		1 to: eventHandler class instSize do:			[:i | old _ eventHandler instVarAt: i.			old isMorph ifTrue:				[eventHandler instVarAt: i put:(aDictionary at: old ifAbsent: [old])]]].	properties ifNotNil: [		properties associationsDo: [:ass |			ass value: (aDictionary at: ass value ifAbsent:[ass value])]].	"note side effecting"! !!Morph methodsFor: 'structure' stamp: 'jm 7/8/97 10:08'!isInWorld	"Return true if this morph is in a world."	^ self world ~~ nil! !!Morph methodsFor: 'structure' stamp: 'sw 9/26/97 10:30'!outermostMorphThat: aBlock	"Return the outermost containing morph for which aBlock is true, or nil if none"	| current outermost |	current _ owner.	[current == nil] whileFalse:			[(aBlock value: current) ifTrue: [outermost _ current].			current _ current owner].	^ outermost! !!Morph methodsFor: 'structure'!owner	"Returns the owner of this morph, which may be nil."	^ owner! !!Morph methodsFor: 'structure' stamp: 'tk 10/12/97 17:30'!ownerThatIsA: aClass	"Return the first enclosing morph that is a kind of aClass, or nil if none"	| current |	current _ owner.	[current == nil] whileFalse:			[(current isKindOf: aClass) ifTrue: [^ current].			current _ current owner].	^ current! !!Morph methodsFor: 'structure'!root	"Return the root of the composite morph containing the receiver. The owner of the root is either nil, a WorldMorph, or a HandMorph. If the receiver's owner is nil, the root is the receiver itself. This method always returns a morph."	(owner = nil or: [owner isWorldOrHandMorph]) ifTrue: [^ self].	^ owner root! !!Morph methodsFor: 'structure' stamp: 'jm 7/5/97 17:05'!world	"Return the WorldMorph that contains this morph, or nil if this morph is not in a world."	| o |	o _ self root owner.	o ifNil: [^ nil].	o isWorldMorph ifTrue: [^ o].	o isHandMorph ifTrue: [^ o owner].! !!Morph methodsFor: 'submorphs-accessing'!allMorphs	"Return a collection containing all morphs in this composite morph (including the receiver)."	| all |	all _ OrderedCollection new: 100.	self allMorphsDo: [: m | all add: m].	^ all! !!Morph methodsFor: 'submorphs-accessing'!allMorphsDo: aBlock	"Evaluate the given block for all morphs in this composite morph (including the receiver)."	submorphs size > 0 ifTrue: [		submorphs do: [:m | m allMorphsDo: aBlock].	].	aBlock value: self.! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 10/31/97 20:05'!allNonSubmorphMorphs	"Return a collection containing all morphs in this morph which are not currently in the submorph containment hierarchy (put in primarily for bookmorphs)"	^ OrderedCollection new! !!Morph methodsFor: 'submorphs-accessing' stamp: 'tk 5/29/97'!couldBeOwnedBy: aMorph	"Return true if self has no WorldMorph in its owner chain (it is not installed anywhere) or has aMorph in owner chain.  Returns false if self is definately owned by someone else, not aMorph.  Used for writing a subtree on the disk.  Need to include morphs with nil owner who are held in inst vars.  "	| nextOwner prev |	"is aMorph in my owner chain?"	nextOwner _ self.	prev _ nil.	[nextOwner == aMorph ifTrue: [^ true].		nextOwner == nil] whileFalse: [prev _ nextOwner.								nextOwner _ nextOwner owner].	^ prev isWorldMorph not	"If chain ends with no WorldMorph, not installed and might be held by aMorph"	"If installed in a world, and aMorph is in NOT on my owner chain, ^ false"	! !!Morph methodsFor: 'submorphs-accessing'!findA: aClass	"Return the first submorph of the receiver that is descended from the given class. Return nil if there is no such submorph. Clients of this code should always check for a nil return value so that the code will be robust if the user takes the morph apart."	submorphs do: [:each | (each isKindOf: aClass) ifTrue: [^ each]].	^ nil! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 8/7/97 10:38'!findInWorldA: aClass	"Return the first submorph of the receiver's world that is descended from the given class. Return nil if there is no such submorph. Clients of this code should always check for a nil return value so that the code will be robust if the user takes the morph apart."	^ self world findA: aClass! !!Morph methodsFor: 'submorphs-accessing'!firstSubmorph	^ submorphs at: 1! !!Morph methodsFor: 'submorphs-accessing'!hasSubmorphs	^ submorphs size > 0! !!Morph methodsFor: 'submorphs-accessing'!lastSubmorph	^ submorphs at: submorphs size! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 5/23/97'!morphsAt: aPoint	"Return a collection of all morphs in this morph structure that contain the given point, possibly including the receiver itself.  Simplified "	^ self morphsAt: aPoint addTo: OrderedCollection new! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 8/22/97 23:48'!morphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point, possibly including the receiver itself.  Must do this recursively because of transforms.  "	submorphs size > 0 ifTrue:		[submorphs do: [:m | m morphsAt: aPoint addTo: mList]].	(self containsPoint: aPoint) ifTrue: [mList addLast: self].	^ mList! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 11/14/97 13:09'!morphsIntersecting: aRectangle do: morphBlock	"Perform a display-order traversal of morphic structure,	evaluating aBlock for every morph that intersects aRectangle.	NOTE: this code is fast and conservative -- clients must refine	with, eg, containsPoint:, as this method only considers bounds."	(aRectangle intersects: self fullBounds) ifFalse: [^ self].	(aRectangle intersects: bounds) ifTrue: [morphBlock value: self].	submorphs size > 0 ifTrue:		[submorphs reverseDo:			[:m | m morphsIntersecting: aRectangle do: morphBlock]]! !!Morph methodsFor: 'submorphs-accessing'!submorphCount	^ submorphs size! !!Morph methodsFor: 'submorphs-accessing'!submorphs	^ submorphs copy! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 11/4/97 14:30'!submorphsBehind: aMorph do: aBlock	| behind |	behind _ false.	submorphs do:		[:m | m == aMorph ifTrue: [behind _ true]						ifFalse: [behind ifTrue: [aBlock value: m]]].! !!Morph methodsFor: 'submorphs-accessing'!submorphsDo: aBlock	submorphs do: aBlock.! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 11/4/97 14:29'!submorphsInFrontOf: aMorph do: aBlock	| behind |	behind _ false.	submorphs do:		[:m | m == aMorph ifTrue: [behind _ true]						ifFalse: [behind ifFalse: [aBlock value: m]]].! !!Morph methodsFor: 'submorphs-accessing'!submorphsReverseDo: aBlock	submorphs reverseDo: aBlock.! !!Morph methodsFor: 'submorphs-accessing' stamp: 'jm 7/29/97 15:09'!uncoveredAt: aPoint	"Return true if the receiver is not covered by any submorphs at the given point."	| morphsAbove |	morphsAbove _ self world morphsAt: aPoint.	^ morphsAbove first = self or:	 [(morphsAbove first isKindOf: HaloMorph) and:	 [(morphsAbove at: 2) = self]]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 8/22/97 23:45'!unlockedMorphsAt: aPoint	"Return a collection of all unlocked morphs in this morph structure that contain the given point, possibly including the receiver itself.  Simplified "	^ self unlockedMorphsAt: aPoint addTo: OrderedCollection new! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 8/22/97 23:45'!unlockedMorphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point, possibly including the receiver itself.  Must do this recursively because of transforms.  "	self isLocked ifTrue: [^ mList].	submorphs size > 0 ifTrue:		[submorphs do: [:m | m unlockedMorphsAt: aPoint addTo: mList]].	(self containsPoint: aPoint) ifTrue: [mList addLast: self].	^ mList! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 11/14/97 12:58'!visibleMorphsIn: aRectangle	"Return the front-most morphs that fill this rectangle.	Designed to avoid drawing fully occluded regions"	| visibleMorphs |	visibleMorphs _ OrderedCollection new: 50.	self morphsIntersecting: aRectangle		do: [:m | (m drawOnFills: aRectangle) ifTrue: [visibleMorphs reset].			visibleMorphs addLast: m].	^ visibleMorphs! !!Morph methodsFor: 'submorphs-add/remove'!addAllMorphs: aCollection	aCollection do: [:m |		m owner ifNotNil: [m owner privateRemoveMorph: m].		m layoutChanged.		m privateOwner: self].	submorphs _ submorphs, aCollection.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove'!addMorph: aMorph	self addMorphFront: aMorph.! !!Morph methodsFor: 'submorphs-add/remove'!addMorphBack: aMorph	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph layoutChanged.	aMorph privateOwner: self.	submorphs _ submorphs copyWith: aMorph.	aMorph changed.  "need to paint morphs now front, if any"	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'dhhi 11/6/97 16:02'!addMorphBack: aMorph fromWorldPosition: wp	self addMorphBack: aMorph.	aMorph position: (self transformFromWorld transform: wp)! !!Morph methodsFor: 'submorphs-add/remove'!addMorphCentered: aMorph	self addMorphFront: aMorph.	aMorph position: bounds center - (aMorph extent // 2)! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jm 7/30/97 15:49'!addMorphFront: aMorph	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph layoutChanged.	aMorph privateOwner: self.	submorphs _ (Array with: aMorph), submorphs.	aMorph changed.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'di 10/27/97 23:26'!copyWithoutSubmorph: sub	"Needed to get a morph to draw without one of its submorphs.	NOTE:  This must be thrown away immediately after use."	^ self clone privateSubmorphs: (submorphs copyWithout: sub)! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 11/17/97 17:53'!delete	"Remove the receiver as a submorph of its owner and make its new owner be nil."	| aWorld |	aWorld _ self world.	owner ifNotNil:		[owner privateRemoveMorph: self.		owner _ nil.		aWorld ifNotNil: [aWorld noteDeletionOf: self]].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'di 11/16/97 16:28'!goBehind	owner addMorphBack: self.! !!Morph methodsFor: 'submorphs-add/remove'!removeAllMorphs	self changed.	submorphs do: [:m | m privateOwner: nil].	submorphs _ EmptyArray.	self layoutChanged.! !!Morph methodsFor: 'drawing'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: color.! !!Morph methodsFor: 'drawing' stamp: 'di 11/14/97 10:52'!drawOnFills: aRectangle	"May be overridden by any subclasses whose drawOn: method	may completely fill the rectangle"	^ false! !!Morph methodsFor: 'drawing'!fullDrawOn: aCanvas	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	(aCanvas isVisible: bounds) ifTrue: [self drawOn: aCanvas].	submorphs isEmpty ifFalse: [		submorphs reverseDo: [:m | m fullDrawOn: aCanvas]].  "draw back-to-front"! !!Morph methodsFor: 'drawing' stamp: 'jm 6/11/97 17:21'!imageForm	^ self imageFormForRectangle: self fullBounds! !!Morph methodsFor: 'drawing'!imageFormForRectangle: rect	| canvas |	canvas _ FormCanvas extent: rect extent.	self fullDrawOn: (canvas copyOffset: rect topLeft negated).	^ canvas form offset: rect topLeft! !!Morph methodsFor: 'geometry' stamp: 'di 7/24/97 11:55'!align: aPoint1 with: aPoint2	"Translate by aPoint2 - aPoint1."	^ self position: self position + (aPoint2 - aPoint1)! !!Morph methodsFor: 'geometry'!bottom	^ bounds bottom! !!Morph methodsFor: 'geometry' stamp: 'tk 9/8/97 10:44'!bottomLeft	^ bounds bottomLeft! !!Morph methodsFor: 'geometry' stamp: 'di 6/12/97 11:17'!bottomRight	^ bounds bottomRight! !!Morph methodsFor: 'geometry' stamp: 'jm 8/3/97 15:50'!bounds	"Return the bounds of this morph."	"Note: It is best not to override this method because many methods in Morph and its subclasses use the instance variable directly rather than 'self bounds'. Instead, subclasses should be sure that the bounds instance variable is correct."	^ bounds! !!Morph methodsFor: 'geometry'!bounds: newBounds	self position: newBounds topLeft; extent: newBounds extent! !!Morph methodsFor: 'geometry'!center	^ bounds center! !!Morph methodsFor: 'geometry'!extent	^ bounds extent! !!Morph methodsFor: 'geometry' stamp: 'jm 8/24/97 21:27'!extent: aPoint	bounds extent = aPoint ifFalse: [		self changed.		bounds _ bounds topLeft extent: aPoint.		self layoutChanged.		self changed].! !!Morph methodsFor: 'geometry' stamp: 'jm 10/16/97 09:36'!fullBounds	fullBounds ifNil: [		fullBounds _ self bounds.		self submorphsDo: [:m | fullBounds _ fullBounds quickMerge: m fullBounds]].	^ fullBounds! !!Morph methodsFor: 'geometry'!height	^ bounds height! !!Morph methodsFor: 'geometry'!innerBounds	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."	^ bounds! !!Morph methodsFor: 'geometry'!left	^ bounds left! !!Morph methodsFor: 'geometry' stamp: 'sw 8/11/97 14:35'!nextOwnerPage	"Tell my container to advance to the next page"	| targ |	targ _ owner.	[targ respondsTo: #nextPage] whileFalse: [targ _ targ owner].	targ nextPage! !!Morph methodsFor: 'geometry'!position	^ bounds topLeft! !!Morph methodsFor: 'geometry' stamp: 'jm 7/5/97 13:35'!position: aPoint	"Change the position of this morph and and all of its submorphs."	| delta |	delta _ aPoint truncated - bounds topLeft.	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"	self changed.	self privateFullMoveBy: delta.	self changed.! !!Morph methodsFor: 'geometry' stamp: 'sw 8/11/97 23:03'!previousOwnerPage	"Tell my container to advance to the previous page"	| targ |	targ _ owner.	[targ respondsTo: #previousPage] whileFalse: [targ _ targ owner].	targ previousPage! !!Morph methodsFor: 'geometry'!right	^ bounds right! !!Morph methodsFor: 'geometry' stamp: 'sw 8/20/97 23:36'!setConstrainedPositionFrom: aPoint	"Change the position of this morph and and all of its submorphs to aPoint, but don't let me go outside my owner's bounds."	| trialRect delta |	trialRect _ aPoint extent: self bounds extent.	delta _ trialRect amountToTranslateWithin: owner bounds.	self position: aPoint + delta! !!Morph methodsFor: 'geometry'!top	^ bounds top! !!Morph methodsFor: 'geometry' stamp: 'di 6/12/97 11:07'!topLeft	^ bounds topLeft! !!Morph methodsFor: 'geometry' stamp: 'sw 8/20/97 23:04'!topRight	^ bounds topRight! !!Morph methodsFor: 'geometry'!width	^ bounds width! !!Morph methodsFor: 'geometry testing'!containsPoint: aPoint	^ self bounds containsPoint: aPoint! !!Morph methodsFor: 'geometry testing'!fullContainsPoint: aPoint	(self fullBounds containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"	self allMorphsDo:		[:m | (m containsPoint: aPoint) ifTrue: [^ true]].	^ false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 10/18/97 18:03'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto a morph that has agreed to accept the dropped morph by responding 'true' to the wantsDroppedMorph:Event: message. This default implementation just adds the given morph to the receiver."	self addMorph: aMorph.! !!Morph methodsFor: 'dropping/grabbing'!allowSubmorphExtraction	"Return true if this morph allows its submorphs to be extracted just by grabbing them. This default implementation returns false."	^ false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 10/18/97 18:16'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	self removeProperty: #partsDonor! !!Morph methodsFor: 'dropping/grabbing'!wantsDroppedMorph: aMorph event: evt	"Return true if the receiver wishes to accept the given morph, which is being dropped into the world by a hand in response to the given event. This default implementation returns false."	^ false! !!Morph methodsFor: 'event handling'!click: evt	"Handle a single-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation does nothing."! !!Morph methodsFor: 'event handling'!doubleClick: evt	"Handle a double-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation does nothing."! !!Morph methodsFor: 'event handling'!drag: evt	"Handle a double-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation does nothing."! !!Morph methodsFor: 'event handling'!handlesMouseDown: evt	"Return true if this morph handles mouse events (mouseDown, mouseMove, mouseUp) itself or if its event handler does. Subclasses that implement mouse events typically override this message."	eventHandler ifNotNil: [^ eventHandler handlesMouseDown: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'tk 5/22/97'!handlesMouseOver: evt	"Do I respond to mouseDown, mouseStillDown, or mouseUp?  "	eventHandler ifNotNil: [^ eventHandler handlesMouseOver: evt].	^ false! !!Morph methodsFor: 'event handling'!keyboardFocusChange: aBoolean	"The message is sent to a morph when its keyboard focus change. The given argument indicates that the receiver is gaining keyboard focus (versus losing) the keyboard focus. Morphs that accept keystrokes should change their appearance in some way when they are the current keyboard focus. This default implementation does nothing."! !!Morph methodsFor: 'event handling'!keyStroke: anEvent	"Handle a keystroke event.  The default response is to let my eventHandler, if any, handle it."	eventHandler ifNotNil:		[eventHandler keyStroke: anEvent fromMorph: self].! !!Morph methodsFor: 'event handling'!mouseDown: evt	"Handle a mouse down event. The default response is to let my eventHandler, if any, handle it."	eventHandler ifNotNil:		[eventHandler mouseDown: evt fromMorph: self].! !!Morph methodsFor: 'event handling'!mouseEnter: evt	"Handle a mouseEnter event, meaning the mouse just entered my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."	eventHandler ifNotNil:		[eventHandler mouseEnter: evt fromMorph: self].! !!Morph methodsFor: 'event handling'!mouseLeave: evt	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."	eventHandler ifNotNil:		[eventHandler mouseLeave: evt fromMorph: self].! !!Morph methodsFor: 'event handling'!mouseMove: evt	"Handle a mouse move event. The default response is to let my eventHandler, if any, handle it."	eventHandler ifNotNil:		[eventHandler mouseStillDown: evt fromMorph: self].! !!Morph methodsFor: 'event handling'!mouseUp: evt	"Handle a mouse up event. The default response is to let my eventHandler, if any, handle it."	eventHandler ifNotNil:		[eventHandler mouseUp: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 7/2/97 08:02'!mouseUpBalk: evt	"May be sent to me when a user moves out of a button I own and then lets up the mouse.  For radion buttons, I need to select some button.  tk 7/2/97 08:02"	"do nothing as default"! !!Morph methodsFor: 'event handling'!on: eventName send: selector to: recipient	eventHandler ifNil: [eventHandler _ EventHandler new].	eventHandler on: eventName send: selector to: recipient! !!Morph methodsFor: 'event handling' stamp: '6/9/97 06:22 di'!on: eventName send: selector to: recipient withValue: value	"NOTE: selector must take 3 arguments, of which value will be the 3rd"	eventHandler ifNil: [eventHandler _ EventHandler new].	eventHandler on: eventName send: selector to: recipient withValue: value! !!Morph methodsFor: 'event handling'!passToEventHandler: evt	"Pass the given event to my event handler, if any."	eventHandler ifNotNil:		[eventHandler handleEvent: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'sw 8/11/97 18:36'!preemptsMouseDown: evt	"Return true if this morph wants to handle mouse down events even when the mouse is pressed over a submorph that also wishes to handle mouse down events. Responding true to this message allows a morph to reverse the normal policy that control is given to the inner-most submorph that wants it. This can be used, for example, to allow buttons in a parts bin to be copied when clicked, instead of being activated."	^ self isPartsDonor! !!Morph methodsFor: 'event handling'!transformFrom: uberMorph	"Return a transform to be used to map coordinates in a morph above me into my local coordinates, or vice-versa. This is used to support scrolling, scaling, and/or rotation. This default implementation just returns my owner's transform or the identity transform if my owner is nil."	owner == uberMorph ifTrue: [^ MorphicTransform identity].	owner ifNil: [^ MorphicTransform identity].	^ owner transformFrom: uberMorph! !!Morph methodsFor: 'event handling'!transformFromWorld	"Return a transform to map world coordinates into my local coordinates"	^ self transformFrom: nil! !!Morph methodsFor: 'event handling' stamp: 'sw 10/3/97 09:12'!trumpsMouseDown: evt	"Return true if this morph wants to handle mouse down events even when the mouse is pressed under a submorph that also wishes to preepmpt mouse down events. Complete the comment."	^ false! !!Morph methodsFor: 'stepping'!startStepping	"Start getting sent the 'step' message."	| w |	self step.  "one to get started!!"	w _ self world.	w ifNotNil: [		w startStepping: self.		self changed].! !!Morph methodsFor: 'stepping'!step	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message. This default implementation does nothing."! !!Morph methodsFor: 'stepping'!stepTime	"Answer the desired time between steps in milliseconds. This default implementation requests that the 'step' method be called once every second."	^ 1000! !!Morph methodsFor: 'stepping'!stopStepping	"Stop getting sent the 'step' message."	| w |	w _ self world.	w ifNotNil: [		w stopStepping: self.		self changed].! !!Morph methodsFor: 'stepping'!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	c _ self class.	[c includesSelector: #step] whileFalse: [c _ c superclass].	^ c ~= Morph! !!Morph methodsFor: 'menu' stamp: 'jm 11/13/97 16:13'!addAddHandMenuItemsForHalo: aMenu	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu add: 'poof' action: #dismissMorph.	aMenu addLine.	aMenu add: 'lock' action: #lockMorph.	unlockables _ self submorphs select: [:m | m isLocked].	unlockables size == 1 ifTrue: [		aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue: [		aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	aMenu addLine.	aMenu add: 'go behind' action: #goBehind.	aMenu add: 'rename me' action: #chooseActorName.	self colorSettable ifTrue: [		aMenu add: 'fill color' action: #changeColor].	aMenu addLine.	(Preferences valueOfFlag: #hackerMode) ifTrue: [		aMenu add: 'inspect' action: #inspectMorph.		aMenu add: 'browse' action: #browseMorphClass.		aMenu add: 'make own subclass' action: #subclassMorph.		aMenu addLine.		aMenu add: 'internal name' action: #nameMorph.		aMenu add: 'save morph in file' action: #saveMorphInFile.		aMenu addLine].! !!Morph methodsFor: 'menu' stamp: 'sw 11/17/97 21:26'!addCustomHaloMenuItems: aMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand from the halo.  To get started, we defer to the counterpart method used with the option-menu, but in time we can have separate menu choices for halo-menus and for option-menus"	self addCustomMenuItems: aMenu hand: aHandMorph! !!Morph methodsFor: 'menu' stamp: 'sw 11/3/97 13:40'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."! !!Morph methodsFor: 'menu' stamp: 'di 11/4/97 05:45'!addDropShadow	| ds |	self owner addMorph: (ds _ DropShadowMorph new).	ds addMorph: self! !!Morph methodsFor: 'layout'!minHeight	"Return the minimum width for this morph. Ordinary morphs just answer their current height."	^ self fullBounds height! !!Morph methodsFor: 'layout'!minWidth	"Return the minimum width for this morph. Ordinary morphs just answer their current width."	^ self fullBounds width! !!Morph methodsFor: 'change reporting' stamp: 'di 11/16/97 15:15'!changed	"Report that the area occupied by this morph should be redrawn."	self invalidRect: self fullBounds.! !!Morph methodsFor: 'change reporting'!invalidRect: damageRect	owner ifNotNil: [owner invalidRect: damageRect].! !!Morph methodsFor: 'change reporting' stamp: 'di 11/16/97 15:15'!layoutChanged	"Note that something has changed about the size, shape, or location of the receiver or one of its submorphs, so that fullBounds must be recomputed."	fullBounds _ nil.	owner ifNotNil: [owner layoutChanged].	submorphs size > 0 ifTrue:		["Let submorphs know about a change above"		submorphs do: [:m | m ownerChanged]].! !!Morph methodsFor: 'change reporting' stamp: 'di 10/27/97 22:52'!ownerChanged	"Default no-op may be overridden as for text embedded in changing shape"	^ self! !!Morph methodsFor: 'printing'!colorString: aColor	aColor == nil ifTrue: [^ 'nil'].	Color colorNames do: [:colorName | aColor = (Color perform: colorName)								ifTrue: [^ 'Color ' , colorName]].	^ aColor storeString! !!Morph methodsFor: 'printing'!constructorString	^ String streamContents: [:s | self printConstructorOn: s indent: 0].! !!Morph methodsFor: 'printing' stamp: 'sw 1/15/98 11:10'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ self externalName! !!Morph methodsFor: 'printing'!fullPrintOn: aStream	aStream nextPutAll: self class name , ' newBounds: (';		print: bounds;		nextPutAll: ') color: ' , (self colorString: color)! !!Morph methodsFor: 'printing'!initString	^ String streamContents: [:s | self fullPrintOn: s]! !!Morph methodsFor: 'printing'!printConstructorOn: aStream indent: level	^ self printConstructorOn: aStream indent: level nodeDict: IdentityDictionary new! !!Morph methodsFor: 'printing'!printConstructorOn: aStream indent: level nodeDict: nodeDict	| nodeString |	(nodeString _ nodeDict at: self ifAbsent: [nil])		ifNotNil: [^ aStream nextPutAll: nodeString].	submorphs isEmpty ifFalse: [aStream nextPutAll: '('].	aStream nextPutAll: '('.	self fullPrintOn: aStream.	aStream nextPutAll: ')'.	submorphs isEmpty ifTrue: [^ self].	submorphs size <= 4	ifTrue:		[aStream crtab: level+1;			nextPutAll: 'addAllMorphs: (Array'.		1 to: submorphs size do:			[:i | aStream crtab: level+1; nextPutAll: 'with: '.			(submorphs at: i) printConstructorOn: aStream indent: level+1 nodeDict: nodeDict].		aStream nextPutAll: '))']	ifFalse:		[aStream crtab: level+1;			nextPutAll: 'addAllMorphs: ((Array new: ', submorphs size printString, ')'.		1 to: submorphs size do:			[:i |			aStream crtab: level+1; nextPutAll: 'at: ', i printString, ' put: '.			(submorphs at: i) printConstructorOn: aStream indent: level+1 nodeDict: nodeDict.			aStream nextPutAll: ';'].		aStream crtab: level+1; nextPutAll: 'yourself))']! !!Morph methodsFor: 'printing' stamp: 'sw 8/4/97 12:05'!printOn: aStream	| string aName |	super printOn: aStream.	(aName _ self knownName) ~~ nil ifTrue:		[aStream nextPutAll: '<', aName, '>'].	string _ self findA: StringMorph.	aStream nextPutAll: '('.	string ifNotNil: [			aStream print: string contents; space]. 	aStream print: self identityHash;			nextPutAll: ')'.! !!Morph methodsFor: 'e-toy commands'!start	"Start running my script. For ordinary morphs, this means start stepping."	self startStepping.! !!Morph methodsFor: 'e-toy commands'!stop	"Stop running my script. For ordinary morphs, this means stop stepping."	self stopStepping.! !!Morph methodsFor: 'e-toy support' stamp: 'sw 8/12/97 23:04'!externalName	| n |	(n _ self knownName) ifNotNil: [^ n].	^ self innocuousName! !!Morph methodsFor: 'e-toy support'!nameInModel	"Return the name for this morph in the underlying model or nil."	| w |	w _ self world.	w == nil		ifTrue: [^ nil]		ifFalse: [^ w model nameFor: self].! !!Morph methodsFor: 'e-toy support' stamp: 'jm 8/3/97 10:29'!referencePosition	^ bounds origin! !!Morph methodsFor: 'e-toy support'!rotationDegrees	"Default implementation."	^ 0.0! !!Morph methodsFor: 'e-toy support'!rotationDegrees: ignored	"Default implementation that does nothing to support noop turn: command."! !!Morph methodsFor: 'e-toy support'!specialNameInModel	"Return the name for this morph in the underlying model or nil."	"Not an easy problem.  For now, take the first part of the mouseDownSelector symbol in my eventHandler (fillBrushMouseUp:morph: gives 'fillBrush').  5/26/97 tk"	| hh |	(self isKindOf: MorphicModel)		ifTrue: [^ self slotName]		ifFalse: [			eventHandler ifNotNil: [				eventHandler mouseDownSelector ifNotNil: [					hh _ eventHandler mouseDownSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ eventHandler mouseDownSelector copyFrom: 1 to: hh-1]].				eventHandler mouseUpSelector ifNotNil: [					hh _ eventHandler mouseUpSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ eventHandler mouseUpSelector copyFrom: 1 to: hh-1]].				]].			"	(eventHandler mouseDownRecipient respondsTo: #nameFor:) ifTrue: [					^ eventHandler mouseDownRecipient nameFor: self]]].	"			"myModel _ self findA: MorphicModel.			myModel ifNotNil: [^ myModel slotName]"		^ self world model nameFor: self! !!Morph methodsFor: 'model access'!choosePartName	"Pick an unused name for this morph."	| className |	className _ self class name.	(className size > 5 and: [className endsWith: 'Morph'])		ifTrue: [className _ className copyFrom: 1 to: className size - 5].	^ self world model addPartNameLike: className withValue: self! !!Morph methodsFor: 'model access' stamp: 'sw 8/5/97 14:14'!innocuousName	"Choose an innocuous name for the receiver -- one that does not end in the word Morph"	| className |	className _ self class name.	(className size > 5 and: [className endsWith: 'Morph'])		ifTrue: [className _ className copyFrom: 1 to: className size - 5].	^ className asString! !!Morph methodsFor: 'model access'!installModelIn: ignored	"Simple morphs have no model"	"See MorphicApp for other behavior"! !!Morph methodsFor: 'other' stamp: 'sw 8/11/97 12:40'!flash	| w |	w _ self world.	w ifNotNil: [		Display flash: (bounds translateBy: w viewBox origin)].! !!Morph methodsFor: 'other' stamp: 'jm 11/13/97 16:35'!fullLoadCachedState	"Load the cached state of the receiver and its full submorph tree."	self allMorphsDo: [:m | m loadCachedState].! !!Morph methodsFor: 'other' stamp: 'jm 11/13/97 16:34'!fullReleaseCachedState	"Release the cached state of the receiver and its full submorph tree."	self allMorphsDo: [:m | m releaseCachedState].! !!Morph methodsFor: 'other' stamp: 'jm 11/13/97 16:37'!loadCachedState	"Load the cached state of this morph. This method may be called to pre-load the cached state of a morph to avoid delays when it is first used. (Cached state can always be recompued on demand, so a morph should not rely on this method being called.) Implementations of this method should do 'super loadCachedState'. This default implementation does nothing."! !!Morph methodsFor: 'other' stamp: 'di 11/14/97 10:24'!prepareToBeSaved	"Prepare this morph to be saved to disk. Subclasses should nil out any instance variables that holds state that should not be saved, such as cached Forms. Note that this operation may take more drastic measures than releaseCachedState; for example, it might discard the transcript of an interactive chat session."	self releaseCachedState.	fullBounds _ nil.! !!Morph methodsFor: 'other' stamp: 'jm 11/13/97 16:33'!releaseCachedState	"Release any state that can be recomputed on demand, such as the pixel values for a color gradient or the editor state for a TextMorph. This method may be called to save space when a morph becomes inaccessible. Implementations of this method should do 'super releaseCachedState'. This default implementation does nothing."! !!Morph methodsFor: 'other' stamp: 'tk 5/29/97'!storeDataOn: aDataStream	"Let all Morphs be written out.  DataStream.typeIDFor: catches the ones that are outside our tree (most notably, the root's owner).  For now let everthing try to write out.  "	| cntInstVars cntIndexedVars instVars ti got |	true ifTrue: [^ super storeDataOn: aDataStream].	"keep this code in case we need to filter fields later"	owner ifNil: [^ super storeDataOn: aDataStream].	got _ aDataStream references at: owner ifAbsent: [nil].	got ifNotNil: ["My owner has already started to go out.  I am not top"		^ super storeDataOn: aDataStream].	"block my owner"	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	instVars _ self class allInstVarNames.	ti _ (instVars indexOf: 'owner').	(ti = 0) ifTrue: [self error: 'this method is out of date'].	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: ti-1 do:		[:i | aDataStream nextPut: (self instVarAt: i)].	aDataStream nextPut: nil.	"owner"	ti+1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !!Morph methodsFor: 'private' stamp: 'tk 9/20/97 23:36'!copyRecordingIn: dict	"Recursively copy this entire composite morph, recording the correspondence between old and new morphs in the given dictionary. This dictionary will be used to update intra-composite references in the copy.  See updateReferencesUsing:	Rules:  All morphs being copied must be in the submorph&owner hierarchy of the first object being copied.  Any morph this is NOT in submorph&owner hierarchy, and is only held by an inst var or by an array, etc., MUST be copied by an override of this method for the class of the instance that holds onto it.  This is really hard to obey!!!!!!"	| new |	new _ self copy.	dict at: self put: new.	submorphs size > 0 ifTrue: [		new privateSubmorphs:			(submorphs collect: [:m |				(m copyRecordingIn: dict) privateOwner: new])].	new copyPropertiesFrom: self dict: dict.	^ new! !!Morph methodsFor: 'private'!copyWithoutSubmorphs	^ self clone		privateOwner: nil;		privateSubmorphs: EmptyArray;		privateBounds: (bounds origin corner: bounds corner)  "deep-copy bounds"! !!Morph methodsFor: 'private'!privateAddMorph: aMorph atIndex: index	((index >= 1) and: [index <= (submorphs size + 1)])		ifFalse: [^ self error: 'index out of range'].	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph layoutChanged.	aMorph privateOwner: self.	submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).	self layoutChanged.! !!Morph methodsFor: 'private'!privateBounds: boundsRect	"Private!! Use position: and/or extent: instead."	fullBounds _ nil.	bounds _ boundsRect.! !!Morph methodsFor: 'private' stamp: 'jm 7/8/97 08:32'!privateFullMoveBy: delta	"Private!! Relocate me and all of my subMorphs by recursion. Subclasses that implement different coordinate systems may override this method."	self privateMoveBy: delta.	1 to: submorphs size do: [:i |		(submorphs at: i) privateFullMoveBy: delta].! !!Morph methodsFor: 'private' stamp: 'jm 7/8/97 10:16'!privateMoveBy: delta	"Private!! Use 'position:' instead."	fullBounds == bounds ifTrue: [		"optimization: avoids recomputing fullBounds"		fullBounds _ bounds _ bounds translateBy: delta.	] ifFalse: [		bounds _ bounds translateBy: delta.		fullBounds _ nil].! !!Morph methodsFor: 'private'!privateOwner: aMorph	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	owner _ aMorph.! !!Morph methodsFor: 'private'!privateRemoveMorph: aMorph	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	aMorph changed.	submorphs _ submorphs copyWithout: aMorph.	self layoutChanged.! !!Morph methodsFor: 'private'!privateSubmorphs	"Private!! Use 'submorphs' instead."	^ submorphs! !!Morph methodsFor: 'private'!privateSubmorphs: aCollection	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	submorphs _ aCollection.! !!Morph methodsFor: 'naming' stamp: 'sw 8/4/97 12:05'!knownName	^ self valueOfProperty: #name! !!Morph methodsFor: 'naming' stamp: 'di 1/13/98 21:52'!renameTo: aName	self setNameTo: aName.! !!Morph methodsFor: 'naming' stamp: 'sw 8/10/97 01:38'!setNameTo: aName	self setProperty: #name toValue: aName! !!Morph methodsFor: 'naming' stamp: 'sw 9/21/97 14:13'!updateWorldAfterRenamingMe: aName	self setNameTo: aName! !!Morph methodsFor: 'locking' stamp: 'sw 8/5/97 20:08'!isLocked	^ (self valueOfProperty: #locked) == true! !!Morph methodsFor: 'locking' stamp: 'sw 8/4/97 12:05'!lock	self lock: true! !!Morph methodsFor: 'locking' stamp: 'sw 8/4/97 12:05'!lock: aBoolean	self setProperty: #locked toValue: aBoolean! !!Morph methodsFor: 'locking' stamp: 'sw 8/16/97 01:58'!unlock	self removeProperty: #locked! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/4/97 17:50'!addLabel: aString	^ self addLabel: aString outset: (6@10)! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/4/97 17:49'!addLabel: aString outset: aPoint	| m |	self removeAllMorphs.	m _ StringMorph new contents: aString.	self extent: (m width + aPoint x) @ (m height + aPoint y).	m position: self center - (m extent // 2).	self addMorph: m.! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 10/13/97 20:06'!addTransparentSpacerOfSize: aPoint	self addMorphBack: ((Morph new extent: aPoint) color: Color transparent)! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 10/18/97 18:03'!beRepelling	self setProperty: #repelling toValue: true! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 18:01'!beSticky		self setProperty: #sticky toValue: true! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/8/97 22:13'!buttonOffColor		| val |	^ (val _ self valueOfProperty: #buttonOffColor)		ifNotNil:			[val]		ifNil:			[Color r: 0.4 g: 0.2 b: 0.6]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/8/97 22:10'!buttonOffColor: aColor	self setProperty: #buttonOffColor toValue: aColor! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/8/97 22:13'!buttonOnColor		| val |	^ (val _ self valueOfProperty: #buttonOnColor)		ifNotNil:			[val]		ifNil:			[Color yellow]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/8/97 22:10'!buttonOnColor: aColor	self setProperty: #buttonOnColor toValue: aColor! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/10/97 01:11'!colorSettable	"Answer whether it is meaningful for the receiver to have its color set from outside.  Most Morphs say yes, but some, such as SketchMorph, say no"	^ true! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 10/1/97 00:18'!configureForKids	submorphs ifNotNil:		[submorphs do: [:m | m configureForKids]]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 11/1/97 00:03'!droppableOnPlayfield	^ false! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/20/97 23:19'!eachStepInOwnerChainDo: aBlock	"Perform aBlock for the receiver, its parent, etc., up the chain until nil reached"	aBlock value: self.	owner ifNotNil: [owner eachStepInOwnerChainDo: aBlock]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 11/1/97 14:51'!findDeepSubmorphThat: block1 ifAbsent: block2	^ self allMorphs detect: [:m | (block1 value: m) == true] ifNone: [block2 value]	! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/15/97 22:01'!findSubmorphThat: block1 ifAbsent: block2	^ submorphs detect: [:m | (block1 value: m) == true] ifNone: [block2 value]	! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 14:16'!isPartsBin	^ false! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/11/97 13:18'!isPartsDonor	^ self hasProperty: #partsDonor! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 18:03'!isSticky	self flag: #deferred.  "This generic implementation of stickiness may not find favor, in which case need to back out"	^ (self valueOfProperty: #sticky) == true! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 11/3/97 01:08'!justClonedFrom: aDonor	"A hook so that after the Duplicate command is issued by a user, the clone gets a chance to get things right." ! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/5/97 20:08'!markAsPartsDonor	"Mark the receiver specially so that mouse actions on it are interpreted as 'tearing off a copy'"	self setProperty: #partsDonor toValue: true! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 11/3/97 01:57'!name: aName	(aName isKindOf: String) ifTrue:		[self setNameTo: aName]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 17:52'!nextPageButton	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aButton; actionSelector: #nextOwnerPage; label: '->'; color: Color yellow.	aButton setNameTo: 'next'.	^ aButton! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 17:59'!positionAtBottomLeft	"Position the receiver at the bottom left of its owner.  Was handy recently though temporarily not in use"	self position: owner bounds bottomLeft - (0 @ self extent y)! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 17:59'!positionAtBottomRight	"Position the receiver at the bottom right of its owner.  Was handy recently though temporarily not in use"	self position: owner bounds bottomRight - self extent! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 17:59'!previousPageButton	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aButton; actionSelector: #previousOwnerPage; label: '<-'.	aButton setNameTo: 'previous'.	^ aButton! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/5/97 21:12'!primaryHand	| aWorld |	(aWorld _ self world) ifNil: [^ nil].	^ aWorld hands first ! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/20/97 21:16'!removeEmptyLayoutMorphs	submorphs copy do: [:m |		m isLayoutMorph			ifTrue:				[m submorphCount = 0					ifTrue:						[m delete]					ifFalse:						[m removeEmptyLayoutMorphs]]].	self fullBounds.	self layoutChanged! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 10/18/97 18:03'!repelsMorph: aMorph event: ev	^ self hasProperty: #repelling! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 10/18/97 18:20'!rootForGrabOf: aMorph	"Be sticky if sticky property is set.  Normally this would be recompiled in the unique subclass of each morph, so this is a backstop only, and for development."	^ self isSticky		ifTrue:			[nil]		ifFalse:			[(owner = nil or: [owner isWorldOrHandMorph])				ifTrue:					[self]				ifFalse:					[owner allowSubmorphExtraction						ifTrue: [self]						ifFalse: [owner rootForGrabOf: aMorph]]]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 10/18/97 18:03'!screenLocation	"If the receiver is currently in an mvc window, return its screen origin"	| aWorld aBox |	(aWorld _ self world) ifNil: [^ nil].	(aBox _ aWorld viewBox) ifNil: [^ nil].	^ self fullBounds origin + aBox origin! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/17/97 18:43'!screenRectangle	"If the receiver is currently in an mvc window, return its screen rectangle"	| aWorld aBox |	(aWorld _ self world) ifNil: [^ nil].	(aBox _ aWorld viewBox) ifNil: [^ nil].	^ (self fullBounds origin + aBox origin) extent: self extent! !!Morph methodsFor: 'aug97 additions' stamp: 'jm 10/22/97 07:45'!slideBackToFormerSituation: evt	| aForm formerOwner formerPosition aWorld origin startPoint endPoint |	aForm _ self imageForm offset: 0@0.	formerOwner _ evt hand oldOwner.	formerPosition _ evt hand oldPosition.	aWorld _ self world.	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	endPoint _ formerPosition + origin.	self delete.	aWorld displayWorld.	aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.	formerOwner addMorph: self.	self position: formerPosition.	self justDroppedInto: formerOwner event: evt.! !!Morph methodsFor: 'aug97 additions' stamp: 'jm 10/22/97 07:46'!slideToTrash: evt	| aForm aWorld trash origin startPoint endPoint |	aForm _ self imageForm offset: 0@0.	aWorld _ self world.	trash _ aWorld findA: TrashCanMorph.	trash ifNil: [^ self].	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	endPoint _ trash position + origin.	self delete.	aWorld displayWorld.	aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.	trash acceptDroppingMorph: self event: evt.! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/15/97 22:03'!submorphsSatisfying: aBlock	^ submorphs select: [:m | (aBlock value: m) == true]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 11/1/97 14:37'!suggestedNames	^ self isInWorld		ifTrue:			[self world suggestedNamesFor: self]		ifFalse:			[Array with: self innocuousName with: self innocuousName capitalized]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 10/13/97 23:32'!typedCommands	"Return a list of typed-command arrays of the form:		<result type> <command> <argType>"	^	#(	(command	beep:		sound)			(command	forward: 	number)			(command 	hide)			(command 	show))! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/15/97 23:59'!unlockContents	self submorphsDo:		[:m | m unlock]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/16/97 17:16'!unlockOneSubpart	| unlockables aMenu reply |	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size <= 1 ifTrue: [^ self unlockContents].	aMenu _ SelectionMenu labelList: (unlockables collect: [:m | m externalName]) selections: unlockables.	reply _ aMenu startUpWithCaption: 'Who should be be unlocked?'.	reply == nil ifTrue: [^ self].	reply unlock! !!Morph methodsFor: 'aug97 additions' stamp: 'jm 10/22/97 07:46'!vanishAfterSlidingTo: aPosition event: evt	| aForm aWorld origin startPoint endPoint |	aForm _ self imageForm offset: 0@0.	aWorld _ self world.	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	self delete.	aWorld displayWorld.	endPoint _ aPosition + origin.	aForm slideFrom: startPoint  to: endPoint nSteps: 12 delay: 15.	aWorld soundsEnabled ifTrue: [TrashCanMorph someInstance playDeleteSound].! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 11/3/97 02:11'!wantsKeyboardFocusFor: aSubmorph	"Answer whether a plain mouse click on aSubmorph, a text-edit-capable thing, should result in a text selection there"	^ false! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/20/97 23:20'!withAllContainers	| aList |	aList _ OrderedCollection new.	self eachStepInOwnerChainDo:		[:m | aList add: m].	^ aList asArray! !!Morph methodsFor: 'properties' stamp: 'sw 8/4/97 12:05'!assuredPropertyDictionary	"Return the receiver's property dictionary, creating it if necessary.  Properties are accessed only by symbol, so an IdentityDictionary is used for speed"	properties ifNil: [properties _ IdentityDictionary new].	^ properties! !!Morph methodsFor: 'properties' stamp: 'sw 10/2/97 19:02'!balloonText	"NB: subclasses may override such that they programatically construct the text, for economy's sake, such as model phrases in a Viewer"	^ self valueOfProperty: #balloonText! !!Morph methodsFor: 'properties' stamp: 'tk 8/21/97 15:46'!copyPropertiesFrom: donorMorph dict: dict	properties _ donorMorph properties copy.	properties ifNotNil: [		properties associationsDo: [:ass |			ass value isMorph ifTrue: [				ass value owner ifNil: [ass value: (assvalue copyRecordingIn: dict)]]]].					"note side effecting.  Any un-ownedmorph belongs to us."! !!Morph methodsFor: 'properties' stamp: 'sw 8/4/97 12:05'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	| prop |	^ properties ~~ nil and:		[((prop _ properties at: propName ifAbsent: [nil]) ~~ false) and:			[prop ~~ nil]]! !!Morph methodsFor: 'properties' stamp: 'sw 10/2/97 23:08'!initialExtent	| ext |	(ext _ self valueOfProperty: #initialExtent)		ifNotNil:			[^ ext].	^ super initialExtent! !!Morph methodsFor: 'properties' stamp: 'sw 8/4/97 12:05'!properties	^ properties! !!Morph methodsFor: 'properties' stamp: 'sw 8/4/97 12:05'!removeProperty: propName	properties ifNil: [^ self].	properties removeKey: propName ifAbsent: [].	properties size == 0 ifTrue: [properties _ nil]! !!Morph methodsFor: 'properties' stamp: 'sw 8/4/97 12:05'!setProperty: propName toValue: aValue	self assuredPropertyDictionary at: propName put: aValue! !!Morph methodsFor: 'properties' stamp: 'sw 8/4/97 12:05'!valueOfProperty: propName	properties ifNil: [^ nil].	^ properties at: propName ifAbsent: [nil]! !!Morph methodsFor: 'object fileIn' stamp: 'tk 8/16/97 17:54'!convertbosfce0: varDict bosfcep0: smartRefStrm	"These variables are automatically stored into the new instance('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'eventHandler' ).	This method is for additional changes. Use statements like (foo _varDict at: 'foo')."	"Be sure to to fill in ('properties' ) and deal with theinformation in ()"	"OK if properties is nil"! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 9/18/97 14:01'!addOptionalHandlesTo: aHalo box: box	! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 9/20/97 15:20'!deleteBalloon	"If I am showing one, remove it."	| balloon |	(balloon _ self valueOfProperty: #balloon) ifNil: [^ self].  "No balloon to delete"	balloon owner ifNil: [^ self].  "Already deleted"	balloon delete.	self setProperty: #balloon toValue: nil.	self world ifNotNil: [self world displayWorld]  "It happens  that it can be nil-- such as on at 9/20/97 15:20"! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 9/30/97 09:54'!editBalloonHelpContent: aString	Cursor normal show.	FillInTheBlank		message: ('Edit the balloon help text for ', self externalName) 		displayAt: Sensor cursorPoint 		centered: true		action: [:reply |  (reply size > 0 and: [reply asString ~= self noHelpString]) ifTrue:		[self setBalloonText: reply]] 		initialAnswer: aString		answerHeight: 200		windowTitle: 'Hit ENTER when done'.	Cursor blank show! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 11/3/97 13:27'!editBalloonHelpText	| str  |	str _ self valueOfProperty: #balloonText.	str ifNil: [str _ self noHelpString].	self editBalloonHelpContent: str! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 9/19/97 13:55'!mouseDownOnHelpHandle: anEvent	"The mouse went down in the show-balloon handle"		| str balloon |	str _ self valueOfProperty: #balloonText.	str ifNil: [str _ self noHelpString].	anEvent controlKeyPressed ifTrue:		[^ self editBalloonHelpContent: str].	"Put up the actual balloon"	balloon _ BalloonMorph string: str for: self corner: #topRight.	"corner is a suggestion"	self world addMorphFront: balloon.	self setProperty: #balloon toValue: balloon! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 9/19/97 13:46'!noHelpString	^ 'Help not yet supplied'! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 9/17/97 15:08'!setBalloonText: stringOrText	self setProperty: #balloonText toValue: stringOrText! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 10/2/97 14:21'!showBalloon	"If this Morph has balloon text, create a balloon and add it."	| str balloon |	(str _ self balloonText) ifNil: [^ self].	balloon _ BalloonMorph string: str for: self corner: #topRight.	"corner is a suggestion"	self world addMorphFront: balloon.	self setProperty: #balloon toValue: balloon! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 9/20/97 23:42'!wantsBalloon	^ self hasProperty: #balloonText! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 1/13/98 21:59'!wantsHalo	^ false! !!Morph class methodsFor: 'instance creation' stamp: 'sw 8/11/97 13:17'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		^ self new markAsPartsDonor! !!Morph class methodsFor: 'instance creation' stamp: 'di 6/22/97 09:07'!includeInNewMorphMenu	"Return true for all classes that can be instantiated from the menu"	^ true! !!Morph class methodsFor: 'instance creation'!new	^ super new initialize! !!Morph class methodsFor: 'instance creation'!newBounds: bounds	^ self new privateBounds: bounds! !!Morph class methodsFor: 'instance creation'!newBounds: bounds color: color	^ (self new privateBounds: bounds) color: color! !!Morph class methodsFor: 'instance creation' stamp: 'sw 8/4/97 12:05'!newSticky	^ self new beSticky! !!Morph class methodsFor: 'instance creation' stamp: 'sw 8/4/97 18:26'!newWithExtent: extent	^ self new privateBounds: (0@0 extent: extent)! !!Morph class methodsFor: 'class initialization'!initialize	"Morph initialize"	"this empty array object is shared by all morphs with no submorphs:"	EmptyArray _ Array new.! !!MorphicEvent methodsFor: 'initialization'!initialize	type _ #unknown.	cursorPoint _ 0@0.	buttons _ 0.	keyValue _ 0.	sourceHand _ nil.! !!MorphicEvent methodsFor: 'accessing'!buttons	"Return the a word encoding the mouse and modifier buttons for this event."	^ buttons! !!MorphicEvent methodsFor: 'accessing'!hand	"Return the hand that originated this event."	^ sourceHand! !!MorphicEvent methodsFor: 'accessing'!type	"Return a symbol indicating the type this event."	^ type! !!MorphicEvent methodsFor: 'classification'!isKeystroke	^ type == #keystroke! !!MorphicEvent methodsFor: 'classification'!isMouse	^ (type == #mouseMove) | (type == #mouseDown) | (type == #mouseUp)! !!MorphicEvent methodsFor: 'classification'!isMouseDown	^ type == #mouseDown! !!MorphicEvent methodsFor: 'classification'!isMouseMove	^ type == #mouseMove! !!MorphicEvent methodsFor: 'classification'!isMouseUp	^ type == #mouseUp! !!MorphicEvent methodsFor: 'equality' stamp: 'jm 11/4/97 07:15'!= aMorphicEvent	(aMorphicEvent isKindOf: self class) ifFalse: [^ false].	type = aMorphicEvent type ifFalse: [^ false].	cursorPoint = aMorphicEvent cursorPoint ifFalse: [^ false].	buttons = aMorphicEvent buttons ifFalse: [^ false].	keyValue = aMorphicEvent keyValue ifFalse: [^ false].	^ true! !!MorphicEvent methodsFor: 'equality' stamp: 'jm 11/4/97 07:15'!hash	^ cursorPoint hash + buttons hash + keyValue hash! !!MorphicEvent methodsFor: 'mouse'!anyButtonPressed	"Answer true if any mouse button is being pressed."	^ buttons anyMask: 7! !!MorphicEvent methodsFor: 'mouse'!blueButtonPressed	"Answer true if the blue mouse button is being pressed."	^ buttons anyMask: 1! !!MorphicEvent methodsFor: 'mouse'!cursorPoint	"Answer the location of the cursor's hotspot when this event occured."	^ cursorPoint! !!MorphicEvent methodsFor: 'mouse'!redButtonPressed	"Answer true if the red mouse button is being pressed."	^ buttons anyMask: 4! !!MorphicEvent methodsFor: 'mouse'!targetPoint	"Answer the location of the cursor's hotspot, adjusted by the offset	of the last mouseDown relative to the recipient morph."	^ cursorPoint - sourceHand targetOffset! !!MorphicEvent methodsFor: 'mouse'!transformedBy: aMorphicTransform	"Return a copy of the receiver transformed by the given transformation."	aMorphicTransform isIdentity ifTrue: [^ self].  "no transformation needed"	^ self copy setCursorPoint: (aMorphicTransform transform: cursorPoint)! !!MorphicEvent methodsFor: 'mouse'!yellowButtonPressed	"Answer true if the yellow mouse button is being pressed."	^ buttons anyMask: 2! !!MorphicEvent methodsFor: 'keyboard'!commandKeyPressed	"Answer true if the command key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 64! !!MorphicEvent methodsFor: 'keyboard'!controlKeyPressed	"Answer true if the control key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 16! !!MorphicEvent methodsFor: 'keyboard'!keyCharacter	"Answer the character corresponding this keystroke. This is defined only for keystroke events."	^ keyValue asCharacter! !!MorphicEvent methodsFor: 'keyboard'!keyValue	"Answer the ascii value for this keystroke. This is defined only for keystroke events."	^ keyValue! !!MorphicEvent methodsFor: 'keyboard'!optionKeyPressed	"Answer whether the option key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 32! !!MorphicEvent methodsFor: 'keyboard'!shiftPressed	"Answer true if either the left or right shift key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 8! !!MorphicEvent methodsFor: 'printing'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self cursorPoint printString; space.	aStream nextPutAll: type.	self isKeystroke ifTrue: [		self controlKeyPressed ifTrue: [			aStream nextPutAll: ' ''^'.			aStream nextPut: (keyValue + $a asciiValue - 1) asCharacter.		] ifFalse: [			aStream nextPutAll: ' '''.			aStream nextPut: self keyCharacter.		].		aStream nextPut: $'.	].	aStream nextPut: $].! !!MorphicEvent methodsFor: 'printing' stamp: 'jm 11/4/97 07:15'!storeOn: aStream	aStream nextPutAll: type.	aStream space.	cursorPoint x storeOn: aStream.	aStream space.	cursorPoint y storeOn: aStream.	aStream space.	buttons storeOn: aStream.	aStream space.	keyValue storeOn: aStream.! !!MorphicEvent methodsFor: 'private'!setCursorPoint: aPoint	"Used for transforming events."	cursorPoint _ aPoint.! !!MorphicEvent methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!setHand: aHandMorph	"Set the hand that originated this event."	sourceHand _ aHandMorph.! !!MorphicEvent methodsFor: 'private'!setKeyValue: keyVal mousePoint: aPoint buttons: anInteger hand: hand	type _ #keystroke.	cursorPoint _ aPoint.	buttons _ anInteger.	keyValue _ keyVal.	sourceHand _ hand.! !!MorphicEvent methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!setMousePoint: aPoint buttons: anInteger lastEvent: lastEvent hand: hand	cursorPoint _ aPoint.	buttons _ anInteger.	keyValue _ 0.	sourceHand _ hand.	self anyButtonPressed ifTrue: [		lastEvent anyButtonPressed			ifTrue: [type _ #mouseMove]			ifFalse: [type _ #mouseDown].	] ifFalse: [		lastEvent anyButtonPressed			ifTrue: [type _ #mouseUp]			ifFalse: [type _ #mouseMove]].! !!MorphicEvent methodsFor: 'private'!setType: newType	type _ newType.! !!MorphicEvent methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!setType: t cursorPoint: p buttons: b keyValue: k	type _ t.	cursorPoint _ p.	buttons _ b.	keyValue _ k.	sourceHand _ nil.! !!MorphicEvent class methodsFor: 'instance creation'!new	^ super new initialize! !!MorphicEvent class methodsFor: 'instance creation' stamp: 'jm 11/4/97 07:15'!newWorldExtent: aPoint	"Answer an event that records a WorldMorph window size change."	^ self basicNew setType: #worldExtent		cursorPoint: aPoint		buttons: 0		keyValue: 0! !!MorphicEvent class methodsFor: 'instance creation' stamp: 'jm 11/4/97 07:15'!readFrom: aStream	"Read a MorphicEvent from the given stream."	| s type x y buttons keyValue |	s _ WriteStream on: ''.	[aStream peek isLetter] whileTrue: [s nextPut: aStream next].	type _ s contents asSymbol.	aStream skip: 1.	x _ Integer readFrom: aStream.	aStream skip: 1.	y _ Integer readFrom: aStream.	aStream skip: 1.	buttons _ Integer readFrom: aStream.	aStream skip: 1.	keyValue _ Integer readFrom: aStream.	^ self basicNew setType: type		cursorPoint: x@y		buttons: buttons		keyValue: keyValue! !MorphicModel comment:'MorphicModels are used to represent structures with state and behavior as well as graphical structure.  A morphicModel is usually the root of a morphic tree depicting its appearance.  The tree is constructed concretely by adding its consituent morphs to a world.When a part is named in a world, it is given a new slot in the model.  When a part is sensitized, it is named, and a set of mouse-driven methods is also generated in the model.  These may be edited to induce particular behavior.  When a variable is added through the morphic world, it is given a slot in the model, along with a set of access methods.In addition for public variables (and this is the default for now), methods are generated and called in any outer model in which this model gets embedded, thus propagating variable changes outward.'!!MorphicModel methodsFor: 'initialization'!delete	model ifNil: [^ super delete].	(PopUpMenu confirm:'Shall I remove the slot ', slotName, 'along with all associated methods?') ifTrue: [		(model class selectors select: [:s | s beginsWith: slotName])			do: [:s | model class removeSelector: s].		(model class instVarNames includes: slotName)			ifTrue: [model class removeInstVarName: slotName].	] ifFalse: [		(PopUpMenu confirm:'...but should I at least dismiss this morph?[choose no to leave everything unchanged]')			ifFalse: [^ self]].	super delete.! !!MorphicModel methodsFor: 'initialization' stamp: 'tk 4/15/97'!duplicate: newGuy from: oldGuy	"oldGuy has just been duplicated and will stay in this world.  Make sure all the MorphicModel requirements are carried out for the copy.  Ask user to rename it.  "	newGuy installModelIn: oldGuy world.	newGuy copySlotMethodsFrom: oldGuy slotName.! !!MorphicModel methodsFor: 'initialization' stamp: 'di 7/17/97 10:32'!initialize	super initialize.	open _ false.	bounds _ 0@0 corner: 200@100.	self color: Color transparent;		setBorderWidth: 2 borderColor: Color yellow! !!MorphicModel methodsFor: 'initialization' stamp: 'di 6/21/97 13:25'!model: thang slotName: nameOfThisPart	model _ thang.	slotName _ nameOfThisPart.	open _ false.! !!MorphicModel methodsFor: 'access'!model 	^ model! !!MorphicModel methodsFor: 'access'!slotName	^ slotName! !!MorphicModel methodsFor: 'access' stamp: '6/7/97 10:40 di'!wantsSlot	"Override this default for models that want to be installed in theri model"	^ false! !!MorphicModel methodsFor: 'geometry'!newBounds: newBounds	self bounds: newBounds! !!MorphicModel methodsFor: 'geometry'!recomputeBounds	| bnds |	bnds _ submorphs first bounds.	bounds _ bnds origin corner: bnds corner. "copy it!!"	fullBounds _ nil.	bounds _ self fullBounds.! !!MorphicModel methodsFor: 'printing'!initString	^ String streamContents:		[:s | s nextPutAll: self class name;			nextPutAll: ' newBounds: (';			print: bounds;			nextPutAll: ') model: self slotName: ';			print: slotName]! !!MorphicModel methodsFor: 'compilation'!addPartNameLike: className withValue: aMorph	| otherNames i default partName stem |	stem _ className first asLowercase asString , className allButFirst.	otherNames _ self class allInstVarNames.	i _ 1.	[otherNames includes: (default _ stem, i printString)]		whileTrue: [i _ i + 1].	partName _ FillInTheBlank		request: 'Please give this part a name'		initialAnswer: default.	(otherNames includes: partName)		ifTrue: [self inform: 'Sorry, that name is already used'. ^ nil].	self class addInstVarName: partName.	self instVarAt: self class instSize put: aMorph.  "Assumes added as last field"	^ partName! !!MorphicModel methodsFor: 'compilation' stamp: 'tk 4/15/97'!choosePartName	"When I am renamed, get a slot, make default methods, move any existing methods.  ** Does not clean up old inst var name or methods**  "	| old |	old _ slotName.	super choosePartName.	slotName ifNil: [^ self].  "user chose bad slot name"	self model: self world model slotName: slotName.	old == nil 		ifTrue: [self compilePropagationMethods]		ifFalse: [self copySlotMethodsFrom: old].			"old ones not erased!!"! !!MorphicModel methodsFor: 'compilation' stamp: 'tk 4/18/97'!compileAccessForSlot: aSlotName	"Write the method to get at this inst var.  "	"Instead call the right thing to make this happen?"	| s  |	s _ WriteStream on: (String new: 2000).	s nextPutAll: aSlotName; cr; tab; nextPutAll: '^', aSlotName.	self class		compile: s contents		classified: 'public access'		notifying: nil.! !!MorphicModel methodsFor: 'compilation'!compileInitMethods	| s nodeDict varNames |	nodeDict _ IdentityDictionary new.	s _ WriteStream on: (String new: 2000).	varNames _ self class allInstVarNames.	s nextPutAll: 'initMorph'.	3 to: self class instSize do:		[:i | (self instVarAt: i) isMorph ifTrue:			[s cr; tab; nextPutAll: (varNames at: i) , ' _ '.			s nextPutAll: (self instVarAt: i) initString; nextPutAll: '.'.			nodeDict at: (self instVarAt: i) put: (varNames at: i)]].	submorphs do: 		[:m | s cr; tab; nextPutAll: 'self addMorph: '.		m printConstructorOn: s indent: 1 nodeDict: nodeDict.		s nextPutAll: '.'].	self class		compile: s contents		classified: 'initialization'		notifying: nil.! !!MorphicModel methodsFor: 'compilation'!compilePropagationMethods	| varName |	(self class organization listAtCategoryNamed: 'private - propagation' asSymbol)		do: [:sel | varName _ sel allButLast.			model class compilePropagationForVarName: varName slotName: slotName]! !!MorphicModel methodsFor: 'compilation' stamp: '6/7/97 10:43 di'!installModelIn: aWorld	self wantsSlot ifFalse: [^ self].  "No real need to install"	slotName _ aWorld model addPartNameLike: self class name withValue: self.	slotName ifNil: [^ self].  "user chose bad slot name"	self model: aWorld model slotName: slotName.	self compilePropagationMethods.	aWorld model compileAccessForSlot: slotName.! !!MorphicModel methodsFor: 'compilation' stamp: 'sw 11/1/97 00:41'!instanceVariableValues	"MorphicModel76 someInstance instanceVariableValues"	| c |	c _ OrderedCollection new.	self class superclass instSize + 1 to: self class instSize do:		[:i | c add: (self instVarAt: i)].	^ c! !!MorphicModel methodsFor: 'compilation'!nameFor: aMorph	"Return the name of the slot containing the given morph or nil if that morph has not been named."	| allNames start |	allNames _ self class allInstVarNames.	start _ MorphicModel allInstVarNames size + 1.	start to: allNames size do: [:i |		(self instVarAt: i) == aMorph ifTrue: [^ allNames at: i]].	^ nil! !!MorphicModel methodsFor: 'compilation'!namePartSilently: aMorph	| stem otherNames i partName |	stem _ aMorph class name.	(stem size > 5 and: [stem endsWith: 'Morph'])		ifTrue: [stem _ stem copyFrom: 1 to: stem size - 5].	stem _ stem first asLowercase asString, stem allButFirst.	otherNames _ self class allInstVarNames.	i _ 1.	[otherNames includes: (partName _ stem, i printString)]		whileTrue: [i _ i + 1].	self class addInstVarName: partName.	self instVarAt: self class instSize put: aMorph.  "assumes added as last field"	^ partName! !!MorphicModel methodsFor: 'compilation'!propagate: value as: partStoreSelector	model ifNil: [^ self]."	Later we can cache this for more speed as follows...	(partName == cachedPartName and: [slotName == cachedSlotName])		ifFalse: [cachedPartName _ partName.				cachedSlotName _ slotName.				cachedStoreSelector _ (slotName , partStoreSelector) asSymbol].	model perform: cachedStoreSelector with: value]."	model perform: (self slotSelectorFor: partStoreSelector) with: value! !!MorphicModel methodsFor: 'compilation' stamp: 'tk 10/31/97 12:33'!removeAll	"Clear out all script methods and subpart instance variables in me.  Start over."	"self removeAll"	"MorphicModel2 removeAll"self class == MorphicModel ifTrue: [^ self].	"Must be a subclass!!"self class removeCategory: 'scripts'.self class instVarNames do: [:nn | self class removeInstVarName: nn].! !!MorphicModel methodsFor: 'compilation'!slotSelectorFor: selectorBody	| selector |	model ifNil: [^ nil].	"Make up selector from slotname if any"	selector _ (slotName ifNil: [selectorBody]					ifNotNil: [slotName , selectorBody]) asSymbol.	(model canUnderstand: selector) ifFalse:		[self halt: 'Compiling a null response for ' , model class name , '>>' , selector].	^ selector! !!MorphicModel methodsFor: 'compilation'!use: cachedSelector orMakeModelSelectorFor: selectorBody in: selectorBlock	| selector |	model ifNil: [^ nil].	cachedSelector ifNil:			["Make up selector from slotname if any"			selector _ (slotName ifNil: [selectorBody]								ifNotNil: [slotName , selectorBody]) asSymbol.			(model class canUnderstand: selector) ifFalse:				[(self confirm: 'Shall I compile a null response for'							, Character cr asString							, model class name , '>>' , selector)						ifFalse: [self halt].				model class compile: (String streamContents:								[:s | selector keywords doWithIndex:										[:k :i | s nextPutAll: k , ' arg' , i printString].								s cr; nextPutAll: '"Automatically generated null response."'.								s cr; nextPutAll: '"Add code below for appropriate behavior..."'.])							classified: 'input events'							notifying: nil]]		ifNotNil:			[selector _ cachedSelector].	^ selectorBlock value: selector! !!MorphicModel methodsFor: 'drag and drop' stamp: 'di 6/22/97 23:17'!allowSubmorphExtraction	^ self isOpen! !!MorphicModel methodsFor: 'drag and drop' stamp: 'di 6/22/97 23:16'!isOpen	"Support drag/drop and other edits."	^ open! !!MorphicModel methodsFor: 'drag and drop' stamp: 'di 6/22/97 23:17'!openToDragNDrop	"Support drag/drop when open to edits."	^ self isOpen! !!MorphicModel methodsFor: 'drag and drop' stamp: 'di 6/22/97 23:17'!wantsDroppedMorph: aMorph event: evt	"Supports adding morphs by dropping."	^ self isOpen! !!MorphicModel methodsFor: 'menu' stamp: 'di 6/20/97 15:39'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self isOpen ifTrue: [aCustomMenu add: 'close editing' action: #closeToEdits]			ifFalse: [aCustomMenu add: 'open editing' action: #openToEdits].! !!MorphicModel methodsFor: 'menu' stamp: 'di 6/20/97 15:36'!closeToEdits	"Disable this morph's ability to add and remove morphs via drag-n-drop."	open _ false! !!MorphicModel methodsFor: 'menu' stamp: 'di 6/20/97 15:36'!openToEdits	"Enable this morph's ability to add and remove morphs via drag-n-drop."	open _ true! !!MorphicModel methodsFor: 'run time' stamp: 'tk 11/4/97 07:45'!beNotZero: aNumber	"This is a runtime check if the arg to divide in a script is zero.  If it is, put up a message from M. Mouse.  Return 0.001 instead of 0.  Note the time.  If fails again within 1 min., don't tell the user again."	aNumber = 0 ifFalse: [^ aNumber].	"normal case"	"We have a problem"	TimeOfError 		ifNil: [TimeOfError _ Time totalSeconds]		ifNotNil: [(Time totalSeconds - TimeOfError) > 45 ifTrue: [			TimeOfError _ Time totalSeconds.	"in case user interrupt and reenter"			PopUpMenu inform: 'Dividing by zero makes a number too large for even a Sorcerer to handle.  Please change your script.  					-- M. Mouse'.			TimeOfError _ Time totalSeconds]].	^ 0.001! !!MorphicModel class methodsFor: 'instance creation' stamp: 'di 6/22/97 22:28'!includeInNewMorphMenu	"Dont include until it has at least been given a name"	^ self == MorphicModel or: [(self name beginsWith: 'MorphicModel') not]! !!MorphicModel class methodsFor: 'instance creation' stamp: 'di 6/22/97 09:26'!new	"Return a copy of the prototype, if there is one.	Otherwise create a new instance normally."	self hasPrototype ifTrue: [^ prototype fullCopy].	^ super new! !!MorphicModel class methodsFor: 'instance creation' stamp: 'di 6/22/97 09:27'!newBounds: bounds model: thang slotName: nameOfThisPart	^ (super new model: thang slotName: nameOfThisPart)		newBounds: bounds! !!MorphicModel class methodsFor: 'compilation' stamp: 'sw 8/20/97 15:01'!acceptsLoggingOfCompilation	"Dont log sources for my automatically-generated subclasses.  Can easily switch this back when it comes to deal with Versions, etc."	self flag: #deferred.	^ self == MorphicModel or:		[(self class name beginsWith: 'Morphic') not]! !!MorphicModel class methodsFor: 'compilation'!chooseNewName	"Rename this class."	| oldName newName |	oldName _ self name.		[newName _ (FillInTheBlank request: 'Please give this Model a name'					initialAnswer: oldName) asSymbol.		newName = oldName ifTrue: [^ self].		Smalltalk includesKey: newName]		whileTrue:		[PopUpMenu notify: 'Sorry, that name is already in use.'].	self rename: newName.! !!MorphicModel class methodsFor: 'compilation'!compileAccessorsFor: varName	self compile: ('&var	"Return the value of &var"	^ &var'			copyReplaceAll: '&var' with: varName)		classified: 'public access' notifying: nil.	self compile: ('&varPut: newValue	"Assign newValue to &var.	Add code below to update related graphics appropriately..."	&var _ newValue.'			copyReplaceAll: '&var' with: varName)		classified: 'public access' notifying: nil.	self compile: ('&var: newValue	"Assigns newValue to &var and updates owner"	&var _ newValue.	self propagate: &var as: ''&var:'''			copyReplaceAll: '&var' with: varName)		classified: 'private - propagation' notifying: nil.! !!MorphicModel class methodsFor: 'compilation'!compilePropagationForVarName: varName slotName: slotName	self compile: (('&slot&var: newValue	"The value of &var in &slot has changed to newValue.	This value can be read elsewhere in code with		&slot &var	and it can be stored into with		&slot &varPut: someValue"	"Add code for appropriate response here..."'			copyReplaceAll: '&var' with: varName)			copyReplaceAll: '&slot' with: slotName)		classified: 'input events' notifying: nil.! !!MorphicModel class methodsFor: 'compilation'!newSubclass	| i className |	i _ 1.	[className _ (self name , i printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [i _ i + 1].	^ self subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Morphic-Models'! !!MorphicModel class methodsFor: 'compilation' stamp: 'sw 8/4/97 17:16'!wantsChangeSetLogging	"Log changes for MorphicModel itself and for things like PlayWithMe2, but not for automatically-created subclasses like MorphicModel1, MorphicModel2, etc."	^ self == MorphicModel or:		[(self class name beginsWith: 'Morphic') not]! !!MorphicModel class methodsFor: 'queries'!hasPrototype	"Return true if there is a prototype for this morph."	^ prototype ~~ nil! !!MorphicModel class methodsFor: 'prototype access'!prototype	"Return the prototype for this morph."	^ prototype! !!MorphicModel class methodsFor: 'prototype access'!prototype: aMorph	"Store a copy of the given morph as a prototype to be copied to make new instances."	aMorph ifNil: [prototype _ nil. ^ self].	prototype _ aMorph fullCopy.	(prototype isKindOf: MorphicModel) ifTrue: 		[prototype model: nil slotName: nil].! !!MorphicModel class methodsFor: 'housekeeping' stamp: 'jm 7/30/97 16:40'!removeUninstantiatedModels	"With the user's permission, remove the classes of any models that have neither instances nor subclasses."	"MorphicModel removeUninstantiatedModels"	| candidatesForRemoval ok |	Smalltalk garbageCollect.	candidatesForRemoval _		MorphicModel subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval do: [:c |		ok _ self confirm: 'Are you certain that youwant to delete the class ', c name, '?'.		ok ifTrue: [c removeFromSystem]].! !!MorphicModel class methodsFor: 'housekeeping' stamp: 'tk 11/25/97 16:25'!removeUninstantiatedModelsSilently	"Remove the classes of any models that have neither instances nor subclasses.  Answer the number of bytes reclaimed"	"MorphicModel removeUninstantiatedModelsSilently"	| candidatesForRemoval  oldFree |	oldFree _ Smalltalk garbageCollect.	candidatesForRemoval _		MorphicModel subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval do: [:c | c removeFromSystem].	^ Smalltalk garbageCollect - oldFree! !MorphicTransform comment:'This class implements a simple translation scaling and rotation for points, as well as inverse transformations.'!!MorphicTransform methodsFor: 'accessing'!angle	^ angle! !!MorphicTransform methodsFor: 'accessing'!offset	^ offset! !!MorphicTransform methodsFor: 'accessing'!scale	^ scale! !!MorphicTransform methodsFor: 'accessing'!withAngle: a	"Return a copy of me with a different Angle"	^ self copy setAngle: a! !!MorphicTransform methodsFor: 'accessing'!withOffset: a	"Return a copy of me with a different Offset"	^ self copy setOffset: a! !!MorphicTransform methodsFor: 'accessing'!withScale: a	"Return a copy of me with a different Scale"	^ self copy setScale: a! !!MorphicTransform methodsFor: 'transformations'!composedWith: aTransform	"Return a new transform that has the effect of transforming points first by the receiver and then by the argument."	self isPureTranslation ifTrue:		[^ aTransform copy setOffset: offset + aTransform offset].	aTransform isPureTranslation ifTrue:		[^ self copy setOffset: offset + aTransform offset].self halt: 'general composition not yet implemented'! !!MorphicTransform methodsFor: 'transformations'!invert: aPoint	"Transform the given point from local to global coordinates."	| p3 p2 |	self isPureTranslation ifTrue: [^ aPoint - offset].	p3 _  aPoint * scale.	p2 _ ((p3 x * angle cos) + (p3 y * angle sin))		@ ((p3 y * angle cos) - (p3 x * angle sin)).	^ (p2 - offset) asIntegerPoint! !!MorphicTransform methodsFor: 'transformations'!invertRect: aRectangle	^ (self invert: aRectangle topLeft) corner: (self invert: aRectangle bottomRight)! !!MorphicTransform methodsFor: 'transformations'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	^ self isPureTranslation and: [offset = (0@0)]! !!MorphicTransform methodsFor: 'transformations'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	^ angle = 0.0 and: [scale = 1.0]! !!MorphicTransform methodsFor: 'transformations'!sourceQuadFor: aRectangle	^ aRectangle innerCorners collect: 		[:p | self transform: p]! !!MorphicTransform methodsFor: 'transformations'!transform: aPoint	"Transform the given point from global to local coordinates."	| p2 p3 |	self isPureTranslation ifTrue: [^ aPoint + offset].	p2 _ aPoint + offset.	p3 _ (((p2 x * angle cos) - (p2 y * angle sin))		@ ((p2 y * angle cos) + (p2 x * angle sin)))			/ scale.	^ p3 asIntegerPoint! !!MorphicTransform methodsFor: 'transformations'!transformRect: aRectangle	^ (self transform: aRectangle topLeft) corner: (self transform: aRectangle bottomRight)! !!MorphicTransform methodsFor: 'private'!setAngle: aFloat	angle _ aFloat.! !!MorphicTransform methodsFor: 'private'!setOffset: aPoint	offset _ aPoint.! !!MorphicTransform methodsFor: 'private'!setOffset: aPoint angle: a scale: s	offset _ aPoint.	angle _ a.	scale _ s! !!MorphicTransform methodsFor: 'private'!setScale: aFloat	scale _ aFloat.! !!MorphicTransform class methodsFor: 'instance creation'!identity	^ self offset: 0@0 angle: 0.0 scale: 1.0! !!MorphicTransform class methodsFor: 'instance creation'!new	^ self offset: 0@0! !!MorphicTransform class methodsFor: 'instance creation'!offset: aPoint	^ self offset: aPoint angle: 0.0 scale: 1.0! !!MorphicTransform class methodsFor: 'instance creation'!offset: aPoint angle: a scale: s	^ self basicNew setOffset: aPoint angle: a scale: s! !MorphWorldController comment:'I am a controller for SceneViews. I support gestures for scrolling, click-selection, and area selection of scene glyphs. (See the class comment in GestureController for more details about gestures.) I also support construction operations such as inserting new glyphs and merging glyphs to make them share a common point.The mapping of gestures to actions is as follows (see GestureController comment for more about gestures):  Click:	click on glyph				select glyph	shift-click on glyph			toggle selection of that glyph	click on background			clear selection  Double click:	double-click on glyph			inspect glyph	double-click on background		select all  Hold/Drag/Sweep:	hold (no movement)			yellow-button menu	drag (up/left movement)		scrolling hand	sweep (down/right movement)	select glyphs in region	shift-sweep					toggle selection of glyphs in region'!!MorphWorldController methodsFor: 'control sequence' stamp: 'di 6/14/97 01:41'!controlActivity	"Do one step of the Morphic interaction loop. Called repeatedly while window is active."	self viewHasCursor		ifTrue: [Sensor currentCursor == Cursor blank ifFalse: [Cursor blank show]]		ifFalse: [Sensor currentCursor == Cursor normal ifFalse: [Cursor normal show]].	model doOneCycle.! !!MorphWorldController methodsFor: 'control sequence' stamp: 'di 9/18/97 11:40'!controlInitialize	"This window is becoming active."	"hide the hardware cursor, since hand will draw it"	Cursor blank show.	"In case of, eg, inspect during balloon help..."	BalloonMorph removeCurrentBalloon.	model hands do: [:h | h initForEvents].	view displayView.  "initializes the WorldMorph's canvas"! !!MorphWorldController methodsFor: 'control sequence' stamp: 'di 6/19/97 12:36'!controlLoop 	| outAndMouseUp |	sensor leftShiftDown ifTrue:		["Hold shift down when activating a Morphic window to take stats"		(self confirm: 'The shift key was down;do you really want to spy on Morphic?') ifTrue:			[^ MessageTally spyOn: [super controlLoop. Cursor normal show]]].	"Overridden to keep control active when mouse leaves the view..."	outAndMouseUp _ false.	[outAndMouseUp and: [Sensor anyButtonPressed]]		whileFalse:		[self controlActivity. Processor yield.		self viewHasCursor			ifTrue: [outAndMouseUp _ false]			ifFalse: [outAndMouseUp _ outAndMouseUp | Sensor noButtonPressed]]! !!MorphWorldController methodsFor: 'control sequence' stamp: 'di 11/14/97 08:17'!controlTerminate 	"This window is becoming inactive..."	Cursor normal show.  "restore the normal cursor"	model hands do: [:h | h newKeyboardFocus: nil]. "Free dependents links if any"	model canvas: nil.		"free model's canvas to save space"	model fullReleaseCachedState ! !!MorphWorldController methodsFor: 'control sequence' stamp: 'jm 6/17/97 10:29'!isControlActive	^ sensor redButtonPressed or: [self viewHasCursor]! !!MorphWorldController methodsFor: 'control sequence'!isControlWanted	^ self viewHasCursor! !MorphWorldView comment:'I am a view used to display a Scene. I may be scrolled by adjusting my offset. My default controller is SceneController.SceneViews encapsulate the notion of a changing foreground and a fixed background during interactive updates. During an interaction (such as dragging), some of the glyphs will not change location or appearance. These are part of the "background". All glyphs that may change (the "foreground" glyphs) are painted against this unchanging backdrop during the interaction.Instance Variables:	offset				the current offset of this view (used for scrolling)	enclosingRect 		a rectangle large enough to contain all the objects in the scene, plus a small border (this is a cache that must be recomputed when glyphs are moved, added, or removed from the scene)	backgroundForm		a <Form> containing the fixed background	visibleForeground		the glyphs that are changing but not selected during an interaction	selectedForeground	the selected glyphs that are changing during an interaction'!!MorphWorldView methodsFor: 'all'!deEmphasizeView 	"This window is becoming inactive."	self topView cacheBitsAsTwoTone ifTrue: [		"draw deEmphasized as a two-tone (monochrome) form"		model displayWorldAsTwoTone].! !!MorphWorldView methodsFor: 'all'!defaultControllerClass	^ MorphWorldController! !!MorphWorldView methodsFor: 'all'!displayView	"This method is called by the system when the top view is framed or moved."	model viewBox: self insetDisplayBox.	self topView == ScheduledControllers scheduledControllers first view		ifTrue: [model displayWorld]		ifFalse: [model displayWorldAsTwoTone].  "just restoring the screen"! !!MorphWorldView methodsFor: 'all' stamp: 'sw 9/26/97 20:56'!update: symbol	^ symbol == #newColor		ifTrue: [self topView backgroundColor: model color dominantColor; uncacheBits; display]		ifFalse: [super update: symbol].! !!MorphWorldView class methodsFor: 'instance creation'!fullColorWhenInactive	FullColorWhenInactive ifNil: [FullColorWhenInactive _ true].	^ FullColorWhenInactive! !!MorphWorldView class methodsFor: 'instance creation'!fullColorWhenInactive: aBoolean	"If FullColorWhenInactive is true then WorldMorphViews will created inside StandardSystemViews that cache their contents in full-color when the window is inactive. If it is false, only a half-tone gray approximation of the colors will be cached to save space."	FullColorWhenInactive _ aBoolean.! !!MorphWorldView class methodsFor: 'instance creation'!openOn: aMorphWorld	"Open a view on the given WorldMorph."	self openOn: aMorphWorld label: 'A Morphic World'.! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'sw 10/2/97 23:17'!openOn: aWorldMorph label: aString	"Open a view with the given label on the given WorldMorph."	^ self openOn: aWorldMorph label: aString model: (CautiousModel new initialExtent: aWorldMorph initialExtent)! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'sw 9/29/97 17:01'!openOn: aWorldMorph label: aString model: aModel	"Open a view with the given label on the given WorldMorph."	| topView |	topView _ self fullColorWhenInactive		ifTrue: [topView _ ColorSystemView new]		ifFalse: [topView _ StandardSystemView new].	topView model: aModel;		label: aString;		borderWidth: 1;		minimumSize: aWorldMorph extent + (2@2);  "add border width"		addSubView: (self new initialize model: aWorldMorph);		backgroundColor: aWorldMorph color.	topView controller open.! !!MouseMenuController methodsFor: 'menu setup' stamp: 'sw 1/15/98 18:59'!shiftedYellowButtonMenu	"Serves as a default backstop; every situation where a shifted menu is anticipated should reimplement this"	^ PopUpMenu labels: 'noshiftmenuavailable' lines: #()! !!MouseMenuController methodsFor: 'menu messages'!redButtonActivity	"Determine which item in the red button pop-up menu is selected. If one 	is selected, then send the corresponding message to the object designated 	as the menu message receiver."	| index |	redButtonMenu ~~ nil		ifTrue: 			[index _ redButtonMenu startUp.			index ~= 0 				ifTrue: [self menuMessageReceiver perform:							(redButtonMessages at: index)]]		ifFalse: [super controlActivity]! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sw 1/25/96'!shiftedYellowButtonActivity	"Present the alternate (shifted) menu and take action accordingly.  .	: let #shiftedYellowButtonActivity: do the work"	| index shiftMenu |	(shiftMenu _ self shiftedYellowButtonMenu) == nil ifTrue:		[^ super controlActivity].	self shiftedYellowButtonActivity: shiftMenu! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sw 1/26/96'!shiftedYellowButtonActivity: shiftMenu	"Present the alternate (shifted) menu and take action accordingly.  If we get here, shiftMenu is known to be non-nil.  "	| index  |	(index _ shiftMenu startUp) ~= 0		ifTrue:			[self menuMessageReceiver performMenuMessage: (self shiftedYellowButtonMessages at: index)]		ifFalse:			[super controlActivity]! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sw 7/29/97 17:36'!startUpYellowButtonMenu	"Factored out so that subclasses can use a caption if desired"	^ yellowButtonMenu startUp! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sw 7/29/97 17:37'!unshiftedYellowButtonActivity	"Put up the regular yellow-button menu and take action as appropriate"	| index  |	yellowButtonMenu ~~ nil		ifTrue: 			[index _ self startUpYellowButtonMenu.			index ~= 0 				ifTrue: [self menuMessageReceiver performMenuMessage:							(yellowButtonMessages at: index)]]		ifFalse:			[super controlActivity]! !!MovieMorph methodsFor: 'initialization' stamp: 'jm 7/24/97 15:05'!initialize	super initialize.	color _ (Color r: 1 g: 0 b: 1).	playMode _ #stop.  "#stop, #playOnce, or #loop"	msecsPerFrame _ 200.	rotationDegrees _ 0.	scalePoint _ 1.0@1.0.	frameList _ EmptyArray.	currentFrameIndex _ 1.	dwellCount _ 0.! !!MovieMorph methodsFor: 'accessing'!form	^ self currentFrame form! !!MovieMorph methodsFor: 'accessing'!rotationDegrees	^ rotationDegrees! !!MovieMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:05'!rotationDegrees: newRotationDegrees	| frame |	newRotationDegrees ~= rotationDegrees ifTrue: [		self changed.		rotationDegrees _ newRotationDegrees.		frame _ self currentFrame.		frame ifNotNil: [frame rotationDegrees: newRotationDegrees].		self layoutChanged.		self changed].! !!MovieMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:05'!scalePoint	^ scalePoint! !!MovieMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:05'!scalePoint: newScalePoint	| frame |	newScalePoint ~= scalePoint ifTrue: [		self changed.		scalePoint _ newScalePoint.		frame _ self currentFrame.		frame ifNotNil: [frame scalePoint: newScalePoint].		self layoutChanged.		self changed].! !!MovieMorph methodsFor: 'drawing'!drawOn: aCanvas	| frame |	frame _ self currentFrame.	frame ~~ nil		ifTrue: [^ frame drawOn: aCanvas]		ifFalse: [^ super drawOn: aCanvas].! !!MovieMorph methodsFor: 'geometry-testing'!containsPoint: p	| frame |	frame _ self currentFrame.	((frame ~~ nil) and: [playMode = #stop])		ifTrue: [^ frame containsPoint: p]		ifFalse: [^ super containsPoint: p].! !!MovieMorph methodsFor: 'stepping'!step	playMode = #stop ifTrue: [^ self].	dwellCount > 0 ifTrue: [		dwellCount _ dwellCount - 1.		^ self].	currentFrameIndex < frameList size		ifTrue: [^ self setFrame: currentFrameIndex + 1].	playMode = #loop		ifTrue: [self setFrame: 1]		ifFalse: [playMode _ #stop].! !!MovieMorph methodsFor: 'stepping'!stepTime	^ msecsPerFrame! !!MovieMorph methodsFor: 'menu' stamp: 'sw 8/17/97 22:19'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| movies |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	frameList size > 1 ifTrue: [		aCustomMenu add: 'repaint' action: #editDrawing.		aCustomMenu add: 'set rotation center' action: #setRotationCenter.		aCustomMenu add: 'play once' action: #playOnce.		aCustomMenu add: 'play loop' action: #playLoop.		aCustomMenu add: 'stop playing' action: #stopPlaying.		currentFrameIndex > 1 ifTrue: [			aCustomMenu add: 'previous frame' action: #previousFrame].		currentFrameIndex < frameList size ifTrue: [			aCustomMenu add: 'next frame' action: #nextFrame]].	aCustomMenu add: 'extract this frame' action: #extractFrame:.	movies _		(self world rootMorphsAt: aHandMorph targetOffset)			select: [:m | (m isKindOf: MovieMorph) or:						[m isKindOf: SketchMorph]].	(movies size > 1) ifTrue: [		aCustomMenu add: 'insert into movie' action: #insertIntoMovie:].! !!MovieMorph methodsFor: 'menu'!advanceFrame	currentFrameIndex < frameList size		ifTrue: [self setFrame: currentFrameIndex + 1]		ifFalse: [self setFrame: 1].! !!MovieMorph methodsFor: 'menu'!editDrawing	| frame |	frame _ self currentFrame.	frame ~~ nil ifTrue: [frame editDrawingInWorld: self world].! !!MovieMorph methodsFor: 'menu'!extractFrame: evt	| f |	f _ self currentFrame.	f ifNil: [^ self].	frameList _ frameList copyWithout: f.	frameList isEmpty		ifTrue: [self position: f position]		ifFalse: [self setFrame: currentFrameIndex].	evt hand attachMorph: f.! !!MovieMorph methodsFor: 'menu'!insertIntoMovie: evt	| movies target |	movies _		(self world rootMorphsAt: evt hand targetOffset)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isKindOf: SketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	target _ movies first.	(target isKindOf: SketchMorph) ifTrue: [		target _ target replaceSelfWithMovie].	movies first insertFrames: frameList.	self delete.! !!MovieMorph methodsFor: 'menu'!nextFrame	currentFrameIndex < frameList size		ifTrue: [self setFrame: currentFrameIndex + 1].! !!MovieMorph methodsFor: 'menu'!playLoop	playMode _ #loop.! !!MovieMorph methodsFor: 'menu'!playOnce	self setFrame: 1.	playMode _ #playOnce.! !!MovieMorph methodsFor: 'menu'!previousFrame	currentFrameIndex > 1		ifTrue: [self setFrame: currentFrameIndex - 1].! !!MovieMorph methodsFor: 'menu' stamp: 'jm 7/24/97 15:05'!setRotationCenter	| frame p |	frame _ self currentFrame.	frame ifNil: [^ self].	self rotationDegrees: 0.0.   "must set rotation center with no rotation"	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	frame rotationCenter: p - frame bounds origin.	self setFrame: currentFrameIndex.! !!MovieMorph methodsFor: 'menu'!stopPlaying	playMode _ #stop.	self setFrame: 1.! !!MovieMorph methodsFor: 'private'!currentFrame	frameList isEmpty ifTrue: [^ nil].	currentFrameIndex > frameList size		ifTrue: [currentFrameIndex _ frameList size].	currentFrameIndex < 1		ifTrue: [currentFrameIndex _ 1].	^ frameList at: currentFrameIndex! !!MovieMorph methodsFor: 'private'!insertFrames: newFrames	"Insert the given collection of frames into this movie just after the currentrame."	frameList isEmpty ifTrue: [		frameList _ newFrames asArray copy.		self setFrame: 1.		^ self].	frameList _		frameList			copyReplaceFrom: currentFrameIndex + 1  "insert before"			to: currentFrameIndex			with: newFrames.! !!MovieMorph methodsFor: 'private' stamp: 'jm 7/24/97 15:05'!setFrame: newFrameIndex	| oldFrame p newFrame |	oldFrame _ self currentFrame.	oldFrame ifNil: [^ self].	self changed.	p _ oldFrame referencePosition.	currentFrameIndex _ newFrameIndex.	currentFrameIndex > frameList size		ifTrue: [currentFrameIndex _ frameList size].	currentFrameIndex < 1		ifTrue: [currentFrameIndex _ 1].	newFrame _ frameList at: currentFrameIndex.	newFrame rotationDegrees: rotationDegrees scalePoint: scalePoint.	newFrame referencePosition: p.	oldFrame delete.	self addMorph: newFrame.	dwellCount _ newFrame framesToDwell.	self layoutChanged.	self changed.! !MultiuserTinyPaint comment:'A very simple paint program that handles multiple users (hands).Each user has their own brush size and color.'!!MultiuserTinyPaint methodsFor: 'initialization' stamp: 'jm 11/4/97 07:15'!initialize	super initialize.	color _ Color veryVeryLightGray.	drawState _ IdentityDictionary new.	self clear.! !!MultiuserTinyPaint methodsFor: 'events' stamp: 'jm 11/4/97 07:15'!handlesMouseDown: evt	^ true! !!MultiuserTinyPaint methodsFor: 'events' stamp: 'jm 11/4/97 07:15'!mouseDown: evt	| state |	(drawState includesKey: evt hand) ifFalse: [self createDrawStateFor: evt hand].	state _ drawState at: evt hand.	state at: LastMouseIndex put: evt cursorPoint.! !!MultiuserTinyPaint methodsFor: 'events' stamp: 'jm 11/4/97 07:15'!mouseMove: evt	| state lastP p pen |	state _ drawState at: evt hand ifAbsent: [^ self].	lastP _ state at: LastMouseIndex.	p _ evt cursorPoint.	p = lastP ifTrue: [^ self].	pen _ state at: PenIndex.	pen drawFrom: lastP - bounds origin to: p - bounds origin.	self invalidRect: (		((lastP min: p) - pen sourceForm extent) corner:		((lastP max: p) + pen sourceForm extent)).	state at: LastMouseIndex put: p.! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 9/26/97 14:50'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'clear' action: #clear.	aCustomMenu add: 'pen color' action: #setPenColor:.	aCustomMenu add: 'pen size' action: #setPenSize:."	aCustomMenu add: 'fill' action: #fill:."! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!brushColor: aColor hand: hand	| state |	(drawState includesKey: hand) ifFalse: [self createDrawStateFor: hand].	state _ drawState at: hand.	(state at: PenIndex) color: aColor.	state at: PenColorIndex put: aColor.! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!clear	| newPen |	self form: ((Form extent: 400@300 depth: 8) fillColor: color).	drawState do: [:state |		newPen _ Pen newOnForm: originalForm.		newPen roundNib: (state at: PenSizeIndex).		newPen color: (state at: PenColorIndex).		state at: PenIndex put: newPen].! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!fill: evt	| state fillPt |	(drawState includesKey: evt hand) ifFalse: [self createDrawStateFor: evt hand].	state _ drawState at: evt hand.	Cursor blank show.	Cursor crossHair showWhile:		[fillPt _ Sensor waitButton - self world viewBox origin - self position].	originalForm shapeFill: (state at: PenColorIndex) interiorPoint: fillPt.	self changed.! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 9/26/97 14:47'!penSize: anInteger hand: hand	| state |	(drawState includesKey: hand) ifFalse: [self createDrawStateFor: hand].	state _ drawState at: hand.	state at: PenSizeIndex put: anInteger.	(state at: PenIndex) roundNib: anInteger.! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!setPenColor: evt	evt hand changeColorTarget: self selector: #brushColor:hand:.! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!setPenSize: evt	| menu sizes |	menu _ MenuMorph new.	sizes _ (0 to: 5), (6 to: 12 by: 2), (15 to: 40 by: 5).	sizes do: [:w |		menu add: w printString			target: self			selector: #penSize:hand:			argumentList: (Array with: w with: evt hand)].	menu popUpAt: evt hand position event: evt.! !!MultiuserTinyPaint methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!createDrawStateFor: aHand	| pen state |	pen _ Pen newOnForm: originalForm.	state _ Array new: 4.	state at: PenIndex put: pen.	state at: PenSizeIndex put: 3.	state at: PenColorIndex put: Color red.	state at: LastMouseIndex put: nil.	drawState at: aHand put: state.! !!MultiuserTinyPaint class methodsFor: 'class initialization' stamp: 'jm 11/4/97 07:15'!initialize	"MultiuserTinyPaint initialize"	"indices into the state array for a given hand"	PenIndex _ 1.	PenSizeIndex _ 2.	PenColorIndex _ 3.	LastMouseIndex _ 4.! !NetNameResolver comment:'This class implements TCP/IP style network name lookup and translation facilities.'!!NetNameResolver class methodsFor: 'class initialization' stamp: 'jm 9/17/97 16:18'!initialize	"NetNameResolver initialize"	"Note: On the Mac, the name resolver is asynchronous (i.e., Squeak can do other things while it is working), but can only handle one request at a time. On other platforms, such as Unix, the resolver is synchronous; a call to, say, the name lookup primitive will block all Squeak processes until it returns."	"Resolver Status Values"	ResolverUninitialized _ 0.	"network is not initialized"	ResolverReady _ 1.			"resolver idle, last request succeeded"	ResolverBusy _ 2.			"lookup in progress"	ResolverError _ 3.			"resolver idle, last request failed"	DefaultHostName _ ''.! !!NetNameResolver class methodsFor: 'address string utils' stamp: 'jm 9/15/97 06:19'!addressFromString: addressString	"Return the internet address represented by the given string. The string should contain four positive decimal integers delimited by periods, commas, or spaces, where each integer represents one address byte. Return nil if the string is not a host address in an acceptable format."	"NetNameResolver addressFromString: '1.2.3.4'"	"NetNameResolver addressFromString: '1,2,3,4'"	"NetNameResolver addressFromString: '1 2 3 4'"	| newAddr s byte delimiter |	newAddr _ ByteArray new: 4.	s _ ReadStream on: addressString.	s skipSeparators.	1 to: 4 do: [:i |		byte _ self readDecimalByteFrom: s.		byte = nil ifTrue: [^ nil].		newAddr at: i put: byte.		i < 4 ifTrue: [			delimiter _ s next.			((delimiter = $.) or: [(delimiter = $,) or: [delimiter = $ ]])				ifFalse: [^ nil]]].	^ newAddr! !!NetNameResolver class methodsFor: 'address string utils' stamp: 'jm 9/15/97 16:52'!stringFromAddress: addr	"Return a string representing the given host address as four decimal bytes delimited with decimal points."	"NetNameResolver stringFromAddress: NetNameResolver localHostAddress"	| s |	s _ WriteStream on: ''.	1 to: 3 do: [ :i | (addr at: i) printOn: s. s nextPut: $.].	(addr at: 4) printOn: s.	^ s contents! !!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 9/15/97 16:44'!addressForName: hostName timeout: secs	"Look up the given host name and return its address. Return nil if the address is not found in the given number of seconds."	"NetNameResolver addressForName: 'create.ucsb.edu' timeout: 30"	| deadline ready success |	(hostName isEmpty not and: [hostName first isDigit]) ifTrue: [		"assume a numeric host address if first character is a digit"		^ self addressFromString: hostName].	deadline _ Time millisecondClockValue + (secs * 1000).	ready _ self waitForResolverReadyUntil: deadline.	ready ifFalse: [^ nil].	self primStartLookupOfName: hostName.	success _ self waitForCompletionUntil: deadline.	success		ifTrue: [^ self primNameLookupResult]		ifFalse: [^ nil].! !!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 9/15/97 16:52'!localAddressString	"Return a string representing the local host address as four decimal bytes delimited with decimal points."	"NetNameResolver localAddressString"	^ NetNameResolver stringFromAddress: NetNameResolver localHostAddress! !!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 9/15/97 16:31'!localHostAddress	"Return the local address of this host."	"NetNameResolver localHostAddress"	^ self primLocalAddress! !!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 9/15/97 16:46'!nameForAddress: hostAddress timeout: secs	"Look up the given host address and return its name. Return nil if the lookup fails or is not completed in the given number of seconds. Depends on the given host address being known to the gateway, which may not be the case for dynamically allocated addresses."	"NetNameResolver		nameForAddress: (NetNameResolver addressFromString: '128.111.92.40')		timeout: 30"	| deadline ready success |	deadline _ Time millisecondClockValue + (secs * 1000).	ready _ self waitForResolverReadyUntil: deadline.	ready ifFalse: [^ nil].	self primStartLookupOfAddress: hostAddress.	success _ self waitForCompletionUntil: deadline.	success		ifTrue: [^ self primAddressLookupResult]		ifFalse: [^ nil].! !!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 9/17/97 16:26'!promptUserForHostAddress	"Ask the user for a host name and return its address."	"NetNameResolver promptUserForHostAddress"	^ NetNameResolver promptUserForHostAddressDefault: ''! !!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 11/4/97 07:15'!promptUserForHostAddressDefault: defaultName	"Ask the user for a host name and return its address. If the default name is the empty string, use the last host name as the default."	"NetNameResolver promptUserForHostAddressDefault: ''"	| default hostName serverAddr |	Socket initializeNetwork.	defaultName isEmpty		ifTrue: [default _ DefaultHostName]		ifFalse: [default _ defaultName].	hostName _ FillInTheBlank		request: 'Host name or address?'		initialAnswer: default.	hostName isEmpty ifTrue: [^ 0].	serverAddr _ NetNameResolver addressForName: hostName timeout: 15.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', hostName].	hostName size > 0 ifTrue: [DefaultHostName _ hostName].	^ serverAddr! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'jm 9/15/97 16:58'!initializeNetwork	"Initialize the network drivers and record the semaphore to be used by the resolver. Do nothing if the network is already initialized."	"NetNameResolver initializeNetwork"	| semaIndex |	self primNameResolverStatus = ResolverUninitialized		ifFalse: [^ self].  "network is already initialized"	ResolverSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: ResolverSemaphore.	Utilities informUser:'Initializing the network drivers; this maytake up to 30 seconds and can''t be interrupted'		during: [self primInitializeNetwork: semaIndex].! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'jm 9/15/97 06:37'!primInitializeNetwork: resolverSemaIndex	"Initialize the network drivers on platforms that need it, such as the Macintosh. Since mobile computers may not always be connected to a network, this method should NOT be called automatically at startup time; rather, it should be called when first starting a networking application. It is a noop if the network driver has already been initialized. If non-zero, resolverSemaIndex is the index of a VM semaphore to be associated with the network name resolver. This semaphore will be signalled when the resolver status changes, such as when a name lookup query is completed."	"Note: some platforms (e.g., Mac) only allow only one name lookup query at a time, so a manager process should be used to serialize resolver lookup requests."	<primitive: 200>	self notify: 'Network initialization failed, perhaps becausethis machine is not connected to a network.'.! !!NetNameResolver class methodsFor: 'primitives'!primAbortLookup	"Abort the current lookup operation, freeing the name resolver for the next query."	<primitive: 205>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primAddressLookupResult	"Return the host name found by the last host address lookup. Returns nil if the last lookup was unsuccessful."	<primitive: 204>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primLocalAddress	"Return the local address of this host."	<primitive: 206>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primNameLookupResult	"Return the host address found by the last host name lookup. Returns nil if the last lookup was unsuccessful."	<primitive: 202>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primNameResolverError	"Return an integer reflecting the error status of the last network name resolver request. Zero means no error."	<primitive: 208>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primNameResolverStatus	"Return an integer reflecting the status of the network name resolver. For a list of possible values, see the comment in the 'initialize' method of this class."	<primitive: 207>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primStartLookupOfAddress: hostAddr	"Look up the given host address in the Domain Name Server to find its name. This call is asynchronous. To get the results, wait for it to complete or time out and then use primAddressLookupResult."	<primitive: 203>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primStartLookupOfName: hostName	"Look up the given host name in the Domain Name Server to find its address. This call is asynchronous. To get the results, wait for it to complete or time out and then use primNameLookupResult."	<primitive: 201>	self primitiveFailed! !!NetNameResolver class methodsFor: 'private'!readDecimalByteFrom: aStream	"Read a positive, decimal integer from the given stream. Stop when a non-digit or end-of-stream is encountered. Return nil if stream is not positioned at a decimal digit or if the integer value read exceeds 255."	| digitSeen value digit |	digitSeen _ false.	value _ 0.	[aStream atEnd] whileFalse: [		digit _ aStream next digitValue.		(digit < 0 or: [digit > 9]) ifTrue: [			aStream skip: -1.			digitSeen ifFalse: [^ nil].			^ value].		digitSeen _ true.		value _ (value * 10) + digit].	(digitSeen and: [value <= 255]) ifFalse: [^ nil].	value > 255 ifTrue: [^ nil].  "exceeds the range of a single byte integer"	^ value! !!NetNameResolver class methodsFor: 'private' stamp: 'jm 9/15/97 16:56'!waitForCompletionUntil: deadline	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is ready, false if the network is not initialized or the resolver does not become free within the given time period."	| status |	status _ self primNameResolverStatus.	[(status = ResolverBusy) and:	 [Time millisecondClockValue < deadline]]		whileTrue: [			"wait for resolver to be available"			ResolverSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status _ self primNameResolverStatus].	status = ResolverReady		ifTrue: [^ true]		ifFalse: [self primAbortLookup. ^ false].! !!NetNameResolver class methodsFor: 'private' stamp: 'jm 9/15/97 16:56'!waitForResolverReadyUntil: deadline	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is not busy, false if the network is not initialized or the resolver does not become free within the given time period."	| status |	status _ self primNameResolverStatus.	status = ResolverUninitialized ifTrue: [^ false].	[(status = ResolverBusy) and:	 [Time millisecondClockValue < deadline]]		whileTrue: [			"wait for resolver to be available"			ResolverSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status _ self primNameResolverStatus].	^ status ~= ResolverBusy! !NewParagraph comment:'A Paragraph represents text that has been laid out, or composed, in some container.	text 		A Text with encoded per-character emphasis.	textStyle	A TextStyle with font set, line height and horizontal alignment.	firstCharacterIndex    The starting index in text for this paragraph, allowing				composition of a long text into a number of containers.	container	A Rectangle or TextContainer that determines where text can go.	lines		An Array of TextLines comprising the final layout of the text				after it has been composed within its container.	positionWhenComposed   As its name implies.  Allows display at new locations				without the need to recompose the text.Lines are ordered vertically.  However, for a given y, there may be several lines in left to right order.  Lines must never be empty, even if text is empty.'!!NewParagraph methodsFor: 'access' stamp: 'di 11/16/97 09:02'!adjustedFirstCharacterIndex	"Return the index in the text where this paragraph WOULD begin if nothing had changed, except the size of the text -- ie if there have only been an insertion of deletion in the preceding morphs"	offsetToEnd ifNil: [^ -1].	^ text size - offsetToEnd! !!NewParagraph methodsFor: 'access' stamp: 'di 10/24/97 17:38'!extent	^ container width @ (lines last bottom - lines first top)! !!NewParagraph methodsFor: 'access' stamp: 'di 11/8/97 15:41'!firstCharacterIndex	^ firstCharacterIndex! !!NewParagraph methodsFor: 'access' stamp: 'di 10/23/97 21:01'!lastCharacterIndex	^ lines last last! !!NewParagraph methodsFor: 'access' stamp: 'di 10/21/97 14:39'!text	^ text! !!NewParagraph methodsFor: 'access' stamp: 'jm 11/19/97 20:27'!textOwner: ignored  "See TextOnCurve"! !!NewParagraph methodsFor: 'access' stamp: 'di 10/21/97 14:39'!textStyle	^ textStyle! !!NewParagraph methodsFor: 'access' stamp: 'di 10/23/97 19:33'!textStyle: aTextStyle 	"Set the style by which the receiver should display its text."	textStyle _ aTextStyle! !!NewParagraph methodsFor: 'composition' stamp: 'di 11/8/97 15:31'!compose: t style: ts from: startingIndex in: textContainer	text _ t.	textStyle _ ts.	firstCharacterIndex _ startingIndex.	offsetToEnd _ text size - firstCharacterIndex.	container _ textContainer.	self composeAll! !!NewParagraph methodsFor: 'composition' stamp: 'di 11/15/97 09:21'!composeAll	self composeLinesFrom: firstCharacterIndex		withLines: OrderedCollection new		atY: container top.! !!NewParagraph methodsFor: 'composition' stamp: 'di 11/15/97 09:21'!composeAllStartingAt: characterIndex	firstCharacterIndex _ characterIndex.	offsetToEnd _ text size - firstCharacterIndex.	self composeAll! !!NewParagraph methodsFor: 'composition' stamp: 'di 11/16/97 16:15'!composeLinesFrom: startingIndex withLines: startingLines atY: startingY	| charIndex lineY lineHeight scanner line row firstLine lineHeightGuess saveCharIndex hitCR |	charIndex _ startingIndex.	lines _ startingLines.	lineY _ startingY.	lineHeightGuess _ textStyle lineGrid.	maxRightX _ container left.	scanner _ CompositionScanner new text: text textStyle: textStyle.	firstLine _ true.	[charIndex <= text size and: [(lineY + lineHeightGuess) <= container bottom]]		whileTrue:		[lineHeight _ lineHeightGuess.		saveCharIndex _ charIndex.		hitCR _ false.		(row _ container rectanglesAt: lineY height: lineHeight)			withIndexDo:			[:r :i | (charIndex <= text size and: [hitCR not]) ifTrue:				[line _ scanner composeFrom: charIndex inRectangle: r						firstLine: firstLine leftSide: i=1 rightSide: i=row size.				lines addLast: line.				(text at: line last) = Character cr ifTrue: [hitCR _ true].				lineHeight _ lineHeight max: line lineHeight.  "includes font changes"				charIndex _ line last + 1]].		row size >= 1 ifTrue:		[lineY _ lineY + lineHeight.		lineY > container bottom			ifTrue: ["Oops -- the line is really too high to fit -- back out"					charIndex _ saveCharIndex.					row do: [:r | lines removeLast]]			ifFalse: ["It's OK -- the line still fits."					maxRightX _ maxRightX max: scanner rightX.					1 to: row size - 1 do:  "Adjust heights across row if necess"						[:i | (lines at: lines size - row size + i)								lineHeight: lines last lineHeight								baseline: lines last baseline].					charIndex > text size ifTrue:						["end of text"						lines _ lines asArray.						^ maxRightX].					firstLine _ false]]			ifFalse:			[lineY _ lineY + lineHeight]].	firstLine ifTrue:		["No space in container or empty text"		line _ (TextLine start: startingIndex stop: startingIndex-1						internalSpaces: 0 paddingWidth: 0)				rectangle: (container topLeft extent: 0@lineHeightGuess);				lineHeight: lineHeightGuess baseline: textStyle baseline.		lines _ Array with: line].	"end of container"	lines _ lines asArray.	^ maxRightX! !!NewParagraph methodsFor: 'composition' stamp: 'di 10/22/97 11:13'!compositionRectangle	^ container! !!NewParagraph methodsFor: 'composition' stamp: 'di 11/16/97 16:12'!recomposeFrom: characterIndex orLineAbove: lineAbove	"lineAbove is true when there is need to recompose the prior line (not strictly the one above) as well, owing to edits that may have affected, eg, word breaks."	| priorLines startLine |	startLine _ self lineIndexForCharacter: characterIndex.	lineAbove ifTrue: [startLine _ startLine-1 max: 1].	[startLine > 1 and: [(lines at: startLine-1) top = (lines at: startLine) top]]		whileTrue: [startLine _ startLine - 1].  "Find leftmost of line pieces"	priorLines _ OrderedCollection new: lines size + 1.	1 to: startLine-1 do: [:i | priorLines addLast: (lines at: i)].	self composeLinesFrom: (lines at: startLine) first		withLines: priorLines		atY: (lines at: startLine) top! !!NewParagraph methodsFor: 'selection' stamp: 'di 11/8/97 11:45'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: (aPoint adhereTo: line rectangle) index: nil		in: line! !!NewParagraph methodsFor: 'selection' stamp: 'di 10/23/97 20:32'!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: nil index: index		in: (lines at: (self lineIndexForCharacter: index))! !!NewParagraph methodsFor: 'selection' stamp: 'jm 11/19/97 22:56'!containsPoint: aPoint	^ (lines at: (self lineIndexForPoint: aPoint)) rectangle		containsPoint: aPoint! !!NewParagraph methodsFor: 'selection' stamp: 'di 12/2/97 14:31'!defaultCharacterBlock	^ (CharacterBlock new stringIndex: firstCharacterIndex text: text			topLeft: lines first topLeft extent: 0 @ 0)		textLine: lines first! !!NewParagraph methodsFor: 'selection' stamp: 'di 11/30/97 12:10'!selectionRects	"Return an array of rectangles representing the selection region."	selectionStart ifNil: [^ Array new].	^ self selectionRectsFrom: selectionStart to: selectionStop! !!NewParagraph methodsFor: 'selection' stamp: 'di 12/1/97 09:56'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| line1 line2 rects cb1 cb2 w |	characterBlock1 <= characterBlock2		ifTrue: [cb1 _ characterBlock1.  cb2 _ characterBlock2]		ifFalse: [cb2 _ characterBlock1.  cb1 _ characterBlock2].	cb1 = cb2 ifTrue:		[w _ self caretWidth.		^ Array with: (cb1 topLeft - (w@0) corner: cb1 bottomLeft + ((w+1)@0))].	line1 _ self lineIndexForCharacter: cb1 stringIndex.	line2 _ self lineIndexForCharacter: cb2 stringIndex.	line1 = line2 ifTrue:		[^ Array with: (cb1 topLeft corner: cb2 bottomLeft)].	rects _ OrderedCollection new.	rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).	line1+1 to: line2-1 do: [:i | rects addLast: (lines at: i) rectangle].	rects addLast: ((lines at: line2) topLeft corner: cb2 bottomLeft).	^ rects! !!NewParagraph methodsFor: 'selection' stamp: 'di 12/2/97 19:57'!selectionStart: startBlock selectionStop: stopBlock	selectionStart _ startBlock.	selectionStop _ stopBlock.! !!NewParagraph methodsFor: 'editing' stamp: 'tk 1/7/98 12:05'!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range boxes box |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex) 		do: [:att | att mayActOnClick ifTrue:				[range _ text rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last).				box _ boxes detect: [:each | each containsPoint: clickPoint].				Utilities awaitMouseUpIn: box repeating: []						ifSucceed: [							self controlTerminate.							(att actOnClickFor: model) ifTrue: [action _ true].							self controlInitialize].				]].	^ action!]style[(30 1 23 754)f1b,f1,f1b,f1! !!NewParagraph methodsFor: 'editing' stamp: 'di 11/11/97 09:33'!replaceFrom: start to: stop with: aText displaying: displayBoolean 	"Compatibility with old Paragraph" 	text replaceFrom: start to: stop with: aText.		"Update the text."	self recomposeFrom: start orLineAbove: true! !!NewParagraph methodsFor: 'display' stamp: 'di 12/1/97 19:52'!caretWidth	^ 2! !!NewParagraph methodsFor: 'display' stamp: 'di 12/3/97 20:27'!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| visibleRectangle offset leftInRun line |	visibleRectangle _ aCanvas clipRect.	offset _ somePosition - positionWhenComposed.	leftInRun _ 0.	(self lineIndexForPoint: visibleRectangle topLeft)		to: (self lineIndexForPoint: visibleRectangle bottomRight)		do: [:i | line _ lines at: i.			self displaySelectionInLine: line on: aCanvas.			leftInRun _ displayScanner displayLine: line								offset: offset leftInRun: leftInRun.			].! !!NewParagraph methodsFor: 'display' stamp: 'di 12/2/97 19:56'!displaySelectionInLine: line on: aCanvas	| leftX rightX w |	selectionStart ifNil: [^ self].  "No selection"	selectionStart = selectionStop		ifTrue: ["Only show caret on line where clicked"				selectionStart textLine ~= line ifTrue: [^ self]]		ifFalse: ["Test entire selection before or after here"				(selectionStop stringIndex < line first					or: [selectionStart stringIndex > (line last+1)])					ifTrue: [^ self].  "No selection on this line"				(selectionStop stringIndex = line first					and: [selectionStop textLine ~= line])					ifTrue: [^ self].  "Selection ends on line above"				(selectionStart stringIndex = (line last+1)					and: [selectionStop textLine ~= line])					ifTrue: [^ self]].  "Selection begins on line below"	selectionStart stringIndex < line first		ifTrue: [leftX _ line left]		ifFalse: [leftX _ selectionStart left].	(selectionStop stringIndex > (line last+1)			or: [selectionStop stringIndex = (line last+1)					and: [selectionStop textLine ~= line]])		ifTrue: [rightX _ line right]		ifFalse: [rightX _ selectionStop left].	selectionStart = selectionStop ifTrue:		[rightX _ rightX + 1.		w _ self caretWidth.		1 to: w do:			[:i |  "Draw caret triangles at top and bottom"			aCanvas fillRectangle: ((leftX-w+i-1)@(line top+i-1) extent: (w-i*2+3)@1)				color: self selectionColor.			aCanvas fillRectangle: ((leftX-w+i-1)@(line bottom-i) extent: (w-i*2+3)@1)				color: self selectionColor]].	aCanvas fillRectangle: (leftX@line top corner: rightX@line bottom)				color: self selectionColor.! !!NewParagraph methodsFor: 'display' stamp: 'di 11/30/97 12:09'!selectionColor	^ (Color r: 0.4 g: 1.0 b: 0)! !!NewParagraph methodsFor: 'private' stamp: 'di 11/8/97 15:47'!adjustLineIndicesBy: delta	firstCharacterIndex _ firstCharacterIndex + delta.	lines do: [:line | line slide: delta].! !!NewParagraph methodsFor: 'private' stamp: 'di 10/26/97 15:57'!adjustRightX	| shrink |	shrink _ container right - maxRightX.	lines do: [:line | line paddingWidth: (line paddingWidth - shrink)].	container _ container withRight: maxRightX! !!NewParagraph methodsFor: 'private' stamp: 'di 10/29/97 08:25'!flash  "ParagraphEditor compatibility"	Smalltalk beep! !!NewParagraph methodsFor: 'private' stamp: 'di 10/22/97 13:38'!lineIndexForCharacter: index	"Answer the index of the line in which to select the character at index."	lines size <= 1 ifTrue: [^ 1].	2 to: lines size do: 		[:i | (lines at: i) first > index ifTrue: [^ i-1]].	^ lines size! !!NewParagraph methodsFor: 'private' stamp: 'di 11/7/97 11:13'!lineIndexForPoint: aPoint	"Answer the index of the line in which to select the character nearest to aPoint."	| i |	aPoint y < lines first top ifTrue: [^ 1].	aPoint y >= lines last bottom ifTrue: [^ lines size].	"Find the first line at this y-value"	i _ lines findFirst: [:line | line bottom > aPoint y].	"Now find the first line at this x-value"	[i < lines size and: [(lines at: i+1) top = (lines at: i) top				and: [aPoint x >= (lines at: i+1) left]]]		whileTrue: [i _ i + 1].	^ i! !!NewParagraph methodsFor: 'private' stamp: 'di 10/24/97 17:40'!lines	^ lines! !!NewParagraph methodsFor: 'private' stamp: 'di 11/7/97 12:00'!moveBy: delta	lines do: [:line | line moveBy: delta].	positionWhenComposed _ positionWhenComposed + delta.	container _ container translateBy: delta! !!NewParagraph methodsFor: 'private' stamp: 'di 10/21/97 21:36'!positionWhenComposed: pos	positionWhenComposed _ pos! !!NewParagraph methodsFor: 'alignment' stamp: 'di 10/25/97 19:26'!centered 	textStyle centered! !!NewParagraph methodsFor: 'alignment' stamp: 'di 10/25/97 19:26'!justified 	textStyle justified! !!NewParagraph methodsFor: 'alignment' stamp: 'di 10/25/97 19:26'!leftFlush 	textStyle leftFlush! !!NewParagraph methodsFor: 'alignment' stamp: 'di 10/25/97 19:26'!rightFlush 	textStyle rightFlush! !!NewParagraph methodsFor: 'object fileIn' stamp: 'jm 11/13/97 10:31'!convertttfclpm0: varDict ttfclpom0: smartRefStrm	"These variables are automatically stored into the new instance ('text' 'textStyle' 'firstCharacterIndex' 'container' 'lines' 'positionWhenComposed' 'maxRightX' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('offsetToEnd' ) and deal with the information in ()"! !!NewParagraph methodsFor: 'object fileIn' stamp: 'tk 12/29/97 12:14'!convertttfclpm0: varDict ttfclpomss0: smartRefStrm	"These variables are automatically stored into the new instance ('text' 'textStyle' 'firstCharacterIndex' 'container' 'lines' 'positionWhenComposed' 'maxRightX' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('offsetToEnd' 'selectionStart' 'selectionStop' ) and deal with the information in ()"! !!NewParagraph methodsFor: 'object fileIn' stamp: 'di 1/9/98 11:23'!convertttfclpom0: varDict ttfclpomss0: smartRefStrm	"These variables are automatically stored into the new instance ('text' 'textStyle' 'firstCharacterIndex' 'container' 'lines' 'positionWhenComposed' 'offsetToEnd' 'maxRightX' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('selectionStart' 'selectionStop' ) and deal with the information in ()"! !Notes are general structures for users notes.  Being used in the Comment application and others.!!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:19'!addChild: aNote	children add: aNote! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:17'!author	^author! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:17'!author: anAuthor	author _ anAuthor! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:18'!children	^children! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:39'!children: aCollection	children _ aCollection.! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:26'!parent	^parent! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:26'!parent: whatever	parent _ whatever! !!Note methodsFor: 'access' stamp: 'mjg 11/24/97 15:12'!storeOn: aStream	aStream nextPutAll: '(Note new;'.	aStream nextPutAll: 'author: ',self author storeString,';'.	aStream nextPutAll: 'text: ',self text storeString,';'.	aStream nextPutAll: 'parent: ',self parent storeString,';'.	aStream nextPutAll: 'timestamp: ',self timestamp storeString,';'.	aStream nextPutAll: 'title: ',self title storeString,';'.	aStream nextPutAll: 'url: ',self url storeString,';'.	aStream nextPutAll: 'yourself)'.! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:17'!text	^text! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:18'!text: aString	text _ aString! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:18'!timestamp	^timestamp! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:18'!timestamp: aDateandTime	timestamp _ aDateandTime! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:17'!title	^title! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:17'!title: aString	title _ aString! !!Note methodsFor: 'access' stamp: 'mjg 11/19/97 10:45'!url	^url! !!Note methodsFor: 'access' stamp: 'mjg 11/19/97 10:45'!url: aString	url_aString.! !Represents a note on or off event in a MIDI score.!!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 22:02'!channel	^ channel! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 22:02'!channel: midiChannel	channel _ midiChannel.! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/18/97 19:10'!duration	^ duration! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/31/97 11:49'!duration: aNumber	duration _ aNumber.! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 22:07'!key: midiKeyNum velocity: midiVelocity channel: midiChannel	midiKey _ midiKeyNum.	velocity _ midiVelocity.	channel _ midiChannel.! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/18/97 20:58'!midiKey	^ midiKey! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 09:35'!midiKey: midiKeyNum	midiKey _ midiKeyNum.! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 1/4/98 11:51'!pitch	"Convert my MIDI key number to a pitch and return it."	| indexInOctave octave p |	indexInOctave _ (midiKey \\ 12) + 1.	octave _ (midiKey // 12) + 1.	"Table generator: (0 to: 11) collect: [:i | 16.3516 * (2.0 raisedTo: i asFloat / 12.0)]"	p _ #(16.3516 17.32391 18.35405 19.44544 20.60173 21.82677		  23.12466 24.49972 25.95655 27.50000 29.13524 30.86771) at: indexInOctave.	^ p * (#(0.5 1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0) at: octave)! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 09:32'!velocity	^ velocity! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/31/97 11:51'!velocity: midiVelocity	velocity _ midiVelocity.! !!NoteEvent methodsFor: 'classification' stamp: 'jm 12/31/97 11:48'!isNoteEvent	^ true! !!NoteEvent methodsFor: 'printing' stamp: 'jm 1/3/98 08:58'!keyName	"Return a note name for my pitch."	| pitchName octave |	pitchName _ #(c cs d ef e f fs g af a bf b) at: (midiKey \\ 12) + 1.	octave _ (#(-1 0 1 2 3 4 5 6 7 8 9) at: (midiKey // 12) + 1) printString.	^ pitchName, octave! !!NoteEvent methodsFor: 'printing' stamp: 'jm 1/3/98 08:59'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': '.	aStream nextPutAll: self keyName.	aStream space.	duration printOn: aStream.	aStream nextPut: $).! !!NotifyStringHolderController methodsFor: 'menu messages'!debug	"Open a full DebuggerView."	| debuggerTemp topView |	topView _ view topView.	debuggerTemp _ debugger.  debugger _ nil.  "So close wont terminate"	self controlTerminate.	topView deEmphasizeView; erase.	DebuggerView openNoSuspendDebugger: debuggerTemp label: topView label.	topView controller closeAndUnscheduleNoErase.	Processor terminateActive! !!NotifyStringHolderController methodsFor: 'menu messages'!proceed	"Proceed execution of the suspended process."	| debuggerTemp |	Smalltalk okayToProceedEvenIfSpaceIsLow ifFalse: [^ self].	debuggerTemp _ debugger.  debugger _ nil.  "So close wont terminate"	self controlTerminate.	debuggerTemp proceed: view superView controller.	self controlInitialize! !Number comment:'I am an abstract representation of a number. My subclasses Float, Fraction, and Integer, and their subclasses, provide concrete representations of a numeric quantity.All my subclasses participate in a simple type coercion mechanism that supports mixed-mode arithmetic and comparisons.  It works as follows:  If	self<typeA> op: arg<typeB>fails because of incompatible types, then it is retried in the following guise:	(arg adaptTypeA: self) op: arg adaptToTypeA.This gives the arg of typeB an opportunity to resolve the incompatibility, knowing exactly what two types are involved.  If self is more general, then arg will be converted, and viceVersa.  This mechanism is extensible to any new number classes that one might wish to add to Squeak.  The only requirement is that every subclass of Number must support a pair of conversion methods specific to each of the other subclasses of Number.'!!Number methodsFor: 'arithmetic'!/ aNumber 	"Answer the result of dividing the receiver by aNumber."	self subclassResponsibility! !!Number methodsFor: 'testing'!isFloat	^ false! !!Number methodsFor: 'testing'!isFraction	^ false! !!Number methodsFor: 'converting'!adaptFloat: aFloat	"If I am involved in arithmetic with a Float, I must know whether to convert it."	self subclassResponsibility! !!Number methodsFor: 'converting'!adaptFraction: aFraction	"If I am involved in arithmetic with a Fraction, I must know whether to convert it."	self subclassResponsibility! !!Number methodsFor: 'converting'!adaptInteger: anInteger	"If I am involved in arithmetic with an Integer, I must know whether to convert it."	self subclassResponsibility! !!Number methodsFor: 'converting'!adaptToFloat	"If I am involved in arithmetic with a Float, I must know whether to be converted."	self subclassResponsibility! !!Number methodsFor: 'converting'!adaptToFraction	"If I am involved in arithmetic with a Fraction, I must know whether to be converted."	self subclassResponsibility! !!Number methodsFor: 'converting'!adaptToInteger	"If I am involved in arithmetic with an Integer, I must know whether to be converted."	self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'sw 9/8/97 16:30'!asSmallAngleDegrees	"Return the receiver normalized to lie within the range (-180, 180)"	| pos |	pos _ self \\ 360.	pos > 180 ifTrue: [pos _ pos - 360].	^ pos"#(-500 -300 -150 -5 0 5 150 300 500 1200) collect: [:n | n asSmallAngleDegrees]"! !!Number methodsFor: 'printing'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ super defaultLabelForInspector, ': ', self printString! !!Object methodsFor: 'accessing' stamp: 'sw 8/6/97 11:25'!addInstanceVarNamed: aName withValue: aValue	"Add an instance variable named aName and give it value aValue"	(Utilities isLegalInstVarName: aName) ifFalse: [^ self break].	(Utilities inviolateInstanceVariableNames includes:  aName) ifTrue: [^ self break].	self class addInstVarName: aName asString.	self instVarAt: self class instSize put: aValue! !!Object methodsFor: 'accessing' stamp: 'tk 7/2/97 12:48'!atWrap: index put: value	"Store into this element of an indexable object.  If index is out of bounds, let it wrap around from the end to the beginning until it is in bounds.  6/18/96 tk"^ self at: (index - 1 \\ self size + 1) put: value! !!Object methodsFor: 'accessing' stamp: 'sw 10/9/96'!isDescendedFrom: anObject	"Answer whether the receiver is, from the containment perspective, descended from anObject.  "	^ false! !!Object methodsFor: 'testing'!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Object methodsFor: 'testing'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock value! !!Object methodsFor: 'testing'!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock value! !!Object methodsFor: 'testing'!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock value! !!Object methodsFor: 'testing'!isColor	"Answer true if receiver is a Color. False by default."	^ false! !!Object methodsFor: 'testing'!isMorph	^ false! !!Object methodsFor: 'testing' stamp: 'ikp 9/26/97 14:45'!isPseudoContext	^false! !!Object methodsFor: 'testing'!isText	^ false! !!Object methodsFor: 'testing' stamp: 'tk 10/21/97 12:45'!isTransparent	^ false! !!Object methodsFor: 'testing' stamp: 'sw 9/27/96'!name	"Answer a name for the receiver.  This is used generically in the title of certain inspectors, such as the referred-to inspector, and specificially by various subsystems.  By default, we let the object just print itself out..  "	^ self printString! !!Object methodsFor: 'comparing'!hash	"Answer a SmallInteger whose value is related to the receiver's identity.	May be overridden, and should be overridden in any classes that define = "	^ self identityHash! !!Object methodsFor: 'comparing' stamp: 'pm 9/23/97 09:36'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^map newHashFor: self! !!Object methodsFor: 'comparing' stamp: 'di 9/27/97 20:27'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override."	<primitive: 75>	self primitiveFailed! !!Object methodsFor: 'comparing' stamp: 'di 9/27/97 20:23'!identityHashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^map newHashFor: self! !!Object methodsFor: 'copying'!clone	<primitive: 148>	self primitiveFailed! !!Object methodsFor: 'copying' stamp: 'jm 11/14/97 11:08'!shallowCopy	"Answer a copy of the receiver which shares the receiver's instance variables."	| class newObject index |	<primitive: 148>	class _ self class.	class isVariable		ifTrue: 			[index _ self basicSize.			newObject _ class basicNew: index.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index).					index _ index - 1]]		ifFalse: [newObject _ class basicNew].	index _ class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index).			index _ index - 1].	^ newObject! !!Object methodsFor: 'copying' stamp: 'sw 7/31/97 14:15'!unusedInstVarNameLike: aName	| stem otherNames i prospectiveName |	stem _ aName first asLowercase asString , aName allButFirst.	otherNames _ self class allInstVarNames.	i _ 1.	[otherNames includes: (prospectiveName _ stem, i printString)]		whileTrue: [i _ i + 1].	^ prospectiveName! !!Object methodsFor: 'copying' stamp: 'tk 12/4/97 13:21'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy.  Uses ReferenceStream.  To see where the copying stops, see DataStream.typeIDFor: and implementors of objectToStoreOnDataStream"	| dummy refs class index sub val hashers new |	self allMorphsDo: [:m | m prepareToBeSaved].		"Actors fix open scriptEditors"	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: self.	"inform him about the root"	dummy nextPut: self.	"Do the traverse of the tree"	refs _ dummy references.	"all the objects"	"For each object, make a simple copy, then replace all fields with new copy from dict"	refs keysDo: [:each | refs at: each put: each shallowCopy].		"Watch out for classes that do extra things in copy but not in shallowCopy"	hashers _ OrderedCollection new.	refs associationsDo: [:assoc | 		assoc key == assoc value ifFalse: ["is a new object"			new _ assoc value.			class _ new class.			class isVariable				ifTrue: 					[index _ new basicSize.					[index > 0] whileTrue: 						[sub _ new basicAt: index.						(val _ refs at: sub ifAbsent: [nil]) ifNotNil: [								"If not in refs, then the right value is already in the field"								new basicAt: index put: val].						index _ index - 1]].			index _ class instSize.			[index > 0] whileTrue: 				[sub _ new instVarAt: index.				(val _ refs at: sub ifAbsent: [nil]) ifNotNil: [						"If not in refs, then the right value is already in the field"						new instVarAt: index put: val].				index _ index - 1].			(new respondsTo: #rehash) ifTrue: [hashers add: new].			]].	"Force new sets and dictionaries to rehash"	hashers do: [:each | each rehash].	^ refs at: self! !!Object methodsFor: 'dependents access'!addDependent: anObject	"Make the given object one of the receiver's dependents."	| dependents |	dependents _ self dependents.	dependents do: [:o | o == anObject ifTrue: [^ self]].  "anObject is already a dependent"	DependentsFields at: self put: (dependents copyWith: anObject).! !!Object methodsFor: 'dependents access'!breakDependents	"Remove all of the receiver's dependents."	DependentsFields removeKey: self ifAbsent: [].! !!Object methodsFor: 'dependents access'!dependents	"Answer a collection of objects that are 'dependent' on the receiver;	 that is, all objects that should be notified if the receiver changes."	(DependentsFields includesKey: self)		ifTrue: [^ DependentsFields at: self]		ifFalse: [^ #()].! !!Object methodsFor: 'dependents access'!evaluate: actionBlock wheneverChangeIn: aspectBlock	| viewerThenObject objectThenViewer |	objectThenViewer _ self.	viewerThenObject _ ObjectViewer on: objectThenViewer.	objectThenViewer become: viewerThenObject.	"--- Then ---"	objectThenViewer xxxViewedObject: viewerThenObject			evaluate: actionBlock			wheneverChangeIn: aspectBlock! !!Object methodsFor: 'dependents access'!removeDependent: anObject	"Remove the given object as one of the receiver's dependents."	| dependents newDependents |	dependents _ self dependents.	newDependents _ dependents select: [ :d | (d == anObject) not].	newDependents isEmpty		ifTrue: [DependentsFields removeKey: self ifAbsent: []]		ifFalse: [DependentsFields at: self put: newDependents].! !!Object methodsFor: 'printing' stamp: 'di 6/20/97 08:57'!fullPrintString	"Answer a String whose characters are a description of the receiver."	^ String streamContents: [:s | self printOn: s]! !!Object methodsFor: 'printing' stamp: 'di 6/20/97 09:22'!printString	"Answer a String whose characters are a description of the receiver.	If you want to print without a character limit, use fullPrintString."	| limit limitedString |	limit _ 50000.	limitedString _ String streamContents: [:s | self printOn: s] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , '...etc...'! !!Object methodsFor: 'printing' stamp: 'di 6/20/97 09:12'!storeString	"Answer a String representation of the receiver from which the receiver 	can be reconstructed."	^ String streamContents: [:s | self storeOn: s]! !!Object methodsFor: 'message handling'!perform: selector withArguments: anArray 	"Primitive. Send the receiver the keyword message indicated by the 	arguments. The argument, selector, is the selector of the message. The 	arguments of the message are the elements of anArray. Invoke 	messageNotUnderstood: if the number of arguments expected by the 	selector is not the same as the length of anArray. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 84>	(selector isMemberOf: Symbol)		ifFalse: [^ self error: 'selector argument must be a Symbol'].	self primitiveFailed! !!Object methodsFor: 'error handling'!confirm: queryString 	"Put up a yes/no menu with caption aString. Answer true if the response is yes, false if no. This is a modal question--the user must respond yes or no."	"nil confirm: 'Are you hungry?'"	^ SelectionMenu confirm: queryString! !!Object methodsFor: 'error handling'!doesNotUnderstand: aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message (typically sent from the machine when a message is sent to the receiver and no method is defined for that selector)."	"Unless the receiver has an error handler defined for the active process, report to the user that the receiver does not understand the argument, aMessage, as a message."	"Testing: (3 activeProcess)"	| handler errorString |	(Preferences autoAccessors and: [self tryToDefineVariableAccess: aMessage])		ifTrue: [^ aMessage sentTo: self].	errorString _ 'Message not understood: ', aMessage selector.	(handler _ Processor activeProcess errorHandler) notNil		ifTrue: [handler value: errorString value: self]		ifFalse: [DebuggerView openContext: thisContext					label: errorString					contents: thisContext shortStack].	^ aMessage sentTo: self! !!Object methodsFor: 'error handling'!error: aString 	"The default behavior for error: is the same as halt:. The code is 	replicated in order to avoid showing an extra level of message sending 	in the Debugger. This additional message is the one a subclass should 	override in order to change the error handling behavior."	| handler |	(handler _ Processor activeProcess errorHandler) notNil		ifTrue:			[handler  value: aString value: self]		ifFalse: 			[DebuggerView				openContext: thisContext				label: aString				contents: thisContext shortStack]	"nil error: 'error message'."! !!Object methodsFor: 'user interface'!basicInspect	"Create and schedule an Inspector in which the user can examine the 	receiver's variables. This method should not be overriden."	Inspector openOn: self withEvalPane: false! !!Object methodsFor: 'user interface'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ self class name! !!Object methodsFor: 'user interface' stamp: 'sw 8/15/97 17:25'!fullScreenSize	"Answer the size to which a window displaying the receiver should be set"	| adj |	adj _ (3 * Preferences scrollBarWidth) @ 0.	^ Rectangle origin: adj extent: (DisplayScreen actualScreenSize - adj)! !!Object methodsFor: 'user interface' stamp: 'tk 11/3/97 17:47'!inform: aString	"Display a message for the user to read and then dismiss.  6/9/96 sw"	aString size > 0 ifTrue: [(PopUpMenu labels: '  OK  ') startUpWithCaption: aString]! !!Object methodsFor: 'user interface' stamp: 'di 6/24/97 11:47'!inspect	"Create and schedule an Inspector in which the user can examine the 	receiver's variables."	| insp |	World ifNotNil:		["Written so that Morphic can still be removed."		insp _ (Smalltalk at: #ObjectInspector) on: self.		^ self world addMorph: insp; startStepping: insp].	Inspector openOn: self withEvalPane: true! !!Object methodsFor: 'user interface'!inspectWithLabel: aLabel	Inspector openOn: self withEvalPane: true withLabel: aLabel! !!Object methodsFor: 'user interface' stamp: 'sw 7/28/97 17:11'!smartInspect	"Like inspect, but for collections with only one element, inspects that element"	^ self inspect! !!Object methodsFor: 'system primitives' stamp: 'tk 5/5/97'!instVarNamed: aString	"Return the value of the instance variabvle in me with that name.  Slow and unclean, but very useful.  "	^ self instVarAt: ((self class allInstVarNames) indexOf: aString)! !!Object methodsFor: 'system primitives' stamp: 'tk 5/5/97'!instVarNamed: aString put: aValue	"Store into the value of the instance variable in me of that name.  Slow and unclean, but very useful.  "	^ self instVarAt: ((self class allInstVarNames) indexOf: aString) put: aValue! !!Object methodsFor: 'system primitives' stamp: 'di 1/12/98 14:43'!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118>	^ #simulatorFail! !!Object methodsFor: 'private' stamp: 'di 6/17/97 08:59'!primitiveError: aString 	"This method is called when the error handling results in a recursion in calling	on error: or halt or halt:."	| context |	(String streamContents:		[:s |		s nextPutAll: '**System Error Handling Failed** '.		s cr; nextPutAll: aString.		context _ thisContext sender sender.		6 timesRepeat: 			[context == nil ifFalse: [s cr; print: (context _ context sender)]].		s cr; nextPutAll: '**Type any character to restart.**'])		displayAt: 0@0.	[Sensor keyboardPressed] whileFalse.	Sensor keyboard.	ScheduledControllers searchForActiveController! !!Object methodsFor: 'converting'!asString	"Answer a string that represents the receiver."	^ self printString ! !!Object methodsFor: 'macpal' stamp: 'sw 10/13/97 16:38'!ifKindOf: aClass thenDo: aBlock	^ (self isKindOf: aClass) ifTrue: [aBlock value: self]! !!Object methodsFor: 'flagging' stamp: 'sw 8/4/97 16:54'!break	^ self break: 'Break: ', thisContext sender printString! !!Object methodsFor: 'flagging' stamp: 'sw 8/4/97 16:49'!isThisEverCalled	^ self isThisEverCalled: thisContext sender printString! !!Object methodsFor: 'flagging' stamp: 'sw 8/8/97 18:58'!logEntry	^ self showInTranscript:  'Entered ', thisContext sender printString! !!Object methodsFor: 'flagging' stamp: 'sw 8/8/97 18:59'!logExecution	^ self showInTranscript:  'Executing ', thisContext sender printString! !!Object methodsFor: 'flagging' stamp: 'sw 8/8/97 18:58'!logExit	^ self showInTranscript:  'Exitted ', thisContext sender printString! !!Object methodsFor: 'translation support'!cCode: codeString	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'translation support'!cCoerce: value to: cType	"Type coercion for translation only; just return the value when running in Smalltalk."	^ value! !!Object methodsFor: 'translation support'!inline: inlineFlag	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'translation support'!returnTypeC: typeString	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'translation support'!sharedCodeNamed: label inCase: caseNumber	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'translation support'!var: varSymbol declareC: declString	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'objects from disk' stamp: 'tk 1/8/97'!readDataFrom: aDataStream size: varsOnDisk	"Make self be an object based on the contents of aDataStream, which was	   generated by the objects storeDataOn: method. Return self.	 Read in the instance-variables written by Object>>storeDataOn:.	 NOTE: This method must match its corresponding storeDataOn:	   method. Also, it must send beginReference: after instantiating	   the new object but before reading any objects from aDataStream	   that might reference it.	: allow fewer inst vars, instance does reading, see SmartRefStream."	| cntInstVars cntIndexedVars |	cntInstVars _ self class instSize.	self class isVariable		ifTrue: [cntIndexedVars _ varsOnDisk - cntInstVars.				cntIndexedVars < 0 ifTrue: [					self error: 'Class has changed too much.  Define a convertxxx method']]		ifFalse: [cntIndexedVars _ 0.				cntInstVars _ varsOnDisk]. 	"OK if fewer than now"	aDataStream beginReference: self.	1 to: cntInstVars do:		[:i | self instVarAt: i put: aDataStream next].	1 to: cntIndexedVars do:		[:i | self basicAt: i put: aDataStream next].	"Total number read MUST be equal to varsOnDisk!!"	^ self! !!Object methodsFor: 'objects from disk' stamp: 'tk 6/26/97 13:48'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  Does not file out the class of the object.  tk 6/26/97 13:48"	| aFileName fileStream |	aFileName _ self class name asFileName.	"do better?"	aFileName _ FillInTheBlank request: 'File name?' initialAnswer: aFileName.	aFileName size == 0 ifTrue: [^ self beep].	fileStream _ FileStream newFileNamed: aFileName.	fileStream fileOutClass: nil andObject: self.! !!Object methodsFor: 'objects from disk' stamp: 'jm 12/3/97 21:46'!storeDataOn: aDataStream	"Store myself on a DataStream. Answer self.  This is a low-level DataStream/ReferenceStream method. See also objectToStoreOnDataStream.	 NOTE: This method must send 'aDataStream beginInstance:size:'		and then put a number of objects (via aDataStream nextPut:/nextPutWeak:).	 Cf. readDataFrom:size:, which must read back what this puts	when given the size that it gave to beginInstance:size:. -- 11/15/92 jhm"	| cntInstVars cntIndexedVars |	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !!Object class methodsFor: 'class initialization'!initializeOnceOnly 	"Refer to the comment in Class|initialize.  This is the initilaize message for Object class, but if called initialize, then all classes would inherit it as a class message, and clearly this is not the default desired."	self initializeDependentsFields.  "Note this will disconnect views!!"	self initializeErrorRecursion.	"Object initializeOnceOnly"! !!Object class methodsFor: 'instance creation' stamp: 'sw 7/28/97 15:56'!chooseUniqueClassName	| i className |	i _ 1.	[className _ (self name , i printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [i _ i + 1].	^ className! !!Object class methodsFor: 'instance creation' stamp: 'sw 7/28/97 15:56'!copyMethodDictionaryFrom: donorClass	"Copy the method dictionary of the donor class over to the receiver"	methodDict _ donorClass copyOfMethodDictionary.	organization _ donorClass organization deepCopy! !!Object class methodsFor: 'instance creation' stamp: 'sw 8/12/97 17:56'!instanceOfUniqueClass	"Create a unique class for the receiver, and answer an instance of it"	| aName aClass |	self isSystemDefined ifFalse:		[^ superclass instanceOfUniqueClass].	aName _ self chooseUniqueClassName.	aClass _ self subclass: aName instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'Morphic-UserObjects'.	^ aClass new! !!Object class methodsFor: 'instance creation' stamp: 'sw 8/12/97 17:57'!isSystemDefined	"Answer whether the receiver is a system-defined class or a unique-instance user subclass"	^ self name endsWithDigit not! !!Object class methodsFor: 'instance creation' stamp: 'sw 7/28/97 15:56'!loneInstance	"Answer the lone instance of the receiver, or nil if none"	^ self someInstance! !!Object class methodsFor: 'instance creation' stamp: 'sw 7/28/97 15:56'!newUserInstance	"Answer an instance of an appropriate class to serve as a user object in the containment hierarchy"	^ self instanceOfUniqueClass! !!Object class methodsFor: 'objects from disk' stamp: 'tk 1/8/97'!createFrom: aSmartRefStream size: varsOnDisk version: instVarList	"Create an instance of me so objects on the disk can be read in.  Tricky part is computing the size if variable.  Inst vars will be filled in later.  "	^ self isVariable		ifFalse: [self basicNew]		ifTrue: ["instVarList is names of old class's inst vars plus a version number" 				self basicNew: (varsOnDisk - (instVarList size - 1))]! !!Object class methodsFor: 'objects from disk' stamp: 'tk 1/3/97'!readDataFrom: aDataStream size: varsOnDisk	"Create an object based on the contents of aDataStream, which was	   generated by the objects storeDataOn: method. Answer it.	 This implementation reads back the instance-variables written by	   Object>>storeDataOn:.	 NOTE: This method must match its corresponding storeDataOn:	   method. Also, it must send beginReference: after instantiating	   the new object but before reading any objects from aDataStream	   that might reference it.	11/23/92 jhm: Changed to basicNew & basicNew: to match basicSize and because		we then overwrite all instance & indexed vars.	: allow fewer inst vars, and total remap for others.  Let object do it."	| anObject cntInstVars cntIndexedVars |	self halt.  "Use same method in the instance side"	cntInstVars _ self instSize.	anObject _ self isVariable		ifTrue: [cntIndexedVars _ varsOnDisk - cntInstVars.				cntIndexedVars < 0 ifTrue: [self error: 'Class needs to be reshaped'].				self basicNew: cntIndexedVars]		ifFalse: [self basicNew].	^ anObject readDataFrom: aDataStream size: varsOnDisk! !!ObjectInspector methodsFor: 'initialization' stamp: 'di 6/22/97 22:53'!defaultExtent	^ 300@200! !!ObjectInspector methodsFor: 'initialization' stamp: 'di 6/22/97 23:15'!extent: newExtent	| w h inner labelRect |	super extent: newExtent.	inner _ self innerBounds.	labelRect _ inner topLeft corner: inner topRight + (0@self labelHeight).	w _ inner width - 2 // 3.  h _ inner height - labelRect height - 2 // 3.	fieldPane bounds: (labelRect bottomLeft + (1@1) extent: w @ (inner height-labelRect height - 2)).	valuePane bounds: (fieldPane bounds topRight corner: inner right - 1 @ (labelRect bottom + h)).	doitPane bounds: (valuePane bounds bottomLeft corner: inner bottomRight - 1)! !!ObjectInspector methodsFor: 'initialization' stamp: 'di 6/22/97 23:20'!initialize	super initialize.	fieldIndex _ 0.	fieldPane list: self computeFieldList.! !!ObjectInspector methodsFor: 'initialization' stamp: 'di 6/18/97 09:30'!initPanes	self addMorph: (fieldPane _ ListPane new model: self slotName: 'fieldPane').	self addMorph: (valuePane _ ScrollPane new model: self slotName: 'valuePane').	self addMorph: (doitPane _ ScrollPane new model: self slotName: 'doitPane').! !!ObjectInspector methodsFor: 'initialization' stamp: 'di 6/22/97 22:38'!setObject: anObject	object _ anObject! !!ObjectInspector methodsFor: 'field list, selection' stamp: 'di 6/22/97 23:12'!computeFieldList	"Answer the base field list plus an abbreviated list of indices."	fieldList _ (Array with: 'self') , object class allInstVarNames.	object class isVariable ifFalse: [^ fieldList].	^ fieldList ,		((object basicSize <= (self nLow + self nHigh) or: [showAllIndices])			ifTrue: [(1 to: object basicSize)						collect: [:i | i printString]]			ifFalse: [(1 to: self nLow) , #('...') , (object basicSize-(self nHigh-1) to: object basicSize)						collect: [:i | i printString]])! !!ObjectInspector methodsFor: 'field list, selection' stamp: 'di 6/18/97 09:27'!fieldValue	"Answer the value of the selected variable."	| basicIndex |	fieldIndex = 1 ifTrue: [^ object].	(fieldIndex - 1) <= object class instSize		ifTrue: [^ object instVarAt: fieldIndex - 1].	basicIndex _ fieldIndex - 1 - object class instSize.	((object basicSize <= (self nLow + self nHigh) or: [basicIndex <= self nLow]) or: [showAllIndices])		ifTrue: [^ object basicAt: basicIndex].	basicIndex < object basicSize - self nHigh + 1 ifTrue: [^ nil]. "..."	^ object basicAt: object basicSize - (self nLow + self nHigh) + basicIndex! !!ObjectInspector methodsFor: 'field list, selection' stamp: 'di 6/18/97 09:16'!nHigh	"Number of indices to show at the end of an array"	^ 10! !!ObjectInspector methodsFor: 'field list, selection' stamp: 'di 6/18/97 09:16'!nLow	"Number of indices to show at the beginning of an array"	^ 100! !!ObjectInspector methodsFor: 'field list, selection' stamp: 'di 6/22/97 23:24'!updateFieldValue	fieldIndex = 0 ifTrue: [^ self].	valuePane scroller firstSubmorph contents: self fieldValue printString asText! !!ObjectInspector methodsFor: 'input events' stamp: 'di 6/22/97 23:11'!fieldPaneNewSelection: fieldString	fieldIndex _ fieldList indexOf: fieldString ifAbsent: [0].	fieldIndex = 0 ifTrue: [^ self].	valuePane scroller removeAllMorphs;		addMorph: (TextMorph new contents: self fieldValue printString asText)! !!ObjectInspector methodsFor: 'stepping' stamp: 'di 6/22/97 23:26'!step	self updateFieldValue! !!ObjectInspector methodsFor: 'stepping' stamp: 'di 6/22/97 23:27'!stepTime	^ 100 "milliseconds"! !!ObjectInspector methodsFor: 'stepping' stamp: 'di 6/22/97 23:27'!wantsSteps	^ (fieldIndex = 0) not! !!ObjectInspector class methodsFor: 'instance creation' stamp: 'di 6/22/97 22:40'!on: anObject	^ (self basicNew setLabel: anObject defaultLabelForInspector;					setObject: anObject) initialize! !ObjectMemory comment:'This class describes a 32-bit direct-pointer object memory for Smalltalk.  The model is very simple in principle:  a pointer is either a SmallInteger or a 32-bit direct object pointer.SmallIntegers are tagged with a low-order bit equal to 1, and an immediate 31-bit 2s-complement signed value in the rest of the word.All object pointers point to a header, which may be followed by a number of data fields.  This object memory achieves considerable compactness by using a variable header size (the one complexity of the design).  The format of the 0th header word is as follows:	3 bits	reserved for gc (mark, old, dirty)	12 bits	object hash (for HashSets)	5 bits	compact class index	4 bits	object format	6 bits	object size in 32-bit words	2 bits	header type (0: 3-word, 1: 2-word, 2: forbidden, 3: 1-word)If a class is in the compact class table, then this is the only header information needed.  If it is not, then it will have another header word at offset -4 bytes with its class in the high 30 bits, and the header type repeated in its low 2 bits.  It the objects size is greater than 255 bytes, then it will have yet another header word at offset -8 bytes with its full word size in the high 30 bits and its header type repeated in the low two bits.The object format field provides the remaining information as given in the formatOf: method (including isPointers, isVariable, isBytes, and the low 2 size bits of byte-sized objects).This implementation includes incremental (2-generation) and full garbage collection, each with compaction and rectification of direct pointers.  It also supports a bulk-become (exchange object identity) feature that allows many objects to be becomed at once, as when all instances of a class must be grown or shrunk.'!!ObjectMemory methodsFor: 'initialization'!adjustAllOopsBy: bytesToShift	"Adjust all oop references by the given number of bytes. This is done just after reading in an image when the new base address of the object heap is different from the base address in the image."	| oop last |	bytesToShift = 0 ifTrue: [ ^ nil ].	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifFalse: [			self adjustFieldsAndClassOf: oop by: bytesToShift. 		].		last _ oop.		oop _ self objectAfter: oop.	].! !!ObjectMemory methodsFor: 'initialization'!adjustFieldsAndClassOf: oop by: offsetBytes	"Adjust all pointers in this object by the given offset."	| fieldAddr fieldOop classHeader newClassOop |	fieldAddr _ oop + (self lastPointerOf: oop).	[fieldAddr > oop] whileTrue: [		fieldOop _ self longAt: fieldAddr.		(self isIntegerObject: fieldOop) ifFalse: [			self longAt: fieldAddr put: (fieldOop + offsetBytes).		].		fieldAddr _ fieldAddr - 4.	].	(self headerType: oop) ~= HeaderTypeShort ifTrue: [		"adjust class header if not a compact class"		classHeader _ self longAt: (oop - 4).		newClassOop _			(classHeader bitAnd: AllButTypeMask) + offsetBytes.		self longAt: (oop - 4) put: (newClassOop bitOr: (classHeader bitAnd: TypeMask)).	].! !!ObjectMemory methodsFor: 'initialization'!initializeMemoryFirstFree: firstFree 	"Initialize endOfMemory to the top of oop storage space, reserving some space for forwarding blocks, and create the freeBlock from which space is allocated. Also create a fake free chunk at endOfMemory to act as a sentinal for memory scans."	"Note: The amount of space reserved for forwarding blocks should be chosen to ensure that incremental compactions can usually be done in a single pass. However, there should be enough forwarding blocks so a full compaction can be done in a reasonable number of passes, say ten. (A full compaction requires N object-moving passes, where N = number of non-garbage objects / number of forwarding blocks)."	| fwdBlockBytes |	"reserve space for forwarding blocks"	fwdBlockBytes _ MinimumForwardTableBytes.	(memoryLimit - fwdBlockBytes) >= (firstFree + BaseHeaderSize) ifFalse: [		"reserve enough space for a minimal free block of BaseHeaderSize bytes"		fwdBlockBytes _ memoryLimit - (firstFree + BaseHeaderSize).	].	"set endOfMemory and initialize freeBlock"	endOfMemory _ memoryLimit - fwdBlockBytes.	freeBlock _ firstFree.	self setSizeOfFree: freeBlock to: (endOfMemory - firstFree).  "bytes available for oops"	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	checkAssertions ifTrue: [		((freeBlock < endOfMemory) and: [endOfMemory < memoryLimit])			ifFalse: [ self error: 'error in free space computation' ].			(self oopFromChunk: endOfMemory) = endOfMemory			ifFalse: [ self error: 'header format must have changed' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'free block not properly initialized' ].	].! !!ObjectMemory methodsFor: 'initialization' stamp: 'ikp 1/3/98 23:10'!initializeObjectMemory: bytesToShift	"Initialize object memory variables at startup time. Assume endOfMemory is initially set (by the image-reading code) to the end of the last object in the image. Initialization redefines endOfMemory to be the end of the object allocation area based on the total available memory, but reserving some space for forwarding blocks."	"Assume: image reader initializes the following variables:		memory		endOfMemory		memoryLimit		specialObjectsOop		lastHash	"	self inline: false.	checkAssertions _ false.  "set this early to allow assertions in initialization code to use it"	"set the start of the young object space"	youngStart _ endOfMemory.	self initializeMemoryFirstFree: endOfMemory.		"initializes endOfMemory, freeBlock"	"image may be at a different address; adjust oops for new location"	self adjustAllOopsBy: bytesToShift.	specialObjectsOop _ specialObjectsOop + bytesToShift.	"heavily used special objects"	nilObj	_ self splObj: NilObject.	falseObj	_ self splObj: FalseObject.	trueObj	_ self splObj: TrueObject.	rootTableCount _ 0.	child _ 0.	field _ 0.	parentField _ 0.	freeLargeContexts _ NilContext.	freeSmallContexts _ NilContext.	allocationCount _ 0.	lowSpaceThreshold _ 0.	signalLowSpace _ false.	compStart _ 0.	compEnd _ 0.	fwdTableNext _ 0.	fwdTableLast _ 0.	remapBufferCount _ 0.	allocationsBetweenGCs _ 4000.  "do incremental GC after this many allocations"	tenuringThreshold _ 2000.  "tenure all suriving objects if count is over this threshold"	"garbage collection statistics"	statFullGCs _ 0.	statFullGCMSecs _ 0.	statIncrGCs _ 0.	statIncrGCMSecs _ 0.	statTenures _ 0.! !!ObjectMemory methodsFor: 'interpreter access'!fetchByte: byteIndex ofObject: oop	^ self byteAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + byteIndex! !!ObjectMemory methodsFor: 'interpreter access'!fetchClassOf: oop	| ccIndex |	self inline: true.	(self isIntegerObject: oop)		ifTrue: [ ^ self splObj: ClassInteger ].	ccIndex _ (((self baseHeader: oop) >> 12) bitAnd: 16r1F) - 1.	ccIndex < 0		ifTrue: [ ^ (self classHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [			"look up compact class"			^ self fetchPointer: ccIndex				ofObject: (self fetchPointer: CompactClasses ofObject: specialObjectsOop)		].! !!ObjectMemory methodsFor: 'interpreter access'!fetchPointer: fieldIndex ofObject: oop	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)! !!ObjectMemory methodsFor: 'interpreter access'!fetchWord: fieldIndex ofObject: oop	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)! !!ObjectMemory methodsFor: 'interpreter access'!fetchWordLengthOf: objectPointer	| sz |	sz _ self sizeBitsOf: objectPointer.	^ (sz - BaseHeaderSize) >> 2! !!ObjectMemory methodsFor: 'interpreter access'!instantiateClass: classPointer indexableSize: size	| hash header1 header2 cClass byteSize format inc binc header3 hdrSize fillWord newObj sizeHiBits |"	NOTE: This method supports the backward-compatible split instSize field of the	class format word.  The sizeHiBits will go away and other shifts change by 2	when the split fields get merged in an (incompatible) image change."	self inline: false.	checkAssertions ifTrue: [		size < 0 ifTrue: [ self error: 'cannot have a negative indexable field count' ]].	hash _ self newObjectHash.	header1 _ self formatOfClass: classPointer. "Low 2 bits are 0"	sizeHiBits _ (header1 bitAnd: 16r60000) >> 9.	header1 _ (header1 bitAnd: 16r1FFFF) bitOr: (hash << 17 bitAnd: 16r1FFE0000).	header2 _ classPointer.	header3 _ 0.	cClass _ header1 bitAnd: 16r1F000. "compact class field from format word"	byteSize _ (header1 bitAnd: 16rFC) + sizeHiBits. "size in bytes -- low 2 bits are 0"	format _ (header1 >> 8) bitAnd: 16rF.	format < 8 ifTrue: [		"Bitmaps and Arrays"		inc _ size * 4.	] ifFalse: [		"Strings and Methods"		inc _ (size + 3) bitAnd: 16r1FFFFFFC. "round up"		binc _ 3 - ((size + 3) bitAnd: 3). "odd bytes"		"low bits of byte size go in format field"		header1 _ header1 bitOr: (binc << 8).	].	(byteSize + inc) > 255 ifTrue: [		"requires size header word"		header3 _ byteSize + inc.		header1 _ header1 - (byteSize bitAnd: 16rFF).  "Clear qsize field"	] ifFalse: [		header1 _ header1 + inc.	].	byteSize _ byteSize + inc.	header3 > 0 ifTrue: [		"requires full header"		hdrSize _ 3.	] ifFalse: [		cClass = 0			ifTrue: [ hdrSize _ 2 ]			ifFalse: [ hdrSize _ 1 ].	].	format < 4  "if pointers, fill with nil oop"		ifTrue: [ fillWord _ nilObj ]		ifFalse: [ fillWord _ 0 ].	newObj _ self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 fill: fillWord.	^ newObj! !!ObjectMemory methodsFor: 'interpreter access'!instantiateSmallClass: classPointer sizeInBytes: sizeInBytes fill: fillValue	"This version of instantiateClass assumes that the total object size is under 256 bytes, the limit for objects with only one or two header words. Note that the size is specified in bytes and should include four bytes for the base header word."	| hash header1 header2 hdrSize |	hash _ self newObjectHash.	header1 _ ((hash << 17) bitAnd: 16r1FFE0000) bitOr:			   (self formatOfClass: classPointer).	header1 _ header1 + (sizeInBytes - (header1 bitAnd: 16rFC)).	header2 _ classPointer.	(header1 bitAnd: 16r1F000) = 0 "is compact class field from format word zero?"		ifTrue: [ hdrSize _ 2 ]		ifFalse: [ hdrSize _ 1 ].	^ self allocate: sizeInBytes headerSize: hdrSize h1: header1 h2: header2 h3: 0 fill: fillValue! !!ObjectMemory methodsFor: 'interpreter access'!integerObjectOf: value	value < 0		ifTrue: [^ ((16r80000000 + value) << 1) + 1]		ifFalse: [^ (value << 1) + 1]! !!ObjectMemory methodsFor: 'interpreter access'!integerValueOf: objectPointer	"Translator produces 'objectPointer >> 1'"	((objectPointer bitAnd: 16r80000000) ~= 0)		ifTrue: ["negative"				^ ((objectPointer bitAnd: 16r7FFFFFFF) >> 1)					- 16r3FFFFFFF - 1  "Faster than -16r40000000 (a LgInt)"]		ifFalse: ["positive"				^ objectPointer >> 1]! !!ObjectMemory methodsFor: 'interpreter access'!isIntegerObject: objectPointer	^ (objectPointer bitAnd: 1) > 0! !!ObjectMemory methodsFor: 'interpreter access'!isIntegerValue: intValue	"Return true if the given value can be represented as a Smalltalk integer value."	"Details: This trick is from Tim Rowledge. Use a shift and XOR to set the sign bit if and only if the top two bits of the given value are the same, then test the sign bit. Note that the top two bits are equal for exactly those integers in the range that can be represented in 31-bits."	^ (intValue bitXor: (intValue << 1)) >= 0! !!ObjectMemory methodsFor: 'interpreter access'!nilObject  "For access from BitBlt module"	^ nilObj! !!ObjectMemory methodsFor: 'interpreter access'!popRemappableOop	"Pop and return the possibly remapped object from the remap buffer."	| oop |	oop _ remapBuffer at: remapBufferCount.	remapBufferCount _ remapBufferCount - 1.	^ oop! !!ObjectMemory methodsFor: 'interpreter access'!pushRemappableOop: oop	"Record the given object in a the remap buffer. Objects in this buffer are remapped when a compaction occurs. This facility is used by the interpreter to ensure that objects in temporary variables are properly remapped."	remapBuffer at: (remapBufferCount _ remapBufferCount + 1) put: oop.! !!ObjectMemory methodsFor: 'interpreter access'!splObj: index	"Return one of the objects in the SpecialObjectsArray"	^ self fetchPointer: index ofObject: specialObjectsOop! !!ObjectMemory methodsFor: 'interpreter access'!storeByte: byteIndex ofObject: oop withValue: valueByte	^ self byteAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + byteIndex		put: valueByte! !!ObjectMemory methodsFor: 'interpreter access'!storePointer: fieldIndex ofObject: oop withValue: valuePointer	"Note must check here for stores of young objects into old ones."	(oop < youngStart) ifTrue: [		self possibleRootStoreInto: oop value: valuePointer.	].	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)		put: valuePointer! !!ObjectMemory methodsFor: 'interpreter access'!storePointerUnchecked: fieldIndex ofObject: oop withValue: valuePointer	"Like storePointer:ofObject:withValue:, but the caller guarantees that the object being stored into is a young object or is already marked as a root."	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)			put: valuePointer! !!ObjectMemory methodsFor: 'interpreter access'!storeWord: fieldIndex ofObject: oop withValue: valueWord	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)		put: valueWord! !!ObjectMemory methodsFor: 'memory access'!checkAddress: byteAddress	"Keep this method around for debugging the C code."	byteAddress < (self startOfMemory) ifTrue: [		self error: 'bad address: negative'.	].	byteAddress >= memoryLimit ifTrue: [		self error: 'bad address: past end of heap'.	].! !!ObjectMemory methodsFor: 'memory access'!checkedByteAt: byteAddress	"Assumes zero-based array indexing."	self checkAddress: byteAddress.	^ self byteAt: byteAddress! !!ObjectMemory methodsFor: 'memory access'!checkedByteAt: byteAddress put: byte	"Assumes zero-based array indexing."	self checkAddress: byteAddress.	self byteAt: byteAddress put: byte.! !!ObjectMemory methodsFor: 'memory access'!checkedLongAt: byteAddress	"Assumes zero-based array indexing. For testing in Smalltalk, this method should be overridden in a subclass."	self checkAddress: byteAddress.	self checkAddress: byteAddress + 3.	^ self longAt: byteAddress! !!ObjectMemory methodsFor: 'memory access'!checkedLongAt: byteAddress put: a32BitInteger	"Assumes zero-based array indexing. For testing in Smalltalk, this method should be overridden in a subclass."	self checkAddress: byteAddress.	self checkAddress: byteAddress + 3.	self longAt: byteAddress put: a32BitInteger.! !!ObjectMemory methodsFor: 'header access'!baseHeader: oop	^ self longAt: oop! !!ObjectMemory methodsFor: 'header access'!classHeader: oop	^ self longAt: oop - 4! !!ObjectMemory methodsFor: 'header access'!formatOf: oop"       0      no fields        1      fixed fields only (possibly containing pointers)        2      indexable fields only (possibly containing pointers)        3      both fixed and indexable fields (possibly containing pointers)         4      unused  -- may use for contexts (size = stackPointer for scanning purposes)        5      unused        6      indexable word fields only (no pointers)        7      unused     8-11      indexable byte fields only (no pointers) (low 2 bits are low 2 bits of size)   12-15     compiled methods:                   # of literal oops specified in method header,                   followed by indexable bytes (same interpretation of low 2 bits as above)"	^ ((self baseHeader: oop) >> 8) bitAnd: 16rF! !!ObjectMemory methodsFor: 'header access'!hashBitsOf: oop	^ ((self baseHeader: oop) >> 17) bitAnd: 16rFFF! !!ObjectMemory methodsFor: 'header access'!headerType: oop	^ (self longAt: oop) bitAnd: TypeMask! !!ObjectMemory methodsFor: 'header access'!isBytes: oop	"Answer true if the argument contains indexable bytes. See comment in formatOf:"	"Note: Includes CompiledMethods."	^ (self formatOf: oop)  >= 8! !!ObjectMemory methodsFor: 'header access'!isFreeObject: oop	^ (self headerType: oop) = HeaderTypeFree! !!ObjectMemory methodsFor: 'header access'!isPointers: oop	"Answer true if the argument has only fields that can hold oops. See comment in formatOf:"	^ (self formatOf: oop) <= 4! !!ObjectMemory methodsFor: 'header access'!isWords: oop	"Answer true if the argument contains only indexable words (no oops). See comment in formatOf:"	^ (self formatOf: oop) = 6! !!ObjectMemory methodsFor: 'header access'!isWordsOrBytes: oop	"Answer true if the contains only indexable words or bytes (no oops). See comment in formatOf:"	"Note: Excludes CompiledMethods."	| fmt |	fmt _ self formatOf: oop.	^ fmt = 6 or: [(fmt >= 8) and: [fmt <= 11]]! !!ObjectMemory methodsFor: 'header access'!newObjectHash	"Answer a new 16-bit pseudo-random number for use as an identity hash."	lastHash _ 13849 + (27181 * lastHash) bitAnd: 65535.	^ lastHash! !!ObjectMemory methodsFor: 'header access'!rightType: headerWord	"Computer the correct header type for an object based on the size and compact class fields of the given base header word, rather than its type bits. This is used during marking, when the header type bits are used to record the state of tracing."	(headerWord bitAnd: 16rFC) = 0  "zero size field in header word"		ifTrue: [ ^ HeaderTypeSizeAndClass ]		ifFalse: [			(headerWord bitAnd: 16r1F000) = 0  "zero compact class field  in header word"				ifTrue: [ ^ HeaderTypeClass ]				ifFalse: [ ^ HeaderTypeShort ]].! !!ObjectMemory methodsFor: 'header access'!setSizeOfFree: chunk to: byteSize	"Set the header of the given chunk to make it be a free chunk of the given size."	self longAt: chunk put: ((byteSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).! !!ObjectMemory methodsFor: 'header access'!sizeBitsOf: oop	"Answer the number of bytes in the given object, including its base header, rounded up to an integral number of words."	"Note: byte indexable objects need to have low bits subtracted from this size."	| header |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: 16rFC ].! !!ObjectMemory methodsFor: 'header access'!sizeBitsOfSafe: oop	"Compute the size of the given object from the cc and size fields in its header. This works even if its type bits are not correct."	| header type |	header _ self baseHeader: oop.	type _ self rightType: header.	type = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: 16rFC ].! !!ObjectMemory methodsFor: 'header access'!sizeHeader: oop	^ self longAt: oop - 8! !!ObjectMemory methodsFor: 'header access'!sizeOfFree: oop	"Return the size of the given chunk in bytes. Argument MUST be a free chunk."	^ (self longAt: oop) bitAnd: FreeSizeMask! !!ObjectMemory methodsFor: 'object enumeration'!accessibleObjectAfter: oop	"Return the accessible object following the given object or free chunk in the heap. Return nil when heap is exhausted."	| obj |	self inline: false.	obj _ self objectAfter: oop.	[obj < endOfMemory] whileTrue: [		(self isFreeObject: obj) ifFalse: [ ^obj ].		obj _ self objectAfter: obj.	].	^ nil! !!ObjectMemory methodsFor: 'object enumeration'!firstAccessibleObject	"Return the first accessible object in the heap."	| obj |	obj _ self firstObject.	[obj < endOfMemory] whileTrue: [		(self isFreeObject: obj) ifFalse: [ ^obj ].		obj _ self objectAfter: obj.	].	self error: 'heap is empty'! !!ObjectMemory methodsFor: 'object enumeration'!firstObject	"Return the first object or free chunk in the heap."	^ self oopFromChunk: self startOfMemory! !!ObjectMemory methodsFor: 'object enumeration'!initialInstanceOf: classPointer	"Support for instance enumeration. Return the first instance of the given class, or nilObj if it has no instances."	| thisObj thisClass |	thisObj _ self firstAccessibleObject.	[thisObj = nil] whileFalse: [		thisClass _ self fetchClassOf: thisObj.		thisClass = classPointer ifTrue: [ ^thisObj ].		thisObj _ self accessibleObjectAfter: thisObj.	].	^nilObj! !!ObjectMemory methodsFor: 'object enumeration'!instanceAfter: objectPointer	"Support for instance enumeration. Return the next instance of the class of the given object, or nilObj if the enumeration is complete."	| classPointer thisObj thisClass |	classPointer _ (self fetchClassOf: objectPointer).	thisObj _ self accessibleObjectAfter: objectPointer.	[thisObj = nil] whileFalse: [		thisClass _ self fetchClassOf: thisObj.		thisClass = classPointer ifTrue: [ ^thisObj ].		thisObj _ self accessibleObjectAfter: thisObj.	].	^nilObj! !!ObjectMemory methodsFor: 'object enumeration'!lastPointerOf: objectPointer	"Return the byte offset of the last pointer field of the given object. Works with CompiledMethods, as well as ordinary objects. Can be used even when the type bits are not correct."	| fmt sz methodHeader |	self inline: true.	fmt _ self formatOf: objectPointer.	fmt < 4 ifTrue: [		sz _ self sizeBitsOfSafe: objectPointer.		^ sz - BaseHeaderSize  "all pointers"	].	fmt < 12 ifTrue: [ ^0 ].  "no pointers"	"CompiledMethod: contains both pointers and bytes:"	methodHeader _ self longAt: objectPointer + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'object enumeration'!objectAfter: oop	"Return the object or free chunk immediately following the given object or free chunk in memory. Return endOfMemory when enumeration is complete."	| sz |	self inline: true.	checkAssertions ifTrue: [		oop >= endOfMemory ifTrue: [ self error: 'no objects after the end of memory' ].	].	(self isFreeObject: oop)		ifTrue: [ sz _ self sizeOfFree: oop ]		ifFalse: [ sz _ self sizeBitsOf: oop ].	^ self oopFromChunk: (oop + sz)! !!ObjectMemory methodsFor: 'object enumeration'!startOfMemory	"Return the start of object memory."	^ self cCode: '(int) memory'! !!ObjectMemory methodsFor: 'oop/chunk conversion'!chunkFromOop: oop	"Compute the chunk of this oop by subtracting its extra header bytes."	| extra |	extra _ self extraHeaderBytes: oop.	^ oop - extra! !!ObjectMemory methodsFor: 'oop/chunk conversion'!extraHeaderBytes: oopOrChunk	"Return the number of extra bytes used by the given object's header."	"Warning: This method should not be used during marking, when the header type bits of an object may be incorrect."	| type extra |	self inline: true.	type _ self headerType: oopOrChunk.	type > 1 ifTrue: [		extra _ 0.  "free chunk (type 2) or 1-word header (type 3); most common"	] ifFalse: [		type = 1			ifTrue: [ extra _ 4.  "2-word header (type 1)" ]			ifFalse: [ extra _ 8.  "3-word header (type 0)" ].	].	^ extra! !!ObjectMemory methodsFor: 'oop/chunk conversion'!oopFromChunk: chunk	"Compute the oop of this chunk by adding its extra header bytes."	| extra |	extra _ self extraHeaderBytes: chunk.	^ chunk + extra! !!ObjectMemory methodsFor: 'allocation'!allocate: byteSize headerSize: hdrSize h1: baseHeader h2: classOop h3: extendedSize fill: fillWord	"Allocate a new object of the given size and number of header words. (Note: byteSize already includes space for the base header word.) Initialize the header fields of the new object and fill the remainder of the object with the given value."	| newObj remappedClassOop end i |	self inline: true.	"remap classOop in case GC happens during allocation"	hdrSize > 1 ifTrue: [ self pushRemappableOop: classOop ].  	newObj _ self allocateChunk: byteSize + ((hdrSize - 1) * 4).	hdrSize > 1 ifTrue: [ remappedClassOop _ self popRemappableOop ].	hdrSize = 3 ifTrue: [		self longAt: newObj      put: (extendedSize bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 4 put: (remappedClassOop bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 8 put: (baseHeader bitOr: HeaderTypeSizeAndClass).		newObj _ newObj + 8.	].	hdrSize = 2 ifTrue: [		self longAt: newObj      put: (remappedClassOop bitOr: HeaderTypeClass).		self longAt: newObj + 4 put: (baseHeader bitOr: HeaderTypeClass).		newObj _ newObj + 4.	].	hdrSize = 1 ifTrue: [		self longAt: newObj put: (baseHeader bitOr: HeaderTypeShort).	].	"clear new object"	end _ newObj + byteSize.	i _ newObj + 4.	[i < end] whileTrue: [		self longAt: i put: fillWord.		i _ i + 4.	].	checkAssertions ifTrue: [		self okayOop: newObj.		self oopHasOkayClass: newObj.		(self objectAfter: newObj) = freeBlock			ifFalse: [ self error: 'allocate bug: did not set header of new oop correctly' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'allocate bug: did not set header of freeBlock correctly' ].	].	^ newObj! !!ObjectMemory methodsFor: 'allocation' stamp: 'jm 9/14/97 11:14'!allocateChunk: byteSize 	"Allocate a chunk of the given size. Sender must be sure that the requested size includes enough space for the header word(s)."	"Details: To limit the time per incremental GC, do one every so many allocations."	| enoughSpace newFreeSize newChunk |	self inline: true.	allocationCount >= allocationsBetweenGCs ifTrue: [		"do an incremental GC every so many allocations to keep pauses short"		self incrementalGC.	].	enoughSpace _ self sufficientSpaceToAllocate: byteSize.	enoughSpace ifFalse: [		"signal that space is running low, put proceed with allocation if possible"		signalLowSpace _ true.		lowSpaceThreshold _ 0.  "disable additional interrupts until lowSpaceThreshold is reset by image"		interruptCheckCounter _ 0.	].	(self sizeOfFree: freeBlock) < (byteSize + BaseHeaderSize) ifTrue: [		self error: 'out of memory'.	].	"if we get here, there is enough space for allocation to succeed"	newFreeSize _ (self sizeOfFree: freeBlock) - byteSize.	newChunk _ freeBlock.	freeBlock _ freeBlock + byteSize.	"Assume: client will initialize object header of free chunk, so following is not needed:"	"self setSizeOfFree: newChunk to: byteSize."	self setSizeOfFree: freeBlock to: newFreeSize.	allocationCount _ allocationCount + 1.	^ newChunk! !!ObjectMemory methodsFor: 'allocation'!allocateOrRecycleContext: smallContextWanted	"Return a recycled context or a newly allocated one if none is available for recycling. The argument indicates that a small context is wanted."	| cntxt |	self inline: true.	smallContextWanted ifTrue: [		freeSmallContexts ~= NilContext ifTrue: [			cntxt _ freeSmallContexts.			freeSmallContexts _ self fetchPointer: 0 ofObject: cntxt.		] ifFalse: [			cntxt _ self instantiateSmallClass: (self splObj: ClassMethodContext)								 sizeInBytes: SmallContextSize										 fill: nilObj.		].	] ifFalse: [		freeLargeContexts ~= NilContext ifTrue: [			cntxt _ freeLargeContexts.			freeLargeContexts _ self fetchPointer: 0 ofObject: cntxt.		] ifFalse: [			cntxt _ self instantiateSmallClass: (self splObj: ClassMethodContext)								sizeInBytes: LargeContextSize										fill: nilObj.		].	].	^ cntxt! !!ObjectMemory methodsFor: 'allocation'!clone: oop	"Return a shallow copy of the given object."	"Assume: Oop is a real object, not a small integer."	| extraHdrBytes bytes newChunk remappedOop fromIndex toIndex lastFrom newOop header hash |	self inline: false.	extraHdrBytes _ self extraHeaderBytes: oop.	bytes _ self sizeBitsOf: oop.	bytes _ bytes + extraHdrBytes.	"allocate space for the copy, remapping oop in case of a GC"	self pushRemappableOop: oop.	newChunk _ self allocateChunk: bytes.	remappedOop _ self popRemappableOop.	"copy old to new including all header words"	toIndex _ newChunk - 4.  "loop below uses pre-increment"	fromIndex _ (remappedOop - extraHdrBytes) - 4.	lastFrom _ fromIndex + bytes.	[fromIndex < lastFrom] whileTrue: [		self longAt: (toIndex _ toIndex + 4)			put: (self longAt: (fromIndex _ fromIndex + 4)).	].	newOop _ newChunk + extraHdrBytes.  "convert from chunk to oop"	"fix base header: compute new hash and clear Mark and Root bits"	hash _ self newObjectHash.	header _ (self longAt: newOop) bitAnd: 16r1FFFF.		"use old ccIndex, format, size, and header-type fields"	header _ header bitOr: ((hash << 17) bitAnd: 16r1FFE0000).	self longAt: newOop put: header.	^ newOop! !!ObjectMemory methodsFor: 'allocation'!recycleContextIfPossible: cntxOop methodContextClass: methodCntxClass	"If possible, save the given context on a list of free contexts to be recycled."	"Note: The context is not marked free, so it can be reused with minimal fuss. It's fields are nil-ed out when it is re-used. The recycled context lists are cleared at every garbage collect."	"Note: This code was found to be critical to good send/return speed, so it has been ruthlessly hand-tuned."	| cntxHeader ccField isMethodCntx |	self inline: true.	"only recycle young contexts (which should be most of them)"	cntxOop >= youngStart ifTrue: [		"is the context of class methodCntxClass?"		cntxHeader _ self baseHeader: cntxOop.		ccField _ cntxHeader bitAnd: 16r1F000.		ccField = 0 ifTrue: [			isMethodCntx _ ((self classHeader: cntxOop) bitAnd: AllButTypeMask) = methodCntxClass.		] ifFalse: [			"compare ccField with compact class bits from format word of methodCntxClass"			isMethodCntx _ ccField = ((self formatOfClass: methodCntxClass) bitAnd: 16r1F000).		].		isMethodCntx ifTrue: [			"Note: The following test depends on the format of object headers			 and the fact that both small and large contexts are small enough			 for their size to be encoded in the base object header. If these			 assumptions is false, contexts won't be recycled properly, but the			 code should not break."			(cntxHeader bitAnd: 16rFC) = SmallContextSize ifTrue: [				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeSmallContexts.				freeSmallContexts _ cntxOop.				] ifFalse: [				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeLargeContexts.				freeLargeContexts _ cntxOop.				].		].	].! !!ObjectMemory methodsFor: 'allocation'!sufficientSpaceAfterGC: minFree	"Return true if there is enough free space after doing a garbage collection. If not, signal that space is low."	self inline: false.	self incrementalGC.  "try to recover some space"	(self sizeOfFree: freeBlock) < minFree ifTrue: [		signalLowSpace ifTrue: [ ^ false ].  "give up; problem is already noted"		self fullGC.  "try harder"		"for stability, require more free space after doing an expensive full GC"		(self sizeOfFree: freeBlock) < (minFree + 15000) ifTrue: [ ^ false ].  "still not enough"	].	^ true! !!ObjectMemory methodsFor: 'allocation'!sufficientSpaceToAllocate: bytes	"Return true if there is enough space to allocate the given number of bytes, perhaps after doing a garbage collection."	| minFree |	self inline: true.	minFree _ lowSpaceThreshold + bytes + BaseHeaderSize.	"check for low-space"	(self sizeOfFree: freeBlock) >= minFree ifTrue: [		^ true.	] ifFalse: [		^ self sufficientSpaceAfterGC: minFree.	].! !!ObjectMemory methodsFor: 'garbage collection'!beRootIfOld: oop	"Record that the given oop in the old object area may point to an object in the young area."	| header |	self inline: false.	((oop < youngStart) and: [(self isIntegerObject: oop) not]) ifTrue: [		"oop is in the old object area"		header _ self longAt: oop.		(header bitAnd: RootBit) = 0 ifTrue: [			"record oop as root only if not already recorded"			rootTableCount < RootTableSize ifTrue: [				"record root only if there is room in the roots table"				rootTableCount _ rootTableCount + 1.				rootTable at: rootTableCount put: oop.				self longAt: oop put: (header bitOr: RootBit).			].		].	].! !!ObjectMemory methodsFor: 'garbage collection'!clearRootsTable	"Clear the root bits of the current roots, then empty the roots table."	"Caution: This should only be done when the young object space is empty."	| oop |	"reset the roots table (after this, all objects are old so there are no roots)"	1 to: rootTableCount do: [ :i |		"clear root bits of current root table entries"		oop _ rootTable at: i.		self longAt: oop put: ((self longAt: oop) bitAnd: AllButRootBit).		rootTable at: i put: 0.	].	rootTableCount _ 0.! !!ObjectMemory methodsFor: 'garbage collection'!fullCompaction	"Move all accessible objects down to leave one big free chunk at the end of memory."	"Assume: Incremental GC has just been done to maximimize forwarding table space."	"need not move objects below the first free chunk"	compStart _ self lowestFreeAfter: (self startOfMemory).	compStart = freeBlock ifTrue: [		"memory is already compact; only free chunk is at the end"		^ self initializeMemoryFirstFree: freeBlock	].	"work up through memory until all free space is at the end"	[compStart < freeBlock] whileTrue: [		"free chunk returned by incCompBody becomes start of next compaction"		compStart _ self incCompBody.  "bubble of free space moves up each time"	].! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'ikp 1/14/98 01:11'!fullGC	"Do a mark/sweep garbage collection of the entire object memory. Free inaccessible objects but do not move them."	| startTime |	self inline: false.	self preGCAction: true.	startTime _ self ioMicroMSecs.	self clearRootsTable.	youngStart _ self startOfMemory.  "process all of memory"	self markPhase.	self sweepPhase.	self fullCompaction.	allocationCount _ 0.	statFullGCs _ statFullGCs + 1.	statFullGCMSecs _ statFullGCMSecs + (self ioMicroMSecs - startTime).	youngStart _ freeBlock.  "reset the young object boundary"	self postGCAction.! !!ObjectMemory methodsFor: 'garbage collection'!incrementalCompaction	"Move objects down to make one big free chunk. Compact the last N objects (where N = number of forwarding table entries) of the young object area."	"Assume: compStart was set during the sweep phase"	compStart = freeBlock ifTrue: [		"Note: If compStart = freeBlock then either the young space is already compact		 or there are enough forwarding table entries to do a one-pass incr. compaction."		self initializeMemoryFirstFree: freeBlock.	] ifFalse: [		self incCompBody.	].! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'ikp 1/14/98 01:19'!incrementalGC	"Do a mark/sweep garbage collection of just the young object area of object memory (i.e., objects above youngStart), using the root table to identify objects containing pointers to young objects from the old object area."	| survivorCount startTime |	self inline: false.	rootTableCount >= RootTableSize ifTrue: [		"root table overflow; cannot do an incremental GC (this should be very rare)"		^ self fullGC	].	self preGCAction: false.	"incremental GC and compaction"	startTime _ self ioMicroMSecs.	self markPhase.	survivorCount _ self sweepPhase.	self incrementalCompaction.	allocationCount _ 0.	statIncrGCs _ statIncrGCs + 1.	statIncrGCMSecs _ statIncrGCMSecs + (self ioMicroMSecs - startTime).	survivorCount > tenuringThreshold ifTrue: [		"move up the young space boundary if there are too many survivors;		 this limits the number of objects that must be processed on future		 incremental GC's"		statTenures _ statTenures + 1.		self clearRootsTable.		youngStart _ freeBlock.  "reset the young object boundary"	].	self postGCAction.! !!ObjectMemory methodsFor: 'garbage collection'!lowestFreeAfter: chunk	"Return the first free block after the given chunk in memory."	| oop oopHeader oopHeaderType oopSize |	self inline: false.	oop _ self oopFromChunk: chunk.	[oop < endOfMemory] whileTrue: [		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeFree)			ifTrue: [ ^ oop ]			ifFalse: [				oopHeaderType = HeaderTypeSizeAndClass					ifTrue: [ oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]					ifFalse: [ oopSize _ oopHeader bitAnd: 16rFC ].			].		oop _ self oopFromChunk: (oop + oopSize).	].	self error: 'expected to find at least one free object'.! !!ObjectMemory methodsFor: 'garbage collection'!possibleRootStoreInto: oop value: valueObj	"Called when storing the given value object into the given old object. If valueObj is young, record the fact that oldObj is now a root for incremental garbage collection."	"Warning: No young objects should be recorded as roots."	| header |	self inline: false.	((valueObj >= youngStart) and:	 [(self isIntegerObject: valueObj) not]) ifTrue: [		header _ self longAt: oop.		(header bitAnd: RootBit) = 0 ifTrue: [			"record oop as root only if not already recorded"			rootTableCount < RootTableSize ifTrue: [				"record root only if there is room in the roots table"				rootTableCount _ rootTableCount + 1.				rootTable at: rootTableCount put: oop.				self longAt: oop put: (header bitOr: RootBit).			].		].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep'!aComment	"The mark phase is based on a pointer reversing traversal. This is a little tricky because the class, which is needed by the traversal, may be in either the header (as a compact class index) or in the word above the header. See memo 'Revised object format'.	Compact classes are marked and traced separately.	How do you know that you are returning from having marked a class? Parent pointer has 10 in low bits.Here are the states an object may be in, followed by what to do next in brackets []:  Start Object: parentField is set, [obj _ child]:	obj is pointed at by a field in parent that is being traced now. obj is marked.		[(parent goes up to the next field) field addr _ obj. go to Upward]	obj is pointed at by a field in parent that is being traced now. obj is unmarked. obj has no pointers.		[put 10 into low bits of header. field addr _ obj. go to Start Field (to process class word)]	obj is pointed at by a field in parent that is being traced now. obj is unmarked. obj has pointers.		[put 10 into low bits of header. point to last field. go to Start Field]  Start Field: 	Field ends in 10. It is the header. Short Class is not 0.		[Set low bits to correct value. (have parent pointer) go to Upward]	Field ends in 10. It is the header. Short Class is 0.		[child _ word above header. low bits of child _ 01. class word _ parentField. parentField _ loc of class word. go to Start Obj]	Field is Integer.		[point one word up, go to Start Field]	Field is oop.		[child _ field. field _ parentField. parentField _ loc of field. go to Start Obj]  Upward [restore low bits of header (at field addr)]:	parentField is 3. (bits 11, int 1).		[done!!]	parentField ends in 00.		[child _ field addr. field addr _ parentField. parentField _ field addr contents.		field addr contents _ child (addr of prev object. its oop). field addr - 4. go to Start Field]	parentField ends in 01. Were tracing the class.		[child _ field addr. field addr _ parentField (loc of class word). parentField _ field addr contents.		field addr contents _ child (addr of prev object. its oop). field addr + 4 (header). go to Upward]"! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'ikp 1/3/98 23:10'!markAndTrace: oop	"Mark all objects reachable from the given one. Trace from the given object even if it is old or already marked. Mark it only if it is a young object."	"Tracer state variables:		child		object being examined		field		next field of child to examine		parentField	field where child was stored in its referencing object"	| header lastFieldOffset action |	"record tracing status in object's header"	header _ self longAt: oop.	header _ (header bitAnd: AllButTypeMask) bitOr: HeaderTypeGC.	oop >= youngStart ifTrue: [ header _ header bitOr: MarkBit ].  "mark only if young"	self longAt: oop put: header.	"initialize the tracer state machine"	parentField _ GCTopMarker.	child _ oop.	lastFieldOffset _ self lastPointerOf: oop.	field _ oop + lastFieldOffset.	action _ StartField.	"run the tracer state machine until all objects reachable from oop are marked"	[action = Done] whileFalse: [		action = StartField	ifTrue: [ action _ self startField ].		action = StartObj		ifTrue: [ action _ self startObj ].		action = Upward		ifTrue: [ action _ self upward ].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep'!markPhase	"Mark phase of the mark and sweep garbage collector. Set the mark bits of all reachable objects. Free chunks are untouched by this process."	"Assume: All non-free objects are initially unmarked. Root objects were unmarked when they were made roots. (Make sure this stays true!!!!)."	| oop |	self inline: false.	"clear the recycled context lists"	freeSmallContexts _ NilContext.	freeLargeContexts _ NilContext.	"trace the interpreter's objects, including the active stack and special objects array"	self markAndTraceInterpreterOops.	"trace the roots"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		(self isIntegerObject: oop) ifFalse: [ self markAndTrace: oop ].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep'!startField	"Examine and possibly trace the next field of the object being traced. See comment in markAndTrace for explanation of tracer state variables."	| typeBits childType |	child _ self longAt: field.	typeBits _ child bitAnd: TypeMask.	(typeBits bitAnd: 1) = 1 ifTrue: [		"field contains a SmallInteger; skip it"		field _ field - 4.		^ StartField	].	typeBits = 0 ifTrue: [		"normal oop, go down"		self longAt: field put: parentField.		parentField _ field.		^ StartObj	].	typeBits = 2 ifTrue: [		"reached the header; do we need to process the class word?"		(child bitAnd: 16r1F000) ~= 0 ifTrue: [			"object's class is compact; we're done"			"restore the header type bits"			child _ child bitAnd: AllButTypeMask.			childType _ self rightType: child.			self longAt: field put: (child bitOr: childType).			^ Upward		] ifFalse: [			"object has a full class word; process that class"			child _ self longAt: (field - 4).  "class word"			child _ child bitAnd: AllButTypeMask.  "clear type bits"			self longAt: (field - 4) put: parentField.			parentField _ (field - 4) bitOr: 1.  "point at class word; mark as working on the class."			^ StartObj		].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep'!startObj	"Start tracing the object 'child' and answer the next action. The object may be anywhere in the middle of being swept itself. See comment in markAndTrace for explanation of tracer state variables."	| oop header lastFieldOffset |	oop _ child.	oop < youngStart ifTrue: [		"old object; skip it"		 field _ oop.		^ Upward	].	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [		"unmarked; mark and trace"		header _ header bitAnd: AllButTypeMask.		header _ (header bitOr: MarkBit) bitOr: HeaderTypeGC.		self longAt: oop put: header.		lastFieldOffset _ self lastPointerOf: oop.		field _ oop + lastFieldOffset.		^ StartField	"trace its fields and class"	] ifFalse: [		"already marked; skip it"		field _ oop.		^ Upward	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep'!sweepPhase	"Sweep memory from youngStart through the end of memory. Free all inaccessible objects and coalesce adjacent free chunks. Clear the mark bits of accessible objects. Compute the starting point for the first pass of incremental compaction (compStart). Return the number of surviving objects."	"Details: Each time a non-free object is encountered, decrement the number of available forward table entries. If all entries are spoken for (i.e., entriesAvailable reaches zero), set compStart to the last free chunk before that object or, if there is no free chunk before the given object, the first free chunk after it. Thus, at the end of the sweep phase, compStart through compEnd spans the highest collection of non-free objects that can be accomodated by the forwarding table. This information is used by the first pass of incremental compaction to ensure that space is initially freed at the end of memory. Note that there should always be at least one free chunk--the one at the end of the heap."	| entriesAvailable survivors freeChunk firstFree oop oopHeader oopHeaderType hdrBytes oopSize freeChunkSize |	self inline: false.	entriesAvailable _ self fwdTableInit.	survivors _ 0.	freeChunk _ nil.	firstFree _ nil.  "will be updated later"	oop _ self oopFromChunk: youngStart.	[oop < endOfMemory] whileTrue: [		"get oop's header, header type, size, and header size"		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeShort) ifTrue: [			oopSize _ oopHeader bitAnd: 16rFC.			hdrBytes _ 0.		] ifFalse: [			(oopHeaderType = HeaderTypeClass) ifTrue: [				oopSize _ oopHeader bitAnd: 16rFC.				hdrBytes _ 4.			] ifFalse: [				(oopHeaderType = HeaderTypeSizeAndClass) ifTrue: [					oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask.					hdrBytes _ 8.				] ifFalse: [  "free chunk"					oopSize _ oopHeader bitAnd: FreeSizeMask.					hdrBytes _ 0.				].			].		].		(oopHeader bitAnd: MarkBit) = 0 ifTrue: [			"object is not marked; free it"			freeChunk ~= nil ifTrue: [				"enlarge current free chunk to include this oop"				freeChunkSize _ freeChunkSize + oopSize + hdrBytes.			] ifFalse: [				"start a new free chunk"				freeChunk _ oop - hdrBytes.  "chunk may start 4 or 8 bytes before oop"				freeChunkSize _ oopSize + (oop - freeChunk).  "adjust size for possible extra header bytes"				firstFree = nil ifTrue: [ firstFree _ freeChunk ].			].		] ifFalse: [			"object is marked; clear its mark bit and possibly adjust the compaction start"			self longAt: oop put: (oopHeader bitAnd: AllButMarkBit).			entriesAvailable > 0 ifTrue: [				entriesAvailable _ entriesAvailable - 1.			] ifFalse: [				"start compaction at the last free chunk before this object"				firstFree _ freeChunk.			].			freeChunk ~= nil ifTrue: [				"record the size of the last free chunk"				self longAt: freeChunk					    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).			].			freeChunk _ nil.			survivors _ survivors + 1.		].		oop _ self oopFromChunk: (oop + oopSize).  "get next oop"	].	freeChunk ~= nil ifTrue: [		"record size of final free chunk"		self longAt: freeChunk			    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).	].	oop = endOfMemory		ifFalse: [ self error: 'sweep failed to find exact end of memory' ].	firstFree = nil		ifTrue: [ self error: 'expected to find at least one free object' ]		ifFalse: [ compStart _ firstFree ].	^ survivors! !!ObjectMemory methodsFor: 'gc -- mark and sweep'!upward	"Return from marking an object below. Incoming:		field = oop we just worked on, needs to be put away		parentField = where to put it in our object	NOTE: Type field of object below has already been restored!!!!!!"	| type header |	(parentField bitAnd: 1) = 1 ifTrue: [		parentField = GCTopMarker ifTrue: [			"top of the chain"			header _ (self longAt: field) bitAnd: AllButTypeMask.			type _ self rightType: header.			self longAt: field put: header + type.  "install type on class oop"			^ Done		] ifFalse: [			"was working on the extended class word"			child _ field.	"oop of class"			field _ parentField - 1.  "class word, ** clear the low bit **"			parentField _ self longAt: field.			header _ self longAt: field+4.  "base header word"			type _ self rightType: header.			self longAt: field put: child + type.  "install type on class oop"			field _ field + 4.  "point at header"			"restore type bits"			header _ header bitAnd: AllButTypeMask.			self longAt: field put: (header + type).			^ Upward		].	] ifFalse: [		"normal"		child _ field.  "who we worked on below"		field _ parentField.  "where to put it"		parentField _ self longAt: field.		self longAt: field put: child.		field _ field - 4.  "point at header"		^ StartField	].! !!ObjectMemory methodsFor: 'gc -- compaction'!beRootWhileForwarding: oop	"Record that the given oop in the old object area points to an object in the young area when oop may be forwarded. Like beRoot:"	"Warning: No young objects should be recorded as roots. Callers are responsible for ensuring this constraint is not violated."	| header forwarding fwdBlock newHeader |	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		forwarding _ true.		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	] ifFalse: [		forwarding _ false.	].	(header bitAnd: RootBit) = 0 ifTrue: [		"record oop as root only if not already recorded"		rootTableCount < RootTableSize ifTrue: [			"record root only if there is room in the roots table"			rootTableCount _ rootTableCount + 1.			rootTable at: rootTableCount put: oop.			newHeader _ header bitOr: RootBit.			forwarding				ifTrue: [ self longAt: (fwdBlock + 4) put: newHeader ]				ifFalse: [ self longAt: oop put: newHeader ].		].	].! !!ObjectMemory methodsFor: 'gc -- compaction'!fwdBlockGet	"Return the address of a two-word forwarding block or nil if no more entries are available."	fwdTableNext _ fwdTableNext + 8.	fwdTableNext <= fwdTableLast		ifTrue: [ ^ fwdTableNext ]		ifFalse: [ ^ nil ].  "no more forwarding blocks available"! !!ObjectMemory methodsFor: 'gc -- compaction'!fwdBlockValidate: addr	"Raise an error if the given address is not a valid forward table entry."	(( addr > endOfMemory) and:	 [(addr <= fwdTableNext) and:	 [(addr bitAnd: 3) = 0]])		ifFalse: [ self error: 'invalid fwd table entry' ].! !!ObjectMemory methodsFor: 'gc -- compaction'!fwdTableInit	"Set the limits for a table of two-word forwarding blocks above the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used for compaction of memory and become-ing objects. Returns the number of forwarding blocks available."	self inline: false.	"set endOfMemory to just after a minimum-sized free block"	self setSizeOfFree: freeBlock to: BaseHeaderSize.	endOfMemory _ freeBlock + BaseHeaderSize.	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	"use all memory free between freeBlock and memoryLimit for forwarding table"	fwdTableNext _ endOfMemory + BaseHeaderSize.	fwdTableLast _ memoryLimit - 8.  "last forwarding table entry"	(checkAssertions and: [(fwdTableLast bitAnd: MarkBit) ~= 0]) ifTrue: [		"Note: Address bits must not interfere with the mark bit in header of		 an object, which shows that the object is forwarded."		self error: 'fwd table must be in low half of the 32-bit address space'.	].	"return the number of forwarding blocks available"	^ (fwdTableLast - fwdTableNext) // 8  "round down"! !!ObjectMemory methodsFor: 'gc -- compaction'!incCompBody	"Move objects to consolidate free space into one big chunk. Return the newly created free chunk."	| bytesFreed |	self inline: false.	"reserve memory for forwarding table"	self fwdTableInit.	"assign new oop locations, reverse their headers, and initialize forwarding blocks"	bytesFreed _ self incCompMakeFwd.	"update pointers to point at new oops"	self mapPointersInObjectsFrom: youngStart to: endOfMemory.	"move the objects and restore their original headers; return the new free chunk"	^ self incCompMove: bytesFreed! !!ObjectMemory methodsFor: 'gc -- compaction'!incCompMakeFwd	"Create and initialize forwarding blocks for all non-free objects following compStart. If the supply of forwarding blocks is exhausted, set compEnd to the first chunk above the area to be compacted; otherwise, set it to endOfMemory. Return the number of bytes to be freed."	| bytesFreed oop fwdBlock newOop |	bytesFreed _ 0.	oop _ self oopFromChunk: compStart.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifTrue: [			bytesFreed _ bytesFreed + (self sizeOfFree: oop).		] ifFalse: [			"create a forwarding block for oop"			fwdBlock _ self fwdBlockGet.			fwdBlock = nil ifTrue: [				"stop; we have used all available forwarding blocks"				compEnd _ self chunkFromOop: oop.				^ bytesFreed			].			newOop _ oop - bytesFreed.			self initForwardBlock: fwdBlock mapping: oop to: newOop.		].		oop _ self objectAfterWhileForwarding: oop.	].	compEnd _ endOfMemory.	^ bytesFreed! !!ObjectMemory methodsFor: 'gc -- compaction'!incCompMove: bytesFreed	"Move all non-free objects between compStart and compEnd to their new locations, restoring their headers in the process. Create a new free block at the end of memory. Return the newly created free chunk."	"Note: The free block used by the allocator always must be the last free block in memory. It may take several compaction passes to make all free space bubble up to the end of memory."	| oop next fwdBlock newOop header bytesToMove firstWord lastWord newFreeChunk sz |	newOop _ nil.	oop _ self oopFromChunk: compStart.	[oop < compEnd] whileTrue: [		next _ self objectAfterWhileForwarding: oop.		(self isFreeObject: oop) ifFalse: [			"a moving object; unwind its forwarding block"			fwdBlock _ (self longAt: oop) bitAnd: AllButMarkBitAndTypeMask.			checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].			newOop _ self longAt: fwdBlock.			header _ self longAt: fwdBlock + 4.			self longAt: oop put: header.  "restore the original header"			bytesToMove _ oop - newOop.			"move the oop (including any extra header words)"			sz _ self sizeBitsOf: oop.			firstWord _ oop - (self extraHeaderBytes: oop).			lastWord _ (oop + sz) - BaseHeaderSize.			firstWord to: lastWord by: 4 do: [ :w |				self longAt: (w - bytesToMove) put: (self longAt: w).			].		].		oop _ next.	].	newOop = nil ifTrue: [		"no objects moved"		oop _ self oopFromChunk: compStart.		((self isFreeObject: oop) and: [(self objectAfter: oop) = (self oopFromChunk: compEnd)])			ifTrue: [ newFreeChunk _ oop ]			ifFalse: [ newFreeChunk _ freeBlock ].	] ifFalse: [		"initialize the newly freed memory chunk"		"newOop is the last object moved; free chunk starts right after it"		newFreeChunk _ newOop + (self sizeBitsOf: newOop).		self setSizeOfFree: newFreeChunk to: bytesFreed.	].	checkAssertions ifTrue: [		(self objectAfter: newFreeChunk) = (self oopFromChunk: compEnd)			ifFalse: [ self error: 'problem creating free chunk after compaction' ].	].	(self objectAfter: newFreeChunk) = endOfMemory ifTrue: [		self initializeMemoryFirstFree: newFreeChunk.	] ifFalse: [		"newFreeChunk is not at end of memory; re-install freeBlock"		self initializeMemoryFirstFree: freeBlock.	].	^ newFreeChunk! !!ObjectMemory methodsFor: 'gc -- compaction'!initForwardBlock: fwdBlock mapping: oop to: newOop	"Initialize the given forwarding block to map oop to newOop, and replace oop's header with a pointer to the fowarding block."	"Details: The mark bit is used to indicate that an oop is forwarded. When an oop is forwarded, its header (minus the mark bit) contains the address of its forwarding block. The first word of the forwarding block is the new oop; the second word is the oop's orginal header. The type bits of the forwarding header are the same as those of the original header."	| originalHeader originalHeaderType |	self inline: true.	originalHeader _ self longAt: oop.	checkAssertions ifTrue: [		fwdBlock = nil			ifTrue: [ self error: 'ran out of forwarding blocks in become' ].		(originalHeader bitAnd: MarkBit) ~= 0			ifTrue: [ self error: 'object already has a forwarding table entry' ].	].	originalHeaderType _ originalHeader bitAnd: TypeMask.	self longAt: fwdBlock put: newOop.	self longAt: fwdBlock + 4 put: originalHeader.	self longAt: oop put: (fwdBlock bitOr: (MarkBit bitOr: originalHeaderType)).! !!ObjectMemory methodsFor: 'gc -- compaction'!isObjectForwarded: oop	"Return true if the given object has a forwarding table entry during a compaction or become operation."	^ (oop bitAnd: 1) = 0 "(isIntegerObject: oop) not" and:	   [ ((self longAt: oop) bitAnd: MarkBit) ~= 0 ]! !!ObjectMemory methodsFor: 'gc -- compaction'!lastPointerWhileForwarding: oop	"The given object may have its header word in a forwarding block. Find the offset of the last pointer in the object in spite of this obstacle."	| header fwdBlock fmt size methodHeader |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		"oop is forwarded; get its real header from its forwarding table entry"		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	].	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 4 ifTrue: [		"do sizeBitsOf: using the header we obtained"		(header bitAnd: TypeMask) = HeaderTypeSizeAndClass			ifTrue: [ size _ (self sizeHeader: oop) bitAnd: 16rFFFFFFC ]			ifFalse: [ size _ header bitAnd: 16rFC ].		^ size - BaseHeaderSize	].	fmt < 12 ifTrue: [ ^ 0 ].  "no pointers"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'gc -- compaction'!mapPointersInObjectsFrom: memStart to: memEnd	"Use the forwarding table to update the pointers of all non-free objects in the given range of memory. Also remap pointers in root objects which may contains pointers into the given memory range."	| oop |	self inline: false.	"update interpreter variables"	self mapInterpreterOops.	"update pointers in root objects"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		((oop < memStart) or: [oop >= memEnd]) ifTrue: [			"Note: must not remap the fields of any object twice!!"			"remap this oop only if not in the memory range covered below"			self remapFieldsAndClassOf: oop.		].	].	"update pointers in the given memory range"	oop _ self oopFromChunk: memStart.	[oop < memEnd] whileTrue: [		(self isFreeObject: oop) ifFalse: [			self remapFieldsAndClassOf: oop.		].		oop _ self objectAfterWhileForwarding: oop.	].! !!ObjectMemory methodsFor: 'gc -- compaction'!objectAfterWhileForwarding: oop	"Return the oop of the object after the given oop when the actual header of the oop may be in the forwarding table."	| header fwdBlock realHeader sz |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [ ^ self objectAfter: oop ].  "oop not forwarded"	"Assume: mark bit cannot be set on a free chunk, so if we get here,	 oop is not free and it has a forwarding table entry"	fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.	checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].	realHeader _ self longAt: fwdBlock + 4.	"following code is like sizeBitsOf:"	(realHeader bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: 16rFFFFFFC ]		ifFalse: [ sz _ realHeader bitAnd: 16rFC ].	^ self oopFromChunk: (oop + sz)! !!ObjectMemory methodsFor: 'gc -- compaction'!remap: oop	"Map the given oop to its new value during a compaction or become: operation. If it has no forwarding table entry, return the oop itself."	| fwdBlock |	self inline: false.	(self isObjectForwarded: oop) ifTrue: [		"get the new value for oop from its forwarding block"		fwdBlock _ (self longAt: oop) bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		^ self longAt: fwdBlock	].	^ oop! !!ObjectMemory methodsFor: 'gc -- compaction'!remapClassOf: oop	"Update the class of the given object, if necessary, using its forwarding table entry."	"Note: Compact classes need not be remapped since the compact class field is just an index into the compact class table. The header type bits show if this object has a compact class; we needn't look up the oop's real header."	| classHeader classOop fwdBlock newClassOop newClassHeader |	(self headerType: oop) = HeaderTypeShort ifTrue: [ ^nil ].  "compact classes needn't be mapped"	classHeader _ self longAt: (oop - 4).	classOop _ classHeader bitAnd: AllButTypeMask.	(self isObjectForwarded: classOop) ifTrue: [		fwdBlock _ (self longAt: classOop) bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		newClassOop _ self longAt: fwdBlock.		newClassHeader _ newClassOop bitOr: (classHeader bitAnd: TypeMask).		self longAt: (oop - 4) put: newClassHeader.		"The following ensures that become: into an old object's class makes it a root.		  It does nothing during either incremental or full compaction because		  oop will never be < youngStart."		((oop < youngStart) and: [newClassOop >= youngStart])			ifTrue: [ self beRootWhileForwarding: oop ].	].! !!ObjectMemory methodsFor: 'gc -- compaction'!remapFieldsAndClassOf: oop	"Replace all forwarded pointers in this object with their new oops, using the forwarding table. Remap its class as well, if necessary."	"Note: The given oop may be forwarded itself, which means that its real header is in its forwarding table entry."	| fieldOffset fieldOop fwdBlock newOop |	self inline: true.	fieldOffset _ self lastPointerWhileForwarding: oop.	[fieldOffset >= BaseHeaderSize] whileTrue: [		fieldOop _ self longAt: (oop + fieldOffset).		(self isObjectForwarded: fieldOop) ifTrue: [			"update this oop from its forwarding block"			fwdBlock _ (self longAt: fieldOop) bitAnd: AllButMarkBitAndTypeMask.			checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].			newOop _ self longAt: fwdBlock.			self longAt: (oop + fieldOffset) put: newOop.			"The following ensures that become: into old object makes it a root.			  It does nothing during either incremental or full compaction because			  oop will never be < youngStart."			((oop < youngStart) and: [newOop >= youngStart])				ifTrue: [ self beRootWhileForwarding: oop ].		].		fieldOffset _ fieldOffset - 4.	].	self remapClassOf: oop.! !!ObjectMemory methodsFor: 'become'!allYoung: array1 and: array2	"Return true if all the oops in both arrays, and the arrays themselves, are in the young object space."	| fieldOffset |	array1 < youngStart ifTrue: [ ^ false ].	array2 < youngStart ifTrue: [ ^ false ].	fieldOffset _ self lastPointerOf: array1.  "same size as array2"	[fieldOffset >= BaseHeaderSize] whileTrue: [		(self longAt: array1 + fieldOffset) < youngStart ifTrue: [ ^ false ].		(self longAt: array2 + fieldOffset) < youngStart ifTrue: [ ^ false ].		fieldOffset _ fieldOffset - 4.	].	^ true! !!ObjectMemory methodsFor: 'become'!become: array1 with: array2	"All references to each object in array1 are swapped with all references to the corresponding object in array2. That is, all pointers to one object are replaced with with pointers to the other. The arguments must be arrays of the same length. Returns true if the primitive succeeds."	"Implementation: Uses forwarding blocks to update references as done in compaction."	(self fetchClassOf: array1) = (self splObj: ClassArray) ifFalse: [ ^ false ].	(self fetchClassOf: array2) = (self splObj: ClassArray) ifFalse: [ ^ false ].	(self lastPointerOf: array1) = (self lastPointerOf: array2) ifFalse: [ ^ false ].	(self containOnlyOops: array1 and: array2) ifFalse: [ ^ false ].	(self prepareForwardingTableForBecoming: array1 with: array2) ifFalse: [		^ false  "fail; not enough space for forwarding table"	].	(self allYoung: array1 and: array2) ifTrue: [		"sweep only the young objects plus the roots"		self mapPointersInObjectsFrom: youngStart to: endOfMemory.	] ifFalse: [		"sweep all objects"		self mapPointersInObjectsFrom: (self startOfMemory) to: endOfMemory.	].	self restoreHeadersAfterBecoming: array1 with: array2.	self initializeMemoryFirstFree: freeBlock.  "re-initialize memory used for forwarding table"	^ true  "success"! !!ObjectMemory methodsFor: 'become'!containOnlyOops: array1 and: array2	"Return true if neither array contains a small integer. You can't become: integers!!"	| fieldOffset |	fieldOffset _ self lastPointerOf: array1.  "same size as array2"	[fieldOffset >= BaseHeaderSize] whileTrue: [		(self isIntegerObject: (self longAt: array1 + fieldOffset)) ifTrue: [ ^ false ].		(self isIntegerObject: (self longAt: array2 + fieldOffset)) ifTrue: [ ^ false ].		fieldOffset _ fieldOffset - 4.	].	^ true! !!ObjectMemory methodsFor: 'become'!exchangeHashBits: oop1 with: oop2	| hdr1 hdr2 |	hdr1 _ self longAt: oop1.	hdr2 _ self longAt: oop2.	self longAt: oop1 put:		((hdr1 bitAnd: AllButHashBits) bitOr: (hdr2 bitAnd: HashBits)).	self longAt: oop2 put:		((hdr2 bitAnd: AllButHashBits) bitOr: (hdr1 bitAnd: HashBits)).! !!ObjectMemory methodsFor: 'become'!prepareForwardingTableForBecoming: array1 with: array2	"Ensure that there are enough forwarding blocks to accomodate this become, then prepare forwarding blocks for the pointer swap. Return true if successful."	"Details: Doing a GC might generate enough space for forwarding blocks if we're short. However, this is an uncommon enough case that it is better handled by primitive fail code at the Smalltalk level."	| entriesNeeded entriesAvailable fieldOffset oop1 oop2 fwdBlock |	entriesNeeded _ 2 * ((self lastPointerOf: array1) // 4).  "need enough entries for both directions"	entriesAvailable _ self fwdTableInit.	entriesAvailable < entriesNeeded ifTrue: [		self initializeMemoryFirstFree: freeBlock.  "re-initialize the free block"		^ false	].	fieldOffset _ self lastPointerOf: array1.	[fieldOffset >= BaseHeaderSize] whileTrue: [		oop1 _ self longAt: array1 + fieldOffset.		oop2 _ self longAt: array2 + fieldOffset.		fwdBlock _ self fwdBlockGet.		self initForwardBlock: fwdBlock mapping: oop1 to: oop2.		fwdBlock _ self fwdBlockGet.		self initForwardBlock: fwdBlock mapping: oop2 to: oop1.		fieldOffset _ fieldOffset - 4.	].	^ true! !!ObjectMemory methodsFor: 'become'!restoreHeaderOf: oop	"Restore the original header of the given oop from its forwarding block."	| fwdHeader fwdBlock |	fwdHeader _ self longAt: oop.	fwdBlock _ fwdHeader bitAnd: AllButMarkBitAndTypeMask.	checkAssertions ifTrue: [		(fwdHeader bitAnd: MarkBit) = 0 ifTrue: [			self error: 'attempting to restore the header of an object that has no forwarding block'.		].		self fwdBlockValidate: fwdBlock.	].	self longAt: oop put: (self longAt: fwdBlock + 4).  "restore orginal header"! !!ObjectMemory methodsFor: 'become'!restoreHeadersAfterBecoming: list1 with: list2	"Restore the headers of all oops in both lists. Exchange their hash bits so becoming objects in identity sets and dictionaries doesn't change their hash value."	| fieldOffset oop1 oop2 |	fieldOffset _ self lastPointerOf: list1.	[fieldOffset >= BaseHeaderSize] whileTrue: [		oop1 _ self longAt: list1 + fieldOffset.		oop2 _ self longAt: list2 + fieldOffset.		self restoreHeaderOf: oop1.		self restoreHeaderOf: oop2.		self exchangeHashBits: oop1 with: oop2.		fieldOffset _ fieldOffset - 4.	].! !!ObjectMemory class methodsFor: 'initialization' stamp: 'ikp 1/3/98 23:10'!initialize	"ObjectMemory initialize"	self initializeSpecialObjectIndices.	self initializeObjectHeaderConstants.	LargeContextSize _ 156.	SmallContextSize _ 76.	NilContext _ 1.  "the oop for the integer 0; used to mark the end of context lists"	MinimumForwardTableBytes _ 16000.  "bytes reserved for forwarding table (8 bytes/entry)"	RemapBufferSize _ 25.	RootTableSize _ 1000.  "number of root table entries (4 bytes/entry)"	"tracer actions"	StartField _ 1.	StartObj _ 2.	Upward _ 3.	Done _ 4.! !!ObjectMemory class methodsFor: 'initialization'!initializeObjectHeaderConstants	BaseHeaderSize _ 4.	"masks for type field"	TypeMask _ 3.	AllButTypeMask _ 16rFFFFFFFF - TypeMask.	"type field values"	HeaderTypeSizeAndClass _ 0.	HeaderTypeClass _ 1.	HeaderTypeFree _ 2.	HeaderTypeShort _ 3.	"type field values used during the mark phase of GC"	HeaderTypeGC _ 2.	GCTopMarker _ 3.  "neither an oop, nor an oop+1, this value signals that we have crawled back up to the top of the marking phase."	"mask for a free chunk size"	FreeSizeMask _ 16r1FFFFFFC.	"base header word bit fields"	HashBits _ 16r1FFE0000.	AllButHashBits _ 16rFFFFFFFF - HashBits.	HashBitsOffset _ 17.	"masks for root and mark bits"	MarkBit _ 16r80000000.	RootBit _ 16r40000000.	AllButMarkBit _ 16rFFFFFFFF - MarkBit.	AllButRootBit _ 16rFFFFFFFF - RootBit.	AllButMarkBitAndTypeMask _ AllButTypeMask - MarkBit.! !!ObjectMemory class methodsFor: 'initialization' stamp: 'ikp 1/1/98 23:45'!initializeSpecialObjectIndices	"Initialize indices into specialObjects array."	NilObject _ 0.	FalseObject _ 1.	TrueObject _ 2.	SchedulerAssociation _ 3.	ClassBitmap _ 4.	ClassInteger _ 5.	ClassString _ 6.	ClassArray _ 7.	"SmalltalkDictionary _ 8."  "Do not delete!!"	ClassFloat _ 9.	ClassMethodContext _ 10.	ClassBlockContext _ 11.	ClassPoint _ 12.	ClassLargePositiveInteger _ 13.	TheDisplay _ 14.	ClassMessage _ 15.	ClassCompiledMethod _ 16.	TheLowSpaceSemaphore _ 17.	ClassSemaphore _ 18.	ClassCharacter _ 19.	SelectorDoesNotUnderstand _ 20.	SelectorCannotReturn _ 21.	TheInputSemaphore _ 22.	SpecialSelectors _ 23.	CharacterTable _ 24.	SelectorMustBeBoolean _ 25.	ClassByteArray _ 26.	ClassProcess _ 27.	CompactClasses _ 28.	TheTimerSemaphore _ 29.	TheInterruptSemaphore _ 30.	SmallMethodContext _ 34.	SmallBlockContext _ 36.	ExternalObjectsArray _ 38.	ClassPseudoContext _ 39.	ClassTranslatedMethod _ 40.! !!ObjectMemory class methodsFor: 'translation'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'memory'		declareC: 'unsigned char *memory'.	aCCodeGenerator var: 'remapBuffer'		declareC: 'int remapBuffer[', (RemapBufferSize + 1) printString, ']'.	aCCodeGenerator var: 'rootTable'		declareC: 'int rootTable[', (RootTableSize + 1) printString, ']'.! !ObjectTracer class comment:'An ObjectTracer can be wrapped around another object, and then give you a chance to inspect it whenever it receives messages from the outside.  For instance...	(ObjectTracer on: Display) flash: (50@50 extent: 50@50)will give control to a debugger just before the message flash is sent.Obviously this facility can be embellished in many useful ways.See also the even more perverse subclass, ObjectViewer, and its example.'!!ObjectTracer methodsFor: 'very few messages'!doesNotUnderstand: aMessage 	"All external messages (those not caused by the re-send) get trapped here"	"Present a dubugger before proceeding to re-send the message"	DebuggerView openContext: thisContext				label: 'About to perform: ', aMessage selector				contents: thisContext shortStack.	^ aMessage sentTo: tracedObject.! !!ObjectTracer methodsFor: 'very few messages'!xxxUnTrace	tracedObject become: self! !!ObjectTracer methodsFor: 'very few messages'!xxxViewedObject	"This message name must not clash with any other (natch)."	^ tracedObject! !!ObjectTracer methodsFor: 'very few messages'!xxxViewedObject: anObject	"This message name must not clash with any other (natch)."	tracedObject _ anObject! !!ObjectTracer class methodsFor: 'instance creation'!on: anObject	^ self new xxxViewedObject: anObject! !ObjectViewer class comment:'ObjectViewers offers the same kind of interception of messages (via doesnotUnderstand:) as ObjectTracers, but instead of just being wrappers, they actually replace the object being viewed.  This makes them a lot more dangerous to use, but one can do amazing things.  For instance, the example below actually intercepts the InputSensor object, and prints the mouse coordinates asynchronously, every time they change:	Sensor evaluate: [Sensor cursorPoint printString displayAt: 0@0]		wheneverChangeIn: [Sensor cursorPoint].To exit from this example, execute:	Sensor xxxUnTrace'!!ObjectViewer methodsFor: 'very few messages'!doesNotUnderstand: aMessage 	"Check for change after sending aMessage"	| returnValue newValue |	recursionFlag ifTrue: [^ aMessage sentTo: tracedObject].	recursionFlag _ true.	returnValue _ aMessage sentTo: tracedObject.	newValue _ valueBlock value.	newValue = lastValue ifFalse:		[changeBlock value.		lastValue _ newValue].	recursionFlag _ false.	^ returnValue! !!ObjectViewer methodsFor: 'very few messages'!xxxViewedObject: viewedObject evaluate: block1 wheneverChangeIn: block2	"This message name must not clash with any other (natch)."	tracedObject _ viewedObject.	valueBlock _ block2.	changeBlock _ block1.	recursionFlag _ false! !!ObjectViewer class methodsFor: 'instance creation'!on: viewedObject evaluate: block1 wheneverChangeIn: block2	^ self new xxxViewedObject: viewedObject evaluate: block1 wheneverChangeIn: block2! !OpaqueMaskColor class comment:'The pixel value of an OpaqueMaskColor is all-ones in any depth. This allows it to be used in combination with the AND mode of BitBlt to create masks that work at any depth. Clients typically use "Color opaqueMask" to get an instance of me.'!!OpaqueMaskColor methodsFor: 'equality' stamp: 'di 10/1/97 20:14'!= aColor	^ aColor isColor and: [aColor isOpaqueMask]! !!OpaqueMaskColor methodsFor: 'equality'!hash	^ 1023! !!OpaqueMaskColor methodsFor: 'queries'!isOpaqueMask	^ true! !!OpaqueMaskColor methodsFor: 'transformations'!* aFactor	^ self! !!OpaqueMaskColor methodsFor: 'transformations'!+ aColor	^ self! !!OpaqueMaskColor methodsFor: 'transformations'!- aColor	^ self! !!OpaqueMaskColor methodsFor: 'transformations'!/ aFactor	^ self! !!OpaqueMaskColor methodsFor: 'transformations'!darker	^ self! !!OpaqueMaskColor methodsFor: 'transformations'!lighter	^ self! !!OpaqueMaskColor methodsFor: 'transformations'!mixed: proportion with: aColor	^ self! !!OpaqueMaskColor methodsFor: 'printing'!shortPrintString	^ 'OpaqueMask'! !!OpaqueMaskColor methodsFor: 'printing'!storeOn: aStream	aStream nextPutAll: '(Color opaqueMask)'.! !!OpaqueMaskColor methodsFor: 'conversions'!bitPatternForDepth: depth	^ Bitmap with: (self pixelWordForDepth: depth)! !!OpaqueMaskColor methodsFor: 'conversions'!pixelValueForDepth: depth	^ (1 bitShift: depth) - 1! !!OpaqueMaskColor methodsFor: 'conversions'!pixelWordForDepth: depth	^ 16rFFFFFFFF! !!OpaqueMaskColor methodsFor: 'private'!setRed: r green: g blue: b	"Ignored."! !!OrderedCollection methodsFor: 'accessing'!inspect	"Open an OrderedCollectionInspector on the receiver.	Use basicInspect to get a normal type of inspector."	OrderedCollectionInspector openOn: self withEvalPane: true! !!OrderedCollection methodsFor: 'copying'!copyFrom: startIndex to: endIndex 	"Answer a copy of the receiver that contains elements from position	startIndex to endIndex."	| targetCollection |	endIndex < startIndex ifTrue: [^self species new: 0].	targetCollection _ self species new: endIndex + 1 - startIndex.	startIndex to: endIndex do: [:index | targetCollection add: (self at: index)].	^ targetCollection! !!OrderedCollection methodsFor: 'copying'!copyReplaceFrom: start to: stop with: replacementCollection 	"Answer a copy of the receiver with replacementCollection's elements in	place of the receiver's start'th to stop'th elements. This does not expect	a 1-1 map from replacementCollection to the start to stop elements, so it	will do an insert or append."	| newOrderedCollection delta startIndex stopIndex |	"if start is less than 1, ignore stop and assume this is inserting at the front. 	if start greater than self size, ignore stop and assume this is appending. 	otherwise, it is replacing part of me and start and stop have to be within my 	bounds. "	delta _ 0.	startIndex _ start.	stopIndex _ stop.	start < 1		ifTrue: [startIndex _ stopIndex _ 0]		ifFalse: [startIndex > self size				ifTrue: [startIndex _ stopIndex _ self size + 1]				ifFalse: 					[(stopIndex < (startIndex - 1) or: [stopIndex > self size])						ifTrue: [self errorOutOfBounds].					delta _ stopIndex - startIndex + 1]].	newOrderedCollection _ 		self species new: self size + replacementCollection size - delta.	1 to: startIndex - 1 do: [:index | newOrderedCollection add: (self at: index)].	1 to: replacementCollection size do: 		[:index | newOrderedCollection add: (replacementCollection at: index)].	stopIndex + 1 to: self size do: [:index | newOrderedCollection add: (self at: index)].	^newOrderedCollection! !!OrderedCollection methodsFor: 'copying' stamp: 'di 11/4/97 20:11'!copyWithout: oldElement 	"Answer a copy of the receiver that does not contain any elements equal	to oldElement."	^ self select: [:each | each ~= oldElement]! !!OrderedCollection methodsFor: 'copying' stamp: 'di 11/4/97 20:11'!copyWithoutAll: aList	"Answer a copy of the receiver that does not contain any elements equal	to those in aList."	^ self select: [:each | (aList includes: each) not]! !!OrderedCollection methodsFor: 'copying' stamp: 'sw 1/26/96'!reversed	"Answer a copy of the receiver with element order reversed.  "	| newCol |	newCol _ self species new.	self reverseDo:		[:elem | newCol addLast: elem].	^ newCol"#(2 3 4 'fred') reversed"! !!OrderedCollection methodsFor: 'private'!makeRoomAtLast	| newLast delta |	newLast _ self size.	array size - self size = 0 ifTrue: [self grow].	(delta _ firstIndex - 1) = 0 ifTrue: [^ self].	"we might be here under false premises or grow did the job for us"	1 to: newLast do:		[:index |		array at: index put: (array at: index + delta).		array at: index + delta put: nil].	firstIndex _ 1.	lastIndex _ newLast! !!OrderedCollection methodsFor: 'private' stamp: 'di 11/14/97 12:54'!reset	firstIndex _ array size // 3 max: 1.	lastIndex _ firstIndex - 1! !!OrderedCollection methodsFor: 'private' stamp: 'di 11/14/97 12:54'!setCollection: anArray	array _ anArray.	self reset! !!OrderedCollectionInspector methodsFor: 'all' stamp: 'sw 9/16/97 22:38'!replaceSelectionValue: anObject 	"The receiver has a list of variables of its inspected object. One of these 	is selected. The value of the selected variable is set to the value, anObject."	(selectionIndex - 2) <= object class instSize		ifTrue: [^ super replaceSelectionValue: anObject].	object at: self selectedObjectIndex put: anObject! !!OrderedCollectionInspector methodsFor: 'all' stamp: 'sw 9/16/97 22:28'!selectedObjectIndex	"Answer the index of the inspectee's collection that the current selection refers to."	| basicIndex |	basicIndex _ selectionIndex - 2 - object class instSize.	^ (object size <= (self i1 + self i2)  or: [basicIndex <= self i1])		ifTrue: [basicIndex]		ifFalse: [object size - (self i1 + self i2) + basicIndex]! !!OrderedCollectionInspector methodsFor: 'all' stamp: 'sw 9/16/97 22:39'!selectedSlotName	"Answer the name of the currently selected slot, for the purpose of putting it into a menu title"	^ (selectionIndex _ self selectionIndex) <= self baseFieldList size		ifTrue:			[super selectedSlotName]		ifFalse:			[ 'element ', self selectedObjectIndex printString, ' ']! !!OrderedCollectionInspector methodsFor: 'all' stamp: 'sw 9/16/97 22:39'!selection	"The receiver has a list of variables of its inspected object.	One of these is selected. Answer the value of the selected variable."	(selectionIndex - 2) <= object class instSize		ifTrue: [^ super selection].	^ object at: self selectedObjectIndex! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 7/16/97 18:53'!createButtons	"Create buttons one at a time and let the user place them over the background.  Later can move them again by turning on AuthorModeOwner in ThreePhaseButtonMorph.	self createButtons.	"| rect button nib |#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: pickup: "pickup: pickup: pickup:" stamp: "stamp: stamp: stamp:" undo: keep: toss: prevStamp: nextStamp:) do: [:sel |	(self findButton: sel) ifNil: [		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser translateBy: self world viewBox origin negated.		button _ ThreePhaseButtonMorph new.		button onImage: nil; bounds: rect.		self addMorph: button.		button actionSelector: #tool:action:cursor:; arguments: (Array with: button with: sel with: nil).		button actWhen: #buttonUp; target: self.		]].#(brush1: brush2: brush3: brush4: brush5: brush6: ) doWithIndex: [:sel :ind |	(self findButton: sel) ifNil: [		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser translateBy: self world viewBox origin negated.		button _ ThreePhaseButtonMorph new.		button onImage: nil; bounds: rect.		self addMorph: button.		nib _ Form dotOfSize: (#(1 2 3 6 11 26) at: ind).		button actionSelector: #brush:action:nib:; 				arguments: (Array with: button with: sel with: nib).		button actWhen: #buttonUp; target: self.		]]."stamp:  Stamps are held in a ScrollingToolHolder.  Pickups and stamps and brushes are id-ed by the button == with item from a list."! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 7/1/97 18:03'!initialize	super initialize.	self on: #mouseDown send: #yourself to: self.	colorMemory ifNotNil: [colorMemory on: #mouseDown send: #takeColorEvt:from: to: self].! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 10/21/97 15:48'!loadColorChooser	"Go to bitmap-backed ColorMemoryMorph, Load its picture, load the underlying picture."| form doc |(Smalltalk at: #AA ifAbsent: [nil]) class == Form 	ifFalse: ["read for first time"		doc _ Utilities objectStrmFromUpdates: 'colorPalClosed.obj'.		Smalltalk at: #AA put: doc fileInObjectAndCode.		doc _ Utilities objectStrmFromUpdates: 'colorPalOpen.obj'.		Smalltalk at: #BB put: doc fileInObjectAndCode].form _ (Smalltalk at: #AA) removeZeroPixelsFromForm.	"Make black be black, not transparent"colorMemoryThin image: form.colorMemoryThin position: self position + (0@140)."Install the color memory bitmap"colorMemory delete.	"old"colorMemory _ ColorMemory2Morph new initialize.colorMemory on: #mouseUp send: #click: to: colorMemory.		"it sends takeColorEvt:from: to me""form _ Form newFromFileNamed: 'openPalette.form'. old, from local disk"form _ (Smalltalk at: #BB) removeZeroPixelsFromForm.	"Make black be black, not transparent"colorMemory image: form.colorMemory on: #mouseLeave send: #delete to: colorMemory.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'di 10/13/97 18:49'!loadCursors	"Display the form containing the cursors.  Transparent is (Color r: 1.0 g: 0 b: 1.0).  Grab the forms one at a time, and they are stored away.	self loadCursors.	"| button transp cursor map |transp _ Color r: 1.0 g: 0 b: 1.0.map _ Color indexedColors copy.	"just in case"1 to: 256 do: [:ind | (map at: ind) = transp ifTrue: [			map at: ind put: Color transparent]].#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: ) do: [:sel |	PopUpMenu notify: 'Rectangle for ',sel.	cursor _ ColorForm fromUser.	cursor colors: map.	"share it"	button _ self findButton: sel.	button arguments at: 3 put: cursor.	].! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 7/17/97 16:34'!loadRotScalePics	"Load up class vars with .bmp files for the images of the Rotation control button and the Scale control button.  File names do not change."	"	self loadRotScalePics		"	rotationTabForm _ Form fromBMPFileNamed: 'Rotaball.bmp' depth: 16.	scaleTabForm _ Form fromBMPFileNamed: 'Scalball.bmp' depth: 16.		! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'di 10/13/97 17:20'!moveButtons	"Move buttons one at a time and let the user place them over the background.  Later can move them again by turning on AuthorModeOwner in ThreePhaseButtonMorph.	self createButtons.	"| rect button |#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: "pickup: pickup: pickup: pickup:" "stamp: stamp: stamp: stamp:" undo: keep: toss: prevStamp: nextStamp:) do: [:sel |		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser translateBy: self world viewBox origin negated.		button _ self findButton: sel.		button bounds: rect.	"image is nil"		].#(brush1: brush2: brush3: brush4: brush5: brush6: ) doWithIndex: [:sel :ind |		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser translateBy: self world viewBox origin negated.		button _ self findButton: sel.		button bounds: rect.	"image is nil"		]."stamp:  Stamps are held in a ScrollingToolHolder.  Pickups and stamps and brushes are id-ed by the button == with item from a list."""! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 8/22/97 15:57'!noVeneer	"For a palette with a background (off) image, clear that image.But first, for each button, cut that chunk out and save it in the offImagepart."	"	self noVeneer.		AllOffImage _ nil.	'save space.  irreversible'.	"	| aa on |	AllOffImage ifNil: [AllOffImage _ image].	aa _ AllOffImage.	"Collect all the images for the buttons in the on state"	self allMorphsDo: [:button |		(button isKindOf: ThreePhaseButtonMorph) ifTrue: [			on _ Form extent: button extent depth: 16.			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in:aa rule: Form over.			button offImage: on]].	self image: (Form extent: AllOffImage extent depth: 1).	self invalidRect: bounds.	! !!PaintBoxMorph methodsFor: 'other' stamp: 'tk 10/31/97 13:38'!colorMemory	^ colorMemory! !!PaintBoxMorph methodsFor: 'other' stamp: 'di 10/14/97 10:15'!colorMemory: aMorph	colorMemory _ aMorph! !!PaintBoxMorph methodsFor: 'other' stamp: 'tk 10/31/97 13:35'!colorPatch	^ colorPatch! !!PaintBoxMorph methodsFor: 'other' stamp: 'di 10/14/97 13:28'!copyRecordingIn: dict	"Overridden to copy the stamps holder."	| new |	new _ super copyRecordingIn: dict.	new stampHolder: stampHolder copy.	new colorMemory: (colorMemory copyRecordingIn: dict).	^ new! !!PaintBoxMorph methodsFor: 'other' stamp: 'tk 7/17/97 16:26'!rotationTabForm	^ rotationTabForm! !!PaintBoxMorph methodsFor: 'other' stamp: 'tk 7/17/97 16:26'!scaleTabForm	^ scaleTabForm! !!PaintBoxMorph methodsFor: 'other' stamp: 'di 10/14/97 10:13'!updateReferencesUsing: aDictionary	"Fix up stampHolder which is a ScrollingToolHolder, which is not a Morph"	super updateReferencesUsing: aDictionary.	stampHolder updateReferencesUsing: aDictionary.	colorMemory updateReferencesUsing: aDictionary.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/21/97 11:03'!actionCursor	"Return the cursor to use with this painting action/tool.  Offset of the form must be set."| f c old map width co |action == #paint: ifTrue: ["Make a cursor from the brush and the color"	old _ self getNib.	f _ ColorForm extent: old extent depth: 8.	old displayOn: f at: old offset negated.	map _ Color indexedColors copy.	map at: 1 put: Color transparent.	c _ self getColor.	c = Color white ifTrue: [c _ Color black].	c isTransparent ifTrue: [c _ Color black].	map at: 2 put: c.	f colors: map.	f offset: f extent // 2.	"Morphic thinks of it backwards"	^ f].action == #erase: ifTrue: ["Make a cursor from the cursor and the color"	width _ self getNib width.	co _ (currentCursor offset - (width//2@4)) max: (0@0).	f _ ColorForm extent: (width@width) + currentCursor extent depth: 8.	currentCursor displayOn: f at: currentCursor offset "<- stet" negated "0@0".		f colors: currentCursor colors.	f fill: (co extent: (width@width)) fillColor: Color black.	f offset: co + (width@width //2).	^ f].^ currentCursor! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/4/97 09:28'!brush: brushButton action: aSelector nib: aMask	"Set the current tool and action for the paintBox.  "	currentBrush ifNotNil: [		currentBrush == brushButton ifFalse: [currentBrush state: #off]].	currentBrush _ brushButton.		"A ThreePhaseButtonMorph"	"currentBrush state: #on.	already done"	"aSelector is like brush3:.  Don't save it.  Can always say (currentBrush arguments at: 2)	aMask is the brush shape.  Don't save it.  Can always say (currentBrush arguments at: 3)"	self brushable ifFalse: [self setAction: #paint:].	"User now thinking of painting"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/19/97 11:12'!brushable	"Return true if the current tool uses a brush."	^ (#("non-brushable" eyedropper: fill: pickup: stamp:) indexOf: action) = 0! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/18/97 21:44'!clear: clearButton with: clearSelector	| ss |	(ss _ self world findA: SketchEditorMorph) 		ifNotNil: [ss clear]		ifNil: [PopUpMenu notify: 			'You are currently not painting.  Choose Parts and drag out a new object.'			"Later have to change this for no EToy"].	clearButton state: #off.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/15/97 13:35'!colorable	"Return true if the current tool uses a color."	^ (#("These use no color" erase: eyedropper: "fill: does" pickup: stamp:) indexOf: action) = 0! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/19/97 19:13'!currentColor: aColor	"Accept a color from the outside.  (my colorMemoryMorph must call takeColorEvt: evt from: colorPicker instead)"	currentColor _ aColor.	colorMemory currentColor: aColor.	self showColor.	self colorable ifFalse: [self setAction: #paint:].	"User now thinking of painting"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/11/97 17:06'!deleteCurrentStamp	"The trash is telling us to delete the currently selected stamp"	(tool arguments at: 2) == #stamp: ifTrue: [		stampHolder remove: tool.		self setAction: #paint:].	"no use stamping with a blank stamp"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/30/97 21:51'!eyedropper: aButton action: aSelector cursor: aCursor	"Take total control and pick up a color!!!!"	| pt feedbackColor |	aButton state: #on.	tool ifNotNil: [tool state: #off].	currentCursor _ aCursor."	self world hands first showTemporaryCursor: aCursor 		hotSpotOffset: (aCursor ifNil: [0@0] ifNotNil: [aCursor offset])."	feedbackColor _ Display colorAt: Sensor cursorPoint.	self addMorphFront: colorMemory.	"Full color picker"	self world displayWorld.		[Sensor anyButtonPressed] whileFalse: [			pt _ Sensor cursorPoint.			feedbackColor _ Display colorAt: pt.			Display fill: (colorPatch bounds translateBy: self world viewBox origin) 					fillColor: feedbackColor].		Sensor waitNoButton."	self world hands first showTemporaryCursor: nil 		hotSpotOffset: 0@0."	self currentColor: feedbackColor.	colorMemory delete.	tool ifNotNil: [tool state: #on.		currentCursor _ tool arguments at: 3].	aButton state: #off.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/16/97 18:45'!findButton: aSelector	"Find this button in me"	submorphs do: [:button |		(button respondsTo: #arguments) 			ifTrue: [(button arguments at: 2) == aSelector ifTrue: [^ button]]			ifFalse: [(button isKindOf: LayoutMorph) ifTrue: [				button submorphsDo: [:sub |					(sub respondsTo: #arguments) 						ifTrue: [(sub arguments at: 2) == aSelector ifTrue: [^ sub]]]]].			].	^ nil! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/1/97 12:52'!getColor	^ currentColor! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/1/97 12:24'!getNib	^ currentBrush arguments at: 3! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/1/97 13:02'!getSpecial	^ action		"a selector like #paint:"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/28/97 15:35'!keep: keepButton with: keepSelector	"Showing of the corrent palette (viewer or noPalette) is done by the block submitted to the SketchMorphEditor, see (EToyHand makeNewDrawing) and (SketchMorph editDrawingInWorld:forBackground:)."	| ss |	owner ifNil: [^ self].	keepButton ifNotNil: [keepButton state: #off].	(ss _ self world findA: SketchEditorMorph) 		ifNotNil: [ss save]		ifNil: [keepSelector == #silent ifTrue: [^ self].			PopUpMenu notify: 'You are currently not painting.  Choose Parts and drag out a new object.'			"Later have to change wording for non EToy painting"].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/2/97 08:10'!mouseUpBalk: evt	"A button I own got a mouseDown, but the user moved out before letting up.  Prevent this for the current tool.  Some tool must stay selected."	tool state: #on.	"keep current one, even if user balked on it"	currentBrush ifNotNil: [currentBrush state: #on].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/11/97 21:02'!pickup: actionButton action: aSelector cursor: aCursor	"Special version for pickup: and stamp:, because of these tests"	| ss picker old map stamper |	self tool: actionButton action: aSelector cursor: aCursor.	aSelector == #stamp: ifTrue: [		(stampHolder pickupButtons includes: actionButton) ifTrue: [				stamper _ stampHolder otherButtonFor: actionButton.				^ self pickup: stamper action: #stamp: cursor: (stamper arguments at: 3)].		(stampHolder stampFormFor: actionButton) 			ifNil: [				"If not stamp there, go to pickup mode"				picker _ stampHolder otherButtonFor: actionButton.				picker state: #on.				^ self pickup: picker action: #pickup: cursor: (picker arguments at: 3)]			ifNotNil: [				old _ stampHolder stampFormFor: actionButton.				currentCursor _ ColorForm extent: old extent depth: 8.				old displayOn: currentCursor.				map _ Color indexedColors copy.				map at: 1 put: Color transparent.				currentCursor colors: map.				currentCursor offset: currentCursor extent // 2.				"Emphisize the stamp button"				actionButton owner "layoutMorph" "color: (Color r: 1.0 g: 0.645 b: 0.419);"					borderColor: (Color r: 0.65 g: 0.599 b: 0.8).				]].	aSelector == #pickup: ifTrue: [		ss _ self world findA: SketchEditorMorph.		ss ifNotNil: [currentCursor _ aCursor]	 			ifNil: [PopUpMenu notify: 				'You are currently not painting.  Choose Parts and drag out a new object.'.				self setAction: #paint:]].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/2/97 22:13'!pickupForm: stampForm	"Install the new picture in this stamp"	| stampButton |	stampHolder stampForm: stampForm for: tool.	stampButton _ action == #pickup: 		ifTrue: [stampHolder otherButtonFor: tool]		ifFalse: [tool].	"was a nil stampForm"	stampButton state: #on.	stampButton doButtonAction.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/21/97 11:33'!rememberColorsFrom: aForm	"Tell my colorMemory to show the colors this form has used."	"The new color picker does not remember colors""	colorMemory clear.	aForm colorsUsed do: [:val | colorMemory mark: val].	colorMemory invalidRect: colorMemory bounds."! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/14/97 17:32'!scrollStamps: actionButton action: aSelector	"Move the stamps over"	aSelector == #prevStamp:		ifTrue: [stampHolder scroll: -1]		ifFalse: [stampHolder scroll: 1].	actionButton state: #off.	action == #stamp: ifTrue: ["reselect the stamp and compute the cursor"		self stampForm 			ifNil: [self setAction: #paint:]			ifNotNil: [tool doButtonAction]].		! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/14/97 17:30'!setAction: aSelector	"Find this button and turn it on.  Does not work for stamps or pickups"	| button |	button _ self findButton: aSelector. 	button ifNotNil: [		button state: #on.		button doButtonAction].	"select it!!"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/19/97 20:44'!showColor	"Display the current color in all brushes, both on and off."	| offIndex onIndex byteIndex |	currentColor ifNil: [^ self].	colorPatch color: currentColor.	"May delete later"	(brushes == nil or: [brushes first owner ~~ self]) ifTrue: [		brushes _ OrderedCollection new.		#(brush1: brush2: brush3: brush4: brush5: brush6:) do: [:sel |			brushes addLast: (self findButton: sel)]].	(brushes at: 6) offImage depth = 8 ifFalse: [self error: 'this code not able to handle it yet'].	byteIndex _ (brushes at: 6) offImage bits size * 4 // 2.	"a byte in the center of picture."	offIndex _ (brushes at: 6) offImage bits byteAt: byteIndex.	"raw pixel value, not mapped"	onIndex _ (brushes at: 6) onImage bits byteAt: byteIndex.		"raw pixel value, not mapped"	brushes do: [:bb |		bb offImage colors at: offIndex+1 put: currentColor.		bb offImage colors: bb offImage colors.	"force a remap, very slow"		bb onImage colors at: onIndex+1 put: currentColor.		bb onImage colors: bb onImage colors.	"force a remap, very slow"		bb invalidRect: bb bounds].	self invalidRect: (brushes first topLeft rect: brushes last bottomRight).! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/17/97 14:03'!showColorPalette	"Remove this method later!!"	colorMemory align: colorMemory bounds topRight 			with: colorMemoryThin bounds topRight.	self addMorphFront: colorMemory! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/17/97 14:05'!showColorPalette: evt	| pp myEvt |	colorMemory align: colorMemory bounds topRight 			with: colorMemoryThin bounds topRight.	self addMorphFront: colorMemory.	"Be sure it gets a mouseEnter: and a mouseLeave:, even if mouse leaves on the next cycle." 	pp _ (colorMemory bounds insetBy: 1@1) pointNearestTo: evt cursorPoint.			"so it will be inside"	myEvt _ evt copy setCursorPoint: pp.	evt hand handleMouseOver: myEvt.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/16/97 11:19'!stampCursorBeCursorFor: anAction	"User just chose a stamp.  Take that stamp picture and make it be the cursor for the tool named."	"self stampCursorBeCursorFor: #star:.	currentCursor offset: 9@3.			Has side effect on the saved cursor."	(self findButton: anAction) arguments at: 3 put: currentCursor.		"Already converted to 8 bits and in the right form"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/11/97 21:04'!stampDeEmphasize	"Turn off an emphasized stamp.  Was turned on in pickup:action:cursor:"	tool owner class == LayoutMorph ifTrue: [		tool "actionButton" owner "layoutMorph" color: Color transparent; 					borderColor: Color transparent].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/2/97 14:02'!stampForm	"Return the selected stamp"	^ stampHolder stampFormFor: tool.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/17/97 11:47'!stampHolder	^ stampHolder! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/17/97 11:48'!stampHolder: newOne	stampHolder _ newOne! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/19/97 19:13'!takeColorEvt: evt from: colorPicker	"Accept a new color from the colorMemory.  Programs use currentColor: instead.  Do not do this before the picker has a chance to set its own color!!"	currentColor _ colorPicker currentColor.	self showColor.	self colorable ifFalse: [self setAction: #paint:].	"User now thinking of painting"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'di 10/14/97 06:24'!thumbnailOn: aMorph	"Try to show mineature of this guy.  5/5/97 tk   Not used now."	(aMorph isKindOf: SketchMorph) ifTrue: [		thumbnail morphToView: aMorph.		thumbnail step.		self invalidRect: thumbnail bounds].	! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/1/97 12:09'!tool	^ tool! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/17/97 09:22'!tool: actionButton action: aSelector cursor: aCursor	"Set the current tool and action for the paintBox.  "	tool ifNotNil: [		tool == actionButton ifFalse: [			tool state: #off.			action == #stamp: ifTrue: [self stampDeEmphasize]]].	tool _ actionButton.		"A ThreePhaseButtonMorph"	"tool state: #on.	already done"	action _ aSelector.		"paint:"	currentCursor _ aCursor.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/30/97 11:29'!toss: cancelButton with: cancelSelector	"Reject the painting.  Showing noPalette is done by the block submitted to the SketchMorphEditor, see (EToyHand makeNewDrawing) and (SketchMorph editDrawingInWorld:forBackground:)."	| ss |	owner ifNil: ["it happens"  ^ self].	(ss _ self world findA: SketchEditorMorph) 		ifNotNil: [ss cancel]		ifNil: [PopUpMenu notify: 			'You are currently not painting.  Choose Parts and drag out a new object.'			"Later have to change this for no EToy"].	cancelButton state: #off.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/18/97 21:45'!undo: undoButton with: undoSelector	| ss |	(ss _ self world findA: SketchEditorMorph) 		ifNotNil: [ss undo]		ifNil: [PopUpMenu notify: 			'You are currently not painting.  Choose Parts and drag out a new object.'			"Later have to change this for no EToy"].	undoButton state: #off.! !!PaintBoxMorph class methodsFor: 'all' stamp: 'jm 11/14/97 17:32'!new	| pb button dualUse formCanvas rect |	pb _ Prototype fullCopy.	pb stampHolder normalize.	"Get the stamps to show"	"Get my own copies of the brushes so I can modify them"	#(brush1: brush2: brush3: brush4: brush5: brush6:) do: [:sel |		button _ pb findButton: sel.		button offImage: button offImage deepCopy.		dualUse _ button onImage == button pressedImage.	"sometimes shared"		button onImage: button onImage deepCopy.		dualUse			ifTrue: [button pressedImage: button onImage]			ifFalse: [button pressedImage: button pressedImage deepCopy].		"force color maps for later mapping"		button offImage.		button onImage.		button pressedImage.		formCanvas _ FormCanvas on: button onImage.		formCanvas _ formCanvas			copyOrigin: 0@0			clipRect: (rect _ 0@0 extent: button onImage extent).		(#(brush1: brush3:) includes: sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@2)].		(#brush2: == sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@4)].		formCanvas frameAndFillRectangle: rect fillColor: Color transparent			borderWidth: 2 borderColor: (Color r: 0.599 g: 0.8 b: 1.0).		].	pb showColor.	^ pb! !!PaintBoxMorph class methodsFor: 'all' stamp: 'tk 10/12/97 11:01'!prototype	"Later we will be a subclass of Model, and it will have a general version of this"	^ Prototype! !!PaintBoxMorph class methodsFor: 'all' stamp: 'jm 10/23/97 10:40'!releaseTemporaryForms	"Release the temporary Forms used when loading new artwork."	AllOnImage _ AllOffImage _ AllPressedImage _ nil.	OriginalBounds _ nil.! !!Paragraph methodsFor: 'accessing'!backgroundColor	backColor == nil ifTrue: [^ Color white].	^ backColor! !!Paragraph methodsFor: 'accessing' stamp: 'di 10/5/97 15:33'!clippingRectangle: clipRect 	clippingRectangle _ clipRect! !!Paragraph methodsFor: 'accessing'!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	"find the starting and stopping lines"	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange _ aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle _ compositionRectangle withHeight: (textStyle lineGrid * 9999).	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner _ CompositionScanner new in: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex _ (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine _ startLine - 1.							self lineAt: startLine put: newLine.							startIndex _ newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			displayBoolean ifTrue: [destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor].			self updateCompositionHeight.			^self]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine _ compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY _ self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY _ self topAtLineIndex: firstLineIndex + 1.						stopLine _ firstLineIndex.						done _ true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex _ firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].		startIndex _ newLine last + 1.		firstLineIndex _ firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine _ firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle _				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"Default display message when aDisplayPoint is in absolute screen	coordinates."	rule _ ruleInteger.	mask _ aForm.	clippingRectangle _ clipRectangle.	compositionRectangle _ aDisplayPoint extent: compositionRectangle extent.	(lastLine == nil or: [lastLine < 1]) ifTrue: [self composeAll].	self displayOn: aDisplayMedium lines: (1 to: lastLine)! !!Paragraph methodsFor: 'composition'!composeAll	"Compose a collection of characters into a collection of lines."	| startIndex stopIndex lineIndex maximumRightX compositionScanner |	lines _ Array new: 32.	lastLine _ 0.	maximumRightX _ 0.	text size = 0		ifTrue:			[compositionRectangle _ compositionRectangle withHeight: 0.			^maximumRightX].	startIndex _ lineIndex _ 1.	stopIndex _ text size.	compositionScanner _ CompositionScanner new in: self.	[startIndex > stopIndex] whileFalse: 		[self lineAt: lineIndex 				put: (compositionScanner composeLine: lineIndex 										fromCharacterIndex: startIndex 										inParagraph: self).		 maximumRightX _ compositionScanner rightX max: maximumRightX.		 startIndex _ (lines at: lineIndex) last + 1.		 lineIndex _ lineIndex + 1].	self updateCompositionHeight.	self trimLinesTo: lineIndex - 1.	^ maximumRightX! !!Paragraph methodsFor: 'character location' stamp: 'di 11/30/97 10:10'!defaultCharacterBlock	^ CharacterBlock new stringIndex: 1 text: text			topLeft: compositionRectangle topLeft extent: 0 @ 0! !!Paragraph methodsFor: 'selecting'!caretFormForDepth: depth	"Return a caret form for the given depth."	"(Paragraph new caretFormForDepth: Display depth) displayOn: Display at: 0@0 rule: Form reverse"	| box f bb map |	box _ CaretForm boundingBox.	f _ Form extent: box extent depth: depth.	map _ (Color cachedColormapFrom: CaretForm depth to: depth) copy.	map at: 1 put: (Color transparent pixelValueForDepth: depth).	map at: 2 put: (Color quickHighLight: depth) first.  "pixel value for reversing"	bb _ BitBlt toForm: f.	bb		sourceForm: CaretForm;		sourceRect: box;		destOrigin: 0@0;		colorMap: map; 		combinationRule: Form over;		copyBits.	^ f! !!Paragraph methodsFor: 'selecting' stamp: 'di 1/14/98 09:48'!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range box boxes |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex) 		do: [:att | att mayActOnClick ifTrue:				[range _ text rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last).				box _ boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: box repeating: []						ifSucceed: [							aController controlTerminate.							(att actOnClickFor: model) ifTrue: [action _ true].							aController controlInitialize].				]].	^ action! !!Paragraph methodsFor: 'selecting' stamp: 'di 6/23/97 23:14'!hiliteRect: rect	(rect ~~ nil) ifTrue:		[ destinationForm			fill: rect			rule: Form reverse			fillColor: destinationForm highLight.		"destinationForm			fill: (rect translateBy: 1@1)			rule: Form reverse			fillColor: destinationForm highLight" ].! !!Paragraph methodsFor: 'selecting' stamp: 'jm 7/8/97 12:25'!mouseMovedFrom: beginBlock pivotBlock: pivotBlock showingCaret: caretOn 	| startBlock stopBlock showingCaret |	stopBlock _ startBlock _ beginBlock.	showingCaret _ caretOn.	[Sensor redButtonPressed]		whileTrue: 			[stopBlock _ self characterBlockAtPoint: Sensor cursorPoint.			stopBlock = startBlock				ifFalse: 					[showingCaret						ifTrue: 							[showingCaret _ false.							self reverseFrom: pivotBlock to: pivotBlock].			((startBlock >= pivotBlock and: [stopBlock >= pivotBlock])				or: [startBlock <= pivotBlock and: [stopBlock <= pivotBlock]])				ifTrue: 					[self reverseFrom: startBlock to: stopBlock.					startBlock _ stopBlock]				ifFalse: 					[self reverseFrom: startBlock to: pivotBlock.					self reverseFrom: pivotBlock to: stopBlock.					startBlock _ stopBlock].			(clippingRectangle containsRect: stopBlock) ifFalse:				[stopBlock top < clippingRectangle top				ifTrue: [self scrollBy: stopBlock top - clippingRectangle top						withSelectionFrom: pivotBlock to: stopBlock]				ifFalse: [self scrollBy: stopBlock bottom + textStyle lineGrid - clippingRectangle bottom						withSelectionFrom: pivotBlock to: stopBlock]]]].	pivotBlock = stopBlock ifTrue:		[showingCaret ifFalse:  "restore caret"			[self reverseFrom: pivotBlock to: pivotBlock]].	^ Array with: pivotBlock with: stopBlock! !!Paragraph methodsFor: 'selecting'!reverseFrom: characterBlock1 to: characterBlock2 	"Reverse area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline caret |	characterBlock1 = characterBlock2 ifTrue:		[lineNo _ self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline _ lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		caret _ self caretFormForDepth: Display depth.		^ caret  "Use a caret to indicate null selection"				displayOn: destinationForm				at: characterBlock1 topLeft + (-3 @ baseline)				clippingBox: clippingRectangle				rule: (false "Display depth>8" ifTrue: [9 "not-reverse"]									ifFalse: [Form reverse])				fillColor: nil].	visibleRectangle _ 		(clippingRectangle intersect: compositionRectangle)			"intersect: destinationForm boundingBox" "not necessary".	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle _ 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle _ 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle _ 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle _ 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	self hiliteRect: initialRectangle.	self hiliteRect: interiorRectangle.	self hiliteRect: finalRectangle.! !!Paragraph methodsFor: 'selecting' stamp: 'di 12/1/97 04:43'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline |	characterBlock1 = characterBlock2 ifTrue:		[lineNo _ self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline _ lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		^ Array with: (characterBlock1 topLeft extent: 1 @ baseline)].	visibleRectangle _ clippingRectangle intersect: compositionRectangle.	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle _ 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle _ 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle _ 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle _ 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	^ (Array with: initialRectangle with: interiorRectangle with: finalRectangle)			select: [:rect | rect notNil]! !!Paragraph methodsFor: 'scrolling'!scrollUncheckedBy: heightToMove withSelectionFrom: startBlock to: stopBlock 	"Scroll by the given amount.  Copy bits where possible, display the rest.	If selection blocks are not nil, then select the newly visible text as well."	| savedClippingRectangle delta |	delta _ 0 @ (0 - heightToMove).	compositionRectangle _ compositionRectangle translateBy: delta.	startBlock == nil ifFalse:		[startBlock moveBy: delta.		stopBlock moveBy: delta].	savedClippingRectangle _ clippingRectangle.	clippingRectangle _ clippingRectangle intersect: Display boundingBox.	heightToMove abs >= clippingRectangle height	  ifTrue: 		["Entire visible region must be repainted"		self displayLines: (1 to: lastLine) affectedRectangle: clippingRectangle]	  ifFalse:		["Copy bits where possible / display the rest"		destinationForm			copyBits: clippingRectangle from: destinationForm			at: clippingRectangle topLeft + delta			clippingBox: clippingRectangle			rule: Form over fillColor: nil.		"Set clippingRectangle to 'vacated' area for lines 'pulled' into view."		clippingRectangle _ heightToMove < 0			ifTrue:  "On the top"				[clippingRectangle topLeft corner: clippingRectangle topRight + delta]			ifFalse:  "At the bottom"				[clippingRectangle bottomLeft + delta corner: clippingRectangle bottomRight].		self displayLines: (1 to: lastLine)   "Refresh vacated region"			affectedRectangle: clippingRectangle].	startBlock == nil ifFalse:		[self reverseFrom: startBlock to: stopBlock].	"And restore the clippingRectangle to its original value. "	clippingRectangle _ savedClippingRectangle! !!Paragraph methodsFor: 'utilities'!fit	"Make the bounding rectangle of the receiver contain all the text without 	changing the width of the receiver's composition rectangle."	[(self lineIndexOfTop: clippingRectangle top) = 1]		whileFalse: [self scrollBy: (0-1)*textStyle lineGrid].	self updateCompositionHeight.	clippingRectangle _ clippingRectangle withBottom: compositionRectangle bottom! !!Paragraph methodsFor: 'converting'!asForm	"Answer a Form made up of the bits that represent the receiver's displayable text."	| theForm oldBackColor oldForeColor |	theForm _ (ColorForm extent: compositionRectangle extent)		offset: offset;		colors: (Array			with: (backColor == nil ifTrue: [Color transparent] ifFalse: [backColor])			with: (foreColor == nil ifTrue: [Color black] ifFalse: [foreColor])).	oldBackColor _ backColor.	oldForeColor _ foreColor.	backColor _ Color white.	foreColor _ Color black.	self displayOn: theForm		at: 0@0		clippingBox: theForm boundingBox		rule: Form over		fillColor: nil.	backColor _ oldBackColor.	foreColor _ oldForeColor.	^ theForm"Example:| p |p _ 'Abc' asParagraph.p foregroundColor: Color red backgroundColor: Color black.p asForm displayOn: Display at: 30@30 rule: Form over"! !!Paragraph methodsFor: 'private'!bottomAtLineIndex: lineIndex 	"Answer the bottom y of given line."	| y |	y _ compositionRectangle top.	lastLine = 0 ifTrue: [^ y + textStyle lineGrid].	1 to: (lineIndex min: lastLine) do:		[:i | y _ y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private' stamp: 'tk 9/30/96'!compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint	compositionRectangle _ compositionRect copy.	text _ aText.	textStyle _ aTextStyle.	rule _ DefaultRule.	mask _ nil.		"was DefaultMask "	marginTabsLevel _ 0.	destinationForm _ Display.	offset _ aPoint.	^self composeAll! !!Paragraph methodsFor: 'private'!displayLines: linesInterval affectedRectangle: affectedRectangle	"This is the first level workhorse in the display portion of the TextForm routines.	It checks to see which lines in the interval are actually visible, has the	CharacterScanner display only those, clears out the areas in which display will	occur, and clears any space remaining in the visibleRectangle following the space	occupied by lastLine."	| lineGrid topY firstLineIndex lastLineIndex lastLineIndexBottom |	"Save some time by only displaying visible lines"	firstLineIndex _ self lineIndexOfTop: affectedRectangle top.	firstLineIndex < linesInterval first ifTrue: [firstLineIndex _ linesInterval first].	lastLineIndex _ self lineIndexOfTop: affectedRectangle bottom - 1.	lastLineIndex > linesInterval last ifTrue:			[linesInterval last > lastLine		 		ifTrue: [lastLineIndex _ lastLine]		  		ifFalse: [lastLineIndex _ linesInterval last]].	lastLineIndexBottom _ (self bottomAtLineIndex: lastLineIndex).	((Rectangle 		origin: affectedRectangle left @ (topY _ self topAtLineIndex: firstLineIndex) 		corner: affectedRectangle right @ lastLineIndexBottom)	  intersects: affectedRectangle)		ifTrue: [ " . . . (skip to clear-below if no lines displayed)"				DisplayScanner new					displayLines: (firstLineIndex to: lastLineIndex)					in: self clippedBy: affectedRectangle].	lastLineIndex = lastLine ifTrue: 		 [destinationForm  "Clear out white space below last line"		 	fill: (affectedRectangle left @ (lastLineIndexBottom max: affectedRectangle top)				corner: affectedRectangle bottomRight)		 	rule: rule fillColor: self backgroundColor]! !!Paragraph methodsFor: 'private'!leftMarginForDisplayForLine: lineIndex 	"Build the left margin for display of a line. Depends upon	leftMarginForComposition, compositionRectangle left and the alignment."	| pad |	(textStyle alignment = LeftFlush or: [textStyle alignment = Justified])		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex)].	"When called from character location code and entire string has been cut,	there are no valid lines, hence following nil check."	(lineIndex <= lines size and: [(lines at: lineIndex) notNil])		ifTrue: 			[pad _ (lines at: lineIndex) paddingWidth]		ifFalse: 			[pad _ 				compositionRectangle width - textStyle firstIndent - textStyle rightIndent].	textStyle alignment = Centered 		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + (pad // 2)].	textStyle alignment = RightFlush 		ifTrue:			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + pad].	self error: ['no such alignment']! !!Paragraph methodsFor: 'private'!lineIndexOfTop: top 	"Answer the line index at a given top y."	| y line |	lastLine = 0 ifTrue: [^ 1].	y _ compositionRectangle top.	1 to: lastLine do:		[:i | line _ lines at: i.		(y _ y + line lineHeight) > top ifTrue: [^ i]].	^ lastLine! !!Paragraph methodsFor: 'private'!moveBy: delta	compositionRectangle _ compositionRectangle translateBy: delta.	clippingRectangle _ clippingRectangle translateBy: delta.! !!Paragraph methodsFor: 'private'!removeFirstChars: numberOfChars	"Remove a number of characters from the beginning of the receiver,	adjusting the composition rectangle so the displayed text moves as little as	possible. Special kludge for TextCollectorController."	"9/14/82 SBP"	| delta scrollDelta |	delta _ ((self lineIndexOfCharacterIndex: numberOfChars)-1)*self lineGrid.	scrollDelta _ self compositionRectangleDelta negated.	delta > scrollDelta ifTrue:		[delta _ scrollDelta. 	"deleting some visible lines"		self clearVisibleRectangle].	self replaceFrom: 1 to: numberOfChars with: '' asText displaying: false.	compositionRectangle _ compositionRectangle translateBy: 0@delta.	delta = scrollDelta ifTrue: [self display]! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle 	"Set text and adjust bounding rectangles to fit."	| shrink compositionWidth unbounded |	unbounded _ Rectangle origin: 0 @ 0 extent: 9999@9999.	compositionWidth _ self		setWithText: aText style: aTextStyle compositionRectangle: unbounded clippingRectangle: unbounded.	compositionRectangle _ compositionRectangle withWidth: compositionWidth.	clippingRectangle _ compositionRectangle copy.	shrink _ unbounded width - compositionWidth.	"Shrink padding widths accordingly"	1 to: lastLine do:		[:i | (lines at: i) paddingWidth: (lines at: i) paddingWidth - shrink]! !!Paragraph methodsFor: 'private'!topAtLineIndex: lineIndex 	"Answer the top y of given line."	| y |	y _ compositionRectangle top.	lastLine = 0 ifTrue: [lineIndex > 0 ifTrue: [^ y + textStyle lineGrid]. ^ y].	1 to: (lineIndex-1 min: lastLine) do:		[:i | y _ y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private'!topAtLineIndex: lineIndex using: otherLines and: otherLastLine	"Answer the top y of given line."	| y |	y _ compositionRectangle top.	otherLastLine = 0 ifTrue: [^ y].	1 to: (lineIndex-1 min: otherLastLine) do:		[:i | y _ y + (otherLines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private'!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work." 	compositionRectangle _ compositionRectangle withHeight:		(self bottomAtLineIndex: lastLine) - compositionRectangle top.	(text size ~= 0 and: [(text at: text size) = CR])		ifTrue: [compositionRectangle _ compositionRectangle withHeight:					compositionRectangle height + (lines at: lastLine) lineHeight]! !!Paragraph methodsFor: 'private' stamp: 'di 8/30/97 11:14'!withClippingRectangle: clipRect do: aBlock	| saveClip |	saveClip _ clippingRectangle.	clippingRectangle _ clipRect.		aBlock value.	clippingRectangle _ saveClip! !!Paragraph class methodsFor: 'examples' stamp: 'tk 9/30/96'!example	"This simple example illustrates how to display a few lines of text on the screen at the current cursor point.  	Fixed. "	| para point |	point _ Sensor waitButton.	para _ 'This is the first line of charactersand this is the second line.' asParagraph.	para displayOn: Display at: point.	"Paragraph example"! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 11/30/97 10:13'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	startBlock _ paragraph defaultCharacterBlock.	stopBlock _ startBlock copy.	beginTypeInBlock _ nil.	UndoInterval _ otherInterval _ 1 to: 0.	self setEmphasisHere.	selectionShowing _ false.	initialText _ paragraph text copy! !!ParagraphEditor methodsFor: 'scrolling'!computeMarkerRegion 	"Refer to the comment in ScrollController|computeMarkerRegion."	paragraph compositionRectangle height = 0		ifTrue:	[^0@0 extent: Preferences scrollBarWidth @ scrollBar inside height]		ifFalse:	[^0@0 extent:					Preferences scrollBarWidth 						@ ((paragraph clippingRectangle height asFloat /							self scrollRectangleHeight * scrollBar inside height) rounded							min: scrollBar inside height)]! !!ParagraphEditor methodsFor: 'scrolling'!scrollBar	^ scrollBar! !!ParagraphEditor methodsFor: 'sensor access' stamp: 'tk 1/7/98 12:03'!processRedButton	"The user pressed a red mouse button, meaning create a new text 	selection. Highlighting the selection is carried out by the paragraph 	itself. Double clicking causes a selection of the area between the nearest 	enclosing delimitors."	| previousStartBlock previousStopBlock selectionBlocks tempBlock clickPoint oldDelta oldInterval |	clickPoint _ sensor cursorPoint.	(view containsPoint: clickPoint) ifFalse: [^ self].	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [^ self].	oldInterval _ startBlock stringIndex to: stopBlock stringIndex - 1.	previousStartBlock _ startBlock.	previousStopBlock _ stopBlock.	oldDelta _ paragraph scrollDelta.	sensor leftShiftDown		ifFalse:			[self deselect.			self closeTypeIn.			selectionBlocks _ paragraph mouseSelect: clickPoint]		ifTrue:			[selectionBlocks _ paragraph extendSelectionAt: startBlock endBlock: stopBlock.			self closeTypeIn].	selectionShowing _ true.	startBlock _ selectionBlocks at: 1.	stopBlock _ selectionBlocks at: 2.	startBlock > stopBlock		ifTrue: 			[tempBlock _ startBlock.			startBlock _ stopBlock.			stopBlock _ tempBlock].	(startBlock = stopBlock 		and: [previousStartBlock = startBlock and: [previousStopBlock = stopBlock]])		ifTrue: [self selectWord].	oldDelta ~= paragraph scrollDelta "case of autoscroll"			ifTrue: [self updateMarker].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 1/15/98 12:57'!accept	"Save the current text of the text being edited as the current acceptable version for purposes of canceling."	initialText _ paragraph text copy.	view ifNotNil: [view accepted]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 16:30'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry |	self lineSelectAndEmptyCheck: [^ self].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[aSymbol first isUppercase			ifTrue:				[anEntry _ (Smalltalk at: aSymbol ifAbsent: [nil]).				anEntry isNil ifTrue: [^ view flash].				(anEntry isKindOf: Class)					ifTrue:						[BrowserView browseFullForClass: anEntry method: nil from: self]					ifFalse:						[anEntry inspect]]			ifFalse:				[Smalltalk browseAllImplementorsOf: aSymbol]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 1/15/98 12:57'!cancel 	"Restore the text of the paragraph to be the text saved since initialization 	or the last accept.  Undoer & Redoer: undoAndReselect:redoAndReselect:.	This used to call controlTerminate and controlInitialize but this seemed illogical.	Sure enough, nobody overrode them who had cancel in the menu, and if	anybody really cared they could override cancel."	UndoSelection _ paragraph text.	self undoer: #undoAndReselect:redoAndReselect: with: self selectionInterval with: (1 to: 0).	view ifNotNil: [view clearInside].	self changeParagraph: (paragraph text: initialText).	UndoParagraph _ paragraph.	otherInterval _ UndoInterval _ 1 to: initialText size. "so undo will replace all"	paragraph displayOn: Display.	self selectAt: 1.	self scrollToTop! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/2/97 11:36'!changeAlignment	| aList reply  |	aList _ #(leftFlush centered justified rightFlush).	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[paragraph perform: reply.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/2/97 11:39'!changeEmphasis	| aList reply  |	aList _ #(plain bold italic narrow underlined struckOut).	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self setEmphasis: reply.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/20/97 20:11'!changeStyle	"Let user change styles for the current text pane  	 Moved from experimentalCommand to its own method  "	| aList reply style |	aList _ (TextConstants select: [:thang | thang isKindOf: TextStyle])			keys asOrderedCollection.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[(style _ TextStyle named: reply) ifNil: [self beep. ^ true].		paragraph textStyle: style copy.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'menu messages'!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."	| s |	s _ Smalltalk clipboardText.	(s isEmpty or: [s = CurrentSelection string])		ifTrue: [^ CurrentSelection]		ifFalse: [^ s asText]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:09'!copySelection	"Copy the current selection and store it in the paste buffer, unless a caret.  Undoer & Redoer: undoCutCopy"	self lineSelectAndEmptyCheck: [^ self].	"Simulate 'substitute: self selection' without locking the controller"	UndoSelection _ self selection.	self undoer: #undoCutCopy: with: self clipboardText.	UndoInterval _ self selectionInterval.	self clipboardTextPut: UndoSelection! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 16:33'!cut	"Cut out the current selection and redisplay the paragraph if necessary.  Undoer & Redoer: undoCutCopy:"	self lineSelectAndEmptyCheck: [^ self].	self replaceSelectionWith: self nullText. 	self undoer: #undoCutCopy: with: self clipboardText.	self clipboardTextPut: UndoSelection! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 1/15/96'!explain	"Try to shed some light on what kind of entity the current selection is. 	The selection must be a single token or construct. Insert the answer after 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil.	: put here intact from BrowserCodeController.  But there's too many things that still don't work, as the explain code was very tightly bound with properties of code browsers.  So for the moment, in the interest of system integrity, we don't permit.  "	| string tiVars cgVars selectors delimitors numbers sorry reply newLine |	true ifTrue:		[self flag: #noteToTed.   "Feel like taking this on?  Plenty of things make sense to explain in any text window, but my efforts to elevate the explain facility to more generic use ran out of steam before success."		^ self inform: 'Sorry, explain is currently availableonly in code panes.  Someday, it may be availablein any text pane.  Maybe.'].	newLine _ String with: Character cr.	Cursor execute		showWhile: 			[sorry _ '"Sorry, I can''t explain that.  Please select a single token, construct, or special character.'.			sorry _ sorry , (model isUnlocked							ifTrue: ['"']							ifFalse: ['  Also, please cancel or accept."']).			(string _ self selection asString) isEmpty				ifTrue: [reply _ '']				ifFalse: 					[string _ self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are 					all  					letters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: [])						~~ nil						ifFalse: 							[tiVars _ self explainTemp: string.							tiVars == nil ifTrue: [tiVars _ self explainInst: string]].					(tiVars == nil and: [model class == Browser])						ifTrue: [tiVars _ model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars _ '']						ifFalse: [tiVars _ tiVars , newLine].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:symbol | symbol])						ifTrue: 							[cgVars _ self explainCtxt: symbol.							cgVars == nil								ifTrue: 									[cgVars _ self explainClass: symbol.									cgVars == nil ifTrue: [cgVars _ self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors _ self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors _ self explainPartSel: string.									selectors == nil ifTrue: [selectors _ self explainAnySel: symbol]]]						ifFalse: [selectors _ self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars _ '']						ifFalse: [cgVars _ cgVars , newLine].					selectors == nil						ifTrue: [selectors _ '']						ifFalse: [selectors _ selectors , newLine].					string size = 1						ifTrue: ["single special characters"							delimitors _ self explainChar: string]						ifFalse: ["matched delimitors"							delimitors _ self explainDelimitor: string].					numbers _ self explainNumber: string.					numbers == nil ifTrue: [numbers _ ''].					delimitors == nil ifTrue: [delimitors _ ''].					reply _ tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply _ sorry].			self afterSelectionInsertAndSelect: reply]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 1/15/96'!explainGlobal: symbol 	"Is symbol a global variable?	 : copied intact from BrowserCodeController"	| reply classes newLine |	self flag: #noteToTed.  "a fumbling piece of the generic-explain attempt."	newLine _ String with: Character cr.	reply _ Smalltalk at: symbol ifAbsent: [^nil].	(reply isKindOf: Behavior)		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,			'."', newLine, 'Browser newOnClass: ' , symbol , '.'].	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].	reply class == Dictionary		ifTrue: 			[classes _ Set new.			Smalltalk allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]					ifNone: [])					~~ nil ifTrue: [classes add: each]].			classes _ classes printString.			^'"is a global variable.  ' , symbol , ' is a Dictionary.  It is a pool which is used by the following classes' , (classes copyFrom: 4 to: classes size) , '"'].	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:07'!implementorsOfIt	"Open an implementors browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [Smalltalk browseAllImplementorsOf: aSelector]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 16:34'!lineSelectAndEmptyCheck: returnBlock	"If the current selection is an insertion point, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."	self selectLine.  "if current selection is an insertion point, then first select the entire line in which occurs before proceeding"	startBlock = stopBlock ifTrue: [view flash.  ^ self]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:26'!methodNamesContainingIt	"Open a browser on methods names containing the selected string"	self lineSelectAndEmptyCheck: [^ self].	Cursor wait showWhile:		[self terminateAndInitializeAround: [Smalltalk browseMethodsWhoseNamesContain: self selection string withBlanksTrimmed]].	Cursor normal show! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:10'!methodSourceContainingIt	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).   EXTREMELY slow!!"	self lineSelectAndEmptyCheck: [^ self].	(self confirm: 'This will take a few minutes.Shall I proceed?') ifFalse: [^ self].	Smalltalk browseMethodsWithSourceString: self selection string! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/15/97 13:26'!methodStringsContainingit	"Open a browser on methods which contain the current selection as part of a string constant."	self lineSelectAndEmptyCheck: [^ self].	self terminateAndInitializeAround: [Smalltalk browseMethodsWithString: self selection string]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/2/97 11:34'!mvcRedisplay	"Overridable by subclasses that do their own display"	Display fill: paragraph clippingRectangle 			fillColor: view backgroundColor.	"very brute force"	self display! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 16:39'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self lineSelectAndEmptyCheck: [^ self].	((aSymbol _ self selectedSymbol) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^ view flash].	self terminateAndInitializeAround: [Smalltalk browseAllCallsOn: (Smalltalk associationAt: self selectedSymbol)]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:11'!sendersOfIt	"Open a senders browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [Smalltalk browseAllCallsOn: aSelector]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 16:12'!setSearchString	"Make the current selection, if any, be the current search string."	startBlock = stopBlock ifTrue: [view flash. ^ self].	self setSearch:  self selection string! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 9/9/97 16:42'!shiftedYellowButtonMenu	"Answer the menu to be presented when the yellow button is pressed while the shift key is down. 3/13/96 sw	 5/27/96 sw: added font menu"	^ PopUpMenu labels: 'set font... (k)set style... (K)explainformatfile it inrecognizer (r)spawn (o)browse it (b)senders of it (n)implementors of it (m)references to it (N)selectors containing it (W)method strings with it (E)method source with itspecial menu...more...' 		lines: #(2 7 14).! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 4/29/96'!specialMenuItems	"Refer to comment under #presentSpecialMenu.  .	 : added objectsReferencingIt,"	^ #(	'Transcript cr; show: ''testing'''			'view superView model inspect'			'view superView model browseObjClass'			'view display'			'self inspect'			'view backgroundColor: Color fromUser'			'view topView inspect'			'self compareToClipboard'			'view insideColor: Form white'			'self objectsReferencingIt'		) ! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 1/14/98 09:44'!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to accept characters with the change in emphasis. Emphasis change amounts to a font change.  Keeps typeahead."	| keyCode attribute oldAttributes index thisSel colors |		 "control 0..9 -> 0..9"	keyCode _ ('0123456789-=' indexOf: sensor keyboard ifAbsent: [1]) - 1.	oldAttributes _ paragraph text attributesAt: startBlock stringIndex.	thisSel _ self selection.	"Decipher keyCodes for Command 0-9..."	(keyCode between: 1 and: 5) ifTrue:		[attribute _ TextFontChange fontNumber: keyCode].	keyCode = 6 ifTrue:		[colors _ #(black magenta red yellow green blue cyan white).		index _ (PopUpMenu labelArray: colors , #('Do it' 'Link to comment of class' 'Link to definition of class' 'Link to hierarchy of class' 'Link to method' 'URL' 'Copy hidden info')							lines: (Array with: colors size)) startUp.		index = 0 ifTrue: [^ true].		index <= colors size		ifTrue:			[attribute _ TextColor color: (Color perform: (colors at: index))]		ifFalse:			[index _ index - colors size.			index = 1 ifTrue: [attribute _ TextDoIt new.				thisSel _ attribute analyze: self selection asString].			index = 2 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Comment'].			index = 3 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Definition'].			index = 4 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Hierarchy'].			index = 5 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString].			index = 6 ifTrue: [attribute _ TextURL new. 				thisSel _ attribute analyze: self selection asString].			index = 7 ifTrue: ["Copy hidden info"				self copyHiddenInfo.  ^ true].	"no other action"		thisSel ifNil: [^ true]].	"Could not figure out what to link to"		].	(keyCode between: 7 and: 11) ifTrue:		[sensor leftShiftDown		ifTrue:			[keyCode = 10 ifTrue: [attribute _ TextKern kern: -1].			keyCode = 11 ifTrue: [attribute _ TextKern kern: 1]]		ifFalse:			[attribute _ TextEmphasis perform:					(#(bold italic narrow underlined struckOut) at: keyCode - 6).			oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]]].	(keyCode = 0) ifTrue:		[attribute _ TextEmphasis normal].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream.			emphasisHere _ Text addAttribute: attribute toArray: oldAttributes.			^ true].	self replaceSelectionWith: (thisSel asText addAttribute: attribute).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 12/30/97 10:43'!copyHiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden info.  Copy that to the clipboard.  You can paste it and see what it is.  Usually enclosed in <>."	| attrList |	attrList _ paragraph text attributesAt: (startBlock stringIndex + stopBlock stringIndex)//2.	attrList do: [:attr |		attr class == TextLink ifTrue: [			^ self clipboardTextPut: ('<', attr info, '>') asText].		attr class == TextURL ifTrue: [			^ self clipboardTextPut: ('<', attr info, '>') asText].		attr class == TextAction ifTrue: [			^ self clipboardTextPut: ('<', attr info, '>') asText].		].	"If none of the above"	attrList do: [:attr |		attr class == TextColor ifTrue: [			^ self clipboardTextPut: attr color printString asText]].	^ self clipboardTextPut: '[No hidden info]' asText! !!ParagraphEditor methodsFor: 'editing keys'!enclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char _ sensor keyboard.	self closeTypeIn.	startIndex _ startBlock stringIndex.	stopIndex _ stopBlock stringIndex.	oldSelection _ self selection.	which _ '([<{"''' indexOf: char ifAbsent: [ ^true ].	left _ '([<{"''' at: which.	right _ ')]>}"''' at: which.	text _ paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 8/1/97 15:18'!methodNamesContainingIt: characterStream 	"Browse methods whose selectors containing the selection in their names"	sensor keyboard.		"flush character"	self methodNamesContainingIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 9/9/97 16:44'!methodStringsContainingIt: characterStream 	"Invoked from cmd-E -- open a browser on all methods holding string constants containing it.  Flushes typeahead. "	sensor keyboard.		self methodStringsContainingit.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 5/27/96'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList _ paragraph textStyle fontNames.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 8/1/97 16:14'!selectLine	"Make the receiver's selection, if it currently consists of an insertion point only, encompass the current line."	| string left right |	string _ paragraph text string.	left _ startBlock stringIndex.	right _ stopBlock stringIndex - 1.	left > right ifFalse: [^ self].	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:		[left _ left - 1].	[right < string size and: [(string at: (right + 1)) ~= Character cr]] whileTrue:		[right _ right + 1].	self selectFrom: left to: (right min: string size)! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 8/12/97 22:15'!setEmphasis: emphasisSymbol	"Change the emphasis of the current selection."	| oldAttributes attribute |	oldAttributes _ paragraph text attributesAt: startBlock stringIndex.	(emphasisSymbol == #plain) 		ifTrue:			[attribute _ TextEmphasis normal]		ifFalse:			[attribute _ TextEmphasis perform: emphasisSymbol.			oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	self replaceSelectionWith: (self selection addAttribute: attribute)! !!ParagraphEditor methodsFor: 'editing keys'!shiftEnclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char _ sensor keyboard.	char = $9 ifTrue: [ char _ $( ].	char = $, ifTrue: [ char _ $< ].	char = $[ ifTrue: [ char _ ${ ].	char = $' ifTrue: [ char _ $" ].	char asciiValue = 27 ifTrue: [ char _ ${ ].	"ctrl-["	self closeTypeIn.	startIndex _ startBlock stringIndex.	stopIndex _ stopBlock stringIndex.	oldSelection _ self selection.	which _ '([<{"''' indexOf: char ifAbsent: [1].	left _ '([<{"''' at: which.	right _ ')]>}"''' at: which.	text _ paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 1/18/96'!swapChars: characterStream 	"Triggered byCmd-Y;.  Swap two characters, either those straddling the insertion point, or the two that comprise the selection.  Suggested by Ted Kaehler.  "	| currentSelection aString chars |	sensor keyboard.		"flush the triggering cmd-key character"	(chars _ self selection) size == 0		ifTrue:			[currentSelection _ startBlock stringIndex]		ifFalse:			[chars size == 2				ifFalse:					[view flash.  ^ true]				ifTrue:					[currentSelection _ startBlock stringIndex + 1]].	self selectFrom: currentSelection - 1 to: currentSelection.	aString _ self selection string.	self replaceSelectionWith: (Text fromString: aString reversed).	self selectAt: currentSelection + 1.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!crWithIndent: characterStream 	"Replace the current text selection with CR followed by as many tabs	as on the current line (+/- bracket count) -- initiated by Shift-Return."	| char s i tabCount |	sensor keyboard.		"flush character"	s _ paragraph string.	i _ stopBlock stringIndex.	tabCount _ 0.	[(i _ i-1) > 0 and: [(char _ s at: i) ~= Character cr]]		whileTrue:  "Count tabs and brackets (but not a leading bracket)"		[(char = Character tab and: [(s at: i+1) ~= $[]) ifTrue: [tabCount _ tabCount + 1].		char = $[ ifTrue: [tabCount _ tabCount + 1].		char = $] ifTrue: [tabCount _ tabCount - 1]].	characterStream crtab: tabCount.  "Now inject CR with tabCount tabs"	^ false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!cursorDown: characterStream "Private - Move cursor from position in current line to same position innext line. If next line too short, put at end. If shift key down,select."	| shift string right left start position textSize|	shift := sensor leftShiftDown.	sensor keyboard.	string _ paragraph text string.	textSize _ string size.	left _ right _ stopBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	position _ stopBlock stringIndex - left.	[right < textSize and: [(string at: right) ~= Character cr]] whileTrue:[right _ right + 1].	right _ start _ right + 1.	[right < textSize and: [(string at: right) ~= Character cr]] whileTrue:[right _ right + 1].	shift		ifTrue: 			[			start + position > right				ifTrue: [self selectFrom: startBlock stringIndex to: right - 1]				ifFalse: [self selectFrom: startBlock stringIndex to: start +position - 1]			]		ifFalse: 			[			start + position > right				ifTrue: [self selectFrom: right to: right - 1]				ifFalse: [self selectFrom: start + position to: start + position -1]			].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!cursorEnd: characterStream "Private - Move cursor end of current line. If cursor already at end ofline, put cursor at end of text"	| string right stringSize |	sensor keyboard.	string _ paragraph text string.	stringSize _ string size.	right _ stopBlock stringIndex.	[right <= stringSize and: [(string at: right) ~= Character cr]]whileTrue: [right _ right + 1].	stopBlock stringIndex == right		ifTrue: [self selectAt: string size + 1]		ifFalse: [self selectAt: right].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!cursorHome: characterStream "Private - Move cursor from position in current line to beginning ofcurrent line. If cursor already at beginning of line, put cursor atbeginning of text"	| string left |	sensor keyboard.	string _ paragraph text string.	left _ startBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	startBlock stringIndex == left		ifTrue: [self selectAt: 1]		ifFalse: [self selectAt: left].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!cursorLeft: characterStream "Private - Move cursor left one character if nothing selected, otherwisemove cursor to beginning of selection. If the shift key is down, startselecting or extending current selection. Don't allow cursor pastbeginning of text"	| shift |	shift := sensor leftShiftDown.	sensor keyboard.	shift		ifTrue: 			[			startBlock stringIndex > 1				ifTrue: [self selectFrom: startBlock stringIndex - 1 to: stopBlockstringIndex - 1]			]		ifFalse: 			[			(startBlock stringIndex == stopBlock stringIndex and: [startBlockstringIndex > 1])				ifTrue: [self selectFrom: startBlock stringIndex - 1 to: startBlockstringIndex - 2]				ifFalse: [self selectFrom: startBlock stringIndex to: startBlockstringIndex - 1]			].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!cursorRight: characterStream "Private - Move cursor right one character if nothing selected,otherwise move cursor to end of selection. If the shift key is down,start selecting characters or extending already selected characters.Don't allow cursor past end of text"	| shift |	shift := sensor leftShiftDown.	sensor keyboard.	shift		ifTrue: [self selectFrom: startBlock stringIndex to: stopBlockstringIndex]		ifFalse: 			[			startBlock stringIndex == stopBlock stringIndex				ifTrue: [self selectFrom: stopBlock stringIndex + 1 to: stopBlockstringIndex]				ifFalse: [self selectFrom: stopBlock stringIndex to: stopBlockstringIndex - 1]			].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!cursorUp: characterStream "Private - Move cursor from position in current line to same position inprior line. If prior line too short, put at end"	| shift string left position start |	shift := sensor leftShiftDown.	sensor keyboard.	string _ paragraph text string.	left _ startBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	position _ startBlock stringIndex - left.	start _ left.	left _ left - 1.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	left < 1 ifTrue: [left _ 1].	start = 1 ifTrue: [position _ 0].	shift		ifTrue: 			[			(start - left < position and: [start > 1])				ifTrue: [self selectFrom: start - 1 to: stopBlock stringIndex - 1]				ifFalse: [self selectFrom: left + position to: stopBlock stringIndex- 1]			]		ifFalse: 			[			(start - left < position and: [start > 1])				ifTrue: [self selectFrom: start - 1 to: start - 2]				ifFalse: [self selectFrom: left + position to: left + position - 1]			].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!displayIfFalse: characterStream 	"Replace the current text selection with the text 'ifFalse:'--initiated by 	ctrl-f."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifFalse:'.	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!displayIfTrue: characterStream 	"Replace the current text selection with the text 'ifTrue:'--initiated by 	ctrl-t."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifTrue:'.	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'tk 11/4/96'!forwardDelete: characterStream	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char."	| startIndex usel upara uinterval ind |	startIndex _ startBlock stringIndex.	startIndex > paragraph text size ifTrue:		[sensor keyboard.		^ false].	startIndex = stopBlock stringIndex ifFalse:		["there was a selection"		"Just like regular Backspace -- delete the selection"		^ self backspace: characterStream].	"Null selection - do the delete forward"	beginTypeInBlock == nil	"no previous typing.  openTypeIn"		ifTrue: [self openTypeIn. UndoSelection _ self nullText].	uinterval _ UndoInterval deepCopy.	"umes _ UndoMessage deepCopy.	Set already by openTypeIn"	"usel _ UndoSelection deepCopy."	upara _ UndoParagraph deepCopy.	sensor keyboard.	self selectFrom: startIndex to: startIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph _ upara.  UndoInterval _ uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isText) ifTrue: [			usel _ UndoSelection.			ind _ startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'sw 8/1/97 16:13'!setSearchString: characterStream	"Establish the current selection as the current search string."	| aString |	sensor keyboard.	self lineSelectAndEmptyCheck: [^ true].	aString _  self selection string.	aString size == 0		ifTrue:			[self flash]		ifFalse:			[self setSearch: aString].	^ true! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 11/7/97 14:00'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over (excluding	 typeahead, which never even appears); (3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit _ beginTypeInBlock == nil		ifTrue: [self openTypeIn. UndoSelection _ self nullText. stopBlock stringIndex]		ifFalse: [beginTypeInBlock stringIndex].	startBlock _ paragraph characterBlockForIndex: startIndex.	startIndex < saveLimit ifTrue:		[newBackovers _ beginTypeInBlock stringIndex - startIndex.		beginTypeInBlock _ startBlock copy.		UndoSelection replaceFrom: 1 to: 0 with:			(paragraph text copyFrom: startIndex to: saveLimit - 1).		UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers].	self zapSelectionWith: self nullText.	startBlock _ stopBlock copy! !!ParagraphEditor methodsFor: 'typing support' stamp: 'sw 1/15/98 12:57'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	char = Character enter		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].	"enter, backspace, and escape keys (ascii 3, 8, and 27) are command keys"	(sensor commandKeyPressed or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue:				[self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse:				[self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	sensor controlKeyPressed ifTrue:		[^ self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	^ self perform: #normalCharacter: with: typeAheadStream! !!ParagraphEditor methodsFor: 'typing support' stamp: 'sw 1/15/98 12:58'!dispatchOnEnterWith: typeAheadStream	"Enter key hit.  Treat is as an 'accept', viz a synonym for cmd-s.  If cmd key is down, treat is as a synonym for print-it. "	sensor keyboard.  "consume enter key"	sensor commandKeyPressed		ifTrue:			[self printIt.]		ifFalse: 			[self closeTypeIn: typeAheadStream.			self accept].	^ true! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 11/10/97 14:10'!setEmphasisHere	emphasisHere _ (paragraph text attributesAt: (startBlock stringIndex-1 max: 1))					select: [:att | att mayBeExtended]! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'sw 6/18/96'!initialize	"Initialize the keyboard shortcut maps and the shared buffers	for copying text across views and managing again and undo.	: call initializeTextEditorMenus	other times: marked change to trigger reinit" 	"ParagraphEditor initialize"	CurrentSelection _ UndoSelection _ FindText _ ChangeText _ Text new.	UndoMessage _ Message selector: #halt.	self initializeCmdKeyShortcuts.	self initializeShiftCmdKeyShortcuts.	self initializeTextEditorMenus! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'di 10/29/97 20:22'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"ParagraphEditor initialize"	| cmdMap cmds |	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #backspace:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"cmd-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	'0123456789-=' do: [ :char | cmdMap at: (char asciiValue + 1) put: #changeEmphasis: ].	'([{''"<'         do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose: ].	cmdMap at: ($, asciiValue + 1) put: #shiftEnclose:.	cmds _ #(		$a	selectAll:		$b	browseIt:		$c	copySelection:		$d	doIt:		$e	exchange:		$f	find:		$g	findAgain:		$h	setSearchString:		$i	inspectIt:		$j	doAgainOnce:		$k  offerFontMenu:		$l	cancel:		$m	implementorsOfIt:		$n	sendersOfIt:		$o	spawnIt:		$p	printIt:		$q	querySymbol:		$r	recognizer:		$s	save:		$t	tempCommand:		$u	align:		$v	paste:		$w	backWord:		$x	cut:		$y	swapChars:		$z	undo:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).	].	CmdActions _ cmdMap.! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'di 10/29/97 20:27'!initializeShiftCmdKeyShortcuts	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	cmdMap at: (27 + 1) put: #shiftEnclose:.	"ctrl-["	cmds _ #(		$a	argAdvance:		$b	browseItHere:		$c	compareToClipboard:		$d	duplicate:		$e	methodStringsContainingIt:		$f	displayIfFalse:		$j	doAgainMany:		$k	changeStyle:		$n	referencesToIt:		$r	indent:		$l	outdent:		$s	search:		$t	displayIfTrue:		$w	methodNamesContainingIt:		$v	pasteInitials:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1)			put: (cmds at: i + 1).		cmdMap at: (((cmds at: i) asciiValue - 96) + 1)	put: (cmds at: i + 1).	].	ShiftCmdActions _ cmdMap.! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables'!specialShiftCmdKeys"Private - return array of key codes that represent single keys actingas if shift-command were also being pressed"^#(	1	"home"	3	"enter"	4	"end"	8	"backspace"	27	"escape"	28	"left arrow"	29	"right arrow"	30	"up arrow"	31	"down arrow"	127	"delete"	)! !!ParseNode methodsFor: 'testing'!isUndefTemp	^ false! !!ParseNode methodsFor: 'testing'!isUnusedTemp	^ false! !!ParseNode methodsFor: 'testing'!nowHasDef  "Ignored in all but VariableNode"! !!ParseNode methodsFor: 'testing'!nowHasRef  "Ignored in all but VariableNode"! !!ParseNode methodsFor: 'printing'!printCommentOn: aStream indent: indent 	| thisComment |	comment == nil ifTrue: [^self].	"Show comments in green"	aStream withAttribute: (TextColor color: Color blue) do: 	[1 to: comment size do: 		[:index | 		index > 1 ifTrue: [aStream crtab: indent].		aStream nextPut: $".		thisComment _ comment at: index.		self printSingleComment: thisComment			on: aStream			indent: indent.		aStream nextPut: $"]].	comment _ nil! !!ParseNode methodsFor: 'private'!printSingleComment: aString on: aStream indent: indent 	"Print the comment string, assuming it has been indented indent tabs.   	Break the string at word breaks, given the widths in the default font, at 	450 points."	| readStream word position lineBreak font wordWidth tabWidth spaceWidth |	readStream _ ReadStream on: aString.	font _ TextStyle default defaultFont.	tabWidth _ TextConstants at: #DefaultTab.	spaceWidth _ font widthOf: Character space.	position _ indent * tabWidth.	lineBreak _ 450.	[readStream atEnd]		whileFalse: 			[word _ self nextWordFrom: readStream setCharacter: [:lastChar | lastChar].			wordWidth _ 0.			word do: [:char | wordWidth _ wordWidth + (font widthOf: char)].			position _ position + wordWidth.			position > lineBreak				ifTrue: 					[aStream crtab: indent.					position _ indent * tabWidth + wordWidth + spaceWidth.					lastChar = Character cr						ifTrue: [[readStream peekFor: Character tab] whileTrue].					aStream nextPutAll: word; space]				ifFalse: 					[aStream nextPutAll: word.					readStream atEnd						ifFalse: 							[position _ position + spaceWidth.							aStream space].					lastChar = Character cr						ifTrue: 							[aStream crtab: indent.							position _ indent * tabWidth.							[readStream peekFor: Character tab] whileTrue]]]! !!ParseNode class methodsFor: 'class initialization'!initialize	"ParseNode initialize. VariableNode initialize"	LdInstType _ 1.	LdTempType _ 2.	LdLitType _ 3.	LdLitIndType _ 4.	SendType _ 5.	CodeBases _ #(0 16 32 64 208 ).	CodeLimits _ #(16 16 32 32 16 ).	LdSelf _ 112.	LdTrue _ 113.	LdFalse _ 114.	LdNil _ 115.	LdMinus1 _ 116.	LoadLong _ 128.	Store _ 129.	StorePop _ 130.	ShortStoP _ 96.	SendLong _ 131.	DblExtDoAll _ 132.	SendLong2 _ 134.	LdSuper _ 133.	Pop _ 135.	Dup _ 136.	LdThisContext _ 137.	EndMethod _ 124.	EndRemote _ 125.	Jmp _ 144.	Bfp _ 152.	JmpLimit _ 8.	JmpLong _ 164.  "code for jmp 0"	BtpLong _ 168.	SendPlus _ 176.	Send _ 208.	SendLimit _ 16! !!Parser methodsFor: 'expression types'!assignment: varNode	" var '_' expression => AssignmentNode."	| loc |	(loc _ varNode assignmentCheck: encoder at: prevMark + requestorOffset) >= 0		ifTrue: [^self notify: 'Cannot store into' at: loc].	varNode nowHasDef.	self advance.	self expression ifFalse: [^self expected: 'Expression'].	parseNode _ AssignmentNode new				variable: varNode				value: parseNode				from: encoder.	^true! !!Parser methodsFor: 'expression types'!blockExpression	" [ {:var} ( | statements) ] => BlockNode."	| argNodes |	argNodes _ OrderedCollection new.	[self match: #colon	"gather any arguments"]		whileTrue: 			[argNodes addLast: (encoder autoBind: self argumentName)].	(argNodes size > 0 & (hereType ~~ #rightBracket) and: [(self match: #verticalBar) not])		ifTrue: [^self expected: 'Vertical bar'].	self statements: argNodes innerBlock: true.	(self match: #rightBracket)		ifFalse: [^self expected: 'Period or right bracket'].	argNodes do: [:arg | arg scope: -1] "Scope no longer active"! !!Parser methodsFor: 'expression types'!method: doit context: ctxt 	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	sap _ self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	(sap at: 2) do: [:argNode | argNode isArg: true].	temps _ self temporaries.	messageComment _ currentComment.	currentComment _ nil.	prim _ doit ifTrue: [0] ifFalse: [self primitive].	self statements: #() innerBlock: doit.	blk _ parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode _ MethodNode new comment: messageComment.	^methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim! !!Parser methodsFor: 'expression types'!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} => 	{selector, arguments, precedence}."	| args selector |	fromDoit 		ifTrue: 			[ctxt == nil				ifTrue: [^Array with: #DoIt with: #() with: 1]				ifFalse: [^Array 							with: #DoItIn: 							with: (Array 									with: (encoder encodeVariable: 'homeContext')) 									with: 3]].	hereType == #word 		ifTrue: [^Array with: self advance asSymbol with: #() with: 1].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector _ self advance asSymbol.			args _ Array with: (encoder bindArg: self argumentName).			^Array with: selector with: args with: 2].	hereType == #keyword		ifTrue: 			[selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[selector nextPutAll: self advance.					args addLast: (encoder bindArg: self argumentName)].			^Array with: selector contents asSymbol with: args with: 3].	^self expected: 'Message pattern'! !!Parser methodsFor: 'expression types'!primaryExpression 	hereType == #word 		ifTrue: 			[parseNode _ self variable.			(parseNode isUndefTemp and: [self interactive])				ifTrue: [self queryUndefined].			parseNode nowHasRef.			^ true].	hereType == #leftBracket		ifTrue: 			[self advance.			self blockExpression.			^true].	hereType == #leftBrace		ifTrue: 			[self braceExpression.			^true].	hereType == #leftParenthesis		ifTrue: 			[self advance.			self expression ifFalse: [^self expected: 'expression'].			(self match: #rightParenthesis)				ifFalse: [^self expected: 'right parenthesis'].			^true].	(hereType == #string or: [hereType == #number or: [hereType == #literal]])		ifTrue: 			[parseNode _ encoder encodeLiteral: self advance.			^true].	(here == #- and: [tokenType == #number])		ifTrue: 			[self advance.			parseNode _ encoder encodeLiteral: self advance negated.			^true].	^false! !!Parser methodsFor: 'temps'!bindArg: name	^ self bindTemp: name! !!Parser methodsFor: 'error correction'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction fullSearch: tryHard 	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice correctSelector userSelection lines firstLine |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ tryHard		ifFalse: [ Symbol possibleSelectorsFor: proposedKeyword ]		ifTrue: [ Symbol morePossibleSelectorsFor: proposedKeyword ].	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.	firstLine _ 1. 	alternatives do:		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).	tryHard ifFalse:		[aStream cr; nextPutAll: 'try harder'.		lines _ lines copyWith: (alternatives size + firstLine + 1)].		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	tryHard not & (choice > lines last) ifTrue:		[^ self correctSelector: proposedKeyword wordIntervals: spots				exprInterval: expInt ifAbort: abortAction fullSearch: true ]. 	(choice = 0) | (choice > (lines at: 2))		ifTrue: [ ^ abortAction value ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].	correctSelector _ alternatives at: choice - 1.	self substituteSelector: correctSelector keywords wordIntervals: spots.	^ correctSelector.! !!Parser methodsFor: 'error correction'!queryUndefined	| varStart varName | 	varName _ parseNode key.	varStart _ self endOfLastToken + requestorOffset - varName size + 1.	requestor selectFrom: varStart to: varStart + varName size - 1; select.	((PopUpMenu labels:'yesno') startUpWithCaption:		((varName , ' appears to beundefined at this point.Proceed anyway?') asText makeBoldFrom: 1 to: varName size))		= 1 ifFalse: [^ self fail]! !!Parser methodsFor: 'error correction'!removeUnusedTemps 	| str end start | 	str _ requestor text string.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp |		((PopUpMenu labels: 'yes\no' withCRs) startUpWithCaption:			((temp , ' appears to beunused in this method.OK to remove it?') asText makeBoldFrom: 1 to: temp size))			= 1		ifTrue:		[(encoder encodeVariable: temp) isUndefTemp			ifTrue:			[end _ tempsMark.			["Beginning at right temp marker..."			start _ end - temp size + 1.			end < temp size or: [temp = (str copyFrom: start to: end)								and: [(str at: start-1) isSeparator]]]			whileFalse:				["Search left for the unused temp"				end _ requestor nextTokenFrom: end direction: -1].			end < temp size ifFalse:				[(str at: start-1) = $  ifTrue: [start _ start-1].				requestor correctFrom: start to: end with: ''.				str _ str copyReplaceFrom: start to: end with: ''. 				tempsMark _ tempsMark - (end-start+1)]]			ifFalse:			[PopUpMenu notify:'You''ll first have to remove thestatement where it''s stored into']]]! !!PartsBinMorph methodsFor: 'extraction support' stamp: 'sw 8/12/97 14:16'!isPartsBin	^ true! !!PartsBinMorph methodsFor: 'extraction support' stamp: 'sw 10/18/97 18:03'!repelsMorph: aMorph event: ev	self flag: #deferred.  "This isn't really right"	^ true! !!PartsBinMorph methodsFor: 'extraction support' stamp: 'sw 10/18/97 18:19'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. Otherwise, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner = self ifTrue:			[^ openToDragNDrop				ifTrue: [root]				ifFalse: [root fullCopy removeProperty: #partsDonor]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PartsBinMorph methodsFor: 'extraction support' stamp: 'sw 8/5/97 21:16'!shiftedForGrab: aMorph	"Support for e-toys; grab the given morph by its bottom-left corner."	aMorph position: self primaryHand position - (0 @ aMorph fullBounds height).	^ aMorph! !!Password methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 21:08'!decode: string	"Xor with secret number -- just so file won't have raw password in it"	| kk rand |	rand _ Random new seed: 234237.	kk _ (ByteArray new: string size) collect: [:bb | (rand next * 255) asInteger].	1 to: kk size do: [:ii |		kk at: ii put: ((kk at: ii) bitXor: (string at: ii) asciiValue)].	^ kk asString! !!Password methodsFor: 'as yet unclassified' stamp: 'tk 1/6/98 13:09'!serverPasswords	"Get the server passwords off the disk.  Decode them.  File 'sqk.info' must be in the same folder with the version of the Squeak application (VM) that is running this image now."	| raw dir |	dir _ (SourceFiles at: 1) directory.	(dir fileExists: 'sqk.info') ifFalse: [^ nil].	"Caller will ask user for password"	raw _ (dir oldFileNamed: 'sqk.info') contentsOfEntireFile.		"If you don't have this file, and you really do want to release 		an update, contact Ted Kaehler."	^ (self decode: raw) findTokens: '\' withCRs.! !!Password methodsFor: 'accessing' stamp: 'tk 1/3/98 21:36'!cache: anObject	cache _ anObject! !!Password methodsFor: 'accessing' stamp: 'tk 1/7/98 10:28'!passwordFor: serverDir	"Returned the password from one of many sources.  OK if send in a nil arg."	| sp msg |	cache ifNotNil: [^ cache].	sequence ifNotNil: [		(sp _ self serverPasswords) ifNotNil: [			sequence <= sp size ifTrue: [^ sp at: sequence]]].	msg _ (serverDir isKindOf: ServerDirectory)		ifTrue: [serverDir moniker]		ifFalse: ['this directory'].	^ cache _ FillInTheBlank request: 'Password for ', msg, ':'.		"Diff between empty string and abort?"! !!Password methodsFor: 'accessing' stamp: 'tk 1/5/98 21:14'!sequence: anNumber	sequence _ anNumber! !!Password class methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 21:26'!shutDown	"Forget all cached passwords, so they won't stay in the image"	self withAllSubclasses do: [:cls |		cls allInstancesDo: [:each | each cache: nil]].! !!Pen methodsFor: 'initialize-release'!defaultNib: widthInteger 	"Nib is the tip of a pen. This sets up the pen, with a nib of width	widthInteger. Alternatively, try		roundNib: widthInteger, or		sourceForm: aForm	to set the shape of the tip. For example, try:		| bic | bic _ Pen new sourceForm: Cursor normal.		bic combinationRule: Form paint; turn: 90.		10 timesRepeat: [bic down; go: 10; up; go: 20]."	self color: Color black.	self squareNib: widthInteger! !!Pen methodsFor: 'coloring'!black	"Set the receiver's mask to black."	self fillColor: Color black.! !!Pen methodsFor: 'coloring' stamp: 'tk 6/18/96'!color: colorSpec	"Set the pen to the Nth color (wraps), or to an explicit color.  "	colorSpec isInteger		ifTrue: [destForm depth=1 ifTrue: [^ self fillColor: Color black].				"spread colors out in randomish fashion"				self fillColor: (Colors atWrap: colorSpec*9)]		ifFalse: [self fillColor: colorSpec].	"arg must be a color already"! !!Pen methodsFor: 'coloring'!white 	"Set the receiver's mask to white."	self fillColor: Color white.! !!Pen methodsFor: 'moving' stamp: 'tk 2/17/97'!goDelta: aPoint 	"Move the receiver by the relative amount in aPoint. If the pen is down, a line will be 	drawn from the current position to the new one using the receiver's 	form source as the shape of the drawing brush. The receiver's set 	direction does not change.  "	| old |	old _ location.	location _ location + aPoint.	penDown ifTrue: [self drawFrom: old to: location]! !!Pen methodsFor: 'moving' stamp: 'di 11/4/97 20:11'!goto: aPoint 	"Move the receiver to position aPoint. If the pen is down, a line will be 	drawn from the current position to the new one using the receiver's 	form source as the shape of the drawing brush. The receiver's set 	direction does not change."	| old |	old _ location.	location _ aPoint.	penDown ifTrue: [self drawFrom: old rounded								to: location rounded]	"NOTE:  This should be changed so it does NOT draw the first point, so as	not to overstrike at line junctions.  At the same time, place should draw	a single dot if the pen is down, as should down (put-pen-down) if it	was not down before."! !!Pen methodsFor: 'geometric designs'!mandala: npoints	"Display restoreAfter: [Pen new mandala: 30]"	"On a circle of diameter d, place npoints number of points. Draw all 	possible connecting lines between the circumferential points."	| l points d |	Display fillWhite.	d _ Display height-50.	l _ 3.14 * d / npoints.	self home; up; turn: -90; go: d // 2; turn: 90; go: 0 - l / 2; down.	points _ Array new: npoints.	1 to: npoints do: 		[:i | 		points at: i put: location rounded.		self go: l; turn: 360.0 / npoints].	npoints // 2		to: 1		by: -1		do: 			[:i | 			self color: i.			1 to: npoints do: 				[:j | 				self place: (points at: j).				self goto: (points at: j + i - 1 \\ npoints + 1)]]! !!Pen methodsFor: 'geometric designs' stamp: 'jm 8/1/97 11:42'!web   "Display restoreAfter: [Pen new web]"	"Draw pretty web-like patterns from the mouse movement on the screen.	Press the mouse button to draw, option-click to exit.	By Dan Ingalls and Mark Lentczner. "	| history newPoint ancientPoint lastPoint filter color |	"self erase."	color _ 1.	[ true ] whileTrue:		[ history _ OrderedCollection new.		Sensor waitButton.		Sensor yellowButtonPressed ifTrue: [^ self].		filter _ lastPoint _ Sensor mousePoint.		20 timesRepeat: [ history addLast: lastPoint ].		self color: (color _ color + 1).		[ Sensor redButtonPressed ] whileTrue: 			[ newPoint _ Sensor mousePoint.			(newPoint = lastPoint) ifFalse:				[ ancientPoint _ history removeFirst.				filter _ filter * 4 + newPoint // 5.				self place: filter.				self goto: ancientPoint.				lastPoint _ newPoint.				history addLast: filter ] ] ]! !!PermanentRecordingControlsMorph methodsFor: 'all' stamp: 'sw 10/18/97 23:28'!addButtonRows	"Spun off to allow subclasses to customize the buttons but still benefit from super intialize"	| r |	r _ LayoutMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Tile' action: #makeTile).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Trim' action: #trim).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Show' action: #show).	self addMorphBack: r.	r _ LayoutMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Record' action: #record).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Stop' action: #stop).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Play' action: #playback).	r addMorphBack: self makeStatusLight..	self addMorphBack: r! !!PermanentRecordingControlsMorph methodsFor: 'all' stamp: 'sw 11/5/97 13:53'!initialize	super initialize.	hResizing _ #shrinkWrap! !!PlayWithMe1 methodsFor: 'public access'!slider1Value: x	valuePrinter contents: x printString.	scrollBar1 value: x! !!PlayWithMe1 methodsFor: 'input events'!listPane1MenuButtonPressed: arg1	self confirm: 'Do you like menu buttons?'! !!PlayWithMe1 methodsFor: 'input events'!listPane1NewSelection: arg1	valuePrinter contents: arg1.	listPane2 selection: arg1! !!PlayWithMe1 methodsFor: 'input events'!listPane2MenuButtonPressed: arg1	self confirm: 'Do you like menu buttons?'! !!PlayWithMe1 methodsFor: 'input events'!listPane2NewSelection: arg1	valuePrinter contents: arg1.	listPane1 selection: arg1! !!PlayWithMe1 methodsFor: 'input events'!scrollBar1MenuButtonPressed: arg1	self confirm: 'Do you like menu buttons?'! !!PlayWithMe1 methodsFor: 'input events'!scrollBar1Value: arg1	valuePrinter contents: arg1 printString.	slider1 value: arg1! !!PlayWithMe1 class methodsFor: 'all' stamp: 'di 6/22/97 09:14'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!PlayWithMe3 methodsFor: 'public access' stamp: '6/6/97 16:12 di'!codeBrowser1	^codeBrowser1! !!PlayWithMe3 methodsFor: 'public access'!slantedList1	^slantedList1! !!PlayWithMe3 class methodsFor: 'all' stamp: 'di 6/22/97 09:14'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!Pluck methodsFor: 'as yet unclassified' stamp: 'jm 12/17/97 22:43'!initialize	super initialize.	sound _ PluckedSound pitch: 440.0 dur: 5.0 loudness: 0.5.! !The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string. Fractional indexing is used to allow precise tuning; without this, the pitch would be rounded to the pitch corresponding to the nearest buffer size.!!PluckedSound methodsFor: 'initialization' stamp: 'jm 1/5/98 17:26'!setPitch: p dur: d loudness: vol	| sz |	initialCount _ (d * self samplingRate asFloat) asInteger.	ring _ SoundBuffer newMonoSampleCount:		(((2.0 * self samplingRate) / p) asInteger max: 2).	sz _ ring monoSampleCount.	scaledIndexLimit _ (sz + 1) * ScaleFactor.	scaledIndexIncr _ (p * sz * ScaleFactor) // (2.0 * self samplingRate).	self setLoudness: vol.	self initialVolume: vol.	self reset.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 1/5/98 18:29'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string."	"(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play"	| lastIndex scaledThisIndex scaledNextIndex average sample i s |	<primitive: 181>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #ring declareC: 'short int *ring'.	lastIndex _ (startIndex + n) - 1.	scaledThisIndex _ scaledIndex.	startIndex to: lastIndex do: [:sliceIndex |		scaledNextIndex _ scaledThisIndex + scaledIndexIncr.		scaledNextIndex >= scaledIndexLimit			ifTrue: [scaledNextIndex _ ScaleFactor + (scaledNextIndex - scaledIndexLimit)].		average _			((ring at: scaledThisIndex // ScaleFactor) +			 (ring at: scaledNextIndex // ScaleFactor)) // 2.		ring at: scaledThisIndex // ScaleFactor put: average.		sample _ (average * scaledVol) // ScaleFactor.  "scale by volume"		scaledThisIndex _ scaledNextIndex.		leftVol > 0 ifTrue: [			i _ (2 * sliceIndex) - 1.			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i _ 2 * sliceIndex.			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0]]].	scaledIndex _ scaledNextIndex.	count _ count - n.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 12/17/97 21:35'!reset	"Fill the ring with random noise."	| seed n |	super reset.	seed _ 17.	n _ ring monoSampleCount.	1 to: n do: [:i |		seed _ ((seed * 1309) + 13849) bitAnd: 65535.		ring at: i put: seed - 32768].	count _ initialCount.	scaledIndex _ ScaleFactor.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 11/26/97 10:51'!samplesRemaining	^ count! !!PluckedSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:13'!copy	^ super copy copyRing! !!PluckedSound methodsFor: 'copying' stamp: 'jm 11/4/97 08:25'!copyRing	"Private!! Support for copying"	ring _ ring copy.! !!PluckedSound class methodsFor: 'instruments' stamp: 'jm 1/5/98 17:25'!default	"PluckedSound default play"	"(AbstractSound majorScaleOn: PluckedSound default) play"	| snd p env |	snd _ PluckedSound pitch: 220 dur: 1 loudness: 0.8.	p _ OrderedCollection new.	p add: 0@1.0; add: 10@1.0; add: 20@0.0.	env _ VolumeEnvelope points: p loopStart: 2 loopEnd: 2.	env target: snd; scale: 1.0.	snd addEnvelope: env.	snd duration: 1.0.	^ snd! !!PluggableListController methodsFor: 'all'!changeModelSelection: anInteger	"Let the view handle this."	view changeModelSelection: anInteger.! !!PluggableListController methodsFor: 'all'!controlActivity	"Overridden to handle keystrokes."	sensor keyboardPressed ifTrue: [view handleKeystroke: sensor keyboard].	super controlActivity.! !!PluggableListController methodsFor: 'all'!yellowButtonActivity	"Invoke the model's menu."	| menu |	menu _ view getMenu.	menu == nil ifFalse: [menu invokeOn: model].! !!PluggableListView methodsFor: 'initialization'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'itemsList' holds the original list.	 The instance variable 'items' is a paragraph constructed from	 this list."	| s |	items _ arrayOfStrings.	isEmpty _ arrayOfStrings isEmpty.	s _ WriteStream on: Array new.	"add top and bottom delimiters"	s nextPut: topDelimiter.	arrayOfStrings do: [:item |		item == nil ifFalse: [s nextPut: item].	].	s nextPut: bottomDelimiter.	list _ ListParagraph withArray: s contents.	selection _ self getCurrentSelectionIndex.	self positionList.! !!PluggableListView methodsFor: 'initialization'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self model: anObject.	getListSelector _ getListSel.	getSelectionSelector _ getSelectionSel.	setSelectionSelector _ setSelectionSel.	getMenuSelector _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	self borderWidth: 1.	self list: self getList.! !!PluggableListView methodsFor: 'model access'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setSelectionSelector ~~ nil ifTrue: [		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [items at: anInteger]).		model perform: setSelectionSelector with: item.		getSelectionSelector == nil ifFalse: [model perform: getSelectionSelector].	].! !!PluggableListView methodsFor: 'model access'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getSelectionSelector == nil ifTrue: [^ 0].	item _ model perform: getSelectionSelector.	^ items findFirst: [ :x | x = item]! !!PluggableListView methodsFor: 'model access'!getList 	"Answer the list to be displayed."	| lst |	getListSelector == nil ifTrue: [^ #()].	lst _ model perform: getListSelector.	lst == nil ifTrue: [^ #()].	^ lst! !!PluggableListView methodsFor: 'model access'!getMenu	"Answer the menu for this list view."	getMenuSelector == nil ifTrue: [^ nil].	^ model perform: getMenuSelector! !!PluggableListView methodsFor: 'model access'!handleKeystroke: aCharacter	"Answer the menu for this list view."	keystrokeActionSelector == nil ifTrue: [^ nil].	model perform: keystrokeActionSelector with: aCharacter.! !!PluggableListView methodsFor: 'controller access'!defaultControllerClass 	^ PluggableListController! !!PluggableListView methodsFor: 'updating'!update: aSymbol 	"Refer to the comment in View|update:."	| oldIndex newIndex |	aSymbol == getListSelector ifTrue: [		oldIndex _ self getCurrentSelectionIndex.		self list: self getList.		newIndex _ self getCurrentSelectionIndex.		(oldIndex > 0 and: [newIndex = 0]) ifTrue: [			"new list did not include the old selection; deselecting"			self changeModelSelection: newIndex].		self displayView.		self displaySelectionBox.		^self].	aSymbol == getSelectionSelector ifTrue: [		self moveSelectionBox: self getCurrentSelectionIndex.		^self].! !!PluggableListView class methodsFor: 'as yet unclassified'!aboutPluggability	"A pluggable list view gets its content from the model. This allows the same kind of view can be used in different situations, thus avoiding a proliferation of gratuitous view and controller classes. Selector usage is:		getListSel		fetch the list of items (strings) to be displayed		getSelectionSel	get the currently selected item		setSelectionSel	set the currently selected item (takes an argument)		getMenuSel		get the pane-specific (or 'yellow-button') menu		keyActionSel	process keystrokes typed to this view (takes an argument)	Any of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default, do-nothing behavior should be used. However, if getListSel is nil, the default behavior just provides an empty list, which makes for a rather dull list view!! (Such behavior can actually be useful during debugging.)	The model informs a pluggable view of changes by sending #changed: to itself with getListSel or getSelectionSel as a parameter. The view informs the model of selection changes by sending setSelectionSel to it with the newly selected item as a parameter, and invokes menu and keyboard actions on the model via getMenuSel and keyActionSel.	Pluggability allows a single model object to have pluggable list views on multiple aspects of itself. For example, an object representing one personal music library might be organized as a three-level hierarchy: the types of music, the titles within a given type, and the songs on a given title. Pluggability allows one to easily build a multipane browser for this object with separate list views for the music type, title, and song."! !!PluggableListView class methodsFor: 'as yet unclassified'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: nil		keystroke: nil! !!PluggableListView class methodsFor: 'as yet unclassified'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: nil! !!PluggableListView class methodsFor: 'as yet unclassified'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: keyActionSel! !A PluggableServerAction instance has two blocks in instance variables. The processBlock is executed with the web request to do any input processing that is needed. The returnBlock is executed with the web request, and its return value is sent as the output of the CGI processing.!!PluggableServerAction methodsFor: 'accessing' stamp: 'mjg 11/10/97 08:58'!processBlock: aBlock	processBlock := aBlock.! !!PluggableServerAction methodsFor: 'accessing' stamp: 'mjg 11/10/97 08:59'!returnBlock: aBlock	returnBlock := aBlock.! !!PluggableServerAction methodsFor: 'URL processing' stamp: 'mjg 11/6/97 17:09'!process: request	processBlock value: request.	request reply: PWS success; reply: PWS contentHTML.	request reply: (returnBlock value: request).! !!PluggableTest methodsFor: 'initialization'!initialize	list1 _ #('reggae' 'early' 'classical').	list2 _ #('marley' 'alpha blondy' 'burning spear' 'ziggy').! !!PluggableTest methodsFor: 'artist pane'!artist	^ selection2! !!PluggableTest methodsFor: 'artist pane'!artist: aString	selection2 _ aString.	self changed: #artist.! !!PluggableTest methodsFor: 'artist pane'!artistKeystroke: aCharacter	list2 do: [ :artist |		(artist first asLowercase = aCharacter asLowercase) ifTrue: [			self artist: artist]].! !!PluggableTest methodsFor: 'artist pane'!artists	selection1 = 'reggae' ifTrue: [^ list2].	selection1 = 'early' ifFalse: [^ #('ziggy' 'marley')].	^ #()! !!PluggableTest methodsFor: 'music type pane'!musicType	^ selection1! !!PluggableTest methodsFor: 'music type pane'!musicType: aString	selection1 _ aString.	self changed: #musicType.	self changed: #artists.! !!PluggableTest methodsFor: 'music type pane'!musicTypeKeystroke: aCharacter	list1 do: [ :type |		(type first asLowercase = aCharacter asLowercase) ifTrue: [			self musicType: type]].! !!PluggableTest methodsFor: 'music type pane'!musicTypeMenu	^ SelectionMenu		labels: 'reggae\grunge\flash' withCRs		lines: #(2)		selections: #(reggaeCmd grungeCmd flashCmd)! !!PluggableTest methodsFor: 'music type pane'!musicTypes	^ list1! !!PluggableTest methodsFor: 'menu commands'!flashCmd	Display reverse; reverse.! !!PluggableTest methodsFor: 'menu commands'!grungeCmd	SelectionMenu confirm:		'You mean, like those strange bands from Seattle?'! !!PluggableTest methodsFor: 'menu commands'!reggaeCmd	self musicType: 'reggae'.! !!PluggableTest class methodsFor: 'as yet unclassified'!open	"PluggableTest open"	| model listView1 topView listView2 |	model _ self new initialize.	listView1 _		PluggableListView on: model			list: #musicTypes			selected: #musicType			changeSelected: #musicType:			menu: #musicTypeMenu			keystroke: #musicTypeKeystroke:.	listView2 _		PluggableListView on: model			list: #artists			selected: #artist			changeSelected: #artist:			menu: nil			keystroke: #artistKeystroke:.	topView _ StandardSystemView new		label: 'Pluggable Test';		minimumSize: 300@200;		borderWidth: 1;		addSubView: listView1;		addSubView: listView2 toRightOf: listView1.	topView controller open.! !!Point methodsFor: 'arithmetic'!\\ scale 	"Answer a Point that is the mod of the receiver and scale (which is a  Point or Number)."	| scalePoint |	scalePoint _ scale asPoint.	^ x \\ scalePoint x @ (y \\ scalePoint y)! !!Point methodsFor: 'polar coordinates' stamp: 'di 6/12/97 12:18'!degrees	"Answer the angle the receiver makes with origin in degrees. right is 0; down is 90."	| tan theta |	x = 0		ifTrue: [y >= 0				ifTrue: [^ 90.0]				ifFalse: [^ 270.0]]		ifFalse: 			[tan _ y asFloat / x asFloat.			theta _ tan arcTan.			x >= 0				ifTrue: [y >= 0						ifTrue: [^ theta radiansToDegrees]						ifFalse: [^ 360.0 + theta radiansToDegrees]]				ifFalse: [^ 180.0 + theta radiansToDegrees]]! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:11'!dotProduct: aPoint 	"Answer a number that is the dot product of the receiver and the 	argument, aPoint. That is, the two points are multipled and the 	coordinates of the result summed."	| temp |	temp _ self * aPoint.	^temp x abs + temp y abs! !!Point methodsFor: 'point functions' stamp: 'di 6/11/97 16:08'!flipBy: direction centerAt: c	"Answer a Point which is flipped according to the direction about the point c.	Direction must be #vertical or #horizontal."	direction == #vertical ifTrue: [^ x @ (c y * 2 - y)].	direction == #horizontal ifTrue: [^ (c x * 2 - x) @ y].	self error: 'unrecognizable direction'! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:37'!nearestPointAlongLineFrom: p1 to: p2	"Note this will give points beyond the endpoints.	Streamlined by Gerardo Richarte 11/3/97"	| x21 y21 t x1 y1 |	p1 x = p2 x ifTrue: [^ p1 x @ y].	p1 y = p2 y ifTrue: [^ x @ p1 y].	x1 _ p1 x asFloat.	y1 _ p1 y asFloat.	x21 _ p2 x asFloat - x1.	y21 _ p2 y asFloat - y1.	t _ ((y asFloat - y1 / x21) + (x asFloat - x1 / y21))			/ ((x21 / y21) + (y21 / x21)).	^ (x1 + (t * x21)) @ (y1 + (t * y21))"	| old new |	Pen new place: 200@100; goto: (old _ 500@300).	Display reverse: (old extent: 10@10).	[Sensor anyButtonPressed] whileFalse:		[(new _ (Sensor cursorPoint nearestPointAlongLineFrom: 200@100 to: 500@300) )			= old ifFalse:				[Display reverse: (old extent: 10@10).				Display reverse: ((old _ new) extent: 10@10)]]"! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:40'!nearestPointOnLineFrom: p1 to: p2	"This will not give points beyond the endpoints"	^ (self nearestPointAlongLineFrom: p1 to: p2)		adhereTo: (p1 rect: p2)! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:12'!onLineFrom: p1 to: p2	^ self onLineFrom: p1 to: p2 within: 2! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:07'!onLineFrom: p1 to: p2 within: epsilon	"Answer true if the receiver is on the line between p1 and p2within a small epsilon plus half the line width."	"test if receiver is within the bounding box"	(((p1 rect: p2) expandBy: epsilon) containsPoint: self) ifFalse: [^ false].	"it's in the box;  is it on the line?"	^ (self dist: (self nearestPointAlongLineFrom: p1 to: p2)) <= epsilon! !!Point methodsFor: 'point functions' stamp: '6/9/97 14:51 di'!quadrantOf: otherPoint	"Return 1..4 indicating relative direction to otherPoint.	1 is downRight, 2=downLeft, 3=upLeft, 4=upRight"	^ x <= otherPoint x		ifTrue: [y < otherPoint y ifTrue: [1] ifFalse: [4]]		ifFalse: [y <= otherPoint y ifTrue: [2] ifFalse: [3]]"[Sensor anyButtonPressed] whileFalse:	[(Display boundingBox center quadrantOf: Sensor cursorPoint) printString displayAt: 0@0]"! !!Point methodsFor: 'point functions' stamp: 'di 6/11/97 15:12'!rotateBy: direction centerAt: c	"Answer a Point which is rotated according to direction, about the point c.	Direction must be one of #right (CW), #left (CCW) or #pi (180 degrees)."	| offset |	offset _ self - c.	direction == #right ifTrue: [^ (offset y negated @ offset x) + c].	direction == #left ifTrue: [^ (offset y @ offset x negated) + c].	direction == #pi ifTrue: [^ c - offset].	self error: 'unrecognizable direction'! !!Point methodsFor: 'converting' stamp: 'di 11/1/97 19:07'!adaptFloat: floatScalar	^ floatScalar @ floatScalar! !!Point methodsFor: 'converting' stamp: 'di 11/1/97 19:10'!adaptInteger: scalar	^ scalar @ scalar! !!Point methodsFor: 'converting' stamp: 'di 11/1/97 19:08'!adaptToFloat	^ x asFloat @ y asFloat! !!Point methodsFor: 'converting' stamp: 'di 11/1/97 19:11'!adaptToInteger	^ x asInteger @ y asInteger! !!Point methodsFor: 'converting'!asFloatPoint	^ x asFloat @ y asFloat! !!Point methodsFor: 'converting' stamp: 'di 12/3/97 19:00'!rect: aPoint 	"Answer a Rectangle that encompasses the receiver and aPoint.	This is the most general infix way to create a rectangle."	^ Rectangle 		origin: (self min: aPoint)		corner: (self max: aPoint)! !!Point methodsFor: 'transforming'!adhereTo: aRectangle	"If the receiver lies outside aRectangle, return the nearest point on the boundary of the rectangle, otherwise return self."	(aRectangle containsPoint: self)	ifTrue: [^ self]	ifFalse: [^ (x min: (aRectangle corner x) max: (aRectangle origin x))			@ (y min: (aRectangle corner y) max: (aRectangle origin y))]! !!Point methodsFor: 'transforming'!rotateBy: angle about: center	"Even though Point.theta is measured CW, this rotates with the more conventional CCW interpretateion of angle."	| p r theta |	p _ self - center.	r _ p r.	theta _ angle asFloat - p theta.	^ (center x asFloat + (r * theta cos)) @	  (center y asFloat - (r * theta sin))! !!Point methodsFor: 'transforming' stamp: 'di 12/4/97 14:34'!scaleFrom: rect1 to: rect2	"Produce a point stretched according to the stretch from rect1 to rect2"	^ rect2 topLeft + (((x-rect1 left) * rect2 width // rect1 width)					@ ((y-rect1 top) * rect2 height // rect1 height))! !!Point methodsFor: 'private'!setR: rho degrees: theta	| radians |	radians _ theta asFloat degreesToRadians.	x _ (rho asFloat * radians cos) asInteger.	y _ (rho asFloat * radians sin) asInteger.! !!Point class methodsFor: 'instance creation' stamp: 'sw 9/20/97 15:34'!fromUser	Sensor waitNoButton.	Cursor crossHair show.	Sensor waitButton.	Cursor normal show.	^ Sensor cursorPoint"Point fromUser"! !!Point class methodsFor: 'instance creation'!r: rho degrees: theta	"Answer an instance of me with polar coordinates rho and theta."	^self new setR: rho degrees: theta! !PolygonMorph comment:'Polygons and curves use a 1-bit shape form to make display reasonably fast.  This could be further optimized by going to a 2-bit form and including the border.  It would also be simpleto compute an inner rectangle, as with ellipses. '!!PolygonMorph methodsFor: 'initialization' stamp: 'jm 8/2/97 14:21'!initialize	super initialize.	vertices _ Array with: 20@20 with: 40@30 with: 20@40.	color _ Color orange.	borderWidth _ 2.	borderColor _ Color magenta.	closed _ true.	quickFill _ true.	arrows _ #none.	self computeBounds.! !!PolygonMorph methodsFor: 'initialization' stamp: 'di 9/26/97 10:33'!installModelIn: aWorld	aWorld isWorldMorph ifTrue: [self addHandles]! !!PolygonMorph methodsFor: 'initialization' stamp: 'di 12/3/97 10:00'!vertices: verts color: c borderWidth: bw borderColor: bc	super initialize.	vertices _ verts.	color _ c.	borderWidth _ bw.	borderColor _ bc.	closed _ vertices size > 2.	quickFill _ true.	arrows _ #none.	self computeBounds.! !!PolygonMorph methodsFor: 'access' stamp: 'di 6/13/97 07:22'!borderColor: colorOrNil	borderColor _ colorOrNil.	self changed! !!PolygonMorph methodsFor: 'access' stamp: '6/8/97 15:43 di'!borderWidth: anInteger	borderColor ifNil: [borderColor _ Color black].	borderWidth _ anInteger.	self computeBounds! !!PolygonMorph methodsFor: 'access' stamp: 'di 12/4/97 09:45'!isCurve	^ false! !!PolygonMorph methodsFor: 'access' stamp: 'jm 11/19/97 18:55'!isOpen	^ closed not! !!PolygonMorph methodsFor: 'access' stamp: '6/9/97 13:22 di'!makeClosed	closed _ true.	self computeBounds! !!PolygonMorph methodsFor: 'access' stamp: '6/9/97 13:22 di'!makeOpen	closed _ false.	self computeBounds! !!PolygonMorph methodsFor: 'access' stamp: 'sw 9/14/97 18:22'!vertices	^ vertices! !!PolygonMorph methodsFor: 'geometry' stamp: 'di 12/1/97 12:44'!closestPointTo: aPoint	| curvePoint closestPoint dist minDist |	closestPoint _ minDist _ nil.	self lineSegmentsDo:		[:p1 :p2 | 		curvePoint _ aPoint nearestPointOnLineFrom: p1 to: p2.		dist _ curvePoint dist: aPoint.		(closestPoint == nil or: [dist < minDist])			ifTrue: [closestPoint _ curvePoint.					minDist _ dist]].	^ closestPoint! !!PolygonMorph methodsFor: 'geometry' stamp: 'di 12/3/97 14:38'!containsPoint: aPoint	(super containsPoint: aPoint) ifFalse: [^ false].	closed ifTrue:		[self filledForm colors: (Array with: Color white with:Color black).		^ (filledForm pixelValueAt: aPoint - boundstopLeft) = 1]	ifFalse:		[self lineSegmentsDo:			[:p1 :p2 | (aPoint onLineFrom: p1 to: p2 within: (2 max: borderWidth+1//2))					ifTrue: [^ true]].		arrowForms ifNotNil: [arrowForms do:			[:f | (f pixelValueAt: aPoint - f offset) > 0					ifTrue: [^ true]]].		^ false]! !!PolygonMorph methodsFor: 'geometry' stamp: 'sw 9/14/97 18:22'!flipHAroundX: centerX	"Flip me horizontally around the center.  If centerX is nil, compute my center of gravity."	| cent |	cent _ centerX 		ifNil: [bounds center x			"cent _ 0.			vertices do: [:each | cent _ cent + each x].			cent asFloat / vertices size"]		"average is the center"		ifNotNil: [centerX].	self setVertices: (vertices collect: [:vv |			(vv x - cent) * -1 + cent @ vv y]) reversed.! !!PolygonMorph methodsFor: 'geometry' stamp: 'sw 9/14/97 18:22'!flipVAroundY: centerY	"Flip me vertically around the center.  If centerY is nil, compute my center of gravity."	| cent |	cent _ centerY 		ifNil: [bounds center y			"cent _ 0.			vertices do: [:each | cent _ cent + each y].			cent asFloat / vertices size"]		"average is the center"		ifNotNil: [centerY].	self setVertices: (vertices collect: [:vv |			vv x @ ((vv y - cent) * -1 + cent)]) reversed.! !!PolygonMorph methodsFor: 'geometry' stamp: 'sw 9/14/97 18:22'!inset: amt	"Only works if I am made of rectangles (every segment of me is horizontal or vertical).  Inset each vertex by amt.  Uses containsPoint."	| delta four cnt offset |	delta _ amt asPoint.	four _ {delta.  -1@1 * delta.  -1@-1 * delta.  1@-1 * delta}.	self setVertices: (vertices collect: [:vv | 		cnt _ 0.		offset _ four detectSum: [:del | 			(self containsPoint: del+vv) ifTrue: [cnt _ cnt + 1. del] ifFalse: [0@0]].		cnt = 2 ifTrue: [offset _ offset // 2].		vv + offset]).! !!PolygonMorph methodsFor: 'geometry' stamp: 'sw 9/14/97 18:22'!merge: aPolygon	"Expand myself to enclose the other polygon.  (Later merge overlapping or disjoint in a smart way.)  For now, the two polygons must share at least two vertices.  Shared vertices must come one after the other in each polygon.  Polygons must not overlap."	| shared mv vv hv xx |	shared _ vertices select: [:mine | 		(aPolygon vertices includes: mine)].	shared size < 2 ifTrue: [^ nil].	"not sharing a segment"	mv _ vertices asOrderedCollection.	[shared includes: mv first] whileFalse: ["rotate them"		vv _ mv removeFirst.		mv addLast: vv].	hv _ aPolygon vertices asOrderedCollection.	[mv first = hv first] whileFalse: ["rotate him until same shared vertex is first"		vv _ hv removeFirst.		hv addLast: vv].	[shared size > 2] whileTrue: [		shared _ shared asOrderedCollection.		(self mergeDropThird: mv in: hv from: shared) ifNil: [^ nil]].		"works by side effect on the lists"	(mv at: 2) = hv last ifTrue: [mv removeFirst; removeFirst.		^ self setVertices: (hv, mv) asArray].	(hv at: 2) = mv last ifTrue: [hv removeFirst; removeFirst.		^ self setVertices: (mv, hv) asArray].	(mv at: 2) = (hv at: 2) ifTrue: [hv removeFirst.  mv remove: (mv at: 2).		xx _ mv removeFirst.		^ self setVertices: (hv, (Array with: xx), mv reversed) asArray].	mv last = hv last ifTrue: [mv removeLast.  hv removeFirst.		^ self setVertices: (mv, hv reversed) asArray].	^ nil! !!PolygonMorph methodsFor: 'geometry' stamp: 'sw 9/14/97 18:22'!mergeDropThird: mv in: hv from: shared	"We are merging two polygons.  In this case, they have at least three identical shared vertices.  Make sure they are sequential in each, and drop the middle one from vertex lists mv, hv, and shared.  First vertices on lists are identical already."	"know (mv first = hv first)"	| mdrop vv |	(shared includes: (mv at: mv size - 2)) 		ifTrue: [(shared includes: (mv last)) ifTrue: [mdrop _ mv last]]		ifFalse: [(shared includes: (mv last)) ifTrue: [			(shared includes: (mv at: 2)) ifTrue: [mdrop _ mv first]]].	(shared includes: (mv at: 3)) ifTrue: [		(shared includes: (mv at: 2)) ifTrue: [mdrop _ mv at: 2]].	mdrop ifNil: [^ nil].	mv remove: mdrop.	hv remove: mdrop.	shared remove: mdrop.	[shared includes: mv first] whileFalse: ["rotate them"		vv _ mv removeFirst.		mv addLast: vv].	[mv first = hv first] whileFalse: ["rotate him until same shared vertex is first"		vv _ hv removeFirst.		hv addLast: vv].! !!PolygonMorph methodsFor: 'geometry' stamp: 'sw 9/14/97 18:22'!rotate: degrees around: centerPt	"Rotate me around the center.  If center is nil, use the center of my bounds.  Rotation is clockwise on the screen."	| cent |	cent _ centerPt 		ifNil: [bounds center]	"approx the center"		ifNotNil: [centerPt].	degrees \\ 90 = 0 ifTrue: ["make these cases exact"		degrees \\ 360 = 90 ifTrue: ["right"			^ self setVertices: (vertices collect: [:vv |				(vv - cent) y * -1 @ ((vv - cent) x) + cent])].		degrees \\ 360 = 180 ifTrue: [			^ self setVertices: (vertices collect: [:vv |				(vv - cent) negated + cent])].		degrees \\ 360 = 270 ifTrue: ["left"			^ self setVertices: (vertices collect: [:vv |				(vv - cent) y @ ((vv - cent) x * -1) + cent])].		degrees \\ 360 = 0 ifTrue: [^ self].		].	self setVertices: (vertices collect: [:vv |			(Point r: (vv - cent) r degrees: (vv - cent) degrees + degrees) + cent]).! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 12/3/97 19:41'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	| lineColor bevel topLeftColor bottomRightColor bigClipRect brush p1i p2i |	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not ifTrue:		[self filledForm colors: (Array with: Color transparent with: color).		aCanvas image: self filledForm at: bounds topLeft].	lineColor _ borderColor.  bevel _ false.	"Border colors for bevelled effects depend on CW ordering of vertices"	borderColor == #raised ifTrue: [topLeftColor _ color lighter.						bottomRightColor _ color darker.  bevel _ true].	borderColor == #inset ifTrue: [topLeftColor _ owner colorForInsets darker.						bottomRightColor _ owner colorForInsets lighter.  bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth+1//2.	brush _ nil.	self lineSegmentsDo:		[:p1 :p2 | p1i _ p1 asIntegerPoint.  p2i _ p2 asIntegerPoint.		(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"					((p1i min: p2i) max: bigClipRect origin) <=					((p1i max: p2i) min: bigClipRect corner)]) ifTrue:			[bevel ifTrue: [((p1i quadrantOf: p2i) > 2)						ifTrue: [lineColor _ topLeftColor]						ifFalse: [lineColor _ bottomRightColor]].			(borderWidth > 3 and: [borderColor isColor])			ifTrue: [brush == nil ifTrue:						[brush _ (ColorForm dotOfSize: borderWidth)								colors: (Array with: Color transparent with: borderColor)].					aCanvas line: p1i to: p2i brushForm: brush]			ifFalse: [aCanvas line: p1i to: p2i							width: borderWidth color: lineColor]]].	self arrowForms ifNotNil:		[self arrowForms do:			[:f | f colors: (Array with: Color transparent with: borderColor).			aCanvas image: f at: f offset]]! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 11/14/97 11:14'!drawOnFills: aRectangle	^ false  "Could be improved by quick check of inner rectangle"! !!PolygonMorph methodsFor: 'editing' stamp: 'di 12/3/97 14:38'!dragVertex: evt fromHandle: handle vertIndex: ix	| p |	p _ evt cursorPoint.	vertices at: ix put: p.	handle position: p - (handle extent//2).	self computeBounds! !!PolygonMorph methodsFor: 'editing' stamp: 'di 9/25/97 16:13'!dropVertex: evt fromHandle: handle vertIndex: ix	| p |	p _ vertices at: ix.	(((vertices atWrap: ix-1) dist: p) < 3 or:		[((vertices atWrap: ix+1) dist: p) < 3])		ifTrue: ["Drag a vertex onto its neighbor means delete"				self setVertices: (vertices copyReplaceFrom: ix to: ix with: Array new)]! !!PolygonMorph methodsFor: 'editing' stamp: 'di 6/11/97 16:03'!extent: newExtent	"Not really advisable, but we can preserve most of the geometry if we don't	shrink things too small."	| safeExtent |	safeExtent _ newExtent max: 20@20.	self setVertices: (vertices collect:		[:p | p - bounds topLeft * (safeExtent asFloatPoint / (bounds extent max: 1@1)) + bounds topLeft])! !!PolygonMorph methodsFor: 'editing' stamp: 'di 9/26/97 10:33'!newVertex: evt fromHandle: handle afterVert: ix	"Insert a new vertex and fix everything up!!	Install the drag-handle of the new vertex as recipient of further mouse events."	| pt |	pt _ evt cursorPoint.	self setVertices: (vertices copyReplaceFrom: ix+1 to: ix with: (Array with: pt)).	evt hand mouseDownRecipient: (handles at: ix+1*2-1)! !!PolygonMorph methodsFor: 'menu' stamp: 'tk 7/28/97 23:04'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	handles == nil ifTrue: [aCustomMenu add: 'show handles' action: #addHandles]		ifFalse: [aCustomMenu add: 'hide handles' action: #removeHandles].	closed ifTrue: [aCustomMenu add: 'open polygon' action: #makeOpen]		ifFalse:		[aCustomMenu add: 'close polygon' action: #makeClosed.		arrows == #none ifFalse: [aCustomMenu add: '---' action: #makeNoArrows].		arrows == #forward ifFalse: [aCustomMenu add: '-->' action: #makeForwardArrow].		arrows == #back ifFalse: [aCustomMenu add: '<--' action: #makeBackArrow].		arrows == #both ifFalse: [aCustomMenu add: '<-->' action: #makeBothArrows]]! !!PolygonMorph methodsFor: 'menu' stamp: 'di 12/3/97 14:30'!addHandles	| handle newVert tri |	self removeHandles.	handles _ OrderedCollection new.	tri _ Array with: 0@-4 with: 4@3 with: -3@3.	vertices withIndexDo:		[:vertPt :vertIndex |		handle _ EllipseMorph newBounds: (Rectangle center: vertPt extent: 8@8)				color: Color yellow.		handle on: #mouseStillDown send: #dragVertex:fromHandle:vertIndex:				to: self withValue: vertIndex.		handle on: #mouseUp send: #dropVertex:fromHandle:vertIndex:				to: self withValue: vertIndex.		self addMorph: handle.		handles addLast: handle.		(closed or: [vertIndex < vertices size]) ifTrue:			["newVert _ (RectangleMorph newBounds: (Rectangle center: vertPt + (vertices atWrap: vertIndex+1) // 2 extent: 7@7)					color: Color green) borderWidth: 1."			newVert _ PolygonMorph					vertices: (tri collect: [:p | p + (vertPt + (vertices atWrap: vertIndex+1) // 2)])					color: Color green borderWidth: 1 borderColor: Color black.			newVert on: #mouseDown send: #newVertex:fromHandle:afterVert:					to: self withValue: vertIndex.			self addMorph: newVert.			handles addLast: newVert]].	self changed! !!PolygonMorph methodsFor: 'menu' stamp: '6/9/97 21:32 di'!makeBackArrow	arrows _ #back.	self computeBounds! !!PolygonMorph methodsFor: 'menu' stamp: '6/9/97 21:32 di'!makeBothArrows	arrows _ #both.	self computeBounds! !!PolygonMorph methodsFor: 'menu' stamp: '6/9/97 21:32 di'!makeForwardArrow	arrows _ #forward.	self computeBounds! !!PolygonMorph methodsFor: 'menu' stamp: '6/9/97 21:32 di'!makeNoArrows	arrows _ #none.	self computeBounds! !!PolygonMorph methodsFor: 'menu' stamp: 'tk 9/2/97 16:04'!removeHandles	"tk 9/2/97 allow it to be called twice (when nil already)"	handles ifNotNil: [		handles do: [:h | h delete].		handles _ nil].! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/13/97 15:09'!arrowForms	"ArrowForms are computed only upon demand"	(closed or: [arrows == #none or: [vertices size < 2]]) ifTrue:		[^ arrowForms _ nil].	arrowForms ifNotNil: [^ arrowForms].	arrowForms _ Array new.	(arrows == #forward or: [arrows == #both]) ifTrue:		[arrowForms _ arrowForms copyWith:			(self computeArrowFormAt: vertices last from: self nextToLastPoint)].	(arrows == #back or: [arrows == #both]) ifTrue:		[arrowForms _ arrowForms copyWith:			(self computeArrowFormAt: vertices first from: self nextToFirstPoint)].	^ arrowForms! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/13/97 07:21'!computeArrowFormAt: endPoint from: priorPoint	"Compute a triangle oriented along the line from priorPoint to endPoint.	Then draw those lines in a form and return that form, with appropriate offset"	| d v p1 pts box arrowForm bb origin angle |	d _ borderWidth max: 1.	v _ endPoint - priorPoint.	angle _ v theta radiansToDegrees.	pts _ Array with: (endPoint + (borderWidth//2) + (Point r: d*5 degrees: angle))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle + 135.0))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle - 135.0)).	box _ ((pts first rect: pts last) encompass: (pts at: 2)) expandBy: 1.	arrowForm _ ColorForm extent: box extent asIntegerPoint.	bb _ (BitBlt toForm: arrowForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ box topLeft.	p1 _ pts last - origin.	pts do: [:p | bb drawFrom: p1 to: p-origin.  p1 _ p-origin].	arrowForm convexShapeFill: Color black.	^ arrowForm offset: box topLeft! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/13/97 15:11'!computeBounds	self changed.	bounds _ self curveBounds.	self releaseCachedState.	self arrowForms ifNotNil:		[self arrowForms do:		[:f | bounds _ bounds merge: (f offset extent: f extent)]].	handles ifNotNil: [self updateHandles].	self layoutChanged.	self changed! !!PolygonMorph methodsFor: 'private' stamp: 'sw 9/14/97 18:22'!copyRecordingIn: dict	"Copy the vertices array.  Give each one its own handles, and in the handles array."	| new hadHandles |	hadHandles _ handles ifNil: [false] ifNotNil: [self removeHandles. true].	new _ super copyRecordingIn: dict.	new setVertices: vertices copy.	hadHandles ifTrue: [self addHandles.  new addHandles].	^ new! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/3/97 19:37'!curveBounds	^ (Rectangle encompassing: vertices) expandBy: borderWidth+1//2! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/29/97 21:00'!filledForm	"Computation of the filled form is done only on demand"	| bb origin |	closed ifFalse: [^ filledForm _ nil].	filledForm ifNotNil: [^ filledForm].	filledForm _ ColorForm extent: bounds extent.	bb _ (BitBlt toForm: filledForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ bounds topLeft.	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin										to: p2 asIntegerPoint-origin].	quickFill ifTrue: [filledForm convexShapeFill: Color black]			ifFalse: ["Someday put a better fill algorithm here"].	^ filledForm! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/21/97 21:29'!lineSegments	| lineSegments |	lineSegments _ OrderedCollection new.	self lineSegmentsDo: [:p1 :p2 | lineSegments addLast: (Array with: p1 with: p2)].	^ lineSegments! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/29/97 20:54'!lineSegmentsDo: endPointsBlock	| beginPoint |	beginPoint _ nil.	vertices do:		[:endPoint | beginPoint ifNotNil:			[endPointsBlock value: beginPoint							value: endPoint].		beginPoint _ endPoint].	(closed or: [vertices size = 1])		ifTrue: [endPointsBlock value: beginPoint								value: vertices first]! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/13/97 15:16'!loadCachedState	"Prepare for fast response -- next page of a book?"	self filledForm.	self arrowForms! !!PolygonMorph methodsFor: 'private' stamp: '6/9/97 12:07 di'!nextToFirstPoint  "For arrow direction"	^ vertices at: 2! !!PolygonMorph methodsFor: 'private' stamp: '6/9/97 12:07 di'!nextToLastPoint  "For arrow direction"	^ vertices at: vertices size - 1! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/13/97 15:08'!privateMoveBy: delta	super privateMoveBy: delta.	vertices _ vertices collect: [:p | p + delta].	self arrowForms ifNotNil: [self arrowForms do: [:f | f offset: f offset + delta]]! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/13/97 15:05'!releaseCachedState	filledForm _ nil.	arrowForms _ nil! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/11/97 16:00'!setVertices: newVertices	| hadHandles |	hadHandles _ handles ifNil: [false] ifNotNil: [self removeHandles. true].	vertices _ newVertices.	hadHandles ifTrue: [self addHandles].	self computeBounds! !!PolygonMorph methodsFor: 'private' stamp: 'di 9/26/97 10:33'!updateHandles	| newVert |	vertices withIndexDo:		[:vertPt :vertIndex |		(closed or: [vertIndex < vertices size]) ifTrue:			[newVert _ handles at: vertIndex*2.			newVert position: (vertPt + (vertices atWrap: vertIndex+1)								- newVert extent) // 2 + (2@0)]].! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'di 9/26/97 10:33'!vertices: verts color: c borderWidth: bw borderColor: bc	^ self basicNew vertices: verts color: c borderWidth: bw borderColor: bc! !!PopUpMenu methodsFor: 'displaying'!displayAt: aPoint withCaption: captionOrNil during: aBlock	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."	| delta savedArea captionView captionSave outerFrame captionText tFrame frameSaveLoc |	frame _ frame align: marker leftCenter with: aPoint + (2@0).	outerFrame _ frame.	captionOrNil notNil ifTrue:		[captionText _ DisplayText				text: captionOrNil asText				textStyle: TextStyle default copy centered.		tFrame _ captionText boundingBox insetBy: -2.		outerFrame _ frame merge: (tFrame align: tFrame bottomCenter					with: frame topCenter + (0@2))].	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	frame _ frame translateBy: delta.	captionOrNil notNil ifTrue:		[captionView _ DisplayTextView new model: captionText.		captionView align: captionView boundingBox bottomCenter					with: frame topCenter + (0@2).		captionView insideColor: Color white.		captionView borderWidth: 2.		captionSave _ Form fromDisplay: captionView displayBox.		captionView unlock; display; release].	marker _ marker align: marker leftCenter with: aPoint + delta +  (2@0).	savedArea _ Form fromDisplay: frame.	self menuForm displayOn: Display at: (frameSaveLoc _ frame topLeft).	selection ~= 0 ifTrue: [Display reverse: marker].	Cursor normal showWhile: [aBlock value].	savedArea displayOn: Display at: frameSaveLoc.	captionOrNil notNil ifTrue:		[captionSave displayOn: Display at: captionView displayBox topLeft]! !!PopUpMenu methodsFor: 'marker adjustment'!manageMarker	"If the cursor is inside the receiver's frame, then highlight the marked 	item. Otherwise no item is to be marked."	| pt |	"Don't let pt get far from display box, so scrolling will go all the way"	pt _ Sensor cursorPoint adhereTo: (Display boundingBox expandBy: 1).	(frame inside containsPoint: pt)		ifTrue: ["Need to cache the form for reasonable scrolling performance"				(Display boundingBox containsPoint: pt)					ifTrue: [CacheMenuForms ifFalse: [form _ nil]]					ifFalse: [form == nil ifTrue: [form _ self computeForm].							pt _ pt - (self scrollIntoView: pt)].				self markerOn: pt]		ifFalse: [self markerOff]! !!PopUpMenu methodsFor: 'marker adjustment'!scrollIntoView: cursorLoc	| dy |	dy _ 0.	cursorLoc y < 0 ifTrue: [dy _ font height].	cursorLoc y > Display height ifTrue: [dy _ font height negated].	dy = 0 ifTrue: [^ 0@0].	self markerOff.	frame _ frame translateBy: 0@dy.	marker _ marker translateBy: 0@dy.	self menuForm displayOn: Display at: frame topLeft.	^ 0@dy! !!PopUpMenu methodsFor: 'private'!computeForm	"Compute and answer a Form to be displayed for this menu."	| borderInset paraForm menuForm |	borderInset _ 2@2.	paraForm _ self computeLabelParagraph asForm.	menuForm _ Form extent: paraForm extent + (borderInset * 2).	menuForm fillBlack.	paraForm displayOn: menuForm at: borderInset.	lineArray == nil ifFalse: [		lineArray do: [ :line |			menuForm fillBlack:				(0 @ ((line * font height) + borderInset y) extent: (menuForm width @ 1)).		].	].	^ menuForm! !!PopUpMenu methodsFor: 'private'!computeLabelParagraph	"Answer a Paragraph containing this menu's labels, one per line and centered."	^ Paragraph withText: labelString asText style: MenuStyle! !!PopUpMenu methodsFor: 'private'!labels: aString font: aFont lines: anArray	| style inside |	labelString _ aString.	font _ aFont.	lineArray _ anArray.	frame _ Quadrangle new.	frame region: self menuForm boundingBox.	frame borderWidth: 2.	inside _ frame inside.	marker _ inside topLeft extent: (inside width @ self computeLabelParagraph lineGrid).	selection _ 1.! !!PopUpMenu methodsFor: 'private'!menuForm	"Answer a Form to be displayed for this menu."	"Details: On slower systems, cache the menu Form for speed."	form == nil ifFalse: [^ form].	CacheMenuForms		ifTrue: [^ form _ self computeForm]		ifFalse: [^ self computeForm]! !!PopUpMenu methodsFor: 'private'!rescan	"Cause my form to be recomputed after a font change."	labelString == nil ifTrue: [labelString _ 'NoText!!'].	self labels: labelString font: (MenuStyle fontAt: 1) lines: lineArray.	form _ nil.	"PopUpMenu withAllSubclasses do: [ :menuClass |		menuClass allInstancesDo: [ :m | m rescan ]]"! !!PopUpMenu class methodsFor: 'instance creation'!labels: aString lines: anArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray."	^self new		labels: aString		font: (MenuStyle fontAt: 1)		lines: anArray! !!PopUpMenu class methodsFor: 'class initialization'!initialize  "PopUpMenu initialize"	"Change CacheMenuForms to true to get faster popup menus on slower systems."	"CacheMenuForms _ true"	CacheMenuForms _ false.	(MenuStyle _ TextStyle default copy)		gridForFont: 1 withLead: 0;		centered.	PopUpMenu withAllSubclasses do:		[:menuClass | menuClass allInstancesDo:			[:m | m rescan]]! !!PositionableStream methodsFor: 'accessing'!next: anInteger 	"Answer the next anInteger elements of the receiver."	| newArray |	newArray _ collection species new: anInteger.	1 to: anInteger do: [:index | newArray at: index put: self next].	^newArray! !!PositionableStream methodsFor: 'accessing'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| newStream el |	newStream _ WriteStream on: (collection species new: 100).	[(el _ self next) == nil] whileFalse: [ newStream nextPut: el ].	^ newStream contents! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 08:34'!copyMethodChunkFrom: aStream	"Copy the next chunk from aStream (must be different from the receiver)."	| terminator code |	terminator _ $!!.	aStream skipSeparators.	code _ aStream upTo: terminator.	self nextPutAll: code; nextPut: terminator.	[aStream peekFor: terminator] whileTrue:   "case of imbedded (doubled) terminators"			[self nextPut: terminator;				nextPutAll: (aStream upTo: terminator);				nextPut: terminator].! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 08:49'!copyMethodWithPreamble: preamble from: aStream	| newFilePosition |	"First copy the preamble if any."	self copyPreamble: preamble from: aStream.	"Then copy the method chunk"	newFilePosition _ self position.	self copyMethodChunkFrom: aStream.	self nextChunkPut: ' '.	^ newFilePosition! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 09:16'!copyPreamble: preamble from: aStream	"Look for a changeStamp for this method by peeking backward.	Write a method preamble, with that stamp if found."	| terminator methodPos p last50 stamp i |	terminator _ $!!.	"Look back to find stamp in old preamble, such as...	Polygon methodsFor: 'private' stamp: 'di 6/25/97 21:42' prior: 34957598!! "	methodPos _ aStream position.	aStream position: (p _ 0 max: methodPos-50).	last50 _ aStream next: methodPos - p.	stamp _ String new.	(i _ last50 findString: 'stamp:' startingAt: 1) > 0 ifTrue:		[stamp _ (last50 copyFrom: i+8 to: last50 size) copyUpTo: $'].	"Write the new preamble, with old stamp if any."	self cr; nextPut: terminator.	self nextChunkPut: (String streamContents:		[:strm |		strm nextPutAll: preamble.		stamp size > 0 ifTrue:			[strm nextPutAll: ' stamp: '; print: stamp]]).	self cr! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'tk 12/13/97 13:36'!decodeStyle: runsObjData version: styleVersion	"Decode the runs array from the ReferenceStream it is stored in."	"Verify that the class mentioned have the same inst vars as we have now"	| structureInfo |	styleVersion = RemoteString currentTextAttVersion ifTrue: [		"Matches our classes, no need for checking"		^ (ReferenceStream on: runsObjData) next].	structureInfo _ RemoteString structureAt: styleVersion.	"or nil"		"See SmartRefStream instVarInfo: for dfn"	^ SmartRefStream read: runsObjData withClasses: structureInfo! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'tk 12/12/97 11:29'!nextChunk	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character.  This is raw nextChunk, and may begin with ]text[."	| terminator out ch |	terminator _ $!!.	out _ WriteStream on: (String new: 1000).	self skipSeparators.	[(ch _ self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 1/13/98 16:54'!nextChunkText	"Deliver the next chunk as a Text.  Decode the following ]style[ chunk if present.  Position at start of next real chunk."	| string runsRaw strm runs peek |	"Read the plain text"	string _ self nextChunk.		"Test for ]style[ tag"	peek _ self skipSeparatorsAndPeekNext.	peek = $] ifFalse: [^ string asText].  "no tag"	(self upTo: $[) = ']style' ifFalse: [^ string asText].  "different tag"	"Read and decode the style chunk"	runsRaw _ self nextChunk.	"style encoding"	strm _ ReadStream on: runsRaw from: 1 to: runsRaw size.	runs _ RunArray scanFrom: strm.	^ Text basicNew setString: string setRunsChecking: runs.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 6/13/97 12:00'!skipSeparators	[self atEnd]		whileFalse:		[self next isSeparator ifFalse: [^ self position: self position-1]]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 1/13/98 16:08'!skipSeparatorsAndPeekNext	"A special function to make nextChunk fast"	| peek |	[self atEnd]		whileFalse:		[(peek _ self next) isSeparator			ifFalse: [self position: self position-1. ^ peek]]!]style[(70 126)f1b,f1! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'tk 12/29/97 12:37'!skipStyleChunk	"Get to the start of the next chunk that is not a style for the previous chunk"	| pos |	pos _ self position.	self skipSeparators.	self peek == $] 		ifTrue: [(self upTo: $[) = ']text' 	"old -- no longer needed"				"now positioned past the open bracket"			ifFalse: [self nextChunk]]	"absorb ]style[ and its whole chunk"						ifFalse: [self position: pos]	"leave untouched"! !Preferences comment:'A general mechanism to store preference choices.  The default setup treats any symbol as a potential boolean flag; flags unknown to the preference dictionary are always returned as false.  It is also possible to store non-boolean data in the preference table.  sw 8/91'!!Preferences class methodsFor: 'initialization' stamp: 'jhm 10/15/97 17:28'!chooseInitialSettings	"Restore the default choices for Preferences."	"Preferences chooseInitialSettings"	self setPreference: #reverseWindowStagger toValue: true.	self setPreference: #thoroughSenders toValue: true.	self setPreference: #uniformWindowColors toValue: false.	self setPreference: #warnIfNoChangesFile toValue: true.	self setPreference: #warnIfNoSourcesFile toValue: true.! !!Preferences class methodsFor: 'initialization' stamp: 'jhm 10/15/97 17:13'!initialize	"Preferences initialize"	FlagDictionary _ Dictionary new.	self chooseInitialSettings.! !!Preferences class methodsFor: 'hard-coded preferences' stamp: 'jhm 10/15/97 17:31'!desktopColor	"Answer the desktop color. Initialize it if necessary."		DesktopColor == nil ifTrue: [DesktopColor _ Color gray].	^ DesktopColor! !!Preferences class methodsFor: 'hard-coded preferences' stamp: 'jhm 10/15/97 17:31'!desktopColor: aColor	"Record a new desktop color preference."	DesktopColor _ aColor.! !!Preferences class methodsFor: 'hard-coded preferences'!scrollBarColor	"Answer the preferred color for scroll bar elevators."	^ Color gray! !!Preferences class methodsFor: 'hard-coded preferences'!scrollBarWidth	"Answer the preferred width for scroll bars."	^ 8! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jhm 10/15/97 17:29'!deletePreference: preferenceNameSymbol	FlagDictionary removeKey: preferenceNameSymbol ifAbsent: [].! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jhm 10/15/97 17:32'!doesNotUnderstand: aMessage	"Look up the message selector as a flag."	^ self valueOfFlag: aMessage selector! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jhm 10/15/97 17:12'!openPreferencesInspector	"Open a window on the current preferences dictionary, allowing the user to inspect and change the current preference settings."	"Preferences openPreferencesInspector"	FlagDictionary inspectWithLabel: 'Preferences'! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jhm 10/15/97 17:12'!setPreference: preferenceNameSymbol toValue: aBoolean	FlagDictionary at: preferenceNameSymbol put: aBoolean.! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jhm 10/15/97 17:12'!valueOfFlag: aFlagName	^ FlagDictionary at: aFlagName ifAbsent: [false]! !!Preferences class methodsFor: 'ui prefs' stamp: 'di 1/2/98 11:15'!userPlacement	"Answer whether the user prefers to place and size all new windows by hand."	^ false! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'jm 9/11/97 10:44'!idleProcess	"A default background process which is invisible."	[true] whileTrue:		[self relinquishProcessorForMicroseconds: 1000].! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'jm 9/3/97 11:17'!relinquishProcessorForMicroseconds: anInteger	"Platform specific. This primitive is used to return processor cycles to the host operating system when Squeak's idle process is running (i.e., when no other Squeak process is runnable). On some platforms, this primitive causes the entire Squeak application to sleep for approximately the given number of microseconds. No Squeak process can run while the Squeak application is sleeping, even if some external event makes it runnable. On the Macintosh, this primitive simply calls GetNextEvent() to give other applications a chance to run. On platforms without a host operating system, it does nothing. This primitive should not be used to add pauses to a Squeak process; use a Delay instead."	<primitive: 230>	"don't fail if primitive is not implemented, just do nothing"! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'jm 9/11/97 10:42'!startUp	"Install a background process of the lowest possible priority that is always runnable."	"Details: The virtual machine requires that there is aways some runnable process that can be scheduled; this background process ensures that this is the case."	BackgroundProcess == nil ifFalse: [BackgroundProcess terminate].	BackgroundProcess _ [self idleProcess] newProcess.	BackgroundProcess priority: SystemRockBottomPriority.	BackgroundProcess resume.! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'jm 9/11/97 10:32'!sweepHandIdleProcess	"A default background process which shows a sweeping circle of XOR-ed bits on the screen."	| sweepHand |	sweepHand _ Pen new.	sweepHand defaultNib: 2.	sweepHand combinationRule: 6.	[true] whileTrue: [		2 timesRepeat: [			sweepHand north.			36 timesRepeat: [				sweepHand place: Display boundingBox topRight + (-25@25).				sweepHand go: 20.				sweepHand turn: 10]].		self relinquishProcessorForMicroseconds: 10000].! !Project comment:'A Project stores the state of a complete Squeak desktop, including the windows, and the currently active changeSet, as well as the parent project in which it was created.  When you change projects, whether by entering or exiting, all the global state is saved into the project being exited, and loaded from the one being entered.A project is retained by its view in the parent world.  It is effectively named by the name of its changeSet, which can be changed either by renaming in a changeSorter, or by editing the label of its view from the parent project.As the site of major context switch, Projects are the locus of swapping between the old MVC and the new Morphic worlds.  The distinction is based on whether the variable ''world'' contains a WorldMorph or a ControlManager.'!!Project methodsFor: 'initialization' stamp: 'di 6/24/97 11:51'!initFromParent:  aProject	"Written so that Morphic can still be removed."	world _ (Smalltalk at: #WorldMorph ifAbsent: [^ nil]) new.	changeSet _ ChangeSet new initialize.	transcript _ Transcript.  "  -- we need a TranscriptMorph"	displayDepth _ Display depth.	parentProject _ aProject! !!Project methodsFor: 'initialization'!initialProject	self saveState.	parentProject _ self! !!Project methodsFor: 'initialization'!setChangeSet: aChangeSet	changeSet _ aChangeSet! !!Project methodsFor: 'initialization'!setProjectHolder: aProject	world _ ControlManager new.	changeSet _ ChangeSet new initialize.	transcript _ TextCollector new.	displayDepth _ Display depth.	parentProject _ aProject! !!Project methodsFor: 'accessing'!isTopProject	"Return true only of this is the top project (its own holder)"	^ parentProject == self! !!Project methodsFor: 'accessing'!leaveThisWorld	exitFlag _ true! !!Project methodsFor: 'accessing'!name	^ changeSet name! !!Project methodsFor: 'accessing'!projectChangeSet	^ changeSet! !!Project methodsFor: 'accessing'!world	^ world! !!Project methodsFor: 'menu messages' stamp: 'di 6/17/97 18:05'!enter	"The user has chosen to change the context of the workspace to be that of 	the receiver. Change the ChangeSet, Transcript, and collection of 	scheduled views accordingly."	CurrentProject saveState.	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TextCollector newTranscript: transcript.	displayDepth == nil ifTrue: [displayDepth _ Display depth].	Display newDepthNoRestore: displayDepth.	world isMorph ifFalse: [World _ nil.  ^ ControlManager newScheduler: world].	(World _ world) install.	self spawnNewProcess! !!Project methodsFor: 'menu messages' stamp: 'di 11/14/97 08:31'!exit	"Leave the current project and return to the project	in which this one was created."	self isTopProject ifTrue: [^ PopUpMenu notify: 'Can''t exit the top project'].	activeProcess _ nil.	parentProject enter.! !!Project methodsFor: 'menu messages'!fileOut	changeSet fileOut! !!Project methodsFor: 'menu messages' stamp: 'di 6/16/97 11:39'!saveState	"Save the current state in me prior to switching projects"	world isMorph ifTrue: [world _ World]				ifFalse: [world _ ScheduledControllers.						ScheduledControllers unCacheWindows].	changeSet _ Smalltalk changes.	transcript _ Transcript.	displayDepth _ Display depth.! !!Project methodsFor: 'menu messages' stamp: 'di 6/17/97 18:05'!spawnNewProcess	exitFlag _ false.	activeProcess _		[[World doOneCycle.  Processor yield.  exitFlag] whileFalse: [].		self exit]			newProcess priority: Processor userSchedulingPriority.	activeProcess resume.	Processor terminateActive! !!Project methodsFor: 'release' stamp: 'di 1/2/98 11:34'!okToChange	^ (world isMorph not and: [world scheduledControllers size <= 1]) or: [self confirm:'Are you sure you have savedall changes that you care aboutin ', self name printString].! !!Project methodsFor: 'release'!release	world == nil ifFalse:		[world release.		world _ nil].	^ super release! !!Project class methodsFor: 'instance creation' stamp: 'di 11/16/97 09:39'!newMorphic   "ProjectView open: Project newMorphic"	^ super new initFromParent: CurrentProject! !!ProjectView methodsFor: 'displaying' stamp: 'di 11/14/97 08:31'!displayView	| scale rect topLeft ibox worldImage sc |	super displayView.	self label = model name		ifFalse: [super relabel: model name].	self isCollapsed ifTrue: [^ self].	model world isMorph ifTrue:		[Display fill: (ibox _ self insetDisplayBox) fillColor: model world color.		model world layoutChanged.		worldImage _ model world imageForm.		model world fullReleaseCachedState.		^ (WarpBlt toForm: Display)			sourceForm: worldImage;			cellSize: 2;    "installs a colormap"			combinationRule: Form paint;			copyQuad: (worldImage offset negated extent: Display extent) innerCorners			toRect: self insetDisplayBox].	Display fill: (ibox _ self insetDisplayBox) fillColor: model world screenController view model asForm " Color lightGray".	scale _ ibox extent / Display extent.	topLeft _ ibox topLeft.	sc _ model world screenController.	(model world scheduledControllers select: [:c | c ~~ sc] thenCollect: [:c | c view])		reverseDo:		[:v | rect _ ((v displayBox scaleBy: scale) rounded				translateBy: topLeft) intersect: ibox.		Display fill: rect fillColor: v backgroundColor;			border: rect width: 1;			border: (rect topLeft extent: rect width@3) width: 1]! !ProtocolBrowser comment:'An instance of ProtocolBrowser shows the methods a class understands--inherited or implemented at this level--as a "flattened" list.'!!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:33'!getList	"Answer the receiver's message list."	^ messageList! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:33'!list	"Answer the receiver's message list."	^ messageList! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!selectedClass	"Answer the receiver's selected class."	^ selectedClass! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!selectedClass: aClass	"Set the receiver's selected class to be the argument."	selectedClass := aClass! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!selector	"Answer the receiver's selected selector."	^ selectedSelector! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!selector: aString	"Set the currently selected message selector to be aString."	selectedSelector := aString.	self changed: #selector! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!setSelector: aString	"Set the currently selected message selector to be aString."	selectedSelector := aString! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 7/13/97 16:23'!initListFrom: selectorCollection highlighting: aClass 	"Make up the messageList with items from aClass in boldface."	| defClass item |	messageList := OrderedCollection new.	selectorCollection do: 		[:selector |  defClass := aClass whichClassIncludesSelector: selector.		item _ selector, '     (' , defClass name , ')'.		messageList add: (defClass == aClass ifTrue:[item asText allBold] ifFalse:[item])]! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 7/13/97 16:26'!on: aClass 	"Initialize with the entire protocol for the class, aClass."	self initListFrom: aClass allSelectors asSortedCollection		highlighting: aClass! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 7/13/97 16:29'!onSubProtocolOf: aClass 	"Initialize with the entire protocol for the class, aClass,		but excluding those inherited from Object."	| selectors |	selectors := Set new.	(aClass withAllSuperclasses copyWithout: Object) do:		[:each | selectors addAll: each selectors].	self initListFrom: selectors asSortedCollection		highlighting: aClass! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 7/13/97 16:51'!parse: messageString toClassAndSelector: csBlock	"Decode strings of the form <selectorName>   (<className> [class])  "	| tuple cl |	tuple _ messageString asString findTokens: ' '.	cl _ tuple at: 2.	cl _ cl copyWithoutAll: '()'.  "Strip parens"	cl _ tuple size = 2		ifTrue: [Smalltalk at: cl asSymbol]		ifFalse: [(Smalltalk at: cl asSymbol) class].	self selectedClass: cl.	self setSelector: tuple first.	^ csBlock value: cl value: tuple first asSymbol! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 7/13/97 16:37'!setClassAndSelectorIn: csBlock	"Decode strings of the form <selectorName>   (<className> [class])  "	^ self parse: self selection toClassAndSelector: csBlock! !!ProtocolBrowser class methodsFor: 'instance creation' stamp: 'di 7/13/97 15:15'!openFullProtocolForClass: aClass 	"Create and schedule a browser for the entire protocol of the class."	"ProtocolBrowser openFullProtocolForClass: ProtocolBrowser."	| aPBrowser label |	aPBrowser := ProtocolBrowser new on: aClass.	label := 'Entire protocol of: ', aClass name.	self open: aPBrowser name: label! !!ProtocolBrowser class methodsFor: 'instance creation' stamp: 'di 7/13/97 15:15'!openSubProtocolForClass: aClass 	"Create and schedule a browser for the entire protocol of the class."	"ProtocolBrowser openSubProtocolForClass: ProtocolBrowser."	| aPBrowser label |	aPBrowser := ProtocolBrowser new onSubProtocolOf: aClass.	label := 'Sub-protocol of: ', aClass name.	self open: aPBrowser name: label! !PseudoContext comment:'I represent cached context state within the virtual machine.  I have the same format as normal method and block contexts, but my fields are never referenced directly from Smalltalk.  Whenever a message is sent to me I will magically transform myself into a real context which will respond to all the usual messages.	I rely on the fact that block and method contexts have exactly the same number of fixed fields.'!!PseudoContext methodsFor: 'testing' stamp: 'ikp 9/26/97 14:45'!isPseudoContext	^true! !!PseudoContext methodsFor: 'system primitives' stamp: 'ikp 10/20/97 15:36'!nextObject	"See Object>>nextObject."	<primitive: 139>	self primitiveFailed.! !!PseudoContext class methodsFor: 'class initialization' stamp: 'ikp 1/10/98 02:33'!initialize	"It's tricky to do the necessary stuff with the regular file-in machinery."	PseudoContext superclass = nil		ifFalse: [			(Smalltalk confirm: 'Shall I convert PseudoContext into a compact subclass of nil?("yes" is almost always the correct response)')				ifTrue: [					PseudoContext becomeCompact.					PseudoContext superclass removeSubclass: PseudoContext.					PseudoContext superclass: nil]].	Smalltalk recreateSpecialObjectsArray.	Smalltalk specialObjectsArray size = 41		ifFalse: [self error: 'Please check size of special objects array!!']! !!PseudoContext class methodsFor: 'filing out' stamp: 'ikp 9/26/97 14:45'!definition	"Our superclass is really nil, but this causes problems when we try to become compact	after filing in for the first time.  Fake the superclass as Object, and repair the situation	during class initialisation."	| defn |	defn _ super definition.	^(defn beginsWith: 'nil ')		ifTrue: ['Object' , (defn copyFrom: 4 to: defn size)]		ifFalse: [defn].! !!PseudoContext class methodsFor: 'private' stamp: 'ikp 9/26/97 14:45'!contextCacheDepth	"Answer the number of entries in the context cache.  This requires a little insider	knowledge.  Not intended for casual use, which is why it's private protocol."	^self contextCacheDepth: thisContext yourself! !!PseudoContext class methodsFor: 'private' stamp: 'ikp 9/26/97 14:45'!contextCacheDepth: b	^b isPseudoContext		ifTrue: [1 + (self contextCacheDepth: b)]		ifFalse: [1]! !PWS is the PluggableWebServer.  Documentation for it can be found athttp://www.cc.gatech.edu/fac/mark.guzdial/squeak/pws/.The PWS decouples the networking and HTTP translation roles of a Web Serverfrom the URL translation and CGI execution roles. The latter roles areplayed by ServerActions.To record a ServerAction for the PWS, use PWS link: key to: action. Key isa string that will be parsed out of the incoming URL.PWS (and its associated files) are based on Georg Gollman's WebServer,extended by Mark Guzdial.  Those portions are copyright 1997 Georgia TechResearch Corporation and are used with permission.  Mark Guzdial's work onPWS was funded in part by NSF grant REC-9550458.!!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:23'!fields   "Return the value of the instance variable 'fields'."   ^fields! !!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:23'!log   "Return the value of the instance variable 'log'."   ^log! !!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:23'!log: aString	"Add to the log."	log nextPutAll: aString! !!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:23'!message   "Return the value of the instance variable 'message'."   ^message! !!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:23'!objectsInField: fieldName  "Extract the array of objects denoted by 'fieldName', return an empty array if there are none."  | sel |  sel := fields at: fieldName ifAbsent: [ ^#() ].  (sel isKindOf: Array) ifFalse: [ sel := { sel } ].  ^sel collect: [ :s | self objectFromString: s ]! !!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:23'!peerName  "Return the requesting ipAddress"  ^peerName! !!PWS methodsFor: 'Accessing' stamp: 'mjg 11/26/97 10:27'!reply: aString	"Send back part of the reply. If we are in roll forward mode just do nothing."	"Transcript show: 'R',aString ; cr."	connection ifNotNil: [ connection sendData: aString ]! !!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:33'!url	^ url! !!PWS methodsFor: 'Accessing' stamp: 'mjg 11/6/97 16:57'!userID   "Return the value of the instance variable 'userID'."   ^userId! !!PWS methodsFor: 'Initializing' stamp: 'mjg 11/4/97 13:53'!initializeFrom: aSocket	"Initialize me from aSocket."	| request header idx |	log _ WriteStream on: ''.	connection _ aSocket.	request _ self readRequest.	header _ request first substrings.	url _ self unEscape: (header at: 2).	((idx _ header indexOf: 'Authorization:') ~= 0 and: [(header at: idx + 1)			= 'Basic'])		ifTrue: [userId _ header at: idx + 2].	peerName _ connection peerName.	log		nextPutAll: Time totalSeconds asString; tab;		nextPutAll: peerName asString; tab;		nextPutAll: userId asString; tab;		nextPutAll: url; tab;		nextPutAll: request last asString; tab.	message := url findTokens: '/.\?:='.	request last notNil ifTrue: [ fields := self decodeFields: request last ]! !!PWS methodsFor: 'Initializing' stamp: 'mjg 10/25/97 14:22'!readRequest	"Read the request and return an array of header and query."	| idx request header query length |	request := ''.	[	request := request, connection getData.		(idx := request findString: (self class crlfcrlf) startingAt: 1) = 0 ] whileTrue.	header := request copyFrom: 1 to: idx - 1.	(request beginsWith: 'POST') ifTrue: [		(length := request asUppercase findString: 'CONTENT-LENGTH:' startingAt: 1) = 0 			ifTrue: [ self error: '* noLength' ].		length := (request copyFrom: length + 15 to: 		  (request indexOf: Character cr startingAt: length ifAbsent: [])) 			withBlanksTrimmed asNumber + idx + 3.		[ request size < length ] whileTrue: [ request := request, connection getData ].		query := (request copyFrom: idx + 3 to: request size) withBlanksTrimmed ]	ifFalse: [		((idx := header indexOf: $?) between: 1 and: (header indexOf: (Character cr))) ifTrue: [			query := header copyFrom: idx + 1 to: header size.			header := header copyFrom: 1 to: idx - 1 ]].	"Transcript show: request."	^{ header. query }! !!PWS methodsFor: 'Processing' stamp: 'mjg 10/24/97 17:27'!decodeFields: aString  "Convert the form fields in aString to a query dictionary."  | query dict i key value |  query := aString findTokens: '&'.  dict := Dictionary new.  query do: [ :tag |    i := tag indexOf: $=.    key := tag copyFrom: 1 to: i - 1.    value := i < tag size ifTrue: [ self unEscape: (tag copyFrom: i + 1 to: tag size) ] ifFalse: [ nil ].    (dict includesKey: key)     ifFalse: [ dict at: key put: value ]     ifTrue: [      ((dict at: key) isKindOf: String) 		ifTrue: [ dict at: key put: (OrderedCollection with: (dict at: key)) ].      (dict at: key) add: value     ]  ].  ^dict! !!PWS methodsFor: 'Processing' stamp: 'mjg 11/26/97 10:22'!getReply  "Generate the reply."	| key |	Transcript show: ('Now serving:' , url printString, ' from ', peerName) ; cr.	[key := message at: 1] ifError: [:r :c | key := nil].	(ActionTable includesKey: key)	ifTrue: ["Transcript show: 'Serving from action ', key ; cr."		(ActionTable at: key) process: self]	ifFalse: ["Transcript show: 'Serving from action Default' ; cr."		(ActionTable at: 'Default') process: self].! !!PWS methodsFor: 'Processing' stamp: 'mjg 11/17/97 12:40'!report: msg for: rec	"Write an error report."	"msg = 'noAuth' ifTrue: [ ^self ]."	self log: '*** ', rec asString, ': ', msg.	[ self reply: ((msg indexOfSubCollection: 'HTTP' startingAt: 1) = 1		ifTrue: [ msg ] 		ifFalse: [ 'HTTP/1.0 400 Bad Request', self class crlfcrlf, msg ])]	 ifError: [ :m :r | ]! !!PWS methodsFor: 'Processing' stamp: 'mjg 10/24/97 17:29'!unEscape: aString  "Convert escape sequences to their proper characters."	| rs ws c |	rs := ReadStream on: aString.	ws := WriteStream on: ''.	[ rs atEnd ] whileFalse: [		c := rs next.		ws nextPut: 			(c = $+ ifTrue: [ $  ] ifFalse: [				c = $% 					ifTrue: [ (Number readFrom: (rs next: 2) asUppercase base: 16) asCharacter ]					ifFalse: [ c ]				]).		].	^ws contents copyWithout: Character cr! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 11/10/97 09:22'!content: type	"Can also return image types"	^'Content-Type: ', type, self crlfcrlf! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 10/25/97 12:18'!contentHTML	^self content: 'text/html'! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 10/25/97 12:16'!crlf	^String with: Character cr with: Character linefeed! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 10/25/97 12:16'!crlfcrlf	^self crlf , self crlf.! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 11/17/97 13:01'!notFound	^'HTTP/1.0 404 FILE NOT FOUND',self crlf,'<title>File Not Found</title><h2>File Not Found</h2>'! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 10/25/97 12:26'!redirectTo: URL	^'HTTP/1.0 302 FOUND', self crlf, 'Location: ',URL, self crlf,'URI: ',URL,	self crlfcrlf! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 10/25/97 12:17'!success	^'HTTP/1.0 200 OK',self crlf! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 12/4/97 12:05'!unauthorizedFor: realm	^'HTTP/1.0 401 Unauthorized', self crlf, 'WWW-Authenticate: Basic realm="Squeak/',realm,'"',	self crlfcrlf, '<html><title>Unauthorized</title><body><h2>Unauthorized for ',realm, '</h2></body>'! !!PWS class methodsFor: 'Backups' stamp: 'mjg 11/10/97 09:21'!addToBackupJob: block	"Stores blocks to be executed hourly at snapshot time."	BackupJobs add: block.! !!PWS class methodsFor: 'ServerActions' stamp: 'mjg 11/6/97 16:58'!actions	^ActionTable! !!PWS class methodsFor: 'ServerActions' stamp: 'mjg 10/25/97 14:39'!link: key to: action	ActionTable at: key put: action.! !!PWS class methodsFor: 'Initializing' stamp: 'mjg 11/10/97 10:22'!initialize	BackupJobs := OrderedCollection new.	self addToBackupJob: [Smalltalk garbageCollect].	ActionTable := Dictionary new.! !!PWS class methodsFor: 'Initializing' stamp: 'mjg 12/2/97 16:43'!initializeAll	| anAuthorizer |	anAuthorizer _ Authorizer new.	anAuthorizer realm: 'AuthorizedSpace'.	anAuthorizer mapName: 'owner' password: 'squeak' to: 'owner'.	self link: 'authorized' to: (AuthorizedServerAction new authorizer: anAuthorizer).	self link: 'chat' to: ChatPage new.	self link: 'Default' to: ServerAction new.	self link: 'embedded' to: EmbeddedServerAction new.	Comment setUpExample.	self link: 'comment' to: (SinglePlugServerAction new 			processBlock: [:request | Comment process: request]).	self link: 'Comment' to: (SinglePlugServerAction new 			processBlock: [:request | Comment process: request]).! !!PWS class methodsFor: 'Serving' stamp: 'mjg 10/25/97 14:17'!doBackupJobs	"This is just a wrapper so we don't have to restart the server loop when we add/remove jobs."	BackupJobs do: [:block | [block value]		ifError: [ :msg :rec | ^'*** ', rec asString, ': ', msg asString ].].	^'Backup completed'! !!PWS class methodsFor: 'Serving' stamp: 'mjg 12/2/97 15:11'!loopOnPort: portNumber loggingTo: fileName	"This is the inner HTTP server loop. Periodically flush the logfile. Invoke nightly jobs."	| port connection log clock |	Socket initializeNetwork: 0.	log := FileStream fileNamed: fileName. log position: log size.	(port := ServerSocket new) bindTo: portNumber backlog: 5.	clock := Time now hours.	ServerStatus := #running.	[	(connection := port listen) notNil		ifTrue: [ log nextPutAll: (self serve: connection); cr ]		ifFalse: [			clock ~= Time now hours ifTrue: [				log nextPutAll: (self doBackupJobs); cr.				clock := Time now hours.				ServerStatus := #snapshot ].			"log flush. log position: log size."].		ServerStatus = #running ] whileTrue.	port destroy.	log close! !!PWS class methodsFor: 'Serving' stamp: 'mjg 10/25/97 14:13'!serve: aSocket	"Create an instance and initialize it from aSocket."	| inst |	inst := self new.	([ inst initializeFrom: aSocket; getReply ] ifError: [ :msg :rec | inst report: msg for: rec ])	 ~~ #inBackground ifTrue: [ aSocket closeAndDestroy ].	^inst log contents! !!PWS class methodsFor: 'Serving' stamp: 'mjg 10/25/97 14:14'!serveOnPort: portNumber loggingTo: fileName	"This is the outer HTTP server loop."	[	self loopOnPort: portNumber loggingTo: fileName.		ServerStatus = #snapshot ifTrue: [			Smalltalk snapshot: true andQuit: false.].		ServerStatus ~= #quit ] whileTrue! !!PWS class methodsFor: 'Serving' stamp: 'mjg 10/25/97 14:46'!status	^ServerStatus! !!PWS class methodsFor: 'Serving' stamp: 'mjg 10/25/97 14:17'!stopServer	"Stop the server."	ServerStatus := #quit! !!Quadrangle methodsFor: 'initialize-release'!initialize	"Initialize the region to a null Rectangle, the borderWidth to 1, the 	borderColor to black, and the insideColor to white."	origin _ 0 @ 0.	corner _ 0 @ 0.	borderWidth _ 1.	borderColor _ Color black.	insideColor _ Color white.! !!Quadrangle methodsFor: 'displaying-generic'!displayOn: aDisplayMedium transformation: aWindowingTransformation clippingBox: aRectangle	"Display the border and region of the receiver so that it is scaled and 	translated with respect to aWindowingTransformation. The displayed 	information should be clipped so that only information with the area 	determined by aRectangle is displayed."	| screenRectangle |	screenRectangle _ 		(aWindowingTransformation applyTo: self) intersect: aRectangle.	borderWidth ~~ 0 & (insideColor ~~ nil)		ifTrue: 			[aDisplayMedium fill: screenRectangle fillColor: Color black "borderColor".			aDisplayMedium				fill: (screenRectangle insetBy: borderWidth)				fillColor: insideColor]! !!Quadrangle methodsFor: 'private'!setRegion: aRectangle borderWidth: anInteger borderColor: aMask1 insideColor: aMask2	origin _ aRectangle origin.	corner _ aRectangle corner.	borderWidth _ anInteger.	borderColor _ aMask1.	insideColor _ aMask2! !!Quadrangle class methodsFor: 'instance creation'!region: aRectangle borderWidth: anInteger borderColor: aMask1 insideColor: aMask2	"Answer an instance of me with rectangle, border width and color, and 	inside color determined by the arguments."	^super new		setRegion: aRectangle		borderWidth: anInteger		borderColor: aMask1		insideColor: aMask2! !QuickPrint comment:'This class supports fast, single-line string display. It is significantly faster than using a Paragraph for the same purpose.'!!QuickPrint methodsFor: 'displaying' stamp: 'di 10/29/97 20:52'!drawString: aString at: aPoint	"Draw the given string."	destX _ aPoint x asInteger.	destY _ aPoint y asInteger.	self scanCharactersFrom: 1 to: aString size in: aString		rightX: clipX + clipWidth + font maxWidth		stopConditions: stopConditions		displaying: true! !!QuickPrint methodsFor: 'displaying'!lineHeight	"Answer the height of the font used by QuickPrint."	^ font height! !!QuickPrint methodsFor: 'displaying' stamp: 'di 10/29/97 20:52'!stringWidth: aString	"Answer the width of the given string."	destX _ 0.	destY _ 0.	self scanCharactersFrom: 1 to: aString size in: aString		rightX: 99999	"virtual infinity"		stopConditions: stopConditions		displaying: false.	^ destX"	(1 to: 10) collect: [:i | QuickPrint new stringWidth: (String new: i withAll: $A)]"! !!QuickPrint methodsFor: 'private' stamp: 'di 10/29/97 12:21'!newOn: aForm box: aRectangle font: aStrikeFont color: textColor	"Initialize myself."	font _ aStrikeFont ifNil: [TextStyle default fontAt: 1].	self setFont.	destForm _ aForm.	self colorMap: (Bitmap with: 0      "Assumes 1-bit deep fonts"						with: ((textColor bitPatternForDepth: destForm depth) at: 1)).	combinationRule _ Form paint.	self clipRect: aRectangle.	sourceY _ 0.	kern _ 0.	"sourceX is set when selecting the character from the font strike bitmap"! !!QuickPrint methodsFor: 'private'!setFont	"Install various parameters from the font."	spaceWidth _ font widthOf: Space. 	sourceForm _ font glyphs.  "Should only be needed in DisplayScanner"	height _ font height.			" ditto "	xTable _ font xTable.	stopConditions _ font stopConditions.	stopConditions at: Space asciiValue + 1 put: nil.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX! !!QuickPrint class methodsFor: 'instance creation'!new	"Create an instance to print on the display in the default font."	^ super new newOn: Display box: Display boundingBox font: self defaultFont color: Color black! !!QuickPrint class methodsFor: 'instance creation'!newOn: aForm box: aRectangle	"Create an instance to print on the given form in the given rectangle."	^(super new) newOn: aForm box: aRectangle font: self defaultFont color: Color black! !!QuickPrint class methodsFor: 'instance creation'!newOn: aForm box: aRectangle font: aStrikeFont	"Create an instance to print on the given form in the given rectangle."	^(super new) newOn: aForm box: aRectangle font: aStrikeFont color: Color black! !!QuickPrint class methodsFor: 'instance creation'!newOn: aForm box: aRectangle font: aStrikeFont color: textColor	"Create an instance to print on the given form in the given rectangle."	^ (super new) newOn: aForm box: aRectangle font: aStrikeFont color: textColor! !!QuickPrint class methodsFor: 'queries'!defaultFont	^ (TextStyle default) fontArray at: 1! !!QuickPrint class methodsFor: 'example'!example	"This will quickly print all the numbers from 1 to 100 on the display,	and then answer the default width and height of the string 'hello world'."	"QuickPrint example"	| scanner |	scanner _ QuickPrint new.	0 to: 99 do: [: i | scanner drawString: i printString at: (i//10*20) @ (i\\10*12) ].	^ (scanner stringWidth: 'hello world') @ (scanner lineHeight)! !Random comment:'This Random Number Generator graciously contributed by David N. Smith.  It is an adaptation of the Park-Miller RNG which uses Floats to avoid the need for LargeInteger arithmetic.'!!Random methodsFor: 'all'!initialize	" Set a reasonable Park-Miller starting seed "	seed := Time millisecondClockValue.	a := 16r000041A7 asFloat.    " magic constant =      16807 "	m := 16r7FFFFFFF asFloat.    " magic constant = 2147483647 "	q := (m quo: a) asFloat.	r  := (m \\ a) asFloat.! !!Random methodsFor: 'all'!next	" This method generates random instances of Float in the interval 0to 1. "	seed := self nextValue.	^ seed / m! !!Random methodsFor: 'all'!nextValue	" This method generates random instances of Integer	in the interval 0 to 16r7FFFFFFF.	This method does NOT update the seed; repeated sends answer thesame value.	The algorithm is described in detail in 'Random Number Generators:	Good Ones Are Hard to Find' by Stephen K. Park and Keith W. Miller	(Comm. Asso. Comp. Mach., 31(10):1192--1201, 1988). "	| lo hi aLoRHi answer |	hi := (seed quo: q) asFloat.	lo := seed - (hi*q).     " = seed rem: q"  	aLoRHi := (a * lo) - (r * hi).	answer := (aLoRHi > 0.0)		ifTrue:  [ aLoRHi ]		ifFalse: [ aLoRHi + m ].	^ answer! !!Random methodsFor: 'all'!seed: anInteger	 seed := anInteger! !!Random class methodsFor: 'examples'!example	"If you just want a quick random integer, use:		10 atRandom	Every integer interval can give a random number:		(6 to: 12) atRandom	Most Collections can give randomly selected elements:		'pick one of these letters randomly' atRandom	Collections also respond to shuffled, as in:		($A to: $Z) shuffled	The correct way to use class Random is to store one in 	an instance or class variable:		myGenerator _ Random new.	Then use it every time you need another number between 0.0 and 1.0		myGenerator next"! !!Random class methodsFor: 'testing'!bucketTest: randy	"Execute this:   Random bucketTest: Random new"	" A quick-and-dirty bucket test. Prints nbuckets values on theTranscript.	  Each should be 'near' the value of ntries. Any run with any value'far' from ntries	  indicates something is very wrong. Each run generates differentvalues.	  For a slightly better test, try values of nbuckets of 200-1000 ormore; go get coffee.	  This is a poor test; see Knuth.   Some 'OK' runs:		1000 1023 998 969 997 1018 1030 1019 1054 985 1003		1011 987 982 980 982 974 968 1044 976		1029 1011 1025 1016 997 1019 991 954 968 999 991		978 1035 995 988 1038 1009 988 993 976"	| nbuckets buckets ntrys slot |	nbuckets := 20.	buckets := Array new: nbuckets.	buckets atAllPut: 0.	ntrys :=  100.	ntrys*nbuckets timesRepeat: [		slot := (randy next * nbuckets) floor + 1.		buckets at: slot put: (buckets at: slot) + 1 ].	Transcript cr.	1 to: nbuckets do: [ :nb |		Transcript show: (buckets at: nb) printString, ' ' ]! !!Random class methodsFor: 'testing'!theItsCompletelyBrokenTest	"Random theItsCompletelyBrokenTest"	"The above should print as...	(0.149243269650845 0.331633021743797 0.75619644800024 0.393701540023881 0.941783181364547 0.549929193942775 0.659962596213428 0.991354559078512 0.696074432551896 0.922987899707159 )	If they are not these values (accounting for precision of printing) then something is horribly wrong: DO NOT USE THIS CODE FOR ANYTHING. "	| rng |	rng := Random new.	rng seed: 2345678901.	^ (1 to: 10) collect: [:i | rng next]! !!Random class methodsFor: 'instance creation'!new	^ super new		initialize! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 1/13/98 16:57'!fileIn	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation."	| val |	'Reading ' , self name		displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:		[:bar |		[self atEnd]			whileFalse: 				[bar value: self position.				self skipSeparators.				val _ (self peekFor: $!!)							ifTrue: [(Compiler evaluate: self nextChunk logged: false)									scanFrom: self]							ifFalse: [Compiler evaluate: self nextChunk logged: true].				self skipStyleChunk].		self close].	^ val! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 7/17/97 16:12'!fileInObjectAndCode	"This file may contain:1) a fileIn of code  2) just an object in SmartReferenceStream format 3) both code and an object.	File it in and return the object.  Note that self must be a FileStream or RWBinaryOrTextStream.  Maybe ReadWriteStream incorporate RWBinaryOrTextStream?"	| refStream object |	self text.	self peek asciiValue = 4		ifTrue: [  "pure object file"			refStream _ SmartRefStream on: self.			object _ refStream nextAndClose]		ifFalse: [  "objects mixed with a fileIn"			self fileIn.  "reads code and objects, then closes the file"			object _ SmartRefStream scannedObject].	"set by side effect of one of the chunks"	SmartRefStream scannedObject: nil.  "clear scannedObject"	^ object! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 1/13/98 22:09'!fileOutClass: modelClass andObject: eToyHolder	"Write a file that has both code and an object as bits.  tk 6/26/97 12:25"	| class refStream |	self setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	self header; timeStamp.	modelClass ifNotNil: [		class _ modelClass.	"The model class of this world"		class sharedPools size > 0 ifTrue:			[class shouldFileOutPools				ifTrue: [class fileOutSharedPoolsOn: self]].		class fileOutOn: self moveSource: false toFile: 0].	self trailer.	"Does nothing for normal files.  HTML streams will have trouble with object data"	"Append the object's raw data"	self cr; cr; nextPutAll: '!!SmartRefStream!!'.	self binary.		"redundant"	refStream _ SmartRefStream on: self.	refStream nextPut: eToyHolder.  "with its morphs"		"Terminator, $!!, is not doubled inside object data"	self ascii.	self nextPutAll: '!!'; cr; cr.	refStream close.		"also closes me"! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 7/14/97 22:57'!timeStamp	"Append the current time to the receiver as a String."	self nextChunkPut:	"double string quotes and !!s"		(String streamContents: [:s | Smalltalk timeStamp: s]) printString.	self cr! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 10/24/96'!assignCollapsePointFor: aSSView	"Offer up a location along the left edge of the screen for a collapsed SSView.	Make sure it doesn't overlap any other collapsed frames.	"	| grid extent allOthers y putativeFrame free |	grid _ 24.  "should be mult of 8, since manual move is gridded by 8"	extent _ aSSView labelDisplayBox extent.	allOthers _ ScheduledControllers scheduledWindowControllers				collect: [:aController | aController view collapsedFrame]				thenSelect: [:rect | rect notNil].	y _ 0.	[(y _ y + grid) < (Display height - extent y)]		whileTrue:		[putativeFrame _ 0@y extent: extent.		free _ true.		allOthers do: [:w | free _ free & (w intersects: putativeFrame) not].		free ifTrue: [^ putativeFrame topLeft]].	"If all else fails..."	^ 0 @ 0! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'sw 5/22/96'!standardPositions	"Return a list of standard window positions -- this may have one, two, or four of them, depending on the size and shape of the display screen.  "	| anArea aList  midX midY |	anArea _ Display usableArea.	midX _ ScrollBarSetback +   ((anArea width - ScrollBarSetback)  // 2).	midY _ ScreenTopSetback + ((anArea height - ScreenTopSetback) // 2).	aList _ OrderedCollection with: (ScrollBarSetback @ ScreenTopSetback).	self windowColumnsDesired > 1		ifTrue:			[aList add: (midX @ ScreenTopSetback)].	self windowRowsDesired > 1		ifTrue:			[aList add: (ScrollBarSetback @ (midY+ScreenTopSetback)).			self windowColumnsDesired > 1 ifTrue:				[aList add: (midX @ (midY+ScreenTopSetback))]].	^ aList! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'sw 5/23/96'!standardWindowExtent	"Answer the standard default extent for new windows.  "	| effectiveExtent width strips height grid allowedArea maxLevel |	effectiveExtent _ Display usableArea extent - (ScrollBarSetback @ ScreenTopSetback).	Preferences reverseWindowStagger ifTrue:		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"		allowedArea _ ScrollBarSetback @ ScreenTopSetback						corner: Display usableArea bottomRight.		"Number to be staggered at each corner (less on small screens)"		maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].		"Amount by which to stagger (less on small screens)"		grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: 600@400].	width _ (strips _ self windowColumnsDesired) > 1		ifTrue:			[effectiveExtent x // strips]		ifFalse:			[(3 * effectiveExtent x) // 4].	height _ (strips _ self windowRowsDesired) > 1		ifTrue:			[effectiveExtent y // strips]		ifFalse:			[(3 * effectiveExtent y) //4].	^ width @ height"RealEstateAgent standardWindowExtent"! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'sw 8/12/97 01:34'!strictlyStaggeredInitialFrameFor: aStandardSystemView	"This method implements a staggered window placement policy that I like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible.	"	| allowedArea grid initialFrame allWindows cornerSel corner delta putativeCorner free maxLevel |	allowedArea _ ScrollBarSetback @ ScreenTopSetback					corner: Display usableArea bottomRight.	"Number to be staggered at each corner (less on small screens)"	maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame _ 0@0 extent: ((aStandardSystemView initialExtent							"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400")).	allWindows _ ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.			corner _ allowedArea perform: cornerSel.			"The extra grid//2 in delta helps to keep title tabs distinct"			delta _ (maxLevel-level*grid+(grid//2)) @ (level*grid).			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner _ corner + delta.			free _ true.			allWindows do:				[:w |				free _ free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 squishedWithin: allowedArea]]].	"If all else fails..."	^ (ScrollBarSetback @ ScreenTopSetback extent: initialFrame extent)		squishedWithin: allowedArea! !!RecentMessageSet methodsFor: 'as yet unclassified'!accept	^ super accept! !!RecentMessageSet methodsFor: 'as yet unclassified'!contents: c notifying: n	| result |	result _ super contents: c notifying: n.	result == true ifTrue:		[self initializeMessageList: Utilities recentlySubmittedMessages.		self changed: #messageListChanged].	^ result! !!RecentMessageSet methodsFor: 'as yet unclassified'!maybeSetSelection	"After a browser's message list is changed, this message is dispatched to the model, to give it a chance to refigure a selection"		self messageListIndex: 1! !!RecordingControlsMorph methodsFor: 'initialization' stamp: 'sw 10/18/97 18:32'!addButtonRows	"Spun off to allow subclasses to customize the buttons but still benefit from super intialize"	| r |	r _ LayoutMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Tile' action: #makeTile).	r addMorphBack: (self buttonName: 'Done' action: #done).	r addMorphBack: (self buttonName: 'Trim' action: #trim).	r addMorphBack: (self buttonName: 'Show' action: #show).	self addMorphBack: r.	r _ LayoutMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Record' action: #record).	r addMorphBack: (self buttonName: 'Stop' action: #stop).	r addMorphBack: (self buttonName: 'Play' action: #playback).	r addMorphBack: self makeStatusLight..	self addMorphBack: r! !!RecordingControlsMorph methodsFor: 'initialization' stamp: 'sw 10/18/97 18:32'!initialize	| r |	super initialize.	borderWidth _ 2.	orientation _ #vertical.	recorder _ SoundRecorder new.	self addButtonRows.	r _ LayoutMorph newRow vResizing: #shrinkWrap.	r addMorphBack: self makeRecordMeter.	self addMorphBack: r.! !!RecordingControlsMorph methodsFor: 'accessing' stamp: 'jm 9/13/97 17:20'!recorder	^ recorder! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jhm 10/15/97 15:28'!done	recorder stopRecording.	self makeTile.	self delete.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'di 1/13/98 22:28'!makeTile	| tile |	recorder pause.	tile _ InterimSoundMorph new sound: 		(SampledSound			samples: recorder condensedSamples			samplingRate: recorder samplingRate).	self world hands first attachMorph: tile.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jm 10/18/97 11:41'!playback	recorder pause.	recorder playback.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jhm 10/15/97 14:30'!record	recorder clearRecordedSound.	recorder resumeRecording.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jm 10/18/97 11:50'!show	"Show my samples in a GraphMorph."	| g m |	recorder pause.	g _ GraphMorph new extent: 500@150; data: recorder condensedSamples.	m _ StringMorph new contents: 'Index:'.	g addMorph: (m position: 5@5).	m _ UpdatingStringMorph new		target: g; getSelector: #cursor; putSelector: #cursor:; step.	g addMorph: (m position: 45@5).	m _ StringMorph new contents: 'Value:'.	g addMorph: (m position: 5@20).	m _ UpdatingStringMorph new		target: g; getSelector: #valueAtCursor; putSelector: #valueAtCursor:; step.	g addMorph: (m position: 45@20).	self world hands first attachMorph: g.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jhm 10/15/97 14:30'!stop	recorder pause.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jm 11/17/97 18:58'!trim	"Show my samples in a GraphMorph."	recorder pause.	recorder trim: 1400 normalizedVolume: 80.0.! !!RecordingControlsMorph methodsFor: 'stepping' stamp: 'jm 10/17/97 15:19'!startStepping	"Make the level meter active when dropped into the world. Do nothing if already recording. Note that this will cause other recorders to stop recording..."	super startStepping.	recorder isPaused ifTrue: [		SoundRecorder allInstances do: [:r | r stopRecording].  "stop all other sound recorders"		recorder pause].  "meter is updated while paused"! !!RecordingControlsMorph methodsFor: 'stepping' stamp: 'jm 10/17/97 15:00'!step	recorder isPaused		ifTrue: [recordingStatusLight color: Color transparent]		ifFalse: [recordingStatusLight color: Color red].	recordMeter extent: (recorder meterLevel + 1) @ recordMeter height.! !!RecordingControlsMorph methodsFor: 'stepping' stamp: 'jm 8/24/97 21:00'!stepTime	^ 50! !!RecordingControlsMorph methodsFor: 'stepping' stamp: 'jm 10/17/97 15:13'!stopStepping	"Turn off recording."	super stopStepping.	recorder stopRecording.! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jhm 10/15/97 14:30'!buttonName: aString action: aSymbol	^ SimpleButtonMorph new		target: self;		label: aString;		actionSelector: aSymbol! !!RecordingControlsMorph methodsFor: 'other' stamp: 'sw 9/19/97 17:15'!droppableOnPlayfield	^ false! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jm 8/24/97 21:31'!makeRecordMeter	| outerBox |	outerBox _ Morph new extent: 102@18; color: Color gray.	recordMeter _ Morph new extent: 1@16; color: Color yellow.	recordMeter position: outerBox topLeft + (1@1).	outerBox addMorph: recordMeter.	^ outerBox! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jhm 10/15/97 15:06'!makeStatusLight	recordingStatusLight _ Morph new extent: 18@18.	recordingStatusLight color: Color transparent.	^ recordingStatusLight! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jm 10/17/97 15:17'!updateReferencesUsing: aDictionary	"Copy my recorder."	super updateReferencesUsing: aDictionary.	recorder _ SoundRecorder new.! !!Rectangle methodsFor: 'accessing'!corners	"Return an array of corner points in the order of a quadrilateral spec for WarpBlt."	^ Array		with: self topLeft		with: self bottomLeft		with: self bottomRight		with: self topRight! !!Rectangle methodsFor: 'accessing'!innerCorners	"Return an array of inner corner points,	ie, the most extreme pixels included,	in the order of a quadrilateral spec for WarpBlt"	| r1 |	r1 _ self topLeft corner: self bottomRight - (1@1).	^ Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRight! !!Rectangle methodsFor: 'rectangle functions'!areasOutside: aRectangle	"Answer an Array of Rectangles comprising the parts of the receiver not 	intersecting aRectangle."	| areas yOrigin yCorner |	"Make sure the intersection is non-empty"	(origin <= aRectangle corner and: [aRectangle origin <= corner])		ifFalse: [^Array with: self].	areas _ OrderedCollection new.	aRectangle origin y > origin y		ifTrue: [areas addLast: (origin corner: corner x @ (yOrigin _ aRectangle origin y))]		ifFalse: [yOrigin _ origin y].	aRectangle corner y < corner y		ifTrue: [areas addLast: (origin x @ (yCorner _ aRectangle corner y) corner: corner)]		ifFalse: [yCorner _ corner y].	aRectangle origin x > origin x 		ifTrue: [areas addLast: (origin x @ yOrigin corner: aRectangle origin x @ yCorner)].	aRectangle corner x < corner x 		ifTrue: [areas addLast: (aRectangle corner x @ yOrigin corner: corner x @ yCorner)].	^areas! !!Rectangle methodsFor: 'rectangle functions'!bordersOn: her along: herSide 	(herSide = #right and: [self left = her right])	| (herSide = #left and: [self right = her left])		ifTrue:		[^ (self top max: her top) <= (self bottom min: her bottom)].	(herSide = #bottom and: [self top = her bottom])	| (herSide = #top and: [self bottom = her top])		ifTrue:		[^ (self left max: her left) <= (self right min: her right)].	^ false! !!Rectangle methodsFor: 'rectangle functions'!merge: aRectangle 	"Answer a Rectangle that contains both the receiver and aRectangle."	^Rectangle 		origin: (origin min: aRectangle origin)		corner: (corner max: aRectangle corner)! !!Rectangle methodsFor: 'rectangle functions'!quickMerge: aRectangle 	"Answer the receiver if it encloses the given rectangle or the merge of the two rectangles if it doesn't. THis method is an optimization to reduce extra rectangle creations."	| useRcvr rOrigin rCorner minX maxX minY maxY |	useRcvr _ true.	rOrigin _ aRectangle topLeft.	rCorner _ aRectangle bottomRight.	minX _ rOrigin x < origin x ifTrue: [useRcvr _ false. rOrigin x] ifFalse: [origin x].	maxX _ rCorner x > corner x ifTrue: [useRcvr _ false. rCorner x] ifFalse: [corner x].	minY _ rOrigin y < origin y ifTrue: [useRcvr _ false. rOrigin y] ifFalse: [origin y].	maxY _ rCorner y > corner y ifTrue: [useRcvr _ false. rCorner y] ifFalse: [corner y].	useRcvr		ifTrue: [^ self]		ifFalse: [^ Rectangle origin: minX@minY corner: maxX@maxY].! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/20/97 23:01'!rectanglesAt: y height: ht	(y+ht) > self bottom ifTrue: [^ Array new].	^ Array with: (origin x @ y corner: corner x @ (y+ht))! !!Rectangle methodsFor: 'rectangle functions'!withBottom: y 	"Return a copy of me with a different bottom y"	^ origin x @ origin y corner: corner x @ y! !!Rectangle methodsFor: 'rectangle functions'!withHeight: height 	"Return a copy of me with a different height"	^ origin corner: corner x @ (origin y + height)! !!Rectangle methodsFor: 'rectangle functions'!withLeft: x 	"Return a copy of me with a different left x"	^ x @ origin y corner: corner x @ corner y! !!Rectangle methodsFor: 'rectangle functions'!withRight: x 	"Return a copy of me with a different right x"	^ origin x @ origin y corner: x @ corner y! !!Rectangle methodsFor: 'rectangle functions'!withSide: side setTo: value  "return a copy with side set to value"	^ self perform: (#(withLeft: withRight: withTop: withBottom: )							at: (#(left right top bottom) indexOf: side))		with: value! !!Rectangle methodsFor: 'rectangle functions'!withTop: y 	"Return a copy of me with a different top y"	^ origin x @ y corner: corner x @ corner y! !!Rectangle methodsFor: 'rectangle functions'!withWidth: width 	"Return a copy of me with a different width"	^ origin corner: (origin x + width) @ corner y! !!Rectangle methodsFor: 'testing'!containsRect: aRect	"Answer whether aRect is within the receiver (OK to coincide)."	^ aRect origin >= origin and: [aRect corner <= corner]! !!Rectangle methodsFor: 'testing'!isTall	^ self height > self width! !!Rectangle methodsFor: 'testing'!isWide	^ self width > self height! !!Rectangle methodsFor: 'truncation and round off' stamp: 'jm 8/2/97 13:54'!truncated	"Answer a Rectangle whose origin and corner have any fractional parts removed."	(origin x isInteger and:	[origin y isInteger and:	[corner x isInteger and:	[corner y isInteger]]])		ifTrue: [^ self].	^ Rectangle origin: origin truncated corner: corner truncated! !!Rectangle methodsFor: 'transforming' stamp: 'di 6/11/97 16:24'!flipBy: direction centerAt: aPoint 	"Return a copy flipped #vertical or #horizontal, about aPoint."	^ (origin flipBy: direction centerAt: aPoint)		rect: (corner flipBy: direction centerAt: aPoint)! !!Rectangle methodsFor: 'transforming' stamp: 'di 6/11/97 15:11'!rotateBy: direction centerAt: aPoint	"Return a copy rotated #right, #left, or #pi about aPoint"	^ (origin rotateBy: direction centerAt: aPoint)		rect: (corner rotateBy: direction centerAt: aPoint)! !!Rectangle methodsFor: 'transforming'!scaleFrom: rect1 to: rect2	"Produce a rectangle stretched according to the stretch from rect1 to rect2"	^ (origin scaleFrom: rect1 to: rect2)		corner: (corner scaleFrom: rect1 to: rect2)! !!Rectangle methodsFor: 'transforming' stamp: 'sw 5/21/96'!squishedWithin: aRectangle	"Return an adjustment of the receiver that fits within aRectangle by reducing its size, not by changing its origin.  "	^ origin corner: (corner min: aRectangle bottomRight)"(50 @ 50 corner: 160 @ 100) squishedWithin:  (20 @ 10 corner: 90 @ 85)"! !!Rectangle methodsFor: 'printing' stamp: 'sw 12/9/96'!display: c 	"Display the receiver filling it with the given color; by Alan Kay.  Used by his mini painting system, 1/96.	: fixed so it doesn't always draw a square!!"	| p |	p _ Pen new.	p color: c.	p place: self origin.	1 to: 2 do:		[:i | p turn: 90; go: self width.		p turn: 90; go: self height]! !!Rectangle methodsFor: 'private'!setOrigin: topLeft corner: bottomRight	origin _ topLeft.	corner _ bottomRight! !!Rectangle class methodsFor: 'instance creation' stamp: 'tk 3/9/97'!center: centerPoint extent: extentPoint 	"Answer an instance of me whose center is centerPoint and width 	by height is extentPoint.  "	^self origin: centerPoint - (extentPoint//2) extent: extentPoint! !!Rectangle class methodsFor: 'instance creation' stamp: 'di 12/1/97 10:42'!encompassing: listOfPoints	"A number of callers of encompass: should use this method."	| topLeft bottomRight |	topLeft _ bottomRight _ nil.	listOfPoints do:		[:p | topLeft == nil			ifTrue: [topLeft _ bottomRight _ p]			ifFalse: [topLeft _ topLeft min: p.					bottomRight _ bottomRight max: p]].	^ topLeft corner: bottomRight! !!Rectangle class methodsFor: 'instance creation'!left: leftNumber right: rightNumber top: topNumber bottom: bottomNumber 	"Answer an instance of me whose left, right, top, and bottom coordinates 	are determined by the arguments."	^ self new setOrigin: leftNumber @ topNumber corner: rightNumber @ bottomNumber! !!Rectangle class methodsFor: 'instance creation' stamp: 'di 12/1/97 10:36'!merging: listOfRects	"A number of callers of merge: should use this method."	| topLeft bottomRight |	topLeft _ bottomRight _ nil.	listOfRects do:		[:r | topLeft == nil			ifTrue: [topLeft _ r topLeft.					bottomRight _ r bottomRight]			ifFalse: [topLeft _ topLeft min: r topLeft.					bottomRight _ bottomRight max: r bottomRight]].	^ topLeft corner: bottomRight! !!Rectangle class methodsFor: 'instance creation'!origin: originPoint corner: cornerPoint 	"Answer an instance of me whose corners (top left and bottom right) are 	determined by the arguments."	^self new setOrigin: originPoint corner: cornerPoint! !!Rectangle class methodsFor: 'instance creation'!origin: originPoint extent: extentPoint 	"Answer an instance of me whose top left corner is originPoint and width 	by height is extentPoint."	^self new setOrigin: originPoint corner: originPoint + extentPoint! !!RectangleMorph methodsFor: 'initialization' stamp: 'sw 8/4/97 12:05'!initialize	super initialize.	color _ Color gray! !ReferenceStream comment:'This is an interim save-to-disk facility. A ReferenceStream can storeone or more objects in a persistent form, including sharing andcycles. Cf. DataStream.Here is the way to use DataStream and ReferenceStream:	rr _ ReferenceStream fileNamed: ''test.obj''.	rr nextPut: <your object>.	rr close.To get it back:	rr _ ReferenceStream fileNamed: ''test.obj''.	<your object> _ rr next.	rr close.ReferenceStreams can now write "weak" references. nextPutWeak:writes a "weak" reference to an object, which refers to that object*if* it also gets written to the stream by a normal nextPut:.Public messages:	resetPublic inherited messages (see DataStream)	(class) on:	(class) fileNamed:	(class) fileTypeCode	atEnd	beginInstance:size: (for use by storeDataOn: methods)	beginReference: (for use by readDataFrom:size: methods)	close	next	next:	nextPut:	nextPutAll:	nextPutWeak:	setType:	shorten	sizeNOTE: A ReferenceStream should be treated as a read-stream *or* as awrite-stream, *not* as a read/write-stream. The reference-rememberingmechanism would probably do bad things if you tried to read and writefrom the same ReferenceStream.[TBD] Should we override "close" to do	self forgetReferences. super close?Instance variables references -- an IdentityDictionary mapping objects already written	to their byteStream positions. If asked to write any object a	second time, we just write a reference to its stream position.	This handles shared objects and reference cycles between objects.	To implement "weak references" (for Aliases), the references	dictionary also maps objects not (yet?) written to a Collection	of byteStream positions with hopeful weak-references to it. If	asked to definitely write one of these objects, we''ll fixup those	weak references. objects -- an IdentityDictionary mapping relative byte stream positions to	objects already read in. If asked to follow a reference, we	return the object already read.	This handles shared objects and reference cycles between objects. currentReference -- the current reference position. Positon relative to the 	start of object data in this file.  (Allows user to cut and paste smalltalk 	code from the front of the file without effecting the reference values.)  	This variable is used to help install each new object in "objects" as soon	as it''s created, **before** we start reading its contents, in	case any of its content objects reference it. fwdRefEnds -- A weak reference can be a forward reference, which	requires advance-reading the referrent. When we later come to the	object, we must get its value from "objects" and not re-read it so	refs to it don''t become refs to copies. fwdRefEnds remembers the	ending byte stream position of advance-read objects. transients -- an IdentitySet of byte stream positions corresponding	to objects that we''ve started to read in (and already added to	"objects" in case of reference cycles) but haven''t yet handed out	OOPs for. If we hand out an OOP to one of these interim OOPs, and	if internalizing it (comeFullyUpOnReload) returns a different OOP,	then we must ask it to #become: the new OOP. Tracking the interim	OOPs handed out lets us save most calls to (costly) #become:.-- 11/17/92 jhm'!!ReferenceStream methodsFor: 'all' stamp: 'jm 7/31/97 16:17'!beginInstance: aClass size: anInteger	"This is for use by storeDataOn: methods.  Cf. Object>>storeDataOn:."	"Addition of 1 seems to make extra work, since readInstance has to compensate.  Here for historical reasons dating back to Kent Beck's original implementation in late 1988.	In ReferenceStream, class is just 5 bytes for shared symbol.	SmartRefStream puts out the names and number of class's instances variables for checking.6/10/97 16:09 tk: See if we can put on a short header. Type = 16. "	| short ref |	short _ true.	"All tests for object header that can be written in 4 bytes"	anInteger <= 254 ifFalse: [short _ false].	"one byte size"	ref _ references at: aClass name ifAbsent: [short _ false. nil].	short & (ref isInteger) ifTrue: [short _ (ref < 65536) & (ref > 0)].	short ifTrue: [		byteStream skip: -1.		short _ byteStream next = 9.		byteStream skip: 0].	"ugly workaround"	short 		ifTrue: ["passed all the tests!!"			byteStream skip: -1; nextPut: 16; "type = short header"				nextPut: anInteger + 1;	"size is short"				nextNumber: 2 put: ref]		ifFalse: [			"default to normal longer object header"			byteStream nextNumber: 4 put: anInteger + 1.			self nextPut: aClass name].! !!ReferenceStream methodsFor: 'all' stamp: '6/9/97 08:25 tk'!beginReference: anObject	"Remember anObject as the object we read at the position recorded by	 noteCurrentReference:. This must be done after instantiating anObject but	 before reading any of its contents that might (directly or indirectly) refer to	 it. (It's ok to do this redundantly, which is convenient for #next.)	 Answer the reference position. -- jhm"	objects at: currentReference put: anObject.	"relative to start of data portion of file"	^ currentReference		"relative position"! !!ReferenceStream methodsFor: 'all' stamp: 'jm 12/3/97 19:43'!forgetReferences    "PRIVATE -- Reset my internal state.       11/15-17/92 jhm: Added transients and fwdRefEnds.       7/11/93 sw: Give substantial initial sizes to avoid huge time spent growing.       9/3/93 sw: monster version for Sasha"    references _ IdentityDictionary new: 4096*4.    objects _ IdentityDictionary new: 4096.    fwdRefEnds _ IdentityDictionary new.! !!ReferenceStream methodsFor: 'all' stamp: '6/9/97 08:26 tk'!getCurrentReference    "PRIVATE -- Return the currentReference posn.  Always a relative position.  So user can cut and paste the Smalltalk source code at the beginning of the file."    ^ currentReference	"relative position"! !!ReferenceStream methodsFor: 'all' stamp: 'tk 8/14/96'!internalize: externalObject	"PRIVATE -- We just read externalObject. Give it a chance to internalize. Return the internalized object.	 If become: is expensive, we could use it less often. It's needed when we've already given out references to the object being read (while recursively reading its contents).  In other cases, we could just change the entry in the objects Dictionary.	If an object is pointed at from inside itself, then it cannot have a different external and internal form.  It cannot be a PathFromHome or return anything other than self when sent comeFullyUpOnReload. (DiskProxy is OK)	Objects that do return something other than self when sent comeFullyUpOnReload must not point to themselves, even indirectly.    	Allowin the use of DiskProxy for shared sysem objects.  "	| internalObject |	internalObject _ externalObject comeFullyUpOnReload.	(self isAReferenceType: (self typeIDFor: internalObject))			ifTrue: [self beginReference: internalObject].			"save the final object and give it out next time.  Substitute for become"	^ internalObject"This code was removed.  I don't understand it.  	(externalObject ~~ internalObject and: [externalObject isKindOf: DiskProxy])		ifTrue: [externalObject become: internalObject]		ifFalse: [(self isAReferenceType:(self typeIDFor: internalObject))			ifTrue: [self beginReference: internalObject]]."! !!ReferenceStream methodsFor: 'all' stamp: '6/9/97 09:02 tk'!next	"Answer the next object in the stream. If this object was already read by a	 forward ref, don't re-read it. Cf. class comment. -- 11/18-24/92 jhm"	| curPosn skipToPosn |	"Did we already read the next object? If not, use ordinary super next."	skipToPosn _ fwdRefEnds removeKey: (curPosn _ byteStream position - basePos)							 ifAbsent: [nil].	skipToPosn ifNil: [^ super next].		"Compared to ifAbsent: [^ super next], this saves 2 stack frames per cycle		 in the normal case of this deep recursion. This is mainly a debugging aid		 but it also staves off stack overflow."	"Skip over the object and return the already-read-in value from 'object'."	byteStream position: skipToPosn + basePos.	"make absolute"	^ objects at: curPosn ifAbsent: [self errorInternalInconsistency]! !!ReferenceStream methodsFor: 'all' stamp: 'jhm 11/15/92'!nextPutWeak: anObject    "Write a weak reference to anObject to the receiver stream. Answer anObject.     If anObject is not a reference type of object, then just put it normally.     A 'weak' reference means: If anObject gets written this stream via nextPut:,     then its weak references will become normal references. Otherwise they'll     read back as nil. -- "    | typeID referencePosn |    "Is it a reference type of object? If not, just write it normally."    typeID _ self typeIDFor: anObject.    (self isAReferenceType: typeID) ifFalse: [^ self nextPut: anObject].    "Have we heard of and maybe even written anObject before?"    referencePosn _ references at: anObject ifAbsent: [			references at: anObject put: OrderedCollection new].    "If referencePosn is an Integer, it's the stream position of anObject.     Else it's a collection of hopeful weak-references to anObject."    referencePosn isInteger ifFalse:        [referencePosn add: byteStream position - basePos.		"relative"        referencePosn _ self vacantRef].    self outputReference: referencePosn.		"relative"    ^ anObject! !!ReferenceStream methodsFor: 'all' stamp: '6/9/97 09:00 tk'!noteCurrentReference: typeID	"PRIVATE -- If we support references for type typeID, remember	 the current byteStream position so beginReference: can add the	 next object to the 'objects' dictionary of reference positions,	 then return true. Else return false."	| answer |	(answer _ self isAReferenceType: typeID)		ifTrue: [self setCurrentReference: (byteStream position - 1) - basePos "relative"				"subtract 1 because we already read the object's type ID byte"].	^ answer! !!ReferenceStream methodsFor: 'all' stamp: ' 6/9/97'!objectAt: anInteger    "PRIVATE -- Read & return the object at a given stream position.     If we already read it, just get it from the objects dictionary.     (Reading it again wouldn't work with cycles or sharing.)     If not, go read it and put it in the objects dictionary.     NOTE: This resolves a cross-reference in the ReferenceStream:       1. A backward reference to an object already read (the normal case).       2. A forward reference which is a sated weak reference (we record where          the object ends so when we get to it normally we can fetch it from          'objects' and skip over it).       3. A backward reference to a 'non-reference type' per the long NOTE in          nextPut: (we compensate here--seek back to re-read it and add the object          to 'objects' to avoid seeking back to read it any more times).       4. While reading a foward weak reference (case 2), we may recursively hit an          ordinary backward reference to an object that we haven't yet read because          we temporarily skipped ahead. Such a reference is forward in time so we          treat it much like case 2.     11/16-24/92 jhm: Handle forward refs. Cf. class comment and above NOTE.	08:57 tk   anInteger is a relative position"    | savedPosn refPosn anObject |    ^ objects at: anInteger "relative position.  case 1: It's in 'objects'"        ifAbsent:   "do like super objectAt:, but remember the fwd-ref-end position"            [savedPosn _ byteStream position.		"absolute"            refPosn _ self getCurrentReference.	"relative position"            byteStream position: anInteger + basePos.	"was relative"            anObject _ self next.            (self isAReferenceType: (self typeIDFor: anObject))                ifTrue:  [fwdRefEnds at: anInteger put: byteStream position - basePos] "cases 2, 4"                ifFalse: [objects at: anInteger put: anObject]. "case 3"            self setCurrentReference: refPosn.		"relative position"            byteStream position: savedPosn.		"absolute"            anObject]! !!ReferenceStream methodsFor: 'all' stamp: '6/9/97 08:24 tk'!setCurrentReference: refPosn    "PRIVATE -- Set currentReference to refPosn.  Always a relative position."    currentReference _ refPosn		"relative position"! !!ReferenceStream methodsFor: 'all' stamp: ' 6/9/97'!tryToPutReference: anObject typeID: typeID	"PRIVATE -- If we support references for type typeID, and if	   anObject already appears in my output stream, then put a	   reference to the place where anObject already appears. If we	   support references for typeID but didn't already put anObject,	   then associate the current stream position with anObject in	   case one wants to nextPut: it again.	 Return true after putting a reference; false if the object still	   needs to be put.	 : Added support for weak refs. Split out outputReference:.	08:42 tk  references stores relative file positions."	| referencePosn nextPosn |	"Is it a reference type of object?"	(self isAReferenceType: typeID) ifFalse: [^ false].	"Have we heard of and maybe even written anObject before?"	referencePosn _ references at: anObject ifAbsent:			["Nope. Remember it and let the sender write it."			references at: anObject put: (byteStream position - basePos).	"relative"			^ false].	"If referencePosn is an Integer, it's the stream position of anObject."	referencePosn isInteger ifTrue:		[self outputReference: referencePosn.	"relative"		^ true].	"Else referencePosn is a collection of positions of weak-references to anObject.	 Make them full references since we're about to really write anObject."	references at: anObject put: (nextPosn _ byteStream position) - basePos.	"store relative"	referencePosn do: [:weakRefPosn |			byteStream position: weakRefPosn + basePos.		"make absolute"			self outputReference: nextPosn - basePos].	"make relative"	byteStream position: nextPosn.		"absolute"	^ false! !!ReferenceStream class methodsFor: 'all' stamp: 'sw 12/2/92'!versionCode    "Answer a number representing the 'version' of the ReferenceStream facility; this is stashed at the beginning of ReferenceStreams, as a secondary versioning mechanism (the primary one is the fileTypeCode).   At present, it serves for information only, and is not checked for compatibility at reload time, but could in future be used to branch to variant code. "	" 1 = original version 1992"	" 2 = HyperSqueak.  PathFromHome used for Objs outside the tree.  SqueakSupport SysLibrary for shared globals like Display and StrikeFonts.  File has version number, class structure, then an IncomingObjects manager.  8/16/96 tk.  	Extended to SmartRefStream.  class structure also keeps superclasse chain.  Does analysis on structure to see when translation methods are needed.  Embedable in file-ins.  (factored out HyperSqueak support)  Feb-May 97 tk"	" 3 = Reference objects are byte offsets relative to the start of the object portion of the file.  Rectangles with values -2048 to 2047 are encoded compactly."	^ 3! !!RemoteHandMorph methodsFor: 'initialization' stamp: 'jm 11/4/97 07:15'!initialize	super initialize.	remoteWorldExtent _ 100@100.  "initial guess"	socket _ nil.	waitingForConnection _ false.	receiveBuffer _ ''.! !!RemoteHandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:15'!connectRemoteUser	"This menu command does nothing when invoked by a RemoteHandMorph."! !!RemoteHandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:15'!disconnectAllRemoteUsers	"This menu command does nothing when invoked by a RemoteHandMorph."! !!RemoteHandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:15'!disconnectRemoteUser	"This menu command does nothing when invoked by a RemoteHandMorph."! !!RemoteHandMorph methodsFor: 'connections' stamp: 'jm 11/4/97 07:15'!remoteHostAddress	"Return the address of the remote host or zero if not connected."	(socket ~~ nil and: [socket isUnconnectedOrInvalid not])		ifTrue: [^ socket remoteAddress]		ifFalse: [^ 0].! !!RemoteHandMorph methodsFor: 'connections' stamp: 'jm 11/4/97 07:15'!startListening	"Create a socket and start listening for a connection."	self stopListening.	Transcript show: 'My address is ', NetNameResolver localAddressString; cr.	Transcript show: 'Remote hand ', userInitials, ' waiting for a connection...'; cr.	socket _ Socket new.	socket listenOn: 54323.	waitingForConnection _ true.! !!RemoteHandMorph methodsFor: 'connections'!stopListening	"Destroy the socket, if any, terminating the connection."	socket ifNotNil: [		socket destroy.		socket _ nil].! !!RemoteHandMorph methodsFor: 'other' stamp: 'jm 11/4/97 07:15'!drawOn: aCanvas	"For remote cursors, always draw the hand itself (i.e., the cursor)."	super drawOn: aCanvas.	aCanvas image: NormalCursor at: self position.! !!RemoteHandMorph methodsFor: 'other' stamp: 'jm 11/14/97 11:19'!processEvents	"Process user input events from the remote input devices."	| evt |	evt _ self getNextRemoteEvent.	[evt ~~ nil] whileTrue: [		evt type == #worldExtent ifTrue: [			remoteWorldExtent _ evt cursorPoint.			^ self].		(evt yellowButtonPressed and:		 [lastEvent yellowButtonPressed not]) ifTrue: [			lastEvent _ evt.			^ self invokeMetaMenu: evt].		(evt blueButtonPressed and:		 [lastEvent blueButtonPressed not]) ifTrue: [			lastEvent _ evt.			^ self specialGesture: evt].		self handleEvent: evt.		lastEvent _ evt.		evt _ self getNextRemoteEvent].! !!RemoteHandMorph methodsFor: 'other' stamp: 'jm 11/4/97 07:15'!withdrawFromWorld	"Close the socket, if any, and remove this hand from the world."	self stopListening.	Transcript show: 'Remote hand ', userInitials, ' closed'; cr.	owner ifNotNil: [owner removeHand: self].! !!RemoteHandMorph methodsFor: 'other' stamp: 'jm 11/4/97 07:15'!worldBounds	^ 0@0 extent: remoteWorldExtent! !!RemoteHandMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!appendNewDataToReceiveBuffer	"Append all available raw data to my receive buffer. Assume that my socket is not nil."	| newData tempBuf bytesRead |	socket dataAvailable ifTrue: [		"get all the data currently available"		newData _ WriteStream on: (String new: receiveBuffer size + 1000).		newData nextPutAll: receiveBuffer.		tempBuf _ String new: 1000.		[socket dataAvailable] whileTrue: [			bytesRead _ socket receiveDataInto: tempBuf.			1 to: bytesRead do: [:i | newData nextPut: (tempBuf at: i)]].		receiveBuffer _ newData contents].! !!RemoteHandMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!getNextRemoteEvent	"Return the next remote event, or nil if the receive buffer does not contain a full event record. An event record is the storeString for a MorphicEvent terminated by a <CR> character."	| i s |	self receiveData.	receiveBuffer isEmpty ifTrue: [^ nil].	i _ receiveBuffer indexOf: Character cr ifAbsent: [^ nil].	s _ receiveBuffer copyFrom: 1 to: i - 1.	receiveBuffer _ receiveBuffer copyFrom: i + 1 to: receiveBuffer size.	^ (MorphicEvent readFromString: s) setHand: self! !!RemoteHandMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!receiveData	"Check my connection status and withdraw from the world if the connection has been broken. Append any data that has arrived to receiveBuffer. "	socket ifNotNil: [		socket isConnected			ifTrue: [  "connected"				waitingForConnection ifTrue: [					Transcript show: 'Remote hand ', userInitials, ' connected'; cr.					waitingForConnection _ false].				self appendNewDataToReceiveBuffer]			ifFalse: [  "not connected"				waitingForConnection ifFalse: [					"connection was established, then broken"					self withdrawFromWorld.					receiveBuffer _ '']]].! !!RemoteHandMorph class methodsFor: 'all' stamp: 'di 6/22/97 09:07'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !My instances provide an external file reference to a piece of text.  It may be the sourceCode of a method, or the class comments of a class.The changes file or file-in file usually has a chunk that is just the source string of a method:max: aNumber	^ self > aNumber ifTrue: [self] ifFalse: [aNumber]!!I can return either a String or a Text.  Some a chunk is followed by a second chunk (beginning with ]style[) containing style information.  The encoding is like this:max: aNumber	^ self > aNumber ifTrue: [self] ifFalse: [aNumber]!!]style[(14 50 312)f1,f1b,f1LInteger +;i!!Allowed TextAttributes are TextFontChange, TextEmphasis, TextColor, TextDoIt, TextKern, TextLink, TextURL.  TextFontReference and TextAnchor are not supported.See PositionableStream nextChunkText and RunArray class scanFrom:.!]style[(748 32 5 24 1)f1,f1LPositionableStream nextChunkText;,f1,f1LRunArray class scanFrom:;,f1!!RemoteString methodsFor: 'accessing'!position 	"Answer the location of the string on a file."	^ filePositionHi! !!RemoteString methodsFor: 'accessing' stamp: 'tk 12/14/97 05:27'!sourcePointer	sourceFileNumber ifNil: [^ 0].	^ (sourceFileNumber * 16r1000000) + filePositionHi! !!RemoteString methodsFor: 'accessing' stamp: 'di 1/13/98 16:57'!string 	"Answer the receiver's string if remote files are enabled."	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^''].	theFile _ SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	^ theFile nextChunk! !!RemoteString methodsFor: 'accessing' stamp: 'tk 12/13/97 13:37'!text 	"Answer the receiver's string asText if remote files are enabled."	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^''].	theFile _ SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	^ theFile nextChunkText! !!RemoteString methodsFor: 'private' stamp: 'tk 12/11/97 10:33'!checkSum: aString	"Construct a checksum of the string.  A three byte number represented as Base64 characters."| sum shift bytes ss bb |sum _ aString size.shift _ 0.aString do: [:char |	(shift _ shift + 7) > 16 ifTrue: [shift _ shift - 17].		"shift by 7 to keep a change of adjacent chars from xoring to same value"	sum _ sum bitXor: (char asInteger bitShift: shift)].bytes _ ByteArray new: 3.sum _ sum + 16r10000000000.1 to: 3 do: [:ind | bytes at: ind put: (sum digitAt: ind)].ss _ ReadWriteStream on: (ByteArray new: 3).ss nextPutAll: bytes.bb _ Base64MimeConverter mimeEncode: ss.^ bb contents! !!RemoteString methodsFor: 'private'!fileNumber: fileNumber position: position 	sourceFileNumber _ fileNumber.	filePositionHi _ position! !!RemoteString methodsFor: 'private' stamp: 'tk 12/11/97 10:31'!makeNewTextAttVersion	"Create a new TextAttributes version because some inst var has changed.  If no change, don't make a new one."	"Don't delete this method even though it has no callers!!!!!!!!!!"| obj cls struct tag |"Note that TextFontReference and TextAnchor are forbidden."obj _ #(RunArray TextDoIt TextLink TextURL TextColor TextEmphasis TextFontChange TextKern TextLinkToImplementors 3 'a string') collect: [:each | 		cls _ Smalltalk at: each ifAbsent: [nil].		cls ifNil: [each] ifNotNil: [cls new]].struct _ (SmartRefStream on: (RWBinaryOrTextStream on: String new)) instVarInfo: obj.tag _ self checkSum: struct printString.TextAttributeStructureVersions ifNil: [TextAttributeStructureVersions _ Dictionary new].(struct = CurrentTextAttStructure) & (tag = CurrentTextAttVersion) 	ifTrue: [^ false].CurrentTextAttStructure _ struct.CurrentTextAttVersion _ tag.TextAttributeStructureVersions at: tag put: struct.^ true! !!RemoteString methodsFor: 'private'!string: aString onFileNumber: fileNumber	"Store this as my string if source files exist."	| theFile |	(SourceFiles at: fileNumber) == nil ifFalse: 		[theFile _ SourceFiles at: fileNumber.		theFile setToEnd; cr.		self string: aString onFileNumber: fileNumber toFile: theFile]! !!RemoteString methodsFor: 'private' stamp: 'tk 12/12/97 10:41'!string: aStringOrText onFileNumber: fileNumber toFile: aFileStream 	"Store this as the receiver's text if source files exist. If aStringOrText is a Text, store a marker with the string part, and then store the runs of TextAttributes in the next chunk."	| position |	position _ aFileStream position.	self fileNumber: fileNumber position: position.	aFileStream nextChunkPutWithStyle: aStringOrText	"^ self		(important)"! !!RemoteString class methodsFor: 'all' stamp: 'tk 12/12/97 11:46'!currentTextAttVersion	"The current configuration of the TextAttributes classes has a structures array describing the inst vars of the classes (SmartRefStream instVarInfo:).  Return tag that indexes the TextAttributeStructureVersions dictionary (4 random characters)."	^ CurrentTextAttVersion	"Be sure to run makeNewTextAttVersion when any TextAttributes class changes inst vars"! !!RemoteString class methodsFor: 'all' stamp: 'tk 12/11/97 10:35'!initialize	"Derive the current TextAttributes classes object structure"	self new makeNewTextAttVersion! !!RemoteString class methodsFor: 'all' stamp: 'tk 12/13/97 13:36'!structureAt: styleVersion	^ TextAttributeStructureVersions at: styleVersion ifAbsent: [nil]! !!RepeatingSound methodsFor: 'initialization' stamp: 'jm 9/12/97 15:54'!setPitch: p dur: d loudness: l	self error: 'RepeatingSounds do not support playing notes'.! !!RepeatingSound methodsFor: 'initialization' stamp: 'jm 9/12/97 16:39'!setSound: aSound iterations: anIntegerOrSymbol	"Initialize the receiver to play the given sound the given number of times. If iteration count is the symbol #forever, then repeat indefinitely."	"(RepeatingSound repeat: AbstractSound scaleTest count: 2) play"	"(RepeatingSound repeatForever: PluckedSound lowMajorScale) play"	super initialize.	sound _ aSound.	iterationCount _ anIntegerOrSymbol.	self reset.! !!RepeatingSound methodsFor: 'accessing' stamp: 'jm 11/17/97 18:48'!iterationCount	^ iterationCount! !!RepeatingSound methodsFor: 'accessing' stamp: 'jm 11/17/97 18:48'!iterationCount: aNumber	iterationCount _ aNumber.! !!RepeatingSound methodsFor: 'accessing' stamp: 'jm 11/17/97 18:48'!sound	^ sound! !!RepeatingSound methodsFor: 'accessing' stamp: 'jm 12/15/97 22:39'!sound: aSound	sound _ aSound.! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 11/25/97 13:40'!doControl	super doControl.	sound doControl.! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 11/24/97 16:05'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a collection of sounds in sequence."	"(RepeatingSound new		setSound: FMSound majorScale		iterations: 2) play"	| i count samplesNeeded |	iteration <= 0 ifTrue: [^ self].	i _ startIndex.	samplesNeeded _ n.	[samplesNeeded > 0] whileTrue: [		count _ sound samplesRemaining min: samplesNeeded.		count = 0 ifTrue: [			iterationCount == #forever				ifFalse: [					iteration _ iteration - 1.					iteration <= 0 ifTrue: [^ self]].  "done"			sound reset.			count _ sound samplesRemaining min: samplesNeeded.			count = 0 ifTrue: [^ self]].  "zero length sound"		sound mixSampleCount: count			into: aSoundBuffer			startingAt: i			leftVol: leftVol			rightVol: rightVol.		i _ i + count.		samplesNeeded _ samplesNeeded - count].! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 9/12/97 16:09'!reset	super reset.	sound reset.	iterationCount == #forever		ifTrue: [iteration _ 1]		ifFalse: [iteration _ iterationCount].! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 9/12/97 16:09'!samplesRemaining	iteration > 0		ifTrue: [^ 1000000]		ifFalse: [^ 0].! !!RepeatingSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:13'!copy	"Copy my component sound."	^ super copy copySound! !!RepeatingSound methodsFor: 'copying' stamp: 'jm 12/15/97 22:34'!copySound	"Private!! Support for copying. Copy my component sound."	sound _ sound copy.! !!RepeatingSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 16:14'!repeat: aSound count: anInteger	"Return a RepeatingSound that will repeat the given sound for the given number of iterations."	^ self new setSound: aSound iterations: anInteger! !!RepeatingSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 16:13'!repeatForever: aSound	"Return a RepeatingSound that will repeat the given sound forever."	^ self new setSound: aSound iterations: #forever! !!RepeatingSound class methodsFor: 'car motor example' stamp: 'jm 11/16/97 11:29'!carMotorSound	"Return a repeating sound for the sound of a car engine."	"RepeatingSound carMotorSound play"	^ self carMotorSound: 18050! !!RepeatingSound class methodsFor: 'car motor example' stamp: 'jm 11/16/97 11:29'!carMotorSound: samplingRate	"Return a repeating sound for the sound of a car engine. Different sampling rates give different motor sounds."	"(RepeatingSound carMotorSound: 12050) play"	CarMotorSamples ifNil: [self initializeCarMotor].	^ RepeatingSound repeatForever:		(SampledSound samples: CarMotorSamples samplingRate: samplingRate)! !!RepeatingSound class methodsFor: 'car motor example' stamp: 'jm 11/16/97 11:29'!initializeCarMotor	"Initialize the samples array for the sound of a car engine."	CarMotorSamples _ SoundBuffer fromArray: #(36 199 190 508 332 167 253 302 788 884 1233 1145 977 904 991 1371 1361 1495 1253 1346 1696 1454 1631 1784 1752 1826 1389 1234 1202 1152 1188 1000 1048 898 724 937 1145 1537 2023 2079 2371 2156 2098 1855 1843 2208 2126 2218 1664 1457 1389 1454 1481 1458 1661 1400 1548 1499 1949 2055 2130 2220 2038 1904 1750 1993 2114 2272 2418 2101 1976 1791 2161 2690 2958 3013 2888 2798 2792 2875 3207 3627 3732 3842 3791 3836 3964 4082 4351 4550 4755 4746 4851 5180 5507 6100 6491 6533 6133 5394 4627 3886 3133 2209 1073 -368 -1876 -3170 -4067 -4641 -4963 -5049 -4922 -4634 -4147 -3544 -2805 -1962 -1219 -592 -326 -374 -627 -901 -1075 -1159 -1252 -1312 -1444 -1397 -1338 -1142 -748 -541 -350 -314 -265 -143 52 464 653 927 1269 1617 2048 2365 2654 2924 3306 3669 3855 3799 3160 2372 1629 1289 1635 1841 1838 1557 987 630 557 857 1005 868 435 -309 -1083 -1765 -2025 -2055 -2219 -2388 -2409 -2438 -2314 -2002 -1687 -1477 -1533 -1641 -1878 -1885 -1776 -1580 -1005 -525 -164 -84 396 768 1160 1788 2219 2365 1836 1435 1097 988 1326 1423 2106 2191 1965 1829 1578 1835 1429 1570 1596 1301 1357 1233 1634 2386 2597 3037 3225 3406 3339 3049 2935 2611 2428 2340 2728 2621 2994 2599 2591 3010 3341 3922 3992 3824 2982 2128 1376 1455 1437 2022 1927 1730 1841 1832 2334 2942 3183 3124 3362 3342 3549 3322 3474 3686 4164 4550 4051 3701 2742 2656 3210 4011 4641 4416 3697 2998 3382 3715 3729 3687 3375 3521 3932 4273 4172 3970 3598 3675 4879 5887 6320 5794 4623 4179 4453 5626 6412 6353 5563 4689 4683 5058 5905 6270 6218 6134 5704 5297 4087 2627 1221 -181 -1351 -2616 -4341 -6598 -8702 -9888 -10087 -9286 -8357 -7568 -6878 -6063 -4839 -3540 -2281 -1176 -315 248 409 337 -353 -1326 -2135 -2392 -2324 -2288 -2486 -3272 -3618 -3573 -2804 -1503 -604 267 808 1389 2069 2643 3328 3964 4706 5502 6136 6163 5665 4956 4491 4507 4409 4042 3132 1996 998 330 -116 -475 -877 -1370 -1250 -1048 -851 -740 -1207 -1166 -1040 -395 405 441 342 -281 -763 -799 -774 -447 -319 -190 -120 115 182 91 207 387 959 1462 1811 1767 1335 972 730 979 1157 1338 1347 807 591 232 417 696 664 1406 1512 2065 2416 2374 2539 2395 2483 2677 2674 2585 2299 1134 320 -336 -65 676 743 538 16 -374 -515 138 463 1043 1533 1786 2332 2258 2566 2663 2961 3599 3498 3518 2952 2309 2045 1667 1571 1504 1213 1118 1029 874 843 710 977 1377 1816 2236 2114 1989 1698 1618 1672 1682 1602 1382 1044 689 364 55 -24 4 322 669 948 1148 1193 1280 1463 1873 2261 2578 2654 2543 2312 1976 1772 1738 1763 1855 1834 1664 1469 1312 1399 1484 1732 1880 2004 2124 2090 2056 2000 2048 2227 2464 2670 2721 2511 2234 2056 2081 2263 2522 2737 2768 2728 2693 2711 2768 2891 3068 3182 3126 2913 2545 2171 1950 1820 1765 1710 1538 1319 1020 764 600 538 607 742 808 710 517 307 162 62 17 -8 -205 -486 -858 -1288 -1581 -1720 -1795 -1834 -1863 -1906 -1966 -1895 -1855 -1651 -1350 -1049 -721 -464 -265 -65 75 189 306 412 472 458 374 222 113 101 178 309 481 568 576 516 497 582 724 844 964 914 774 662 509 472 576 610 572 554 517 605 785 1008 1312 1555 1786 1957 2044 2081 2118 2193 2264 2328 2335 2277 2205 2098 2002 1981 1982 2017 1972 1912 1788 1611 1519 1428 1393 1367 1209 1045 842 624 564 509 465 398 172 11 -157 -264 -259 -269 -248 -249 -222 -266 -355 -372 -288 -158 -55 1 71 91 102 228 420 619 798 829 930 1012 1047 1210 1359 1531 1676 1702 1787 1809 1729 1668 1653 1721 1808 1793 1747 1616 1485 1476 1516 1751 1961 2029 2057 2006 1955 1893 1904 1960 1967 1975 1934 1827 1814 1749 1809 1947 2037 2098 2067 1970 1754 1627 1667 1759 1904 1890 1819 1747 1644 1698 1746 1834 1959 1922 1887 1864 1712 1734 1770 1895 2029 2062 2153 2132 2203 2206 2202 2194 2075 2019 1889 1923 1930 2090 2250 2335 2372 2209 2085 1902 1805 1826 1843 1804 1761 1605 1580 1680 1713 1825 1904 2097 2269 2373 2384 2235 2351 2445 2530 2610 2560 2618 2511 2445 2374 2111 1959 1760 1602 1474 1208 1021 786 688 654 573 526 409 452 566 694 746 831 914 1008 1043 821 513 214 -45 -242 -453 -723 -898 -1103 -1078 -1081 -1087 -1015 -1073 -869 -884 -720 -555 -329 -24 -63 14 -96 5 260 412 636 623 611 785 788 1001 1025 989 1162 1215 1404 1408 1305 1311 1120 1076 956 785 740 371 389 164 202 522 478 770 483 259 250 79 497 987 1288 1453 1283 1350 1436 1441 1804 1861 2059 2156 1969 2142 2148 2384 2652 2470 2383 1883 1739 1618 1475 1523 1134 1167 1031 816 674 274 251 162 301 387 23 -176 -345 -333 -198 -356 -363 -444 -421 -192 -226 -230 -239 -326 10 106 195 132 95 202 79 -68 -222 -45 429 788 954 1256 1426 1521 1704 1729 2053 1867 1581 1434 1367 1554 1386 1221 1165 1253 1571 1394 1425 1390 948 1288 999 1421 1568 1292 1478 1019 1053 591 693 520 302 314 116 847 1340 1792 1883 1582 1474 1821 2140 2486 2651 2167 1728 1380 1345 1811 1993 2052 2325 2231 2148 2271 2450 2831 2866 2908 2721 2623 2252 2025 2393 2667 3015 2817 2668 2588 2540 2736 2761 3275 3232 3252 3168 3112 3284 3138 3458 3716 3876 3928 3824 3928 4040 4330 4923 5226 5205 5183 5172 5510 5926 6225 6306 6020 5433 4448 3261 2118 959 -239 -1741 -3208 -4507 -5623 -6134 -6133 -5617 -4931 -4192 -3378 -2817 -2219 -1588 -817 -110 199 281 -5 -417 -652 -749 -679 -890 -1261 -1549 -1905 -1928 -2002 -1885 -1552 -1185 -655 -235 222 793 1424 1992 2599 2940 3081 2982 2695 2667 2771 2919 2980 2662 2146 1537 1215 1217 1374 1337 1061 790 376 250 -97 -111 5 -149 -243 -733 -936 -1395 -1810 -1781 -1762 -1500 -1716 -2039 -2318 -2398 -1907 -1592 -1422 -1900 -2619 -3034 -3024 -2335 -1429 -557 323 1051 1587 2021 2282 2438 2207 1843 1789 1482 1392 1056 742 1220 1294 1464 1641 1731 1847 1291 1682 1970 2097 2253 1624 1474 1312 1312 1873 2315 2523 2486 2323 2385 2924 3638 4341 4431 4045 3644 2945 2939 2935 2867 3411 2886 2731 2211 1405 1001 640 1077 1430 1688 1803 1857 2036 2447 3394 3628 3702 3468 3361 3782 3668 3672 4050 3895 4188 4564 4217 3965 2693 1946 1878 2245 3152 3267 3120 2670 2675 3308 4567 5358 5556 5114 3953 3653 3658 4111 4688 4262 3819 3732 4224 4771 5579 5622 5585 5613 5501 5593 5452 5570 5632 6094 5985 5579 4982 4206 3878 3683 3274 2172 698 -1224 -2821 -3890 -4742 -5518 -6463 -7297 -7730 -8054 -7991 -7508 -6683 -5163 -3562 -2162 -1401 -1000 -650 -255 344 643 475 -347 -1530 -2545 -3189 -3506 -3525 -3563 -3239 -2710 -1975 -1174 -649 117 1250 2603 3929 4750 4920 4876 4692 4897 5263 5455 5008 4285 3535 2650 2480 2198 1908 1831 1412 1060 602 80 -281 -245 -37 518 694 559 449 134 264 395 501 454 294 14 -188 -258 -603 -471 -526 -212 202 413 643 447 674 1151 2015 2779 2830 2783 2349 2213 2223 1805 1467 750 640 762 709 685 202 48 360 1103 1707 1935 1604 992 986 883 1293 1285 840 880 25 72 -201 -568 -194 -266 416 698 748 1106 930 1391 2268 2672 3350 3207 3010 3183 2888 3077 3048 2737 2684 2102 1594 1047 146 -39 -397 -420 -237 -520 -465 -526 -247 398 929 1605 2176 2568 2979 3102 3165 3206 3205 3315 3167 2841 2330 1660 1172 909 881 992 1021 1063 1098 1184 1407 1681 1927 2245 2498 2652 2755 2740 2720 2600 2599 2547 2529 2425 2327 2216 1983 1798 1578 1501 1596 1707 1778 1775 1794 1832 1945 2157 2368 2534 2679 2726 2647 2546 2482 2500 2613 2715 2858 2909 2875 2798 2847 3002 3238 3544 3763 3906 3870 3762 3684 3570 3510 3375 3115 2665 2099 1534 1114 848 744 650 462 329 147 161 282 430 614 681 701 635 505 263 -31 -284 -523 -787 -1040 -1310 -1530 -1694 -1726 -1660 -1541 -1319 -1101 -872 -661 -468 -289 -53 235 439 581 607 542 488 496 442 476 539 528 480 404 353 383 409 514 643 801 911 1039 1099 1060 1002 1008 1079 1079 1088 1043 998 953 947 1077 1232 1417 1630 1737 1807 1861 1947 2139 2352 2521 2494 2388 2251 2163 2142 2183 2246 2312 2333 2215 2167 2080 1954 1856 1767 1725 1685 1560 1366 1157 915 754 677 570 434 268 50 -48 -106 -80 23 -6 3 -105 -143 -106 -86 -10 15 72 129 151 224 269 377 540 615 755 802 841 986 1126 1263 1430 1501 1565 1592 1629 1704 1769 1780 1815 1868 1875 1853 1767 1657 1676 1777 1954 2063 2033 2006 1997 2052 2132 2218 2192 2163 2068 1935 1832 1731 1692 1644 1603 1587 1656 1704 1735 1707 1693 1778 1855 1886 1808 1854 1866 2020 2082 2051 2063 1922 1994 2055 1979 1867 1654 1725 1958 2103 2250 2210 2181 2136 1990 1769 1538 1555 1690 1847 1927 1833 1861 1845 1916 1901 1878 1827 1965 2079 2011 1813 1442 1294 1314 1438 1527 1471 1351 1346 1433 1541 1742 1882 2055 2187 2137 2094 2026 2216 2547 2788 2910 2700 2476 2276 2271 2219 2140 2106 1948 1839 1563 1271 991 871 785 695 490 237 93 101 302 452 541 637 735 773 731 667 554 479 381 262 -30 -313 -571 -871 -940 -1094 -1156 -946 -946 -789 -822 -1016 -846 -729 -380 -130 -174 -291 -393 -459 -370 -385 -488 -235 -189 -29 66 20 251 506 931 1376 1399 1348 1192 940 1022 839 916 1173 1247 1303 1207 950 888 944 1151 1385 1216 1012 762 741 964 995 1072 1129 1201 1243 1189 1214 1209 1090 1188 1226 962 840 480 309 201 8 -27 -108 19 120 122 175 188 247 298 326 490 659 638 530 299 294 391 561 749 632 677 592 520 445 175 452 195 476 279 54 216 -444 -153 -497 -42 65 -76 89 -307 613 424 736 729 692 1203 923 1051 761 782 993 912 1361 971 671 640 713 1230 870 821 292 243 774 1172 1686 1286 1348 1303 1523 1622 1578 1833 1810 1913 1658 1535 1352 1375 1673 2156 2537 2408 2275 2078 2090 2117 2030 2120 2227 2296 2388 2667 2966 3152 3134 2987 2799 2665 2686 2666 2584 2637 2572 2631 2836 3106 3325 3066 2882 2869 3046 3325 3369 3339 3398 3350 3293 3457 3587 3759 3999 4191 4413 4437 4477 4519 4628 4905 5061 5239 5014 4922 5179 5616 6008 6053 5515 4650 3634 2615 2101 1403 430 -981 -2592 -4097 -5331 -6002 -6365 -6339 -5996 -5552 -4825 -4058 -3378 -2538 -1678 -858 -70 377 250 -342 -1019 -1354 -1355 -1196 -1361 -1521 -1624 -1862 -1561 -1109 -638 -510 -705 -845 -1026 -585 -35 768 1668 2308 2850 3002 3103 3216 3453 3876 4335 4501 4065 3249 2233 1669 1518 1717 1688 1115 370 -493 -662 -599 -225 85 -153 -466 -954 -1270 -1132 -935 -978 -1481 -2039 -2683 -3353 -3678 -3673 -3362 -2780 -2386 -2281 -2137 -2034 -1498 -801 -239 351 480 608 886 1176 1592 1788 2106 2205 2010 1893 1582 1539 1597 1795 1990 2158 2092 1255 800 1029 1404 1884 2085 1537 1103 919 870 2111 3220 3367 3480 2671 2319 2914 3620 4073 3498 2841 2067 1810 2225 2669 3168 2603 1347 499 729 1563 2063 1953 1175 432 458 1393 2521 3149 3279 2822 2467 2697 3005 3756 4386 4418 4555 3662 3241 3320 3520 3914 4087 3923 2896 2532 1732 1807 2221 2972 3933 3101 2464 1657 1615 2639 3948 4718 5026 4305 3909 3815 3811 4014 3853 4090 4153 4670 4783 4527 4113 4296 4866 5695 6258 6024 5748 5089 5020 5101 4974 4353 3499 2056 779 -738 -2628 -4028 -5515 -6213 -6815 -7376 -7953 -8558 -8565 -7680 -6158 -4573 -3152 -2390 -1579 -792 -128 414 470 360 165 -390 -1164 -2225 -3460 -4085 -4255 -3862 -3277 -2975 -2731 -2390 -1656 -387 1008 2146 3014 3428 3832 4526 4822 4875 4472 3941 3954 3945 3710 2856 1848 931 619 1054 1206 877 318 -270 -412 34 160 399 532 402 655 568 472 246 -92 356 716 776 540 -331 -730 -548 -242 338 202 -72 4 -6 637 885 1005 1330 1619 2174 2350 2069 1709 1412 1476 1747 1558 1230 711 321 398 293 313 92 81 454 659 806 581 346 351 585 870 851 436 -76 -479 -756 -907 -1190 -1414 -1586 -1628 -1483 -1389 -1238 -816 -177 556 1249 1735 2074 2385 2710 3065 3264 3285 3143 2928 2692 2297 1832 1387 1022 955 1088 1101 1028 872 870 1090 1475 1976 2316 2578 2716 2705 2557 2467 2367 2328 2364 2301 2073 1686 1366 1175 1116 1199 1196 1109 962 920 934 983 1051 1258 1536 1752 1836 1770 1680 1643 1800 1954 2082 2111 1986 1885 1813 1824 1898 2088 2236 2353 2399 2340 2255 2213 2244 2350 2365 2326 2266 2154 2072 2068 2093 2130 2223 2295 2394 2515 2449 2426 2527 2778 3021 3240 3286 3216 3108 3004 3042 3106 3147 2990 2690 2282 1902 1641 1457 1359 1172 825 473 189 106 166 377 569 634 551 403 364 415 437 366 107 -242 -524 -723 -824 -959 -1100 -1264 -1381 -1408 -1252 -1072 -932 -889 -819 -581 -341 -107 56 128 156 158 185 260 284 270 324 376 391 423 449 446 429 521 569 566 584 546 589 624 594 594 584 607 725 876 976 1004 1046 1082 1193 1341 1372 1434 1446 1409 1528 1618 1747 1911 1985 2090 2092 2110 2170 2230 2360 2411 2433 2402 2317 2280 2227 2126 2017 1878 1729 1564 1406 1237 1073 957 906 841 788 706 548 437 429 449 554 653 664 582 500 486 511 519 430 339 318 294 287 265 288 299 429 605 681 822 808 887 950 1042 1240 1348 1547 1638 1752 1787 1765 1864 1949 2025 2058 1990 1921 1818 1707 1755 1810 2007 2069 2017 1840 1623 1633 1646 1803 1962 2002 1985 1838 1694 1588 1493 1551 1685 1756 1784 1604 1458 1532 1660 1898 1986 1737 1551 1457 1665 1890 2078 2066 2082 2181 2156 2167 2174 2290 2341 2314 2302 2134 2114 2054 2020 2109 1974 1916 1841 1628 1718 1718 1860 1951 1774 1893 1745 1701 1769 1541 1733 1542 1509 1547 1370 1640 1572 1480 1679 1501 1747 1697 1748 1973 1763 1949 1795 2000 2185 2249 2600 2532 2713 2672 2558 2572 2506 2691 2760 2797 2680 2299 1992 1796 1558 1444 1055 663 489 6 -197 -508 -713 -632 -763 -579 -532 -472 -253 -174 -66 75 -39 72 208 312 339 87 16 -170 -198 -166 -227 -270 -498 -495 -406 -544 -569 -766 -656 -500 -344 -121 -161 -67 -60 97 96 47 31 -76 163 173 417 465 257 332 5 48 -14 -135 124 -51 17 -190 -361 -127 -23 352 410 491 632 489 608 746 1100 1463 1473 1668 1380 1289 1319 1575 1979 1935 1824 1385 1265 1351 1528 1675 1429 1018 548 133 -254 -466 -736 -796 -815 -994 -916 -948 -584 -366 -196 -132 -119 -108 -165 12 -235 -107 -353 -349 -579 -765 -953 -1235 -888 -764 -286 -769 -804 -787 -508 255 127 169 -177 -373 -111).! !!RestSound methodsFor: 'initialization' stamp: 'jm 12/30/97 16:48'!setDur: d	"Set rest duration in seconds."	initialCount _ (d * self samplingRate asFloat) rounded.	count _ initialCount.! !!RestSound methodsFor: 'sound generation' stamp: 'jm 11/24/97 16:04'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play silence for a given duration."	"(RestSound dur: 1.0) play"	count _ count - n.! !!RestSound methodsFor: 'sound generation' stamp: 'jm 12/15/97 22:37'!samplesRemaining	^ count! !!RestSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 15:54'!dur: d	"Return a rest of the given duration."	^ self basicNew setDur: d! !!RestSound class methodsFor: 'instance creation' stamp: 'jm 12/15/97 22:38'!pitch: p dur: d loudness: l	"Return a rest of the given duration."	"Note: This message allows one to silence one or more voices of a multi-voice piece by using RestSound as their instrument."	^ self new setDur: d! !!ReturnNode methodsFor: 'C translation'!asTranslatorNode	^TReturnNode new setExpression: expr asTranslatorNode! !!Riffle methodsFor: 'as yet unclassified' stamp: 'jm 10/9/97 04:53'!initialize	super initialize.	sound _ SampledSound		samples: #(-311 -282 -250 -258 -206 -258 -214 -222 -173 -185 -52 -44 -44 -32 12 36 76 24 84 32 4 -12 -117 -141 -109 -133 -96 -101 -12 -92 -157 -76 -129 -242 -177 -250 -258 -282 -290 -238 -270 -266 -319 -375 -331 -404 -375 -432 -468 -444 -416 -392 -363 -331 -270 -299 -270 -367 -286 -230 -193 -193 -109 -125 -48 -8 -4 20 16 16 -4 8 52 -101 -117 -173 -157 -250 -278 -266 -262 -343 -383 -420 -379 -440 -448 -432 -456 -529 -472 -452 -476 -513 -436 -456 -387 -347 -355 -315 -379 -428 -351 -375 -387 -444 -400 -347 -355 -375 -274 -185 -125 -145 -125 -189 -262 -359 -448 -509 -497 -464 -549 -533 -521 -545 -541 -642 -650 -695 -739 -699 -747 -678 -561 -533 -400 -303 -299 -375 -335 -392 -484 -565 -626 -735 -735 -816 -901 -965 -998 -1143 -1171 -1155 -1095 -1256 -1305 -1337 -1184 -792 -432 -32 290 230 60 -323 -662 -982 -1333 -1563 -1652 -1725 -1491 -1079 -618 -307 60 258 222 20 -137 -133 36 400 735 771 707 590 505 428 468 533 634 666 949 1232 1357 1507 1725 1883 2101 2283 2533 2643 2853 2877 2925 2897 2719 2558 2412 2327 2388 2453 2655 2804 3022 3071 3148 3285 3386 3451 3455 3495 3608 3524 3612 3576 3572 3612 3487 3447 3330 3281 3309 3321 3350 3366 3414 3451 3495 3548 3616 3564 3713 3673 3657 3633 3507 3455 3374 3188 2958 2812 2792 2638 2643 2723 2711 2687 2695 2667 2667 2598 2566 2550 2562 2590 2537 2465 2440 2440 2477 2343 2287 2242 2271 2226 2117 1972 1972 1943 1814 1596 1503 1438 1418 1353 1313 1365 1370 1325 1317 1268 1232 1103 1022 800 642 493 505 327 311 295 222 101 48 -153 -266 -420 -533 -533 -569 -678 -666 -763 -788 -937 -941 -1014 -1107 -1176 -1264 -1454 -1483 -1572 -1632 -1713 -1766 -1802 -1794 -1915 -1988 -2069 -2137 -2190 -2202 -2335 -2376 -2315 -2311 -2392 -2380 -2469 -2440 -2436 -2509 -2533 -2509 -2570 -2638 -2655 -2727 -2881 -2901 -2857 -2913 -2978 -2958 -2970 -3010 -3030 -3087 -3115 -3119 -3168 -3156 -3148 -3115 -3107 -2970 -2954 -2986 -2946 -2925 -2917 -2889 -2909 -2925 -2828 -2828 -2832 -2849 -2816 -2841 -2841 -2792 -2889 -2897 -2861 -2865 -2832 -2837 -2897 -2853 -2849 -2796 -2776 -2744 -2675 -2626 -2610 -2505 -2505 -2444 -2416 -2440 -2469 -2449 -2428 -2404 -2408 -2420 -2339 -2343 -2489 -2465 -2513 -2509 -2578 -2578 -2679 -2643 -2695 -2707 -2853 -2917 -2954 -3043 -3107 -3107 -3144 -3220 -3216 -3233 -3237 -3152 -3180 -3229 -3245 -3374 -3495 -3588 -3649 -3693 -3742 -3754 -3843 -3911 -3944 -3932 -3984 -3988 -4194 -4211 -4279 -4271 -4360 -4396 -4441 -4473 -4530 -4538 -4570 -4530 -4590 -4518 -4538 -4578 -4538 -4514 -4558 -4603 -4671 -4623 -4732 -4724 -4788 -4740 -4821 -4837 -4889 -4974 -5088 -5144 -5160 -5100 -5185 -5229 -5261 -5298 -5282 -5294 -5362 -5249 -5241 -5229 -5241 -5176 -5193 -5136 -5031 -5092 -5088 -5011 -4950 -4829 -4829 -4768 -4784 -4752 -4732 -4691 -4784 -4724 -4700 -4780 -4801 -4801 -4760 -4736 -4679 -4611 -4639 -4526 -4433 -4372 -4340 -4194 -4101 -4033 -3948 -3891 -3859 -3867 -3907 -3851 -3883 -3883 -3968 -3891 -3851 -3875 -3879 -3827 -3819 -3863 -3920 -3903 -3823 -3742 -3588 -3439 -3301 -3216 -3115 -3022 -2942 -2849 -2699 -2582 -2449 -2299 -2178 -2097 -2000 -1943 -1984 -1911 -1972 -1863 -1725 -1584 -1479 -1345 -1256 -1107 -1079 -1062 -1026 -1022 -909 -856 -796 -779 -751 -695 -642 -626 -618 -618 -549 -460 -448 -375 -299 -226 -109 -32 68 121 121 210 189 193 202 254 153 157 177 242 185 262 262 335 343 432 472 484 569 682 642 594 537 521 420 501 416 396 525 614 699 792 767 719 634 529 468 432 299 371 379 448 488 505 525 658 666 646 646 699 755 775 792 868 804 703 404 189 -32 -161 -234 -181 -36 88 40 169 642 1147 1535 2000 2093 1798 1260 820 238 -452 -755 -836 -666 -323 185 840 1531 2121 2505 2748 2679 2711 2776 3047 3519 3899 4069 4154 3875 3524 3208 2917 2744 2598 2574 2578 2671 2832 3026 3156 3253 3265 3297 3410 3612 3738 3697 3681 3491 3313 3132 2990 2881 2893 3188 3568 3972 4279 4485 4732 4885 4930 4946 4918 4966 4966 4986 5063 5023 4938 4756 4675 4510 4400 4207 4134 3988 3976 4065 4227 4283 4384 4429 4457 4485 4514 4409 4380 4356 4316 4227 4021 3806 3524 3265 3144 2990 2901 2897 2921 2929 2909 2925 2921 2869 2715 2638 2566 2509 2505 2449 2436 2420 2473 2449 2477 2343 2444 2416 2501 2481 2501 2440 2461 2428 2291 2299 2396 2513 2707 2820 3083 3317 3495 3766 3964 4110 4316 4445 4760 4999 5306 5560 5872 6106 6296 6478 6595 6627 6704 6664 6639 6514 6583 6490 6470 6462 6482 6385 6462 6421 6401 6401 6385 6453 6401 6304 6324 6308 6272 6251 6199 6163 6102 6066 5928 5831 5779 5560 5504 5374 5253 5128 5071 5015 4902 4752 4728 4679 4526 4465 4376 4287 4182 3968 3798 3730 3616 3427 3386 3265 3229 3188 3123 3119 3063 2897 2861 2776 2735 2606 2505 2412 2384 2368 2416 2335 2404 2436 2602 2647 2570 2740 2784 2723 2804 2731 2760 2695 2651 2594 2477 2404 2388 2327 2339 2271 2246 2267 2331 2299 2339 2271 2396 2473 2481 2489 2497 2582 2776 2715 2796 2950 2942 2954 3079 3099 3071 3144 3180 3172 3196 3172 3245 3245 3115 3035 3055 3051 3026 2946 2958 2962 2913 2950 2986 2901 2877 2804 2667 2562 2485 2238 2129 1980 1927 1850 1725 1636 1580 1495 1475 1378 1248 1200 1135 1054 1022 929 917 840 658 565 529 416 331 270 242 177 246 189 173 137 117 68 68 -20 -36 -56 0 -92 -133 -173 -242 -254 -371 -513 -448 -464 -493 -541 -549 -658 -695 -654 -658 -751 -751 -856 -889 -885 -885 -994 -973 -1074 -1111 -1277 -1329 -1402 -1499 -1624 -1669 -1770 -1822 -1842 -1903 -2008 -1996 -2024 -2097 -2186 -2202 -2408 -2364 -2420 -2546 -2610 -2562 -2647 -2683 -2804 -2865 -2889 -2978 -3047 -3067 -3144 -3160 -3233 -3220 -3301 -3350 -3346 -3253 -3342 -3443 -3515 -3475 -3370 -3346 -3289 -3043 -2921 -2917 -2869 -2861 -2881 -2837 -2865 -2849 -2824 -2816 -2804 -2764 -2784 -2731 -2703 -2756 -2760 -2723 -2837 -2857 -2784 -2784 -2820 -2776 -2853 -2820 -2849 -2857 -2857 -2893 -2913 -2925 -2946 -2913 -2942 -2905 -2942 -2893 -2966 -2845 -2824 -2776 -2691 -2634 -2626 -2554 -2501 -2509 -2501 -2570 -2578 -2424 -2291 -2210 -2105 -1927 -1887 -1794 -1891 -1879 -1919 -1915 -1972 -2000 -2109 -2178 -2307 -2331 -2372 -2461 -2485 -2420 -2457 -2424 -2453 -2428 -2360 -2255 -2145 -2178 -2246 -2408 -2602 -2889 -3208 -3374 -3572 -3560 -3528 -3459 -3483 -3713 -4053 -4392 -4550 -4647 -4801 -4465 -4017 -3568 -3342 -3370 -3374 -3734 -4299 -4712 -5185 -5322 -5152 -4586 -3863 -3115 -2614 -2214 -2057 -2032 -2206 -2206 -2016 -1677 -1337 -1066 -1099 -1345 -1725 -2238 -2651 -2893 -3148 -3095 -2824 -2558 -2331 -2065 -1923 -1859 -1883 -1814 -1766 -1669 -1588 -1519 -1535 -1648 -1798 -2012 -2214 -2283 -2210 -2129 -1846 -1414 -1107 -788 -606 -436 -355 -141 32 141 238 383 468 521 472 456 262 173 8 -193 -347 -295 -367 -472 -472 -367 -363 -141 -68 -20 -32 56 72 76 -32 -76 -262 -448 -687 -856 -925 -1010 -1038 -1018 -1046 -1014 -953 -957 -1119 -1216 -1289 -1568 -1733 -1871 -2044 -2125 -2065 -2057 -2105 -2137 -2186 -2186 -2263 -2291 -2307 -2174 -2137 -2174 -2279 -2311 -2412 -2465 -2546 -2517 -2626 -2634 -2638 -2598 -2687 -2687 -2772 -2832 -2881 -2970 -3103 -3095 -3172 -3172 -3099 -3148 -3200 -3184 -3188 -3269 -3313 -3245 -3249 -3204 -3132 -3039 -2808 -2687 -2550 -2392 -2222 -2085 -1960 -1778 -1592 -1289 -1079 -832 -493 -246 -92 161 323 590 691 767 824 1030 1030 1107 1176 1289 1325 1321 1297 1361 1442 1450 1414 1370 1260 1281 1155 1115 1127 1107 941 973 957 848 707 695 573 476 371 206 117 -68 -173 -218 -367 -371 -472 -533 -622 -755 -876 -852 -901 -905 -953 -893 -901 -885 -868 -872 -889 -788 -775 -691 -626 -573 -480 -400 -420 -375 -396 -400 -488 -497 -573 -541 -610 -585 -666 -699 -784 -784 -747 -784 -881 -840 -788 -695 -800 -775 -747 -747 -788 -812 -881 -824 -848 -860 -876 -860 -876 -893 -937 -941 -945 -973 -1010 -1030 -1058 -1050 -965 -864 -820 -771 -747 -650 -626 -549 -533 -513 -509 -521 -533 -513 -533 -460 -444 -392 -424 -396 -371 -303 -202 -129 -145 48 72 64 52 -12 -60 20 -52 -84 -44 -44 -56 -8 -28 -48 52 133 206 206 222 242 290 290 222 141 72 125 76 189 246 246 250 149 -4 -68 -226 -278 -270 -339 -379 -295 -238 -177 -84 -12 -230 -727 -1252 -1790 -2170 -2255 -2222 -2016 -1519 -836 -622 -808 -747 -755 -1159 -1471 -1996 -2578 -2837 -2489 -1652 -990 -444 117 505 848 1030 1143 1232 1515 1911 2117 2190 2141 1972 1968 1903 1753 1551 1414 1418 1632 1749 1717 1733 1673 1471 1438 1390 1426 1543 1677 1721 1685 1479 1289 1131 1119 1111 1163 1151 1309 1705 1968 2089 2097 2154 2210 2251 2279 2343 2388 2566 2756 2792 2897 2824 2731 2574 2469 2380 2214 2069 2032 2004 2085 2101 2186 2154 2089 2061 2137 1996 1960 1786 1648 1450 1281 1074 876 731 666 606 614 537 468 412 400 359 254 109 -4 -133 -230 -339 -404 -400 -440 -561 -565 -691 -779 -901 -933 -982 -1002 -1022 -1002 -1103 -1204 -1365 -1483 -1660 -1741 -1810 -1838 -1951 -1947 -1988 -2085 -2145 -2170 -2271 -2396 -2541 -2683 -2780 -2905 -3071 -3099 -3144 -3148 -3212 -3289 -3334 -3321 -3342 -3346 -3317 -3330 -3338 -3321 -3273 -3237 -3188 -3014 -3014 -2938 -2889 -2845 -2744 -2582 -2420 -2263 -2081 -1899 -1806 -1665 -1515 -1329 -1099 -921 -775 -537 -448 -339 -266 -165 -44 52 173 258 351 432 476 581 695 771 816 820 832 929 945 885 840 872 804 889 852 812 771 755 731 715 598 626 521 468 436 383 343 303 210 206 125 121 8 -117 -157 -181 -282 -339 -327 -303 -323 -286 -311 -262 -343 -307 -266 -307 -363 -404 -444 -392 -468 -400 -448 -497 -533 -545 -598 -703 -767 -731 -759 -775 -755 -707 -703 -775 -824 -796 -860 -771 -812 -699 -594 -618 -642 -594 -743 -788 -917 -1010 -1030 -1095 -1248 -1240 -1285 -1248 -1244 -1232 -1321 -1341 -1418 -1475 -1523 -1555 -1705 -1673 -1741 -1782 -1729 -1741 -1774 -1749 -1786 -1733 -1725 -1656 -1644 -1531 -1519 -1426 -1341 -1268 -1329 -1349 -1353 -1353 -1398 -1353 -1349 -1333 -1305 -1260 -1244 -1224 -1264 -1256 -1228 -1143 -1171 -1123 -961 -889 -820 -707 -654 -618 -594 -541 -529 -448 -444 -379 -347 -371 -303 -262 -315 -198 -242 -165 -80 12 52 169 242 311 359 464 505 545 529 606 569 577 585 577 577 561 484 557 501 581 497 480 505 553 488 464 387 488 476 521 602 602 642 731 767 840 860 921 1050 1115 1119 1192 1188 1301 1426 1620 1745 1968 2093 2210 2174 2242 2182 2202 2141 2129 2174 2145 2057 2081 2057 2000 1960 1939 1931 1947 1972 2121 2251 2352 2343 2311 2166 2028 1907 1854 1794 1931 2000 2008 1943 1863 1850 1964 2109 2275 2360 2279 1980 1507 953 480 56 -141 -387 -650 -695 60 856 1309 1709 1669 1107 428 -505 -1337 -1939 -1830 -1305 -699 -189 363 990 1709 2311 2594 2521 2481 2582 2711 2897 3006 3022 2796 2509 2105 1677 1402 1285 1357 1341 1192 1014 949 788 658 610 602 590 739 775 779 662 525 420 311 96 -20 -295 -286 40 493 913 1248 1458 1766 2057 2267 2343 2453 2550 2663 2780 2938 2929 2780 2634 2558 2428 2449 2319 2226 2303 2469 2606 2772 2905 2978 3006 3055 2946 2845 2756 2703 2582 2444 2206 2016 1794 1503 1103 982 1022 1038 925 913 796 828 856 788 727 585 335 238 125 16 -113 -214 -290 -335 -513 -585 -626 -658 -715 -731 -893 -905 -929 -990 -1103 -1159 -1204 -1176 -1176 -1050 -1002 -868 -775 -654 -553 -448 -400 -327 -315 -222 -173 -117 16 80 153 92 20 -12 -60 -157 -270 -226 -137 -141 -153 -76 -4 117 218 242 189 161 133 133 60 28 20 48 24 -52 -125 -214 -311 -327 -335 -404 -448 -472 -493 -533 -533 -565 -594 -569 -650 -788 -941 -953 -965 -949 -1083 -1070 -1139 -1091 -1143 -1192 -1244 -1224 -1353 -1277 -1256 -1252 -1301 -1317 -1329 -1297 -1365 -1394 -1434 -1418 -1535 -1491 -1434 -1390 -1289 -1264 -1176 -1058 -917 -779 -662 -565 -501 -303 -173 -64 -32 109 165 129 64 133 149 189 113 105 88 125 161 157 125 206 270 392 319 311 303 351 343 408 299 238 222 246 88 12 -44 -105 -206 -274 -367 -339 -307 -181 -234 -161 -262 -387 -400 -484 -634 -642 -723 -860 -945 -909 -913 -840 -775 -622 -569 -585 -650 -650 -747 -893 -1034 -1123 -1192 -1143 -1115 -1050 -1192 -1301 -1466 -1475 -1414 -1305 -1293 -1604 -2307 -3006 -3730 -4441 -4849 -4752 -4590 -3891 -2845 -2000 -1394 -957 -868 -1268 -1976 -2752 -3406 -3572 -3099 -2259 -1285 -533 -254 -64 125 246 222 125 218 375 412 416 189 -105 -545 -1018 -1466 -1846 -2129 -2319 -2287 -2299 -2469 -2614 -2752 -2881 -2970 -2881 -2695 -2554 -2287 -1964 -2028 -2210 -2546 -2719 -2857 -3140 -3427 -3503 -3459 -2905 -2408 -1927 -1717 -1592 -1426 -1200 -1074 -1087 -1139 -905 -662 -420 -331 -311 -412 -452 -484 -573 -755 -872 -1014 -1062 -1030 -990 -973 -836 -852 -682 -614 -513 -359 -274 -375 -501 -618 -755 -1046 -1458 -1741 -1899 -1951 -1867 -1782 -1721 -1774 -1733 -1673 -1660 -1806 -1984 -2234 -2424 -2626 -2752 -2942 -3014 -3018 -3035 -3047 -3018 -3039 -2933 -2849 -2812 -2772 -2703 -2606 -2509 -2513 -2444 -2647 -2788 -2970 -3030 -3018 -2901 -2772 -2606 -2687 -2849 -3055 -3237 -3463 -3637 -3629 -3499 -3483 -3738 -4122 -4510 -4889 -5229 -5338 -5104 -4441 -3216 -2044 -1632 -1725 -2020 -2461 -3107 -3653 -3883 -3855 -3374 -2558 -1503 -577 254 1074 1806 2194 2182 2016 2198 2582 2970 2913 2731 2469 2287 2178 2129 1915 1624 1398 1374 1281 1034 788 654 650 594 626 634 509 408 311 177 -76 -480 -836 -1285 -1705 -2048 -2396 -2610 -2440 -2057 -1757 -1600 -1454 -1184 -953 -747 -533 -448 -327 -137 -16 -48 -323 -642 -860 -982 -1176 -1240 -1398 -1301 -1038 -856 -856 -759 -678 -614 -678 -727 -905 -994 -1022 -1099 -1289 -1551 -1770 -2125 -2562 -2877 -3043 -3067 -2946 -2804 -3010 -3233 -3463 -3580 -3689 -3806 -3859 -3762 -3810 -4053 -4635 -5350 -5799 -6243 -6542 -6466 -6045 -5035 -3928 -3362 -3431 -3479 -3730 -4211 -4566 -4651 -4772 -4627 -4081 -3253 -2331 -1402 -678 -117 157 12 -468 -743 -687 -400 -424 -735 -1357 -1923 -2505 -2853 -3269 -3637 -3988 -4154 -4207 -4392 -4732 -4914 -5055 -5071 -5043 -5100 -5100 -4885 -4752 -4627 -4691 -4841 -5035 -5079 -5144 -5035 -5067 -4861 -4344 -3790 -3281 -2877 -2533 -2242 -2077 -1863 -1790 -1628 -1337 -889 -509 -238 -153 -117 -88 68 185 290 408 731 1196 1660 2121 2457 2622 2622 2578 2372 2190 2141 2194 2400 2533 2537 2242 1871 1519 1159 472 258 707 1725 2905 3722 3746 3608 3208 2392 1503 1151 1208 1361 1923 2929 3697 4396 5358 6352 6813 6805 6639 6494 6526 6619 6571 6413 6041 5556 4950 4506 4029 3519 3136 2970 2679 2327 1814 1370 929 678 375 12 -303 -598 -763 -771 -1095 -1398 -1907 -2428 -2994 -3491 -3944 -4207 -4279 -4105 -3891 -3762 -3794 -3738 -3653 -3560 -3487 -3455 -3366 -3229 -3075 -2986 -3030 -2990 -2901 -2703 -2558 -2364 -2166 -1689 -1212 -957 -1139 -1632 -2315 -2865 -3293 -3625 -3782 -3701 -3132 -2024 -1305 -743 84 929 1228 990 537 509 541 889 1640 2505 2893 3055 3350 3608 3487 3390 3471 3867 4207 4295 4029 3653 3111 2655 2295 1927 1240 497 -266 -816 -1232 -1677 -2000 -1919 -1762 -1475 -1365 -1499 -1931 -2315 -2566 -2772 -3002 -3071 -3212 -3495 -4041 -4801 -5572 -5920 -6187 -6373 -6247 -5750 -4861 -3782 -2752 -1863 -1842 -2182 -2436 -3245 -4396 -4982 -5415 -5682 -5488 -5225 -5467 -5637 -5916 -6292 -6530 -6740 -7044 -7161 -6874 -6478 -6490 -6748 -7100 -7638 -8248 -8749 -9024 -9153 -9133 -8894 -8983 -9383 -9893 -10147 -10196 -10018 -9925 -9590 -9367 -9218 -9242 -9561 -10123 -10660 -11388 -12220 -12859 -13170 -13639 -14092 -14480 -15118 -15910 -16383 -16233 -15579 -14063 -11925 -9860 -7795 -5932 -4497 -4211 -4409 -4889 -5876 -6922 -7339 -7112 -6470 -5888 -5144 -4538 -4392 -4029 -3398 -2857 -2271 -1814 -1357 -1006 -973 -1273 -1818 -2562 -3326 -4344 -5310 -6138 -6688 -7027 -7229 -7318 -7690 -8381 -9080 -9909 -10685 -11327 -11970 -12487 -12661 -12245 -11246 -10406 -9695 -9153 -9076 -9691 -10709 -11542 -11820 -11356 -10091 -8466 -7193 -6518 -6369 -6809 -7092 -6615 -5467 -4510 -2626 1188 5039 6882 7767 9121 10535 11093 11174 10838 10426 10305 10180 9311 8022 6607 6158 6902 7900 8066 7941 8042 8369 8244 7233 5843 4728 3924 3390 3014 2174 602 -1050 -2416 -3483 -4295 -4918 -5185 -5043 -4724 -4797 -5318 -6114 -6870 -7318 -8171 -9230 -10228 -10596 -10588 -10277 -10079 -10285 -10523 -10733 -10810 -10628 -10693 -10850 -10677 -9885 -8741 -7686 -6979 -6219 -5185 -3839 -2776 -2154 -1907 -1721 -1547 -1212 -994 -897 -1119 -1410 -1499 -1357 -982 -581 -226 141 480 1010 1365 1422 1038 452 -145 -303 -529 -779 -1285 -1729 -2113 -2315 -2501 -2905 -3293 -3604 -3843 -4045 -4514 -5031 -5605 -6276 -7068 -7743 -8486 -9076 -9719 -10297 -10879 -11343 -12002 -12612 -13332 -14015 -14520 -14948 -15417 -15676 -15894 -15999 -16019 -15934 -15846 -15744 -15656 -15538 -15239 -14795 -14241 -13590 -13017 -12455 -12220 -11978 -11671 -11259 -10693 -9961 -9133 -8114 -7100 -5952 -4861 -3940 -3285 -2651 -2000 -1349 -755 -319 72 416 719 1038 1370 1669 2057 2424 2889 3483 4081 4603 4974 5290 5455 5512 5621 5750 5928 6284 6494 6708 6902 7108 7282 7448 7452 7460 7581 7920 8389 8886 9230 9731 10297 10774 11174 11384 11723 12168 12572 13105 13457 13659 13890 14027 14176 14245 14237 14415 14564 14843 15126 15264 15474 15676 15874 15999 16052 16233 16233 16250 16145 16108 16023 15922 15680 15405 15183 14997 14706 14609 14536 14496 14504 14451 14415 14439 14399 14480 14524 14564 14540 14653 14714 14811 14694 14544 14415 14346 14233 14108 13930 13776 13736 13675 13518 13283 13013 12879 12726 12600 12390 12297 12253 12152 12196 12305 12305 12305 12309 12317 12309 12350 12414 12447 12520 12665 12750 13037 13146 13372 13497 13704 13926 14132 14249 14435 14496 14512 14621 14807 14783 14815 14791 14932 15053 15215 15308 15369 15320 15482 15607 15660 15712 15700 15708 15805 15837 15785 15773 15728 15732 15720 15696 15761 15720 15639 15599 15652 15603 15571 15425 15389 15474 15308 15235 15150 15098 15130 15057 15053 14847 14730 14653 14593 14480 14374 14217 14096 14051 13966 13841 13752 13720 13683 13683 13712 13696 13691 13578 13607 13542 13510 13364 13364 13348 13340 13364 13530 13590 13639 13704 13784 13793 13877 13918 13922 13894 13954 13894 13906 13801 13708 13603 13611 13639 13506 13372 13332 13174 13178 13013 12952 12790 12722 12665 12645 12507 12431 12326 12330 12249 12144 12083 11934 11845 11760 11647 11542 11445 11287 11065 10939 10887 10786 10640 10507 10349 10305 10139 10026 9945 9864 9707 9670 9533 9404 9133 9064 8911 8664 8426 8337 8123 7953 7868 7743 7565 7541 7508 7464 7403 7334 7209 7161 7072 7011 6914 6898 6858 6789 6692 6627 6559 6482 6494 6429 6247 6158 6086 6017 5847 5686 5601 5435 5362 5257 5112 5116 5096 5071 5079 5047 5015 5011 4942 4817 4805 4793 4716 4716 4538 4461 4372 4364 4360 4295 4219 4227 4114 4110 3996 3883 3705 3629 3511 3487 3382 3354 3269 3317 3188 3075 2970 2873 2837 2711 2647 2590 2525 2489 2404 2444 2384 2364 2214 2113 2069 2057 1947 1822 1701 1669 1648 1588 1434 1394 1345 1277 1212 1167 1074 1111 1034 1046 1038 1054 957 945 860 836 763 723 662 695 699 682 638 630 549 472 331 327 222 117 4 -137 -387 -436 -602 -626 -747 -909 -1010 -909 -937 -957 -1002 -977 -986 -897 -917 -1034 -1135 -1083 -1042 -1046 -1196 -1176 -1268 -1297 -1301 -1297 -1341 -1329 -1402 -1434 -1503 -1547 -1612 -1620 -1725 -1709 -1786 -1798 -1927 -1871 -1887 -1879 -1875 -1838 -1931 -1887 -1891 -1846 -1850 -1875 -1964 -1907 -1923 -2008 -2020 -1988 -2044 -2121 -2202 -2194 -2275 -2275 -2295 -2218 -2279 -2307 -2343 -2339 -2408 -2372 -2440 -2428 -2335 -2251 -2279 -2170 -2061 -1996 -2036 -1996 -2016 -2073 -2133 -2101 -2162 -2295 -2339 -2444 -2533 -2659 -2788 -2820 -2841 -2812 -2861 -2925 -2946 -2917 -2942 -2938 -2994 -3022 -3002 -2986 -3075 -3026 -2982 -2962 -2938 -2946 -3018 -3035 -3063 -3035 -3051 -3047 -3091 -3192 -3285 -3330 -3362 -3358 -3443 -3439 -3560 -3633 -3681 -3718 -3726 -3746 -3883 -3851 -3810 -3778 -3972 -3928 -3827 -3871 -3895 -3875 -3891 -3883 -3940 -3964 -3984 -4008 -3984 -4013 -4077 -4045 -4105 -4089 -4029 -3980 -4025 -3916 -3948 -3810 -3661 -3592 -3528 -3447 -3374 -3245 -3261 -3261 -3273 -3172 -3184 -3164 -3127 -3002 -2913 -2816 -2812 -2780 -2760 -2841 -2958 -2946 -3010 -2921 -2873 -2808 -2905 -2933 -2901 -2893 -2913 -2942 -2893 -2929 -2893 -2800 -2804 -2748 -2727 -2792 -2784 -2776 -2816 -2845 -2837 -2752 -2792 -2796 -2703 -2675 -2703 -2679 -2683 -2638 -2626 -2562 -2602 -2473 -2372 -2271 -2238 -2186 -2149 -2117 -2081 -1988 -1968 -2020 -2052 -1972 -2016 -2061 -2081 -2073 -2194 -2210 -2238 -2210 -2259 -2230 -2198 -2182 -2162 -2081 -2004 -1891 -1887 -1947 -1955 -1923 -1846 -1907 -1976 -1964 -1988 -1935 -1955 -1939 -1923 -1919 -2028 -2036 -2048 -2065 -2081 -2057 -2077 -2081 -2065 -2012 -1972 -1935 -1923 -1867 -1854 -1838 -1782 -1757 -1721 -1725 -1725 -1652 -1741 -1701 -1717 -1762 -1770 -1685 -1689 -1648 -1628 -1527 -1600 -1612 -1620 -1608 -1596 -1572 -1555 -1495 -1515 -1475 -1410 -1361 -1349 -1248 -1208 -1151 -1042 -1115 -1058 -1066 -1099 -1022 -1103 -1095 -1139 -1135 -1159 -1155 -1167 -1216 -1240 -1208 -1192 -1171 -1188 -1163 -1127 -1087 -1115 -1135 -1079 -1014 -1014 -917 -1010 -941 -820 -711 -691 -715 -707 -634 -650 -590 -618 -719 -784 -723 -682 -723 -711 -594 -594 -533 -517 -480 -488 -456 -497 -444 -392 -400 -404 -230 -238 -270 -250 -222 -230 -185 -202 -210 -246 -254 -290 -270 -343 -347 -367 -424 -400 -379 -468 -347 -331 -335 -299 -262 -323 -250 -295 -278 -234 -177 -274 -307 -202 -185 -258 -222 -165 -181 -242 -181 -270 -319 -327 -392 -335 -274 -363 -359 -392 -400 -484 -456 -484 -408 -367 -387 -400 -383 -525 -480 -476 -400 -533 -553 -602 -654 -662 -662 -707 -759 -755 -731 -691 -682 -622 -585 -626 -537 -565 -585 -561 -585 -598 -533 -533 -525 -545 -513 -448 -383 -464 -525 -464 -533 -549 -533 -622 -594 -682 -695 -792 -739 -808)		samplingRate: 22050.! !!RulerMorph methodsFor: 'all'!drawOn: aCanvas	| s |	super drawOn: aCanvas.	s _ self width printString, 'x', self height printString.	aCanvas text: s bounds: (bounds insetBy: borderWidth + 5) font: nil color: Color red.! !!RulerMorph methodsFor: 'all'!initialize	super initialize.	self color: (Color r: 0.8 g: 1.0 b: 1.0).	self borderWidth: 1.! !My instances provide space-efficient storage of data which tends to be constant over long runs of the possible indices. Essentially repeated values are stored singly and then associated with a "run" length that denotes the number of consecutive occurrences of the value.My two important variables are	runs	An array of how many elements are in each run	values	An array of what the value is over those elementsThe variables lastIndex, lastRun and lastOffset cache the last accessso that streaming through RunArrays is not an N-squared process.Many complexities of access can be bypassed by using the method	RunArray withStartStopAndValueDo:!]style[(615 33)f1,f1LRunArray withStartStopAndValueDo:;!!RunArray methodsFor: 'accessing'!at: index	self at: index setRunOffsetAndValue: [:run :offset :value | ^value]! !!RunArray methodsFor: 'accessing'!runLengthAt: index 	"Answer the length remaining in run beginning at index."	self at: index 		setRunOffsetAndValue: [:run :offset :value | ^(runs at: run) - offset]! !!RunArray methodsFor: 'accessing' stamp: 'di 11/10/97 13:34'!withStartStopAndValueDo: aBlock	| start stop |	start _ 1.	runs with: values do:		[:len : val | stop _ start + len - 1.		aBlock value: start value: stop value: val.		start _ stop + 1]		! !!RunArray methodsFor: 'adding' stamp: 'tk 12/11/97 17:21'!coalesce	"Try to combine adjacent runs"	| ind |	ind _ 2.	[ind > values size] whileFalse: [		(values at: ind-1) = (values at: ind) 			ifFalse: [ind _ ind + 1]			ifTrue: ["two are the same, combine them"				values _ values copyReplaceFrom: ind to: ind with: #().				runs at: ind-1 put: (runs at: ind-1) + (runs at: ind).				runs _ runs copyReplaceFrom: ind to: ind with: #()]].			! !!RunArray methodsFor: 'copying'!copyFrom: start to: stop	| newRuns |	stop < start ifTrue: [^RunArray new].	self at: start setRunOffsetAndValue: [:run1 :offset1 :value1 | value1].	self at: stop setRunOffsetAndValue: [:run2 :offset2 :value2 | value2].	run1 = run2		ifTrue: 			[newRuns _ Array with: offset2 - offset1 + 1]		ifFalse: 			[newRuns _ runs copyFrom: run1 to: run2.			newRuns at: 1 put: (newRuns at: 1) - offset1.			newRuns at: newRuns size put: offset2 + 1].	^RunArray runs: newRuns values: (values copyFrom: run1 to: run2)! !!RunArray methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self class name.	aStream nextPutAll: ' runs: '.	runs printOn: aStream.	aStream nextPutAll: ' values: '.	values printOn: aStream.! !!RunArray methodsFor: 'printing' stamp: 'tk 12/16/97 09:18'!writeScanOn: strm	"Write out the format used for text runs in source files. (14 50 312)f1,f1b,f1LInteger +;i"	strm nextPut: $(.	runs do: [:rr | rr printOn: strm.  strm space].	strm skip: -1; nextPut: $).	values do: [:vv |		vv do: [:att | att writeScanOn: strm].		strm nextPut: $,].	strm skip: -1.  "trailing comma"! !!RunArray methodsFor: 'private'!mapValues: mapBlock	"NOTE: only meaningful to an entire set of runs"	values _ values collect: [:val | mapBlock value: val]! !!RunArray class methodsFor: 'instance creation' stamp: 'di 1/13/98 16:36'!scanFrom: strm	"Read the style section of a fileOut or sources file.  nextChunk has already been done.  We need to return a RunArray of TextAttributes of various kinds."	| rr vv aa this |	(strm peekFor: $( ) ifFalse: [^ nil].	rr _ OrderedCollection new.	[strm skipSeparators.	 strm peekFor: $)] whileFalse: 		[rr add: (Number readFrom: strm)].	vv _ OrderedCollection new.	"Value array"	aa _ OrderedCollection new.	"Attributes list"	[(this _ strm next) == nil] whileFalse: [		this == $, ifTrue: [vv add: aa asArray.  aa _ OrderedCollection new].		this == $f ifTrue: [aa add: (TextFontChange new fontNumber: (Number readFrom: strm))].		this == $b ifTrue: [aa add: (TextEmphasis bold)].		this == $i ifTrue: [aa add: (TextEmphasis italic)].		this == $u ifTrue: [aa add: (TextEmphasis underlined)].		this == $= ifTrue: [aa add: (TextEmphasis struckOut)].		this == $n ifTrue: [aa add: (TextEmphasis normal)].		this == $- ifTrue: [aa add: (TextKern kern: -1)].		this == $+ ifTrue: [aa add: (TextKern kern: 1)].		this == $c ifTrue: [aa add: (TextColor scanFrom: strm)]. "color"		this == $L ifTrue: [aa add: (TextLink scanFrom: strm)].	"L not look like 1"		this == $R ifTrue: [aa add: (TextURL scanFrom: strm)].	"R cap so it can follow a number"		this == $d ifTrue: [aa add: (TextDoIt scanFrom: strm)].		"space, cr do nothing"		].	aa size > 0 ifTrue: [vv add: aa asArray].	^ self runs: rr asArray values: vv asArray"RunArray scanFrom: (ReadStream on: '(14 50 312)f1,f1b,f1LInteger +;i')"! !RWBinaryOrTextStream class comment:'A simulation of a FileStream, but living totally in memory.  Need to be able to switch between binary and text, as a FileStream does, without recopying the whole collection.  Convert upon input and output.  Always keep as text internally.'!!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/25/97 13:22'!ascii	isBinary _ false! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/20/97 19:46'!binary	isBinary _ true! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/21/97 12:49'!contents	"Answer with a copy of my collection from 1 to readLimit."	| newArray |	isBinary ifFalse: [^ super contents].	"String"	readLimit _ readLimit max: position.	newArray _ ByteArray new: readLimit.	^ newArray replaceFrom: 1		to: readLimit		with: collection		startingAt: 1.! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'jm 11/4/97 08:25'!contentsOfEntireFile	"For compatibility with file streams."	^ self contents! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/20/97 19:47'!isBinary	^ isBinary! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 12/13/97 13:07'!next	| byte |	^ isBinary 			ifTrue: [byte _ super next.				 byte ifNil: [nil] ifNotNil: [byte asciiValue]]			ifFalse: [super next].! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/21/97 12:51'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override to get class right."	| newArray |	newArray _ (isBinary ifTrue: [ByteArray] ifFalse: [String]) new: anInteger.	1 to: anInteger do: [:index | newArray at: index put: self next].		"Could be done faster than this!!"	^newArray! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/20/97 07:38'!nextPut: charOrByte	super nextPut: charOrByte asCharacter! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/21/97 13:04'!reset	"Set the receiver's position to the beginning of the sequence of objects."	super reset.	isBinary ifNil: [isBinary _ false].	collection class == ByteArray ifTrue: ["Store as String and convert as needed."		collection _ collection asString.		isBinary _ true].! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/20/97 19:47'!text	isBinary _ false! !!SampledSound methodsFor: 'initialization' stamp: 'jm 1/5/98 17:50'!setPitch: p dur: d loudness: vol	"Used to play scores using the default sample table."	"(SampledSound pitch: 880.0 dur: 1.5 loudness: 0.6) play"	samples _ DefaultSampleTable.	samplesSize _ samples size.	initialCount _ (d * self samplingRate asFloat) rounded.	originalSamplingRate _		((self samplingRate asFloat * p asFloat) / NominalSamplePitch asFloat) asInteger.	self setLoudness: vol.	self initialVolume: vol.	self reset.! !!SampledSound methodsFor: 'initialization' stamp: 'jm 9/12/97 17:19'!setSamples: anArray	"There are two ways to use sampled sound: (a) you can play them through once (supported by this method) or (b) you can make them the default waveform with which to play a musical score (supported by the class method defaultSamplesFromAIFF:samplePitch:)."	"(SampledSound new setSamples: SampledSound coffeeCupClink) play"	self setSamples: anArray samplingRate: self samplingRate.! !!SampledSound methodsFor: 'initialization' stamp: 'jm 12/16/97 11:41'!setSamples: anArray samplingRate: rate	"Set my samples array to the given array with the given nominal sampling rate. Altering the rate parameter allows the sampled sound to be played back at different pitches."	"Assume: anArray is either a SoundBuffer or a collection of signed 16-bit sample values."	"(SampledSound		samples: SampledSound coffeeCupClink		samplingRate: 5000) play"	"copy the array into a SoundBuffer if necessary"	anArray class isWords		ifTrue: [samples _ anArray]		ifFalse: [samples _ SoundBuffer fromArray: anArray].	samplesSize _ samples size.	originalSamplingRate _ rate.	initialCount _ (samplesSize * self samplingRate) // originalSamplingRate.	self reset.! !!SampledSound methodsFor: 'accessing' stamp: 'jm 12/16/97 11:37'!duration	^ (initialCount / self samplingRate asFloat) rounded! !!SampledSound methodsFor: 'accessing' stamp: 'jm 12/16/97 11:38'!duration: seconds	initialCount _ (seconds * self samplingRate asFloat) rounded.! !!SampledSound methodsFor: 'accessing' stamp: 'jm 12/15/97 22:51'!originalSamplingRate	^ originalSamplingRate! !!SampledSound methodsFor: 'accessing' stamp: 'jm 9/12/97 16:46'!samples	^ samples! !!SampledSound methodsFor: 'playing' stamp: 'jm 1/5/98 18:30'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1."	| lastIndex sliceIndex sampleIndex sample i s |	<primitive: 182>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #samples declareC: 'short int *samples'.	lastIndex _ (startIndex + n) - 1.	sliceIndex _ startIndex.	sampleIndex _ indexTimes1000 // 1000.	[(sampleIndex <= samplesSize) and: [sliceIndex <= lastIndex]] whileTrue: [		sample _ ((samples at: sampleIndex) * scaledVol) // ScaleFactor.		leftVol > 0 ifTrue: [			i _ (2 * sliceIndex) - 1.			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i _ 2 * sliceIndex.			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0]].		indexTimes1000 _ indexTimes1000 + incrementTimes1000.		sampleIndex _ indexTimes1000 // 1000.		sliceIndex _ sliceIndex + 1].	count _ count - n.! !!SampledSound methodsFor: 'playing' stamp: 'jm 12/15/97 23:00'!reset	"Details: The increment amount is represented as 1000 * the increment value to allow fractional increments without having to do floating point arithmetic in the inner loop."	super reset.	incrementTimes1000 _		((originalSamplingRate asFloat / self samplingRate asFloat) * 1000.0) rounded.	count _ initialCount.	indexTimes1000 _ 1000.! !!SampledSound methodsFor: 'playing' stamp: 'jm 9/13/97 19:07'!samplesRemaining	^ count! !!SampledSound class methodsFor: 'class initialization' stamp: 'jm 10/18/97 14:19'!initialize	"SampledSound initialize"	self useCoffeeCupClink.	SoundLibrary _ Dictionary new.! !!SampledSound class methodsFor: 'instance creation' stamp: 'jm 1/7/98 16:09'!from16BitAIFFfileNamed: fileName samplingRate: anInteger	"Read a SampledSound from the 16-bit AIFF file of the given name. This method skips the header without parsing it; it assumes the file contains 16-bit uncompressed mono data. The headers of such AIFF files are 54 bytes."	"(SampledSound fromAIFFfileNamed: '1.aif' samplingRate: 8000) play"	| data |	data _ self raw16BitDataFromAIFFfileNamed: fileName.	^ self samples: data samplingRate: anInteger! !!SampledSound class methodsFor: 'instance creation' stamp: 'jm 9/13/97 10:39'!fromAIFFfileNamed: fileName	"Read a SampledSound from the AIFF file of the given name assuming a default sampling rate."	"(SampledSound fromAIFFfileNamed: '1.aif') play"	"| snd |	 FileDirectory default fileNames do: [:n |		(n endsWith: '.aif')			ifTrue: [				snd _ SampledSound fromAIFFfileNamed: n.				snd play.				SoundPlayer waitUntilDonePlaying: snd]]."	| data |	data _ self rawDataFromAIFFfileNamed: fileName.	data _ self convert8bitSignedTo16Bit: data.	^ self samples: data samplingRate: 11025! !!SampledSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 21:29'!fromAIFFfileNamed: fileName samplingRate: anInteger	"Read a SampledSound from the AIFF file of the given name. This method skips the header without parsing it; it assumes the file contains 8-bit uncompressed mono data as recorded by the shareware program SoundMachine 2.1. The headers of such AIFF files are 54 bytes."	"(SampledSound fromAIFFfileNamed: '1.aif' samplingRate: 8000) play"	| data |	data _ self rawDataFromAIFFfileNamed: fileName.	data _ self convert8bitSignedTo16Bit: data.	^ self samples: data samplingRate: anInteger! !!SampledSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 19:20'!samples: anArrayOf16BitSamples samplingRate: samplesPerSecond	"Return a SampledSound with the given samples array and sampling rate."	^ self new setSamples: anArrayOf16BitSamples samplingRate: samplesPerSecond! !!SampledSound class methodsFor: 'default sound' stamp: 'jm 9/17/97 13:10'!defaultSamples: anArray repeated: n	| data |	data _ WriteStream on: (SoundBuffer newMonoSampleCount: anArray size * n).	n timesRepeat: [		anArray do: [:sample | data nextPut: sample truncated]].	DefaultSampleTable _ data contents.! !!SampledSound class methodsFor: 'default sound' stamp: 'jm 9/12/97 19:17'!defaultSamplesFromAIFF: fileName samplePitch: aNumber	"Set the sample table to be used as the default waveform from the AIFF file of the given name. The sample pitch is an estimate of the normal pitch of the sampled sound."	"SampledSound defaultSamplesFromAIFF: 'boing.aiff' samplePitch: 200"	self defaultSampleTable: (self fromAIFFfileNamed: fileName) samples.	self nominalSamplePitch: aNumber.! !!SampledSound class methodsFor: 'default sound'!defaultSampleTable	"Return the sample table to be used as the default waveform for playing a score."	^ DefaultSampleTable! !!SampledSound class methodsFor: 'default sound' stamp: 'jm 9/17/97 12:49'!defaultSampleTable: anArray	"Set the sample table to be used as the default waveform for playing a score such as the Bach fugue. Array is assumed to contain monaural signed 16-bit sample values."	DefaultSampleTable _ SoundBuffer fromArray: anArray.! !!SampledSound class methodsFor: 'default sound'!nominalSamplePitch: aNumber	"Record an estimate of the normal pitch of the sampled sound."	NominalSamplePitch _ aNumber.! !!SampledSound class methodsFor: 'default sound' stamp: 'jm 9/12/97 19:38'!useCoffeeCupClink	"Set the sample table to be used as the default waveform to the sound of a coffee cup being tapped with a spoon."	"SampledSound useCoffeeCupClink bachFugue play"	self defaultSampleTable: self coffeeCupClink.	NominalSamplePitch _ 400.! !!SampledSound class methodsFor: 'coffee cup clink' stamp: 'jm 8/23/97 22:25'!coffeeCupClink	"Return the samples array for the sound of a spoon being tapped against a coffee cup."	CoffeeCupClink ifNil: [self initializeCoffeeCupClink].	^ CoffeeCupClink! !!SampledSound class methodsFor: 'coffee cup clink' stamp: 'jm 9/17/97 12:50'!initializeCoffeeCupClink	"Initialize the samples array for the sound of a spoon being tapped against a coffee cup."	"SampledSound initializeCoffeeCupClink"	| samples |	samples _ #(768 1024 -256 2304 -13312 26624 32512 19200 6400 -256 5888 32512 28928 32512 -32768 32512 -32768 18688 26368 -26112 32512 32512 2304 32512 5632 2816 10240 -4608 -1792 32512 32512 -5376 10752 32512 32512 32512 8192 15872 32512 -3584 -32768 -23296 -24832 -32768 -32768 -32768 -2304 32512 32512 -32768 32512 -15360 6400 8448 -18176 -32768 -256 -32768 -29440 9472 20992 17920 32512 32512 -256 32512 -32768 -32768 -23040 -32768 -25088 -32768 -27648 -1536 24320 -32768 32512 20480 27904 22016 16384 -32768 32512 -27648 -32768 -7168 28160 -6400 5376 32512 -256 32512 -7168 -11776 -19456 -27392 -24576 -32768 -24064 -19456 12800 32512 27136 2048 25344 15616 8192 -4608 -28672 -32768 -30464 -2560 17664 256 -8192 8448 32512 27648 -6144 -512 -7424 -18688 7936 -256 -22272 -14080 2048 27648 15616 -12288 -768 5376 3328 5632 3072 -6656 -20480 10240 27136 -10752 -11008 -768 -2048 6144 -7168 -3584 -1024 -7680 19712 26112 1024 -11008 3072 16384 -8960 -14848 -4864 -23808 -11264 12288 8192 7168 4864 23040 32512 512 -11776 -5632 -16896 -21504 -12800 -6144 -16896 -4352 32512 32512 23296 21760 5632 2816 -9472 -20992 -11264 -29440 -32768 -3584 7680 8448 15360 32512 32512 15616 15104 -2048 -27904 -27904 -25600 -12288 -12032 -13568 17152 22272 15360 30208 28160 7680 -5632 -8192 -16384 -31744 -25856 -10752 -3840 6656 13056 24320 26368 12800 20736 12288 -19200 -20992 -16640 -21504 -17920 -6912 8448 11264 14080 23040 18176 8192 -1024 0 256 -20992 -19712 -4608 -11264 -2048 14080 12032 8192 6912 13056 9216 -5632 -5376 -3840 -6656 -9984 -5632 4864 -3584 -1280 17408 7680 -1280 4096 2816 -1024 -4864 3328 8448 -768 -5888 -2048 5120 0 3072 11008 -7680 -15360 2560 6656 -3840 0 11776 7680 2816 1536 -1280 -3840 -8704 -1536 3584 -9728 -9728 11776 18688 7680 6656 6400 -4864 -3840 -256 -6912 -13312 -11264 2304 9728 1792 3328 18944 18432 6912 6144 -1536 -17664 -14336 -2304 -10496 -15616 -4096 9728 17152 14848 13312 11520 2304 -1024 2560 -8704 -26624 -18688 -256 -256 2816 14080 13824 12544 14080 9728 -512 -12032 -8960 -3328 -9984 -15872 -5120 8192 3584 10496 20224 7936 4608 6144 1280 -8704 -12800 -7424 -8448 -8960 -3840 7424 13056 8704 13312 13056 -2304 -4864 -768 -7168 -10496 -4608 -1536 -3072 -1280 6144 13312 11008 4864 4864 1536 -8960 -7680 1792 -4864 -7680 2816 5632 3328 2560 5376 7936 3584 -512 512 -4608 -9728 0 9216 768 -4096 7680 7168 256 4608 -768 -8704 -6400 2048 6144 -3072 -3328 6400 9472 3840 -768 1792 -3840 -5120 6144 768 -9984 -4352 5120 9472 6912 2816 1792 1280 768 512 -2816 -9728 -6912 6912 6912 -3328 -768 8448 11776 10752 3328 -6912 -10752 -8704 -1536 0 -6912 -3328 9984 13568 7424 6144 6656 256 0 256 -12032 -17920 -8192 3584 8960 4096 5632 12032 8704 6912 5632 -3584 -10496 -7936 -2048 -9216 -11776 2304 9472 15104 14848 5888 512 -2816 1024 2560 -9984 -13312 -5120 768 1792 768 8448 12032 11264 12800 -256 -11264 -9728 -2304 3072 -4352 -6912 256 2304 5376 9984 8192 2816 1280 3584 -2048 -11008 -8448 -2048 3072 4864 2304 3072 3072 3072 7168 3328 -5376 -4864 512 512 -1792 -1792 1792 5376 5888 5888 512 -5888 -3584 4096 3584 -6400 -4864 4608 3072 3840 5376 1024 768 2816 5888 -768 -12288 -7936 2304 5888 3328 2048 6144 3072 3072 6400 -3328 -7168 256 4096 -512 -9472 -6656 3328 6912 9216 8704 3840 -2560 -256 6656 -2560 -11264 -4608 -768 -1280 1536 3072 4096 5120 9984 11264 1024 -8192 -6144 -1024 -3840 -5632 -512 1024 2304 9728 9728 1280 512 4096 2816 -3584 -9984 -6912 -2304 512 5632 7680 3584 1024 5632 5888 -1280 -3584 -2304 -2560 -1536 -1024 -1792 -512 1536 7680 9984 2048 -2048 2048 3328 -1280 -4096 -3328 -4608 -1280 4352 3328 1280 1792 5120 6912 1024 -2560 0 -768 -1024 1280 -256 -4608 -1280 6400 5120 768 1792 2560 2048 0 -1536 -1280 -2304 1024 5376 2560 -2560 -512 4096 2048 512 768 -1280 -256 2560 2560 -256 -1024 768 3584 1280 -3328 -1536 1792 2816 3328 2304 -256 256 2816 2304 -1280 -3328 -1536 2304 2304 -256 -256 1024 1536 3840 5120 1024 -2048 0 1536 -768 -2560 -1792 256 2304 2048 1536 256 768 5888 6656 256 -3840 -2304 -1280 -1536 256 0 -512 2304 4352 3840 768 0 2304 3072 256 -3072 -2560 -2560 256 4608 2560 256 1536 3072 3072 1792 256 256 512 -256 -768 -1280 -1536 768 4352 2816 -512 768 2560 2560 2304 -256 -1792 -768 768 1792 256 -2304 -256 3328 3840 2304 2304 1536 256 2048 1024 -1536 -1792 -1024 512 256 -512 0 2304 4864 5120 4352 1024 -1280 0 -768 -2816 -2304 -512 1024 2048 2304 2048 3072 3840 2816 2048 -512 -3072 -1792 -1536 -1280 768 1280 1536 2304 2816 2048 1536 2048 1536 1536 -768 -3840 -2048 0 1280 2816 1792 1536 2560 3584 2816 1024 256 -768 -768 -1280 -2816 -768 1792 3328 5120 3072 1280 1536 1792 768 -1024 -1280 -1536 -768 512 256 1536 2560 2560 3328 1280 0 768 1536 768 -256 -512 -1536 -1280 768 1280 2304 2560 2560 2560 1024 -256 -512 0 1280 1536 768 -1280 -512 2048 1536 2048 1280 -256 256 512 768 768 1280 2304 1792 512 -1280 -1024 768 1536 1536 256 -768 1536 3584 3072 1792 -256 -1536 -512 256 -512 -512 768 2048 2048 1792 1280 1280 3072 2816 768 -1024 -2304 -1024 256 256 1280 1792 2304 2816 2304 1280 512 1024 768 -768 -1280 -1280 -512 1536 2560 2816 2048 512 1024 1792 1280 768 0 -768 -768 0 256 256 1280 2560 2304 2304 1536 512 512 1024 1280 0 -1792 -1536 -512 1280 3072 2816 1792 512 1024 1536 256 -256 768 768 256 256 -256 512 1280 1280 1536 768 1024 1792 1536 1024 0 256 -512 -256 1024 512 256 768 1792 2304 1280 256 768 1024 1280 1792 768 -768 -768 768 512 256 1024 1792 1536 1280 1536 1792 1280 768 512 -512 -1792 -512 512 768 2304 2816 1792 768 1536 2304 1536 0 -256 -256 -768 -768 256 1536 1536 2304 2048 256 768 2048 2304 1280 0 -256 -1024 -1024 0 1024 1792 2304 2304 1280 512 1280 2048 1280 256 -512 -1792 -1536 256 1536 1792 2048 2048 2048 1536 512 512 768 256 -256 0 -512 -1024 768 2048 2304 2304 1280 1280 1024 1024 1024 0 -512 256 768 0 -256 1536 2304 1792 2304 1280 -512 -256 768 1536 1024 256 512 512 1024 1792 1792 1536 1024 1280 0 -1280 256 2048 2560 2048 1024 -256 -256 1024 1280 1536 1024 0 0 256 768 1792 2304 2048 1280 1024 0 -512 -256 256 1024 1024 512 768 768 1280 2048 1792 1024 768 768 -256 -1024 0 256 1024 1536 1024 1280 1536 1792 1792 1024 512 512 0 -512 -256 512 768 1280 1280 1024 1280 1792 1792 1280 512 -256 -256 256 512 1280 1024 1280 1280 1024 1024 768 1024 1024 1024 1280 256 256 768 768 1024 512 256 768 1280 2560 2560 1280 512 -256 -512 -256 1024 1536 768 1024 1280 768 1024 1536 1536 1024 256 0 0 0 768 768 512 1280 1536 1280 1280 1280 1280 768 768 256 -256 768 768 256 768 1280 1792 1536 1536 1536 256 512 1024 0 -768 -256 768 512 1024 2048 1536 1024 1536 1536 768 0 0 -256).	CoffeeCupClink _ SoundBuffer fromArray: samples.! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 9/13/97 21:55'!addLibrarySoundNamed: aString fromAIFFfileNamed: fileName sampleRate: samplesPerSecond	"Add a sound from the given AIFF file to the library. The file is assumed to be 8-bits, mono, uncompressed."	"SampledSound addLibrarySoundNamed: 'shutterClick'		fromAIFFfileNamed: '7.aif'		sampleRate: 11025"	self addLibrarySoundNamed: aString		samples: (self rawDataFromAIFFfileNamed: fileName)		sampleRate: samplesPerSecond.! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 9/12/97 19:45'!addLibrarySoundNamed: aString samples: sampleData sampleRate: samplesPerSecond	"Add the given sound to the sound library. The sample data may be either a ByteArray or a SoundBuffer. If the former, it is take to be 8-bit unsigned samples (as from an AIFF file). If the latter, it is taken to be 16 bit signed samples."	SoundLibrary		at: aString		put: (Array with: sampleData with: samplesPerSecond).! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 12/15/97 14:29'!addLibrarySoundNamed: aString samples: sampleData samplingRate: samplesPerSecond	"Add the given sound to the sound library. The sample data may be either a ByteArray or a SoundBuffer. If the former, it is take to be 8-bit unsigned samples (as from an AIFF file). If the latter, it is taken to be 16 bit signed samples."	SoundLibrary		at: aString		put: (Array with: sampleData with: samplesPerSecond).! !!SampledSound class methodsFor: 'sound library' stamp: 'sw 10/20/97 17:10'!atSoundLibraryKey:  aString put: anObject	"SampledSound atSoundLibraryKey: 'no sound' put: nil"	SoundLibrary at: aString put: anObject! !!SampledSound class methodsFor: 'sound library' stamp: 'sw 9/19/97 18:58'!playSoundNamed: aString	"SampledSound playSoundNamed: 'croak'"	| aSound |	(aSound _ self soundNamed: aString) ifNotNil: [aSound play]! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 10/18/97 14:56'!putCoffeeCupClinkInSoundLibrary	"SampledSound putCoffeeCupClinkInSoundLibrary"	self addLibrarySoundNamed: 'clink'		samples: self coffeeCupClink		sampleRate: 11025! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 12/5/97 15:40'!readLibrarySoundsFromDisk	"Scan the current directory for .aif files, read them in, put them in the sound library"	"SampledSound readLibrarySoundsFromDisk "	 (FileDirectory default fileNamesMatching: '*.aif') do:		[:fileName |			self addLibrarySoundNamed: (fileName copyUpTo: $.)				fromAIFFfileNamed: fileName				sampleRate: 11025].! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 9/12/97 19:46'!removeSoundNamed: aString	"Remove the sound with the given name from the sound library."	SoundLibrary removeKey: aString ifAbsent: [].! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 10/23/97 11:05'!soundLibrary	"Return the sound library dictionary."	^ SoundLibrary! !!SampledSound class methodsFor: 'sound library' stamp: 'sw 10/20/97 17:03'!soundNamed: aString	"Return a list of sound names for the sounds stored in the sound library."	"(SampledSound soundNamed: 'shutterClick') play"	| entry samples |	entry _ SoundLibrary		at: aString		ifAbsent:			[self inform: aString, ' not found in the Sound Library'.			^ nil].	entry ifNil: [^ nil].	samples _ entry at: 1.	samples class isBytes ifTrue: [samples _ self convert8bitSignedTo16Bit: samples].	^ self samples: samples samplingRate: (entry at: 2)! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 11/2/97 17:44'!soundNames	"Return a list of sound names for the sounds stored in the sound library."	"SampledSound soundNames do: [:n | SampledSound playSoundNamed: n]"	^ SoundLibrary keys asArray! !!SampledSound class methodsFor: 'sound library' stamp: 'jhm 10/15/97 14:57'!unusedSoundNameLike: desiredName	"Pick an unused sound name based on the given string. If necessary, append digits to avoid name conflicts with existing sounds."	"SampledSound unusedSoundNameLike: 'chirp'"	| newName i |	newName _ desiredName.	i _ 2.	[SoundLibrary includesKey: newName] whileTrue: [		newName _ desiredName, i printString.		i _ i + 1].	^ newName! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/17/97 13:10'!convert8bitSignedTo16Bit: anArray	"Convert the given array of samples--assumed to be 8-bit signed, linear data--into 16-bit signed samples. Return an array containing the resulting samples. Typically used to read uncompressed AIFF sound data."	| n samples s |	n _ anArray size.	samples _ SoundBuffer newMonoSampleCount: n.	1 to: n do: [:i |		s _ anArray at: i.		s > 127 ifTrue: [s _ s - 256].		samples at: i put: (s * 256)].	^ samples! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 1/7/98 17:33'!raw16BitDataFromAIFFfileNamed: fileName	"Read a 16-bit SampledSound from the AIFF file of the given name. This method skips the header without parsing it; it assumes the file contains 16-bit uncompressed mono data as recorded by the shareware program SoundMachine 2.1. The headers of such AIFF files are 54 bytes."	| raw n data w src |	raw _ self rawDataFromAIFFfileNamed: fileName.	n _ raw size // 2.	data _ SoundBuffer newMonoSampleCount: n.	src _ 1.	1 to: n do: [:i |		w _ raw at: src.		w _ (w bitShift: 8) + (raw at: src + 1).		w > 32767 ifTrue: [w _ 65536 - w].		data at: i put: w.		src _ src + 2].	^ data! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/12/97 20:02'!rawDataFromAIFFfileNamed: fileName	"Read a SampledSound from the AIFF file of the given name. This method skips the header without parsing it; it assumes the file contains 8-bit uncompressed mono data as recorded by the shareware program SoundMachine 2.1. The headers of such AIFF files are 54 bytes."	"(SampledSound fromAIFFfileNamed: '1.aif') play"	| data f sz |	f _ (FileStream oldFileNamed: fileName) binary.	sz _ f size.	f skip: 54.  "skip AIFF header"	data _ (f next: sz - 54).	f close.	^ data! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/12/97 19:51'!readTrimmedSamplesFromAIFF: fileName	"Read samples from the given AIFF file and trim off leading and trailing silence."	| data first last i s |	data _ (FileStream oldFileNamed: fileName) binary contentsOfEntireFile.	first _ last _ nil.	i _ 55.	[(first == nil) and: [i < data size]] whileTrue: [		s _ data at: i.		s > 127 ifTrue: [s _ s - 256].		s abs > 10 ifTrue: [first _ i].		i _ i + 1].	first ifNil: [^ SoundBuffer new].  "all silence"	i _ data size.	[(last == nil) and: [i > first]] whileTrue: [		s _ data at: i.		s > 127 ifTrue: [s _ s - 256].		s abs > 10 ifTrue: [last _ i].		i _ i - 1].	^ self convert8bitSignedTo16Bit: (data copyFrom: first to: last)! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/17/97 13:11'!uLawDecode: aByteArray	"Convert the given array of uLaw-encoded 8-bit samples into a SoundBuffer of 16-bit signed samples."	| n out decodingTable |	n _ aByteArray size.	out _ SoundBuffer newMonoSampleCount: n.	decodingTable _ self uLawDecodeTable.	1 to: n do: [:i | out at: i put: (decodingTable at: (aByteArray at: i) + 1)].	^ out! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/13/97 16:41'!uLawDecodeTable	"Return a 256 entry table to be used to decode 8-bit uLaw-encoded samples."	"Details: This table was computed as follows:		| d encoded lastEncodedPos lastEncodedNeg |		d _ Array new: 256.		lastEncodedPos _ nil.		lastEncodedNeg _ nil.		4095 to: 0 by: -1 do: [:s |			encoded _ SampledSound uLawEncodeSample: s.			lastEncodedPos = encoded				ifFalse: [					d at: (encoded + 1) put: (s bitShift: 3).					lastEncodedPos _ encoded].			encoded _ encoded bitOr: 16r80.			lastEncodedNeg = encoded				ifFalse: [					d at: (encoded + 1) put: (s bitShift: 3) negated.					lastEncodedNeg _ encoded]].		d "	^ #(32760 31608 30584 29560 28536 27512 26488 25464 24440 23416 22392 21368 20344 19320 18296 17272 16248 15736 15224 14712 14200 13688 13176 12664 12152 11640 11128 10616 10104 9592 9080 8568 8056 7800 7544 7288 7032 6776 6520 6264 6008 5752 5496 5240 4984 4728 4472 4216 3960 3832 3704 3576 3448 3320 3192 3064 2936 2808 2680 2552 2424 2296 2168 2040 1912 1848 1784 1720 1656 1592 1528 1464 1400 1336 1272 1208 1144 1080 1016 952 888 856 824 792 760 728 696 664 632 600 568 536 504 472 440 408 376 360 344 328 312 296 280 264 248 232 216 200 184 168 152 136 120 112 104 96 88 80 72 64 56 48 40 32 24 16 8 0 -32760 -31608 -30584 -29560 -28536 -27512 -26488 -25464 -24440 -23416 -22392 -21368 -20344 -19320 -18296 -17272 -16248 -15736 -15224 -14712 -14200 -13688 -13176 -12664 -12152 -11640 -11128 -10616 -10104 -9592 -9080 -8568 -8056 -7800 -7544 -7288 -7032 -6776 -6520 -6264 -6008 -5752 -5496 -5240 -4984 -4728 -4472 -4216 -3960 -3832 -3704 -3576 -3448 -3320 -3192 -3064 -2936 -2808 -2680 -2552 -2424 -2296 -2168 -2040 -1912 -1848 -1784 -1720 -1656 -1592 -1528 -1464 -1400 -1336 -1272 -1208 -1144 -1080 -1016 -952 -888 -856 -824 -792 -760 -728 -696 -664 -632 -600 -568 -536 -504 -472 -440 -408 -376 -360 -344 -328 -312 -296 -280 -264 -248 -232 -216 -200 -184 -168 -152 -136 -120 -112 -104 -96 -88 -80 -72 -64 -56 -48 -40 -32 -24 -16 -8 0)! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/13/97 15:52'!uLawEncode: anArray	"Convert the given array of 16-bit signed samples into a ByteArray of uLaw-encoded 8-bit samples."	| n out s |	n _ anArray size.	out _ ByteArray new: n.	1 to: n do: [:i |		s _ anArray at: i.		s _ s bitShift: -3.  "drop 4 least significant bits"		s < 0			ifTrue: [s _ (self uLawEncodeSample: s negated) bitOr: 16r80]			ifFalse: [s _ (self uLawEncodeSample: s)].		out at: i put: s].	^ out! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/13/97 15:40'!uLawEncodeSample: s	"Encode the given 16-bit signed sample using the uLaw 8-bit encoding."	s < 496 ifTrue: [		s < 112 ifTrue: [			s < 48 ifTrue: [				s < 16					ifTrue: [^ 16r70 bitOr: (15 - s)]					ifFalse: [^ 16r60 bitOr: (15 - ((s - 16) bitShift: -1))]].			^ 16r50 bitOr: (15 - ((s - 48) bitShift: -2))].		s < 240			ifTrue: [^ 16r40 bitOr: (15 - ((s - 112) bitShift: -3))]			ifFalse: [^ 16r30 bitOr: (15 - ((s - 240) bitShift: -4))]].	s < 2032 ifTrue: [		s < 1008			ifTrue: [^ 16r20 bitOr: (15 - ((s - 496) bitShift: -5))]			ifFalse: [^ 16r10 bitOr: (15 - ((s - 1008) bitShift: -6))]].	s < 4080		ifTrue: [^ 15 - ((s - 2032) bitShift: -7)]		ifFalse: [^ 0].! !!Scanner methodsFor: 'multi-character scans'!xColon		"Allow := for assignment by converting to #_ "	aheadChar = $= ifTrue:		[self step.		tokenType _ #leftArrow.		self step.		^ token _ #_].	"Otherwise, just do what normal scan of colon would do"	tokenType _ #colon.	^ token _ self step asSymbol! !!Scanner methodsFor: 'multi-character scans' stamp: 'wod 1/10/98 00:43'!xDoubleQuote    "Collect a comment."    "wod 1/10/98: Allow 'empty' comments by testing the first characterfor $"" rather than blindly adding it to the comment being collected."    | aStream stopChar |    stopChar _ 30 asCharacter.    aStream _ WriteStream on: (String new: 200).    self step.    [hereChar == $"]        whileFalse:            [(hereChar == stopChar and: [source atEnd])                ifTrue: [^self offEnd: 'Unmatched comment quote'].            aStream nextPut: self step.].    self step.    currentComment == nil        ifTrue: [currentComment _ OrderedCollection with: aStreamcontents]        ifFalse: [currentComment add: aStream contents].    self scanToken! !!Scanner methodsFor: 'multi-character scans'!xLetter	"Form a word or keyword."	| type |	buffer reset.	[(type _ typeTable at: hereChar asciiValue) == #xLetter or: [type == #xDigit]]		whileTrue:			["open code step for speed"			buffer nextPut: hereChar.			hereChar _ aheadChar.			source atEnd				ifTrue: [aheadChar _ 30 asCharacter "doit"]				ifFalse: [aheadChar _ source next]].	(type == #colon or: [type = #xColon and: [aheadChar ~= $=]])		ifTrue: 			[buffer nextPut: self step.			tokenType _ #keyword]		ifFalse: 			[tokenType _ #word].	token _ buffer contents! !!Scanner class methodsFor: 'class initialization'!initialize	| newTable |	newTable _ Array new: 256 withAll: #xBinary. "default"	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"	newTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.	newTable atAll: ($A asciiValue to: $Z asciiValue) put: #xLetter.	newTable atAll: ($a asciiValue to: $z asciiValue) put: #xLetter.	newTable at: 30 put: #doIt.	newTable at: $" asciiValue put: #xDoubleQuote.	newTable at: $# asciiValue put: #xLitQuote.	newTable at: $$ asciiValue put: #xDollar.	newTable at: $' asciiValue put: #xSingleQuote.	newTable at: $: asciiValue put: #xColon.	newTable at: $( asciiValue put: #leftParenthesis.	newTable at: $) asciiValue put: #rightParenthesis.	newTable at: $. asciiValue put: #period.	newTable at: $; asciiValue put: #semicolon.	newTable at: $[ asciiValue put: #leftBracket.	newTable at: $] asciiValue put: #rightBracket.	newTable at: ${ asciiValue put: #leftBrace.	newTable at: $} asciiValue put: #rightBrace.	newTable at: $^ asciiValue put: #upArrow.	newTable at: $_ asciiValue put: #leftArrow.	newTable at: $| asciiValue put: #verticalBar.	TypeTable _ newTable "bon voyage!!"	"Scanner initialize"! !!Scanner class methodsFor: 'testing'!isLiteralSymbol: aSymbol 	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type |	i _ aSymbol size.	i = 0 ifTrue: [^ false].	i = 1 ifTrue: [('$''"()' includes: (aSymbol at: 1)) ifTrue: [^ false] ifFalse: [^ true]].	ascii _ (aSymbol at: 1) asciiValue.	"TypeTable should have been origined at 0 rather than 1 ..."	ascii = 0 ifTrue: [^ false].	type _ TypeTable at: ascii.	(type == #xColon or: [type == #verticalBar]) ifTrue: [^ i = 1].	type == #xBinary ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					(TypeTable at: ascii) == #xBinary ifFalse: [^ false].					i _ i - 1].			^ true].	type == #xLetter ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					type _ TypeTable at: ascii.					(type == #xLetter or: [type == #xDigit or: [type == #xColon]])						ifFalse: [^ false].					i _ i - 1].			^ true].	^ false! !!ScorePlayer methodsFor: 'initialization' stamp: 'jm 1/3/98 09:33'!initialize	score _ nil.	instruments _ Array new.	leftVols _ Array new.	rightVols _ Array new.	rate _ 1.0.! !!ScorePlayer methodsFor: 'initialization' stamp: 'jm 1/6/98 18:35'!onScore: aMIDIScore	| n |	score _ aMIDIScore.	n _ score tracks size.	instruments _ (1 to: n) collect: [:i | FMSound oboe1].	leftVols   _ Array new: n withAll: ScaleFactor // 8.	rightVols _ Array new: n withAll: ScaleFactor // 8.	rate _ 1.0.	tempo _ 120.0.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 1/4/98 11:00'!doControl	| t |	super doControl.	1 to: activeSounds size do: [:i | (activeSounds at: i) first doControl].	ticksSinceStart _ ticksSinceStart + ticksClockIncr.	t _ ticksSinceStart asInteger.	self processTempoMapAtTick: t.	self processEventsAtTick: t.	done _ self isDone.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 1/3/98 09:44'!isDone	| track |	activeSounds size > 0  ifTrue: [^ false].	1 to: score tracks size do: [:i |		track _ score tracks at: i.		(trackEventIndex at: i) <= track size ifTrue: [^ false]].	^ true! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 1/5/98 13:42'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a number of sounds concurrently. The level of each sound can be set independently for the left and right channels."	| someSoundIsDone pair snd trk left right |	someSoundIsDone _ false.	1 to: activeSounds size do: [:i |		pair _ activeSounds at: i.		snd _ pair at: 1.		trk _ pair at: 2.		left _ (leftVol * (leftVols at: trk)) // ScaleFactor.		right _ (rightVol * (rightVols at: trk)) // ScaleFactor.		snd samplesRemaining > 0			ifTrue: [				snd mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: left rightVol: right]			ifFalse: [someSoundIsDone _ true]].	someSoundIsDone ifTrue: [		activeSounds _ activeSounds select: [:p | p first samplesRemaining > 0]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 1/4/98 10:38'!processEventsAtTick: scoreTicks	| instr j snd |	1 to: score tracks size do: [:i |		instr _ instruments at: i.		j _ trackEventIndex at: i.		[snd _ score soundForTrack: i			after: j			ticks: scoreTicks			instrument: instr			secsPerTick: secsPerTick.		 snd ~~ nil]			whileTrue: [				activeSounds add: (Array with: snd with: i).				j _ j + 1.				trackEventIndex at: i put: j]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 1/4/98 11:14'!processTempoMapAtTick: scoreTicks	| map |	map _ score tempoMap.	map ifNil: [^ self].	[(tempoMapIndex <= map size) and:	 [(map at: tempoMapIndex) time <= scoreTicks]] whileTrue: [		tempo _ (120.0 * (500000.0 / (map at: tempoMapIndex) tempo)) roundTo: 0.01.		self tempoOrRateChanged.		tempoMapIndex _ tempoMapIndex + 1].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 1/4/98 10:43'!reset	super reset.	tempo _ 120.0.	self tempoOrRateChanged.	done _ false.	ticksSinceStart _ 0.	trackEventIndex _ Array new: score tracks size withAll: 1.	tempoMapIndex _ 1.	activeSounds _ OrderedCollection new.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 12/30/97 17:38'!samplesRemaining	done		ifTrue: [^ 0]		ifFalse: [^ 1000000].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:37'!instrumentForTrack: trackIndex	^ instruments at: trackIndex! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:38'!instrumentForTrack: trackIndex put: aSoundProto	instruments at: trackIndex put: aSoundProto.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:38'!panForTrack: i! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:38'!panForTrack: i put: aNumber! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:33'!rate	^ rate! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/4/98 10:07'!rate: aNumber	"Set the playback rate. For example, a rate of 2.0 will playback at twice normal speed."	rate _ aNumber asFloat.	self tempoOrRateChanged.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:33'!score	^ score! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/4/98 10:10'!tempo	"Return the current tempo in beats (quarter notes) per minute. The tempo at any given moment is defined by the score and cannot be changed by the client. To change the playback speed, the client may change the rate parameter."	^ tempo! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:35'!trackCount	^ score tracks size! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:36'!volumeForTrack: i! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:36'!volumeForTrack: i put: aNumber! !!ScorePlayer methodsFor: 'copying' stamp: 'jm 12/15/97 19:13'!copy	"Copy my component sounds."	^ super copy copySounds! !!ScorePlayer methodsFor: 'copying' stamp: 'jm 1/3/98 09:24'!copySounds	"Private!! Support for copying."	instruments _ instruments copy.	leftVols _ leftVols copy.	rightVols _ rightVols copy.	self reset.! !!ScorePlayer methodsFor: 'copying' stamp: 'jm 1/4/98 10:36'!tempoOrRateChanged	secsPerTick _ 60.0 / (tempo * rate * score ticksPerQuarterNote).	ticksClockIncr _ (1.0 / self controlRate) / secsPerTick.! !!ScreenController methodsFor: 'menu messages' stamp: 'di 1/13/98 22:45'!aboutThisSystem 	"Identify software version"	^ self inform: Smalltalk version! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 1/18/96'!browseChangedMessages	"Browse all methods in the current change set.  , "	ChangedMessageSet openFor: Smalltalk changes! !!ScreenController methodsFor: 'menu messages'!changeWindowPolicy	Preferences setPreference: #reverseWindowStagger		toValue: (Preferences valueOfFlag: #reverseWindowStagger) not! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/26/97 15:02'!chooseDirtyBrowser	"Put up a list of browsers with unsubmitted changes in them, and activate the one selected by the user if any"	"ScheduledControllers screenController chooseDirtyBrowser"	ScheduledControllers findWindowSatisfying:		[:contr |  (contr model isKindOf: Browser) and:			[contr model hasUnacceptedInput]]! !!ScreenController methodsFor: 'menu messages'!fastWindows	StandardSystemView cachingBits		ifTrue: [StandardSystemView dontCacheBits]		ifFalse: [StandardSystemView doCacheBits]! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 10/2/97 16:12'!indicateWindowsWithUnacceptedInput	"Put up a list of windows with unaccepted input, and let the user chose one to activate"	ScheduledControllers findWindowSatisfying:		[:contr |  contr model hasUnacceptedInput]! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 7/4/97 08:06'!openMorphicWorld 	"Create and schedule a StringHolderView for use as a workspace."	WorldMorph new open.! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 5/10/96'!setAuthorInitials	"Put up a dialog allowing the user to specify the author's initials.  "	Utilities setAuthorInitials! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 11/26/96'!setDesktopColor	"Let the user choose a new color for the desktop.   Based on an idea by Georg Gollmann.   "	Preferences desktopColor: Color fromUser.	ScheduledControllers updateGray; restore! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/28/97 16:18'!setDisplayDepth	"Let the user choose a new depth for the display. "	| result |	(result _ (SelectionMenu selections: #('1' '2' '4' '8' '16' '32')) startUpWithCaption: 'Choose a display depth') == nil ifFalse:		[Display newDepth: result asNumber]! !!ScreenController methodsFor: 'menu messages' stamp: 'ikp 1/13/98 03:29'!vmStatistics	"Open a string view on a report of vm statistics"	StringHolderView		open: (StringHolder new contents: Utilities vmStatisticsReportString)		label: 'VM Statistics'! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/28/97 16:01'!changesMenu	"Answer a menu for changes-related items.	sw 7/28/97 16:00 scott private, restore open changes sorter to here.  Dan doesn't want it here, so this is just for my personal version."	self flag: #scottPrivate.	ChangesMenu == nil ifTrue: 		[ChangesMenu _ SelectionMenu labelList:		#(	'file out changes'			'open changes sorter'			'browse changed methods'			'browse recent submissions'			'recent change log')		lines: #(1 4)		selections: #(fileOutChanges openChangeManager browseChangedMessages browseRecentSubmissions browseRecentLog)].	^ ChangesMenu"ScreenController new changesMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'ikp 1/13/98 03:27'!helpMenu	"Answer the help menu to be put up as a screen submenu"	HelpMenu == nil ifTrue:		[HelpMenu _ SelectionMenu labelList:		#(	'preferences...'			'about this system...'			'command-key help'			'useful expressions'			'set author initials...'			'set desktop color...'			'set display depth...'			'view GIF imports'			'space left'			'vm statistics'				)		lines: #(1 4 7)		selections: #(editPreferences  aboutThisSystem openCommandKeyHelp openStandardWorkspace setAuthorInitials setDesktopColor setDisplayDepth viewGIFImports garbageCollect vmStatistics)].	^ HelpMenu"ScreenController new helpMenu startUpScreenController initialize"! !!ScreenController methodsFor: 'nested menus' stamp: 'di 1/13/98 22:49'!openMenu	"Answer a menu for open-related items.  	 : useful expressions moved to help menu"	OpenMenu == nil ifTrue:		[OpenMenu _ SelectionMenu labelList:		#(	'open browser'			'open workspace'			'open file list'			'open change sorter'			'open project'			'open transcript'			'open system workspace'			'open Morphic world')		lines: #()		selections: #(openBrowser openWorkspace openFileList openChangeManager openProject openTranscript openSystemWorkspace openMorphicWorld)].	^ OpenMenu"ScreenController new openMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/23/96'!projectScreenMenu	"Answer the project screen menu.   	 : remove misc menu thing"	ProjectScreenMenu == nil ifTrue:		[ProjectScreenMenu _ SelectionMenu labelList:		#(	'exit project'			'restore display'			'open...'			'changes...'			'window...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit...')		lines: #(2 7)		selections: #(exitProject restoreDisplay openMenu changesMenu windowMenu helpMenu commonRequests  snapshot saveAs snapshotAndQuit quit)].	^ ProjectScreenMenu"ScreenController new projectScreenMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/24/96'!topScreenMenu	"Answer the screen menu for the top project, from whence there is no relevance to the 'exit project' item.  "	TopScreenMenu == nil ifTrue:		[TopScreenMenu _ SelectionMenu labelList:		#(	'restore display'			'open...'			'changes...'			'window...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit...')		lines: #(1 6)		selections: #( restoreDisplay openMenu changesMenu windowMenu helpMenu commonRequests  snapshot saveAs snapshotAndQuit quit)].	^ TopScreenMenu"ScreenController new newScreenMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 10/2/97 16:12'!windowMenu	"Answer a menu for windows-related items.  "	^ SelectionMenu labelList:		#(	'find window...'			'find changed browsers...'			'find changed windows...'			'collapse all windows'			'expand all windows'			'close unchanged windows') ,			(Array with: (StandardSystemView cachingBits							ifTrue: ['dont save bits (compact)']							ifFalse: ['save bits (fast)'])				with: ((Preferences valueOfFlag: #reverseWindowStagger)							ifTrue: ['tile windows']							ifFalse: ['stagger windows']))		lines: #(3 5 6)		selections: #(findWindow chooseDirtyBrowser indicateWindowsWithUnacceptedInput collapseAll expandAll closeUnchangedWindows fastWindows changeWindowPolicy)"ScreenController new windowMenu startUpScreenController initialize"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 5/8/96'!yellowButtonActivity	"Put up the alternate yellow button activity if appropriate, else defer to the old way.  2/7/96 sw	 : if shift key down, do find window.	 : project screen menu different from regular (top) screen menu"	| reply aMenu |	Sensor leftShiftDown ifTrue: [^ self findWindow].	aMenu _ self projectScreenMenu.	(reply _ aMenu startUp) isNil ifTrue: [^ super controlActivity].	(#(changesMenu helpMenu openMenu windowMenu miscMenu) includes: reply)		ifTrue:  "submenu called for"			[reply _ (self perform: reply) startUp.			reply == nil ifTrue: [^ super controlActivity]].	^ self perform: reply! !!ScreenController class methodsFor: 'class initialization' stamp: 'di 6/24/97 00:16'!initialize	"Initialize the screen menus.  Call this method to reset everything back to nil, so that the various menu retrieval methods will duly reinitialize them."	"ScreenController initialize"	ChangesMenu _ HelpMenu _ TopScreenMenu _ OpenMenu _ WindowMenu _ ProjectScreenMenu _ nil.! !ScreeningMorph comment:'ScreeningMorph uses its first submorph as a screen, and its second submorph as a source.  It also wants you to choose (when showing only the screen) the passing color in the screen.  It then makes up a 1-bit mask which clips the source, and displays transparently outside it.'!!ScreeningMorph methodsFor: 'initialization'!initialize	super initialize.	displayMode _ #showScreened! !!ScreeningMorph methodsFor: 'menu' stamp: 'di 11/4/97 09:03'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	submorphs size = 0 ifTrue:		[^ aCustomMenu add: '*Please add a source morph*' action: #itself].	submorphs size = 1 ifTrue:		[^ aCustomMenu add: '*Please add a screen morph*' action: #itself].	submorphs size > 2 ifTrue:		[^ aCustomMenu add: '*I have too many submorphs*' action: #itself].	aCustomMenu add: 'show screen only' action: #showScreenOnly.	aCustomMenu add: 'show source only' action: #showSourceOnly.	aCustomMenu add: 'show screen over source' action: #showScreenOverSource.	aCustomMenu add: 'show source screened' action: #showScreened.	aCustomMenu add: 'exchange source and screen' action: #exchange.	displayMode == #showScreenOnly ifTrue:		[aCustomMenu add: 'choose passing color' action: #choosePassingColor.		aCustomMenu add: 'choose blocking color' action: #chooseBlockingColor].! !!ScreeningMorph methodsFor: 'menu'!chooseBlockingColor	self mapColor: Color fromUser to: 0 othersTo: 16rFFFFFFFF! !!ScreeningMorph methodsFor: 'menu'!choosePassingColor	self mapColor: Color fromUser to: 16rFFFFFFFF othersTo: 0! !!ScreeningMorph methodsFor: 'menu'!exchange	submorphs swap: 1 with: 2.	self changed! !!ScreeningMorph methodsFor: 'menu'!showScreened	displayMode _ #showScreened.	self changed! !!ScreeningMorph methodsFor: 'menu'!showScreenOnly	displayMode _ #showScreenOnly.	self changed! !!ScreeningMorph methodsFor: 'menu'!showScreenOverSource	displayMode _ #showScreenOverSource.	self changed! !!ScreeningMorph methodsFor: 'menu'!showSourceOnly	displayMode _ #showSourceOnly.	self changed! !!ScreeningMorph methodsFor: 'drawing' stamp: 'di 7/17/97 10:09'!fullDrawOn: aCanvas	| mergeForm |	submorphs size = 2 ifFalse: [^ super fullDrawOn: aCanvas].	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	"self drawOn: aCanvas."	displayMode == #showScreenOnly ifTrue:		[self screenMorph fullDrawOn: aCanvas].	displayMode == #showSourceOnly ifTrue:		[self sourceMorph fullDrawOn: aCanvas].	screenForm ifNil:		[self mapColor: Color black to: 16rFFFFFFFF othersTo: 0].	displayMode == #showScreenOverSource ifTrue:		[self sourceMorph fullDrawOn: aCanvas.		aCanvas image: screenForm at: self position].	displayMode == #showScreened ifTrue:		[mergeForm _ self sourceMorph imageFormForRectangle: self bounds.		(BitBlt toForm: mergeForm) copyForm: screenForm to: 0@0 rule: Form and			colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		aCanvas image: mergeForm at: self position]! !!ScreeningMorph methodsFor: 'geometry'!containsPoint: aPoint	submorphs size = 2 ifFalse: [^ super containsPoint: aPoint].	^ self screenMorph containsPoint: aPoint! !!ScreeningMorph methodsFor: 'private'!mapColor: aColor to: pickValue othersTo: elseValue	| screenImage colorMap |	screenImage _ self screenMorph imageForm.	colorMap _ screenImage newColorMap atAllPut: elseValue.	colorMap at: (aColor indexInMap: colorMap) put: pickValue.	screenForm _ Form extent: screenImage extent.	screenForm copyBits: screenForm boundingBox			from: screenImage at: 0@0 colorMap: colorMap.	self changed.	self privateBounds: (screenImage offset extent: screenForm extent).	self changed! !!ScreeningMorph methodsFor: 'private'!screenMorph	^ submorphs at: 1! !!ScreeningMorph methodsFor: 'private'!sourceMorph	^ submorphs at: 2! !!ScreenshotAction methodsFor: 'URL processing' stamp: 'mjg 12/31/97 08:26'!process: request	FileDirectory default deleteFileNamed: 'screenshot.GIF'.	GIFReadWriter putForm: Display onFileNamed: 'screenshot.GIF'.	request reply: (PWS success), (PWS content: 'image/gif').	request reply: (FileStream fileNamed: 'screenshot.GIF') contentsOfEntireFile.! !!ScreenshotAction class methodsFor: 'setupForPWS' stamp: 'mjg 12/31/97 08:19'!setUp	PWS link: 'screenshot' to: ScreenshotAction new.! !ScrollBar comment:'Inspired by an oiginal design of Hans-Martin Mosner, this ScrollBar is intended to exercise the handling of input events in Morphic.  With sufficient flexibility in this area, all particular behavior can be concentrated in this single class with no need to specialize any other morphs to achieve button, slider and menu-button behavior.Once we have this working, put in logic for horizontal operation as well.'!!ScrollBar methodsFor: 'initialize'!initialize	super initialize.	scrollDelta _ 0.02.	pageDelta _ 0.2! !!ScrollBar methodsFor: 'initialize'!initializeDownButton	downButton := RectangleMorph		newBounds: (self innerBounds bottomRight - self buttonExtent extent: self buttonExtent)		color: Color lightGray.	downButton on: #mouseDown send: #borderInset to: downButton.	downButton on: #mouseStillDown send: #scrollDown to: self.	downButton on: #mouseUp send: #borderRaised to: downButton.	downButton addMorphCentered: (ImageMorph new image: 		(UpArrow rotateBy: (bounds isWide ifTrue: [#right] ifFalse: [#pi]) centerAt: 0@0)).	downButton setBorderWidth: 2 borderColor: #raised.	self addMorph: downButton! !!ScrollBar methodsFor: 'initialize'!initializeMenuButton	menuButton := RectangleMorph			newBounds: (self innerBounds topLeft extent: self buttonExtent)			color: Color lightGray.	menuButton on: #mouseEnter send: #menuButtonMouseEnter: to: self.	menuButton on: #mouseDown send: #menuButtonMouseDown: to: self.	menuButton on: #mouseLeave send: #menuButtonMouseLeave: to: self.	menuButton addMorphCentered:		(RectangleMorph newBounds: (0@0 extent: 4@2) color: Color black).	menuButton setBorderWidth: 2 borderColor: #raised.	self addMorph: menuButton! !!ScrollBar methodsFor: 'initialize'!initializePagingArea	pagingArea := RectangleMorph newBounds: self totalSliderArea								color: (Color r: 0.6 g: 0.6 b: 0.8).	pagingArea borderWidth: 0.	pagingArea on: #mouseDown send: #nextPage: to: self.	self addMorph: pagingArea! !!ScrollBar methodsFor: 'initialize'!initializeSlider	self initializeMenuButton; initializeUpButton; initializeDownButton; initializePagingArea.	super initializeSlider! !!ScrollBar methodsFor: 'initialize'!initializeUpButton	upButton := RectangleMorph		newBounds: ((bounds isWide ifTrue: [menuButton bounds topRight]									ifFalse: [menuButton bounds bottomLeft])					extent: self buttonExtent)		color: Color lightGray.	upButton on: #mouseDown send: #borderInset to: upButton.	upButton on: #mouseStillDown send: #scrollUp to: self.	upButton on: #mouseUp send: #borderRaised to: upButton.	upButton addMorphCentered: (ImageMorph new image: 		(bounds isWide ifTrue: [UpArrow rotateBy: #left centerAt: 0@0] ifFalse: [UpArrow])).	upButton setBorderWidth: 2 borderColor: #raised.	self addMorph: upButton! !!ScrollBar methodsFor: 'access'!interval: d	"Supply an optional floating fraction so slider can expand to indicate range"	interval _ d.	self computeSlider! !!ScrollBar methodsFor: 'access'!scrollDelta	^ scrollDelta! !!ScrollBar methodsFor: 'access'!scrollDelta: d1 pageDelta: d2	"Supply optional increments for better scrolling of, eg, text"	scrollDelta _ d1.	pageDelta _ d2.! !!ScrollBar methodsFor: 'geometry'!buttonExtent	^ bounds isWide		ifTrue: [9 @ self innerBounds height]		ifFalse: [self innerBounds width @ 9]! !!ScrollBar methodsFor: 'geometry'!computeSlider	super computeSlider.	interval ifNotNil: [self expandSlider]! !!ScrollBar methodsFor: 'geometry'!expandSlider	| r val2 |	val2 _ value + interval min: 1.0.	r _ self roomToMove.	slider extent: (bounds isWide		ifTrue: [((r width * (val2 - value)) asInteger + self sliderThickness) @ slider height]		ifFalse: [slider width @ ((r height * (val2 - value)) asInteger + self sliderThickness)])! !!ScrollBar methodsFor: 'geometry'!extent: p	p x > p y	ifTrue: [super extent: (p x max: 36) @ 16]	ifFalse: [super extent: 16 @ (p y max: 36)]! !!ScrollBar methodsFor: 'geometry'!totalSliderArea	^ bounds isWide		ifTrue: [upButton bounds topRight corner: downButton bounds bottomLeft]		ifFalse: [upButton bounds bottomLeft corner: downButton bounds topRight]! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 6/12/97 12:26'!nextPage: event	event cursorPoint >= slider topLeft		ifTrue: [self setValue: value + pageDelta]		ifFalse: [self setValue: value - pageDelta]! !!ScrollBar methodsFor: 'scrolling'!scrollDown	self setValue: value + scrollDelta! !!ScrollBar methodsFor: 'scrolling'!scrollUp	self setValue: value - scrollDelta! !!ScrollBar methodsFor: 'scrolling'!setValue: newValue	^ super setValue: (newValue + 0.0001 truncateTo: scrollDelta)! !!ScrollBar methodsFor: 'other events'!menuButtonMouseDown: event	event hand showTemporaryCursor: nil.	self use: menuSelector orMakeModelSelectorFor: 'MenuButtonPressed:'		in: [:sel | menuSelector _ sel.  model perform: sel with: event]! !!ScrollBar methodsFor: 'other events'!menuButtonMouseEnter: event	event hand showTemporaryCursor: Cursor menu! !!ScrollBar methodsFor: 'other events'!menuButtonMouseLeave: event	event hand showTemporaryCursor: nil! !!ScrollBar methodsFor: 'other events'!mouseDownInSlider	slider color: Color veryLightGray! !!ScrollBar methodsFor: 'other events'!mouseUpInSlider	slider color: Color lightGray! !!ScrollBar class methodsFor: 'class initialization'!initialize "ScrollBar initialize"	UpArrow _ Form		extent: 6@3		fromArray: #(2r11e28 2r1111e27 2r111111e26)		offset: 0@0.! !!ScrollController methodsFor: 'initialize-release'!initialize	super initialize.	scrollBar _ Quadrangle new.	scrollBar borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	marker _ Quadrangle new.	marker insideColor: Preferences scrollBarColor.	menuBar _ Quadrangle new.	menuBar borderWidthLeft:  2 right: 0 top: 2 bottom: 2.! !!ScrollController methodsFor: 'basic control sequence'!controlInitialize	"Recompute scroll bars.  Save underlying image unless it is already saved."	| |	super controlInitialize.	scrollBar region: (0 @ 0 extent: 24 @ view apparentDisplayBox height).	scrollBar insideColor: view backgroundColor.	marker region: self computeMarkerRegion.	scrollBar _ scrollBar align: scrollBar topRight with: view apparentDisplayBox topLeft.	marker _ marker align: marker topCenter with: self upDownLine @ (scrollBar top + 2).	savedArea isNil ifTrue: [savedArea _ Form fromDisplay: scrollBar].	scrollBar displayOn: Display.	"Show a border around yellow-button (menu) region""	yellowBar _ Rectangle left: self yellowLine right: scrollBar right + 1		top: scrollBar top bottom: scrollBar bottom.	Display border: yellowBar width: 1 mask: Form veryLightGray."	self moveMarker! !!ScrollController methodsFor: 'control defaults'!isControlActive 	view isNil ifTrue: [^ false].	^ (view insetDisplayBox merge: scrollBar inside)		containsPoint: sensor cursorPoint! !!ScrollController methodsFor: 'scrolling'!downLine	"if cursor before downLine, display down cursor and scroll down on button down"	^scrollBar left + 6 ! !!ScrollController methodsFor: 'scrolling'!scroll	"Check to see whether the user wishes to jump, scroll up, or scroll down."	| savedCursor |	savedCursor _ sensor currentCursor.			[self scrollBarContainsCursor]				whileTrue: 					[Processor yield.					sensor cursorPoint x <= self downLine								ifTrue: [self scrollDown]								ifFalse: [sensor cursorPoint x <= self upLine										ifTrue: [self scrollAbsolute]										ifFalse: [sensor cursorPoint x <= self yellowLine												ifTrue: [self scrollUp]												ifFalse: [sensor cursorPoint x <= scrollBar right														ifTrue: "Might not be, with touch pen"														[self changeCursor: Cursor menu.														sensor anyButtonPressed 														ifTrue: [self changeCursor: savedCursor. 																self anyButtonActivity]]]]]].	savedCursor show! !!ScrollController methodsFor: 'scrolling'!upDownLine	"Check to see whether the user wishes to jump, scroll up, or scroll down."	^scrollBar left + 12! !!ScrollController methodsFor: 'scrolling'!upLine	"if cursor beyond upLine, display up cursor and scroll up on button down"	^scrollBar left + 12! !!ScrollController methodsFor: 'scrolling'!yellowLine	"Check to see whether the user wishes to jump, scroll up, or scroll down."	^scrollBar left + 16! !!ScrollController methodsFor: 'marker adjustment'!computeMarkerRegion	"Answer the rectangular area in which the gray area of the scroll bar 	should be displayed."	^0@0 extent: Preferences scrollBarWidth @			((view window height asFloat /						view boundingBox height *							scrollBar inside height)				 rounded min: scrollBar inside height)! !!ScrollController methodsFor: 'marker adjustment'!markerRegion: aRectangle 	"Set the area defined by aRectangle as the marker. Fill it with gray tone."	Display fill: marker fillColor: scrollBar insideColor.	marker region: aRectangle.	marker _ marker align: marker topCenter 			with: self upDownLine @ (scrollBar top + 2) ! !ScrollingToolHolder comment:'Allows there to be a small number of displayed tool buttons, but a larger number of pictures that go in them.  You scroll across the possibilities.  For stamp tools in the PaintBox.  One picture is always kept blank, with new ones added as needed.'!!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 15:00'!clear	"wipe out all existing stamps"	stamps _ OrderedCollection new: 16.	thumbnailPics _ OrderedCollection new: 16.	stampButtons do: [:each | 		stamps addLast: nil.	"hold a space"		thumbnailPics addLast: nil].	start _ 1.	self normalize.! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 14:34'!normalize	"Correspondence between buttons and stamp forms has changed.  Make all thumbnails show up right."	| shrunkForm |	1 to: stampButtons size do: [:ind |		shrunkForm _ thumbnailPics atWrap: ind+start-1.		(stampButtons at: ind) offImage: shrunkForm; onImage: shrunkForm; 			pressedImage: shrunkForm.	"later modify them"		].! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 11:46'!otherButtonFor: aButton	"Find the corresponding button for either a pickup or a stamp button"	| ii |	(ii _ pickupButtons indexOf: aButton) > 0 ifTrue: [^ stampButtons at: ii].	(ii _ stampButtons indexOf: aButton) > 0 ifTrue: [^ pickupButtons at: ii].	self error: 'stamp button not found'.! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/16/97 19:22'!pickupButtons	^ pickupButtons! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 10:51'!pickupButtons: anArray	"Save the list of buttons that are for making a new stamp.  Left to right"	pickupButtons _ anArray! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 10/11/97 17:04'!remove: tool	"Remove a stamp.  Make this stamp blank.  OK to have a bunch of blank ones."	| which |	which _ stampButtons indexOf: tool ifAbsent: [				pickupButtons indexOf: tool ifAbsent: [^ self]].	stamps atWrap: which+start-1 put: nil.	thumbnailPics atWrap: which+start-1 put: nil.	self normalize.	"show them"! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 14:37'!scroll: amt	"Move the stamps over"	start _ start - 1 + amt \\ stamps size + 1.	self normalize.	"show them"! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/16/97 19:22'!stampButtons	^ stampButtons! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 10/11/97 10:21'!stampButtons: anArray	"Pop in a new list of buttons that are the tools for stamping.  Left to right"	stampButtons _ anArray.	self clear.! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/17/97 09:59'!stampForm: stampForm for: aPickupButton	"Install this form to stamp. Find its index.  Make a thumbnail."	| which scale shrunkForm stampBtn mini |	which _ pickupButtons indexOf: aPickupButton.	which = 0 ifTrue: [which _ stampButtons indexOf: aPickupButton].	stamps atWrap: which+start-1 put: stampForm.	"Create the thumbnail"	stampBtn _ stampButtons at: which.	scale _ stampBtn width / (stampForm extent x max: stampForm extent y).	scale _ scale min: 1.0.	"do not expand it"	mini _ stampForm magnify: stampForm boundingBox by: scale smoothing: 1.	shrunkForm _ mini class extent: stampBtn extent depth: stampForm depth.	mini displayOn: shrunkForm at: (stampBtn extent - mini extent)//2.	thumbnailPics atWrap: which+start-1 put: shrunkForm.	stampBtn offImage: shrunkForm; onImage: shrunkForm; pressedImage: shrunkForm.		"Emphasis is done by border of enclosing layoutMorph, not modifying image"	(stamps indexOf: nil) = 0 ifTrue: ["Add an extra blank place"		"Keep stamp we just installed in the same location!!"		start+which-1 > stamps size ifTrue: [start _ start + 1].		stamps addLast: nil.		thumbnailPics addLast: nil.		self normalize].! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 14:04'!stampFormFor: aButton	| which |	which _ stampButtons indexOf: aButton ifAbsent: [1].	^ stamps atWrap: which+start-1! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'jm 7/28/97 11:54'!updateReferencesUsing: aDictionary	"Fix up the Morphs I own"	"Note: Update this method when adding new inst vars that could contain Morphs."	stampButtons _ stampButtons collect:		[:old | aDictionary at: old ifAbsent: [old]].	pickupButtons _ pickupButtons collect:		[:old | aDictionary at: old ifAbsent: [old]].! !!ScrollPane methodsFor: 'initialization'!fullCopy	| copy |	self mouseEnter.          "Make sure scrollBar is in morphic structure"	copy _ super fullCopy.  "So that references are updated properly"	self mouseLeave.	^ copy mouseLeave! !!ScrollPane methodsFor: 'initialization'!initialize	| |	super initialize.	borderWidth _ 2.  borderColor _ #inset.	retractableScrollBar _ scrollBarOnLeft _ true.	scrollBar := ScrollBar new model: self slotName: 'scrollBar'.	scrollBar borderWidth: 2; borderColor: #inset.	retractableScrollBar ifFalse: [self addMorph: scrollBar].	scroller := TransformMorph new color: Color transparent.	scroller offset: -3@0.	self addMorph: scroller.	self on: #mouseEnter send: #mouseEnter to: self.	self on: #mouseLeave send: #mouseLeave to: self.	self extent: 150@120! !!ScrollPane methodsFor: 'access'!colorForInsets	"My submorphs use the surrounding color"	^ owner color! !!ScrollPane methodsFor: 'access' stamp: '6/6/97 13:37 di'!paneColor: aColor	self color: aColor! !!ScrollPane methodsFor: 'access'!scroller	^ scroller! !!ScrollPane methodsFor: 'access' stamp: '6/7/97 10:42 di'!wantsSlot	"For now do it the old way, until we sort this out"	^ true! !!ScrollPane methodsFor: 'geometry'!containsPoint: aPoint	(super containsPoint: aPoint) ifTrue: [^ true].	"Also include scrollbar when it is extended..."	^ (retractableScrollBar and: [submorphs includes: scrollBar]) and:		[scrollBar containsPoint: aPoint]! !!ScrollPane methodsFor: 'geometry'!extent: newExtent	super extent: (newExtent max: 16@36).	self resizeScrollBar; resizeScroller! !!ScrollPane methodsFor: 'geometry' stamp: '6/6/97 11:59 di'!resizeScrollBar	| d | d _ retractableScrollBar ifTrue: [14@0] ifFalse: [0@0].	scrollBar bounds: (scrollBarOnLeft		ifTrue: [bounds topLeft - d extent: 16 @ bounds height]		ifFalse: [bounds topRight - (16@0) + d extent: 16 @ bounds height])! !!ScrollPane methodsFor: 'geometry'!resizeScroller	| d inner |	d _ retractableScrollBar ifTrue: [16@0] ifFalse: [0@0].	inner _ self innerBounds.	scroller bounds: (scrollBarOnLeft		ifTrue: [inner topLeft + (16@0) - d corner: inner bottomRight]		ifFalse: [inner topLeft corner: inner bottomRight - (16@0) + d])! !!ScrollPane methodsFor: 'geometry'!totalScrollRange	^ (scroller submorphBounds encompass: 0@0) height - (bounds height // 2) max: 0! !!ScrollPane methodsFor: 'retractable scroll bar'!mouseEnter	(retractableScrollBar and: [(submorphs includes: scrollBar) not])		ifTrue: [self resizeScrollBar.				self privateAddMorph: scrollBar atIndex: 1]! !!ScrollPane methodsFor: 'retractable scroll bar'!mouseLeave	retractableScrollBar ifTrue: [self privateRemoveMorph: scrollBar]! !!ScrollPane methodsFor: 'scroll bar events'!scrollBarMenuButtonPressed: event	self use: menuSelector orMakeModelSelectorFor: 'MenuButtonPressed:'		in: [:sel | menuSelector _ sel.  model perform: sel with: event]! !!ScrollPane methodsFor: 'scroll bar events'!scrollBarValue: scrollValue	scroller hasSubmorphs ifFalse: [^ self].	scroller offset: -3 @ (self totalScrollRange * scrollValue)! !!ScrollPane methodsFor: 'menu' stamp: 'di 11/14/97 09:07'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	retractableScrollBar		ifTrue: [aCustomMenu add: 'make scrollbar inboard' action: #retractableOrNot]		ifFalse: [aCustomMenu add: 'make scrollbar retractable' action: #retractableOrNot].	scrollBarOnLeft		ifTrue: [aCustomMenu add: 'scroll bar on right' action: #leftOrRight]		ifFalse: [aCustomMenu add: 'scroll bar on left' action: #leftOrRight]! !!ScrollPane methodsFor: 'menu' stamp: 'di 11/14/97 09:09'!leftOrRight  "Change scroll bar location"	scrollBarOnLeft _ scrollBarOnLeft not.	self extent: self extent! !!ScrollPane methodsFor: 'menu' stamp: 'di 11/14/97 09:14'!retractableOrNot  "Change scroll bar operation"	retractableScrollBar _ retractableScrollBar not.	retractableScrollBar		ifTrue: [self privateRemoveMorph: scrollBar]		ifFalse: [(submorphs includes: scrollBar) 					ifFalse: [self privateAddMorph: scrollBar atIndex: 1]].	self extent: self extent! !!SegmentScanner methodsFor: 'all' stamp: 'di 11/26/97 21:23'!setFont	super setFont.	stopConditions at: Character space asciiValue + 1 put: nil.! !!SelectionMenu methodsFor: 'basic control sequence'!invokeOn: targetObject	"Pop up this menu and return the result of sending to the target object	 the selector corresponding to the menu item selected by the user. Return	 nil if no item is selected."	| sel |	sel _ self startUp.	sel = nil ifFalse: [^ targetObject perform: sel].	^ nil"(SelectionMenu labels:'sincosneg' lines: #() selections: #(sin cos negated)) invokeOn: 0.7"! !!SelectionMenu methodsFor: 'marker management'!manageMarker	"Returns the selected item. If no selection, return nil."	super manageMarker.	(selections = nil or: [(selection between: 1 and: selections size) not])		ifTrue: [^ nil].	^ selections at: selection! !!SelectionMenu class methodsFor: 'instance creation'!confirm: queryString 	"Put up a yes/no menu with caption queryString. Answer true if the response is yes, false if no. This is a modal question--the user must respond yes or no."	"SelectionMenu confirm: 'Are you hungry?'"	| menu choice |	menu _ self selections: #('yes' 'no').	[true] whileTrue: [		choice _ menu startUpWithCaption: queryString.		choice = 'yes' ifTrue: [^ true].		choice = 'no' ifTrue: [^ false]]! !!SelectionMenu class methodsFor: 'instance creation'!labels: aString lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray. Record the given array of selections	corresponding to the items in labelsArray."	^ (self labels: aString lines: linesArray) selections: selectionsArray! !!SelectionMenu class methodsFor: 'instance creation'!labels: aString selections: selectionsArray	"Answer an instance of me whose items are in aString, recording	 the given array of selections corresponding to the items in aString."	^ self labels: aString lines: #() selections: selectionsArray! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sw 6/27/96'!selections: aList	"Answer an instance of me whose labels and selections are identical.  "	^ self labelList: aList lines: nil selections: aList! !!SelectionMenu class methodsFor: 'instance creation'!selections: aList lines: lineList	"Answer an instance of me whose labels and selections are identical"	^ self labelList: aList lines: lineList selections: aList! !!SelectorNode methodsFor: 'code generation'!emit: stack args: nArgs on: aStream super: supered	| index |	stack pop: nArgs.	(supered not and: [code - Send < SendLimit and: [nArgs < 3]]) ifTrue:		["short send"		code < Send			ifTrue: [^ aStream nextPut: code "special"]			ifFalse: [^ aStream nextPut: nArgs * 16 + code]].	index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].	(index <= 31 and: [nArgs <= 7]) ifTrue: 		["extended (2-byte) send [131 and 133]"		aStream nextPut: SendLong + (supered ifTrue: [2] ifFalse: [0]).		^ aStream nextPut: nArgs * 32 + index].	(supered not and: [index <= 63 and: [nArgs <= 3]]) ifTrue:		["new extended (2-byte) send [134]"		aStream nextPut: SendLong2.		^ aStream nextPut: nArgs * 64 + index].	"long (3-byte) send"	aStream nextPut: DblExtDoAll.	aStream nextPut: nArgs + (supered ifTrue: [32] ifFalse: [0]).	aStream nextPut: index! !!SelectorNode methodsFor: 'code generation'!size: encoder args: nArgs super: supered	| index |	self reserve: encoder.	(supered not and: [code - Send < SendLimit and: [nArgs < 3]])		ifTrue: [^1]. "short send"	(supered and: [code < Send]) ifTrue: 		["super special:"		code _ self code: (encoder litIndex: key) type: 5].	index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].	(index <= 31 and: [nArgs <= 7])		ifTrue: [^ 2]. "medium send"	(supered not and: [index <= 63 and: [nArgs <= 3]])		ifTrue: [^ 2]. "new medium send"	^ 3 "long send"! !!Semaphore methodsFor: 'communication' stamp: 'jm 9/15/97 17:11'!waitTimeoutMSecs: anInteger	"Wait on this semaphore for up to the given number of milliseconds, then timeout. It is up to the sender to determine the difference between the expected event and a timeout."	| d |	d _ Delay timeoutSemaphore: self afterMSecs: (anInteger max: 0).	self wait.	d unschedule.! !!Semaphore methodsFor: 'communication' stamp: 'jm 9/12/97 11:39'!waitTimeoutSeconds: anInteger	"Wait on this semaphore for up to the given number of seconds, then timeout. It is up to the sender to determine the difference between the expected event and a timeout."	self waitTimeoutMSecs: anInteger * 1000.! !!SequenceableCollection methodsFor: 'accessing'!allButFirst	^ self copyFrom: 2 to: self size! !!SequenceableCollection methodsFor: 'accessing'!allButLast	^ self copyFrom: 1 to: self size - 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 7/13/97 09:49'!atAll: indexArray	"Return the selected elements in order"	^ indexArray collect: [:i | self at: i]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 7/13/97 09:50'!atAll: indexArray putAll: valueArray	"Store the elements of valueArray into the slots	of this collection selected by indexArray."	indexArray with: valueArray do:		[:i :x | self at: i put: x]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 10/3/97 13:42'!fifth	"Answer the fifth element of the receiver. Create an error notification if 	the receiver contains fewer than four elements."	^ self at: 5 ifAbsent: [self break]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 9/11/97 12:04'!fourth	"Answer the fourth element of the receiver. Create an error notification if 	the receiver contains fewer than four elements."	^ self at: 4 ifAbsent: [self break]! !!SequenceableCollection methodsFor: 'accessing'!indexOf: anElement startingAt: start ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	start to: self size do:		[:i | (self at: i) = anElement ifTrue: [^ i]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 8/7/97 16:33'!second	"Answer the second element of the receiver. Create an error notification if 	the receiver contains fewer than two elements."	^ self at: 2 ifAbsent: [self break]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 7/28/97 17:14'!smartInspect	"Like inspect, but for collections with only one element, inspects that element"	^ self size == 1		ifTrue:			[self first smartInspect]		ifFalse:			[self inspect]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 9/11/97 12:04'!third	"Answer the third element of the receiver. Create an error notification if 	the receiver contains fewer than three elements."	^ self at: 3 ifAbsent: [self break]! !!SequenceableCollection methodsFor: 'copying' stamp: 'di 1/16/98 16:40'!, otherCollection 	"Concatenate two Strings or Collections."		^ self copyReplaceFrom: self size + 1		  to: self size		  with: otherCollection"#(2 4 6 8) , #(who do we appreciate)((2989 printStringBase: 16) copyFrom: 4 to: 6) , ' boy!!'"! !!SequenceableCollection methodsFor: 'copying'!copyAt: anIndex put: anElement	"Answer a copy of the receiver with anElement inserted at anIndex."	^ self copyReplaceFrom: anIndex to: anIndex with: (Array with: anElement)! !!SequenceableCollection methodsFor: 'copying' stamp: 'ward 7/28/97 14:33'!shuffled	| copy |  "($A to: $Z) shuffled"	copy _ self shallowCopy.	copy size to: 1 by: -1 do: 		[:i | copy swap: i with: (1 to: i) atRandom].	^ copy! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 7/30/97 12:41'!asDigitsToPower: anInteger do: aBlock	"Repeatedly value aBlock with a single Array.  Adjust the collection	so that aBlock is presented all (self size raisedTo: anInteger) possible 	combinations of the receiver's elements taken as digits of an anInteger long number."	"(0 to: 1) asDigitsToPower: 4 do: [:each | Transcript cr; show: each printString]"	| aCollection |	aCollection _ Array new: anInteger.	self asDigitsAt: 1 in: aCollection do: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:44'!collectWithIndex: elementAndIndexBlock	"Use the new version with consistent naming"	^ self withIndexCollect: elementAndIndexBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 7/30/97 12:52'!combinations: kk atATimeDo: aBlock	"Take the items in the receiver, kk at a time, and evaluate the block for each combination.  Hand in an array of elements of self as the block argument.  Each combination only occurs once, and order of the elements does not matter.  There are (self size take: kk) combinations."	" 'abcde' combinations: 3 atATimeDo: [:each | Transcript cr; show: each printString]"	| aCollection |	aCollection _ Array new: kk.	self combinationsAt: 1 in: aCollection after: 0 do: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:43'!doWithIndex: elementAndIndexBlock	"Use the new version with consistent naming"	^ self withIndexDo: elementAndIndexBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sw 12/23/96'!pairsDo: aBlock 	"March through the receiver two elements at a time.  If there's an odd number of items, ignore the last one.  Allows use of a flattened array for things that naturally group into pairs.  "	| i |	1 to: self size // 2 do:		[:index |			i _ 2 * index - 1.			 aBlock value: (self at: i) value: (self at: i + 1)]"#(1 'fred' 2 'charlie' 3 'elmer') pairsDo:	[:a :b | Transcript cr; show: b, ' is number ', a printString]"! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ward 7/28/97 09:41'!permutationsDo: aBlock	"Repeatly value aBlock with a single copy of the receiver. Reorder the copy	so that aBlock is presented all (self size factorial) possible permutations."	"(1 to: 4) permutationsDo: [:each | Transcript cr; show: each printString]"	self shallowCopy permutationsStartingAt: 1 do: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:30'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."	| result |	result _ self species new: self size.	1 to: self size do:		[:index | result at: index put:		(twoArgBlock			value: (self at: index)			value: (otherCollection at: index))].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:32'!with: otherCollection do: twoArgBlock 	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection."	1 to: self size do:		[:index |		twoArgBlock value: (self at: index)				value: (otherCollection at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:35'!withIndexCollect: elementAndIndexBlock 	"Just like with:collect: except that the iteration index supplies the second argument to the block."	| result |	result _ self species new: self size.	1 to: self size do:		[:index | result at: index put:		(elementAndIndexBlock			value: (self at: index)			value: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:35'!withIndexDo: elementAndIndexBlock 	"Just like with:do: except that the iteration index supplies the second argument to the block."	1 to: self size do:		[:index |		elementAndIndexBlock			value: (self at: index)			value: index]! !!SequenceableCollection methodsFor: 'converting' stamp: 'di 7/7/97 09:51'!reversed	"Answer a copy of the receiver with element order reversed."	| reversal strm |	reversal _ self species new: self size.	strm _ WriteStream on: reversal.	self reverseDo: [:elem | strm nextPut: elem].	^ reversal" 'frog' reversed "! !!SequenceableCollection methodsFor: 'private' stamp: 'tk 7/30/97 12:42'!asDigitsAt: anInteger in: aCollection do: aBlock	"(0 to: 1) asDigitsToPower: 4 do: [:each | Transcript cr; show: each printString]"	self do: 		[:each | 		aCollection at: anInteger put: each.		anInteger = aCollection size 			ifTrue: [aBlock value: aCollection]			ifFalse: [self asDigitsAt: anInteger + 1 in: aCollection do: aBlock]].! !!SequenceableCollection methodsFor: 'private' stamp: 'tk 7/30/97 12:42'!combinationsAt: jj in: aCollection after: nn do: aBlock	"Choose k of N items and put in aCollection.  jj-1 already chosen.  Indexes of items are in numerical order, to avoid the same combo being used twice.  In this slot, we are allowed to use items in self indexed by nn+1 to self size.  nn is the index used for position jj-1."	"(1 to: 6) combinationsSize: 3 do: [:each | Transcript cr; show: each printString]"nn+1 to: self size do: [:index | 		aCollection at: jj put: (self at: index).		jj = aCollection size 			ifTrue: [aBlock value: aCollection]			ifFalse: [self combinationsAt: jj + 1 in: aCollection after: index do: aBlock]].! !!SequenceableCollection methodsFor: 'private' stamp: 'tk 1/7/98 10:57'!copyReplaceAll: oldSubstring with: newSubstring asTokens: ifTokens	"Answer a copy of the receiver in which all occurrences of	oldSubstring have been replaced by newSubstring.	ifTokens (valid for Strings only) specifies that the characters	surrounding the recplacement must not be alphanumeric.		Bruce Simth,  must be incremented by 1 and not 	newSubstring if ifTokens is true.  See example below. "	| aString startSearch currentIndex endIndex |	(ifTokens and: [(self isKindOf: String) not])		ifTrue: [(self isKindOf: Text) ifFalse: [			self error: 'Token replacement only valid for Strings']].	aString _ self.	startSearch _ 1.	[(currentIndex _ aString indexOfSubCollection: oldSubstring startingAt: startSearch)			 > 0]		whileTrue: 		[endIndex _ currentIndex + oldSubstring size - 1.		(ifTokens not			or: [(currentIndex = 1					or: [(aString at: currentIndex-1) isAlphaNumeric not])				and: [endIndex = aString size					or: [(aString at: endIndex+1) isAlphaNumeric not]]])			ifTrue: [aString _ aString					copyReplaceFrom: currentIndex					to: endIndex					with: newSubstring.				startSearch _ currentIndex + newSubstring size]			ifFalse: [				ifTokens 					ifTrue: [startSearch _ currentIndex + 1]					ifFalse: [startSearch _ currentIndex + newSubstring size]]].	^ aString"Test case:	'test te string' copyReplaceAll: 'te' with: 'longone' asTokens: true   "! !!SequenceableCollection methodsFor: 'private' stamp: 'ward 7/28/97 09:38'!permutationsStartingAt: anInteger do: aBlock	"#(1 2 3 4) permutationsDo: [:each | Transcript cr; show: each printString]"	anInteger > self size ifTrue: [^self].	anInteger = self size ifTrue: [^aBlock value: self].	anInteger to: self size do:		[:i | self swap: anInteger with: i.		self permutationsStartingAt: anInteger + 1 do: aBlock.		self swap: anInteger with: i]! !!SequenceableCollection class methodsFor: 'stream creation' stamp: 'di 6/20/97 09:07'!streamContents: blockWithArg limitedTo: sizeLimit	| stream |	stream _ LimitedWriteStream on: (self new: (100 min: sizeLimit)).	stream setLimit: sizeLimit limitBlock: [^ stream contents].	blockWithArg value: stream.	^ stream contents"String streamContents: [:s | 1000 timesRepeat: [s nextPutAll: 'Junk']] limitedTo: 25 'JunkJunkJunkJunkJunkJunkJ'"! !!SequentialSound methodsFor: 'sound generation' stamp: 'jm 11/25/97 13:41'!doControl	super doControl.	currentIndex > 0		ifTrue: [(sounds at: currentIndex) doControl].! !!SequentialSound methodsFor: 'sound generation' stamp: 'jm 11/24/97 16:16'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a collection of sounds in sequence."	"PluckedSound chromaticScale play"	| finalIndex i snd remaining count |	currentIndex = 0 ifTrue: [^ self].  "already done"	finalIndex _ (startIndex + n) - 1.	i _ startIndex.	[i <= finalIndex] whileTrue: [		snd _ (sounds at: currentIndex).		[(remaining _ snd samplesRemaining) <= 0] whileTrue: [			"find next undone sound"			currentIndex < sounds size				ifTrue: [					currentIndex _ currentIndex + 1.					snd _ (sounds at: currentIndex)]				ifFalse: [					currentIndex _ 0.					^ self]].  "no more sounds"		count _ (finalIndex - i) + 1.		remaining < count ifTrue: [count _ remaining].		snd mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: leftVol rightVol: rightVol.		i _ i + count].! !!SequentialSound methodsFor: 'sound generation' stamp: 'jm 12/15/97 22:47'!reset	super reset.	sounds do: [:snd | snd reset].	sounds size > 0 ifTrue: [currentIndex _ 1].! !!SequentialSound methodsFor: 'sound generation' stamp: 'jm 12/15/97 22:47'!samplesRemaining	currentIndex = 0		ifTrue: [^ 0]		ifFalse: [^ 1000000].! !!SequentialSound methodsFor: 'composition' stamp: 'jm 12/15/97 22:48'!add: aSound	sounds _ sounds copyWith: aSound.! !!SequentialSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:10'!copy	"Copy my component sounds."	^ super copy copySounds! !!SequentialSound methodsFor: 'copying' stamp: 'jm 12/15/97 22:48'!copySounds	"Private!! Support for copying. Copy my component sounds."	sounds _ sounds collect: [:s | s copy].! !The ServerAction class is the default ServerAction (if the first token in the URL does not match any in the PWS ActionTable). Instances of ServerAction act like Mac Web servers -- they parse the URL into a Mac file path (including use of default.html if no final filename is provided), then return the contents of that file as the reply. All ServerActions get asked to process: a PWS request. This ServerAction does the processing by asking itself to checkAuthorization, to parse the request, to log the parsed request, and then to reply to the request.  Other ServerActions (like EmbeddedServerAction) can override one or more of those requests.The ServerAction class provides a ServerDirectory service.!!ServerAction methodsFor: 'file input/output' stamp: 'mjg 11/17/97 14:06'!fileContents: serverFileRef	^(FileStream fileNamed: (ServerAction serverDirectory) , serverFileRef)	 contentsOfEntireFile! !!ServerAction methodsFor: 'file input/output' stamp: 'mjg 11/25/97 14:17'!subdirectory: named	^named, (ServerAction pathSeparator)! !!ServerAction methodsFor: 'URL processing' stamp: 'mjg 11/4/97 16:37'!checkAuthorization: request	^self! !!ServerAction methodsFor: 'URL processing' stamp: 'mjg 10/25/97 15:02'!log: pieces to: request	| tab |	tab := String with: Character tab.	request log: ((Time now printString), tab, (Date today printString), tab, (pieces printString),	Character cr asString).! !!ServerAction methodsFor: 'URL processing' stamp: 'mjg 11/19/97 09:00'!parse: request	| filename |	filename := (ServerAction serverDirectory) , ((request url) allButFirst copyReplaceAll: '/' with: 		(ServerAction pathSeparator)).	(filename endsWith: (ServerAction pathSeparator)) ifTrue: [filename _ filename , (ServerAction defaultFile)].	^filename! !!ServerAction methodsFor: 'URL processing' stamp: 'mjg 11/4/97 16:37'!process: request	| pieces |	self checkAuthorization: request.	pieces _ self parse: request.	self log: pieces to: request.	self replyTo: pieces from: request.! !!ServerAction methodsFor: 'URL processing' stamp: 'mjg 11/3/97 12:10'!replyTo: pieces from: request	Transcript show: 'Now replying with: ', pieces; cr.	(StandardFileStream isAFileNamed: pieces) 	ifTrue:		[request reply: PWS success; reply: PWS contentHTML.		request reply: (FileStream fileNamed: pieces) contentsOfEntireFile]	ifFalse:		[request error: PWS notFound].! !!ServerAction class methodsFor: 'System Services' stamp: 'mjg 11/17/97 11:17'!defaultFile	^'default.html'! !!ServerAction class methodsFor: 'System Services' stamp: 'mjg 11/20/97 10:12'!pathSeparator  ^String with: FileDirectory pathNameDelimiter! !!ServerAction class methodsFor: 'System Services' stamp: 'mjg 12/19/97 13:50'!serverDirectory	^'Guz BigDisk:Server:'.! !Holds all the information needed to read or write on a directory of an internet server.  I am used for FTP and HTTP (and STMP?  NNTP?).  The password policy is: unless it is a public password (like annomyous), clear all passwords before any snapshot.  There is a way to store passwords on the disk.server 		'www.disney.com'  or '123.34.56.08' or the ServerDirectory above me 			(if I am a subdirectory sharing the info in a master directory)directory 	'ftp/pubs/'  name of my directory within the server or superdirectory.type 		#ftp	what you can do in this directoryuser 		'Jones45'password 	an instance of Password.  group 		an Association ('group name' -> an array of ServerDirectorys)			If this first one is down, try the next one.  Store on all of them.  I am in the list.moniker 	'Main Squeak Directory'  Description of this directory.!]style[(615 8 228)f1,f1LPassword Comment;,f1!!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 1/6/98 12:55'!fileExists: fileName	"Does the file exist on this server directory?  fileName must be simple with no / or references to other directories."	^ (self getFileList contentsOfEntireFile findTokens: FTPSocket crLf) includes: fileName! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 1/6/98 12:14'!getDirectory	"Return a stream with a listing of the current server directory.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so sendCommand: 'LIST'.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieve from port ', dd portNum printString; cr.	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"RWStream with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 1/6/98 12:47'!getFileList	"Return a stream with a list of files in the current server directory.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so sendCommand: 'NLST'.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieve from port ', dd portNum printString; cr.	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"RWStream with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 1/5/98 12:29'!getFileNamed: fileNameOnServer	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieve from port ', dd portNum printString; cr.	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 1/5/98 21:54'!openFTP	"Open a connection to the directory and server I hold.  Return a FTPSocket.  It has opened passive, and has a dataPort number assigned to a data FTPSocket.  But the data connection is not open.  When you are done, be sure to tell the socket to QUIT, and then destroy it."	| so resp portInfo list dataPort dd rr serverIP |	Socket initializeNetwork.	FTPSocket retry: [serverIP _ NetNameResolver addressForName: server timeout: 20.				serverIP ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', server].	so _ FTPSocket new.	so portNum: 21.	so connectTo: serverIP port: 21.  "21 is for the control connection"	so waitForConnectionUntil: FTPSocket standardDeadline.	Transcript cr; show: server; cr.	(rr _ so responseOK) == true ifFalse: [^ rr].	"220 para1 Microsoft FTP Service"	so sendCommand: 'USER ', user.	(rr _ so responseOK) == true ifFalse: [^ rr].	"331 Password required"	so sendCommand: 'PASS ', self password.	(rr _ so responseOK) == true ifFalse: [^ rr].	"230 User logged in"	so sendCommand: 'CWD ', directory.	(rr _ so responseOK) == true ifFalse: [^ rr].	"250 CWD successful"	"Need to ask for name of directory to make sure?"	so sendCommand: 'TYPE L 8'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"200 Type set to L"	so sendCommand: 'PASV'.	resp _ (so getResponseUpTo: FTPSocket crLf) first.		"Tells which port on server to use for data"	Transcript show: resp; cr.	(resp beginsWith: '227 Entering Passive Mode (') ifFalse: [		so sendCommand: 'QUIT'.		so destroy.		^ self error: 'can''t get into passive mode'].	portInfo _ (resp findTokens: '()') at: 2.	list _ portInfo findTokens: ','.	dataPort _ (list at: 5) asNumber * 256 + (list at: 6) asNumber.	dd _ FTPSocket new.	dd portNum: dataPort.	so dataSocket: dd.	"save it, not opened yet"	^ so! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 1/3/98 22:31'!putFile: fileStream named: fileNameOnServer	"Just FTP a local fileStream to the server.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so sendCommand: 'STOR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'store via port ', dd portNum printString; cr.	dd sendData: fileStream contentsOfEntireFile.	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(resp _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"226 Transfer complete."! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 1/7/98 11:17'!putUpdate: fileStrm	"Put this file out as an Update on the servers of my group.  Use the 'Ted' convention for updates.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence newName myName response local |	local _ fileStrm localName.	(local count: [:char | char == $.]) > 1 ifTrue: [		^ self inform: 'File name cannot have more than one period'].	(local findDelimiters: '%/* ' startingAt: 1) <= local size ifTrue: [		^ self inform: 'File name cannot contain % / * or space'].	myServers _ group ifNil: [myName _ self moniker.  Array with: self] 			ifNotNil: [myName _ group key.  group value].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', local, 			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	updateStrm _ self getFileNamed: 'updates.list'.	"get last number and add 1"	sequence _ Utilities lastUpdateNum: updateStrm.	"and warn if not current version"	sequence ifNil: [^ self].	"abort update of wrong sys version"	newName _ (sequence+1) printString, local.	"append name to updates"	(updateStrm setToEnd; skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: newName; nextPut: Character cr.	myServers do: [:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName.		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list'.		self inform: 'Update succeeded on server ', aServer moniker].			self inform: 'Be sure to test your new update!!'.	"rename the file locally (may fail)"	fileStrm directory rename: local toBe: newName.!]style[(19 264 39 1546)f1b,f1,f1LUtilities class absorbUpdatesFromServer;,f1! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/3/98 21:36'!directory: anObject	directory _ anObject! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/6/98 11:11'!group	^group! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/5/98 21:16'!group: anObject	group _ anObject! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/5/98 22:20'!groupName	group ifNotNil: [^ group key].	^ self moniker! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/3/98 22:59'!moniker	"a plain language name for this directory"	moniker ifNil: [		^ directory first == $/ 			ifTrue: [server, directory]			ifFalse: [server, '/', directory]].	^ moniker! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/5/98 21:55'!password	^ passwordHolder passwordFor: self! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/5/98 21:55'!password: pp	passwordHolder _ Password new.	pp class == String 		ifTrue: [passwordHolder cache: pp. ^ self].	pp isInteger 		ifTrue: [passwordHolder sequence: pp]		ifFalse: [passwordHolder _ pp].! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/3/98 21:36'!server: anObject	server _ anObject! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/3/98 21:36'!user: anObject	user _ anObject! !!ServerDirectory class methodsFor: 'as yet unclassified' stamp: 'tk 1/7/98 12:18'!serverGroups	"Return all registered groups of servers (include individual servers not in any group).  Each is an association (name -> server)"	| grp set |	set _ Set new.	Smalltalk associationsDo: [:ass |		(ass value isKindOf: self) ifTrue: [			grp _ ass value group.			grp ifNil: [set add: ass]	"assoc"				ifNotNil: [ass value == grp value first ifTrue: [set add: ass]]]].	^ (set asOrderedCollection) collect: [:each | 				Association key: each value groupName value: each value].! !This class is a workaround to get Unix like listening behaviour.!!ServerSocket methodsFor: 'open/close' stamp: 'go 9/5/97 13:21'!bindTo: portNumber backlog: aNumber	"Start listening. Accept only up to aNumber outstanding connections."	highwater := Semaphore new.	aNumber timesRepeat: [highwater signal].	queue := SharedQueue new: aNumber.	listener := Process forContext: [[		(socket := Socket new) listenOn: portNumber.		[socket waitForConnectionUntil: Socket standardDeadline] whileFalse: [			queue nextPut: nil.			highwater wait].		queue nextPut: socket.		highwater wait.		true] whileTrue] priority: Processor lowIOPriority.	listener resume! !!ServerSocket methodsFor: 'open/close' stamp: 'go 9/5/97 12:49'!destroy	"Stop listening."	| sock |	listener terminate.	socket destroy.	[queue size > 0] whileTrue: [(sock := queue next) notNil ifTrue: [sock destroy]]! !!ServerSocket methodsFor: 'open/close' stamp: 'go 9/5/97 12:49'!listen	"Return the next open socket or nil if no connection has been established during the timeout period."	highwater signal.	^ queue next! !A Session can provide server-side storage of state/data between HTML pages. After creating a new session (which can be manipulated using at: and at:put:), it can be saved on the Sessions list by asking the Session class to store: the session. A random integer is returned as a key to the session, and the key can be stored in an HTML page in a hidden field.A session can be retrieved by ID by asking Session to recall: an ID. A session can be retired when it is no longer useful.Each recall: or use at:/at:put: "touches" (updates) the Session's last use time. A Session that is older than a certain period (default 30 minutes, in viableTime instance method) will generate an error. Every hour, the PWS, as part of its backup procedures, will clear out old sessions.!!Session methodsFor: 'access' stamp: 'mjg 11/4/97 14:12'!at: key	self touch.	^data at: key ifAbsent: [self error: 'Internal key error. Please alert administrator about key',key printString].! !!Session methodsFor: 'access' stamp: 'mjg 11/4/97 14:12'!at: key put: value	self touch.	^data at: key put: value.! !!Session methodsFor: 'access' stamp: 'mjg 11/4/97 14:07'!isViable	^ (Time now subtractTime: lastAccess) asSeconds > self viableTime! !!Session methodsFor: 'access' stamp: 'mjg 11/4/97 14:06'!touch	lastAccess := Time now.! !!Session methodsFor: 'access' stamp: 'mjg 11/4/97 14:07'!viableTime	"In seconds"	^60*30! !!Session methodsFor: 'initialize' stamp: 'mjg 11/4/97 16:39'!initialize	data := Dictionary new.	lastAccess := Time now.	PWS addToBackupJob: [Session user].! !!Session class methodsFor: 'store/recall' stamp: 'mjg 12/2/97 10:06'!clearOld	| aSession |	Sessions keys do: [:s |	aSession := Sessions at: s ifAbsent: [nil].	aSession isNil ifFalse:		[aSession isViable ifFalse: [self retire: s].]]! !!Session class methodsFor: 'store/recall' stamp: 'mjg 11/4/97 14:09'!recall: id	| aSession |	aSession := Sessions at: id ifAbsent: [self error: 'Non-existent session'].	aSession isViable ifFalse: [self error: 'Your session data has expired. Please restart the operation.'].	aSession touch.	^aSession! !!Session class methodsFor: 'store/recall' stamp: 'mjg 11/4/97 14:11'!retire: id	Sessions removeKey: id.! !!Session class methodsFor: 'store/recall' stamp: 'mjg 11/4/97 14:04'!store: aSession	| newID |	[	newID := SmallInteger maxVal atRandom.		Sessions includesKey: newID ] whileTrue.	Sessions at: newID put: aSession.	^newID! !!Session class methodsFor: 'initialization' stamp: 'mjg 11/4/97 16:43'!initialize	Sessions := Dictionary new.	PWS addToBackupJob: [Session clearOld].! !!Session class methodsFor: 'initialization' stamp: 'mjg 11/4/97 13:54'!new	^super new initialize! !!Set methodsFor: 'adding' stamp: 'go 10/1/97 09:33'!add: newObject	"Add an element. User error instead of halt. go 10/1/97 09:33"	| index |	newObject == nil ifTrue: [self error: 'Sets cannot meaningfully contain nil as an element'].	index _ self findElementOrNil: newObject.	(array at: index) == nil ifTrue:		[self atNewIndex: index put: newObject].	^ newObject! !!Set methodsFor: 'private'!findElementOrNil: anObject	"Answer the index of a first slot containing either a nil (indicating an empty slot) or an element that matches the given object. Answer the index of that slot or zero. Fail if neither a match nor an empty slot is found."	| index |	index _ self scanFor: anObject.	index > 0 ifTrue: [ ^ index ].	"Bad scene.  Neither have we found a matching element	nor even an empty slot.  No hashed set is ever supposed to get	completely full."	self error: 'There is no free space in this set!!'.! !!Set methodsFor: 'private' stamp: 'di 11/4/97 20:11'!fullCheck	"Keep array at least 1/4 free for decent hash behavior"	array size - tally < (array size // 4 max: 1)		ifTrue: [self grow]! !!Set methodsFor: 'private'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Set methodsFor: 'accessing' stamp: 'sw 12/2/96'!asArray	"Return an array whose elements are those of the receiver.  "	^ self asOrderedCollection asArray! !!Set methodsFor: 'accessing' stamp: 'tk 2/14/97'!someElement	"Return some element of the Set.  "	^ array detect: [:each | each ~~ nil] ifNone: [ nil]! !!Set methodsFor: 'objects from disk' stamp: 'tk 1/8/97'!readDataFrom: aDataStream size: anInteger	"Symbols have new hash in this world.  "	| aSet |	aSet _ super readDataFrom: aDataStream size: anInteger.	aSet rehash.	^ aSet! !!Set class methodsFor: 'instance creation' stamp: 'tk 9/7/96'!readDataFrom: aDataStream size: anInteger	"Symbols have new hash in this world.  "	| aSet |	self halt.	aSet _ super readDataFrom: aDataStream size: anInteger.	aSet rehash.	^ aSet! !!Set class methodsFor: 'initialization'!rehashAllSets  "Set rehashAllSets"	| insts |	self withAllSubclassesDo:		[:c | insts _ c allInstances.		insts isEmpty ifFalse:		['Rehashing instances of ' , c name			displayProgressAt: Sensor cursorPoint			from: 1 to: insts size			during: [:bar |			1 to: insts size do:				[:x | bar value: x.				(insts at: x) rehash]]]]! !!SimpleButtonMorph methodsFor: 'initialization'!initialize	super initialize.	self borderWidth: 1.	self borderColor: #raised.	self color: (Color r: 0.4 g: 0.8 b: 0.6).	target _ nil.	actionSelector _ #flash.	arguments _ EmptyArray.	actWhen _ #buttonUp.	self label: 'Flash'.! !!SimpleButtonMorph methodsFor: 'initialization' stamp: 'sw 8/12/97 18:36'!initializeIconFromGIFNamed: aString	"Make the receiver be an iconic button with its picture derived from a form found in GIFImports.  Not currently in use, and was somewhat flawed. "	| aForm image |	aForm _ GIFImports at: aString ifAbsent: [self halt].	self removeAllMorphs.	self extent: aForm extent.	self addMorphCentered: (image _ ImageMorph new image: aForm).	self color: Color yellow.	self flag: #deferred.	self setBorderWidth: 2 borderColor: Color yellow.	"image lock"! !!SimpleButtonMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change label' action: #setLabel.	aCustomMenu add: 'change action selector' action: #setActionSelector.	aCustomMenu add: 'change arguments' action: #setArguments.	aCustomMenu add: 'change when to act' action: #setActWhen.	((self world rootMorphsAt: aHandMorph targetOffset) size > 1) ifTrue: [		aCustomMenu add: 'set target' action: #setTarget:].! !!SimpleButtonMorph methodsFor: 'menu'!setActionSelector	| newSel |	newSel _ FillInTheBlank		request:'Please type the selector to be sent tothe target when this button is pressed'		initialAnswer: actionSelector.	newSel isEmpty ifFalse: [self actionSelector: newSel].! !!SimpleButtonMorph methodsFor: 'menu'!setActWhen	actWhen _ (SelectionMenu selections: #(buttonDown buttonUp whilePressed))		startUpWithCaption: 'Choose one of the following conditions'! !!SimpleButtonMorph methodsFor: 'menu'!setArguments	| s newArgs newArgsArray |	s _ WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs _ FillInTheBlank		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods'		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray _ Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!SimpleButtonMorph methodsFor: 'menu'!setLabel	| newLabel |	newLabel _ FillInTheBlank		request:'Please a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel].! !!SimpleButtonMorph methodsFor: 'menu'!setTarget: evt	| rootMorphs |	rootMorphs _ self world rootMorphsAt: evt hand targetOffset.	rootMorphs size > 1		ifTrue: [target _ rootMorphs at: 2]		ifFalse: [target _ nil. ^ self].! !!SimpleButtonMorph methodsFor: 'accessing'!actionSelector	^ actionSelector! !!SimpleButtonMorph methodsFor: 'accessing'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!SimpleButtonMorph methodsFor: 'accessing'!actWhen: condition	"Accepts symbols:  #buttonDown, #buttonUp, and #whilePressed"	actWhen _ condition! !!SimpleButtonMorph methodsFor: 'accessing'!arguments	^ arguments! !!SimpleButtonMorph methodsFor: 'accessing'!arguments: aCollection	arguments _ aCollection asArray copy.! !!SimpleButtonMorph methodsFor: 'accessing' stamp: '6/7/97 10:53 di'!extent: newExtent	| label |	super extent: newExtent.	submorphs size = 1 ifTrue:		["keep the label centered"		"NOTE: may want to test more that it IS a label..."		label _ self firstSubmorph.		label position: self center - (label extent // 2)]! !!SimpleButtonMorph methodsFor: 'accessing'!label	| s |	s _ ''.	self allMorphsDo: [:m | (m isKindOf: StringMorph) ifTrue: [s _ m contents]].	^ s! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'sw 8/16/97 01:59'!label: aString	| oldLabel m |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	m _ StringMorph new contents: aString.	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'di 10/20/97 20:26'!label: aString font: aFont	| oldLabel m |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	m _ StringMorph contents: aString font: aFont.	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!SimpleButtonMorph methodsFor: 'accessing'!target	^ target! !!SimpleButtonMorph methodsFor: 'accessing'!target: anObject	target _ anObject! !!SimpleButtonMorph methodsFor: 'events'!doButtonAction	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		Cursor normal showWhile: [			target perform: actionSelector withArguments: arguments]].! !!SimpleButtonMorph methodsFor: 'events' stamp: 'sw 8/16/97 22:10'!handlesMouseDown: evt	^  self isPartsDonor not! !!SimpleButtonMorph methodsFor: 'events'!mouseDown: evt	oldColor _ color.	actWhen == #buttonDown		ifTrue: [self doButtonAction].! !!SimpleButtonMorph methodsFor: 'events' stamp: 'di 12/8/97 10:48'!mouseMove: evt	(self containsPoint: evt cursorPoint)		ifTrue: [self color: (oldColor mixed: 1/2 with: Color white).				(actWhen == #whilePressed and: [evt anyButtonPressed])					 ifTrue: [self doButtonAction]]		ifFalse: [self color: oldColor].! !!SimpleButtonMorph methodsFor: 'events'!mouseUp: evt	self color: oldColor.	(actWhen == #buttonUp and: [self containsPoint: evt cursorPoint])		ifTrue: [self doButtonAction].! !!SimpleButtonMorph methodsFor: 'copying' stamp: 'jm 7/28/97 11:52'!updateReferencesUsing: aDictionary	"If the arguments array points at a morph we are copying, then point at the new copy.  And also copies the array, which is important!!"	super updateReferencesUsing: aDictionary.	arguments _ arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !SimpleClientSocket comment:'This class supports client for simple network protocols based on sending textual commands and responses. Examples of such protocols include POP3 (mail retrieval), SMTP (mail posting), HTTP (web browsing), and NTTP (network news). Some simple examples are presented as class methods, but a full-service client of some service should be implemented as a subclass.The basic services provided by this class are:	sendCommand:			-- sends a command line terminate with <CR><LF>	getResponse				-- gets a (typically) single-line response to a command	getMultilineResponse	-- gets a multiple line response terminated by a period							-- on a line by itselfThere are variants of the getResponse commands that display lines on the screen as they are being received. Linefeeds are stripped out of all responses.'!!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/15/97 15:21'!displayString: aString	"Display the given string on the Display. Used for testing."	| s |	aString isEmpty ifTrue: [^ self].	aString size > 60		ifTrue: [s _ aString copyFrom: 1 to: 60]  "limit to 60 characters"		ifFalse: [s _ aString].	s asParagraph displayOn: Display.! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/15/97 11:36'!endsWithSinglePeriodLine: aString	"Return true if the given string ends with a period on a line by itself."	| sz |	sz _ aString size.	^ ((sz > 2) and:	   [(aString at: sz) = CR and:	   [(aString at: sz - 1) = $. and:	   [(aString at: sz - 2) = CR]]])! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/15/97 15:43'!getMultilineResponse	"Get a multiple line response to the last command, filtering out LF characters. A multiple line response ends with a line containing only a single period (.) character."	^ self getMultilineResponseShowing: false.! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/15/97 15:41'!getMultilineResponseShowing: showFlag	"Get a multiple line response to the last command. A multiple line response ends with a line containing only a single period (.) character. Linefeed characters are filtered out. If showFlag is true, each line is shown in the upper-left corner of the Display as it is received."	| response done chunk |	response _ WriteStream on: ''.	done _ false.	[done] whileFalse: [		showFlag			ifTrue: [chunk _ self getResponseShowing: true]			ifFalse: [chunk _ self getResponse].		response nextPutAll: chunk.		done _ self endsWithSinglePeriodLine: chunk].	^ response contents! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/15/97 15:30'!getResponse	"Get the response to the last command, filtering out LF characters."	^ self getResponseShowing: false! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/15/97 15:47'!getResponseShowing: showFlag	"Get a the response to the last command, filtering out LF characters. If showFlag is true, each of the response is shown in the upper-left corner of the Display as it is received."	| response line buf bytesRead c |	self waitForDataQueryingUserEvery: 15.	response _ WriteStream on: ''.	line _ WriteStream on: ''.	buf _ String new: 1000.	[self dataAvailable]		whileTrue: [			bytesRead _ self receiveDataInto: buf.			1 to: bytesRead do: [:i |				(c _ buf at: i) ~= LF					ifTrue: [						line nextPut: c.						response nextPut: c]					ifFalse: [						showFlag ifTrue: [							self displayString: line contents.							line reset]]]].	^ response contents! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/17/97 16:00'!sendCommand: commandString	"Send the given command as a single line followed by a <CR><LF> terminator."	self sendData: commandString, CrLf.! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/15/97 15:46'!waitForDataQueryingUserEvery: seconds	"Wait for data to arrive, asking the user periodically if they wish to keep waiting. If they don't wish to keep waiting, destroy the socket and raise an error."	| gotData |	gotData _ false.	[gotData]		whileFalse: [			gotData _ self waitForDataUntil: (Socket deadlineSecs: seconds).			gotData ifFalse: [				(self confirm: 'server not responding; keep trying?')					ifFalse: [						self destroy.						self error: 'no response from server']]].! !!SimpleClientSocket class methodsFor: 'class initialization' stamp: 'jm 9/15/97 11:42'!initialize	"SimpleClientSocket initialize"	CR _ Character cr.	LF _ Character linefeed.	"string for command line termination:"	CrLf _ String with: CR with: LF.! !!SimpleClientSocket class methodsFor: 'simple HTTP example' stamp: 'jm 9/26/97 18:29'!httpTestHost: hostName port: port url: url	"This test fetches a URL from the given host and port."	"SimpleClientSocket httpTestHost: 'www.exploratorium.edu' port: 80 url: '/'"	"Tests URL fetch through a local HTTP proxie server:		(SimpleClientSocket			httpTestHost: '127.0.0.1'			port: 8080			url: 'HTTP://www.exploratorium.edu/index.html')"	| hostAddr s result buf bytes totalBytes t |	Transcript cr; show: 'starting http test'; cr.	Socket initializeNetwork.	hostAddr _ NetNameResolver addressForName: hostName timeout: 10.	hostAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', hostName].	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: hostAddr port: port.	s waitForConnectionUntil: "self standardDeadline" (Socket deadlineSecs: 4).	(s isConnected) ifFalse: [		s destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection open; waiting for data'; cr.	s sendCommand: 'GET ', url, ' HTTP/1.0'.	s sendCommand: 'User-Agent: Squeak 1.19'.	s sendCommand: 'ACCEPT: text/html'.	"always accept plain text"	s sendCommand: 'ACCEPT: application/octet-stream'.  "also accept binary data"	s sendCommand: ''.  "blank line"	result _ WriteStream on: (String new: 10000).	buf _ String new: 10000.	totalBytes _ 0.	t _ Time millisecondsToRun: [		[s isConnected] whileTrue: [			s waitForDataUntil: (Socket deadlineSecs: 5).			bytes _ s receiveDataInto: buf.			1 to: bytes do: [:i | result nextPut: (buf at: i)].			totalBytes _ totalBytes + bytes.			Transcript show: totalBytes printString, ' bytes received'; cr]].	s destroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.	Transcript show: 'http test done; ', totalBytes printString, ' bytes read in '.	Transcript show: ((t / 1000.0) roundTo: 0.01) printString, ' seconds'; cr.	Transcript show: ((totalBytes asFloat / t) roundTo: 0.01) printString, ' kBytes/sec'; cr.	Transcript endEntry.	StringHolderView		open: (StringHolder new contents: (result contents))		label: 'HTTP Test Result: URL Contents'.! !!SimpleClientSocket class methodsFor: 'net news example' stamp: 'jm 9/17/97 14:24'!nntpTest	"SimpleClientSocket nntpTest"	| addr s headers msgs header allNewsGroups |	addr _ NetNameResolver promptUserForHostAddress.	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 119.  "119 is the NNTP port number"	s waitForConnectionUntil: self standardDeadline.	Transcript show: s getResponse.	s sendCommand: 'group comp.lang.smalltalk'.	Transcript show: s getResponse.	"get all the message headers for the current newsgroup"	s sendCommand: 'xover 1-1000000'.	headers _ s getMultilineResponseShowing: true.	"print the headers of the first 10 messages of comp.lang.smalltalk"	s sendCommand: 'listgroup comp.lang.smalltalk'.	msgs _ self parseIntegerList: s getMultilineResponse.	msgs ifNotNil: [		1 to: 5 do: [:i |			s sendCommand: 'head ', (msgs at: i) printString.			header _ s getMultilineResponse.			Transcript show: (self extractDateFromAndSubjectFromHeader: header); cr]].	"get a full list of usenet newsgroups"	s sendCommand: 'newgroups 010101 000000'.	allNewsGroups _ s getMultilineResponse.	Transcript show: allNewsGroups size printString, ' bytes in full newsgroup list'; cr.	Transcript show: 'Sending quit...'; cr.	s sendCommand: 'QUIT'.	Transcript show: s getResponse.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.	(headers ~~ nil and:	 [self confirm: 'show article headers from comp.lang.smalltalk?'])		ifTrue: [			StringHolderView				open: (StringHolder new contents: (self parseHeaderList: headers))				label: 'Newsgroup Headers'].	(allNewsGroups ~~ nil and:	 [self confirm: 'show list of all newsgroups available on your server?'])		ifTrue: [			StringHolderView				open: (StringHolder new contents: allNewsGroups)				label: 'All Usenet Newsgroups'].! !!SimpleClientSocket class methodsFor: 'net news example' stamp: 'jm 9/15/97 13:25'!parseHeaderList: aString	"Parse a list of newsgroup headers."	| results s lineStart |	results _ WriteStream on: (String new: aString size).	s _ ReadStream on: aString.	[s atEnd]		whileFalse: [			lineStart _ s position + 1.			3 timesRepeat: [s skipTo: Character tab].  "find fourth tab"			lineStart to: s position - 1 do: [:i | results nextPut: (aString at: i)].			results cr.			s skipTo: Character cr].	^ results contents! !!SimpleClientSocket class methodsFor: 'net news example' stamp: 'jm 9/15/97 13:26'!parseIntegerList: aString	"Parse a list of integers, each on a line by itself."	| s out |	s _ ReadStream on: aString.	s skipTo: Character cr.  "skip the first line"	out _ OrderedCollection new.	[s atEnd]		whileFalse: [			out addLast: (Integer readFrom: s).			s skipTo: Character cr].	^ out asArray! !!SimpleClientSocket class methodsFor: 'net news example' stamp: 'jm 9/15/97 13:26'!parseNTTPMsgList: aString	"Parse a list of integers, each on a line by itself."	| s out |	s _ ReadStream on: aString.	s skipTo: Character cr.  "skip the first line"	out _ OrderedCollection new.	[s atEnd]		whileFalse: [			out addLast: (Integer readFrom: s).			s skipTo: Character cr].	^ out asArray! !!SimpleClientSocket class methodsFor: 'POP mail example' stamp: 'jm 9/15/97 14:47'!extractDateFromAndSubjectFromHeader: headerString	| date from subject s lineBuf c line i |	date _ from _ subject _ ''.	s _ ReadStream on: headerString.	lineBuf _ WriteStream on: ''.	[s atEnd] whileFalse: [		c _ s next.		c = CR			ifTrue: [				line _ lineBuf contents.				(line beginsWith: 'Date: ')	ifTrue: [date _ line copyFrom: 7 to: line size].				(line beginsWith: 'From: ')	ifTrue: [from _ line copyFrom: 7 to: line size].				(line beginsWith: 'Subject: ')	ifTrue: [subject _ line copyFrom: 10 to: line size].				lineBuf _ WriteStream on: '']			ifFalse: [lineBuf nextPut: c]].	i _ date indexOf: $' ifAbsent: [0].	date _ date copyFrom: i + 1 to: date size.	^ (self simpleDateString: date), ', ', from, ':  ', subject! !!SimpleClientSocket class methodsFor: 'POP mail example' stamp: 'jm 9/17/97 14:24'!popTest	"SimpleClientSocket popTest"	| addr userName userPassword s msgs header |	addr _ NetNameResolver promptUserForHostAddress.	userName _ FillInTheBlank		request: 'What is your email name?'		initialAnswer: 'johnm'.	userPassword _ FillInTheBlank		request: 'What is your email password?'.	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 110.  "110 is the POP3 port number"	s waitForConnectionUntil: self standardDeadline.	Transcript show: s getResponse.	s sendCommand: 'USER ', userName.	Transcript show: s getResponse.	s sendCommand: 'PASS ', userPassword.	Transcript show: s getResponse.	s sendCommand: 'LIST'.	"the following should be tweaked to handle an empy mailbox:"	msgs _ self parseIntegerList: s getMultilineResponse.	1 to: (msgs size min: 5) do: [ :i |		s sendCommand: 'TOP ', (msgs at: i) printString, ' 0'.		header _ s getMultilineResponse.		Transcript show: (self extractDateFromAndSubjectFromHeader: header); cr].	msgs size > 0 ifTrue: [		"get the first message"		s sendCommand: 'RETR 1'.		Transcript show: s getMultilineResponse].	Transcript show: 'closing connection'; cr.	s sendCommand: 'QUIT'.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!SimpleClientSocket class methodsFor: 'POP mail example' stamp: 'jm 9/15/97 13:53'!simpleDateString: dateString	| s |	s _ ReadStream on: dateString.	s skipTo: $,.  "scan thru first comma"	s atEnd ifTrue: [s reset].  "no comma found; reset s"	s skipSeparators.	^ (Date readFrom: s) mmddyy! !!SimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'jm 9/17/97 14:25'!forkingRemoteCursorSender	"This is the client side of a test that sends samples of the local input sensor state to the server, which may be running on a local or remote host. This method opens the connection, then forks a process to send the cursor data. Data is sent continuously until the user clicks in a 20x20 pixel square at the top-left corner of the display. The server should be started first. Note the server's address, since this method will prompt you for it."	"SimpleClientSocket forkingRemoteCursorSender"	| sock addr stopRect |	Transcript show: 'starting remote cursor sender'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	addr _ NetNameResolver promptUserForHostAddress.	Transcript show: 'opening connection'; cr.	sock _ SimpleClientSocket new.	sock connectTo: addr port: 54323.	sock waitForConnectionUntil: self standardDeadline.	(sock isConnected) ifFalse: [self error: 'sock not connected'].	Transcript show: 'connection established'; cr.	stopRect _ 0@0 corner: 20@20.  "click in this rectangle to stop sending"	Display reverse: stopRect.	["the sending process"		[(stopRect containsPoint: Sensor cursorPoint) and:		 [Sensor anyButtonPressed]]			whileFalse: [				sock sendCommand: self sensorStateString.				(Delay forMilliseconds: 20) wait].		sock waitForSendDoneUntil: self standardDeadline.		sock destroy.		Transcript show: 'remote cursor sender done'; cr.		Display reverse: stopRect.	] fork.! !!SimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'jm 9/15/97 14:49'!parseSensorStateString: aString	"Parse the given sensor stat string and return an array whose first element is the cursor point and whose second is the cursor button state."	"SimpleClientSocket parseSensorStateString: SimpleClientSocket sensorStateString"	| s buttons x y |	s _ ReadStream on: aString.	x _ Integer readFrom: s.	s skipSeparators.	y _ Integer readFrom: s.	s skipSeparators.	buttons _ Integer readFrom: s.	^ Array with: x@y with: buttons! !!SimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'jm 9/15/97 15:16'!remoteCursorReceiver	"Wait for a connection, then display data sent by the client until the client closes the stream. This server process is usually started first (optionally in a forked process), then the sender process is started (optionally on another machine). Note this machine's address, which is printed in the transcript, since the sender process will ask for it."	"[SimpleClientSocket remoteCursorReceiver] fork"	| sock response |	Transcript show: 'starting remote cursor receiver'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	Transcript show: 'my address is ', NetNameResolver localAddressString; cr.	Transcript show: 'opening connection'; cr.	sock _ SimpleClientSocket new.	sock listenOn: 54323.	sock waitForConnectionUntil: (Socket deadlineSecs: 60).	sock isConnected		ifFalse: [			 sock destroy.			Transcript show: 'remote cursor receiver did not receive a connection in 60 seconds; aborting.'.			^ self].	Transcript show: 'connection established'; cr.	[sock isConnected]		whileTrue: [			sock dataAvailable				ifTrue: [					response _ sock getResponse.					response asParagraph displayOn: Display at: 10@10]				ifFalse: [					"if no data available, let other processes run for a while"					(Delay forMilliseconds: 20) wait]].	sock destroy.	Transcript show: 'remote cursor receiver done'; cr.! !!SimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'jm 9/15/97 15:16'!remoteCursorTest	"This version of the remote cursor test runs both the client and the server code in the same loop."	"SimpleClientSocket remoteCursorTest"	| sock1 sock2 samplesToSend samplesSent done t |	Transcript show: 'starting remote cursor test'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	Transcript show: 'opening connection'; cr.	sock1 _ SimpleClientSocket new.	sock2 _ SimpleClientSocket new.	sock1 listenOn: 54321.	sock2 connectTo: (NetNameResolver localHostAddress) port: 54321.	sock1 waitForConnectionUntil: self standardDeadline.	sock2 waitForConnectionUntil: self standardDeadline.	(sock1 isConnected) ifFalse: [self error: 'sock1 not connected'].	(sock2 isConnected) ifFalse: [self error: 'sock2 not connected'].	Transcript show: 'connection established'; cr.	samplesToSend _ 100.	t _ Time millisecondsToRun: [		samplesSent _ 0.		done _ false.		[done]			whileFalse: [				(sock1 sendDone and: [samplesSent < samplesToSend]) ifTrue: [					sock1 sendCommand: self sensorStateString.					samplesSent _ samplesSent + 1].				sock2 dataAvailable ifTrue: [					sock2 getResponse asParagraph displayOn: Display at: 10@10].				done _ samplesSent = samplesToSend]].	sock1 destroy.	sock2 destroy.	Transcript show: 'remote cursor test done'; cr.	Transcript show:		samplesSent printString, ' samples sent in ',		t printString, ' milliseconds'; cr.	Transcript show: ((samplesSent * 1000) // t) printString, ' samples/sec'; cr.! !!SimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'jm 9/15/97 13:11'!sensorStateString	"SimpleClientSocket sensorStateString"	| pt buttons s |	pt _ Sensor cursorPoint.	buttons _ Sensor primMouseButtons.	s _ WriteStream on: (String new: 100).	s nextPutAll: pt x printString.	s space.	s nextPutAll: pt y printString.	s space.	s nextPutAll: buttons printString.	^ s contents! !!SimpleClientSocket class methodsFor: 'other examples' stamp: 'tk 1/3/98 21:12'!crLf	^CrLf! !!SimpleClientSocket class methodsFor: 'other examples' stamp: 'jm 9/17/97 14:27'!finger: userName	"SimpleClientSocket finger: 'stp'"	| addr s |	addr _ NetNameResolver promptUserForHostAddress.	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 79.  "finger port number"	s waitForConnectionUntil: self standardDeadline.	s sendCommand: userName.	Transcript show: s getResponse.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!SimpleClientSocket class methodsFor: 'other examples' stamp: 'jm 9/17/97 14:22'!timeTest	"SimpleClientSocket timeTest"	| addr s |	addr _ NetNameResolver promptUserForHostAddress.	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 13.  "time port number"	s waitForConnectionUntil: self standardDeadline.	Transcript show: s getResponse.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !When asked to process: a Web request, this ServerAction simply executes its processBlock -- the simplest possible server action. It is the responsibility of the block to send a reply: to the request.!!SinglePlugServerAction methodsFor: 'URL processing' stamp: 'mjg 11/10/97 09:00'!process: request	processBlock value: request.! !!SinglePlugServerAction methodsFor: 'accessing' stamp: 'mjg 11/10/97 09:00'!processBlock: aBlock	processBlock := aBlock.! !SketchEditorMorph comment:'	Inst vars (converting to morphic events)hostView -- SketchMorph we are working on.stampForm -- Stamp is stored here.canvasRectangle -- later use boundspalette -- the PaintBox interface Morphdirty -- not usedcurrentColor ticksToDwell rotationCenter registrationPoint newPicBlock -- do this after paintingaction -- selector of painting actionpaintingForm -- our copycomposite -- now paintArea origin.  world relative.  stop using it.dimForm -- SketchMorph of the dimmed background.  Opaque.  		installed behind the editor morph.buff brush -- 1-bit Form of the brush, paintingFormPen formCanvas -- Aim it at paintingForm to allow it to draw ovals, rectangles, lines, etc.picToComp dimToComp compToDisplay -- used to composite -- obsoletepicToBuff brushToBuff buffToBuff buffToPic rotationButton scaleButton -- submorphs, handles to do these actions.strokeOrigin -- During Pickup, origin of rect. cumRot cumMag -- cumulative for multiple operations from same originalundoBuffer lastEvent currentNib -- 1 bit deep form.For now, we do not carry the SketchMorph''s registration point, rotation center, or ticksToDwell.Registration point convention:  In a GraphicFrame, reg point is relative to this image''s origin.During painting, it is relative to canvasRectangle origin, and thus us absolute within the canvas.  To convert back, subract newBox origin.Be sure to convert back and forth correctly.  In deliverPainting. initializeFromFrame:inView: '!!SketchEditorMorph methodsFor: 'initialization' stamp: 'tk 11/5/97 16:40'!initializeFor: aSketchMorph inWorld: aWorldMorph	hostView _ aSketchMorph.	self bounds: (aWorldMorph paintAreaFor: aSketchMorph).	canvasRectangle _ bounds translateBy: aWorldMorph viewBox origin.	palette _ aWorldMorph paintBox.	aWorldMorph addMorphFront: palette.	"Bring it in front"	aWorldMorph fullRepaintNeeded.	paintingForm _ Form extent: bounds extent 		depth: aWorldMorph canvas depth.	self dimTheWindow.	"And set up the bitBlts"	aSketchMorph ~~ nil ifTrue:		[aSketchMorph form displayOn: paintingForm 			at: (hostView bounds origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth"		rotationCenter _ aSketchMorph rotationCenter].	palette rememberColorsFrom: paintingForm.	self resumePainting.! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'jm 7/31/97 15:08'!drawOn: aCanvas	"Put the painting on the display"	paintingForm ifNotNil: [		aCanvas image: paintingForm at: bounds origin]. ! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'jm 7/28/97 11:49'!handlesMouseDown: evt	^ true! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'tk 6/11/97 20:36'!initMorph	"Prepare to paint.  6/11/97 20:35 tk"! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'jm 7/30/97 17:11'!mouseDown: evt	"Start a new stroke.  Check if any palette setting have changed.  6/11/97 20:30 tk"	"verify that we are in a good state"	self verifyState.		"includes prepareToPaint and #scalingOrRotate"	undoBuffer _ paintingForm deepCopy.	"know we will draw something"	paintingFormPen place: (evt cursorPoint - bounds origin).	strokeOrigin _ evt cursorPoint.		"origin point for pickup: rect: ellispe: polygon: line: star:.  Always take it."	action == #pickup: ifTrue: [		evt hand showTemporaryCursor: Cursor corner].	action == #polygon: ifTrue: [self polyNew: evt].	"a mode lets you drag vertices"! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'tk 10/19/97 11:05'!mouseEnter: evt	"Set the cursor.  Reread colors if embedded editable polygon needs it."	| curs poly top |	super mouseEnter: evt.	top _ evt hand recipientForMouseDown: evt.	top == self ifTrue: ["none of my buttons in the way"		curs _ palette actionCursor.		evt hand showTemporaryCursor: curs			hotSpotOffset: (curs ifNil: [0@0] ifNotNil: [curs offset]).		palette getSpecial == #polygon: ifTrue:			[(poly _ self valueOfProperty: #polygon) ifNil: [^ self].			currentColor _ palette getColor.			poly color: currentColor; borderWidth: palette getNib width.			poly changed]].! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'tk 7/23/97 21:53'!mouseLeave: evt	"Set the cursor."	super mouseLeave: evt.	evt hand showTemporaryCursor: nil		hotSpotOffset: 0@0.	"back to normal"	"If this is modified to close down the SketchEditorMorph in any way, watch out for how it is called when entering a rotationButton and a scaleButton."! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'tk 7/15/97 14:49'!mouseMove: evt	"In the middle of drawing a stroke.  6/11/97 19:51 tk"	| pt |	pt _ evt cursorPoint.	(lastEvent ~~ nil and: [pt = lastEvent cursorPoint]) ifTrue: [^ self].	self perform: action with: evt.		"Each action must do invalidRect:"	lastEvent _ evt.	false ifTrue: ["So senders will find the things performed here"		self paint: nil; fill: nil; areaFill: nil; erase: nil; pickup: nil; stamp: nil.		self rect: nil; ellipse: nil; polygon: nil; line: nil; star: nil].! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'tk 7/7/97 10:45'!mouseUp: evt	"Do nothing except those that work on mouseUp."	action == #fill: ifTrue: [		self perform: action with: evt.		"Each action must do invalidRect:"		].	action == #areaFill: ifTrue: ["old, remove it"		self perform: action with: evt.		"Each action must do invalidRect:"		].	action == #pickup: ifTrue: [		self pickupMouseUp: evt].	lastEvent _ nil.! !!SketchEditorMorph methodsFor: 'access'!currentColor	^ currentColor! !!SketchEditorMorph methodsFor: 'access'!currentColor: aColor	currentColor _ aColor.	"Caller must set the pens' color himself.  It is complicated."! !!SketchEditorMorph methodsFor: 'access' stamp: 'tk 9/2/97 16:02'!forwardDirection	"The direction object will go when issued a sent forward:.  Up iszero.  Clockwise like a compass.  From the arrow control."| bb |bb _ (self valueOfProperty: #fwdButton).^ (self center - bb vertices first) degrees - 90.0! !!SketchEditorMorph methodsFor: 'access'!hostView	^ hostView! !!SketchEditorMorph methodsFor: 'access'!painting	^ paintingForm! !!SketchEditorMorph methodsFor: 'access'!palette	^palette! !!SketchEditorMorph methodsFor: 'access'!registrationPoint	^ registrationPoint! !!SketchEditorMorph methodsFor: 'access'!registrationPoint: aPoint	registrationPoint _ aPoint! !!SketchEditorMorph methodsFor: 'access' stamp: 'tk 9/3/97 17:12'!rotationStyle^ (self valueOfProperty: #rotationStyle) ifNil: [#normal]! !!SketchEditorMorph methodsFor: 'access' stamp: 'tk 7/4/97 10:17'!save: aForm	"Save these bits.  Not to be confused with the Save command.  "	stampForm _ aForm! !!SketchEditorMorph methodsFor: 'access'!ticksToDwell	ticksToDwell == nil ifTrue: [ticksToDwell _ 1].	^ ticksToDwell! !!SketchEditorMorph methodsFor: 'access'!ticksToDwell: t	ticksToDwell _ t! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/28/97 15:31'!afterNewPicDo: goodBlock ifNoBits: badBlock	"If the user said 'Save' at the end of drawing, do this block to save the picture.goodBlock takes 2 args, the painted form and the bounding rectangle of its bits.badBlock takes no args.  "	newPicBlock _ goodBlock.	emptyPicBlock _ badBlock.! !!SketchEditorMorph methodsFor: 'start & finish'!backgroundFromUser	^ self deliverPainting: (self getPaintingStartingWith: nil at: nil).	"Caller will want to fetch (aSketchEditorMorph painting) to get one that has not been trimmed"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 4/20/97'!cancel	"Palette is telling us that the use wants to end the painting session.  "	Cursor blank show.	self deliverPainting: #cancel.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/28/97 15:52'!cancelOutOfPainting	self delete.	dimForm delete.	emptyPicBlock value.	"note no args to block!!"	hostView changed.	^ nil	"Tell them we cancelled"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/31/97 11:12'!deliverPainting: result	"Done painting.  May come from resume, or from original call.  Execute user's post painting instructions in the block.  Always use this standard one.  4/21/97 tk"	| newBox newForm |	action == #areaFill: ifTrue: [palette setCurrentBrush: palette brush3a].	palette setAction: #paint:.	"Get out of odd modes"	"rot _ palette getRotations."	"rotate with heading, or turn to and fro"	"palette setRotation: #normal."	result == #cancel ifTrue: [^ self cancelOutOfPainting].	"for Morphic"	"hostView rotationStyle: rot."		"rotate with heading, or turn to and fro"	newBox _ paintingForm innerPixelRectFor: 0 orNot: true.	registrationPoint ifNotNil:		[registrationPoint _ registrationPoint - newBox origin]. "relative to newForm origin"	newForm _ 	Form extent: newBox extent depth: paintingForm depth.	newForm copyBits: newBox from: paintingForm at: 0@0 		clippingBox: newForm boundingBox rule: Form over fillColor: nil.	newForm isAllWhite ifTrue: [		(self valueOfProperty: #background) == true 			ifFalse: [^ self cancelOutOfPainting]].	self delete.	"so won't find me again"	dimForm delete.	newPicBlock value: newForm value: (newBox copy translateBy: bounds origin).! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'jm 10/15/97 22:39'!dimTheWindow	"Do not call twice!!  Installs a morph with the background behindme.  6/12/97 12:29 tk"	| dim map notTrans fwdButton pt toggle |	"create a dim version of the stuff on the screen"	"dim _ Form fromDisplay: canvasRectangle."	dim _ owner imageFormForRectangle: self bounds.	dim fill: dim boundingBox		rule: (dim depth < 16 ifTrue: [Form and] ifFalse: [Form under])		fillColor: (Color pixelScreenForDepth: dim depth).	map _ (Color cachedColormapFrom: dim depth to: dim depth) copy.	map _ map collect: [:c |		c = 0 ifTrue: [Color white pixelValueForDepth: dim depth]ifFalse: [c]].	notTrans _ BitBlt toForm: dim.	notTrans colorMap: map; sourceForm: dim; combinationRule: Form over;		destRect: dim boundingBox; sourceOrigin: 0@0; copyBits.	dimForm _ SketchMorph new form: dim.	dimForm position: self position.	owner privateAddMorph: dimForm atIndex: (owner submorphs indexOf:self)+1.	"Rotation and scaling handles"	rotationButton _ SketchMorph new form: (palette rotationTabForm).	rotationButton position: bounds topCenter - (6@0).	rotationButton on: #mouseDown send: #rotateScalePrep to: self.	rotationButton on: #mouseStillDown send: #rotateBy: to: self.	rotationButton on: #mouseUp send: #rotateDone: to: self.	rotationButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	rotationButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: rotationButton.	rotationButton setBalloonText: 'Drag me sideways to\rotate yourpicture.' withCRs.	scaleButton _ SketchMorph new form: (palette scaleTabForm).	scaleButton position: bounds rightCenter - ((scaleButton width)@6).	scaleButton on: #mouseDown send: #rotateScalePrep to: self.	scaleButton on: #mouseStillDown send: #scaleBy: to: self.	scaleButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	scaleButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: scaleButton.	scaleButton setBalloonText: 'Drag me up and down to change\the sizeof your picture.' withCRs.	fwdButton _ PolygonMorph new.	pt _ "rotationButton topRight" bounds topCenter.	fwdButton borderWidth: 2; makeOpen; makeBackArrow; borderColor:(Color r: 0 g: 0.8 b: 0).	fwdButton removeHandles; setVertices: (Array with: pt+(0@7) with:pt+(0@22)).	fwdButton on: #mouseStillDown send: #forward:direction: to: self.	fwdButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursorback"	fwdButton on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdButton toValue: fwdButton.	self addMorph: fwdButton.	fwdButton setBalloonText: 'Drag me around to point\in the directionI go forward.' withCRs.	toggle _ EllipseMorph		newBounds: (Rectangle center: fwdButton vertices last +(-4@4) extent: 8@8)		color: Color gray.	toggle on: #mouseUp send: #toggleDirType:in: to: self.	toggle on: #mouseEnter send: #mouseLeave: to: self.	"Put cursorback"	toggle on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdToggle toValue: toggle.	fwdButton addMorph: toggle.	toggle setBalloonText: 'When your object turns,\how should itspicture change?\It can rotate, face left or right,\face up or down, or notchange.' withCRs.	self setProperty: #rotationStyle toValue: hostView rotationStyle.	self forward: hostView forwardDirection direction: fwdButton.	"Set to its current value"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/28/97 16:15'!getPaintingStartingWith: initialForm at: aRectangle	canvasRectangle _ bounds translateBy: self world viewBox origin.	paintingForm _ Form extent: canvasRectangle extent 		depth: self world canvas depth.	self dimTheWindow.	"And set up the bitBlts"	initialForm ~~ nil ifTrue:		["paintingForm copy: (0@0 extent: aRectangle extent) 			from: 0@0 in: initialForm form rule: Form over."		initialForm displayOn: paintingForm 			at: (aRectangle origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.			"assume they are the same depth"		"initialForm displayOn: Display 			at: (aRectangle translateBy: canvasRectangle origin) origin			clippingBox: (aRectangle translateBy: canvasRectangle origin)			rule: Form over			fillColor: nil."		].	^ self resumePainting.	! !!SketchEditorMorph methodsFor: 'start & finish'!getRepaintedBackgroundStartingWith: startingForm	"Obtain a revised background painting from the user, given that the point of departure is startingForm, to be displayed in aRectangle."	| result |	result _ self getPaintingStartingWith: startingForm at: canvasRectangle.	^ self deliverPainting: result	"Caller will want to fetch (aSketchEditorMorph painting) to get one that has not been trimmed"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'sw 12/8/96'!getRepaintingStaringWith: startingForm at: aRectangle	"Obtain a revised painting from the user, given that the point of departure is startingForm, to be displayed at aRectangle.	: accept the new graphic even if no fresh paint laid down, so other edits can stick."	| result |	result _ self getPaintingStartingWith: startingForm at: aRectangle.	^ self deliverPainting: result! !!SketchEditorMorph methodsFor: 'start & finish'!handlesMouseOver: evt	^true! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/21/97 12:26'!prepareToPaint	"Figure out what the current brush, fill, etc is.  Return an action to take every mouseMove.  Set up instance variable and pens.  Prep for normal painting is inlined here.  tk 6/14/97 21:11"	| specialMode |	"Install the brush, color, (replace mode), and cursor."	specialMode _ palette getSpecial. 	currentColor  _ palette getColor.	brush _ currentNib _ palette getNib.	paintingFormPen _ Pen newOnForm: paintingForm.	stampForm _ nil.	"let go of stamp"	formCanvas _ FormCanvas on: paintingForm.	"remember to change when undo"	formCanvas _ formCanvas		copyOrigin: self topLeft negated		clipRect: (0@0 extent: bounds extent).	specialMode == #paint: ifTrue: [		"get it to one bit depth.  For speed, instead of going through a colorMap every time ."		brush _ Form extent: brush extent depth: 1.		brush offset: (0@0) - (brush extent // 2).		currentNib displayOn: brush at: (0@0 - currentNib offset).		paintingFormPen sourceForm: brush.		paintingFormPen combinationRule: Form paint.		paintingFormPen color: currentColor.		currentColor isTransparent ifTrue: [			paintingFormPen combinationRule: Form erase1bitShape.			paintingFormPen color: Color black].		^ #paint:].	specialMode == #erase: ifTrue: [		self erasePrep.		^ #erase:].	specialMode == #stamp: ifTrue: [		stampForm _ palette stampForm.	"keep it"		^ #stamp:].	(self respondsTo: specialMode) 		ifTrue: [^ specialMode]	"fill: areaFill: pickup: (in mouseUp:) 				rect: ellipse: line: polygon: star:"		ifFalse: ["Don't recognise the command"			palette setAction: #paint:.	"set it to Paint"			^ self prepareToPaint].! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 3/14/97'!resume	"Just came back from another window.  Keep painting.  Save the picture after.  "	^ self deliverPainting: self resumePainting! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'di 10/14/97 06:23'!resumePainting	"Set everything up.  Amazingly, it's all handled by verifyState!!"	"palette thumbnailOn: hostView.		not used in current paintbox"	"palette setRotation: hostView rotationStyle."	"stillScaling now will be indicated by action == #scaleOrRotate"	! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/28/97 14:14'!save	"Palette is telling us that the use wants to end the painting session.  "	Cursor blank show.	action == #polygon: ifTrue: [self polyFreeze].		"end polygon mode"	^ self deliverPainting: #okay.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 4/3/97'!setRotations: num	"Tell the palette what number of rotations (or background) to show.  "	| key |	key _ 'ItTurns'.	"default and value for num > 1"	num == 1 ifTrue: [key _ 'JustAsIs'].	num == 18 ifTrue: [key _ 'ItTurns'].	num == 99 ifTrue: [key _ 'ToAndFro'].	num == #Background ifTrue: [key _ 'Background'].	num == #Repeated ifTrue: [key _ 'Repeated'].	palette setRotations: (palette contentsAtKey: key).! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'sw 8/13/96'!singleImageFromUser	"Let the user paint a single image, and return an array consisting of the form and its bounding box.  "	| result |	ticksToDwell _ 1.	result _ self getPaintingStartingWith: nil at: nil.	^ self deliverPainting: result! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 9/10/97 15:34'!undo	"revert to a previous state.  "	| temp poly |	undoBuffer ifNil: [^ self beep].	"nothing to go back to"	(poly _ self valueOfProperty: #polygon) ifNotNil:		[poly delete.		self setProperty: #polygon toValue: nil.		^ self].	temp _ paintingForm.	paintingForm _ undoBuffer.	undoBuffer _ temp.		"can get back to what you had byundoing again"	paintingFormPen setDestForm: paintingForm.	formCanvas _ FormCanvas on: paintingForm.	"used for lines,ovals, etc."	formCanvas _ formCanvas		copyOrigin: self topLeft negated		clipRect: (0@0 extent: bounds extent).	self render: bounds.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/21/97 12:31'!verifyState	"We are sure we will make a mark now.  Make sure the palette has not changed state while we were away.  If so, end this action and start another one.  6/11/97 19:52 tk  action, currentColor, brush"	"Install the brush, color, (replace mode), and cursor."	action == palette getSpecial ifFalse: [		self invalidRect: rotationButton bounds.	"snap these back"		rotationButton position: bounds topCenter - (6@0).		"later adjust by button width?"		self invalidRect: rotationButton bounds.		self invalidRect: scaleButton bounds.		scaleButton position: bounds rightCenter - ((scaleButton width)@6).		self invalidRect: scaleButton bounds.		action == #polygon: ifTrue: [self polyFreeze].		"end polygon mode"		^ action _ self prepareToPaint].	action == #paint: ifTrue: [		currentNib = palette getNib ifFalse: [			currentNib _ palette getNib.			"Change the nib on the cursor (Hand)"			"get it to one bit depth.  For speed, instead of going through 				a colorMap every time ."			brush _ Form extent: currentNib extent depth: 1.			brush offset: (0@0) - (brush extent // 2).			currentNib displayOn: brush at: (0@0 - currentNib offset).			paintingFormPen sourceForm: brush]].	action == #erase: ifFalse: [	 	currentColor = palette getColor ifFalse: [			currentColor _ palette getColor.			"Change the color of the nib on the cursor (Hand)"			paintingFormPen color: currentColor.			currentColor isTransparent 				ifTrue: [					paintingFormPen combinationRule: Form erase1bitShape.					paintingFormPen color: Color black]				ifFalse: [paintingFormPen combinationRule: Form paint]]]		ifTrue: [palette getNib width = brush width ifFalse: [self erasePrep]].	"it changed"	action == #stamp: ifTrue: [		stampForm _ palette stampForm.	"get the current form"		stampForm ifNil: [self error: 'no stamp']].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/28/97 16:01'!areaFill: evt	"Find the area that is the same color as where you clicked.  Fill it with the current paint color."evt isMouseUp ifTrue: ["Only fill upon mouseUp"	Cursor execute showWhile:		[paintingForm shapeFill: self currentColor interiorPoint: evt cursorPoint - bounds origin.		self render: bounds.	"would like to only invalidate the area 				changed, but can't find out what it is."		]].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 6/11/97 20:27'!brushAlphaFromGray	"Get currentNib again, (a gray-scale Form) and transform it into an alpha brush.  3/15/97 tk"	| d alphaMap this alpha colorMaker newBox smallNib |	currentNib _ palette getNib.	newBox _ currentNib innerPixelRectFor: 0 orNot: true.	"minimum size"	smallNib _ Form extent: newBox extent depth: currentNib depth.	smallNib copyBits: newBox from: currentNib at: 0@0 		clippingBox: smallNib boundingBox rule: Form over fillColor: nil."smallNib display.  newBox printString displayAt: 0@50."	d _ currentNib depth.	"usually 8"	alphaMap _ (Color cachedColormapFrom: d to: 32) copy.	"force a map to be there"	1 to: alphaMap size do: [:pixVal |		this _ Color colorFromPixelValue: pixVal-1 depth: d.		alpha _ 1.0 - this brightness.	"based on brightness"		"alpha _ alpha * 0.14 - 0.01."	"Adjust sensitivity for buffer depth"		"alpha _ alpha raisedTo: 2.0."	"Adjust sensitivity for buffer depth"		alphaMap at: pixVal 				put: ((currentColor alpha: alpha) pixelWordForDepth: 32)].		brush _ Form extent: smallNib extent depth: 32.	"brush offset: smallNib offset."	colorMaker _ BitBlt toForm: brush.	colorMaker sourceForm: smallNib; colorMap: alphaMap.	colorMaker sourceOrigin: 0@0; destOrigin: 0@0; combinationRule: Form over;		width: brush width; height: brush height; copyBits.	^ brush	! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/21/97 16:32'!clear	"wipe out all the paint"	self polyFreeze.		"end polygon mode"	paintingForm fillWithColor: Color transparent.	self invalidRect: bounds.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'jm 7/28/97 14:58'!ellipse: evt	"Draw an ellipse from the center. "	| rect oldRect ww ext oldExt |	ext _ (strokeOrigin - evt cursorPoint) abs * 2.	evt shiftPressed ifTrue: [ext _ ext r].	rect _ Rectangle center: strokeOrigin extent: ext.	ww _ palette getNib width.	lastEvent ifNotNil: [		oldExt _ (strokeOrigin - lastEvent cursorPoint) abs + ww * 2.		lastEvent shiftPressed ifTrue: [oldExt _ oldExt r].		(oldExt < ext) ifFalse: ["Last draw sticks out, must erase the area"			oldRect _ Rectangle center: strokeOrigin extent: oldExt.			self restoreRect: oldRect]].	formCanvas fillOval: rect color: currentColor 		borderWidth: ww borderColor: Color black.	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/2/97 09:02'!erase: evt	"Pen is set up to draw transparent squares"	self paint: evt! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/19/97 10:53'!erasePrep	"Transparent paint, square brush.  Be careful not to let this be undone by asking palette for brush and color."	| size |	size _ palette getNib width.	brush _ Form extent: size@size depth: 1.	brush offset: (0@0) - (brush extent // 2).	brush fillWithColor: Color black.	paintingFormPen sourceForm: brush.	"transparent"	paintingFormPen combinationRule: Form erase1bitShape.	paintingFormPen color: Color black.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/28/97 16:01'!fill: evt	"Find the area that is the same color as where you clicked.  Fill it with the current paint color."evt isMouseUp ifTrue: ["Only fill upon mouseUp"	Cursor execute showWhile:		[paintingForm shapeFill: self currentColor interiorPoint: evt cursorPoint - bounds origin.		self render: bounds.	"would like to only invalidate the area 				changed, but can't find out what it is."		]].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/7/97 22:23'!flipHoriz: evt	"Flip the image"| temp |temp _ buff deepCopy flipBy: #horizontal centerAt: buff center.temp offset: 0@0.paintingForm fillWithColor: Color transparent.temp displayOn: paintingForm at: (paintingForm center - buff center + buff offset).rotationButton position: (evt cursorPoint x - 6) @ rotationButton position y.self render: bounds.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/7/97 22:22'!flipVert: evt	"Flip the image"| temp |temp _ buff deepCopy flipBy: #vertical centerAt: buff center.temp offset: 0@0.paintingForm fillWithColor: Color transparent.temp displayOn: paintingForm at: (paintingForm center - buff center + buff offset).rotationButton position: (evt cursorPoint x - 6) @ rotationButton position y.self render: bounds.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/3/97 21:11'!forward: evt direction: button	"Move the forward direction arrow of this painting.  When the usersays forward:, the object moves in the direction of the arrow.  evt may bean Event (from the user moving the arrow), or an initial number ofdegrees."	| center dir ww ff |	center _ bounds center "+ (rotationButton width - 6 @ 0)".	evt isNumber ifTrue: [dir _ Point r: 100 degrees: evt - 90.0"convert to 0 on X axis"]		ifFalse: [dir _ evt cursorPoint - center].	ww _ (bounds height min: bounds width)//2 - 7.	button setVertices: (Array		with: (center + (Point r: ww degrees: dir degrees))		with: (center + (Point r: ww-15 degrees: dir degrees))).	(ff _ self valueOfProperty: #fwdToggle) position:		(center + (Point r: ww-7 degrees: dir degrees + 6.5)) - (ffextent // 2).	self showDirType.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/12/97 19:41'!line: evt	"Draw a line on the paintingForm using formCanvas aimed at it."	| rect oldRect ww now diff cor |	rect _ strokeOrigin rect: (now _ evt cursorPoint).	evt shiftPressed ifTrue:		[diff _ evt cursorPoint - strokeOrigin.		now _ strokeOrigin + (Point r: diff r degrees: (diffdegrees + 22.5 // 45 * 45)).		rect _ strokeOrigin rect: now].	ww _ palette getNib width.	lastEvent ifNotNil:		[oldRect _ strokeOrigin rect: lastEvent cursorPoint.		lastEvent shiftPressed ifTrue:			[diff _ lastEvent cursorPoint - strokeOrigin.			cor _ strokeOrigin + (Point r: diff r degrees:(diff degrees + 22.5 // 45 * 45)).			oldRect _ strokeOrigin rect: cor].		oldRect _ oldRect expandBy: ww@ww.		"Last draw will always stick out, must erase the area"		self restoreRect: oldRect].	formCanvas line: strokeOrigin to: now width: ww color: currentColor.	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps'!notes	"Singleton costumes.Registration points"! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/28/97 16:01'!paint: evt	"While the mouse is down, lay down paint, but only within window bounds.	 11/28/96 sw: no longer stop painting when pen strays out of window; once it comes back in, resume painting rather than waiting for a mouse up"	|  mousePoint startRect endRect |	mousePoint _ evt cursorPoint.	startRect _ paintingFormPen location + brush offset extent: brush extent.	paintingFormPen goto: mousePoint - bounds origin.	endRect _ paintingFormPen location + brush offset extent: brush extent.	"self render: (startRect merge: endRect).	Show the user what happened"	self invalidRect: ((startRect merge: endRect) translateBy: bounds origin).! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'jm 7/30/97 17:36'!pickup: evt	"Grab a part of the picture (or screen) and store it in a known place.  Note where we started.  Use a rubberband rectangle to show what is being selected."	| rect oldRect |	rect _ strokeOrigin rect: evt cursorPoint + (14@14).	lastEvent == nil ifFalse: [			"Last draw will stick out, must erase the area"			oldRect _ strokeOrigin rect: lastEvent cursorPoint + (14@14).			self restoreRect: oldRect].	formCanvas frameAndFillRectangle: rect fillColor: Color transparent		borderWidth: 2 borderColor: Color gray.	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'jm 10/15/97 22:41'!pickupMouseUp: evt	"Grab a part of the picture (or screen) and store it in a known place. Like Copy on the Mac menu. Then switch to the stamp tool."	| rr pp pForm ii oldRect curs |	lastEvent == nil ifFalse: [			"Last draw will stick out, must erase the area"			oldRect _ strokeOrigin rect: lastEvent cursorPoint + (14@14).			self restoreRect: oldRect].	self primaryHand showTemporaryCursor: nil.	"later get rid of this"		rr _ strokeOrigin rect: evt cursorPoint + (14@14).	pp _ rr translateBy: self world viewBox origin.	ii _ rr translateBy: (0@0) - bounds origin.	(rr intersects: bounds) ifTrue: [		pForm _ paintingForm copy: ii.		pForm primCountBits > 0 			ifTrue: []	"normal case.  Can be transparent in parts"			ifFalse: [pForm _ nil.			"Get an un-dimmed picture of other objects on the playfield"			"don't know how yet"]].	pForm ifNil: [pForm _ Form fromDisplay: pp].		"Anywhere on the screen"	palette pickupForm: pForm.	curs _ palette actionCursor.	evt hand		showTemporaryCursor: curs 		hotSpotOffset: (curs ifNil: [0@0] ifNotNil: [curs offset]).! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/10/97 15:36'!polyFreeze	"A live polygon is on the painting.  Draw it into the painting anddelete it."	| poly |	(poly _ self valueOfProperty: #polygon) ifNil: [^ self].	poly drawOn: formCanvas.	poly delete.	self setProperty: #polygon toValue: nil.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/7/97 11:25'!polygon: evt	"Action is in polyVerts: from mouseDown:.  Do nothing here."! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/3/97 22:04'!polyNew: evt	"Create a new polygon.  Add it to the sketch, and let the user dragits vertices around!!  Freeze it into the painting when the user choosesanother tool."	| poly |	self polyFreeze.		"any old one we were working on"	poly _ PolygonMorph new addHandles.	poly color: currentColor; borderWidth: palette getNib width;borderColor: Color black.	poly position: evt cursorPoint.	self addMorph: poly.	poly changed.	self setProperty: #polygon toValue: poly.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/21/97 12:31'!rect: evt	"While moving corner, just write on the canvas.  When done, writeon the paintingForm"	| rect within oldRect now diff cor |	rect _ strokeOrigin rect: (now _ evt cursorPoint).	evt shiftPressed ifTrue:		[diff _ evt cursorPoint - strokeOrigin.		now _ strokeOrigin +			(Point r: (diff x abs min: diff y abs)*2 degrees:(diff degrees // 90 * 90 + 45)).		rect _ strokeOrigin rect: now].	lastEvent == nil ifFalse:		[oldRect _ strokeOrigin rect: lastEvent cursorPoint.		lastEvent shiftPressed ifTrue:			[diff _ lastEvent cursorPoint - strokeOrigin.			cor _ strokeOrigin + (Point r: (diff x abs min:diff y abs)*2						degrees: (diff degrees //90 * 90 + 45)).			oldRect _ strokeOrigin rect: cor].		within _ (rect containsRect: oldRect).		within & (currentColor isTransparent not) ifFalse:			["Last draw will stick out, must erase the area"			self restoreRect: oldRect]].	formCanvas frameAndFillRectangle: rect fillColor: currentColor		borderWidth: (palette getNib width) borderColor: Color black.	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: '6/13/97 09:14 '!render: damageRect	"Compose the damaged area again and store on the display.  damageRect is relative to paintingForm origin.  3/19/97 tk"	self invalidRect: damageRect.	"Now in same coords as self bounds""	| rect |	rect _ damageRect translateBy: composite.	just within this window	dimToComp destRect: rect; 		sourceOrigin: damageRect origin; copyBits.	picToComp destRect: rect; 		sourceOrigin: damageRect origin; copyBits.	rotationButton copyBits.	scaleButton copyBits.	compToDisplay sourceRect: rect; 		destOrigin: canvasRectangle origin + damageRect origin; copyBits."! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 6/16/97 15:38'!replaceOnly: initialMousePoint	"Paint replacing only one color!!  Call this each stroke.  Also works for replacing all but one color.  "! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'jm 7/28/97 14:56'!restoreRect: oldRect	"Restore the given rectangular area of the painting Form from the undo buffer."	formCanvas image: undoBuffer		at: oldRect origin		sourceRect: (oldRect translateBy: self topLeft negated)		rule: Form over.	self invalidRect: oldRect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/28/97 16:01'!rotateBy: evt	"Left-right is rotation.  3/26/97 tk  Slider at top of window.  4/3/97 tk"| pt temp amt smooth |evt cursorPoint x - self left < 20 ifTrue: [^ self flipHoriz: evt].	"at left end flip horizontal"evt cursorPoint x - self right > -20 ifTrue: [^ self flipVert: evt].	"at right end flip vertical"pt _ evt cursorPoint - bounds center.smooth _ 2.  	"paintingForm depth > 8 ifTrue: [2] ifFalse: [1]."	"Could go back to 1 for speed"amt _ pt x abs < 12 ifTrue: [0 "detent"] ifFalse: [pt x - (12 * pt x abs // pt x)].amt _ amt * 1.8.temp _ buff rotateBy: amt magnify: cumMag smoothing: smooth.temp displayOn: paintingForm at: (paintingForm center - temp center + buff offset).rotationButton position: (evt cursorPoint x - 6) @ rotationButton position y.self render: bounds.cumRot _ amt.	"what we settled on"! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: '6/13/97 17:55 '!rotateDone: evt	"MouseUp, snap box back to center.""self render: rotationButton bounds.rotationButton position: (canvasRectangle width // 2 + composite x) @ rotationButton position y.self render: rotationButton bounds."		"Not snap back..."! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: '6/13/97 17:42 '!rotateScalePrep	"Make a source that is the paintingForm.  Work from that.  3/26/97 tk"	| newBox |	action == #scaleOrRotate ifTrue: [^ self].	"Already doing it"	paintingForm width > 120 		ifTrue: [newBox _ paintingForm innerPixelRectFor: 0 orNot: true.			"minimum size"			newBox _ newBox insetBy: 				((18 - newBox width max: 0)//2) @ ((18 - newBox height max: 0)//2) * -1]		ifFalse: [newBox _ paintingForm boundingBox].	newBox _ newBox expandBy: 1.	buff _ Form extent: newBox extent depth: paintingForm depth.	buff offset: newBox center - paintingForm center.	buff copyBits: newBox from: paintingForm at: 0@0 		clippingBox: buff boundingBox rule: Form over fillColor: nil.	"Could just run up owner chain asking colorUsed, but may not be embedded"	cumRot _ 0.0.  cumMag _ 1.0.	"start over"	action _ #scaleOrRotate.		"Only changed by mouseDown with tool in paint area"! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/28/97 16:01'!scaleBy: evt	"up-down is scale.  3/26/97 tk  Now a slider on the right."| pt temp cy oldRect amt |pt _ evt cursorPoint - bounds center.cy _ bounds height * 0.5.oldRect _ buff boundingBox expandBy: (buff extent * cumMag / 2).amt _ pt y abs < 12 ifTrue: [1.0 "detent"] ifFalse: [pt y- (12 * pt y abs // pt x)].amt _ amt asFloat / cy + 1.0.temp _ buff rotateBy: cumRot magnify: amt smoothing: 2.cumMag > amt ifTrue: ["shrinking"	oldRect _ oldRect translateBy: (paintingForm center - oldRect center + buff offset).	paintingForm fill: (oldRect expandBy: 1@1) rule: Form over fillColor: Color transparent].temp displayOn: paintingForm at: (paintingForm center - temp center + buff offset).scaleButton position: scaleButton position x @ (evt cursorPoint y - 6).self render: bounds.cumMag _ amt.	"what we settled on"! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/3/97 21:11'!showDirType	"Display the proper symbol for this direction type.  rotationStyleis one of #(normal leftRight upDown none)."| rr poly |rr _ self rotationStyle.poly _ self valueOfProperty: #fwdButton.rr == #normal ifTrue: [^ poly makeBackArrow].rr == #leftRight ifTrue: [	poly makeBothArrows.	^ poly setVertices: (Array with: poly center - (7@0) with:  polycenter + (7@0))].rr == #upDown ifTrue: [	poly makeBothArrows.	^ poly setVertices: (Array with: poly center - (0@7) with:  polycenter + (0@7))].rr == #none ifTrue: [	poly makeNoArrows.	^ poly setVertices: (Array with: poly center - (7@0) with:  polycenter + (7@0)		 with: poly center with: poly center - (0@7) with:  polycenter + (0@7))].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/7/97 17:56'!stamp: evt	"plop one copy of the user's chosen Form down."	"Check depths"	| pt |	pt _ evt cursorPoint - (stampForm extent // 2).	stampForm displayOn: paintingForm 		at: pt - bounds origin		clippingBox: paintingForm boundingBox		rule: Form paint		fillColor: nil.	self render: (pt extent: stampForm extent).! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'jm 8/2/97 14:21'!star: evt	"Draw an star from the center. "	| poly ext ww rect oldExt oldRect oldR verts pt |	ww _ palette getNib width.	ext _ (pt _ strokeOrigin - evt cursorPoint) r + ww * 2.	rect _ Rectangle center: strokeOrigin extent: ext.	ww _ palette getNib width.	lastEvent ifNotNil: [		oldExt _ (strokeOrigin - lastEvent cursorPoint) r + ww * 2.		"Last draw sticks out, must erase the area"		oldRect _ Rectangle center: strokeOrigin extent: oldExt.		self restoreRect: oldRect].	ext _ pt r.	oldR _ ext.	verts _ (0 to: 350 by: 36) collect: [:angle |		(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse: [ext]) degrees: angle + pt degrees)			+ strokeOrigin].		poly _ PolygonMorph new addHandles.	poly color: currentColor; borderWidth: ww; borderColor: Color black.	"self addMorph: poly."	poly privateOwner: self.	poly bounds: (strokeOrigin extent: ext).	poly setVertices: verts.	poly drawOn: formCanvas.	"poly delete."	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/3/97 21:17'!toggleDirType: evt in: handle	"Toggle from 'rotate' to 'to and fro' to 'up and down' to 'none'for the kind of rotation the object does.  An actor's rotationStyle is oneof #(normal leftRight upDown none)."| rr ii |"Clear the indicator""Find new style, store it, install the indicator"rr _ self rotationStyle.ii _ #(normal leftRight upDown none) indexOf: rr.self setProperty: #rotationStyle toValue:	(#(leftRight upDown none normal) at: ii).ii = 4 ifTrue: ["normal" self forward: self forwardDirection			direction: (self valueOfProperty: #fwdButton)]	ifFalse: [self showDirType.].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'di 12/1/97 12:13'!transBrush: evt	"Paint with a semi-transparent brush.  Call this each stroke.  , di"	|  prevP p buffSize theta brushRect buffRect delta newBuffRect updateRect scale half |	scale _ buffToPic cellSize.	"2"	buffSize _ (buff width - brush width) // scale.	"100"	half _ brush extent // 2.	"center"	"buffRect now relative to pictureForm"	buffRect _ (evt cursorPoint - bounds origin) - (buff extent // scale // 2) 		extent: buff extent // scale.	picToBuff copyQuad: buffRect innerCorners toRect: buff boundingBox.	prevP _ ((evt cursorPoint - bounds origin) - buffRect origin) * scale - half.	[Sensor redButtonPressed] whileTrue:		[p _ ((evt cursorPoint - bounds origin) - buffRect origin) * scale - half.				"p, prevP are rel to buff origin"		p ~= prevP ifTrue: [		(p dist: prevP) > buffSize ifTrue:			["Stroke too long to fit in buffer -- clip to buffer,				and next time through will do more of it"			theta _ (p-prevP) theta.			p _ ((theta cos@theta sin) * (buffSize-2) asFloat + prevP) truncated].		brushRect _ p extent: brush extent.		((buff boundingBox insetBy: scale) containsRect: brushRect) ifFalse:			["Brush is out of buffer region.  Scroll the buffer,				and fill new areas from the display"			delta _ (brushRect amountToTranslateWithin: 				(buff boundingBox insetBy: scale)) // scale.			buffToBuff copyFrom: buff boundingBox in: buff to: delta*scale.			newBuffRect _ buffRect translateBy: delta negated.			p _ p translateBy: delta*scale.			prevP _ prevP translateBy: delta*scale.			(newBuffRect areasOutside: buffRect) do:				[:r | picToBuff copyQuad: r innerCorners 						toRect: (r origin - newBuffRect origin*scale extent: r extent*scale)].			buffRect _ newBuffRect].		"Interpolate from prevP to p..."		brushToBuff drawFrom: prevP to: p withFirstPoint: false.		"Update only the altered pixels of the destination"		updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.		updateRect _ updateRect origin // scale * scale				corner: updateRect corner + scale // scale * scale.		"And finally store into the painting""buff displayAt: 0@0."		buffToPic copyQuad: updateRect innerCorners					toRect: (updateRect origin // scale + buffRect origin								extent: updateRect extent // scale).		prevP _ p.		self render: (updateRect origin // scale + buffRect origin										extent: updateRect extent // scale)]].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 3/26/97'!transBrushPrep	"Prepare to paint with a transparent brush at twice the resolution.  Do the work in 32-bits.  See BitBlt.alphaBlendDemo8 for details.  "	| buffSize scale cm1 cm2 |	currentColor class == Bitmap ifTrue: [currentColor _ palette getColor]. "do not force white"	brush _ self brushAlphaFromGray.	"Get currentNib again, 		(a gray-scale Form) and transform it into an alpha brush"	scale _ 3.  "Actual drawing happens at this magnification"	"Scale brush up for painting in magnified buffer"	brush _ brush magnify: brush boundingBox by: scale.	buffSize _ 100.	buff _ Form extent: (buffSize * scale) asPoint + brush extent depth: 32.  "Travelling 32-bit buffer"	picToBuff _ (WarpBlt toForm: buff)  "from Picture to buff - magnify by 2"		sourceForm: paintingForm;		combinationRule: Form over.	cm1 _ (Color cachedColormapFrom: paintingForm depth to: 32) copy.	cm1 ifNotNil: [		"map off-the-edge pixels to the background color, so blend will look right at edge"		cm1 at: 1 put: (self world color pixelValueForDepth: 32)].	picToBuff colorMap: cm1.	brushToBuff _ (BitBlt toForm: buff)  "from brush to buff"		sourceForm: brush;		sourceOrigin: 0@0;		combinationRule: Form blend.	"use buffToPic instead of paintingFormPen"	buffToPic _ (WarpBlt toForm: paintingForm)  "from buff to Picture - shrink by 2"		sourceForm: buff;		cellSize: scale;    "...and use smoothing"		combinationRule: Form over.	cm2 _ (Color cachedColormapFrom: 32 to: paintingForm depth) copy.	cm2 ifNotNil: [		"remap background color to transparent"		cm2 at: (self world color indexInMap: cm2) put: 0].	buffToPic colorMap: cm2.	buffToBuff _ BitBlt toForm: buff.  "for slewing the buffer"! !!SketchEditorMorph class methodsFor: 'instance creation' stamp: 'di 6/22/97 09:07'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!SketchMorph methodsFor: 'initialization' stamp: 'sw 8/12/97 22:08'!initialize	super initialize.	originalForm _ (Form extent: 14@10 depth: 8) fillColor: Color gray.	rotationCenter _ 7@5.		"relative to the top-left corner of the Form"	rotationDegrees _ 0.0.		"clockwise angle of rotation"	rotationStyle _ #normal.		"styles: #normal, #leftRight, #upDown, or #none"	scalePoint _ 1.0@1.0.	framesToDwell _ 1.	rotatedForm _ originalForm.	"cached rotation of originalForm"	offsetWhenRotated _ 0@0.	"offset for rotated form"	self extent: originalForm extent.! !!SketchMorph methodsFor: 'accessing'!form	^ originalForm! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!form: aForm	originalForm _ aForm.	rotationCenter _ aForm extent // 2.	rotationDegrees _ 0.0.	self layoutChanged.! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 9/3/97 15:31'!forwardDirection	"The direction I will go when issued a sent forward:.  Up is zero.Clockwise like a compass."^ (self valueOfProperty: #forwardDirection) ifNil: [0.0]! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 9/2/97 15:55'!forwardDirection: degFromUp	"The direction I will go when issued a sent forward:.  Up is zero.Clockwise like a compass."self setProperty: #forwardDirection toValue: degFromUp! !!SketchMorph methodsFor: 'accessing'!framesToDwell	^ framesToDwell! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!framesToDwell: anInteger	framesToDwell _ anInteger.! !!SketchMorph methodsFor: 'accessing'!referencePosition	^ (bounds origin - offsetWhenRotated) + rotationCenter! !!SketchMorph methodsFor: 'accessing'!referencePosition: aPoint	self position: (aPoint - rotationCenter) + offsetWhenRotated.! !!SketchMorph methodsFor: 'accessing'!rotatedForm	rotatedForm ifNil: [self layoutChanged].	^ rotatedForm! !!SketchMorph methodsFor: 'accessing'!rotationCenter	^ rotationCenter! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!rotationCenter: aPoint	rotationCenter _ aPoint.	self layoutChanged.! !!SketchMorph methodsFor: 'accessing'!rotationDegrees	^ rotationDegrees! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 9/8/97 16:31'!rotationDegrees: angleInDegrees	rotationDegrees ~= angleInDegrees ifTrue:		[rotationDegrees _ angleInDegrees asSmallAngleDegrees.		self layoutChanged].! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 11/4/97 07:42'!rotationDegrees: newRotationDegrees scalePoint: newScalePoint	((newRotationDegrees ~= rotationDegrees) or:	 [scalePoint ~= newScalePoint]) ifTrue: [		"rotationDegrees _ newRotationDegrees \\ 360.0."		rotationDegrees _ newRotationDegrees asSmallAngleDegrees.		scalePoint _ newScalePoint.		self layoutChanged].! !!SketchMorph methodsFor: 'accessing'!rotationStyle	^ rotationStyle! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!rotationStyle: aSymbol	"Set my rotation style to #normal, #leftRight, #upDown, or #none. Styles mean:		#normal		-- continuous 360 degree rotation		#leftRight		-- quantize angle to left or right facing		#upDown		-- quantize angle to up or down facing		#none			-- do not rotate"	rotationStyle _ aSymbol.	self layoutChanged.! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!scalePoint	scalePoint ifNil: [scalePoint _ 1.0@1.0].	^ scalePoint! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!scalePoint: aPoint	scalePoint _ aPoint.	self layoutChanged.! !!SketchMorph methodsFor: 'drawing'!drawOn: aCanvas	aCanvas image: self rotatedForm at: bounds origin.! !!SketchMorph methodsFor: 'geometry'!containsPoint: aPoint	^ (self bounds containsPoint: aPoint) and:	  [(self rotatedForm isTransparentAt: aPoint - bounds origin) not]! !!SketchMorph methodsFor: 'geometry' stamp: 'jm 11/5/97 12:54'!extent: newExtent	"Change my scale to fit myself into the given extent."	| radians s c divisor w h origExtent |	radians _ rotationDegrees degreesToRadians.	s _ radians sin abs.	c _ radians cos abs.	divisor _ (c * c) - (s * s).	w _ ((c * newExtent x) - (s * newExtent y)) / divisor.	h _ ((c * newExtent y) - (s * newExtent x)) / divisor.	origExtent _ originalForm extent.	scalePoint _		((w max: 1) / origExtent x) @		((h max: 1) / origExtent y).	self layoutChanged.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 11/16/97 11:33'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| movies |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'repaint' action: #editDrawing.	aCustomMenu add: 'set rotation center' action: #setRotationCenter.	aCustomMenu add: 'set rotation style' action: #setRotationStyle.	aCustomMenu add: 'erase pixels of color' action: #erasePixelsOfColor:.	aCustomMenu add: 'recolor of pixels of color' action: #recolorPixelsOfColor:.	movies _		(self world rootMorphsAt: aHandMorph targetOffset)			select: [:m | (m isKindOf: MovieMorph) or:						[m isKindOf: SketchMorph]].	(movies size > 1) ifTrue: [		aCustomMenu add: 'insert into movie' action: #insertIntoMovie:].! !!SketchMorph methodsFor: 'menu' stamp: 'sw 9/21/97 13:24'!editDrawing	self flag: #deferred.  "Don't allow this if the user is already in paint mode, because it creates a very strange situation."	self editDrawingInWorld: self world.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 11/13/97 11:12'!editDrawingInWorld: w	w abandonAllHalos.	^ self editDrawingInWorld: w forBackground: false! !!SketchMorph methodsFor: 'menu' stamp: 'di 1/13/98 21:50'!editDrawingInWorld: w forBackground: aBoolean	| oldRotation aPaintWindow oldFwdDir |	w stopRunningAll.	w displayWorld.	aPaintWindow _ SketchEditorMorph new.	aBoolean ifTrue: [aPaintWindow setProperty: #background toValue: true].	w addMorphFront: aPaintWindow.	oldRotation _ rotationDegrees.	oldFwdDir _ self forwardDirection.	self rotationDegrees: 0.	aPaintWindow initializeFor: self inWorld: w.	self rotationDegrees: oldRotation.  "while drawing is still rotated. cancel leaves it right"	aPaintWindow 		afterNewPicDo: [:aForm :aRect |			self form: aForm.			self position: aRect origin.			self forwardDirection: aPaintWindow forwardDirection.			self rotationDegrees: oldRotation + (aPaintWindow forwardDirection - oldFwdDir).				"add in any changes"			self rotationStyle: aPaintWindow rotationStyle.			owner changed]		ifNoBits: ["If no bits drawn.  Must keep old pic.  Can't have no picture"			].	aPaintWindow changed.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 11/12/97 20:04'!erasePixelsOfColor: evt	| c |	c _ evt hand chooseColor.	originalForm mapColor: c to: Color transparent.	self form: (originalForm trimToPixelValue: Color transparent orNot: true).! !!SketchMorph methodsFor: 'menu'!insertIntoMovie: evt	| movies target |	movies _		(self world rootMorphsAt: evt hand targetOffset)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isKindOf: SketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	target _ movies first.	(target isKindOf: SketchMorph) ifTrue: [		target _ target replaceSelfWithMovie].	target insertFrames: (Array with: self).	self delete.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 1/7/98 08:06'!recolorPixelsOfColor: evt	| c d newForm map newC |	c _ evt hand chooseColor.  "color to replace"	newC _ evt hand chooseColor.  "new color"	d _ originalForm depth.	newForm _ Form extent: originalForm extent depth: d.	map _ (Color cachedColormapFrom: d to: d) copy.	map at: (c indexInMap: map) put: (newC pixelValueForDepth: d).	newForm copyBits: newForm boundingBox		from: originalForm at: 0@0		colorMap: map.	self form: newForm.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 7/24/97 15:06'!setRotationCenter	| oldRotation p oldScale |	oldRotation _ rotationDegrees.	oldScale _ scalePoint.	scalePoint _ 1.0@1.0.	self rotationDegrees: 0.0.	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	self rotationCenter: p - bounds origin.	scalePoint _ oldScale.	self rotationDegrees: oldRotation.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 8/2/97 14:45'!setRotationStyle	| menu newStyle |	menu _ CustomMenu new.	#('rotate smoothly' 'left-right flip only' 'top-down flip only' 'don''t rotate')		with: #(normal leftRight upDown none)		 do: [:name :action | menu add: name action: action].	newStyle _ menu startUp.	newStyle ifNotNil: [self rotationStyle: newStyle].! !!SketchMorph methodsFor: 'change reporting' stamp: 'jm 7/24/97 15:06'!layoutChanged	"Update rotatedForm and offsetWhenRotated and compute new bounds."	| unrotatedOrigin |	self changed.	unrotatedOrigin _ bounds origin - offsetWhenRotated.	((rotationDegrees = 0.0 or: [rotationStyle = #none]) and:	 [scalePoint = (1.0@1.0)])		ifTrue: [			"zero rotation and scale; use original Form"			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: [self generateRotatedForm].	"changes offsetWhenRotated"	bounds _ (unrotatedOrigin + offsetWhenRotated) extent: rotatedForm extent.	super layoutChanged.	self changed.! !!SketchMorph methodsFor: 'other' stamp: 'sw 8/20/97 15:31'!addOptionalHandlesTo: aHalo box: box	| aHandle |	aHandle _ aHalo addHandleAt: box bottomLeft color: Color blue.	aHandle on: #mouseDown send: #startRot:with: to: aHalo.	aHandle on: #mouseStillDown send: #doRot:with: to: aHalo.	aHandle _ aHalo addHandleAt: box rightCenter color: Color lightGray.	aHandle on: #mouseDown send: #editDrawing to: aHalo target! !!SketchMorph methodsFor: 'other' stamp: 'sw 8/10/97 01:12'!colorSettable	"Answer whether it is meaningful for the receiver to have its color set from outside"	^ false! !!SketchMorph methodsFor: 'other' stamp: 'jm 7/8/97 10:11'!colorUnder	"Return the color of under the receiver's reference position."	self isInWorld		ifTrue: [^ self world colorAt: self referencePosition belowMorph: self]		ifFalse: [^ self color].! !!SketchMorph methodsFor: 'other' stamp: 'tk 11/3/97 21:58'!generateRotatedForm	"Compute my rotatedForm and offsetWhenRotated."	| pair smoothPix formAngle |	formAngle _ self forwardDirection.  "where user wants forward to be on the picture"	formAngle ifNil: [formAngle _ 0.0].	formAngle _ rotationDegrees - formAngle.  "apply correction"	rotationStyle = #leftRight ifTrue: [		rotationDegrees >= 0 ifTrue: [			"headed right; use original"			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0.		] ifFalse: [			"headed left; use flipped"			rotatedForm _ originalForm flipBy: #horizontal centerAt: 0@0.			offsetWhenRotated _ (2 * (rotationCenter x - (originalForm width // 2)))@0.		].		^ self].	rotationStyle = #upDown ifTrue: [		(rotationDegrees abs <= 90.0) ifTrue: [			"headed up; use original"			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0.		] ifFalse: [			"headed down; use flipped"			rotatedForm _ originalForm flipBy: #vertical centerAt: 0@0.			offsetWhenRotated _ 0@(2 * (rotationCenter y - (originalForm height // 2))).		].		^ self].	"do the actual rotation!!"	((scalePoint x < 1.0) or: [scalePoint y < 1.0])		ifTrue: [smoothPix _ 2]		ifFalse: [smoothPix _ 1].	pair _ WarpBlt		rotate: originalForm		degrees: formAngle negated		center: rotationCenter		scaleBy: self scalePoint		smoothing: smoothPix.	rotatedForm _ pair first.	offsetWhenRotated _ pair last.! !!SketchMorph methodsFor: 'other' stamp: 'jm 11/13/97 16:41'!releaseCachedState	"Clear cache of rotated, scaled Form."	super releaseCachedState.	rotatedForm _ nil.! !!SketchMorph methodsFor: 'other' stamp: 'jm 7/24/97 15:06'!replaceSelfWithMovie	"Replace this SketchMorph in its owner with a MovieMorph containing this sketch as its only frame. This allows a SketchMorph to be turned into a MovieMorph by just insering additional frames."	| o movie |	self changed.	o _ self owner.	movie _ MovieMorph new position: self referencePosition.	movie insertFrames: (Array with: self).	o ifNil: [^ movie].	o addMorphFront: movie.	^ movie! !!SketchMorph methodsFor: 'other'!wearCostume: aMorph	"If the receiver and argument are both kinds of SketchMorph, make the receiver wear the costume of the argument. Otherwise, do nothing. This default implementation does nothing."	| p |	((aMorph isKindOf: SketchMorph) or:	 [aMorph isKindOf: MovieMorph]) ifTrue: [		self changed.		p _ self referencePosition.		originalForm _ aMorph form.		rotationCenter _ aMorph rotationCenter.		self referencePosition: p.		self layoutChanged].! !!SketchMorph methodsFor: 'object fileIn' stamp: 'jm 7/24/97 20:46'!convertbosfceorrrfro0: varDict bosfceorrrsfro0: smartRefStrm	"These variables are automatically stored into the new instance ('originalForm' 'rotationCenter' 'rotationDegrees' 'rotationStyle' 'framesToDwell' 'rotatedForm' 'offsetWhenRotated' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('scalePoint' ) and deal with the information in ()"	scalePoint _ 1.0@1.0.! !!SlantedList methodsFor: 'input events'!listPane1MenuButtonPressed: arg1	self confirm: 'Should the menu be slanted too?'! !!SlantedList methodsFor: 'input events'!listPane1NewSelection: arg1	string1 contents: arg1! !!SlantedList methodsFor: 'input events'!slider1Value: arg1	transform1 scale: slider1 value * 5.0 + 0.2! !!SlantedList methodsFor: 'input events'!slider2Value: arg1	transform1 offset: ((slider4 value @ slider2 value) * 400 - 200) asIntegerPoint! !!SlantedList methodsFor: 'input events'!slider3Value: arg1	transform1 angle: slider3 value - 0.5 * Float pi * 2! !!SlantedList methodsFor: 'input events'!slider4Value: arg1	transform1 offset: ((slider4 value @ slider2 value) * 400 - 200) asIntegerPoint! !!Slider methodsFor: 'initialize'!initialize	super initialize.	bounds := 0@0 corner: 16@100.	color := Color gray.	borderWidth := 2.	borderColor := #inset.	value _ 0.0.	self initializeSlider! !!Slider methodsFor: 'initialize'!initializeSlider	slider := RectangleMorph newBounds: self totalSliderArea color: Color veryLightGray.	slider on: #mouseStillDown send: #scrollAbsolute: to: self.	slider setBorderWidth: 2 borderColor: #raised.	self addMorph: slider.	self computeSlider.! !!Slider methodsFor: 'access'!value	^ value! !!Slider methodsFor: 'access' stamp: '6/7/97 10:42 di'!wantsSlot	"For now do it the old way, until we sort this out"	^ true! !!Slider methodsFor: 'geometry'!computeSlider	| r |	r _ self roomToMove.	slider position: (bounds isWide		ifTrue: [r topLeft + ((r width * value) asInteger @ 0)]		ifFalse: [r topLeft + (0 @ (r height * value)  asInteger)]).	slider extent: self sliderExtent! !!Slider methodsFor: 'geometry'!extent: aPoint	super extent: (aPoint x max: self sliderThickness * 2)					@ (aPoint y max: self sliderThickness * 2).	self removeAllMorphs; initializeSlider! !!Slider methodsFor: 'geometry'!roomToMove	^ self totalSliderArea insetBy: (0@0 extent: self sliderExtent)! !!Slider methodsFor: 'geometry'!sliderExtent	^ bounds isWide		ifTrue: [self sliderThickness @ self innerBounds height]		ifFalse: [self innerBounds width @ self sliderThickness]! !!Slider methodsFor: 'geometry'!sliderThickness	^ 6! !!Slider methodsFor: 'geometry'!totalSliderArea	^ self innerBounds! !!Slider methodsFor: 'scrolling'!scrollAbsolute: event	| r p |	r _ self roomToMove.	p _ event targetPoint adhereTo: r.	self setValue: (bounds isWide 		ifTrue: [(p x - r left) asFloat / r width]		ifFalse: [(p y - r top) asFloat / r height])! !!Slider methodsFor: 'model access'!setValue: newValue	"Called internally for propagation to model"	self value: newValue.	self use: setValueSelector orMakeModelSelectorFor: 'Value:'		in: [:sel | setValueSelector _ sel.  model perform: sel with: value]! !!Slider methodsFor: 'model access'!value: newValue	"Drive the slider position externally..."	value _ newValue min: 1.0 max: 0.0.	self computeSlider! !!SmallInteger methodsFor: 'comparing'!hash	^self! !!SmallInteger methodsFor: 'comparing'!identityHash	^self! !!SmallInteger methodsFor: 'comparing' stamp: 'di 9/27/97 20:32'!identityHashMappedBy: map	^ self! !!SmallInteger methodsFor: 'converting'!adaptToFloat	"Fast conversion equivalent to self asFloat."	<primitive: 40>	self primitiveFailed! !!SmallInteger methodsFor: 'printing'!printOn: aStream base: b	"Refer to the comment in Integer|printOn:base:."	"SmallInteger maxVal printStringBase: 2"	| digitsInReverse x i |	self < 0 ifTrue: [		aStream nextPut: $-.		^ self negated printOn: aStream base: b.	].	b = 10 ifFalse: [aStream print: b; nextPut: $r].	digitsInReverse _ Array new: 32.	x _ self.	i _ 0.	[x >= b] whileTrue: [		digitsInReverse at: (i _ i + 1) put: x \\ b.		x _ x // b.	].	digitsInReverse at: (i _ i + 1) put: x.	[i > 0] whileTrue: [		aStream nextPut: (Character digitValue: (digitsInReverse at: i)).		i _ i - 1.	].! !SmartRefStream comment:'Ordinary ReferenceStreams cannot bring in objects whose instance variables have changed.  This class does that.  1/13/97 tk>>>>See SmartRefStream.aComment for details of how to transform incoming classes to newer versions.<<<< * Allows incoming object to have fewer instance variables than the current class.* Recognises that conversion to new versions is only done after the fact.  Nothing special needs to be done at object file write time.  Prompts for a new version number when there are new inst vars with same initials, and tells how to make conversion work when some files have already been written.* Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure, which is big.  Writes triplets of (version, class structure dictionary, object) on the file.  Has methods for creating the structure description for file-out.* Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset ", so version 2 of it has version tag #bwhdo2.* Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.Note that aDictionary has (old inst var name -> value) * There is a dispatch method to avoid N squared conversions when there are lots of old versions.  It can cascade calls on conversion methods. (not yet)* Prompts the user to write (or file in) a conversion method when needed.* (Does not use DiskProxy, DiskProxyQ, or IOWeakArray)writing		true if writing a file.  To avoid mixing next with nextPut:.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> origin corner)).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except some added on end now.reshaped 	Dictionary of Classes who have a different structure now as on the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name. 				(old class name symbol -> new class name).  Then look new class up in reshaped.topCall		Tells if next or nextPut: coming from the outside.  nil if outside, a Context if 				internal call.>>>>> See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file. '!!SmartRefStream methodsFor: 'all'!aComment"SmartRefStream implements the 'Seeds' object storage system.  Please see the class comment.Headlines:	To bring in an instance of a class whose instance variables have changed, you need only define one conversion method.  The method is named	convertxxxxx: aDictionary yyyyyy: aSmartRefStream.Where xxxxxx is the first letters of all the instance variables in the old instance, and yyyyy are the first letters of all instance variables in the current version of the class.  A Form has inst vars 'bits width height depth offset', so version 2 of it has version tag #bwhdo2.  If the old instance had variables 'bitMap extent depth offsetPoint textDescription', its code would be #bedot0.	Form new convertbedot0: aDictionary bwhdo3: aSmartRefStream.All you have to do is to write the method.  aDictionary has entries (old inst var name -> value), so you can fetch the old vars by name.  See SmartRefStream.catalogValues:size:.  aSmartRefStream is available so you can get at 'structures' which tells the inst vars of other old classes in this file.In the Squeak Goodies Folder, we provide an example.	Suppose there once was a file named ArrayTwoDee.  If it like Array2D in this system, but is implemented differently.  ArrayTwoDee was defined like this: (Array variableSubclass: #ArrayTwoDee instanceVariableNames: 'height '...) so it is a variable class with the array values directly in the instance.  	Array2D uses an instance var for 'contents' instead.   It has width varying most quickly, whereas the old ArrayTwoDee had height varying first.  The order of the elements must be changed.	File in the file ConvArrayTwoDee2.st.It defines SmartRefStream.arrayTwoDeeh2 to return Array2D, so we know what class to convert to.It defines Array2D.converth2:wc0: to do the actual conversion.  Look at the method.  The method 'test' has the code for actually doing the conversion:	| new2D ss |	ss _ SmartRefStream fileNamed: 'ArrayTwoDee.test.obj'.	new2D _ ss next.	ss close.	new2D class == Array2D ifFalse: [self error: 'Class conversion failed'].	(new2D atCol: 1) = #(1 2 3 4) ifFalse: [self error: 'not flipped properly'].	^ new2D	The file ArrayTwoDee.test.obj has the object data in it, and is the actual file we converted.  Note that we never had to file in the old class ArrayTwoDee.  It is never needs to be defined in our system.  	If ArrayTwoDee held an instance variable of another old class, say WeirdNumber, what form would it be in when converth2:wc0: gets run?  All objects get assigned instances in the current system before they are put into the value dictionary.  Generally, leaves of the object tree get converted first, so the values in an instance variable should be fully functioning objects in the current system."! !!SmartRefStream methodsFor: 'all' stamp: 'tk 1/7/97'!catalogValues: instVarList size: varsOnDisk	"Create a dictionary of (name -> value) for the inst vars of this reshaped object.  Indexed vars as (1 -> val) etc.  "	| dict sz |	dict _ Dictionary new.	2 to: instVarList size do: [:ind |		dict at: (instVarList at: ind) put: self next].	sz _ varsOnDisk - (instVarList size - 1).	1 to: sz do: [:ii | 		dict at: ii put: self next].	"Total number read MUST be equal to varsOnDisk!!"	sz > 0 ifTrue: [dict at: #SizeOfVariablePart put: sz].	^ dict! !!SmartRefStream methodsFor: 'all' stamp: 'tk 1/10/97'!fixObjVer1: className	"Temporary bug fix.  Old obj files have no structure entry for Obj and other HyperSqueak classes that have unique instances.  Add the data to structures.  Will also have to read in ObjConvertDec96.st  "	| data ind |	Smalltalk at: #Obj ifAbsent: [^ self].	"non HyperSqueak"	data _ #( "Alias" ()  "BooleanObj" ()  "FastObj" ('blitter' 'fastVelocity ') 		"Folder" ('contentsDictionary') "NumberObj" () 		"Obj" (0 'dependents' 'objectContainedIn' 'workingsBackToFront' 'workingsDictionary' 'contents' 'costumes' 'currentCostume' 'parameters' 'canvas' 'canvasValid' 'layoutRectangle' 'windowBounds' 'flags' 'velocity' 'type' 'heading' 'speed' 'pen' )		"StringObj" ()  "TextObj" ('prevTextFrame' 'nextTextFrame' 'suppressDisplay')).	ind _ #(Alias BooleanObj FastObj Folder NumberObj Obj StringObj TextObj) indexOf: className.	ind = 0 ifTrue: [^ self].	structures at: className put: 		(className == #Obj				ifTrue: [data at: ind]				ifFalse: [(data at: 6 "Obj"), (data at: ind)]).	self verifyStructure! !!SmartRefStream methodsFor: 'all' stamp: 'tk 9/10/97 21:11'!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs cls newSupers |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	refs _ dummy references.	structures _ Dictionary new.	superclasses _ Dictionary new.	objCount _ refs size.		"for progress bar"		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	refs keysDo: [:each | 		cls _ each class.		(cls category asString = 'HyperSqueak-UserObjects') 			ifTrue: [structures at: cls officialClass name put: false] 			ifFalse: [structures at: cls name put: false]].	"Save work by only computing inst vars once for each class"	newSupers _ Set new.	structures keysDo: [:nm | 		cls _ Smalltalk at: nm.		cls allSuperclasses do: [:aSuper |			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].			"Don't modify structures during iteration"	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"	structures keysDo: [:nm | "Nothing added to classes during loop"		cls _ Smalltalk at: nm.		structures at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames)).		superclasses at: nm ifAbsent: [				superclasses at: nm put: cls superclass name]].	^ Array with: 'class structure' with: structures with: 'superclasses' with: superclasses! !!SmartRefStream methodsFor: 'all' stamp: 'tk 1/8/97'!mapClass: nm	"See if the old class named nm exists.  If so, return it.  If not, map it to a new class, and save the mapping in renamed.  "	| cls oldVer sel |	cls _ Smalltalk at: nm ifAbsent: [nil].	cls ifNotNil: [^ cls]. 	"Known class.  It will know how to translate the instance."	oldVer _ self versionSymbol: (structures at: nm).	sel _ nm asString.	sel at: 1 put: (sel at: 1) asLowercase.	sel _ sel, oldVer.	"i.e. #rectangleoc4"	Symbol hasInterned: sel ifTrue: [:symb | 		(self class canUnderstand: sel asSymbol) ifTrue: [			cls _ self perform: sel asSymbol]].	"This class will take responsibility"	cls ifNotNil: [			renamed at: nm put: cls name.			^ cls].	"Never heard of it!!"	^ self writeClassRenameMethod: sel was: nm				fromInstVars: (structures at: nm).! !!SmartRefStream methodsFor: 'all' stamp: 'tk 1/6/97'!next	"Really write three objects: (version, class structure, object). But only when called from the outside.  "	| version ss object |	^ topCall == nil 		ifTrue: 			[topCall _ thisContext.			writing _ false.			version _ super next.			version class == SmallInteger ifFalse: [^ version].					"version number, else just a regular object, not in our format, "			ss _ super next.			ss class == Array ifFalse: [^ ss].  "just a regualr object"			(ss at: 1) = 'class structure' ifFalse: [^ ss].			structures _ ss at: 2.			superclasses _ (ss size > 3 and: [(ss at: 3) = 'superclasses']) 				ifTrue: [ss at: 4]		"class name -> superclass name"				ifFalse: [Dictionary new].			(self verifyStructure = 'conversion method needed') ifTrue: [^ nil].			writing _ #Unclassed.	"Pass 1"			object _ super next.	"all the action here"			topCall _ writing _ nil.	"reset it"			object]		ifFalse:			[super next]! !!SmartRefStream methodsFor: 'all' stamp: 'tk 9/10/97 21:17'!nextPut: anObject	"Really write three objects: (version, class structure, object). But only when called from the outside.  "	| info |	topCall == nil 		ifTrue:			[topCall _ anObject.  writing _ true. 			super nextPut: ReferenceStream versionCode.			'Please wait while objects are counted' displayProgressAt: Sensor cursorPoint				from: 0 to: 10				during: [:bar |					info _ self instVarInfo: anObject].			'Writing an object file' displayProgressAt: Sensor cursorPoint				from: 0 to: objCount*4	"estimate"				during: [:bar |					objCount _ 0.					progressBar _ bar.					super nextPut: info.					super nextPut: anObject].	"<- the real writing"			"references is an IDict of every object that got written			(in case you want totake statistics)"			"Transcript cr; show: structures keys printString."		"debug"			topCall _ writing _ progressBar _ nil]	"reset it"		ifFalse:			[super nextPut: anObject.			progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'all' stamp: 'tk 12/9/97 21:27'!noHeader	"Signal that we've already dealt with the version and structure array, and are now reading objects."	topCall _ thisContext.	writing _ false.! !!SmartRefStream methodsFor: 'all' stamp: 'tk 7/24/97 18:39'!readInstance	"PRIVATE -- Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next. jhm.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.1/7/97 tk	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| instSize className refPosn anObject newName newClass dict oldInstVars sel supers this |	instSize _ (byteStream nextNumber: 4) - 1.	refPosn _ self getCurrentReference.	className _ self next asSymbol.	self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	(Smalltalk includesKey: className) ifTrue: [		newClass _ Smalltalk at: className.		(steady includes: newClass) ifTrue: [		 	anObject _ newClass isVariable "Create it here"				ifFalse: [newClass basicNew]				ifTrue: [newClass basicNew: instSize - (newClass instSize)].			anObject _ anObject readDataFrom: self size: instSize.			self setCurrentReference: refPosn.  "before returning to next"			^ anObject]].	newName _ renamed at: className ifAbsent: [className].	newClass _ Smalltalk at: newName.	oldInstVars _ structures at: className ifAbsent: [		"self fixObjVer1: className.	HyperSqueak"		structures at: className ifAbsent: [			self error: 'class is not in structures list']].	"Missing in object file"	anObject _ newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict _ self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: dict.	"ones with the same names"	supers _ OrderedCollection with: className.	this _ className.	[(this _ superclasses at: this) = 'nil'] whileFalse: [		supers addFirst: this].	supers do: [:aName |			sel _ reshaped at: aName ifAbsent: [nil].		sel ifNotNil: [			anObject perform: sel with: dict with: self]].	"exceptions"	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!SmartRefStream methodsFor: 'all' stamp: 'tk 7/24/97 18:38'!readShortInst	"PRIVATE -- Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.1/7/97 tk	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| instSize className refPosn anObject newName newClass dict oldInstVars sel supers this |	instSize _ (byteStream next) - 1.	"one byte of size"	refPosn _ self getCurrentReference.	className _ self readShortRef.	"class symbol in two bytes of file pos"	self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	(Smalltalk includesKey: className) ifTrue: [		newClass _ Smalltalk at: className.		(steady includes: newClass) ifTrue: [		 	anObject _ newClass isVariable "Create it here"				ifFalse: [newClass basicNew]				ifTrue: [newClass basicNew: instSize - (newClass instSize)].			anObject _ anObject readDataFrom: self size: instSize.			self setCurrentReference: refPosn.  "before returning to next"			^ anObject]].	newName _ renamed at: className ifAbsent: [className].	newClass _ Smalltalk at: newName.	oldInstVars _ structures at: className ifAbsent: [		"self fixObjVer1: className.	HyperSqueak"		structures at: className ifAbsent: [			self error: 'class is not in structures list']].	"Missing in object file"	anObject _ newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict _ self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: dict.	"ones with the same names"	supers _ OrderedCollection with: className.	this _ className.	[(this _ superclasses at: this) = 'nil'] whileFalse: [		supers addFirst: this].	supers do: [:aName |			sel _ reshaped at: aName ifAbsent: [nil].		sel ifNotNil: [			anObject perform: sel with: dict with: self]].	"exceptions"	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!SmartRefStream methodsFor: 'all'!renamed	^ renamed! !!SmartRefStream methodsFor: 'all' stamp: 'tk 1/9/97'!setStream: aStream	"Initialize me. "	super setStream: aStream.	steady _ Set new.	#(Array Dictionary Association String SmallInteger) do: [:sym |		steady add: (Smalltalk at: sym)].		"These must stay constant.  When structures read in, then things can change."	reshaped _ Dictionary new.			"(old class name -> method selector to fill in data for version to version)"	renamed _ Dictionary new.		"(old class name symbol -> new class name)"! !!SmartRefStream methodsFor: 'all' stamp: 'tk 5/26/97'!storeInstVarsIn: anObject from: dict	"For instance variables with the same names, store them in the new instance.  Values in variable-length part also.  This is NOT the normal inst var transfer!!  See Object.readDataFrom:size:.  This is for when inst var names have changed and some additional conversion is needed.  Here we handle the unchanged vars.  "	(anObject class allInstVarNames) doWithIndex: [:varName :index |		(dict includesKey: varName) ifTrue: [			anObject instVarAt: index put: (dict at: varName)]].	"variable part"	(dict includesKey: #SizeOfVariablePart) ifFalse: [^ anObject].	1 to: (dict at: #SizeOfVariablePart) do: [:index | 		anObject basicAt: index put: (dict at: index)].	^ anObject! !!SmartRefStream methodsFor: 'all'!structures	^ structures! !!SmartRefStream methodsFor: 'all' stamp: 'tk 9/28/97 11:17'!superclasses	^superclasses! !!SmartRefStream methodsFor: 'all' stamp: 'tk 5/24/97'!verifyClass: newClass was: nm selector: sel newList: newShort oldList: oldShort	"Compare the incoming inst var name lists with the existing class.  See if the proper conversion method is present.  Works for either comparing inst vars for THIS class, or for allInstVars of the superclasses.  "	Symbol hasInterned: sel ifTrue: [:symb | reshaped at: nm put: symb].	newShort = oldShort ifFalse: ["Did change inst vars"		(reshaped includesKey: nm) ifFalse: ["No conversion method exists"				self close.				self writeConversionMethod: sel class: newClass was: nm						fromInstVars: oldShort to: newShort.				^ 'conversion method needed']]. "you need to restart the read-in"	(reshaped includesKey: nm) ifTrue: ["Symbol exists"		(newClass canUnderstand: sel asSymbol) ifFalse: ["But not in this class!!"			self close.				self writeConversionMethod: sel class: newClass was: nm						fromInstVars: oldShort to: newShort.				^ 'conversion method needed']]. "you need to restart the read-in"	"any other cases to test?"! !!SmartRefStream methodsFor: 'all' stamp: 'tk 9/22/97 17:43'!verifyStructure	"Compare the incoming inst var name lists with the existing classes.  Prepare tables that will help to restructure those who need it (renamed, reshaped, steady).    If all superclasses are recorded in the file, only compare inst vars of this class, not of superclasses.  They will get their turn.  "| sel newClass oldVer newList newVer oldList ans newShort oldShort sup |structures keysDo: [:nm "an old className (symbol)" |	"For missing classes, there needs to be a method in SmartRefStream like 		#rectangleoc2 that returns the new class."	newClass _ self mapClass: nm.		"does (renamed at: nm put: newClass name)"	newClass class == String ifTrue: [^ newClass].	"error, fileIn needed"	oldVer _ self versionSymbol: (structures at: nm).	newList _ (Array with: newClass classVersion), (newClass allInstVarNames).	newVer _ self versionSymbol: newList.	sel _ 'convert',oldVer,':',newVer, ':'.			"method name of conversion routine that is send after the object is created."	oldList _ structures at: nm.	superclasses ifNil: [newShort _ newList.  oldShort _ oldList]		ifNotNil: ["just compare inst vars for this class"			sup _ superclasses at: nm.			oldShort _ sup = 'nil' 				ifFalse: [oldList copyFrom: (structures at: sup) size + 1 to: oldList size]				ifTrue: [oldList copyFrom: 2 to: oldList size].			oldShort _ (Array with: (oldList at: 1)), oldShort.	"put version back".			newShort _ (Array with: newClass classVersion), (newClass instVarNames)].	newList = oldList 		ifTrue: [steady add: newClass]	"read it in as written"		ifFalse: [ans _ self verifyClass: newClass was: nm 					selector: sel newList: newShort oldList: oldShort.			ans = 'conversion method needed' ifTrue: [^ ans]]].! !!SmartRefStream methodsFor: 'all' stamp: 'tk 1/7/97'!versionSymbol: instVarList	"Create the symbolic code (like a version number) for this class in some older version.  First initials of all the inst vars, followed by the class version number.  Returns a string, caller makes it into a compound selector.  "	| str |	str _ instVarList size = 1 ifFalse: [''] ifTrue: ['x'].		"at least one letter"	2 to: instVarList size do: [:ind |		str _ str, (instVarList at: ind) first asString].	str _ str, instVarList first printString.	"the number"	^ str" | list | list _ (Array with: Paragraph classVersion), (Paragraph alistInstVarNames).(SmartRefStream  on: (DummyStream on: nil)) versionSymbol: list"! !!SmartRefStream methodsFor: 'all' stamp: 'tk 9/22/97 16:08'!writeClassRenameMethod: sel was: oldName fromInstVars: oldList	"The class coming is unknown.  Ask the user for the existing class it maps to.  If got one, write a method, and restart the obj fileIn.  If none, write a dummy method and get the user to complete it later.  "| tell choice  newName answ code |tell _ 'Reading an instance of ', oldName, '.Which modern class should it translate to?'.answ _ (PopUpMenu labels: 'Let me type the name nowLet me think about itLet me find a conversion file on the disk') startUpWithCaption: tell. answ = 1 ifTrue: [	tell _ 'Name of the modern class that ', oldName, 's should it translate to:'.	choice _ FillInTheBlank request: tell.		"class name"	(choice size = 0) 		ifTrue: [answ _ 'conversion method needed']		ifFalse: [newName _ choice.			answ _ Smalltalk at: newName asSymbol 				ifAbsent: ['conversion method needed'].			answ class == String ifFalse: [renamed at: oldName asSymbol put: answ name]]].(answ = 3) | (answ = 0) ifTrue: [self close.		^ 'conversion method needed'].answ = 2 ifTrue: [answ _ 'conversion method needed'].answ = 'conversion method needed' ifTrue: [		self close.  		newName _ 'PutNewClassHere'].code _ WriteStream on: (String new: 500).code nextPutAll: sel; cr; tab.code nextPutAll: '^ ', newName.	"Return new class"self class compile: code contents classified: 'conversion'.newName = 'PutNewClassHere' ifTrue: [	PopUpMenu notify: 'Please complete the following method and then read-in the object file again.'.	Smalltalk browseAllImplementorsOf: sel asSymbol]. 	"The class version number only needs to change under one specific circumstance.  That is when the first letters of the instance variables have stayed the same, but their meaning has changed.  A conversion method is needed, but this system does not know it.  	If this is true for class Foo, define classVersion in Foo class.  	Beware of previous object fileouts already written after the change in meaning, but before bumping the version number.  They have the old (wrong) version number, say 2.  If this is true, your method must be able to test the data and successfully read files that say version 2 but are really 3."	^ answ! !!SmartRefStream methodsFor: 'all' stamp: 'tk 4/26/97'!writeConversionMethod: sel class: newClass was: oldName fromInstVars: oldList to: newList	"No method sel was found in newClass.  Ask user to look for the fileIn.  Or help by writing a prototype conversion method.  "| tell choice code keywords newOthers oldOthers copied |newClass name = oldName 	ifTrue: [tell _ 'The class ', oldName]	ifFalse: [tell _ 'An instance of ', oldName, ' is coming in as an ', newClass name, '.  It'].tell _ tell, ' has different instance variables than before.  It needs a conversion method.  You may:'.choice _ (PopUpMenu labels: 'Find a conversion file on the disk and file it inWrite a conversion method by editing a prototype') startUpWithCaption: tell. choice = 1 ifTrue: [PopUpMenu notify: 'After filing in the conversion file, please read-in the object file again.'].	"you need to restart the read-in"choice = 2 ifTrue: [	code _ WriteStream on: (String new: 500).	keywords _ sel keywords.	code nextPutAll: (keywords at: 1); nextPutAll: ' varDict '; 			nextPutAll: (keywords at: 2); nextPutAll: ' smartRefStrm'; cr; tab.	newOthers _ newList asOrderedCollection "copy".	oldOthers _ oldList asOrderedCollection "copy".	copied _ OrderedCollection new.	newList do: [:instVar |		(oldList includes: instVar) ifTrue: [			instVar isInteger ifFalse: [copied add: instVar].			newOthers remove: instVar.			oldOthers remove: instVar]].	code nextPutAll: '"These variables are automatically stored into the new instance '.	code nextPutAll: copied asArray printString; nextPut: $. .	code cr; tab; nextPutAll: 'This method is for additional changes.'; 		nextPutAll: ' Use statements like (foo _ varDict at: ''foo'')."'; cr; cr; tab.	(newOthers size = 0) & (oldOthers size = 0) 		ifTrue: [code nextPutAll: '"Instance variables are the same.  Only the order changed.  This method should work as written."']		ifFalse: [code nextPutAll: '"Be sure to to fill in ', newOthers asArray printString, 			' and deal with the information in ', oldOthers asArray printString, '"'].	newClass compile: code contents classified: 'object fileIn'.	PopUpMenu notify: 'Please complete the following method and then read-in the object file again.'.	Smalltalk browseAllImplementorsOf: sel asSymbol]. 	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe." ! !!SmartRefStream methodsFor: 'all'!writing	^ writing! !!SmartRefStream methodsFor: 'conversion' stamp: 'jm 11/13/97 10:32'!gradientFillbosfcepbbfgcc0	^ GradientFillMorph! !!SmartRefStream class methodsFor: 'all' stamp: 'tk 12/9/97 21:31'!read: aByteStream withClasses: structureArray	"Read an object off the stream, but first check structureArray against the current system."	| me |	me _ self on: aByteStream.	me noHeader.	me structures: (structureArray at: 2).	me superclasses: (structureArray at: 4).	(me verifyStructure = 'conversion method needed') ifTrue: [^ nil].	^ super next! !!SmartRefStream class methodsFor: 'all' stamp: 'tk 5/20/97'!scanFrom: aByteStream	"During a code fileIn, we need to read in an object, and stash it in ScannedObject.  "	| me |	me _ self on: aByteStream.	ScannedObject _ me next.	aByteStream ascii.	aByteStream next == $!! ifFalse: [		aByteStream close.		self error: 'Object did not end correctly']. 	"caller will close the byteStream"	"HandMorph.readMorphFile will retrieve the ScannedObject"! !!SmartRefStream class methodsFor: 'all' stamp: 'tk 5/20/97'!scannedObject	"The most recently read in object.  Watch out for read-in that is interrupted and resumed.  May want to make this a dictionary?  "	^ ScannedObject! !!SmartRefStream class methodsFor: 'all' stamp: 'tk 5/20/97'!scannedObject: objOrNil	"Used to free up the last object stashed here.  "	ScannedObject _ objOrNil! !A Socket represents a network connection point. Current sockets are designed to support the TCP/IP and UDP protocols, although UDP is not yet implemented. It should be possible to support other protocols (such as AppleTalk) sockets by extending the socket primitives.Subclasses of socket provide support for network protocols such as POP, NNTP, HTTP, and FTP. Sockets also allow you to implement your own custom services and may be used to support Remote Procedure Call or Remote Method Invocation some day.!]style[(347 4 6 3 150)f1,f1LHTTPSocket Comment;,f1,f1LFTPSocket Comment;,f1!!Socket methodsFor: 'initialize-destroy' stamp: 'jm 9/15/97 12:28'!destroy	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil		ifFalse: [			self primSocketDestroy: socketHandle.			Smalltalk unregisterExternalObject: semaphore.			socketHandle _ nil.			semaphore _ nil].! !!Socket methodsFor: 'initialize-destroy' stamp: 'jm 9/11/97 20:36'!initialize	"Create a new socket handle."	| semaIndex |	semaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	socketHandle _		self primSocketCreateNetwork: 0			type: 0			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex.! !!Socket methodsFor: 'accessing' stamp: 'jm 9/17/97 14:34'!localAddress	^ self primSocketLocalAddress: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'jm 9/17/97 14:33'!localPort	^ self primSocketLocalPort: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'jm 9/17/97 14:34'!remoteAddress	^ self primSocketRemoteAddress: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'jm 9/17/97 14:34'!remotePort	^ self primSocketRemotePort: socketHandle! !!Socket methodsFor: 'queries' stamp: 'jm 9/11/97 20:27'!dataAvailable	"Return true if this socket has unread received data."	^ self primSocketReceiveDataAvailable: socketHandle! !!Socket methodsFor: 'queries' stamp: 'jm 9/11/97 20:27'!isConnected	"Return true if this socket is connected."	^ (self primSocketConnectionStatus: socketHandle) == Connected! !!Socket methodsFor: 'queries' stamp: 'jm 11/4/97 07:15'!isUnconnectedOrInvalid	"Return true if this socket is completely disconnected or is invalid."	| status |	socketHandle ifNil: [^ true].	status _ self primSocketConnectionStatus: socketHandle.	^ (status = Unconnected) | (status = InvalidSocket)! !!Socket methodsFor: 'queries' stamp: 'jm 11/4/97 07:15'!isValid	"Return true if this socket contains a valid, non-nil socket handle."	| status |	socketHandle ifNil: [^ false].	status _ self primSocketConnectionStatus: socketHandle.	^ status ~= InvalidSocket! !!Socket methodsFor: 'queries' stamp: 'go 8/18/97 11:12'!peerName	"Return the name of the host I'm connected to."	^NetNameResolver nameForAddress: (self primSocketRemoteAddress: socketHandle) timeout: 60! !!Socket methodsFor: 'queries' stamp: 'jm 9/11/97 20:28'!sendDone	"Return true if the most recent send operation on this socket has completed."	^ self primSocketSendDone: socketHandle! !!Socket methodsFor: 'queries' stamp: 'jm 9/17/97 16:10'!statusString	"Return a string describing the status of this socket."	| status |	status _ self primSocketConnectionStatus: socketHandle.	status = InvalidSocket ifTrue: [^ 'invalidSocketHandle'].	status = Unconnected ifTrue: [^ 'unconnected'].	status = WaitingForConnection ifTrue: [^ 'waitingForConnection'].	status = Connected ifTrue: [^ 'connected'].	status = OtherEndClosed ifTrue: [^ 'otherEndClosedButNotThisEnd'].	status = ThisEndClosed ifTrue: [^ 'thisEndClosedButNotOtherEnd'].	^ 'unknown socket status'! !!Socket methodsFor: 'connection open/close' stamp: 'jm 9/11/97 20:29'!close	"Close this connection gracefully. For TCP, this sends a close request, but the stream remains open until the other side also closes it."	self primSocketCloseConnection: socketHandle.  "close this end"! !!Socket methodsFor: 'connection open/close' stamp: 'jm 11/4/97 07:15'!closeAndDestroy	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	self closeAndDestroy: 20.! !!Socket methodsFor: 'connection open/close' stamp: 'jm 11/4/97 07:15'!closeAndDestroy: timeoutSeconds	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil		ifFalse: [			self close.  "close this end"			(self waitForDisconnectionUntil: (Socket deadlineSecs: timeoutSeconds))				ifFalse: [					"if the other end doesn't close soon, just abort the connection"					self primSocketAbortConnection: socketHandle].			self destroy].! !!Socket methodsFor: 'connection open/close'!connectTo: hostAddress port: port	"Initiate a connection to the given port at the given host address. This operation will return immediately; follow it with waitForConnectionUntil: to wait until the connection is established."	| status |	status _ self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before opening a new connection'].	self primSocket: socketHandle connectTo: hostAddress port: port.! !!Socket methodsFor: 'connection open/close'!listenOn: port	"Listen for a connection on the given port. This operation will return immediately; follow it with waitForConnectionUntil: to wait until a connection is established."	| status |	status _ self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: port.! !!Socket methodsFor: 'sending-receiving' stamp: 'jm 9/15/97 12:22'!discardReceivedData	"Discard any data received up until now, and return the number of bytes discarded."	| buf totalBytesDiscarded |	buf _ String new: 10000.	totalBytesDiscarded _ 0.	[self isConnected and: [self dataAvailable]] whileTrue: [		totalBytesDiscarded _			totalBytesDiscarded + (self receiveDataInto: buf)].	^ totalBytesDiscarded! !!Socket methodsFor: 'sending-receiving' stamp: 'go 9/29/97 15:44'!getData	"Get some data"	| buf bytesRead |	(self waitForDataUntil: Socket standardDeadline) ifFalse: [self error: 'getData timeout'].	buf _ String new: 2000.	bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 count: buf size.	^ buf copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'sending-receiving'!readInto: aStringOrByteArray startingAt: aNumber	"Read data into the given buffer starting at the given index and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	(self waitForDataUntil: Socket standardDeadline) ifFalse: [self error: 'receive timeout'].	^ self primSocket: socketHandle		receiveDataInto: aStringOrByteArray		startingAt: aNumber		count: aStringOrByteArray size - aNumber + 1! !!Socket methodsFor: 'sending-receiving' stamp: 'jm 9/15/97 12:21'!receiveDataInto: aStringOrByteArray	"Receive data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	^ self primSocket: socketHandle		receiveDataInto: aStringOrByteArray		startingAt: 1		count: aStringOrByteArray size! !!Socket methodsFor: 'sending-receiving' stamp: 'jm 9/17/97 16:00'!sendData: aStringOrByteArray	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent."	| bytesSent bytesToSend count |	bytesToSend _ aStringOrByteArray size.	bytesSent _ 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneUntil: (Socket deadlineSecs: 20))			ifFalse: [self error: 'send data timeout; data not sent'].		count _ self primSocket: socketHandle			sendData: aStringOrByteArray			startIndex: bytesSent + 1			count: bytesToSend - bytesSent.		bytesSent _ bytesSent + count].	^ bytesSent! !!Socket methodsFor: 'sending-receiving' stamp: 'jm 9/17/97 15:55'!sendSomeData: aStringOrByteArray	"Send as much of the given data as possible and return the number of bytes actually sent."	"Note: This operation may have to be repeated many times to send a large amount of data."	| bytesSent |	(self waitForSendDoneUntil: (Socket deadlineSecs: 20))		ifTrue: [			bytesSent _ self primSocket: socketHandle				sendData: aStringOrByteArray				startIndex: 1				count: aStringOrByteArray size]		ifFalse: [self error: 'send data timeout; data not sent'].	^ bytesSent! !!Socket methodsFor: 'waiting' stamp: 'jm 9/15/97 17:05'!waitForConnectionUntil: deadline	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	| status |	status _ self primSocketConnectionStatus: socketHandle.	[(status ~= Connected) and: [Time millisecondClockValue < deadline]] whileTrue: [		semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		status _ self primSocketConnectionStatus: socketHandle].	^ status = Connected! !!Socket methodsFor: 'waiting' stamp: 'jm 9/15/97 17:05'!waitForDataUntil: deadline	"Wait up until the given deadline for data to arrive. Return true if data arrives by the deadline, false if not."	| dataArrived |	dataArrived _ self primSocketReceiveDataAvailable: socketHandle.	[dataArrived not and:	 [self isConnected and:	 [Time millisecondClockValue < deadline]]] whileTrue: [		semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		dataArrived _ self primSocketReceiveDataAvailable: socketHandle].	^ dataArrived! !!Socket methodsFor: 'waiting' stamp: 'jm 9/15/97 17:06'!waitForDisconnectionUntil: deadline	"Wait up until the given deadline for the the connection to be broken. Return true if it is broken by the deadline, false if not."	"Note: The client should know the the connect is really going to be closed (e.g., because he has called 'close' to send a close request to the other end) before calling this method."	| extraBytes status |	extraBytes _ 0.	status _ self primSocketConnectionStatus: socketHandle.	[((status = Connected) or: [status = ThisEndClosed]) and:	 [Time millisecondClockValue < deadline]] whileTrue: [		self dataAvailable			ifTrue: [extraBytes _ extraBytes + self discardReceivedData].		semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		status _ self primSocketConnectionStatus: socketHandle].	extraBytes > 0		ifTrue: [self inform: 'Discarded ', extraBytes printString, ' bytes while closing connection.'].	^ status ~= Connected! !!Socket methodsFor: 'waiting' stamp: 'jm 9/15/97 17:06'!waitForSendDoneUntil: deadline	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone |	sendDone _ self primSocketSendDone: socketHandle.	[sendDone not and:	 [self isConnected and:	 [Time millisecondClockValue < deadline]]] whileTrue: [		semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		sendDone _ self primSocketSendDone: socketHandle].	^ sendDone! !!Socket methodsFor: 'primitives'!primSocket: socketID connectTo: hostAddress port: port	"Attempt to establish a connection to the given port of the given host. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 217>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocket: socketID listenOn: port	"Listen for a connection on the given port. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 218>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocket: socketID receiveDataInto: aStringOrByteArray startingAt: startIndex count: count	"Receive data from the given socket into the given array starting at the given index. Return the number of bytes read or zero if no data is available."	<primitive: 221>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocket: socketID sendData: aStringOrByteArray startIndex: startIndex count: count	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."	<primitive: 223>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketAbortConnection: socketID	"Terminate the connection on the given port immediately without going through the normal close sequence. This is an asynchronous call; query the socket status to discover if and when the connection is actually terminated."	<primitive: 220>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketCloseConnection: socketID	"Close the connection on the given port. The remote end is informed that this end has closed and will do no further sends. This is an asynchronous call; query the socket status to discover if and when the connection is actually closed."	<primitive: 219>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'jm 9/17/97 14:45'!primSocketConnectionStatus: socketID	"Return an integer reflecting the connection status of this socket. For a list of possible values, see the comment in the 'initialize' method of this class. If the primitive fails, return a status indicating that the socket handle is no longer valid, perhaps because the Squeak image was saved and restored since the socket was created. (Sockets do not survive snapshots.)"	<primitive: 211>	^ InvalidSocket! !!Socket methodsFor: 'primitives' stamp: 'jm 9/11/97 20:35'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex	"Return a new socket handle for a socket of the given type and buffer sizes.	The netType parameter is platform dependent and can be used to encode both the protocol type (IP, Xerox XNS, etc.) and/or the physical network interface to use if this host is connected to multiple networks. A zero netType means to use IP protocols and the primary (or only) network interface.	The socketType parameter specifies:		0	unreliable datagram socket (UDP if the protocol is IP) [NOTE: UDP is not yet implemented]		1	reliable stream socket (TCP if the protocol is IP)	The buffer size parameters allow performance to be tuned to the application. For example, a larger receive buffer should be used when the application expects to be receiving large amounts of data, especially from a host that is far away. These values are considered requests only; the underlying implementation will ensure that the buffer sizes actually used are within allowable bounds. Note that memory may be limited, so an application that keeps many sockets open should use smaller buffer sizes. 	If semaIndex is > 0, it is taken to be the index of a Semaphore in the external objects array to be associated with this socket. This semaphore will be signalled when the socket status changes, such as when data arrives or a send completes. All processes waiting on the semaphore will be awoken for each such event; each process must then query the socket state to figure out if the conditions they are waiting for have been met. For example, a process waiting to send some data can see if the last send has completed."	<primitive: 209>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketDestroy: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted."	<primitive: 210>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketError: socketID	"Return an integer encoding the most recent error on this socket. Zero means no error."	<primitive: 212>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketLocalAddress: socketID	"Return the local host address for this socket."	<primitive: 213>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketLocalPort: socketID	"Return the local port for this socket, or zero if no port has yet been assigned."	<primitive: 214>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'jm 9/11/97 20:22'!primSocketReceiveDataAvailable: socketID	"Return true if data may be available for reading from the current socket."	<primitive: 222>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketRemoteAddress: socketID	"Return the remote host address for this socket, or zero if no connection has been made."	<primitive: 215>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketRemotePort: socketID	"Return the remote port for this socket, or zero if no connection has been made."	<primitive: 216>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketSendDone: socketID	"Return true if there is no send in progress on the current socket."	<primitive: 224>	self primitiveFailed! !!Socket class methodsFor: 'class initialization' stamp: 'jm 9/17/97 14:42'!initialize	"Socket initialize"	"Socket Status Values"	InvalidSocket _ -1.	Unconnected _ 0.	WaitingForConnection _ 1.	Connected _ 2.	OtherEndClosed _ 3.	ThisEndClosed _ 4.! !!Socket class methodsFor: 'instance creation' stamp: 'jm 9/15/97 06:16'!new	"Return a new, unconnected Socket."	^ super new initialize! !!Socket class methodsFor: 'network initialization' stamp: 'jj 10/20/97 15:08'!ensureNetworkConnected	"Try to ensure that an intermittent network connection, such as a dialup or ISDN line, is actually connected. This is necessary to make sure a server is visible in order to accept an incoming connection."	"Socket ensureNetworkConnected"	NetNameResolver initializeNetwork.	Utilities		informUser: 'Contacting domain name server...'		during: [			NetNameResolver				addressForName: 'bogusNameToForceDNSToBeConsulted.org'				timeout: 30].! !!Socket class methodsFor: 'network initialization' stamp: 'jm 9/15/97 09:30'!initializeNetwork	"Initialize the network drivers and the NetNameResolver. Do nothing if the network is already initialized."	"Note: The network must be re-initialized every time Squeak starts up, so applications that persist across snapshots should be prepared to re-initialize the network as needed. Such applications should call 'Socket initializeNetwork' before every network transaction. "	NetNameResolver initializeNetwork.! !!Socket class methodsFor: 'network initialization' stamp: 'jm 9/15/97 06:53'!initializeNetwork: ignored	"Old message for backward compatibility. This method will be removed in some future release; clients should use 'Socket initializeNetwork' instead."	Socket initializeNetwork.! !!Socket class methodsFor: 'tests' stamp: 'jm 11/4/97 08:25'!loopbackTest	"Send data from one socket to another on the local machine. Tests most of the socket primitives."	"Socket loopbackTest"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived t extraBytes |	Transcript cr; show: 'starting loopback test'; cr.	Transcript show: '---------- Connecting ----------'; cr.	Socket initializeNetwork.	sock1 _ Socket new.	sock2 _ Socket new.	sock1 listenOn: 54321.	sock2 connectTo: (NetNameResolver localHostAddress) port: 54321.	sock1 waitForConnectionUntil: self standardDeadline.	sock2 waitForConnectionUntil: self standardDeadline.	(sock1 isConnected) ifFalse: [self error: 'sock1 not connected'].	(sock2 isConnected) ifFalse: [self error: 'sock2 not connected'].	Transcript show: 'connection established'; cr.	bytesToSend _ 5000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	bytesSent _ bytesReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse: [			(sock1 sendDone and: [bytesSent < bytesToSend]) ifTrue: [				bytesSent _ bytesSent + (sock1 sendSomeData: sendBuf)].			sock2 dataAvailable ifTrue: [				bytesReceived _ bytesReceived +					(sock2 receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend) and: [bytesReceived = bytesSent]]].	Transcript show: 'closing connection'; cr.	sock1 waitForSendDoneUntil: self standardDeadline.	sock1 close.	sock2 waitForDisconnectionUntil: self standardDeadline.	extraBytes _ sock2 discardReceivedData.	extraBytes > 0 ifTrue: [		Transcript show: ' *** received ', extraBytes size printString, ' extra bytes ***'; cr.	].	sock2 close.	sock1 waitForDisconnectionUntil: self standardDeadline.	(sock1 isUnconnectedOrInvalid) ifFalse: [self error: 'sock1 not closed'].	(sock2 isUnconnectedOrInvalid) ifFalse: [self error: 'sock2 not closed'].	Transcript show: '---------- Connection Closed ----------'; cr.	sock1 destroy.	sock2 destroy.	Transcript show: 'loopback test done; time = ', t printString; cr.	Transcript show: ((bytesToSend asFloat / t) roundTo: 0.01) printString, ' kBytes/sec'; cr.	Transcript endEntry.! !!Socket class methodsFor: 'tests' stamp: 'jm 9/17/97 15:55'!sendTest	"Send data to the 'discard' socket of the given host. Tests the speed of one-way data transfers across the network to the given host. Note that many host hosts do not run a discard server."	"Socket sendTest"	| sock bytesToSend sendBuf bytesSent t serverName serverAddr |	Transcript cr; show: 'starting send test'; cr.	Socket initializeNetwork.	serverName _ FillInTheBlank		request: 'What is the destination server?'		initialAnswer: 'bobo.rd.wdi.disney.com'.	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', serverName].	sock _ Socket new.	Transcript show: '---------- Connecting ----------'; cr.	sock connectTo: serverAddr port: 9.	sock waitForConnectionUntil: self standardDeadline.	(sock isConnected) ifFalse: [		sock destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection established; sending data'; cr.	bytesToSend _ 100000.	sendBuf _ String new: 5000 withAll: $x.	bytesSent _ 0.	t _ Time millisecondsToRun: [		[bytesSent < bytesToSend] whileTrue: [			sock sendDone ifTrue: [				bytesSent _ bytesSent + (sock sendSomeData: sendBuf)]]].	sock destroy.	Transcript show: '---------- Connection Closed ----------'; cr.	Transcript show: 'send test done; time = ', t printString; cr.	Transcript show: ((bytesToSend asFloat / t) roundTo: 0.01) printString, ' kBytes/sec'; cr.	Transcript endEntry.! !!Socket class methodsFor: 'utilities' stamp: 'jm 9/15/97 06:56'!deadlineSecs: secs	"Return a deadline time the given number of seconds from now."	^ Time millisecondClockValue + (secs * 1000)! !!Socket class methodsFor: 'utilities' stamp: 'jm 9/15/97 06:56'!standardDeadline	"Return a default deadline time some seconds into the future."	^ self deadlineSecs: 45! !!SoundBuffer methodsFor: 'accessing' stamp: 'jm 9/17/97 13:00'!monoSampleCount	"Return the number of monaural 16-bit samples that fit into this SoundBuffer."	^ super size * 2! !!SoundBuffer methodsFor: 'accessing' stamp: 'jm 9/17/97 13:28'!size	"Return the number of 16-bit sound samples that fit in this sound buffer. To avoid confusion, it is better to get the size of SoundBuffer using monoSampleCount or stereoSampleCount."	^ self monoSampleCount! !!SoundBuffer methodsFor: 'accessing' stamp: 'jm 9/17/97 13:01'!stereoSampleCount	"Return the number of stereo slices that fit into this SoundBuffer. A stereo 'slice' consists of two 16-bit samples, one for each channel."	^ super size! !!SoundBuffer methodsFor: 'primitives' stamp: 'jm 9/17/97 13:03'!at: index	"Return the 16-bit integer value at the given index of the receiver."	<primitive: 143>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber ifTrue: [^ self at: index truncated].	self errorNonIntegerIndex.! !!SoundBuffer methodsFor: 'primitives' stamp: 'jm 9/17/97 13:03'!at: index put: value	"Store the given 16-bit integer at the given index in the receiver."	<primitive: 144>	index isInteger		ifTrue: [			(index >= 1 and: [index <= self size])				ifTrue: [self errorImproperStore]				ifFalse: [self errorSubscriptBounds: index]].	index isNumber ifTrue: [^ self at: index truncated put: value].	self errorNonIntegerIndex.! !!SoundBuffer methodsFor: 'primitives' stamp: 'jm 9/2/97 16:07'!primFill: aPositiveInteger	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays."	"Note: Since 16-bit word arrays are not built into the virtual machine, this primitive fills by 32-bit words."	<primitive: 145>	self errorImproperStore.! !!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!indexOfFirstSampleOver: threshold	"Return the index of the first sample whose absolute value is over the given threshold value. Return an index one greater than my size if no sample is over the threshold."	1 to: self size do: [:i |		(self at: i) abs > threshold ifTrue: [^ i]].	^ self size + 1! !!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!indexOfLastSampleOver: threshold	"Return the index of the last sample whose absolute value is over the given threshold value. Return zero if no sample is over the threshold."	self size to: 1 by: -1 do: [:i |		(self at: i) abs > threshold ifTrue: [^ i]].	^ 0! !!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!normalized: percentOfFullVolume	"Increase my amplitudes so that the highest peak is the given percent of full volume. For example 's normalized: 50' would normalize to half of full volume."	| peak s mult |	peak _ 0.	1 to: self size do: [:i |		s _ (self at: i) abs.		s > peak ifTrue: [peak _ s]].	mult _ (32767.0 * percentOfFullVolume) / (100.0 * peak).	1 to: self size do: [:i | self at: i put: (mult * (self at: i)) asInteger].! !!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!trimmedThreshold: threshold	| start end |	start _ self indexOfFirstSampleOver: threshold.	end _  self indexOfLastSampleOver: threshold.	start > end ifTrue: [^ SoundBuffer new].	start _ (start - 200) max: 1.	end _ (end + 200) min: self size.	^ self copyFrom: start to: end! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 12:39'!fromArray: anArray	"Return a new SoundBuffer whose contents are copied from the given Array or ByteArray."	| new |	new _ SoundBuffer newMonoSampleCount: anArray size.	1 to: anArray size do: [:i | new at: i put: (anArray at: i)].	^ new! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 13:25'!new: anInteger	"See the comment in newMonoSampleCount:. To avoid confusion, it is best to create new instances using newMonoSampleCount: or newStereoSampleCount:."	^ self newMonoSampleCount: anInteger! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 12:44'!newMonoSampleCount: anInteger	"Return a SoundBuffer large enough to hold the given number of monaural samples (i.e., 16-bit words)."	"Details: The size is rounded up to an even number, since the underlying representation is in terms of 32-bit words."	^ self basicNew: (anInteger + 1) // 2! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 12:52'!newStereoSampleCount: anInteger	"Return a SoundBuffer large enough to hold the given number of stereo slices. A stereo 'slice' consists of two 16-bit samples, one for each channel."	^ self basicNew: anInteger! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:09'!initialize	super initialize.	orientation _ #vertical.	centering _ #center.	hResizing _ #spaceFill.	vResizing _ #spaceFill.	inset _ 3.	color _ Color lightGray.	self borderWidth: 2.	self addMorph: self makeControls.	soundColumn _ LayoutMorph newColumn.	soundColumn openToDragNDrop: true.	self addMorphBack: soundColumn.	self extent: 118@150.! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:09'!makeControls	| b r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ LayoutMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: 'V1';			actionSelector: #playV1).	r addMorphBack: (b fullCopy label: 'V2';			actionSelector: #playV2).	r addMorphBack: (b fullCopy label: 'V3';			actionSelector: #playV3).	r addMorphBack: (b fullCopy label: 'All';			actionSelector: #playAll).	r addMorphBack: (b fullCopy label: 'Stop';		actionSelector: #stopSound).	^ r! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 12/17/97 17:13'!playAll	| snd |	soundColumn submorphs size < 1 ifTrue: [^ self].	self setTimbreFromTile: (soundColumn submorphs at: 1).	snd _ SampledSound bachFugueVoice1On: SampledSound new.	soundColumn submorphs size >= 2 ifTrue: [		self setTimbreFromTile: (soundColumn submorphs at: 2).		snd _ snd + (AbstractSound bachFugueVoice2On: SampledSound new)].	soundColumn submorphs size >= 3 ifTrue: [		self setTimbreFromTile: (soundColumn submorphs at: 3).		snd _ snd + (AbstractSound bachFugueVoice3On: SampledSound new)].	snd play.! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:09'!playV1	soundColumn submorphs size < 1 ifTrue: [^ self].	self setTimbreFromTile: (soundColumn submorphs at: 1).	SampledSound bachFugueVoice1 play.! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:09'!playV2	soundColumn submorphs size < 2 ifTrue: [^ self].	self setTimbreFromTile: (soundColumn submorphs at: 2).	SampledSound bachFugueVoice2 playSilentlyUntil: 4.8; resumePlaying.! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 12/17/97 17:13'!playV3	soundColumn submorphs size < 3 ifTrue: [^ self].	self setTimbreFromTile: (soundColumn submorphs at: 3).	(AbstractSound bachFugueVoice3On: SampledSound new)		playSilentlyUntil: 14.4; resumePlaying.! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:09'!setTimbreFromTile: aSoundTile	SampledSound defaultSampleTable: aSoundTile sound samples.	SampledSound nominalSamplePitch: 400.! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:09'!stopSound	SoundPlayer shutDown.! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!addCursorMorph	self addMorph:		(cursor _ (RectangleMorph				newBounds: (self innerBounds topLeft extent: 1@self innerBounds height)				color: Color red)						borderWidth: 0)! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:11'!allowSubmorphExtraction	^ true! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 1/5/98 17:31'!buildSound	"Build a compound sound for the next iteration of the loop."	| mixer soundMorphs startTime pan |	mixer _ MixedSound new.	mixer add: (RestSound dur: (self width - (2 * borderWidth)) / 128.0).	soundMorphs _ self submorphs select: [:m | m respondsTo: #sound].	soundMorphs do: [:m |		startTime _ (m position x - (self left + borderWidth)) / 128.0.		pan _ (m position y - (self top + borderWidth)) asFloat / (self height - (2 * borderWidth) - m height).		mixer add: ((RestSound dur: startTime), m sound copy) pan: pan].	^ mixer! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!extent: newExtent	super extent: (newExtent truncateTo: 128@128) + (self borderWidth*2)! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!initialize	super initialize.	borderWidth _ 1.	bounds _ 0@0 corner: (128@128) + (borderWidth*2).	color _ Color lightBlue.	controlIndex _ 0.	self addCursorMorph! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:11'!play	"Play this sound to the sound ouput port in real time."	self reset.	SoundPlayer playSound: self.! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:11'!stop	"Stop playing this sound."	SoundPlayer pauseSound: self.! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:11'!wantsDroppedMorph: aMorph event: evt	^ aMorph respondsTo: #sound! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!controlRate	"Answer the number of control changes per second."	^ 32! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!doControl	seqSound doControl.	controlIndex _ controlIndex + 1.	controlIndex >= (self controlRate * (self innerBounds width // 128))		ifTrue: [controlIndex _ 0].! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 1/5/98 13:40'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Repeatedly play my sounds."	| i count samplesNeeded |	i _ startIndex.	samplesNeeded _ n.	[samplesNeeded > 0] whileTrue: [		count _ seqSound samplesRemaining min: samplesNeeded.		count = 0 ifTrue: [			self reset.			count _ seqSound samplesRemaining min: samplesNeeded.			count = 0 ifTrue: [^ self]].  "zero length sound"		seqSound mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: leftVol rightVol: rightVol.		i _ i + count.		samplesNeeded _ samplesNeeded - count].! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 1/5/98 13:53'!playSampleCount: n into: aSoundBuffer startingAt: startIndex stereo: stereoFlag	"Mixes the next count samples of this sound into the given buffer starting at the given index, updating the receiver's control parameters at periodic intervals."	| fullVol samplesBetweenControlUpdates pastEnd i remainingSamples count |	fullVol _ AbstractSound scaleFactor.	samplesBetweenControlUpdates _ self samplingRate // self controlRate.	pastEnd _ startIndex + n.  "index just index of after last sample"	i _ startIndex.	[i < pastEnd] whileTrue: [		remainingSamples _ self samplesRemaining.		remainingSamples <= 0 ifTrue: [^ self].		count _ pastEnd - i.		samplesUntilNextControl < count ifTrue: [count _ samplesUntilNextControl].		remainingSamples < count ifTrue: [count _ remainingSamples].		self mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: fullVol rightVol: fullVol.		samplesUntilNextControl _ samplesUntilNextControl - count.		samplesUntilNextControl <= 0 ifTrue: [			self doControl.			samplesUntilNextControl _ samplesBetweenControlUpdates].		i _ i + count].! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!positionCursor	| x |	x _ controlIndex * 128 // self controlRate.	cursor position: self innerBounds topLeft + (x@0)! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!reset	"Reset my internal state for a replay."	seqSound _ self buildSound reset.	samplesUntilNextControl _ (self samplingRate // self controlRate).	controlIndex _ 0.	self positionCursor! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:11'!samplesRemaining	^ 1000000! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:11'!samplingRate	"Answer the sampling rate in samples per second."	^ SoundPlayer samplingRate! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!step	self positionCursor! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!stepTime	^ 50! !!SoundMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!buildImage	| scale env h imageColor |	owner ifNil: [scale _ 128@128]  "Default is 128 pix/second, 128 pix fullscale"		ifNotNil: [scale _ owner soundScale].	env _ sound volumeEnvelopeScaledTo: scale.	self image: (ColorForm extent: env size @ env max).	1 to: image width do:		[:x | h _ env at: x.		image fillBlack: ((x-1)@(image height-h//2) extent: 1@h)].	imageColor _ #(black red orange green blue) atPin:						(sound pitch / 110.0) rounded highBit.	image colors: (Array with: Color transparent with: (Color perform: imageColor)).! !!SoundMorph methodsFor: 'all' stamp: 'jm 12/17/97 22:43'!initialize	super initialize.	self sound: (FMSound pitch: 880.0 dur: 0.2 loudness: 0.8).! !!SoundMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!justDroppedInto: aMorph event: anEvent	| relPosition |	relPosition _ self position - aMorph innerBounds topLeft.	relPosition _ (relPosition x roundTo: 8) @ relPosition y.	self position: aMorph innerBounds topLeft + relPosition.	sound copy play! !!SoundMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:08'!reset	sound reset! !!SoundMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:08'!sound	^ sound! !!SoundMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:08'!sound: aSound	sound _ aSound copy.	sound reset.	self buildImage! !!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 1/6/98 18:35'!initialize	"SoundPlayer initialize"	"Details: BufferMSecs represents a tradeoff between latency and quality. If BufferMSecs is too low, the sound will not play smoothing, especially during other activities. If it is too high, there will be an overly long time lag between when a sound buffer is submitted to be played and when that sound is actually heard. It is typically in the range 50-200."	"SoundPlayer initialize; shutDown; startUp"	SamplingRate _ 22050.	BufferMSecs _ 1000.	Stereo _ true.! !!SoundPlayer class methodsFor: 'accessing'!stereo	^ Stereo! !!SoundPlayer class methodsFor: 'snapshotting'!shutDown	"Stop player process, for example before snapshotting."	self stopPlayerProcess.! !!SoundPlayer class methodsFor: 'snapshotting' stamp: 'jm 7/11/97 12:17'!startUp	"Start up the player process."	SoundPlayer initialize.	SoundPlayer		startPlayerProcessBufferSize: (BufferMSecs * SamplingRate) // 1000		rate: SamplingRate		stereo: Stereo.! !!SoundPlayer class methodsFor: 'playing' stamp: 'jj 10/20/97 15:37'!canStartPlayer	"Some platforms do no support simultaneous record and play. If this is one of those platforms, return false if there is a running SoundRecorder."	SoundRecorder canRecordWhilePlaying ifTrue: [^ true].	SoundRecorder allInstances do: [:rec | rec isActive ifTrue: [^ false]].	^ true! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 8/23/97 20:38'!pauseSound: aSound	"Stop playing the given sound. Playing can be resumed from this point later."	PlayerSemaphore critical: [		ActiveSounds remove: aSound ifAbsent: []].! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/13/97 19:47'!playSound: aSound	"Reset and start playing the given sound from its beginning."	aSound reset.	self resumePlaying: aSound.! !!SoundPlayer class methodsFor: 'playing' stamp: 'jj 10/20/97 15:26'!resumePlaying: aSound	"Start playing the given sound without resetting it; it will resume playing from where it last stopped."	| quickStart |	quickStart _ true.	PlayerProcess == nil ifTrue: [		self canStartPlayer ifFalse: [^ self].		self startUp. quickStart _ false].	PlayerSemaphore critical: [		(ActiveSounds includes: aSound)			ifTrue: [quickStart _ false]			ifFalse: [				quickStart ifFalse: [ActiveSounds add: aSound]]].	"quick-start the given sound, unless the sound player has just started"	quickStart ifTrue: [self startPlayingImmediately: aSound].! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/13/97 19:49'!waitUntilDonePlaying: aSound	"Wait until the given sound is no longer playing."	[PlayerSemaphore critical: [ActiveSounds includes: aSound]]		whileTrue: [(Delay forMilliseconds: 100) wait].! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 11/22/97 11:28'!oldStylePlayLoop	"This version of the play loop is used if the VM does not yet support sound primitives that signal a semaphore when a sound buffer becomes available."	| bytesPerSlice count |	bytesPerSlice _ Stereo ifTrue: [4] ifFalse: [2].	[true] whileTrue: [		[(count _ self primSoundAvailableBytes // bytesPerSlice) > 100]			whileFalse: [(Delay forMilliseconds: 1) wait].		count _ count min: Buffer stereoSampleCount.		PlayerSemaphore critical: [			ActiveSounds _ ActiveSounds select: [:snd | snd samplesRemaining > 0].			ActiveSounds do: [:snd |				snd ~~ SoundJustStarted ifTrue: [					snd playSampleCount: count into: Buffer startingAt: 1 stereo: Stereo]].			self primSoundPlaySamples: count from: Buffer startingAt: 1.			Buffer primFill: 0.			SoundJustStarted _ nil]].! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 11/22/97 11:26'!playLoop	"The sound player process loop."	| bytesPerSlice count |	bytesPerSlice _ Stereo ifTrue: [4] ifFalse: [2].	[true] whileTrue: [		[(count _ self primSoundAvailableBytes // bytesPerSlice) > 100]			whileFalse: [ReadyForBuffer wait].		count _ count min: Buffer stereoSampleCount.		PlayerSemaphore critical: [			ActiveSounds _ ActiveSounds select: [:snd | snd samplesRemaining > 0].			ActiveSounds do: [:snd |				snd ~~ SoundJustStarted ifTrue: [					snd playSampleCount: count into: Buffer startingAt: 1 stereo: Stereo]].			self primSoundPlaySamples: count from: Buffer startingAt: 1.			Buffer primFill: 0.			SoundJustStarted _ nil]].! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 9/17/97 20:24'!startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start the sound player process. Terminate the old process, if any."	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"	self stopPlayerProcess.	ActiveSounds _ OrderedCollection new.	Buffer _ SoundBuffer newStereoSampleCount: (bufferSize // 4) * 4.	PlayerSemaphore _ Semaphore forMutualExclusion.	SamplingRate _ samplesPerSecond.	Stereo _ stereoFlag.	ReadyForBuffer _ Semaphore new.	UseReadySemaphore _ true.  "set to false if ready semaphore not supported by VM"	self primSoundStartBufferSize: Buffer stereoSampleCount		rate: samplesPerSecond		stereo: Stereo		semaIndex: (Smalltalk registerExternalObject: ReadyForBuffer).	UseReadySemaphore		ifTrue: [PlayerProcess _ [SoundPlayer playLoop] newProcess]		ifFalse: [PlayerProcess _ [SoundPlayer oldStylePlayLoop] newProcess].	PlayerProcess priority: Processor userInterruptPriority.	PlayerProcess resume.! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 9/17/97 20:31'!stopPlayerProcess	"Stop the sound player process."	"SoundPlayer stopPlayerProcess"	PlayerProcess == nil ifFalse: [PlayerProcess terminate].	PlayerProcess _ nil.	self primSoundStop.	ActiveSounds _ OrderedCollection new.	Buffer _ nil.	PlayerSemaphore _ Semaphore forMutualExclusion.	ReadyForBuffer ifNotNil:		[Smalltalk unregisterExternalObject: ReadyForBuffer].	ReadyForBuffer _ nil.! !!SoundPlayer class methodsFor: 'primitive test' stamp: 'jm 9/13/97 20:01'!boinkPitch: p dur: d loudness: l waveTable: waveTable pan: pan	"Play a decaying note on the given stream using the given wave table. Used for testing only."	| decay tableSize amplitude increment cycles i |	decay _ 0.96.	tableSize _ waveTable size.	amplitude _ l asInteger min: 1000.	increment _ ((p asFloat * tableSize asFloat) / SamplingRate asFloat) asInteger.	increment _ (increment max: 1) min: (tableSize // 2).	cycles _ (d * SamplingRate asFloat) asInteger.	i _ 1.	1 to: cycles do: [:cycle |		(cycle \\ 100) = 0			ifTrue: [amplitude _ (decay * amplitude asFloat) asInteger].		i _ (((i - 1) + increment) \\ tableSize) + 1.		self playTestSample: (amplitude * (waveTable at: i)) // 1000 pan: pan].! !!SoundPlayer class methodsFor: 'primitive test' stamp: 'jm 1/5/98 17:56'!boinkScale	"Tests the sound output primitives by playing a scale."	"SoundPlayer boinkScale"	| sineTable pan |	self shutDown.	SamplingRate _ 11025.	Stereo _ true.	sineTable _ self sineTable: 1000.	Buffer _ SoundBuffer newStereoSampleCount: 1000.	BufferIndex _ 1.	self primSoundStartBufferSize: Buffer stereoSampleCount		rate: SamplingRate		stereo: Stereo.	pan _ 0.	#(261.626 293.665 329.628 349.229 391.996 440.001 493.884 523.252) do: [:p |		self boinkPitch: p dur: 0.3 loudness: 300 waveTable: sineTable pan: pan.		pan _ pan + 125].	self boinkPitch: 261.626 dur: 1.0 loudness: 300 waveTable: sineTable pan: 500.	self primSoundStop.	self shutDown.	SoundPlayer initialize.  "reset sampling rate, buffer size, and stereo flag"! !!SoundPlayer class methodsFor: 'primitive test' stamp: 'jm 9/17/97 12:55'!playTestSample: s pan: pan	"Append the given sample in the range [-32767..32767] to the output buffer, playing the output buffer when it is full. Used for testing only."	| sample leftSample |	BufferIndex >= Buffer size		ifTrue: [			"current buffer is full; play it"			[self primSoundAvailableBytes > 0]				whileFalse. "wait for space to be available"			self primSoundPlaySamples: Buffer stereoSampleCount from: Buffer startingAt: 1.			Buffer primFill: 0.			BufferIndex _ 1].	sample _ s.	sample >  32767 ifTrue: [ sample _  32767 ]. 	sample < -32767 ifTrue: [ sample _ -32767 ].	Stereo		ifTrue: [			leftSample _ (sample * pan) // 1000.			Buffer at: BufferIndex		put: sample - leftSample.			Buffer at: BufferIndex + 1	put: leftSample]		ifFalse: [			Buffer at: BufferIndex + 1 put: sample].	BufferIndex _ BufferIndex + 2.! !!SoundPlayer class methodsFor: 'primitive test' stamp: 'jm 9/17/97 20:06'!sineTable: size	"Compute a sine table of the given size. Used for testing only."	| radiansPerStep table |	table _ Array new: size.	radiansPerStep _ (2.0 * Float pi) / table size asFloat.	1 to: table size do: [:i |		table at: i put:			(32767.0 * (radiansPerStep * i) sin) asInteger].	^ table! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 9/13/97 20:11'!primSoundAvailableBytes	"Return the number of bytes of available space in the sound output buffer."	"Note: Squeak always uses buffers containing 4-bytes per sample (2 channels at 2 bytes per channel) regardless of the state of the Stereo flag."	<primitive: 173>	^ self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 9/17/97 16:55'!primSoundInsertSamples: count from: aSoundBuffer samplesOfLeadTime: anInteger	"Mix the given number of sample frames from the given sound buffer into the queue of samples that has already been submitted to the sound driver. This primitive is used to start a sound playing with minimum latency, even if large sound output buffers are being used to ensure smooth sound output. Returns the number of samples consumed, or zero if the primitive is not implemented or fails."	<primitive: 189>	^ 0! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 9/13/97 20:07'!primSoundPlaySamples: count from: aSampleBuffer startingAt: index	"Copy count bytes into the current sound output buffer from the given sample buffer starting at the given index."	<primitive: 174>	^ self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 9/13/97 20:05'!primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start double-buffered sound output with the given buffer size and sampling rate. This version has been superceded by primitive 171 (primSoundStartBufferSize:rate:stereo:semaIndex:)."	<primitive: 170>	^ self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 9/18/97 16:21'!primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag semaIndex: anInteger	"Start double-buffered sound output with the given buffer size and sampling rate. If the given semaphore index is > 0, it is taken to be the index of a Semaphore in the external objects array to be signalled when the sound driver is ready to accept another buffer of samples."	"Details: If this primitive fails, this method tries to use the older version instead."	<primitive: 171>	UseReadySemaphore _ false.	self primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag.! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 9/13/97 20:04'!primSoundStop	"Stop double-buffered sound output."	<primitive: 172>	^ self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'jj 10/20/97 15:08'!startPlayingImmediately: aSound	"Private!! Start playing the given sound as soon as possible by mixing it into the sound output buffers of the underlying sound driver."	| dontInsertSamples totalSamples buf n leftover src rest |	dontInsertSamples _ true.  "temporary, until insert samples primitive is ported"	dontInsertSamples ifTrue: [		ActiveSounds add: aSound.		^ self].	"first, fill a double-size buffer with samples"	totalSamples _ Buffer stereoSampleCount * 2.  "two buffer's worth"	buf _ SoundBuffer newStereoSampleCount: totalSamples.	aSound playSampleCount: totalSamples into: buf startingAt: 1 stereo: Stereo.	PlayerSemaphore critical: [		"insert as many samples as possible into the sound driver's buffers"		n _ self primSoundInsertSamples: totalSamples			from: buf			samplesOfLeadTime: 1024.		leftover _ totalSamples - n.		"copy the remainder of buf into Buffer"		"Note: the following loop iterates over 16-bit words, not two-word stereo slices"		"assert: 0 < leftover <= Buffer stereoSampleCount"		src _ 2 * n.		1 to: 2 * leftover do:			[:dst | Buffer at: dst put: (buf at: (src _ src + 1))].		"generate enough additional samples to finish filling Buffer"		rest _ Buffer stereoSampleCount - leftover.		aSound playSampleCount: rest into: Buffer startingAt: leftover + 1 stereo: Stereo.		"record the fact that this sound has already been played into Buffer so that  we don't process it again this time around"		SoundJustStarted _ aSound.		ActiveSounds add: aSound].! !!SoundRecorder methodsFor: 'initialization' stamp: 'jm 11/1/97 20:22'!initialize	"SoundRecorder new"	stereo _ false.	samplingRate _ SoundPlayer samplingRate.	recordedBuffers _ OrderedCollection new: 1000.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	self initializeRecordingState.! !!SoundRecorder methodsFor: 'initialization' stamp: 'jhm 10/15/97 14:30'!initializeRecordingState	recordProcess _ nil.	bufferAvailableSema _ nil.	paused _ true.	meteringBuffer _ nil.	meterLevel _ 0.	soundPlaying _ nil.	currentBuffer _ nil.	nextIndex _ 1.! !!SoundRecorder methodsFor: 'accessing' stamp: 'jj 10/20/97 15:30'!isActive	"Return true if I have a recordProcess running."	^ recordProcess ~~ nil! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 9/2/97 16:16'!isPaused	"Return true if recording is paused."	^ paused! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 9/18/97 19:19'!meterLevel	"Return the meter level, an integer in the range [0..100] where zero is silence and 100 represents the maximum signal level possible without clipping."	^ (100 * meterLevel) // 32768! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 11/4/97 08:25'!recordedSound	"Return the sound that was recorded."	| snd |	stereo ifTrue: [^ self condensedStereoSound].	snd _ SequentialSound new.	recordedBuffers do: [:buf |		snd add: (SampledSound new setSamples: buf samplingRate: samplingRate)].	^ snd! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 12/15/97 14:28'!samplingRate	^ samplingRate! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 9/18/97 14:10'!clearRecordedSound	"Clear the sound recorded thus far. Go into pause mode if currently recording."	paused _ true.	recordedBuffers _ OrderedCollection new: 1000.	self allocateBuffer.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 11/4/97 08:25'!pause	"Go into pause mode. The record level continues to be updated, but no sound is recorded."	paused _ true.	((currentBuffer ~~ nil) and: [nextIndex > 1])		ifTrue: [			recordedBuffers addLast: (currentBuffer copyFrom: 1 to: nextIndex - 1).			self allocateBuffer].	soundPlaying ifNotNil: [		soundPlaying pause.		soundPlaying _ nil].	CanRecordWhilePlaying ifFalse: [self stopRecording].! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 10/17/97 14:53'!playback	"Playback the sound that has been recorded."	self pause.	soundPlaying _ self recordedSound.	soundPlaying play.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 9/17/97 19:47'!recordLevel: anInteger	"Set the desired recording level to the given value in the range 0-1000, where 0 is the lowest recording level and 1000 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	self primSetRecordLevel: anInteger.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jj 10/20/97 15:13'!resumeRecording	"Continue recording from the point at which it was last paused."	CanRecordWhilePlaying ifFalse: [self startRecording].	paused _ false.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 11/4/97 08:25'!startRecording	"Turn of the sound input driver and start the recording process. Initially, recording is paused."	| semaIndex |	CanRecordWhilePlaying ifFalse: [SoundPlayer shutDown].	recordProcess ifNotNil: [self stopRecording].	paused _ true.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	meterLevel _ 0.	self allocateBuffer.	bufferAvailableSema _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: bufferAvailableSema.	self primStartRecordingDesiredSampleRate: (SoundPlayer samplingRate)		stereo: stereo		semaIndex: semaIndex.	samplingRate _ self primGetActualRecordingSampleRate.	recordProcess _ [self recordLoop] newProcess.	recordProcess priority: Processor userInterruptPriority.	recordProcess resume.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jhm 10/15/97 14:30'!stopRecording	"Stop the recording process and turn of the sound input driver."	recordProcess ifNotNil: [recordProcess terminate].	recordProcess _ nil.	self primStopRecording.	Smalltalk unregisterExternalObject: bufferAvailableSema.	((currentBuffer ~~ nil) and: [nextIndex > 1])		ifTrue: [			recordedBuffers addLast: (currentBuffer copyFrom: 1 to: nextIndex - 1)].	self initializeRecordingState.! !!SoundRecorder methodsFor: 'trimming' stamp: 'jm 10/17/97 17:43'!copyFrom: startPlace to: endPlace normalize: nFactor dcOffset: dcOffset	"Return a new SoundBuffer containing the samples in the given range."	| startBufIndex startSampleIndex endBufIndex endSampleIndex	 count resultBuf j buf firstInBuf n |	startBufIndex _ startPlace at: 1.	startSampleIndex _ startPlace at: 2.	endBufIndex _ endPlace at: 1.	endSampleIndex _ endPlace at: 2.	startBufIndex = endBufIndex		ifTrue: [count _ endSampleIndex + 1 - startSampleIndex]		ifFalse: [			count _ ((recordedBuffers at: startBufIndex) size + 1 - startSampleIndex).  "first buffer"			count _ count + endSampleIndex.  "last buffer"			startBufIndex + 1 to: endBufIndex - 1 do:				[:i | count _ count + (recordedBuffers at: i) size]].  "middle buffers"	resultBuf _ SoundBuffer newMonoSampleCount: count.	j _ 1.  "next destination index in resultBuf"	startBufIndex to: endBufIndex do: [:i |		buf _ recordedBuffers at: i.		firstInBuf _ 1.	 	n _ buf size.		i = startBufIndex ifTrue: [			n _ (recordedBuffers at: startBufIndex) size + 1 - startSampleIndex.			firstInBuf _ startSampleIndex].		i = endBufIndex ifTrue: [			i = startBufIndex				ifTrue: [n _ endSampleIndex + 1 - startSampleIndex]				ifFalse: [n _ endSampleIndex]].		self copyTo: resultBuf from: j to: (j + n - 1)			from: buf startingAt: firstInBuf			normalize: nFactor dcOffset: dcOffset.		j _ j + n].	^ resultBuf! !!SoundRecorder methodsFor: 'trimming' stamp: 'jm 10/18/97 11:23'!copyTo: resultBuf from: startIndex to: endIndex from: buf startingAt: firstInBuf normalize: nFactor dcOffset: dcOffset	"Copy samples from buf to resultBuf removing the DC offset and normalizing their volume in the process."	| indexOffset |	indexOffset _ firstInBuf - startIndex.	startIndex to: endIndex do: [:i |		resultBuf at: i put: (((buf at: (i + indexOffset)) - dcOffset) * nFactor) // 1000].! !!SoundRecorder methodsFor: 'trimming' stamp: 'jm 10/18/97 11:22'!normalizeFactorFor: percentOfMaxVolume min: min max: max dcOffset: dcOffset	"Return a normalization factor for the range of sample values and DC offset. A normalization factor is a fixed-point number that will be divided by 1000 after multiplication with each sample value."	| peak factor |	peak _ (max - dcOffset) max: (min - dcOffset) negated.	peak = 0 ifTrue: [^ 1000].	factor _ (32767.0 * percentOfMaxVolume) / (100.0 * peak).	^ (factor * 1000.0) asInteger! !!SoundRecorder methodsFor: 'trimming' stamp: 'jm 10/18/97 11:16'!scanForEndThreshold: threshold dcOffset: dcOffset	"Return an array containing the (<buffer index>, <sample index in buffer>) of the last sample whose absolute value is over the given threshold after subtracting the given DC offset."	| extraSamples buf s |	extraSamples _ 1000.  "number of samples after triggering sample to include"	recordedBuffers size to: 1 by: -1 do: [:i |		buf _ recordedBuffers at: i.		buf size to: 1 by: -1 do: [:j |			s _ (buf at: j) - dcOffset.			s < 0 ifTrue: [s _ s negated].			s > threshold ifTrue: [  "found end"				(j + extraSamples) <= buf size					ifTrue: [^ Array with: i with: j + extraSamples]					ifFalse: [						i < recordedBuffers size							ifTrue: [^ Array with: i + 1 with: extraSamples - (buf size - j)]							ifFalse: [^ Array with: i with: buf size]]]]].	^ Array with: recordedBuffers size with: recordedBuffers last size! !!SoundRecorder methodsFor: 'trimming' stamp: 'jj 10/20/97 15:43'!scanForStartThreshold: threshold dcOffset: dcOffset	"Return an array containing the (<buffer index>, <sample index in buffer>) of the first sample whose absolute value is over the given threshold after subtracting the given DC offset."	| extraSamples buf s |	extraSamples _ 350.  "number of samples before triggering sample to include"	1 to: recordedBuffers size do: [:i |		buf _ recordedBuffers at: i.		1 to: buf size do: [:j |			s _ (buf at: j) - dcOffset.			s < 0 ifTrue: [s _ s negated].			s > threshold ifTrue: [				"found start"				j > extraSamples					ifTrue: [^ Array with: i with: j - extraSamples]					ifFalse: [						i > 1							ifTrue: [^ Array with: i - 1 with: (recordedBuffers at: i - 1) size - (extraSamples - j)]							ifFalse: [^ Array with: i with: 1]]]]].	^ Array with: recordedBuffers size with: recordedBuffers last size! !!SoundRecorder methodsFor: 'trimming' stamp: 'jm 10/18/97 11:04'!trim: threshold normalizedVolume: percentOfMaxVolume	"Remove the leading and trailing parts of this recording that are below the given threshold. Remove any DC offset and scale the recording so that its peaks are the given percent of the maximum volume."	| max min sum totalSamples bufSize s dcOffset startPlace endPlace resultBuf nFactor |	stereo ifTrue: [self error: 'stereo trimming is not yet supported'].	paused ifFalse: [self error: 'must stop recording before trimming'].	recordedBuffers isEmpty ifTrue: [^ self].	max _ min _ sum _ totalSamples _ 0.	recordedBuffers do: [:buf |		bufSize _ buf size.		totalSamples _ totalSamples + buf size.		1 to: bufSize do: [:i |			s _ buf at: i.			s > max ifTrue: [max _ s].			s < min ifTrue: [min _ s].			sum _ sum + s]].	dcOffset _ sum // totalSamples.	"a place is an array of <buffer index><index of sample in buffer>"	startPlace _ self scanForStartThreshold: threshold dcOffset: dcOffset.	(((startPlace at: 1) = recordedBuffers size) and:	 [(startPlace at: 2) = recordedBuffers last size])		ifTrue: [  "no samples above threshold"			recordedBuffers _ recordedBuffers species new.			^ self].	endPlace _ self scanForEndThreshold: threshold dcOffset: dcOffset.	nFactor _ self normalizeFactorFor: percentOfMaxVolume min: min max: max dcOffset: dcOffset.	resultBuf _ self copyFrom: startPlace to: endPlace normalize: nFactor dcOffset: dcOffset.	recordedBuffers _ recordedBuffers species with: resultBuf.! !!SoundRecorder methodsFor: 'private' stamp: 'jm 10/17/97 09:59'!allocateBuffer	"Allocate a new buffer and reset nextIndex."	currentBuffer _ SoundBuffer newMonoSampleCount: 20000.	nextIndex _ 1.! !!SoundRecorder methodsFor: 'private' stamp: 'jm 10/17/97 09:59'!condensedSamples	"Return a single SoundBuffer that is the contatenation of all my recorded buffers."	| sz newBuf i |	recordedBuffers isEmpty ifTrue: [SoundBuffer new: 0].	recordedBuffers size = 1 ifTrue: [^ recordedBuffers first copy].	sz _ recordedBuffers inject: 0 into: [:tot :buff | tot + buff size].	newBuf _ SoundBuffer newMonoSampleCount: sz.	i _ 1.	recordedBuffers do: [:b |		1 to: b size do: [:j |			newBuf at: i put: (b at: j).			i _ i + 1]].	^ newBuf! !!SoundRecorder methodsFor: 'private' stamp: 'jm 1/5/98 17:53'!condensedStereoSound	"Decompose my buffers into left and right channels and return a mixed sound consisting of the those two channels. This may be take a while, since the data must be copied into new buffers."	| sz leftBuf rightBuf leftI rightI left |	sz _ recordedBuffers inject: 0 into: [:tot :buff | tot + buff size].	leftBuf _ SoundBuffer newMonoSampleCount: (sz + 1) // 2.	rightBuf _ SoundBuffer newMonoSampleCount: (sz + 1) // 2.	leftI _ rightI _ 1.	left _ true.	recordedBuffers do: [:b |		1 to: b size do: [:j |			left				ifTrue: [leftBuf at: leftI put: (b at: j). leftI _ leftI + 1. left _ false]				ifFalse: [rightBuf at: rightI put: (b at: j). rightI _ rightI + 1. left _ true]]].	^ MixedSound new		add: (SampledSound new setSamples: leftBuf samplingRate: samplingRate) pan: 0.0;		add: (SampledSound new setSamples: rightBuf samplingRate: samplingRate) pan: 1.0! !!SoundRecorder methodsFor: 'private' stamp: 'jm 9/2/97 16:16'!meterFrom: start count: count in: buffer	"Update the meter level with the maximum signal level in the given range of the given buffer."	| last max sample |	count = 0 ifTrue: [^ self].  "no new samples"	last _ start + count - 1.	max _ 0.	start to: last do: [:i |		sample _ buffer at: i.		sample < 0 ifTrue: [sample _ sample negated].		sample > max ifTrue: [max _ sample]].	meterLevel _ max.! !!SoundRecorder methodsFor: 'private' stamp: 'jm 9/18/97 14:43'!recordLoop	"Record process loop that records samples."	| n sampleCount |	n _ 0.	[true] whileTrue: [		n = 0 ifTrue: [bufferAvailableSema wait].		paused			ifTrue: [				n _ self primRecordSamplesInto: meteringBuffer startingAt: 1.				self meterFrom: 1 count: n in: meteringBuffer]			ifFalse: [				n _ self primRecordSamplesInto: currentBuffer startingAt: nextIndex.				self meterFrom: nextIndex count: n in: currentBuffer.				nextIndex _ nextIndex + n.				stereo					ifTrue: [sampleCount _ currentBuffer stereoSampleCount]					ifFalse: [sampleCount _ currentBuffer monoSampleCount].				nextIndex > sampleCount					ifTrue: [						recordedBuffers addLast: currentBuffer.						self allocateBuffer]]].! !!SoundRecorder methodsFor: 'primitives' stamp: 'jm 9/17/97 16:56'!primGetActualRecordingSampleRate	"Return the actual sample rate being used for recording. This primitive fails unless sound recording is currently in progress."	<primitive: 192>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'jm 9/17/97 16:56'!primRecordSamplesInto: aWordArray startingAt: index	"Record a sequence of 16-bit sound samples into the given array starting at the given sample index. Return the number of samples recorded, which may be zero if no samples are currently available."	<primitive: 193>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'jm 9/17/97 16:56'!primSetRecordLevel: anInteger	"Set the desired recording level to the given value in the range 0-1000, where 0 is the lowest recording level and 1000 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	<primitive: 194>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'jm 9/18/97 13:11'!primStartRecordingDesiredSampleRate: samplesPerSec stereo: stereoFlag semaIndex: anInteger	"Start sound recording with the given stereo setting. Use a sampling rate as close to the desired rate as the underlying platform will support. If the given semaphore index is > 0, it is taken to be the index of a Semaphore in the external objects array to be signalled every time a recording buffer is filled."	<primitive: 190>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'jm 9/17/97 16:56'!primStopRecording	"Stop sound recording. Does nothing if recording is not currently in progress."	<primitive: 191>	self primitiveFailed! !!SoundRecorder class methodsFor: 'class initialization' stamp: 'jj 10/20/97 15:09'!initialize	"SoundRecorder initialize"	"Details: Some computers cannot record and playback sound at the same time. If CanRecordWhilePlaying is false, then the SoundRecorder alternates between recording and playing. If it is true, sounds can be playing during recording."	CanRecordWhilePlaying _ false.! !!SoundRecorder class methodsFor: 'instance creation' stamp: 'jm 8/24/97 01:20'!new	^ super new initialize! !!SoundRecorder class methodsFor: 'accessing' stamp: 'jj 10/20/97 15:32'!canRecordWhilePlaying	"Return true if this platform supports simultaneous sound recording and playback."	^ CanRecordWhilePlaying! !!SoundSequencerMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!initialize	super initialize.	self extent: 550@350.	self makeControlPanel.	self addMorph: controlPanel.	self addMorph: ((SoundLoopMorph newBounds: (10@40 extent: 128@128)) extent: 128@128).	self addMorph: ((SoundLoopMorph newBounds: (10@200 extent: 512@128)) extent: 512@128).! !!SoundSequencerMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:08'!makeControlPanel	| b |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	controlPanel _ LayoutMorph newRow.	controlPanel color: b color; borderWidth: 0; inset: 0.	controlPanel hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	controlPanel addMorphBack: (b fullCopy label: 'reset';	actionSelector: #reset).	controlPanel addMorphBack: (b fullCopy label: 'stop';		actionSelector: #stop).	controlPanel addMorphBack: (b fullCopy label: 'play';	actionSelector: #play).! !!SoundSequencerMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:08'!play	self submorphsDo: [:m | m == controlPanel ifFalse: [m play]]! !!SoundSequencerMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:08'!reset	self submorphsDo: [:m | m == controlPanel ifFalse: [m reset]]! !!SoundSequencerMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!stop	self submorphsDo: [:m | m == controlPanel ifFalse: [m stop]].	SoundPlayer shutDown! !!Spline class methodsFor: 'examples' stamp: '6/8/97 13:55 di'!example	"Designate points on the Path by clicking the red button. Terminate by	pressing any other button. A curve will be displayed, through the	selected points, using a long black form."	| splineCurve aForm flag|	aForm _ Form extent: 2@2.	aForm  fillBlack.	splineCurve _ Spline new.	splineCurve form: aForm.	flag _ true.	[flag] whileTrue:		[Sensor waitButton.		 Sensor redButtonPressed			ifTrue: 				[splineCurve add: Sensor waitButton. 				 Sensor waitNoButton.				 aForm displayOn: Display at: splineCurve last]			ifFalse: [flag_false]].	splineCurve computeCurve.	splineCurve isEmpty 		ifFalse: [splineCurve displayOn: Display.				Sensor waitNoButton]. 	"Spline example"! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'jm 12/5/97 15:14'!setFileTypeToObject	"On the Macintosh, set the file type and creator of this file to be a Squeak object file. On other platforms, do nothing. Setting the file type allows Squeak object files to be sent as email attachments and launched by double-clicking. On other platforms, similar behavior is achieved by creating the file with the '.sqo' file name extension."	FileDirectory default		setMacFileNamed: self fullName		type: 'SOBJ'		creator: 'FAST'.! !!StandardFileStream methodsFor: 'access' stamp: 'jm 1/5/98 20:17'!containingDirectory	"Return the directory containing this file."	^ FileDirectory on: (FileDirectory dirPathFor: self fullName)! !!StandardFileStream methodsFor: 'access' stamp: 'tk 1/6/98 11:37'!directory	"Return the directory I am in"	^ FileDirectory on: (FileDirectory dirPathFor: self fullName)! !!StandardFileStream methodsFor: 'access' stamp: 'di 6/27/97 12:18'!peekFor: item 	"Answer false and do not advance if the next element is not equal to item, or if this stream is at the end.  If the next element is equal to item, then advance over it and return true"	| next |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	(next _ self next) == nil ifTrue: [^ false].	item = next ifTrue: [^ true].	self skip: -1.	^ false! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'sw 2/12/96'!atEnd	"Answer whether the receiver is at its end.  "	^ self primAtEnd: fileID! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'sw 2/12/96'!next	"Read the next object from the file. "	| count |	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.	count = 1		ifTrue: [ ^ buffer1 at: 1 ]		ifFalse: [ ^ nil ].! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'sw 1/31/96'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next |	self atEnd ifTrue: [^ nil].	next _ self next.	self position: self position - 1.	^ next! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'di 7/14/97 23:15'!upTo: delim 	"Fast version to speed up nextChunk"	| pos buffer count |	pos _ self position.	buffer _ self next: 2000.	(count _ buffer indexOf: delim) > 0 ifTrue: 		["Found the delimiter part way into buffer"		self position: pos + count.		^ buffer copyFrom: 1 to: count - 1].	self atEnd ifTrue:		["Never found it, and hit end of file"		^ buffer].	"Never found it, but there's more..."	^ buffer , (self upTo: delim)! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'di 6/28/97 21:33'!verbatim: aString	"A copy of nextPutAll that can be called knowing it wont call nextPut: "	self primWrite: fileID from: aString startingAt: 1 count: aString size.	^ aString! !!StandardFileStream methodsFor: 'added by paul' stamp: 'pm 9/22/97 15:39'!padToNextLongPut: char 	"Make position be on long word boundary, writing the padding 	character, char, if necessary."	[self position \\ 4 = 0]		whileFalse: [self nextPut: char]! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 12/5/97 12:55'!newFileNamed: aFileName 	"create a file in the default directory (or in the directory contained in the input arg), set for write access."	| selection |	(self isAFileNamed: aFileName) ifFalse:		[^ self new open: aFileName forWrite: true].	"File already exists..."	selection _ (PopUpMenu labels: 'overwrite that filechoose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: aFileName) , 'already exists.'.	selection = 1 ifTrue:		[FileDirectory default			deleteFileNamed: aFileName			ifAbsent: [self error: 'Sorry, deletion failed'].		^ self new open: aFileName forWrite: true].	selection = 2 ifTrue:		[^ self newFileNamed:			(FillInTheBlank request: 'Enter a new file name'						initialAnswer: (FileDirectory localNameFor: aFileName))].	self halt! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 12/5/97 12:54'!oldFileNamed: aFileName  	"Open a file in the default directory (or in the directory contained	in the input arg); by default, it's available for reading.  2/12/96 sw	Prior contents will be overwritten, but not truncated on close.  3/18 di"	| selection |	(self isAFileNamed: aFileName) ifTrue:		[^ self new open: aFileName forWrite: true].	"File does not exist..."	selection _ (PopUpMenu labels: 'create a new filechoose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: aFileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self new open: aFileName forWrite: true].	selection = 2 ifTrue:		[^ self oldFileNamed:			(FillInTheBlank request: 'Enter a new file name'						initialAnswer: (FileDirectory localNameFor: aFileName))].	self halt! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 12/5/97 12:54'!readOnlyFileNamed: aFileName	"Open a file of the given name for read-only access.  1/31/96 sw"	| selection |	(self isAFileNamed: aFileName) ifTrue:		[^ self new open: aFileName forWrite: false].	"File does not exist..."	selection _ (PopUpMenu labels: 'choose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: aFileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self readOnlyFileNamed:			(FillInTheBlank request: 'Enter a new file name'						initialAnswer: (FileDirectory localNameFor: aFileName))].	self halt! !!StandardSystemController methodsFor: 'control defaults'!controlActivity	self checkForReframe.	^ super controlActivity! !!StandardSystemController methodsFor: 'basic control sequence'!controlInitialize	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	sensor waitNoButton.	status _ #active! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'sw 9/26/97 12:12'!redButtonActivity	"If cursor is in label of a window when red button is pushed,	check for closeBox or growBox, else drag the window frame"	| box p |	p _ sensor cursorPoint.	self labelHasCursor ifFalse: [super redButtonActivity. ^ self].	sensor blueButtonPressed & self viewHasCursor 		ifTrue: [^ self blueButtonActivity].	((box _ view closeBoxFrame) containsPoint: p)		ifTrue: [Utilities awaitMouseUpIn: box repeating: [] ifSucceed: [self close. ^ self].				^ self].	((box _ view growBoxFrame) containsPoint: p)		ifTrue: [Utilities awaitMouseUpIn: box repeating: [] ifSucceed:					[Sensor controlKeyPressed ifTrue:						[^ self expand; fullScreen].					^ view isCollapsed						ifTrue: [self expand]						ifFalse: [self collapse]].				^ self].	((box _ view labelTextRegion expandBy: 1) containsPoint: p)		ifTrue: [Utilities awaitMouseUpIn: box repeating: [] ifSucceed:					[^ self label].				^ self].	self move.! !!StandardSystemController methodsFor: 'menu messages'!collapse	"Get the receiver's view to change to a collapsed view on the screen."	view collapseToPoint: view chooseCollapsePoint! !!StandardSystemController methodsFor: 'menu messages' stamp: 'sw 9/30/97 21:42'!forceClosed	"The receiver's view should be removed from the screen and from the 	collection of scheduled views."	status _ #closed.	view erase! !!StandardSystemController methodsFor: 'menu messages'!reframe	^ view reframeTo: view getFrame! !!StandardSystemController methodsFor: 'menu messages'!toggleTwoTone	(view isMemberOf: StandardSystemView) ifTrue:		[^ view become: (view as: ColorSystemView)].	(view isMemberOf: ColorSystemView) ifTrue:		[^ view become: (view as: StandardSystemView)].! !!StandardSystemController methodsFor: 'scheduling' stamp: 'sw 9/30/97 22:04'!closeAndUnschedule	"Erase the receiver's view and remove it from the collection of scheduled 	views."	status _ #closed.	view erase.	view release.	ScheduledControllers unschedule: self; searchForActiveController! !!StandardSystemController methodsFor: 'scheduling' stamp: 'jm 10/22/97 08:16'!openNoTerminate	"Create an area in which the receiver's scheduled view can be displayed. 	Make it the active view. Do not terminate the currently active process."	view resizeInitially.	status _ #open.	ScheduledControllers scheduleActiveNoTerminate: self! !!StandardSystemController methodsFor: 'borders'!adjustPaneBorders 	| side sub newRect outerFrame |	outerFrame _ view displayBox.	side = #none.	VBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue: [sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withLeft: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				side = #right ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withRight: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]].	HBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue: [sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withTop: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				side = #bottom ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withBottom: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]]! !!StandardSystemController methodsFor: 'borders'!adjustWindowBorders 	| side |	VBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #left ifTrue:					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].				side = #right ifTrue:					[view newFrame: [:f | f withRight: sensor cursorPoint x]]]]].	HBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #top ifTrue:					[view newFrame: [:f | f withTop: sensor cursorPoint y]].				side = #bottom ifTrue:					[view newFrame: [:f | f withBottom: sensor cursorPoint y]].		]]]! !!StandardSystemController methodsFor: 'borders'!adjustWindowCorners 	| box cornerBox p clicked f2 |	box _ view windowBox.	clicked _ false.	#(topLeft topRight bottomRight bottomLeft)		do: [:readCorner |			cornerBox _ ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (p _ sensor cursorPoint))						and: [(clicked _ sensor anyButtonPressed) not]]						whileTrue.				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | p _ sensor cursorPoint.						readCorner = #topLeft ifTrue:							[f2 _ p corner: f bottomRight].						readCorner = #bottomLeft ifTrue:							[f2 _ (f withBottom: p y) withLeft: p x].						readCorner = #bottomRight ifTrue:							[f2 _ f topLeft corner: p].						readCorner = #topRight ifTrue:							[f2 _ (f withTop: p y) withRight: p x].						f2]]]]].	^ clicked! !!StandardSystemController methodsFor: 'borders'!checkForReframe	| cp |	view isCollapsed ifTrue: [^ self].	cp _ sensor cursorPoint.	((view closeBoxFrame expandBy: 2) containsPoint: cp)		| ((view growBoxFrame expandBy: 2) containsPoint: cp)		ifTrue: [^ self].  "Dont let reframe interfere with close/grow"	self adjustWindowCorners.	self cursorOnBorder ifFalse: [^ self].	((view insetDisplayBox insetBy: 2@2) containsPoint: cp)		ifFalse: [^ self adjustWindowBorders].	(view subviewWithLongestSide: [:s | ] near: cp) == nil		ifFalse: [^ self adjustPaneBorders].! !!StandardSystemController methodsFor: 'borders'!cursorOnBorder 	| cp i box |	view isCollapsed ifTrue: [^ false].	cp _ sensor cursorPoint.	((view labelDisplayBox insetBy: (0@2 corner: 0@-2)) containsPoint: cp)		ifTrue: [^ false].	(i _ view subViews findFirst: [:v | v displayBox containsPoint: cp]) = 0		ifTrue: [box _ view windowBox]		ifFalse: [box _ (view subViews at: i) insetDisplayBox].	^ ((box insetBy: 3) containsPoint: cp) not		and: [(box expandBy: 4) containsPoint: cp]! !!StandardSystemController class methodsFor: 'class initialization'!initialize   "StandardSystemController initialize"	"Set up the menus for standard windows.  	 6/6/96 sw: added fullScreen"	ScheduledBlueButtonMenu _ PopUpMenu labels: 'edit labelchoose color...two-tone/full colormoveframefull screencollapseclose'	lines: #(3 7).	ScheduledBlueButtonMessages _ #(label chooseColor toggleTwoTone move reframe fullScreen collapse close)."StandardSystemController initialize.ScheduledControllers scheduledWindowControllers		do: [:c | c initializeBlueButtonMenu]"	VBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010010000100000		2r1010110000110000		2r1011111111111000		2r1010110000110000		2r1010010000100000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000)			offset: 0@0.	HBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1111111111111111		2r0000000000000000		2r1111111111111111		2r0000000100000000		2r0000001110000000		2r0000011111000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000011111000000		2r0000001110000000		2r0000000100000000		2r0000000000000000		2r0000000000000000		2r0000000000000000)			offset: 0@0.! !!StandardSystemView methodsFor: 'initialize-release'!initialize 	"Refer to the comment in View|initialize."	super initialize.	labelFrame _ Quadrangle new.	labelFrame region: (Rectangle origin: 0 @ 0 extent: 50 @ self labelHeight).	labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	self label: nil.	isLabelComplemented _ false.	minimumSize _ 50 @ 50.	maximumSize _ Display extent.	collapsedViewport _ nil.	expandedViewport _ nil.	bitsValid _ false.! !!StandardSystemView methodsFor: 'initialize-release' stamp: 'di 6/24/97 14:05'!release	self isCollapsed ifTrue: [savedSubViews do: [:v | v release]].	super release! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/16/97 12:30'!closeBoxFrame	^ Rectangle origin: (self labelDisplayBox leftCenter + (10@-5)) extent: (11@11)! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/16/97 12:29'!growBoxFrame	^ Rectangle origin: (self labelDisplayBox rightCenter + (-22@-5)) extent: (11@11)! !!StandardSystemView methodsFor: 'label access'!label	"Answer the string that appears in the receiver's label."	labelText isNil		ifTrue: [^ 'Untitled' copy]		ifFalse: [^ labelText asString]! !!StandardSystemView methodsFor: 'label access'!label: aString 	"Set aString to be the receiver's label."	labelText _ Paragraph			withText: (Text string: ((aString == nil or: [aString isEmpty])								ifTrue: ['Untitled' copy]								ifFalse: [aString])							attributes: (Array with: (TextFontChange fontNumber: 2)											with: TextEmphasis bold))			style: LabelStyle.	insetDisplayBox == nil ifTrue: [^ self].  "wait for further initialization"	self setLabelRegion! !!StandardSystemView methodsFor: 'label access'!labelDisplayBox	"Answer the rectangle that borders the visible parts of the receiver's label 	on the display screen."	^ labelFrame region		align: labelFrame topLeft		with: self windowOrigin! !!StandardSystemView methodsFor: 'label access'!labelFrame	^labelFrame! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/16/97 08:44'!labelHeight	^ (LabelStyle fontAt: 2) height + 4! !!StandardSystemView methodsFor: 'label access'!labelOffset	^ 0 @ (self labelHeight-2)! !!StandardSystemView methodsFor: 'label access'!labelTextRegion	labelText == nil ifTrue: [^ self labelDisplayBox center extent: 0@0].	^ (labelText boundingBox			align: labelText boundingBox center			with: self labelDisplayBox center)		intersect: (self labelDisplayBox insetBy: 35@0)! !!StandardSystemView methodsFor: 'label access' stamp: 'di 10/3/97 14:20'!noLabel	"A label of zero height indicates no label"	labelFrame height > 0		ifTrue: [labelFrame region: (labelFrame bottomLeft + (0@1) extent: labelFrame width@0).				labelFrame borderWidth: 0.				self uncacheBits]! !!StandardSystemView methodsFor: 'label access' stamp: 'di 10/3/97 13:35'!setLabelRegion	"Always follows view width"	labelFrame region: (0 @ 0 extent: self displayBox width @ self labelHeight).	labelFrame borderWidth: 2! !!StandardSystemView methodsFor: 'framing'!chooseCollapsePoint	"Answer the point at which to place the collapsed window."	| pt labelForm beenDown offset |	labelForm _ Form fromDisplay: self labelDisplayBox.	self uncacheBits.	self erase.	beenDown _ Sensor anyButtonPressed.	self isCollapsed ifTrue:		[offset _ self labelDisplayBox topLeft - self growBoxFrame topLeft.		labelForm follow: [pt _ (Sensor cursorPoint + offset max: 0@0) truncateTo: 8]				while: [Sensor anyButtonPressed							ifTrue: [beenDown _ true]							ifFalse: [beenDown not]].		^ pt].	collapsedViewport isNil ifTrue:		[^ RealEstateAgent assignCollapsePointFor: self].	labelForm slideFrom: self labelDisplayBox origin			to: (pt _ collapsedViewport topLeft) nSteps: 10.	^ pt! !!StandardSystemView methodsFor: 'framing'!chooseFrame	"Answer a new frame, depending on whether the view is currently 	collapsed or not."	| labelForm f |	self isCollapsed & expandedViewport notNil		ifTrue:			[labelForm _ bitsValid				ifTrue: [windowBits]				ifFalse: [Form fromDisplay: self labelDisplayBox].			bitsValid _ false.			self erase.			labelForm slideFrom: self labelDisplayBox origin					to: expandedViewport origin-self labelOffset					nSteps: 10.			^ expandedViewport]		ifFalse:			[f _ self getFrame.			bitsValid _ false.			self erase.			^ f topLeft + self labelOffset extent: f extent]! !!StandardSystemView methodsFor: 'framing'!collapse	"If the receiver is not already collapsed, change its view to be that of its 	label only."	self isCollapsed ifFalse:			[expandedViewport _ self viewport.			savedSubViews _ subViews.			self resetSubViews.			labelText isNil ifTrue: [self label: nil.  bitsValid _ false.].			self window: (self inverseDisplayTransform:					((self labelDisplayBox topLeft extent: (labelText extent x + 70) @ self labelHeight)						 intersect: self labelDisplayBox))]! !!StandardSystemView methodsFor: 'framing'!collapsedFrame	"Answer the rectangle occupied by this window when collapsed."	^ collapsedViewport  "NOTE may be nil"! !!StandardSystemView methodsFor: 'framing'!collapseToPoint: collapsePoint	self collapse.	self align: self displayBox topLeft with: collapsePoint.	collapsedViewport _ self viewport.	self displayEmphasized! !!StandardSystemView methodsFor: 'framing'!expand	"If the receiver is collapsed, change its view to be that of all of its 	subviews, not its label alone. "	| newFrame |	self isCollapsed		ifTrue:			[newFrame _ self chooseFrame.			collapsedViewport _ self viewport.			subViews _ savedSubViews.			self window: self defaultWindow.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews _ nil.			self resizeTo: newFrame.			self displayDeEmphasized]! !!StandardSystemView methodsFor: 'framing'!expandedFrame	"Answer the rectangle occupied by this window when expanded."	^ expandedViewport  "NOTE may be nil"! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 8/15/97 17:18'!fullScreen	"Expand the receiver to fill the screen.  Let the model decide how big is full -- allows for flop-out scrollbar on left if desired"	self isCollapsed ifFalse:		[self reframeTo: model fullScreenSize]! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 1/22/96'!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  "	^ model initialExtent min: maximumSize max: minimumSize! !!StandardSystemView methodsFor: 'framing'!newDisplayBoxFor: subView adjoining: newRect along: side 	side = #left ifTrue: [^ subView displayBox withRight: newRect left].	side = #right ifTrue: [^ subView displayBox withLeft: newRect right].	side = #top ifTrue: [^ subView displayBox withBottom: newRect top].	side = #bottom ifTrue: [^ subView displayBox withTop: newRect bottom].! !!StandardSystemView methodsFor: 'framing'!reframePanesAdjoining: subView along: side to: aDisplayBox 	| newBox delta newRect minDim |	newRect _ aDisplayBox.	"First check that this won't make any pane smaller than 8 screen dots"	minDim _ ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])		collect: [:sub | self newDisplayBoxFor: sub adjoining: newRect along: side])			inject: 999 into: [:was :rect | (was min: rect width) min: rect height].	"If so, amend newRect as required"	minDim < 8 ifTrue:		[delta _ minDim - 8.		newRect _ newRect withSide: side setTo: 				((newRect perform: side) > (subView displayBox perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	subViews do:		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:			[newBox _ self newDisplayBoxFor: sub adjoining: newRect along: side.			sub window: sub window viewport:				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].	"And adjust the growing pane itself"	subView window: subView window viewport:			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.	"Finally force a recomposition of the whole window"	self window: self window viewport: self viewport.	self uncacheBits; displayEmphasized! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 1/26/96'!reframeTo: newFrame	"Reframe the receiver to the given screen rectangle.  	Repaint difference after the change.  "	| oldBox newBox portRect |	self uncacheBits.	oldBox _ self windowBox.	portRect _ newFrame topLeft + self labelOffset				corner: newFrame corner.	self window: self window viewport: portRect.	self setLabelRegion.	newBox _ self windowBox.	(oldBox areasOutside: newBox) do:		[:rect | ScheduledControllers restore: rect].	self displayEmphasized! !!StandardSystemView methodsFor: 'framing'!resize	"Determine the rectangular area for the receiver, adjusted to the 	minimum and maximum sizes."	| f |	f _ self getFrame.	self resizeTo: (f topLeft + self labelOffset extent: f extent)! !!StandardSystemView methodsFor: 'framing' stamp: 'di 10/3/97 14:19'!windowOrigin	^ (self isCollapsed or: [labelFrame height = 0  "no label"])		ifTrue: [self displayBox topLeft]		ifFalse: [self displayBox topLeft - self labelOffset]! !!StandardSystemView methodsFor: 'displaying'!cacheBitsAsIs	CacheBits ifFalse: [^ self uncacheBits].	windowBits _ (self cacheBitsAsTwoTone and: [Display depth > 1])		ifTrue: [ColorForm					twoToneFromDisplay: self windowBox					using: windowBits					backgroundColor: self backgroundColor]		ifFalse: [Form fromDisplay: self windowBox using: windowBits].	bitsValid _ true.! !!StandardSystemView methodsFor: 'displaying'!deEmphasizeForDebugger	"Carefully de-emphasis this window because a debugger is being opened. Care must be taken to avoid invoking potentially buggy window display code that could cause a recursive chain of errors eventually resulting in a virtual machine crash. In particular, do not de-emphasize the subviews."	self deEmphasizeView.  "de-emphasize this top-level view"	self uncacheBits.	Smalltalk garbageCollectMost > 1000000 ifTrue: [		"if there is enough space, cache current window screen bits"		self cacheBitsAsIs].! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 10/3/97 13:18'!deEmphasizeLabel	"Un-Highlight the label."	labelFrame height = 0 ifTrue: [^ self].  "no label"	self displayLabelBackground: false.	self displayLabelText.! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 1/16/98 15:27'!displayDeEmphasized	"Display this view with emphasis off.	If windowBits is not nil, then simply BLT if possible,		but force full display for top window so color is preserved."	(bitsValid and: [controller ~~ ScheduledControllers activeController])		ifTrue: [self lock.				windowBits displayAt: self windowOrigin]		ifFalse: [super display.				CacheBits ifTrue: [self cacheBitsAsIs]]! !!StandardSystemView methodsFor: 'displaying'!displayLabelBackground: emphasized	"Clear or emphasize the inner region of the label"	| r1 r2 r3 c3 c2 c1 |	emphasized ifFalse:		["Just clear the label if not emphasized"		^ Display fill: (self labelDisplayBox insetBy: 2) fillColor: self labelColor].	r1 _ self labelDisplayBox insetBy: 2.	r2 _ r1 insetBy: 0@2.	r3 _ r2 insetBy: 0@3.	c3 _ self labelColor.	c2 _ c3 darker.	c1 _ c2 darker darker.	Display fill: r1 fillColor: c1.	Display fill: r2 fillColor: c2.	Display fill: r3 fillColor: c3. "	Here is the Mac racing stripe code	stripes _ Bitmap with: (self labelColor pixelWordForDepth: Display depth)					with: (Form black pixelWordForDepth: Display depth).	self windowOrigin y even ifTrue: [stripes swap: 1 with: 2].	Display fill: (self labelDisplayBox insetBy: 3) fillColor: stripes."! !!StandardSystemView methodsFor: 'displaying'!displayLabelText	"The label goes in the center of the window"	| labelRect |	labelText foregroundColor: self foregroundColor			backgroundColor: self labelColor.	labelRect _ self labelTextRegion.	Display fill: (labelRect expandBy: 3@0) fillColor: self labelColor.	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect			rule: labelText rule fillColor: labelText fillColor! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 8/29/97 18:57'!displayOn: aPort	bitsValid ifFalse:		[^ Display clippingTo: aPort clipRect do: [super display]].	windowBits displayOnPort: aPort at: self windowOrigin! !!StandardSystemView methodsFor: 'displaying'!displayRacingStripes	"Display Racing Stripes in the label"	| labelDisplayBox stripes top bottom left box right |	labelDisplayBox _ self labelDisplayBox.	top _ labelDisplayBox top + 3.	bottom _ labelDisplayBox bottom - 3.	stripes _ Bitmap with: (self labelColor pixelWordForDepth: Display depth)			with: (Color black pixelWordForDepth: Display depth).	top even ifFalse: [stripes swap: 1 with: 2].	left _ labelDisplayBox left + 3.	box _ self closeBoxFrame.	right _ box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left _ box right + 2.	box _ self labelTextRegion.	right _ box left - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left _ box right + 2.	box _ self growBoxFrame.	right _ box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left _ box right + 2.	right _ labelDisplayBox right - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 10/3/97 13:14'!displayView	"Refer to the comment in View|displayView. "	labelFrame height = 0 ifTrue: [^ self].  "no label"	self displayBox width = labelFrame width ifFalse:		["recompute label width when window changes size"		self setLabelRegion].	(labelFrame align: labelFrame topLeft with: self windowOrigin)		insideColor: self labelColor;		displayOn: Display.	self displayLabelText! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 10/3/97 13:18'!emphasizeLabel	"Highlight the label."	labelFrame height = 0 ifTrue: [^ self].  "no label"	self displayLabelBackground: true.	self displayLabelBoxes.	self displayLabelText.! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 8/30/97 11:07'!erase	"Clear the display box of the receiver to be gray, as the screen background."	| oldValid |	CacheBits		ifTrue:			[oldValid _ bitsValid.			bitsValid _ false.			ScheduledControllers restore: self windowBox without: self.			bitsValid _ oldValid]		ifFalse:			[ScheduledControllers restore: self windowBox without: self]! !!StandardSystemView methodsFor: 'displaying'!windowBits	^ windowBits! !!StandardSystemView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	isLabelComplemented ifTrue:		[self deEmphasizeLabel.		isLabelComplemented _ false]! !!StandardSystemView methodsFor: 'private'!subviewWithLongestSide: sideBlock near: aPoint 	| region subs max rect side len theSub theSide |	region _ aPoint - (4@4) corner: aPoint + (4@4).	subs _ subViews select: [:sub | sub insetDisplayBox intersects: region].	subs isEmpty ifTrue: [sideBlock value: #none.  ^ nil].	max _ 0.	subs do:		[:sub | rect _ sub insetDisplayBox.		side _ rect sideNearestTo: aPoint.		len _ (side = #left) | (side = #right)			ifTrue: [rect height]			ifFalse: [rect width].		len > max ifTrue: [max _ len.  theSub _ sub.  theSide _ side]].	sideBlock value: theSide.	^ theSub! !!StandardSystemView class methodsFor: 'class initialization'!cachingBits	^ CacheBits! !!StandardSystemView class methodsFor: 'class initialization'!initialize		"StandardSystemView initialize"	self doCacheBits.	(LabelStyle _ TextStyle default copy)		gridForFont: 2 withLead: 0! !!StarMorph methodsFor: 'all' stamp: 'tk 7/28/97 23:15'!addHandles	| handle strokeOrigin p |	handles ifNotNil: [handles do: [:hh | hh delete]].	strokeOrigin _ 0@0.	vertices do: [:each | strokeOrigin _ strokeOrigin + each].	strokeOrigin _ strokeOrigin // vertices size.	"average is the center"	handles _ Array new: 2.		handle _ EllipseMorph newBounds: (Rectangle center: strokeOrigin extent: 8@8)				color: Color yellow.		handle on: #mouseStillDown send: #dragVertex:fromHandle:vertIndex:				to: self withValue: #center.		self addMorph: handle.	handles at: 1 put: handle.	"The center one!!!!"		p _ vertices at: 2.	"an outside one"		handle _ EllipseMorph newBounds: (Rectangle center: p + (borderWidth//2) extent: 8@8)				color: Color yellow.		handle on: #mouseStillDown send: #dragVertex:fromHandle:vertIndex:				to: self withValue: #outside.		self addMorph: handle.	handles at: 2 put: handle.	"The outside one!!!!"	self changed! !!StarMorph methodsFor: 'all' stamp: 'sw 8/11/97 22:44'!authoringPrototype	^ super authoringPrototype removeHandles! !!StarMorph methodsFor: 'all' stamp: 'tk 7/23/97 18:19'!dragVertex: evt fromHandle: handle vertIndex: label	| ext oldR pt strokeOrigin offset |label == #center ifTrue: [	offset _ evt cursorPoint - (handles at: 1) bounds center.	self position: self position + offset.	].label == #outside ifTrue: [	strokeOrigin _ (handles at: 1) bounds center.	pt _ strokeOrigin - evt cursorPoint - ((handles at: 2) extent // 2).	ext _ pt r.	oldR _ ext.	vertices _ (0 to: 359 by: (360//vertices size)) collect: [:angle |		(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse: [ext]) degrees: angle + pt degrees)			+ strokeOrigin].	(handles at: 2) position: evt cursorPoint.	].self computeBounds.! !!StarMorph methodsFor: 'all' stamp: 'tk 8/4/97 22:20'!initialize	| pt ext oldR points |	super initialize.	color _ Color lightBlue.	borderWidth _ 1.	borderColor _ Color black.	pt _ 10@10.	ext _ pt r.	oldR _ ext.	points _ 5.	vertices _ (0 to: 359 by: (360//points//2)) collect: [:angle |		(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse:[ext]) degrees: angle + pt degrees)			+ (45@45)].	self computeBounds! !!StarMorph methodsFor: 'all' stamp: 'di 9/26/97 11:11'!updateHandles! !!StrikeFont methodsFor: 'accessing'!setGlyphs: newGlyphs	"Replace the glyphs form.  Used to make a synthetic bold or italic font quickly."	glyphs _ newGlyphs! !!StrikeFont methodsFor: 'accessing'!widthOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	| ascii |	ascii _ (aCharacter asciiValue min: maxAscii) max: minAscii.	^(xTable at: ascii + 2) - (xTable at: ascii + 1)! !!StrikeFont methodsFor: 'emphasis'!bonk: glyphForm with: bonkForm	"Bonking means to run through the glyphs clearing out black pixels	between characters to prevent them from straying into an adjacent	character as a result of, eg, bolding or italicizing"	"Uses the bonkForm to erase at every character boundary in glyphs."	| bb offset |	offset _ bonkForm offset x.	bb _ BitBlt toForm: glyphForm.	bb sourceForm: bonkForm; sourceRect: bonkForm boundingBox;		combinationRule: Form erase; destY: 0.	1 to: xTable size-1 do: [:i | bb destX: (xTable at: i) + offset; copyBits].! !!StrikeFont methodsFor: 'emphasis'!emphasized: code 	"Answer a copy of the receiver with emphasis set to include code."	| derivative addedEmphasis base g r safeCode |	code = 0 ifTrue: [^ self].	(derivativeFonts == nil or: [derivativeFonts size = 0]) ifTrue: [^ self].	derivative _ derivativeFonts at: (safeCode _ code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis _ 1 bitShift: safeCode highBit - 1.	base _ self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative _ (base copy name: base name , 'B') makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative _ (base copy name: base name , 'I') makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative _ (base copy name: base name , 'U') makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative _ (base copy name: base name , 'N') makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative _ (base copy name: base name , 'X') makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative! !!StrikeFont methodsFor: 'emphasis'!makeBoldGlyphs	"Make a bold set of glyphs with same widths by ORing 1 bit to the right		(requires at least 1 pixel of intercharacter space)"	| g bonkForm |	g _ glyphs deepCopy.	bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.	self bonk: g with: bonkForm.	g copyBits: g boundingBox from: g at: (1@0)		clippingBox: g boundingBox rule: Form under fillColor: nil.	glyphs _ g! !!StrikeFont methodsFor: 'emphasis' stamp: 'di 10/31/97 13:18'!makeCondensedGlyphs	"Make a condensed set of glyphs with same widths.	NOTE: this has been superceded by kerning -- should not get called"	| g newXTable x x1 w |	g _ glyphs deepCopy.	newXTable _ Array new: xTable size.	newXTable at: 1 put: (x _ xTable at: 1).	1 to: xTable size-1 do:		[:i | x1 _ xTable at: i.  w _ (xTable at: i+1) - x1.		w > 1 ifTrue: [w _ w-1].  "Shrink every character wider than 1"		g copy: (x@0 extent: w@g height) from: x1@0 in: glyphs rule: Form over.		newXTable at: i+1 put: (x _ x + w)].	xTable _ newXTable.	glyphs _ g"(TextStyle default fontAt: 1) copy makeCondensedGlyphs	displayLine: 'The quick brown fox jumps over the lazy dog'	at: Sensor cursorPoint"! !!StrikeFont methodsFor: 'emphasis'!makeItalicGlyphs	"Make an italic set of glyphs with same widths by skewing left and right		(may require more intercharacter space)"	| g r bonkForm bc |	g _ glyphs deepCopy.	"BonkForm will have bits where slanted characters overlap their neighbors."	bonkForm _ Form extent: (self height//4+2) @ self height.	bc _ self descent//4 + 1.  "Bonker x-coord corresponding to char boundary."	bonkForm fill: (0 @ 0 corner: (bc+1) @ self ascent) fillColor: Color black.	4 to: self ascent-1 by: 4 do:		[:y | 		"Slide ascenders right..."		g copy: (1@0 extent: g width @ (self ascent - y))			from: 0@0 in: g rule: Form over.		bonkForm copy: (1@0 extent: bonkForm width @ (self ascent - y))			from: 0@0 in: bonkForm rule: Form over].	bonkForm fill: (0 @ 0 corner: (bc+1) @ self ascent) fillColor: Color white.	bonkForm fill: (bc @ self ascent corner: bonkForm extent) fillColor: Color black.	self ascent to: self height-1 by: 4 do:		[:y | 		"Slide descenders left..."		g copy: (0@y extent: g width @ g height)			from: 1@y in: g rule: Form over.		bonkForm copy: (0@0 extent: bonkForm width @ bonkForm height)			from: 1@0 in: bonkForm rule: Form over].	bonkForm fill: (bc @ self ascent corner: bonkForm extent) fillColor: Color white.	"Now use bonkForm to erase at every character boundary in glyphs."	bonkForm offset: (0-bc) @ 0.	self bonk: g with: bonkForm.	glyphs _ g! !!StrikeFont methodsFor: 'emphasis'!makeStruckOutGlyphs	"Make a struck-out set of glyphs with same widths"	| g |	g _ glyphs deepCopy.	g fillBlack: (0 @ (self ascent - (self ascent//3)) extent: g width @ 1).	glyphs _ g! !!StrikeFont methodsFor: 'emphasis'!makeUnderlinedGlyphs	"Make an underlined set of glyphs with same widths"	| g |	g _ glyphs deepCopy.	g fillBlack: (0 @ (self ascent+1) extent: g width @ 1).	glyphs _ g! !!StrikeFont methodsFor: 'emphasis'!reset	"Reset the cache of derivative emphasized fonts"	derivativeFonts _ Array new: 32! !!StrikeFont methodsFor: 'file in/out'!displayChar: ascii form: charForm	"Convenience utility used during conversion of BitFont files"	| m bigForm |	Display fillBlack: (0@0 extent: 20@14).	ascii printString displayAt: 0@2.	charForm width > 0 ifTrue:		[m _ 5.		bigForm _ charForm magnify: charForm boundingBox by: m@m.		Display border: ((bigForm boundingBox expandBy: m) translateBy: 50@2) width: m.		bigForm displayAt: 50@2.		Display fillBlack: ((50@2)+((m*charForm width)@0) extent: 1@(m*self height))].! !!StrikeFont methodsFor: 'file in/out'!newFromStrike: fileName	"Build an instance from the strike font file name. The '.strike' extension	is optional."	| strike startName raster16 |	name _ fileName copyUpTo: $..	"assumes extension (if any) is '.strike'".	strike _ FileStream oldFileNamed: name, '.strike.'.	strike binary.	strike readOnly.		"strip off direcory name if any"	startName _ name size.	[startName > 0 and: [((name at: startName) ~= $>) & ((name at: startName) ~= $])]]		whileTrue: [startName _ startName - 1].	name _ name copyFrom: startName+1 to: name size.	type			_		strike nextWord16.		"type is ignored now -- simplest												assumed.  Kept here to make												writing and consistency more												straightforward."	minAscii		_		strike nextWord16.	maxAscii		_		strike nextWord16.	maxWidth		_		strike nextWord16.	strikeLength	_		strike nextWord16.	ascent			_		strike nextWord16.	descent			_		strike nextWord16.	"xOffset			_"		strike nextWord16. 		raster16			_		strike nextWord16.		superscript		_		ascent - descent // 3.		subscript		_		descent - ascent // 3.		emphasis		_		0.	glyphs			_	Form extent: (raster16 * 16) @ (self height)  							offset: 0@0.		glyphs bits fromByteStream: strike.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: strike nextWord16].	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	strike close.	self setStopConditions ! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 6/26/97 14:16'!objectToStoreOnDataStream	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	| known eval |	thisContext sender receiver class == ReferenceStream ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	known _ TextStyle default fontArray detect: [:x | x name sameAs: self name] ifNone: [nil]. 	known == self ifTrue: ["not modified"		eval _ 'TextStyle default fontNamed: ', self name printString.		^ DiskProxy global: #Compiler selector: #evaluate: 			args: (Array with: eval)			"We are expecting it to be there"].	^ self	"Special font.  Write me out"! !!StrikeFont methodsFor: 'file in/out'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(' , self name , ')'! !!StrikeFont methodsFor: 'file in/out'!readBFHeaderFrom: f	name _ self restOfLine: 'Font name = ' from: f.	ascent _ (self restOfLine: 'Ascent = ' from: f) asNumber.	descent _ (self restOfLine: 'Descent = ' from: f) asNumber.	maxWidth _ (self restOfLine: 'Maximum width = ' from: f) asNumber.	pointSize _ (self restOfLine: 'Font size = ' from: f) asNumber.	name _ (name copyWithout: Character space) ,				(pointSize < 10					ifTrue: ['0' , pointSize printString]					ifFalse: [pointSize printString]).	minAscii _ 258.	maxAscii _ 0.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ 0.	type _ 0.  "ignored for now"! !!StrikeFont methodsFor: 'file in/out' stamp: 'di 9/15/97 21:51'!readFromBitFont: fileName	"This builds a StrikeFont instance by reading the data file format	produced by BitFont, a widely available font conversion utility	written by Peter DiCamillo at Brown University"	"StrikeFont new readFromBitFont: 'Palatino10.BF' "	| f lastAscii charLine width ascii charForm line missingForm tempGlyphs iRect p rectLine left tokens right |	f _ FileStream readOnlyFileNamed: fileName.	self readBFHeaderFrom: f.	"NOTE: if font has been scaled (and in any case),	the REAL bitmap dimensions come after the header."	self restOfLine: 'Extent information for entire font' from: f.	"Parse the following line (including mispelling!!)"	"Image rectange: left = -2, right = 8, bottom = -2, top = 7"	tokens _ (f upTo: Character cr)  findTokens: ' '.	iRect _ Rectangle left: (tokens at: 5) asNumber right: (tokens at: 8) asNumber				top: (tokens at: 14) asNumber bottom: (tokens at: 11) asNumber.	ascent _ iRect top.	descent _ iRect bottom negated.		tempGlyphs _ Form extent: (maxWidth*257) @ self height.	xTable _ (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	"Read character forms and blt into tempGlyphs"	lastAscii _ -1.	[charLine _ self restOfLine: 'Character: ' from: f.	charLine == nil ifFalse:		[p _ f position.		rectLine _ f upTo: Character cr.		(rectLine beginsWith: 'Image rectange: left = ')			ifTrue: [tokens _ rectLine findTokens: ' '.					left _ (tokens at: 5) asNumber. right _ (tokens at: 8) asNumber]			ifFalse: [left _ right _ 0. f position: p].		width_ (self restOfLine: 'Width (final pen position) = ' from: f) asNumber - left					max: (right-left+1).		(charLine beginsWith: 'Missing character') ifTrue: [ascii _ 256].		('x''*' match: charLine) ifTrue:			[ascii _ Number readFrom: (charLine copyFrom: 3 to: 4) asUppercase base: 16].		charForm _ Form extent: width@self height.		('*[all blank]' match: charLine) ifFalse:			[self restOfLine: '  +' from: f.			1 to: self height do:				[:y | line _ f upTo: Character cr.				4 to: (width + 3 min: line size + iRect left - left) do:					[:x | (line at: x - iRect left + left) = $*						ifTrue: [charForm pixelValueAt: (x-4)@(y-1) put: 1]]]]].	charLine == nil]		whileFalse:			[self displayChar: ascii form: charForm.			ascii = 256				ifTrue: [missingForm _ charForm deepCopy]				ifFalse:				[minAscii _ minAscii min: ascii.				maxAscii _ maxAscii max: ascii.				lastAscii+1 to: ascii-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].				tempGlyphs copy: ((xTable at: ascii+1)@0										extent: charForm extent)							from: 0@0 in: charForm rule: Form over.				xTable at: ascii+2 put: (xTable at: ascii+1) + width.				lastAscii _ ascii]].	f close.	lastAscii+1 to: maxAscii+1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs _ Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable _ xTable copyFrom: 1 to: maxAscii+3.	self setStopConditions! !!StrikeFont methodsFor: 'file in/out'!readFromStrike2: fileName  "StrikeFont new readFromStrike2: 'Palatino14.sf2'"	"Build an instance from the strike font stored in strike2 format.	fileName is of the form: <family name><pointSize>.sf2"	| file |	('*.sf2' match: fileName) ifFalse: [self halt.  "likely incompatible"].	name _ fileName copyUpTo: $. .  "Drop filename extension"	file _ FileStream readOnlyFileNamed: fileName.	file binary.	self readFromStrike2Stream: file! !!StrikeFont methodsFor: 'file in/out'!readFromStrike2Stream: file 	"Build an instance from the supplied binary stream on data in strike2 format"	type _ file nextInt32.  type = 2 ifFalse: [file close. self halt "not strike2 format"].	minAscii _ file nextInt32.	maxAscii _ file nextInt32.	maxWidth _ file nextInt32.	ascent _ file nextInt32.	descent _ file nextInt32.	pointSize _ file nextInt32.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ file nextInt32.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: file nextInt32].	glyphs _ Form new readFrom: file.	file close.	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	self setStopConditions! !!StrikeFont methodsFor: 'file in/out'!restOfLine: leadString from: file	"Utility method to assist reading of BitFont data files"	| line |	[line _ file upTo: Character cr.	line size < leadString size or: [leadString ~= (line copyFrom: 1 to: leadString size)]]	whileTrue: [file atEnd ifTrue: [^ nil]].	^ line copyFrom: leadString size+1 to: line size! !!StrikeFont methodsFor: 'file in/out'!setStopConditions	"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	1 to: (minAscii - 1) do:		[:index | stopConditions at: index put: #characterNotInFont].	(maxAscii + 3) to: stopConditions size do:		[:index | stopConditions at: index put: #characterNotInFont].	self reset! !!StrikeFont methodsFor: 'file in/out'!writeAsStrike2named: fileName	"Write me onto a file in strike2 format.	fileName should be of the form: <family name><pointSize>.sf2"	| file |	file _ FileStream fileNamed: fileName.	file binary.	file nextInt32Put: 2.	file nextInt32Put: minAscii.	file nextInt32Put: maxAscii.	file nextInt32Put: maxWidth.	file nextInt32Put: ascent.	file nextInt32Put: descent.	file nextInt32Put: pointSize.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		file nextInt32Put: emphasis.	(minAscii + 1 to: maxAscii + 3) do:		[:index | file nextInt32Put: (xTable at: index)].	glyphs writeOn: file.	file close.! !!StrikeFont methodsFor: 'character shapes'!alter: char formBlock: formBlock	self characterFormAt: char 		put: (formBlock value: (self characterFormAt: char))! !!StrikeFont methodsFor: 'character shapes'!characterForm: char pixelValueAt: pt put: val	| f |	f _ self characterFormAt: char.	f pixelAt: pt put: val.	self characterFormAt: char put: val! !!StrikeFont methodsFor: 'character shapes'!characterFormAt: character 	"Answer a Form copied out of the glyphs for the argument, character."	| ascii leftX rightX |	ascii _ character asciiValue.	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	^ glyphs copy: (leftX @ 0 corner: rightX @ self height)! !!StrikeFont methodsFor: 'character shapes'!characterFormAt: character put: characterForm	"Copy characterForm over the glyph for the argument, character."	| ascii leftX rightX widthDif newGlyphs |	ascii _ character asciiValue.	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	widthDif _ characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue:		["Make new glyphs with more or less space for this char"		newGlyphs _ Form extent: (glyphs width + widthDif) @ glyphs height.		newGlyphs copy: (0@0 corner: leftX@glyphs height)			from: 0@0 in: glyphs rule: Form over.		newGlyphs copy: ((rightX+widthDif)@0 corner: newGlyphs width@glyphs height)			from: rightX@0 in: glyphs rule: Form over.		glyphs _ newGlyphs.		"adjust further entries on xTable"		ascii+2 to: xTable size			do: [:i | xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 corner: rightX @ self height)		from: 0@0 in: characterForm rule: Form over"| f |  f _ TextStyle default fontAt: 1.f characterFormAt: $  put: (Form extent: (f widthOf: $ )+10@f height)"! !!StrikeFont methodsFor: 'character shapes'!edit: character		"(TextStyle default fontAt: 1) edit: $_"	"Open a Bit Editor on the given character.  Note that you must do an accept	(in the option menu of the bit editor) if you want this work.	Accepted edits will not take effect in the font until you leave or close the bit editor.	Also note that unaccepted edits will be lost when you leave or close."	| charForm smallRect editRect scaleFactor bitEditor savedForm r |	charForm _ self characterFormAt: character.	editRect _ BitEditor locateMagnifiedView: charForm	                                        scale: (scaleFactor _ 8@8).	bitEditor _ BitEditor bitEdit: charForm at: editRect topLeft			scale: scaleFactor remoteView: nil.	bitEditor controller blueButtonMenu: nil blueButtonMessages: nil.	savedForm _ Form fromDisplay: (r _ bitEditor displayBox expandBy: (0@23 corner: 0@0)).	bitEditor controller startUp.	bitEditor release.	savedForm displayOn: Display at: r topLeft.	self characterFormAt: character put: charForm! !!StrikeFont methodsFor: 'character shapes'!widen: char by: delta	| newForm |	^ self alter: char formBlock:  "Make a new form, wider or narrower..."		[:charForm | newForm _ Form extent: charForm extent + (delta@0).		charForm displayOn: newForm.  "Copy this image into it"		newForm]    "and substitute it in the font"! !!StrikeFont class methodsFor: 'instance creation' stamp: 'di 10/20/97 20:12'!familyName: aName size: aSize	| aStyle |	(aStyle _ TextStyle named: aName asSymbol)		ifNil: [self halt: 'Error: font ', aName, ' not found.'].	^ aStyle fontOfSize: aSize! !!StrikeFont class methodsFor: 'instance creation'!fromStrike: fileName 	"Read a font from disk in the old ST-80 'strike' format.	Note: this is an old format; use strike2 format instead"	^self new newFromStrike: fileName! !!StrikeFont class methodsFor: 'examples'!convertFontsNamed: familyName  " StrikeFont convertFontsNamed: 'NewYork' "	"This utility is for use after you have used BitFont to produce data files 	for the fonts you wish to use.  It will read the BitFont files and then 	write them out in strike2 (*.sf2) format which is much more compact,	and which can be read in again very quickly."	"For this utility to work as is, the BitFont data files must be named	'familyNN.BF', and must reside in the same directory as the image."	| f |	(FileDirectory default fileNamesMatching: familyName , '*.BF') do:		[:fname | Transcript cr; show: fname.		f _ StrikeFont new readFromBitFont: fname.		f writeAsStrike2named: f name , '.sf2']! !!StrikeFont class methodsFor: 'examples'!example	"Displays a line of text on the display screen at the location of the cursor.	Example depends on the strike font file, 'TimesRoman10.strike'. existing."	(StrikeFont new readFromStrike2: 'NewYork12.sf2')		displayLine: 'A line of 12-pt text in New York style' at: Sensor cursorPoint	 	"StrikeFont example."! !!StrikeFont class methodsFor: 'examples'!size: pointSize fromLiteral: aString	"This method allows a font set to be captured as sourcecode in a subclass.	The string literals will presumably be created by printing, eg,		(FileStream readOnlyFileNamed: 'Palatino24.sf2') contentsOfEntireFile,		and then pasting into a browser after a heading like, eg,size24	^ self size: 24 fromLiteral:	'--unreadable binary data--'	See the method hackDefaultStyle to see how this can be used"	^ (StrikeFont new readFromStrike2Stream:		(ExternalStream on: aString asByteArray from: 1 to: aString size))		name: self name , (pointSize < 10 ifTrue: ['0' , pointSize printString]										ifFalse: [pointSize printString])! !!StrikeFont class methodsFor: 'derivative font caching'!shutDown  "StrikeFont shutDown"	"Deallocate synthetically derived copies of base fonts to save space"	self allInstancesDo: [:sf | sf reset]! !A String is an indexed collection of Characters, compactly encoded as 8-bit bytes.String support a vast array of useful methods, which can best be learned by browsing and trying out examples as you find them in the code.Here are a few useful methods to look at...	String match:	String contractTo:String also inherits many useful methods from its hierarchy, such as	SequenceableCollection ,	SequenceableCollection copyReplaceAll:with:!]style[(269 13 2 18 72 24 2 43)f1,f1LString match:;,f1,f1LString contractTo:;,f1,f1LSequenceableCollection ,;,f1,f1LSequenceableCollection copyReplaceAll:with:;!!String methodsFor: 'accessing' stamp: 'tk 6/18/96'!atWrap: index 	"Return this element of an indexable object, letting the index wrap around from the end to the beginning.  See Object at:.  Needed here when index is not an integer and has to be coerced.  "	<primitive: 63>	^(super atWrap: index) asCharacter! !!String methodsFor: 'accessing' stamp: 'tk 12/26/97 11:09'!findAnySubStr: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."	| min ind |	min _ self size + 1.	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"		delim class == Character 			ifTrue: [ind _ self indexOfSubCollection: (String with: delim) 						startingAt: start ifAbsent: [min]]			ifFalse: [ind _ self indexOfSubCollection: delim 						startingAt: start ifAbsent: [min]].			min _ min min: ind].	^ min! !!String methodsFor: 'accessing' stamp: 'tk 12/26/97 10:09'!findBetweenSubStrs: delimiters	"Answer the collection of tokens that result from parsing self.  Tokens are separated by substrings, as listed in the Array delimiters."	| tokens keyStart keyStop |	tokens _ OrderedCollection new.	keyStop _ 1.	[keyStop <= self size] whileTrue:		[keyStart _ self skipAnySubStr: delimiters startingAt: keyStop.		keyStop _ self findAnySubStr: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'tk 12/26/97 10:07'!findTokens: delimiters	"Answer the collection of tokens that result from parsing self.  Any character in the String delimiters marks a border.  Several delimiters in a row are considered as just one separation."	| tokens keyStart keyStop |	tokens _ OrderedCollection new.	keyStop _ 1.	[keyStop <= self size] whileTrue:		[keyStart _ self skipDelimiters: delimiters startingAt: keyStop.		keyStop _ self findDelimiters: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'tk 12/26/97 09:50'!findTokens: delimiters includes: subString	"Divide self into pieces using delimiters.  Return the piece that includes subString anywhere in it.  Is case sensitive (say asLowercase to everything beforehand to make insensitive)."^ (self findTokens: delimiters) 	detect: [:str | (str includesSubString: subString)] 	ifNone: [nil]! !!String methodsFor: 'accessing' stamp: 'tk 6/19/97 10:05'!findTokens: delimiters keep: keepers	"Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)"	| tokens keyStart keyStop |	tokens _ OrderedCollection new.	keyStop _ 1.	[keyStop <= self size] whileTrue:		[keyStart _ self skipDelimiters: delimiters startingAt: keyStop.		keyStop to: keyStart-1 do: [:ii | 			(keepers includes: (self at: ii)) ifTrue: [				tokens add: (self copyFrom: ii to: ii)]].	"Make this keeper be a token"		keyStop _ self findDelimiters: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'sw 8/12/97 12:37'!includesSubString: subString	^ (self findString: subString startingAt: 1) > 0! !!String methodsFor: 'accessing' stamp: 'tk 12/26/97 11:37'!skipAnySubStr: delimiters startingAt: start 	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."	| any this ind ii |	ii _ start-1.	[(ii _ ii + 1) <= self size] whileTrue: [ "look for char that does not match"		any _ false.		delimiters do: [:delim |			delim class == Character 				ifTrue: [(self at: ii) == delim ifTrue: [any _ true]]				ifFalse: ["a substring"					ind _ 0.					this _ true.					delim do: [:dd | 						dd == (self at: ii+ind) ifFalse: [this _ false].						ind _ ind + 1].					this ifTrue: [ii _ ii + delim size - 1.  any _ true]]].		any ifFalse: [^ ii]].	^ self size + 1! !!String methodsFor: 'accessing'!skipDelimiters: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that does NOT match one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.  Assumes the delimiters to be a non-empty string."	start to: self size do: [:i |		delimiters detect: [:delim | delim = (self at: i)]				ifNone: [^ i]].	^ self size + 1! !!String methodsFor: 'comparing'!beginsWith: prefix | prefixSize |	"Answer whether the receiver begins with the given prefix string."	prefixSize _ prefix size.	self size < prefixSize ifTrue: [^false].	1 to: prefixSize do:		[:index | (self at: index) = (prefix at: index) ifFalse: [^false]].	^true! !!String methodsFor: 'comparing'!crc16	| crc |	crc := 0.	self do: [:c |		crc := (crc bitXor: (c asciiValue bitShift: 8)) bitAnd: 16rFFFF.		1 to: 8 do: [:dmy | "due to compiler optimization this is a bit faster than timesRepeat:"			crc := (crc bitAnd: 16r8000) ~= 0			 ifTrue: [(crc bitShift: 1) bitXor: 16r1021]			 ifFalse: [crc bitShift: 1]		].	].	^crc bitAnd: 16rFFFF! !!String methodsFor: 'converting'!asByteArray	"Convert to a ByteArray with the ascii values of the string.	Fast code uses primitive that avoids character conversion"	^ (ByteArray new: self size) replaceFrom: 1 to: self size with: self! !!String methodsFor: 'converting'!capitalized	"Return a copy with the first letter capitalized"	| cap |	cap _ self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap! !!String methodsFor: 'converting' stamp: 'di 1/16/98 16:33'!contractTo: smallSize	"return myself or a copy shortened by ellipsis to smallSize"	| leftSize |	self size <= smallSize		ifTrue: [^ self].  "short enough"	smallSize < 5		ifTrue: [^ self copyFrom: 1 to: smallSize].    "First N characters"	leftSize _ smallSize-2//2.	^ self copyReplaceFrom: leftSize+1		"First N/2 ... last N/2"		to: self size - (smallSize - leftSize - 3)		with: '...'"	'A clear but rather long-winded summary' contractTo: 18"! !!String methodsFor: 'converting'!substrings	"Answer an array of the substrings that compose the receiver."	| result aStream char |	result _ WriteStream on: (Array new: 10).	aStream _ WriteStream on: (String new: 16).	1 to: self size do: [:i |		((char _ self at: i) isSeparator)		 ifTrue: [aStream isEmpty ifFalse: [result nextPut: aStream contents. aStream reset]]		 ifFalse: [aStream nextPut: char]].	aStream isEmpty ifFalse: [result nextPut: aStream contents].	^ result contents! !!String methodsFor: 'converting' stamp: 'sw 11/25/96'!surroundedBySingleQuotes	"Answer the receiver with leading and trailing quotes.  "	^ $' asString, self, $' asString! !!String methodsFor: 'converting' stamp: 'di 11/16/97 08:52'!withBlanksTrimmed	"Return a copy of the receiver from which leading and trailing blanks 	have been trimmed.   Simplified by Gerardo Richarte 11/3/97"	^ self		copyFrom: (self findFirst: [:eachChar | eachChar isSeparator not])		to: (self findLast: [:eachChar | eachChar isSeparator not])	" ' abc  d   ' withBlanksTrimmed"! !!String methodsFor: 'displaying' stamp: 'di 9/11/97 10:48'!displayProgressAt: aPoint from: minVal to: maxVal during: workBlock 	"Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)'Now here''s some Real Progress'	displayProgressAt: Sensor cursorPoint	from: 0 to: 10	during: [:bar |	1 to: 10 do: [:x | bar value: x.			(Delay forMilliseconds: 500) wait]].HOW IT WORKS (Try this in any other language :-)Since your code (the last 2 lines in the above example) is in a block,this method gets control to display its heading before, and clean up the screen after, its execution.The key, though, is that the block is supplied with an argument,named 'bar' in the example, which will update the bar image every it is sent the message value: x, where x is in the from:to: range."	| delta savedArea captionText textFrame barFrame outerFrame result range |	barFrame _ aPoint - (75@10) corner: aPoint + (75@10).	captionText _ DisplayText text: self asText allBold.	captionText		foregroundColor: Color black		backgroundColor: Color white.	textFrame _ captionText boundingBox insetBy: -4.	textFrame _ textFrame align: textFrame bottomCenter					with: barFrame topCenter + (0@2).	outerFrame _ barFrame merge: textFrame.	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	barFrame _ barFrame translateBy: delta.	textFrame _ textFrame translateBy: delta.	outerFrame _ outerFrame translateBy: delta.	savedArea _ Form fromDisplay: outerFrame.	Display fillBlack: barFrame; fillWhite: (barFrame insetBy: 2).	Display fillBlack: textFrame; fillWhite: (textFrame insetBy: 2).	captionText displayOn: Display at: textFrame topLeft + (4@4).	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"		[:barVal |		Display fillGray: (barFrame topLeft + (2@2) extent:				(((barFrame width-4) * ((barVal-minVal) asFloat / range min: 1.0)) asInteger@16))].	savedArea displayOn: Display at: outerFrame topLeft.	^ result! !!String methodsFor: 'private'!correctAgainstEnumerator: wordBlock continuedFrom: oldCollection	"The guts of correction, instead of a wordList, there is a block that should take abnother block and enumerate over some list with it."	| choices scoreMin results score |	scoreMin _ self size // 2 min: 3.	oldCollection isNil		ifTrue: [ choices _ SortedCollection sortBlock: [ :x :y | x value > y value ] ]		ifFalse: [ choices _ oldCollection ].	wordBlock isNil		ifTrue:			[ results _ OrderedCollection new.			1 to: (5 min: choices size) do: [ :i | results add: (choices at: i) key ] ]		ifFalse:			[ wordBlock value: [ :word |				(score _ self alike: word) >= scoreMin ifTrue:					[ choices add: (Association key: word value: score).						(choices size >= 5) ifTrue: [ scoreMin _ (choices at: 5) value] ] ].			results _ choices ].	^ results! !!String methodsFor: 'Celeste'!includesSubstring: aString caseSensitive: caseSensitive	"Note: Although less general than the 'match:' method, this method was a factor of 10 faster on both successful and unsucessful finds of a short string in a 1116 byte mail message."		| first index i |	self isEmpty ifTrue: [^false].	caseSensitive ifTrue: [		first _ aString first.		1 to: self size - aString size + 1 do: [ :start |			(self at: start) = first ifTrue: [				i _ 1.				[(self at: start + i - 1) = (aString at: i)] whileTrue: [					i = aString size ifTrue: [^true].					i _ i + 1.				].			].		].	] ifFalse: [		first _ aString first asLowercase.		1 to: self size - aString size + 1 do: [ :start |			(self at: start) asLowercase = first ifTrue: [				i _ 1.				[(self at: start + i - 1) asLowercase =				 (aString at: i) asLowercase] whileTrue: [					i = aString size ifTrue: [^ true].					i _ i + 1.				].			].		].	].	^ false! !!String methodsFor: 'Celeste'!withCRs	"Return a copy of the receiver in which backslash (\) characters have been replaced with carriage returns."	^ self collect: [ :c | c = $\ ifTrue: [ Character cr ] ifFalse: [ c ]].! !!String class methodsFor: 'instance creation' stamp: 'sw 8/5/97 13:55'!crString	^ self with: Character cr! !!String class methodsFor: 'instance creation' stamp: 'di 1/14/98 10:26'!fromString: aString 	"Answer an instance of me that is a copy of the argument, aString."		^ aString copyFrom: 1 to: aString size! !!StringButtonMorph methodsFor: 'initialization'!initialize	super initialize.	self color: Color black.	target _ nil.	actionSelector _ #flash.	arguments _ EmptyArray.	actWhen _ #buttonUp.	self contents: 'Flash'.! !!StringButtonMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change label' action: #setLabel.	aCustomMenu add: 'change action selector' action: #setActionSelector.	aCustomMenu add: 'change arguments' action: #setArguments.	aCustomMenu add: 'change when to act' action: #setActWhen.	((self world rootMorphsAt: aHandMorph targetOffset) size > 1) ifTrue: [		aCustomMenu add: 'set target' action: #setTarget:].! !!StringButtonMorph methodsFor: 'menu'!setActionSelector	| newSel |	newSel _ FillInTheBlank		request:'Please type the selector to be sent tothe target when this button is pressed'		initialAnswer: actionSelector.	newSel isEmpty ifFalse: [self actionSelector: newSel].! !!StringButtonMorph methodsFor: 'menu'!setActWhen	actWhen _ (SelectionMenu selections: #(buttonDown buttonUp whilePressed))		startUpWithCaption: 'Choose one of the following conditions'! !!StringButtonMorph methodsFor: 'menu'!setArguments	| s newArgs newArgsArray |	s _ WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs _ FillInTheBlank		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods'		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray _ Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!StringButtonMorph methodsFor: 'menu'!setLabel	| newLabel |	newLabel _ FillInTheBlank		request:'Please type a new label for this button'		initialAnswer: self contents.	newLabel isEmpty ifFalse: [self contents: newLabel].! !!StringButtonMorph methodsFor: 'menu'!setTarget: evt	| rootMorphs |	rootMorphs _ self world rootMorphsAt: evt hand targetOffset.	rootMorphs size > 1		ifTrue: [target _ rootMorphs at: 2]		ifFalse: [target _ nil. ^ self].! !!StringButtonMorph methodsFor: 'accessing'!actionSelector	^ actionSelector! !!StringButtonMorph methodsFor: 'accessing'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!StringButtonMorph methodsFor: 'accessing'!actWhen: aSymbol	"Set the condition under which to invoke my action to one of: #buttonDown, #buttonUp, and #whilePressed."	actWhen _ aSymbol.! !!StringButtonMorph methodsFor: 'accessing'!arguments	^ arguments! !!StringButtonMorph methodsFor: 'accessing'!arguments: aCollection	arguments _ aCollection asArray copy.! !!StringButtonMorph methodsFor: 'accessing'!target	^ target! !!StringButtonMorph methodsFor: 'accessing'!target: anObject	target _ anObject! !!StringButtonMorph methodsFor: 'events'!doButtonAction	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		Cursor normal showWhile: [			target perform: actionSelector withArguments: arguments]].! !!StringButtonMorph methodsFor: 'events'!handlesMouseDown: evt	^ true! !!StringButtonMorph methodsFor: 'events'!mouseDown: evt	oldColor _ color.	actWhen == #buttonDown		ifTrue: [self doButtonAction].! !!StringButtonMorph methodsFor: 'events'!mouseMove: evt	(self containsPoint: evt cursorPoint)		ifTrue: [			self color: (oldColor mixed: 1/2 with: Color white).			actWhen == #whilePressed ifTrue: [self doButtonAction]]		ifFalse: [self color: oldColor].! !!StringButtonMorph methodsFor: 'events'!mouseUp: evt	self color: oldColor.	(actWhen == #buttonUp and: [self containsPoint: evt cursorPoint])		ifTrue: [self doButtonAction].! !!StringButtonMorph methodsFor: 'copying' stamp: 'jm 7/28/97 11:55'!updateReferencesUsing: aDictionary	"If the arguments array points at a morph we are copying, then point at the new copy.  And also copies the array, which is important!!"	super updateReferencesUsing: aDictionary.	arguments _ arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !!StringHolderController methodsFor: 'menu messages' stamp: 'sw 8/1/97 16:46'!evaluateSelection	"Treat the current text selection as an expression; evaluate it.	If the left shift key is down, wait for mouse click, then restore the display"	| result saveBits |	self lineSelectAndEmptyCheck: [^ ''].	(saveBits _ sensor leftShiftDown)		ifTrue: [view topView deEmphasize; cacheBits].	result _ model doItReceiver class evaluatorClass new				evaluate: self selectionAsStream				in: model doItContext				to: model doItReceiver				notifying: self				ifFail: [self controlInitialize.						saveBits ifTrue: [view topView emphasize].						^ #failedDoit].	Smalltalk logChange: self selection string.	saveBits		ifTrue: [sensor waitClickButton. ScheduledControllers restore].	^result! !!StringHolderController methodsFor: 'menu messages' stamp: 'sw 9/27/96'!objectsReferencingIt	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  "	| result |	self controlTerminate.	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or:	 [result == #failedDoit]) ifFalse: [		Smalltalk			browseAllObjectReferencesTo: result			except: #()			ifNone: [:obj | view topView flash. self controlInitialize]].! !!StringHolderController class methodsFor: 'class initialization' stamp: 'sw 1/26/96'!initialize	"Initialize the yellow button pop-up menu and corresponding messages.	 1/12/96 sw: added senders of it, etc.  1/15/96 sw: explain	 1/22/96 sw: cmd keys detailed	 1/24/96 sw: added find; moved many items to shifted side etc.	 : made compatible with paragraph editor's version; I'm not clear on when/how this guy gets used (seemingly eg in a workspace) vs when the paragraph editor's does (seemingly in browsers)	 : correct cmd-key equivalent for do again, and add set-search-string"	CodeYellowButtonMenu _ 		PopUpMenu 			labels: 'find...(f)find again (g)set search string (h)do again (j)undo (z)copy (c)cut (x)paste (v)do it (d)print it (p)inspect it (i)accept (s)cancel (l)show bytecodesmore...' 		lines: #(3 5 8 11 13 14).	CodeYellowButtonMessages _ 		#(find findAgain setSearchString again undo copySelection cut paste doIt printIt inspectIt accept cancel showBytecodes shiftedYellowButtonActivity)	"StringHolderController initialize"! !!StringHolderView methodsFor: 'updating' stamp: 'di 11/4/97 20:11'!promptForCancel	"Ask if it is OK to cancel changes to text"	| okToCancel stripes |	self topView isCollapsed ifTrue:		[(self confirm: 'Changes have not been saved.Is it OK to cancel those changes?') ifTrue: [model unlock].		^ self].	stripes _ Form extent: 16@16 fromStipple: 16r36C9.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel _ self confirm: 'Changes have not been saved.Is it OK to cancel those changes?'.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel ifTrue:		[self updateDisplayContents.		model unlock]! !!StringMorph methodsFor: 'initialization'!initialize	super initialize.	color _ Color black.	font _ nil.	hasFocus _ false.	self contents: 'StringMorph'.! !!StringMorph methodsFor: 'initialization' stamp: '6/11/97 09:01 di'!initWithContents: aString font: aFont	super initialize.	color _ Color black.	font _ aFont.	hasFocus _ false.	self contents: aString.! !!StringMorph methodsFor: 'accessing'!contents	^ contents! !!StringMorph methodsFor: 'accessing'!contents: aString	contents = aString ifTrue: [^ self].  "no substantive change"	contents _ aString.	self fitContents.! !!StringMorph methodsFor: 'accessing'!contentsClipped: aString	"Change my text, but do not change my size as a result"	contents = aString ifTrue: [^ self].  "No substantive change"	contents _ aString.	self changed! !!StringMorph methodsFor: 'accessing' stamp: 'di 11/14/97 11:29'!fitContents	| scanner |	scanner _ QuickPrint newOn: Display box: Display boundingBox font: font.	self extent: (scanner stringWidth: contents) @ (scanner lineHeight).	self changed! !!StringMorph methodsFor: 'accessing' stamp: '6/7/97 09:57 di'!font: aFont	font _ aFont.	self fitContents."in inspector say,	 self font: ((TextStyle default fontAt: 2) emphasized: 1)"! !!StringMorph methodsFor: 'accessing'!setWidth: width	| f |	f _ font ifNil: [TextStyle default fontAt: 1].	self extent: width @ f height.! !!StringMorph methodsFor: 'drawing'!drawOn: aCanvas	hasFocus ifTrue: [aCanvas fillRectangle: self bounds color: Color yellow].	aCanvas text: contents bounds: bounds font: font color: color.! !!StringMorph methodsFor: 'editing'!acceptContents	"The message is sent when the user hits enter or Cmd-S. Accept the current contents and end editing. This default implementation does nothing."! !!StringMorph methodsFor: 'editing' stamp: 'sw 11/5/97 14:30'!handlesMouseDown: evt	^ (evt shiftPressed and: [owner wantsKeyboardFocusFor: self])		ifTrue: [self uncoveredAt: evt cursorPoint]		ifFalse: [super handlesMouseDown: evt].! !!StringMorph methodsFor: 'editing'!keyboardFocusChange: aBoolean	hasFocus _ aBoolean.	self changed.! !!StringMorph methodsFor: 'editing'!keyStroke: evt	"Handle a keystroke event."	| ch |	ch _ evt keyCharacter.	ch = Character backspace ifTrue: [  "backspace"		contents size > 0 ifTrue: [			self contents: (contents copyFrom: 1 to: contents size - 1)].		^ self].	(ch = $x and: [evt commandKeyPressed]) ifTrue: [  "cut"		Smalltalk clipboardText: contents.		^ self contents: ''].	(ch = $c and: [evt commandKeyPressed]) ifTrue: [  "copy"		Smalltalk clipboardText: contents.		^ self].	(ch = $v and: [evt commandKeyPressed]) ifTrue: [  "paste"		^ self contents: Smalltalk clipboardText].	((evt keyCharacter = Character enter) or:	 [(evt keyCharacter = Character cr) or:	 [evt keyCharacter = $s and: [evt commandKeyPressed]]]) ifTrue: [  "accept"		self acceptContents.		evt hand newKeyboardFocus: evt hand world.		^ self].	self contents: (contents copyWith: ch).  "append the character"! !!StringMorph methodsFor: 'editing'!mouseDown: evt	"If the shift key is pressed, make this string the keyboard input focus."	evt shiftPressed		ifTrue: [evt hand newKeyboardFocus: self]		ifFalse: [super mouseDown: evt].! !!StringMorph methodsFor: 'printing'!fullPrintOn: aStream	aStream nextPutAll: '('.	super fullPrintOn: aStream.	aStream nextPutAll: ') contents: '; print: contents! !!StringMorph methodsFor: 'printing' stamp: 'jm 11/3/97 16:52'!printOn: aStream	super printOn: aStream.	aStream print: contents.! !!StringMorph class methodsFor: 'instance creation' stamp: 'sw 8/22/97 22:19'!contents: aString	" 'StringMorph contents: str' is faster than 'StringMorph new contents: str' "	^ self contents: aString font: nil! !!StringMorph class methodsFor: 'instance creation' stamp: 'sw 8/22/97 22:19'!contents: aString font: aFont	^ self basicNew initWithContents: aString font: aFont! !!StringMorph class methodsFor: 'testing'!test	"Return a morph with lots of strings for testing display speed."	| c |	c _ LayoutMorph newColumn.	SystemOrganization categories do:		[:cat | c addMorph: (StringMorph new contents: cat)].	^ c! !!StringMorph class methodsFor: 'testing'!test2	"Return a morph with lots of strings for testing display speed."	| c r |	c _ LayoutMorph newColumn.	SystemOrganization categories reverseDo:		[:cat | c addMorph: (StringMorph new contents: cat)].	r _ RectangleMorph new extent: c fullBounds extent.	c submorphsDo: [:m | r addMorph: m].	^ r! !SwikiAction is the action to implement a Swiki, a collaborative website.See http://guzdial.cc.gatech.edu:8080/myswiki for an example focused ondiscussing Swikis.Swiki is based on the Wiki Server, designed and implemented by WardCunningham.  See the original Wiki at http://c2.com/cgi-bin/wiki, or theSqueak-focused one at http://c2.com:8080/!!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!map	"Answer the receiver's 'urlmap'."	^urlmap! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:23'!map: anObject	"Set the receiver's instance variable 'urlmap' to be anObject."	urlmap := anObject! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!name	"Answer the receiver's 'name'."	^name! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!name: anObject	"Set the receiver's instance variable 'name' to be anObject."	name := anObject! !!SwikiAction methodsFor: 'accessing' stamp: 'tk 1/15/98 13:38'!path	"A complete file path name to the directory where my page data is stored"	^ (ServerAction serverDirectory) , name, (ServerAction pathSeparator)! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!source	"Answer the receiver's 'source'."	^source! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!source: anObject	"Set the receiver's instance variable 'source' to be anObject."	source := anObject! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!urlmap	"Answer the receiver's 'urlmap'."	^urlmap! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!urlmap: anObject	"Set the receiver's instance variable 'urlmap' to be anObject."	urlmap := anObject! !!SwikiAction methodsFor: 'save and restore' stamp: 'mjg 12/23/97 09:32'!restoreFrom: filename	|f|	f _ ReferenceStream fileNamed: filename.	self map: f next.	self map action: self.	f close.! !!SwikiAction methodsFor: 'save and restore' stamp: 'mjg 11/28/97 10:33'!saveTo: filename	|f|	f _ ReferenceStream fileNamed: filename.	f nextPut: self map.	f close.! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 1/12/98 15:35'!log: request	| logfile |	logfile _ FileStream fileNamed: name , '-log.txt'.	logfile isNil		ifTrue: [request log: 'Failed logging on ' , name]		ifFalse:			[logfile setToEnd.			request peerName isNil			ifTrue: [logfile nextPutAll: 'UnknownPeer' , '-' ,				request url , '-' , Time now printString , '-' ,				Date today printString.]			ifFalse: [logfile nextPutAll: request peerName , '-' ,				request url , '-' , Time now printString , '-' ,				Date today printString.].			logfile nextPut: Character cr.			logfile close]! !!SwikiAction methodsFor: 'URL processing' stamp: 'tk 1/14/98 12:07'!process: request	"URLs are of the form:		{swikiname} to browse Front Page		{swikiname}.{coreID} to browse the page		{swikiname}.{coreID}.edit to edit the page	{swikiname}.{coreID}.all displays the page and all its references	{swikiname}.searchresult conducts the search and displays the result	{swikiname}.recent to bring up the recent changes list	{swikiname}.{coreID}.searchresult returns a search for references to coreID's key"	"Transcript show: 'Got request ',(request url); cr."	| coreRef pageRef command formattedPage theLast |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	request reply: PWS success; reply: PWS contentHTML.	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields isNil		ifFalse: ["Are there input fields?"			coreRef = 'searchresult'				ifTrue:					["If contains search string, do search"					request reply: (HTMLformatter evalEmbedded: (self fileContents: source, 'results.html')							with: (urlmap searchFor: (request fields at: 'searchFor' ifAbsent: ['nothing']))).					^ self]				ifFalse: ["It's a response from an edit, so store the page"					urlmap						storeID: coreRef						text: (request fields at: 'text' ifAbsent: ['blank text'])						from: request peerName]].	coreRef = 'recent' ifTrue:			[request reply: (HTMLformatter 					evalEmbedded: (self fileContents: source, 'recent.html')					with: urlmap recent).			^ self].	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 		ifTrue: ["SearchResult, All, or Edit"			command _ request message at: 3.			command = 'edit' ifTrue:					[request reply: (HTMLformatter evalEmbedded: (self fileContents: source , 'edit.html')							with: pageRef).					^ self].			command = 'searchresult' ifTrue:					[request reply: (HTMLformatter evalEmbedded: (self fileContents: source , 'results.html')							with: (urlmap searchFor: pageRef name)).					^ self].			command = 'all' ifTrue: 					[formattedPage _ urlmap allPagesFrom: pageRef for: request.					request reply: (HTMLformatter evalEmbedded: (self fileContents: source, 'page.html')							with: formattedPage).					^ self].			Transcript show: 'Unknown command: ', command; cr]		ifFalse: ["Just a browse"			formattedPage _ pageRef copy.			"Make a copy, then format the text."			formattedPage formatted: (HTMLformatter swikify: pageRef text					linkhandler: [:link | urlmap							linkFor: link							from: request peerName							storingTo: OrderedCollection new]).			request reply: (HTMLformatter evalEmbedded: (self fileContents: source ,'page.html')					with: formattedPage).			^ self]! !!SwikiAction methodsFor: 'URL processing' stamp: 'tk 1/14/98 13:01'!process: request MIMEtype: imageGif	"See if there is a .gif file on my disk of this name, and send it out."	| fName |	fName _ ServerAction serverDirectory, (request message at: 1), 		':', (request message at: 2).	3 to: request message size do: [:part |		fName _ fName, '.', (request message at: part)].	Transcript show: fName; cr.	(FileDirectory default fileExists: fName) 		ifTrue: [			request reply: (PWS success),(PWS content: imageGif).			request reply: (FileStream oldFileNamed: fName) contentsOfEntireFile]		ifFalse: [			request reply: ( 'HTTP/1.0 400 Bad Request', PWS crlfcrlf, 'file not found')].! !!SwikiAction methodsFor: 'URL processing' stamp: 'tk 1/14/98 11:58'!processGif: request	"See if there is a .gif file on my disk of this name, and send it out."	| fName |	fName _ ServerAction serverDirectory, (request message at: 1), 		':', (request message at: 2).	3 to: request message size do: [:part |		fName _ fName, '.', (request message at: part)].	Transcript show: fName; cr.	request reply: (PWS success),(PWS content: 'image/gif').	request reply: (FileStream oldFileNamed: fName) contentsOfEntireFile.! !!SwikiAction class methodsFor: 'initialization' stamp: 'mjg 12/23/97 09:35'!restore: actionName from: filename	"Set up a named Swiki"	| action |	action _ SwikiAction new.	action name: actionName.	action source: 'swiki:'.	action restoreFrom: filename.	action map pages do: [:each |		each file: (ServerAction serverDirectory),actionName,(ServerActionpathSeparator),			((each file findTokens: (ServerAction pathSeparator)) last)].	PWS link: actionName to: action.! !!SwikiAction class methodsFor: 'initialization' stamp: 'mjg 11/25/97 16:35'!setUp	self setUp: 'myswiki'! !!SwikiAction class methodsFor: 'initialization' stamp: 'mjg 1/12/98 12:15'!setUp: actionName	"Set up a named Swiki"	| action map page |	action _ SwikiAction new.	map _ URLmap new.	action map: map.	action name: actionName.	action source: 'swiki',(ServerAction pathSeparator).	map action: action.	map pages: (Dictionary new).	map directory: actionName. "I assume that you've created a directory inthe ServerDirectory for storing pages."	page _ map newpage: 'Front Page' from: 'Beginning'.	page text: (HTMLformatter evalEmbedded:			((FileStream fileNamed: (ServerAction serverDirectory),'swiki',				(ServerAction pathSeparator),'FrontPage') contentsOfEntireFile) with:actionName).	page _ map newpage: 'Formatting Rules' from: 'Beginning'.	page text: (HTMLformatter evalEmbedded:			((FileStream fileNamed: (ServerAction serverDirectory),'swiki',				(ServerAction pathSeparator),'FormattingRules') contentsOfEntireFile)with: actionName).	PWS link: actionName to: action.! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!address	"Answer the receiver's 'address'."	^address! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!address: anObject	"Set the receiver's instance variable 'address' to be anObject."	address := anObject! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!coreID	"Answer the receiver's 'coreID'."	^coreID! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!coreID: anObject	"Set the receiver's instance variable 'coreID' to be anObject."	coreID := anObject! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!date	"Answer the receiver's 'date'."	^date! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!date: anObject	"Set the receiver's instance variable 'date' to be anObject."	date := anObject! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!file	"Answer the receiver's 'file'."	^file! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!file: anObject	"Set the receiver's instance variable 'file' to be anObject."	file := anObject! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:01'!formatted	^formatted! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:01'!formatted: aString	"Never set this except on a copy"	formatted _ aString! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!map	"Answer the receiver's 'map'."	^map! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!map: anObject	"Set the receiver's instance variable 'map' to be anObject."	map := anObject! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!name	"Answer the receiver's 'name'."	^name! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!name: anObject	"Set the receiver's instance variable 'name' to be anObject."	name := anObject! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/24/97 16:03'!text	^(FileStream fileNamed: file) contentsOfEntireFile! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 1/13/98 17:22'!text: someText	| newfile |	newfile _ file allButLast, 		((file last asString asNumber + 1) printString last asString).	self file: newfile.	"since we can't shorten a file name, delete the old version of the new file."	FileDirectory deleteFilePath: file.	(FileStream newFileNamed: file) nextPutAll: someText; close.! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!url	"Answer the receiver's 'url'."	^url! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!url: anObject	"Set the receiver's instance variable 'url' to be anObject."	url := anObject! !!SwitchController methodsFor: 'basic control sequence' stamp: 'di 7/13/97 11:16'!sendMessage	"The receiver consists of a selector and possibly of arguments that should 	be used to create a message to send to the receiver's model."	arguments size = 0		ifTrue: [model perform: selector]		ifFalse: [model perform: selector withArguments: arguments]! !!SwitchView methodsFor: 'label access'!centerLabel	"Align the center of the label with the center of the receiver's window."	label == nil  ifFalse: 		[(label isKindOf: Paragraph)			ifTrue: ["Compensate for leading in default style"					label align: label boundingBox center + (0@1)							with: self getWindow center]			ifFalse: [label align: label boundingBox center 							with: self getWindow center]]! !!SwitchView methodsFor: 'selector' stamp: 'di 7/13/97 11:17'!interrogateModel	"Answer the result of sending the receiver's model the message created 	from the receiver's selector and arguments."	arguments size = 0		ifTrue: [^ model perform: selector]		ifFalse: [^ model perform: selector withArguments: arguments]! !!Symbol methodsFor: 'comparing' stamp: 'pm 9/23/97 09:36'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^map newHashFor: self! !!Symbol methodsFor: 'system primitives' stamp: 'ikp 1/1/98 00:00'!flushCache	"Tell the interpreter to remove all entries with this symbol as a selector in its method lookup cache, if it has one.  This primitive must be called whenever a method is redefined.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 119>	Object flushCache.	"<primitive: 89>"	"self primitiveFailed"! !!Symbol methodsFor: 'menus' stamp: 'jm 11/4/97 07:15'!dispatchAsMenuActionTo: receiver with: argument	^self numArgs = 0		ifTrue: [receiver perform: self]		ifFalse: [receiver perform: self with: argument]! !!Symbol class methodsFor: 'instance creation'!intern: aString 	"Answer a unique Symbol whose characters are those of aString."	| ascii table mainTable index sym numArgs |	ascii _ (aString at: 1) asciiValue.	aString size = 1 ifTrue: [ascii < 128 ifTrue: 		[^ SingleCharSymbols at: ascii + 1]].	table _ ((ascii >= "$a asciiValue" 97) and:		[(ascii <= "$z asciiValue" 122) and:		[(numArgs _ aString numArgs) >= 0]])			ifTrue: [(mainTable _ SelectorTables									at: (numArgs + 1 min: SelectorTables size))						at: (index _ ascii - "($a asciiValue - 1)" 96)]			ifFalse: [(mainTable _ OtherTable)						at: (index _ aString stringhash \\ OtherTable size + 1)].	1 to: table size do: [:i |		aString size = (table at: i) size ifTrue: [aString = (table at: i) ifTrue: [^ table at: i]]	].	sym _ (aString isMemberOf: Symbol)		ifTrue: [aString]	"putting old symbol in new table"		ifFalse: [(Symbol new: aString size) string: aString]. "create a new one"	mainTable at: index put: (table copyWith: sym).	^sym! !!Symbol class methodsFor: 'private'!hasInterned: aString ifTrue: symBlock 	"Answer with false if aString hasnt been interned (into a Symbol), 	otherwise supply the symbol to symBlock and return true."	| table ascii numArgs |	ascii _ (aString at: 1) asciiValue.	aString size = 1 ifTrue: [ascii < 128 ifTrue: 		[symBlock value: (SingleCharSymbols at: ascii + 1).		^true]].	table _ ((ascii >= "$a asciiValue" 97) and:		[(ascii <= "$z asciiValue" 122) and:		[(numArgs _ aString numArgs) >= 0]])			ifTrue: [(SelectorTables at: (numArgs + 1 min: SelectorTables size))						at: ascii - "($a asciiValue - 1)" 96]			ifFalse: [OtherTable at: aString stringhash \\ OtherTable size + 1].	1 to: table size do: [:i | 		aString size = (table at: i) size ifTrue: [aString = (table at: i) ifTrue: [			symBlock value: (table at: i).			^true]]	].	^false! !!SyntaxError methodsFor: 'menu messages'!autoProceed	| someView |	someView _ self dependents first.	self proceed: someView topView controller! !!SyntaxError methodsFor: 'menu messages' stamp: 'tk 12/29/97 21:39'!debugger	^ debugger! !!SyntaxError methodsFor: 'menu messages'!proceed: aController 	"The error has presumably been fixed and the file in that created the 	syntax error can now be continued."	debugger proceed: aController! !!SyntaxError methodsFor: 'contents'!contents: aString notifying: aController 	"Compile the code in aString and notify aController of any errors.	If there are no errors, then automatically proceed."	(class compile: aString classified: category notifying: aController)		 == nil ifTrue: [^ false].	self autoProceed! !!SyntaxError methodsFor: 'contents' stamp: 'tk 1/16/98 16:53'!wantsBoldSelector	"In code pane?  Only when a message selected"	^ self messageListIndex ~= 0! !!SyntaxError class methodsFor: 'instance creation'!errorInClass: aClass withCode: aString 	"Answer a standard system view whose model is an instance of me. The syntax error occurred in typing to add code, aString, to class, aClass. "	self open: (self new setClass: aClass						code: aString						debugger: (Debugger context: thisContext))! !!SyntaxError class methodsFor: 'instance creation' stamp: 'sw 11/2/97 21:39'!open: aSyntaxError	"Answer a standard system view whose model is an instance of me.  TK 15 May 96"	|  topView aListView aCodeView |	topView _ StandardSystemView new.	topView model: aSyntaxError.	topView label: 'Syntax Error'.	topView minimumSize: 380 @ 220.	aListView _ SyntaxErrorListView new.	aListView model: aSyntaxError.	aListView window: (0 @ 0 extent: 380 @ 20).	aListView		borderWidthLeft: 2		right: 2		top: 2		bottom: 0.	topView addSubView: aListView.	aCodeView _ BrowserCodeView new.	aCodeView model: aSyntaxError.	aCodeView window: (0 @ 0 extent: 380 @ 200).	aCodeView		borderWidthLeft: 2		right: 2		top: 2		bottom: 2.	topView		addSubView: aCodeView		align: aCodeView viewport topLeft		with: aListView viewport bottomLeft.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor activeProcess suspend! !!SyntaxErrorListController methodsFor: 'menu messages' stamp: 'tk 12/29/97 21:33'!debug	"Show the stack of how we got to this syntax editor -- Compiler called from FileIn, etc.."	self controlTerminate.	DebuggerView openDebugger: model debugger label: 'Stack of the Syntax Error' .	self controlInitialize! !!SyntaxErrorListController class methodsFor: 'class initialization' stamp: 'tk 12/29/97 21:28'!initialize	SyntaxErrorListYellowButtonMenu _ PopUpMenu 		labels: 'proceed\debugger on calling process' withCRs.	SyntaxErrorListYellowButtonMessages _ #(proceed debug)	"SyntaxErrorListController initialize"! !!SystemCategoryListController methodsFor: 'menu messages'!browseAllClasses	"Create and schedule a browser on all classes alphabetically."	self controlTerminate.	model browseAllClasses.	self controlInitialize! !!SystemCategoryListController methodsFor: 'menu messages' stamp: 'sw 4/29/96'!findClass	"modified  so that if only 1 class matches the user-supplied string, or if the user-supplied string exactly matches a class name, then the pop-up menu is bypassed"	| pattern foundClass classNames index reply |	self controlTerminate.	model okToChange ifFalse: [^ self classNotFound].	pattern _ (reply _ FillInTheBlank request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self classNotFound].	(Smalltalk hasClassNamed: reply)		ifTrue:			[foundClass _ Smalltalk at: reply asSymbol]		ifFalse: 			[classNames _ Smalltalk classNames asArray select: 				[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].			classNames isEmpty ifTrue: [^ self classNotFound].			index _ classNames size == 1				ifTrue:	[1]				ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].			index = 0 ifTrue: [^ self classNotFound].			foundClass _ Smalltalk at: (classNames at: index)]. 	model systemCategoryListIndex: (model systemCategoryList indexOf: foundClass category).	model classListIndex: (model classList indexOf: foundClass name). 	self controlInitialize! !!SystemCategoryListController methodsFor: 'menu messages'!findRecentClass        "Put up a list of recently visited classes and allow the user to select one."        self controlTerminate.        model recent.        self controlInitialize! !!SystemCategoryListController methodsFor: 'menu messages' stamp: 'di 6/28/97 19:03'!printOut	"Make a file with the description of the classes in the selected category.	Defaults to the same file as fileOut, but could be changed in any given	implementation to have a prettier format."	self controlTerminate.	Cursor write showWhile:		[model printOutSystemCategories].	self controlInitialize! !!SystemCategoryListController class methodsFor: 'class initialization'!initialize	"SystemCategoryListController initialize"	SystemCategoryListYellowButtonMenu _ 		PopUpMenu 			labels:'find class...recent classes...browse allbrowseprintOutfileOutreorganizeupdateadd item...rename...remove' 			lines: #(2 4 6 8).	SystemCategoryListYellowButtonMessages _		#(findClass findRecentClass browseAllClasses browse		printOut fileOut		edit update		add rename remove )	"	SystemCategoryListController initialize.	SystemCategoryListController allInstancesDo:		[:x | x initializeYellowButtonMenu]	"! !!SystemDictionary methodsFor: 'browsing' stamp: 'di 9/5/97 16:05'!browseAllCallsOn: aLiteral 	"Create and schedule a message browser on each method that refers to	aLiteral. For example, Smalltalk browseAllCallsOn: #open:label:."	(aLiteral isKindOf: LookupKey)		ifTrue: [self browseMessageList: (self allCallsOn: aLiteral) asSortedCollection					name: 'Users of ' , aLiteral key					autoSelect: aLiteral key]		ifFalse: [self browseMessageList: (self allCallsOn: aLiteral) asSortedCollection					name: 'Senders of ' , aLiteral					autoSelect: aLiteral keywords first]! !!SystemDictionary methodsFor: 'browsing' stamp: 'sw 9/27/96'!browseAllObjectReferencesTo: anObject except: objectsToExclude ifNone: aBlock	"Bring up a list inspector on the objects that point to anObject. If there are none, then evaluate aBlock on anObject.  "	| aList shortName |	aList _ Smalltalk pointersTo: anObject except: objectsToExclude.	aList size > 0 ifFalse: [^ aBlock value: anObject].	shortName _ anObject name.	shortName size > 12 ifTrue: [		shortName _ (shortName truncateTo: 12), '...'.	].	InspectorView		open: (InspectorView inspector: (OrderedCollectionInspector inspect: aList))		withLabel: 'Objects pointing to ', shortName.! !!SystemDictionary methodsFor: 'browsing' stamp: 'sw 8/15/97 15:32'!browseAllSelect: aBlock name: aName autoSelect: autoSelectString	"Create and schedule a message browser on each method that, when used 	as the block argument to aBlock gives a true result.   Do not return an #DoIt traces."	"Smalltalk browseAllSelect: [:method | method numLiterals > 10] name: 'Methods with more than 10 literals' autoSelect: 'isDigit'"	^ self browseMessageList: (self allSelectNoDoits: aBlock) name: aName autoSelect: autoSelectString! !!SystemDictionary methodsFor: 'browsing'!browseChangedMessages	"Create and schedule a message browser on each method that has been 	changed."	ChangedMessageSet openFor: SystemChanges! !!SystemDictionary methodsFor: 'browsing'!browseMethodsWithSourceString: aString	"Smalltalk browseMethodsWithSourceString: 'SourceString' "	"Launch a browser on all methods whose source code contains aString as a substring.  The search is case-sensitive. This takes a long time right now.  7/23/96 di	 1/16/97 sw: set up the autoSelect: string"	^ self browseMessageList: (self allMethodsWithSourceString: aString)		name: 'Methods containing ' , aString printString autoSelect: aString! !!SystemDictionary methodsFor: 'browsing' stamp: 'sw 8/15/97 13:56'!browseMethodsWithString: aString	"Launch a browser on all methods which contain string literals that have aString as a substring.  The search is case-sensitive, unless the option key is pressed, in which case the search is case-insensitive (and consequently somewhat slower)"	| caseBlind testString suffix |	(caseBlind _ Sensor optionKeyPressed)		ifTrue:			[testString _ aString asLowercase.			suffix _ ' (case-blind)']		ifFalse:			[testString _ aString.			suffix _ '-'].	self browseAllSelect:		[:method |  method  hasLiteralSuchThat:				[:lit | lit class == String and:					[lit includesSubstring: testString caseSensitive: caseBlind not]]]				name:  'Methods with string ''', aString, '''', suffix				autoSelect: aString! !!SystemDictionary methodsFor: 'retrieving' stamp: 'di 9/5/97 16:22'!allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."	"Answer a Collection of all the methods that call on aLiteral."	| aCollection special thorough aList |	#(23 48 'fred' (new open:label:)) size.    "For testing!!"	aCollection _ OrderedCollection new.	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:byte ].	thorough _ (aLiteral isMemberOf: Symbol)				and: ["Possibly search for symbols imbedded in literal arrays"					Preferences thoroughSenders].	Cursor wait showWhile: 		[self allBehaviorsDo: 			[:class |				aList _ thorough					ifTrue:			 			[(class thoroughWhichSelectorsReferTo: aLiteral special: special byte: byte)]					ifFalse:						[class whichSelectorsReferTo: aLiteral special: special byte: byte].				aList do: 					[:sel | sel ~~ #DoIt						ifTrue: [aCollection add: class name , ' ' , sel]]]].	^ aCollection! !!SystemDictionary methodsFor: 'retrieving' stamp: 'sw 8/12/97 20:57'!allMethodsWithString: aString 	"Answer a SortedCollection of all the methods that contain, in a string literal, aString as a substring.  2/1/96 sw.  The search is case-sensitive, and does not dive into complex literals, confining itself to string constants.	5/2/96 sw: fixed so that duplicate occurrences of aString in the same method don't result in duplicated entries in the browser"	| aStringSize list lits |	aStringSize _ aString size.	list _ Set new.	Cursor wait showWhile: [self allBehaviorsDo: 		[:class | class selectorsDo:			[:sel | sel ~~ #DoIt ifTrue:				[lits _ (class compiledMethodAt: sel) literals.				lits do:					[:aLiteral | ((aLiteral isMemberOf: String) and:						[aLiteral size >= aStringSize])							ifTrue:								[(aLiteral findString: aString startingAt: 1)  > 0 ifTrue:									[list add: class name , ' ' , sel]]]]]]].	^ list asSortedCollection! !!SystemDictionary methodsFor: 'retrieving' stamp: 'sw 8/15/97 15:31'!allSelectNoDoits: aBlock 	"Like allSelect:, but strip out Doits"	| aCollection |	aCollection _ SortedCollection new.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:class | class selectorsDo: 				[:sel | ((sel ~~ #DoIt) and: [(aBlock value: (class compiledMethodAt: sel))])					ifTrue: [aCollection add: class name , ' ' , sel]]]].	^aCollection! !!SystemDictionary methodsFor: 'retrieving' stamp: 'di 11/4/97 20:11'!allSentMessages	"Answer the set of selectors which are sent somewhere in the system."	| sent |	sent _ Set new.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:cl | cl selectorsDo: 				[:sel | "Include all sels, but not if sent by self"			(cl compiledMethodAt: sel) literals do: 				[:m | 				(m isMemberOf: Symbol) ifTrue:  "might be sent"					[m == sel ifFalse: [sent add: m]].				(m isMemberOf: Array) ifTrue:  "might be performed"					[m do: [:x | (x isMemberOf: Symbol) ifTrue:						[x == sel ifFalse: [sent add: x]]]]]]].		"The following may be sent without being in any literal frame"		1 to: self specialSelectorSize do: 			[:index | 			sent add: (self specialSelectorAt: index)]].	^ sent! !!SystemDictionary methodsFor: 'retrieving'!allUnSentMessages   "Smalltalk allUnSentMessages"	"Answer the set of selectors that are implemented by some object	in the system but not sent by any."	| sent unsent |	sent _ self allSentMessages.	unsent _ Set new.	self allImplementedMessages do:		[:sel | (sent includes: sel) ifFalse: [unsent add: sel]].	^ unsent" | f cl lastClass |f _ FileStream newFileNamed: 'UnsentMessages.txt'.lastClass _ 'xx'.methods _ SortedCollection new.Smalltalk allUnSentMessages do:	[:sel | methods addAll: (Smalltalk allImplementorsOf: sel)].methods do:	[:m | cl _ m copyUpTo: $ . 	cl = lastClass		ifTrue: [f nextPutAll: (m copyFrom: lastClass size+1 to: m size)]		ifFalse: [f cr; cr; nextPutAll: m.  lastClass _ cl]].f close."! !!SystemDictionary methodsFor: 'retrieving' stamp: 'sw 5/8/96'!allUnSentMessagesIn: selectorSet	"Answer the subset of selectorSet which are not sent anywhere in the system.	Factored out from#allUnSentMessages "	|  all |	all _ selectorSet copy.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:cl | cl selectorsDo: 				[:sel | 				(cl compiledMethodAt: sel) literals do: 					[:m |					(m isMemberOf: Symbol)  "might be sent"						ifTrue: [all remove: m ifAbsent: []].					(m isMemberOf: Array)  "might be performed"						ifTrue: [m do: [:x | all remove: x ifAbsent: []]].					]]].		"The following may be sent without being in any literal frame"		1 to: self specialSelectorSize do: 			[:index | 			all remove: (self specialSelectorAt: index) ifAbsent: []]].	^ all! !!SystemDictionary methodsFor: 'retrieving'!pointersTo: anObject	"Find all occurrences in the system of pointers to the argument anObject."	"(Smalltalk pointersTo: Browser) inspect."	^ self pointersTo: anObject except: #()! !!SystemDictionary methodsFor: 'retrieving'!pointersTo: anObject except: objectsToExclude	"Find all occurrences in the system of pointers to the argument anObject. Remove objects in the exclusion list from the results."	| results anObj |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	results _ OrderedCollection new: 1000.	"allObjectsDo: is expanded inline to keep spurious	 method and block contexts out of the results"	anObj _ self someObject.	[0 == anObj] whileFalse: [		(anObj pointsTo: anObject) ifTrue: [			"exclude the results collector and contexts in call chain"			((anObj ~~ results collector) and:			 [(anObj ~~ objectsToExclude) and:			 [(anObj ~~ thisContext) and:			 [(anObj ~~ thisContext sender) and:			 [anObj ~~ thisContext sender sender]]]])				 ifTrue: [ results add: anObj ].		].		anObj _ anObj nextObject.	].	objectsToExclude do: [ :obj | results removeAllSuchThat: [ :el | el == obj]].	^ results asArray! !!SystemDictionary methodsFor: 'retrieving'!pointersToItem: index of: anArray	"Find all occurrences in the system of pointers to the given element of the given array. This is useful for tracing up a pointer chain from an inspector on the results of a previous call of pointersTo:. To find out who points to the second element of the results, one would evaluate:	Smalltalk pointersToItem: 2 of: selfin the inspector."	^ self pointersTo: (anArray at: index) except: (Array with: anArray)! !!SystemDictionary methodsFor: 'class names' stamp: 'sw 9/17/97 20:50'!removeClassFromSystem: aClass	"Delete the class, aClass, from the system."	SystemChanges noteRemovalOf: aClass.	aClass acceptsLoggingOfCompilation ifTrue:		[Smalltalk logChange:  'Smalltalk removeClassNamed: #', aClass name].	SystemOrganization removeElement: aClass name.	self removeKey: aClass name.	self flushClassNameCache! !!SystemDictionary methodsFor: 'class names' stamp: 'sw 9/5/97 18:30'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'class names' stamp: 'sw 10/28/96'!renameClassNamed: oldName as: newName	"Invoked from fileouts:  if there is currently a class in the system named oldName, then rename it to newName.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: oldName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Class-rename for ', oldName, ' ignored because ', oldName, ' does not exist.'.			^ self].	oldClass rename: newName! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 11/4/97 20:11'!abandonSources    "Smalltalk abandonSources"	"Replaces every method by a copy with the 4-byte source pointer 	replaced by a string of all arg and temp names, followed by its length.	These names can then be used to inform the decompiler.  See stats below"	 | oldCodeString argsAndTemps bTotal bCount oldMethods newMethods m |	(self confirm:  '-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning source code files, hit Yes.If you have any doubts, hit No,to back out with no harm done.')		==  true ifFalse: [^ self inform: 'Okay - no harm done'].	Smalltalk forgetDoIts.	oldMethods _ OrderedCollection new: CompiledMethod instanceCount.	newMethods _ OrderedCollection new: CompiledMethod instanceCount.	bTotal _ 0.  bCount _ 0.	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].'Saving temp names for better decompilation...'	displayProgressAt: Sensor cursorPoint	from: 0 to: bTotal	during: [:bar |	Smalltalk allBehaviorsDo:    "for test:  (Array with: Arc with: Arc class) do: "		[:cl |  bar value: (bCount _ bCount + 1).		cl selectors do:			[:selector |			m _ cl compiledMethodAt: selector.			m fileIndex > 0 ifTrue:			[oldCodeString _ cl sourceCodeAt: selector.			argsAndTemps _ (cl compilerClass new				parse: oldCodeString in: cl notifying: nil)				tempNames.			oldMethods addLast: m.			newMethods addLast: (m copyWithTempNames: argsAndTemps)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	Smalltalk condenseChanges.	Smalltalk allBehaviorsDo: [: b | b zapOrganization]."In a system with 7780 methods, we got 83k of temp names, or around 100k with spaces between.  The order of letter frequency was eatrnoislcmdgpSub, with about 60k falling in the first 11.  This suggests that we could encode in 4 bits, with 0-11 beng most common chars, and 12-15 contributing 2 bits to the next nibble for 6 bits, enough to cover all alphaNumeric with upper and lower case.  If we get 3/4 in 4 bits and 1/4 in 8, then we get 5 bits per char, or about 38% savings (=38k in this case).Summary: about 13 bytes of temp names per method, or 8 with simple compression, plus 1 for the size.  This would be 5 bytes more than the current 4-byte trailer."! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/24/97 11:42'!lastRemoval  "Smalltalk lastRemoval"	#(abandonSources printSpaceAnalysis cleanOutUndeclared browseObsoleteReferences obsoleteClasses lastRemoval) do:		[:sel | SystemDictionary removeSelector: sel].	[self removeAllUnSentMessages > 0] whileTrue! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 11/25/97 13:34'!majorShrink    "Smalltalk majorShrink; abandonSources; lastRemoval"	"This method throws out lots of the system that is not needed for, eg, operation in a hand-held PC.  The shrink process is being improved and, in conjunction with removeAllUnSentMessages, yields an image around 600k in size."	"Remove references to a few classes to be deleted, so that they won't leave obsolete versions around."	FormView compile: 'defaultControllerClass 	^  NoController' classified: 'controller access'.	FileModel removeSelector: #fileIntoNewChangeSet.	Form removeSelector: #edit.	ChangeSet class compile: 'defaultName		^ ''Changes'' ' classified: 'initialization'.	ScreenController removeSelector: #openChangeManager.	ScreenController removeSelector: #exitProject.	ScreenController removeSelector: #openProject.	ScreenController removeSelector: #viewGIFImports.	"Now delete lots of classes.."	(Smalltalk includesKey: #CCodeGenerator) ifTrue:		[(Smalltalk at: #CCodeGenerator) removeCompilerMethods].	SystemOrganization removeSystemCategory: 'Squeak Interpreter'.	SystemOrganization removeSystemCategory: 'Translation to C'.	(SystemOrganization categories select: [:c | 'Morphic*' match: c]) reverseDo:		[:c | SystemOrganization removeSystemCategory: c].	SystemOrganization removeSystemCategory: 'System-Network'.	SystemOrganization removeSystemCategory: 'System-Monitoring'.	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	SystemOrganization removeSystemCategory: 'Graphics-Files'.	SystemOrganization removeSystemCategory: 'Interface-Pluggable'.	SystemOrganization removeSystemCategory: 'Interface-Projects'.	SystemOrganization removeSystemCategory: 'Object Storage'.	SystemOrganization removeSystemCategory: 'System-Sound'.	FormEditor removeFromSystem.	FormEditorView removeFromSystem.	FormMenuView removeFromSystem.	FormMenuController removeFromSystem.	FormButtonCache removeFromSystem.	CurveFitter removeFromSystem.	LinearFit removeFromSystem.	Spline removeFromSystem.	Circle removeFromSystem.	Arc removeFromSystem.	FormSetFont removeFromSystem.	FontSet removeFromSystem.	InstructionPrinter removeFromSystem.	SharedQueue removeFromSystem.	TextLinkToImplementors removeFromSystem.	ParagraphEditor removeSelector: #recognizeCharacters.	ParagraphEditor removeSelector: #recognizer:.	ParagraphEditor removeSelector: #recognizeCharactersWhileMouseIn:.	CharRecog removeFromSystem.	Array2D removeFromSystem.	FFT removeFromSystem.	ChangeSorter removeFromSystem.	DualChangeSorter removeFromSystem.	CngsClassList removeFromSystem.	CngsMsgList removeFromSystem.	TriggerController removeFromSystem.	MessageTally removeFromSystem.	BitEditor removeFromSystem.	StringHolder class removeSelector: #originalWorkspaceContents.	CompiledMethod removeSelector: #symbolic.	StringHolder systemWorkspaceContents: ''.	TextConstants removeKey: #ClairVaux.  "Gets rid of a couple of fonts"	FormHolderView removeFromSystem.	FormInspectView removeFromSystem.	GeneralListView removeFromSystem.	GeneralListController removeFromSystem.	HierarchicalMenu removeFromSystem.	EmphasizedMenu removeFromSystem.	ObjectViewer removeFromSystem.	ObjectTracer removeFromSystem.	HtmlFileStream removeFromSystem.	ConciseInspector removeFromSystem.	TextStyle allInstancesDo:		[:ts | (ts instVarAt: 1) size > 2 ifTrue:  "Only need two fonts"			[ts instVarAt: 1 put: ((ts instVarAt: 1) copyFrom: 1 to: 2)]].	ListParagraph initialize.	PopUpMenu initialize.	StandardSystemView initialize.	Smalltalk noChanges.	ChangeSorter classPool at: #AllChangeSets put: (OrderedCollection with: Smalltalk changes).	[self removeAllUnSentMessages > 0] whileTrue.	Smalltalk allClassesDo: [:c | c zapOrganization].	Symbol rehash.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 1/13/98 23:31'!minorShrink	"This method throws out lots of the system that is not needed, although not quite as much as majorShrink. In particular, it retains Morphic, Sound, graphics file readers, and the networking classes."	"Smalltalk minorShrink"	(Smalltalk includesKey: #CCodeGenerator) ifTrue:		[(Smalltalk at: #CCodeGenerator) removeCompilerMethods].	SystemOrganization removeCategoriesMatching: 'Squeak-*'.	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	SystemOrganization removeSystemCategory: 'Interface-Pluggable'.	Form removeSelector: #edit.	Form removeSelector: #bitEdit.	Form removeSelector: #bitEditAt:scale:.	StrikeFont removeSelector: #edit:.	Dictionary removeSelector: #inspectFormsWithLabel:.	InspectorView class removeSelector: #buildFormView:.	InspectorView class removeSelector: #formDictionaryInspector:.	Object removeSelector: #evaluate:wheneverChangeIn:.	SystemDictionary removeSelector: #viewGIFImports.	ScreenController removeSelector: #viewGIFImports.	FormEditor removeSelector: #curve.	CurveFitter removeFromSystem.	LinearFit removeFromSystem.	Spline removeFromSystem.	FormView compile: 'defaultControllerClass 	^  NoController' classified: 'controller access'.	Form removeSelector: #edit.	FormEditor removeFromSystem.	FormEditorView removeFromSystem.	FormMenuView removeFromSystem.	FormMenuController removeFromSystem.	FormButtonCache removeFromSystem.	BitEditor removeFromSystem.	FormHolderView removeFromSystem.	FormInspectView removeFromSystem.	ParagraphEditor removeSelector: #recognizeCharacters.	ParagraphEditor removeSelector: #recognizer:.	ParagraphEditor removeSelector: #recognizeCharactersWhileMouseIn:.	CharRecog removeFromSystem.	Array2D removeFromSystem.	FFT removeFromSystem.	HierarchicalMenu removeFromSystem.	ObjectViewer removeFromSystem.	ObjectTracer removeFromSystem.	StandardFileStream removeSelector: #asHtml.	HtmlFileStream removeFromSystem.	ConciseInspector removeFromSystem.	Smalltalk removeEmptyMessageCategories.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	"remove shrink methods"	SystemDictionary removeSelector: #majorShrink.	SystemDictionary removeSelector: #minorShrink.	Smalltalk noChanges.	ChangeSorter classPool at: #AllChangeSets put: (OrderedCollection with: Smalltalk changes).	Symbol rehash.! !!SystemDictionary methodsFor: 'shrinking'!printSpaceAnalysis	"Smalltalk garbageCollect; printSpaceAnalysis"	"Note: this all needs to be updated for 32-bit direct pointers"	| f name space scale count instSpace |	f _ FileStream newFileNamed: 'STspace.text'.	f timeStamp.	f nextPutAll: 'class'; tab;			nextPutAll: 'space'; tab;			nextPutAll: '#insts'; tab;			nextPutAll: 'inst space'; tab.	self allClassesDo:		[:cl | name _ cl name forceTo: 30 paddingWith: Character space.		space _ cl space.		count _ cl instanceCount.		instSpace _ (cl instSize+4)*count.		cl isVariable ifTrue:				[scale _ cl isBytes ifTrue: [4] ifFalse: [1].				cl allInstancesDo: [:x | instSpace _ instSpace + (x size//scale)]].		f nextPutAll: name; tab;			print: space; tab;			print: count; tab;			print: instSpace; cr].	f close! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 10/3/97 11:13'!removeAllUnSentMessages   "Smalltalk removeAllUnSentMessages" 	"Remove all implementations of unsent messages."	| sels n |	sels _ self allUnSentMessages.	"The following should be preserved for doIts, etc"	#(dragon: hilberts: mandala: web test3 factorial benchmark benchFib		newDepth: restoreAfter: forgetDoIts		removeAllUnSentMessages abandonSources removeUnreferencedKeys		reclaimDependents zapOrganization condenseChanges browseObsoleteReferences		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:		startTimerInterruptWatcher) do:		[:sel | sels remove: sel ifAbsent: []].	"The following may be sent by perform: in dispatchOnChar..."	(ParagraphEditor classPool at: #CmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	(ParagraphEditor classPool at: #ShiftCmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	sels size = 0 ifTrue: [^ 0].	n _ 0. Smalltalk allBehaviorsDo: [:x | n _ n+1].	'Removing ', sels size printString , ' messages . . .'		displayProgressAt: Sensor cursorPoint		from: 0 to: n		during:		[:bar |		n _ 0.		self allBehaviorsDo:			[:class | bar value: (n _ n+1).			sels do:				[:sel | class removeSelectorSimply: sel]]].	MethodDictionary allInstancesDo: [:d | d rehash].	^ sels size! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 1/15/98 10:44'!lowSpaceThreshold	"Return the low space threshold. When the amount of free memory (after garbage collection) falls below this limit, the system is in serious danger of completely exhausting memory and crashing. This limit should be made high enough to allow the user open a debugger to diagnose a problem or to save the image."	thisContext isPseudoContext		ifTrue: [^ 300000  "Allow for translated methods"]		ifFalse: [^  80000  "Enough for interpreter"]! !!SystemDictionary methodsFor: 'memory space'!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [		self garbageCollect <= self lowSpaceThreshold ifTrue: [			"free space must be above threshold before starting low space watcher"			^ self beep]].	LowSpaceSemaphore _ Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess _ nil.	"Note: user now unprotected until the low space watcher is re-installed"	ScheduledControllers interruptName: 'Space is low'.! !!SystemDictionary methodsFor: 'memory space'!okayToProceedEvenIfSpaceIsLow	"Return true if either there is enough memory to do so safely or if the user gives permission after being given fair warning."	self garbageCollectMost > self lowSpaceThreshold ifTrue: [^ true].  "quick"	self garbageCollect > self lowSpaceThreshold ifTrue: [^ true].  "work harder"	^ self confirm:'WARNING: There is not enough space to start the low space watcher.If you proceed, you will not be warned again, and the system mayrun out of memory and crash. If you do proceed, you can start thelow space notifier when more space becomes available simply byopening and then closing a debugger (e.g., by hitting Cmd-period.)Do you want to proceed?'! !!SystemDictionary methodsFor: 'memory space'!signalLowSpace	"Signal the low-space semaphore to alert the user that space is running low."	LowSpaceSemaphore signal.! !!SystemDictionary methodsFor: 'memory space'!useUpMemory	"For testing the low space handler..."	"Smalltalk installLowSpaceWatcher; useUpMemory"	| lst |	lst _ nil.	[true] whileTrue: [		lst _ Link new nextLink: lst; yourself.	].! !!SystemDictionary methodsFor: 'special objects' stamp: 'jm 9/11/97 11:36'!clearExternalObjects	"Clear the array of objects that have been registered for use in non-Smalltalk code."	"Smalltalk clearExternalObjects"	Smalltalk specialObjectsArray at: 39 put: Array new.! !!SystemDictionary methodsFor: 'special objects' stamp: 'jm 9/15/97 16:09'!externalObjects	"Return an array of objects that have been registered for use in non-Smalltalk code. Smalltalk objects should be referrenced by external code only via indirection through this array, thus allowing the objects to move during compaction. This array can be cleared when the VM re-starts, since variables in external code do not survive snapshots. Note that external code should not attempt to access a Smalltalk object, even via this mechanism, while garbage collection is in progress."	"Smalltalk externalObjects"	^ Smalltalk specialObjectsArray at: 39! !!SystemDictionary methodsFor: 'special objects' stamp: 'ikp 1/1/98 23:43'!recreateSpecialObjectsArray    "Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used by the	Smalltalk virtual machine.  Its contents are critical and unchecked,	so don't even think of playing here unless you know what you are doing."	| newArray smallFrameSize largeFrameSize |	newArray _ Array new: 41.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (Smalltalk associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: String.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk. 	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18)  "(low space Semaphore)".	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil.  "*unused*"	"An array of the 32 selectors that are compiled as special bytecodes,	paired alternately with the number of arguments each takes."	newArray at: 24 put: #(+ 1 - 1 < 1 > 1 <= 1 >= 1 = 1 ~= 1 * 1 / 1 \\ 1 @ 1 bitShift: 1 // 1 bitAnd: 1 bitOr: 1 at: 1 at:put: 2 size 0 next 0 nextPut: 1 atEnd 0 == 1 class 0 blockCopy: 1 value 0 value: 1 do: 1 new 0 new: 1 x 0 y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30)   "(delay Semaphore)".	newArray at: 31 put: (self specialObjectsArray at: 31)   "(user input Semaphore)".	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	smallFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0						nStack: 0 nLits: 0 primitive: 0) frameSize.	largeFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0						nStack: smallFrameSize+1 nLits: 0 primitive: 0) frameSize.	newArray at: 35 put: (MethodContext new: smallFrameSize).	newArray at: 36 put: (MethodContext new: largeFrameSize).	newArray at: 37 put: (BlockContext new: smallFrameSize).	newArray at: 38 put: (BlockContext new: largeFrameSize).	newArray at: 39 put: Array new.  "array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	newArray at: 41 put: TranslatedMethod.	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray! !!SystemDictionary methodsFor: 'special objects' stamp: 'jm 8/22/97 12:09'!registerExternalObject: anObject	"Register the given object in the external objects array and return its index. If it is already there, just return its index."	| objects firstEmptyIndex obj sz newObjects |	objects _ self specialObjectsArray at: 39.	"find the first empty slot"	firstEmptyIndex _ 0.	1 to: objects size do: [:i |		obj _ objects at: i.		obj == anObject ifTrue: [^ i].  "object already there, just return its index"		(obj == nil and: [firstEmptyIndex = 0]) ifTrue: [firstEmptyIndex _ i]].	"if no empty slots, expand the array"	firstEmptyIndex = 0 ifTrue: [		sz _ objects size.		newObjects _ objects species new: sz + 20.  "grow linearly"		newObjects replaceFrom: 1 to: sz with: objects startingAt: 1.		firstEmptyIndex _ sz + 1.		Smalltalk specialObjectsArray at: 39 put: newObjects.		objects _ newObjects].	objects at: firstEmptyIndex put: anObject.	^ firstEmptyIndex! !!SystemDictionary methodsFor: 'special objects'!specialNargsAt: anInteger 	"Answer the number of arguments for the special selector at: anInteger."	^ (self specialObjectsArray at: 24) at: anInteger * 2! !!SystemDictionary methodsFor: 'special objects'!specialSelectorAt: anInteger 	"Answer the special message selector from the interleaved specialSelectors array."	^ (self specialObjectsArray at: 24) at: anInteger * 2 - 1! !!SystemDictionary methodsFor: 'special objects'!specialSelectorSize	"Answer the number of special selectors in the system."	^ (self specialObjectsArray at: 24) size // 2! !!SystemDictionary methodsFor: 'special objects' stamp: 'jm 8/24/97 01:16'!unregisterExternalObject: anObject	"Unregister the given object in the external objects array. Do nothing if it isn't registered."	| objects |	anObject ifNil: [^ self].	objects _ self specialObjectsArray at: 39.	1 to: objects size do: [:i |		(objects at: i) == anObject ifTrue: [objects at: i put: nil]].! !!SystemDictionary methodsFor: 'image, changes name' stamp: 'jm 12/4/97 22:37'!changesName	"Answer the local name for the changes file corresponding to the image file name."	"Smalltalk changesName"	| imName ends |	imName _ FileDirectory localNameFor: self imageName.	ends _ self fileNameEnds.	^ (imName copyFrom: 1 to: imName size - ends first size), ends last! !!SystemDictionary methodsFor: 'image, changes name' stamp: 'di 11/6/97 19:27'!fileNameEnds	"Answer the appropriate suffixes for image and changes files"	| pairs |	pairs _ #(('.image' '.changes')			('.image.IMA' '.changes.CHA')			('.IMA' '.CHA')).	pairs do:		[:pair | (self imageName endsWith: pair first) ifTrue: [^ pair]].	self error: 'The image file MUST end with one of' , (pairs collect: [:pair | pair first]) printString! !!SystemDictionary methodsFor: 'image, changes name' stamp: 'jm 12/4/97 22:25'!imagePath	"Answer the path for the directory containing the image file."	"Smalltalk imagePath"	^ FileDirectory dirPathFor: self imageName! !!SystemDictionary methodsFor: 'image, changes name' stamp: 'jm 12/5/97 16:17'!sourcesName	"Answer the full path for to the sources file, which is initially assumed to be in the VM's directory."	^ self vmPath, 'SqueakV1.sources'! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jm 12/5/97 17:51'!externalizeSources   	"Write the sources and changes streams onto external files." 	"Smalltalk externalizeSources"	| sourcesName changesName aFile |	sourcesName _ self sourcesName.	(FileDirectory default fileExists: sourcesName)		ifTrue: [^ self inform:'Sorry, you must first move or remove thefile named ', sourcesName].	changesName _ self changesName.	(FileDirectory default fileExists: changesName)		ifTrue: [^ self inform:'Sorry, you must first move or remove thefile named ', changesName].	aFile _  FileStream newFileNamed: sourcesName.	aFile nextPutAll: SourceFiles first originalContents.	aFile close.	SourceFiles at: 1 put: (FileStream readOnlyFileNamed: sourcesName).	aFile _ FileStream newFileNamed: self changesName.	aFile nextPutAll: SourceFiles last contents.	aFile close.	SourceFiles at: 2 put: (FileStream oldFileNamed: changesName).	self inform: 'Sources successfully externalized'.! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jm 12/5/97 15:30'!internalizeChangeLog    		"Smalltalk internalizeChangeLog"	"Bring the changes file into a memory-resident filestream, for faster access and freedom from external file system.  1/31/96 sw"	| reply aName aFile |	reply _ self confirm:  'CAUTION -- do not undertake this lightly!!If you have backed up your system andare prepared to face the consequences ofthe requested internalization of sources,hit Yes.  If you have any doubts, hit Noto back out with no harm done.'.	(reply ==  true) ifFalse:		[^ self inform: 'Okay - abandoned'].	aName _ self changesName.	(aFile _ SourceFiles last) == nil ifTrue:		[(FileDirectory default fileExists: aName)			ifFalse: [^ self halt: 'Cannot locate ', aName, ' so cannot proceed.'].		aFile _ FileStream readOnlyFileNamed: aName].	SourceFiles at: 2 put: (ReadWriteStream with: aFile contentsOfEntireFile).	self inform: 'Okay, changes file internalized'! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jm 12/5/97 15:30'!internalizeSources    		"Smalltalk internalizeSources"	"Bring the sources and changes files into memory-resident filestreams, for faster access and freedom from file-system interface.  1/29/96 sw"	| reply aName aFile |	reply _ self confirm:  'CAUTION -- do not undertake this lightly!!If you have backed up your system andare prepared to face the consequences ofthe requested internalization of sources,hit Yes.  If you have any doubts, hit Noto back out with no harm done.'.	(reply ==  true) ifFalse:		[^ self inform: 'Okay - abandoned'].	aName _ self sourcesName.	(aFile _ SourceFiles first) == nil ifTrue:		[(FileDirectory default fileExists: aName)			ifFalse: [^ self halt: 'Cannot locate ', aName, ' so cannot proceed.'].		aFile _ FileStream readOnlyFileNamed: aName].	SourceFiles at: 1 put: (ReadWriteStream with: aFile contentsOfEntireFile).	aName _ self changesName.	(aFile _ SourceFiles last) == nil ifTrue:		[(FileDirectory default fileExists: aName)			ifFalse: [^ self halt: 'Cannot locate ', aName, ' so cannot proceed.'].		aFile _ FileStream readOnlyFileNamed: aName].	SourceFiles at: 2 put: (ReadWriteStream with: aFile contentsOfEntireFile).	self inform: 'Okay, sources internalized'! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'tk 12/12/97 10:43'!logChange: aStringOrText	"Write the argument, aString, onto the changes file."	| aString |	(SourceFiles isNil or: [(SourceFiles at: 2) == nil]) ifTrue: [^self].	aStringOrText isText		ifTrue: [aString _ aStringOrText string]		ifFalse: [aString _ aStringOrText].	(aString isMemberOf: String)		ifFalse: [self error: 'cant log this change'].	(aString findFirst: [:char | char isSeparator not]) = 0		ifTrue: [^self].  "null doits confuse replay"	(SourceFiles at: 2) setToEnd;			cr; cr; nextChunkPut: aString.		"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"	self forceChangesToDisk.! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'dhhi 11/6/97 16:50'!openSourceFiles	self imageName = LastImageName ifFalse:		["Reset the author initials to blank when the image gets moved"		LastImageName _ self imageName.		Utilities setAuthorInitials: ''].	FileDirectory		openSources: self sourcesName		andChanges: self changesName		forImage: LastImageName! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'di 1/13/98 20:26'!version	"Answer the version of this release."	^ 'Squeak 1.3 of Jan 16, 1998'! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 1/14/98 08:42'!processShutDownList	"Call the shutDown method on each object that needs to gracefully shut itself down before a snapshot."	(self includesKey: #Password) ifTrue: [Password shutDown].	self shutDownSound.	Delay shutDown.	Smalltalk shutDown.	Color shutDown.	StrikeFont shutDown.	ControlManager shutDown.	DisplayScreen shutDown.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jm 9/11/97 10:49'!processStartUpList	"Call the startUp method on each object that needs to gracefully restart itself after a snapshot."	DisplayScreen startUp.	Cursor startUp.	Smalltalk installLowSpaceWatcher.	InputSensor startUp.	ProcessorScheduler startUp.	Delay startUp.	Smalltalk startUp.	ControlManager startUp.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jm 10/16/97 10:30'!processUpdates	"Process update files from a well-known update server."	| choice |	(Preferences valueOfFlag: #updateFromServer) ifTrue: [		choice _ (PopUpMenu labels: 'Yes, Update\No, Not now' withCRs)			startUpWithCaption: 'Shall I look for new code\updates on the server?' withCRs.		choice = 1 ifTrue: [Utilities absorbUpdatesFromServer]].! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 1/13/98 22:48'!readDocumentFile	"Process system updates. Read a document file, if one was provided. Start application."	| fileName object |	self processUpdates.	fileName _ Smalltalk getSystemAttribute: 1.	((fileName ~~ nil) and: [fileName size > 0])		ifTrue: [			(fileName asLowercase beginsWith: 'http://')				ifTrue: [					"fetch remote file"					HTTPSocket httpFileIn: fileName]				ifFalse: [					"read local file"					object _ (FileStream oldFileNamed: fileName) fileInObjectAndCode.					"if launching a .sqo document, send open to the final object"					(fileName endsWith: '.sqo') ifTrue: [object open]]]		ifFalse: [].! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 11/6/97 19:33'!saveAs	| dir newName imageSuffix changesSuffix |	dir _ FileDirectory default.	imageSuffix _ self fileNameEnds first.	changesSuffix _ self fileNameEnds last.	newName _ (FillInTheBlank request: 'New File Name?' 					initialAnswer: 'NewImageName') asFileName.	(newName endsWith: imageSuffix) ifTrue:		[newName _ newName copyFrom: 1 to: newName size - imageSuffix size].	(dir includesKey: newName , imageSuffix)		| (dir includesKey: newName , changesSuffix) ifTrue:		[^ self notify: newName , ' is already in usePlease choose another name.'].	dir copyFileNamed: self changesName toFileNamed: newName , changesSuffix.	self logChange: '----SAVEAS ' , newName , '----'		, Date dateAndTimeNow printString.	self imageName: newName , imageSuffix.	LastImageName _ self imageName.	self closeSourceFiles; openSourceFiles.	"Just so SNAPSHOT appears on the new file, and not the old"	self snapshot: true andQuit: false.! !!SystemDictionary methodsFor: 'snapshot and quit'!shutDownSound	(self at: #SoundPlayer ifAbsent: [^ self]) shutDown! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jm 9/11/97 11:42'!snapshot: save andQuit: quit	"Mark the changes file and close all files. If save is true, save the current state of this Smalltalk in the image file. If quit is true, then exit to the outer shell. The latter part of this method runs when resuming a previously saved image. The resume logic checks for a document file to process when starting up."	| resuming msg sourceLink |	save & (SourceFiles at: 2) notNil ifTrue:		[msg _  (quit			ifTrue: ['----QUIT----']			ifFalse: ['----SNAPSHOT----'])			, Date dateAndTimeNow printString.		sourceLink _ ' priorSource: ' , LastQuitLogPosition printString.		LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position.		self logChange: msg , sourceLink.		Transcript cr; show: msg].	self processShutDownList.	Cursor write show.	save		ifTrue: [resuming _ self snapshotPrimitive]  "<-- PC frozen here on image file"		ifFalse: [resuming _ false].	quit & resuming not ifTrue: [self quitPrimitive].	Cursor normal show.	self processStartUpList.	resuming ifTrue: [		self clearExternalObjects.		self readDocumentFile].! !!SystemDictionary methodsFor: 'snapshot and quit'!startUp	"Open the files for sources and changes."	self openSourceFiles.! !!SystemDictionary methodsFor: 'housekeeping'!cleanOutUndeclared 	Undeclared removeUnreferencedKeys! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 11/4/97 20:11'!condenseChanges		"Smalltalk condenseChanges"	"Move all the changes onto a compacted sources file."	| f oldChanges classCount |	f _ FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.'Condensing Changes File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class moveChangesTo: f.			class class moveChangesTo: f]].	LastQuitLogPosition _ f position.	f trailer; close.	oldChanges _ SourceFiles at: 2.	oldChanges close.	FileDirectory default deleteFileNamed: oldChanges name , '.old'.	FileDirectory default rename: oldChanges name						toBe: oldChanges name , '.old'.	FileDirectory default rename: f name						toBe: oldChanges name.	SourceFiles at: 2			put: (StandardFileStream oldFileNamed: oldChanges name).! !!SystemDictionary methodsFor: 'housekeeping'!condenseSources		"Smalltalk condenseSources"	"Move all the changes onto a compacted sources file."	| f name oldChanges classCount dir |	dir _ FileDirectory default.	"Write all sources with fileIndex 1"	f _ FileStream newFileNamed: self sourcesName , '.temp'.	f header; timeStamp.'Condensing Sources File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class fileOutOn: f moveSource: true toFile: 1]].	f trailer; close.	"Make a new empty changes file"	self closeSourceFiles.	dir rename: self changesName		toBe: self changesName , '.old'.	(FileStream newFileNamed: self changesName)		header; timeStamp; close.	LastQuitLogPosition _ 0.	dir rename: self sourcesName		toBe: self sourcesName , '.old'.	dir rename: self sourcesName , '.temp'		toBe: self sourcesName.	self openSourceFiles.	SelectionMenu notify: 'Source files have been rewritten!!Check that all is well,and then save/quit.'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 11/4/97 20:11'!forgetDoIts	"Smalltalk forgetDoIts"	Smalltalk allBehaviorsDo: "get rid of old DoIt methods"		[:cl | cl removeSelectorSimply: #DoIt; removeSelectorSimply: #DoItIn:]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 1/13/98 11:09'!makeExternalRelease		"Smalltalk makeExternalRelease"	SystemOrganization removeCategoriesMatching: '*EToys*'.	(self confirm: self version , 'Is this the correct version designation?If not, choose no, and fix it.') ifFalse: [^ self].	(Object classPool at: #DependentsFields) size > 1 ifTrue: [self halt].	Browser initialize.	Undeclared isEmpty ifFalse: [self halt].	Smalltalk garbageCollect.	self obsoleteClasses isEmpty ifFalse: [self halt].	Symbol rehash.	self halt: 'Ready to condense changes'.	Smalltalk condenseChanges!]style[(19 54 25 435)f1b,f1,f1b,f1! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'sw 9/21/97 01:14'!makeInternalRelease		"Smalltalk makeInternalRelease"	(self confirm: self version , 'Is this the correct version designation?If not, choose no, and fix it.') ifFalse: [^ self].	(Object classPool at: #DependentsFields) size > 1 ifTrue: [self halt].	Browser initialize.	Undeclared isEmpty ifFalse: [self halt].	Smalltalk garbageCollect.	self obsoleteClasses isEmpty ifFalse: [self halt].	Symbol rehash.	self halt: 'Ready to condense changes'.	Smalltalk condenseChanges! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 6/20/97 10:51'!reclaimDependents		"Smalltalk reclaimDependents"	"Reclaim unused entries in DependentsFields (DF)..."	"NOTE:  if <object>addDependent: is ever used to add something		other than a view, this process will fail to reinstate that		thing after clearing out DependentsFields.  DF was only		intended to be used as part of the MVC architecture."	Object classPool at: #DependentsFields  "Remove all entries from DF"				put: IdentityDictionary new.	Smalltalk garbageCollect.  "If that was the only reference, they will go away"	"Now if any views of non-models remain,		they should be reinstated as dependent views..."	View allSubInstancesDo:		[:v | (v model==nil or: [v model isKindOf: Model])				ifFalse: [v model addDependent: v]]	! !!SystemDictionary methodsFor: 'housekeeping'!recompileAllFrom: firstName 	"Recompile all classes, starting with given name."	Smalltalk forgetDoIts.	self allClassesDo: 		[:class | class name >= firstName			ifTrue: 				[Transcript show: class name; cr.				class compileAll]]	"Smalltalk recompileAllFrom: 'Aardvark'."! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 10/4/97 09:11'!removeEmptyMessageCategories	"Smalltalk removeEmptyMessageCategories"	Smalltalk garbageCollect.	ClassOrganizer allInstances , (Array with: SystemOrganization) do:		[:org | org categories do: 			[:cat | (org listAtCategoryNamed: cat) isEmpty				ifTrue: [org removeCategory: cat]]]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 7/13/97 11:56'!testDecompiler    "Smalltalk testDecompiler"	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."	 | methodNode oldMethod newMethod badOnes oldCodeString |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.	Smalltalk allBehaviorsDo:		[:cls |  Transcript cr; show: cls name.		cls selectors do:			[:selector |			oldMethod _ cls compiledMethodAt: selector.			oldCodeString _ (cls decompilerClass new								decompile: selector in: cls method: oldMethod)							decompileString.			methodNode _ cls compilerClass new						compile: oldCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldCodeString = (cls decompilerClass new								decompile: selector in: cls method: newMethod)							decompileString ifFalse: [Transcript cr; show: '***' , cls name , ' ' , selector.											badOnes add: cls name , ' ' , selector]]].	^ badOnes! !!SystemDictionary methodsFor: 'housekeeping'!testFormatter    "Smalltalk testFormatter"	"Reformats the source for every method in the system, and then	compiles that source and verifies that it generates identical code"	 | newCodeString methodNode oldMethod newMethod badOnes |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.	Smalltalk allBehaviorsDo:		[:cls |  Transcript cr; show: cls name.		cls selectors do:			[:selector |			newCodeString _ (cls compilerClass new)				format: (cls sourceCodeAt: selector)				in: cls notifying: nil.			methodNode _ cls compilerClass new						compile: newCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldMethod _ cls compiledMethodAt: selector.			oldMethod = newMethod ifFalse: [Transcript cr; show: '***' , cls name , ' ' , selector.											badOnes add: cls name , ' ' , selector]]].	^ badOnes! !!SystemDictionary methodsFor: 'miscellaneous'!clipboardText	"Get the current clipboard text. Return the empty string if the primitive fails."	<primitive: 141>	^ ''! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jj 10/20/97 16:17'!forceDisplayUpdate	"On platforms that buffer screen updates, force the screen to be updated immediately. On other platforms, or if the primitive is not implemented, do nothing."	<primitive: 231>! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jm 6/17/97 07:09'!getSystemAttribute: attributeID	"Return the string for the system attribute with the given integer ID."	<primitive: 149>	self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ikp 1/2/98 20:29'!getVMParameters	"Smalltalk getVMParameters"	"Answer an Array containing the current values of the VM's internal	parameter/metric registers.  Each value is stored in the array at the	index corresponding to its VM register.  (See #vmParameterAt: and	#vmParameterAt:put:.)"	<primitive: 254>	self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ikp 1/2/98 20:29'!vmParameterAt: parameterIndex	"parameterIndex is a positive integer corresponding to one of the VM's internal	parameter/metric registers.  Answer with the current value of that register.	Fail if parameterIndex has no corresponding register."	<primitive: 254>	self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ikp 1/2/98 20:29'!vmParameterAt: parameterIndex put: newValue	"parameterIndex is a positive integer corresponding to one of the VM's internal	parameter/metric registers.  Store newValue (a positive integer) into that	register and answer with the previous value that was stored there.	Fail if newValue is out of range, if parameterIndex has no corresponding	register, or if the corresponding register is read-only."	<primitive: 254>	self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ikp 1/2/98 20:30'!vmTable: tableIndex at: index	"tableIndex is a negative integer corresponding to one of the VM's internal tables.	Answer with the value in the table at the given index (counting from 1).  Index 0	'contains' the size (i.e. largest legal index) of the table."	<primitive: 254>	self primitiveFailed! !!SystemMonitor methodsFor: 'initialize-release' stamp: 'di 11/4/97 20:03'!labels: labelArray selectors: selectorArray	| labelHeight labelWidth topLeft bottomRight |	self readVMParameters.	minValues _ selectorArray collect: [:str | self perform: (str , 'Min') asSymbol].	maxValues _ selectorArray collect: [:str | self perform: (str , 'Max') asSymbol].	valSelectors _ selectorArray collect: [:str | (str , 'Val') asSymbol].	labels _ labelArray collect: [:str |		(DisplayText text: str asText)			foregroundColor: ForegroundColor			backgroundColor: BackgroundColor].	baselineSkip _ (labels at: 1) height.	baselineSkip = 0		ifTrue:	"empty lables: use a completely undecorated display, flush-bottom/left"			[baselineSkip _ DefaultBarHeight.			labelHeight _ baselineSkip * labels size.			topLeft _ 0@(Display height - labelHeight + BarBorderWidth).			bottomRight _ BarWidth@(Display height).			window _ topLeft corner: bottomRight]		ifFalse:			[labelHeight _ baselineSkip * labels size.			labelWidth _ (labels inject: 0 into: [:max :lbl | max max: lbl width]) + (Inset * 2) + BarBorderWidth.			topLeft _ 0@(Display height - labelHeight - (Inset * 2)).			bottomRight _ (labelWidth + (2*Inset) + BarWidth)@(Display height).			window _ (topLeft corner: bottomRight) insetBy: Inset.			"window _ window translateBy: (BorderWidth negated)@BorderWidth."			self displayBordersAndLabels]! !!SystemMonitor methodsFor: 'displaying' stamp: 'di 11/4/97 20:03'!display	| barOrigin delta curVal minVal maxVal |	self readVMParameters.	barOrigin _ window topRight translateBy: (BarWidth negated - BarBorderWidth)@BarBorderWidth.	delta _ 0@baselineSkip.	1 to: valSelectors size do: [:index |		curVal _ self perform: (valSelectors at: index).		minVal _ minValues at: index.		maxVal _ maxValues at: index.		curVal class == Array			ifTrue:				["implicitly trust the system to return sensible values"				self displayBars: curVal from: minVal to: maxVal					in: (barOrigin extent: BarWidth@(baselineSkip - (BarBorderWidth * 2)))]			ifFalse:				["adjust the bounds if necessary"				minVal > curVal ifTrue: [minValues at: index put: (minVal _ curVal)].				maxVal < curVal ifTrue: [maxValues at: index put: (maxVal _ curVal)].				self displayBar: curVal from: minVal to: maxVal					in: (barOrigin extent: BarWidth@(baselineSkip - (BarBorderWidth * 2)))].		barOrigin _ barOrigin translateBy: delta].! !!SystemMonitor methodsFor: 'displaying' stamp: 'di 11/4/97 20:03'!displayBar: val from: min to: max in: barRect	| break |	break _ barRect left + (((val - min) / (max - min)) * barRect width) asInteger.	Display fill: (barRect withRight: break) fillColor: (BarColors at: 1).	Display fill: (barRect withLeft: break) fillColor: BarBackgroundColor.! !!SystemMonitor methodsFor: 'displaying' stamp: 'di 11/4/97 20:03'!displayBars: vals from: min to: max in: barRect	| break prevBreak |	prevBreak _ barRect left.	vals doWithIndex: [:val :index |		break _ barRect left + (((val - min) / (max - min)) * barRect width) asInteger.		Display fill: ((barRect withLeft: prevBreak) withRight: break) fillColor: (BarColors at: index).		prevBreak _ break].	Display fill: (barRect withLeft: prevBreak) fillColor: BarBackgroundColor.! !!SystemMonitor methodsFor: 'displaying' stamp: 'di 11/4/97 20:03'!displayBordersAndLabels	| labelOrigin barOrigin delta |	Display fill: (window insetBy: Inset negated) fillColor: BorderColor.	Display fill: (window insetBy: BorderWidth - Inset) fillColor: BackgroundColor.	barOrigin _ window topRight translateBy: (BarWidth negated - (2 * BarBorderWidth))@0.	labelOrigin _ barOrigin translateBy: (Inset negated)@"0"(BorderWidth - Inset).	delta _ 0@baselineSkip.	1 to: labels size do: [:index |		(labels at: index) displayOn: Display at: (labelOrigin translateBy: ((labels at: index) width negated)@0).		Display fill: (barOrigin extent: (BarWidth + (2 * BarBorderWidth))@baselineSkip)			fillColor: BarBorderColor.		labelOrigin _ labelOrigin translateBy: delta.		barOrigin _ barOrigin translateBy: delta].! !!SystemMonitor methodsFor: 'system parameters' stamp: 'di 11/4/97 20:03'!allocationRateMax	^1! !!SystemMonitor methodsFor: 'system parameters' stamp: 'di 11/4/97 20:03'!allocationRateMin	prevAllocCount _ 0.	prevAllocRate _ 0.	^0! !!SystemMonitor methodsFor: 'system parameters' stamp: 'di 11/4/97 20:03'!allocationRateVal	| rate allocCount |	allocCount _ vmParameters at: 4.	rate _ allocCount < prevAllocCount		ifTrue: [prevAllocRate]		ifFalse: [allocCount - prevAllocCount].	prevAllocCount _ allocCount.	prevAllocRate _ (prevAllocRate // 2) + (rate // 2).	^prevAllocRate! !!SystemMonitor methodsFor: 'system parameters' stamp: 'ikp 1/13/98 00:54'!cacheMax	^100! !!SystemMonitor methodsFor: 'system parameters' stamp: 'ikp 1/13/98 01:00'!cacheMin	prevMcMiss _ vmParameters at: 15.	prevMcHit _ vmParameters at: 16.	prevIcHit _ vmParameters at: 17.	^0! !!SystemMonitor methodsFor: 'system parameters' stamp: 'ikp 1/13/98 01:02'!cacheVal	| icHit mcHit mcMiss total deltaMcMiss deltaMcHit deltaIcHit |	mcMiss _ vmParameters at: 15.	deltaMcMiss _ mcMiss - prevMcMiss.	prevMcMiss _ mcMiss.	mcHit _ vmParameters at: 16.	deltaMcHit _ mcHit - prevMcHit.	prevMcHit _ mcHit.	icHit _ vmParameters at: 17.	deltaIcHit _ icHit - prevIcHit.	prevIcHit _ icHit.	total _ deltaMcMiss + deltaMcHit + deltaIcHit.	deltaMcMiss _ (deltaMcMiss * 100 / total asInteger).	deltaMcHit _ (deltaMcHit * 100 / total asInteger).	^Array		with: deltaMcMiss		with: deltaMcMiss + deltaMcHit! !!SystemMonitor methodsFor: 'system parameters' stamp: 'ikp 1/13/98 00:11'!gcMax	^100! !!SystemMonitor methodsFor: 'system parameters' stamp: 'ikp 1/13/98 00:23'!gcMin	prevMsClock _ Time millisecondClockValue.	prevFullGC _ vmParameters at: 8.	prevDeltaFullGC _ 0.	prevIncrGC _ vmParameters at: 10.	prevDeltaIncrGC _ 0.	^0! !!SystemMonitor methodsFor: 'system parameters' stamp: 'ikp 1/13/98 00:22'!gcVal	| ms fullGC incrGC deltaMs deltaFull deltaIncr max |	ms _ Time millisecondClockValue.	fullGC _ (vmParameters at: 8).	incrGC _ (vmParameters at: 10).	deltaMs _ ms - prevMsClock.	deltaFull _ fullGC - prevFullGC.	deltaIncr _ incrGC - prevIncrGC.	prevMsClock _ ms.	prevFullGC _ fullGC.	prevIncrGC _ incrGC.	prevDeltaFullGC _ prevDeltaFullGC + deltaFull / 2.	prevDeltaIncrGC _ prevDeltaIncrGC + deltaIncr / 2.	max _ deltaMs * 2.	^Array		with: (prevDeltaFullGC * 100 / max) asInteger		with: (prevDeltaIncrGC * 100 / max) asInteger! !!SystemMonitor methodsFor: 'system parameters' stamp: 'di 11/4/97 20:03'!memoryMax	^vmParameters at: 3! !!SystemMonitor methodsFor: 'system parameters' stamp: 'di 11/4/97 20:03'!memoryMin	"Setup the gc low/high water marks at the same time"	gcLowWaterMark _ vmParameters at: 1.	gcHighWaterMark _ vmParameters at: 1.	^0! !!SystemMonitor methodsFor: 'system parameters' stamp: 'di 11/4/97 20:03'!memoryVal	"If youngStart is below the highWaterMark then a full collection has happened."	| youngStart |	youngStart _ vmParameters at: 1.	youngStart < gcHighWaterMark ifTrue: [gcLowWaterMark _ gcHighWaterMark _ youngStart].	youngStart > gcHighWaterMark ifTrue: [gcHighWaterMark _ youngStart].	^Array		with: gcLowWaterMark		with: gcHighWaterMark		with: (vmParameters at: 2)! !!SystemMonitor methodsFor: 'private' stamp: 'di 11/4/97 20:03'!readVMParameters	vmParameters _ Smalltalk getVMParameters.! !!SystemMonitor class methodsFor: 'class initialization' stamp: 'ikp 1/13/98 01:18'!initialize	"SystemMonitor initialize"	MonitorDelay _ 1000.								"milliseconds between updates"	Inset _ 2.										"inset from monitor border (outside) to bars and labels"	BorderWidth _ 1.									"width of border around entire monitor"	BorderColor _ Color black.						"colour of border around entire monitor"	BackgroundColor _ Color gray.		"background colour for monitor area"	ForegroundColor _ Color black.					"foreground colour for bar labels"	DefaultBarHeight _ 8.							"height of bar for undecorated display (no labels)"	BarWidth _ 200.									"horizontal (long-axis) size of each bar"	BarBorderWidth _ 1.								"width of border around each bar"	BarBorderColor _ Color black.					"colour of border around each bar"	BarBackgroundColor _ Color veryLightGray.		"background colour (inactive region) of bar"	BarColors _ Array		with: Color darkGray						"colour of first bar segment"		with: Color lightRed						"colour of second bar segment"		with: Color lightBlue							"colour of third bar segment"		with: Color lightGreen.						"colour of fourth bar segment"! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/13/98 00:52'!cache	^super new		labels: #(cache)		selectors: #(cache).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/13/98 00:53'!cacheUndecorated	^super new labels: #('') selectors: #(cache).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/13/98 00:53'!default	^super new		labels: #(cache memory gc)		selectors: #(cache memory gc).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/13/98 00:53'!defaultUndecorated	^super new labels: #('' '' '') selectors: #(cache memory gc).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/13/98 00:53'!full	^super new		labels: #('alloc' cache mem gc)		selectors: #(allocationRate cache memory gc).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/13/98 00:53'!fullUndecorated	^super new		labels: #('' '' '' '')		selectors: #(allocationRate cache memory gc).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/12/98 23:51'!gc	^super new		labels: #(gc)		selectors: #(gc).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/12/98 23:51'!gcUndecorated	^super new labels: #('') selectors: #(gc).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/14/98 02:25'!memory	^super new		labels: #(memory)		selectors: #(memory).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/14/98 02:25'!memoryUndecorated	^super new		labels: #('')		selectors: #(memory).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'di 11/4/97 20:03'!new	^self default! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!restore		"SystemMonitor restore"	ActiveMonitor = nil ifFalse: [ActiveMonitor displayBordersAndLabels; display]! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!start		"SystemMonitor start"	self startDefault! !!SystemMonitor class methodsFor: 'public access' stamp: 'ikp 1/13/98 00:54'!startCache		"SystemMonitor startCache"	self start: self cache! !!SystemMonitor class methodsFor: 'public access' stamp: 'ikp 1/13/98 00:54'!startCacheUndecorated		"SystemMonitor startCacheUndecorated"	self start: self cacheUndecorated! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!startDefault		"SystemMonitor startDefault"	self start: self default! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!startDefaultUndecorated		"SystemMonitor startDefaultUndecorated"	self start: self defaultUndecorated! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!startFull		"SystemMonitor startFull"	self start: self full! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!startFullUndecorated		"SystemMonitor startFullUndecorated"	self start: self fullUndecorated! !!SystemMonitor class methodsFor: 'public access' stamp: 'ikp 1/12/98 23:52'!startGC		"SystemMonitor startGC"	self start: self gc! !!SystemMonitor class methodsFor: 'public access' stamp: 'ikp 1/12/98 23:52'!startGCUndecorated		"SystemMonitor startGCUndecorated"	self start: self gcUndecorated! !!SystemMonitor class methodsFor: 'public access' stamp: 'ikp 1/14/98 02:25'!startMemory		"SystemMonitor startMemory"	self start: self memory! !!SystemMonitor class methodsFor: 'public access' stamp: 'ikp 1/14/98 02:26'!startMemoryUndecorated		"SystemMonitor startMemoryUndecorated"	self start: self memoryUndecorated! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!startUndecorated		"SystemMonitor startUndecorated"	self startDefaultUndecorated! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!stop		"SystemMonitor stop"	ActiveClock = nil		ifFalse:			[ActiveClock terminate.			ActiveClock _ nil].	ActiveMonitor = nil ifFalse: [ActiveMonitor _ nil].! !!SystemMonitor class methodsFor: 'scheduling' stamp: 'ikp 1/13/98 01:28'!start: aMonitor	self stop.	ActiveMonitor _ aMonitor.	ActiveClock _		[[true] whileTrue:			[ActiveMonitor display.			(Delay forMilliseconds: MonitorDelay) wait]] newProcess.	ActiveClock priority: Processor lowIOPriority.	ActiveClock resume! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 19:01'!fileOutCategory: category 	"Store on the file named category (a string) concatenated with '.st' all the 	classes associated with the category."	^ self fileOutCategory: category asHtml: false! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 19:00'!fileOutCategory: category asHtml: useHtml	"FileOut all the classes in the named system category."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: category , '.html') asHtml]		ifFalse: [FileStream newFileNamed: category , '.st'].	self fileOutCategory: category on: fileStream.	fileStream close! !!SystemOrganizer methodsFor: 'remove' stamp: 'di 1/9/98 12:37'!removeCategoriesMatching: matchString	"Remove all matching categories with their classes"	(self categories select: [:c | matchString match: c]) do:		[:c | self removeSystemCategory: c]! !SystemTracer comment:'NOTE:  The SystemTracer was invented by Ted Kaehler.  It has gone through many variations.  I have simplified it and adapted it to work with Squeak''s limited Object hashing.  It has written runnable Mac images on a Mac.  Some changes may be needed for it to produce runnables image on a bigEndian machine.  -- Dan I. 9/29/97The SystemTracer runs through the system tracing every accessible object, and writing a copy of each object onto a disk image. It does this carefully enough that the resulting clone can be started up and run, just like a snapshot.  Great care must also be taken that the tracer never sees (due to clamping) any of the structures created dynamically while writing the clone.  If this happens an infinite recursion can result.	The tracer has built-in support for clamping unwanted (or unneeded) objects out of the system. It also allows fundamental changes to, eg, object header format, compiledMethod format, number formats, etc.  The current version is fairly simple, as it just copies what is already in the system. This version does, however, reassign object hashes in order to illustrate how one must remap all the hashed structures accordingly.Squeak currently only has 12 bits of object hash.  A normal dictionary, used to map from old oop to new oop, would bog down in a system of, say, 50k objects.  This tracer has a special structure that is optimized for this purpose.  See the comment in initOopMap.  If we ever extend the object hash, this structure could be replaced by a simple IdentityDictionary.When you first start up the cloned image, you will probably get a "cannotReturn" error, a vestige of the old tracing process.  This can simply be closed (or maybe you can figure out how to fix the tracers so it doens''t happen ;-).  '!!SystemTracer methodsFor: 'initialization' stamp: 'di 9/28/97 16:13'!doit  "SystemTracer writeClone"	"(StandardFileStream allInstances select:		[:f | f name endsWith: 'clone.image']) do: [:f | f close]."	| time1 time2 ctxt n |	ctxt _ thisContext sender.	ctxt push: nil.	self init: ctxt.	cleaningUp _ false.	"true means rewriting special objects in writeSpecial2"	Transcript show: 'Tracing . . . '.	time1 _ Time millisecondClockValue.	file _ FileStream fileNamed: 'clone.image'.	file binary.	n _ self writeImage: (Array with: Smalltalk).	time2 _ Time millisecondClockValue.	Transcript cr; show: n printString , ' bytes written in '			, (time2 - time1 //1000) printString , ' seconds.'.	"ctxt pop" "So we can resume"! !!SystemTracer methodsFor: 'initialization' stamp: 'di 9/27/97 22:27'!init: aContext	initialProcess _ Process forContext: aContext priority: Processor activePriority.	self initOopMap.	hashGenerator _ Random new.	self clamp: self.	self clamp: aContext sender.	self initDict! !!SystemTracer methodsFor: 'initialization' stamp: 'di 12/15/97 21:35'!initCompactClasses	| c |	c _ Array new: 31.		"These classes have a short name (their index in this table.  It is not their oop.)	Thus their instances can use just a single word as their header in memory."	c at: 1 put: CompiledMethod.  c at: 2 put: Symbol. c at: 3 put: Array.	c at: 4 put: Float.  c at: 5 put: LargePositiveInteger.  c at: 6 put: String.	c at: 7 put: MethodDictionary.  c at: 8 put: Association.  c at: 9 put: Point.	c at: 10 put: Rectangle.  c at: 11 put: ClassOrganizer.  c at: 12 put: TextLineInterval.	c at: 13 put: BlockContext.  c at: 14 put: MethodContext.  c at: 15 put: PseudoContext.	compactClasses _ c.	"Leave 16 to 31 for user defined compact classes."	"Attempt to correctly write contextCace image.."	compactClasses _ Smalltalk compactClassesArray! !!SystemTracer methodsFor: 'initialization' stamp: 'ikp 12/17/97 00:08'!initDict	writeDict _ Dictionary new: 256.	Smalltalk allClassesDo: 		[:class | 		class isBits 			ifTrue: 			[writeDict at: class put: (class isBytes ifTrue: [#writeBytes:]												ifFalse: [#writeWords:])]			ifFalse:			[writeDict at: class put: #writePointers:.			(class inheritsFrom: Set) | (class == Set) ifTrue:				[writeDict at: class put: #writeSet:].			(class inheritsFrom: IdentitySet) | (class == IdentitySet) ifTrue:				[writeDict at: class put: #writeIdentitySet:].			(class inheritsFrom: IdentityDictionary) | (class == IdentityDictionary) ifTrue:				[writeDict at: class put: #writeIdentitySet:].			(class inheritsFrom: MethodDictionary) | (class == MethodDictionary) ifTrue:				[writeDict at: class put: #writeMethodDictionary:]].				].	Smalltalk allBehaviorsDo: 		[:class | writeDict at: class class put: #writeBehavior:].	(ObjectTracer withAllSubclasses) do: 		[:class | writeDict at: class class put: #writeBehavior:].	writeDict at: PseudoContext class put: #writeBehavior:.	writeDict at: SmallInteger put: #writeClamped:.	writeDict at: CompiledMethod put: #writeMethod:.	writeDict at: Process put: #writeProcess:.	writeDict at: MethodContext put: #writeContext:.	writeDict at: BlockContext put: #writeContext:.! !!SystemTracer methodsFor: 'initialization' stamp: 'di 1/2/98 11:15'!writeFileHeader	file position: 0.  "info in header page"	self write4Bytes: ($A asciiValue *100) + 2.  "version number:  6500+2"	self write4Bytes: imageHeaderSize.  "File offset (bytes) of start of data"							"same as base address (byte) of first object"	self write4Bytes: maxOop.  "Length of data segment in words"	self write4Bytes: 0.		"what you have to add to an oop to get"							"an offset in the data portion of this file"	self write4Bytes: (self mapAt: specialObjects).	self write4Bytes: (hashGenerator next * 16rFFF asFloat) asInteger.  "next hash"	self write4Bytes: Display width * 16r10000 + Display height.  "display size"	file position > imageHeaderSize ifTrue: [self error: 'Header ran over allotted length'].	file padTo: imageHeaderSize put: 0.  "Pad header page"	file setType: 'STim' creator: 'FAST'; close! !!SystemTracer methodsFor: 'initialization' stamp: 'di 10/3/97 16:13'!writeImage: roots 	imageHeaderSize _ 64.	"16 longs"	file position: imageHeaderSize.  "Skip header section"	maxOop _ 0.  "Starting oop"	self initCompactClasses.	specialObjects _ Smalltalk specialObjectsArray copy.	specialObjects at: 29 put: compactClasses.	"New oop of nil is needed before we find out from the trace."	NewNil _ maxOop + ((self headersFor: nil withHash: 0) size-1*4).	self trace: nil.  "In fact, this traverses the system by the time it's done!!"	self trace: specialObjects.	roots do: [:root | self trace: root].	self writeFileHeader.	^ Array with: maxOop! !!SystemTracer methodsFor: 'mapping oops' stamp: 'di 9/29/97 08:21'!clamp: obj	self mapAt: obj put: Clamped with: nil! !!SystemTracer methodsFor: 'mapping oops'!hasClamped: obj	"See if obj will be a SmallInteger in the new system."	obj class == SmallInteger ifTrue: [^ true].	^ (self mapAt: obj) = Clamped! !!SystemTracer methodsFor: 'mapping oops'!initOopMap	"oopMap is an array 4096 long indexed by basicHash.	Each element a subarray of object/newOop/hash triplets.	The subarrrays must be linearly searched.	Access to an object causes it to be promoted in the subarray,		so that frequently accessed objects can be found quickly."	oopMap _ (1 to: 4096) collect: [:i | Array new].! !!SystemTracer methodsFor: 'mapping oops' stamp: 'di 9/27/97 20:26'!mapAt: obj	"Return the new oop for this object"	| bucket |	bucket _ oopMap at: obj identityHash+1.	1 to: bucket size by: 3 do: 		[:i | obj == (bucket at: i)			ifTrue: ["Promote this entry for rapid access"					i > 1 ifTrue: [1 to: 3 do: [:j | bucket swap: j with: i-1+j]].					^ bucket at: 2]].	^ UnassignedOop! !!SystemTracer methodsFor: 'mapping oops' stamp: 'di 9/27/97 20:26'!mapAt: obj put: oop with: hash	"Assign the new oop for this object"	| bucket |	bucket _ oopMap at: obj identityHash+1.	"Check for multiple writes (debug only)""	1 to: bucket size by: 3 do: 		[:i | obj == (bucket at: i) ifTrue: [self halt]]."	oopMap at: obj identityHash+1 put: (Array with: obj with: oop with: hash) , bucket! !!SystemTracer methodsFor: 'mapping oops' stamp: 'di 12/15/97 19:31'!mapHashAt: obj	"Return the new hash for this object"	| bucket |	bucket _ oopMap at: obj identityHash+1.	1 to: bucket size by: 3 do: 		[:i | obj == (bucket at: i) ifTrue: [^ bucket at: i+2]].	self halt! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/29/97 09:05'!new: obj class: class length: length trace: traceBlock write: writeBlock	| oop objpos headers type hash |	"We assign file space for an object.	Only does something when object has not been assigned a new oop yet.  	Length is the instance vars and variable portion in longs.	Class is not included in length.	Special objects come here for an oop, and do no tracing or writing.	To trace and write their fields later, do NOT use this method."  	oop_ self mapAt: obj.	oop = UnassignedOop ifFalse:		["Has already been assigned a new oop or clamped."		^ self].	"Write header and remember new oop in map"	hash _ (hashGenerator next * 16rFFF asFloat) asInteger.	headers _ self headersFor: obj withHash: hash.	file position: maxOop + imageHeaderSize.	headers do: [:h | self write4Bytes: h].	maxOop _ maxOop + (headers size-1*4).		"New oop points at header word"	self mapAt: obj put: maxOop with: hash.	objpos _ maxOop + imageHeaderSize.		"file position"length > 20 ifTrue: [maxOop printString, ' ' displayAt: 0@0].	"Write blank data, advancing to next object position"	maxOop _ maxOop + (length+1*4).	"ready for next object"	file nextPutAll: (ByteArray new: length*4 withAll: 0).	traceBlock notNil ifTrue: [self trace: class.  traceBlock value].	(headers size > 1 and: [(headers at: headers size-1) < 0])		ifTrue: ["rewrite class word if not known before"				file position: objpos-4.				type _ (headers at: headers size-1) bitAnd: 3.				self write4Bytes: (self mapAt: class) + type.				self write4Bytes: (headers at: headers size) "faster to write than skip"]		ifFalse: ["Had no class header, or was already valid"				file position: objpos+4].	"Now positioned after header, before data..."	writeBlock value.	"No allocation of new oops is allowed in here!!"	"Consistency check"	file position = (objpos + (length+1*4)) ifFalse:		["writeBlock did not leave us at end of object"		self halt.		"Maybe copied an object without putting it in holder,		so it got freed and became something else of a different size"]! !!SystemTracer methodsFor: 'tracing and writing'!trace: obj	(self hasClamped: obj) ifTrue: [^ self].	self perform: (writeDict at: obj class ifAbsent: [#writeClamped:])			"May be some classes not in Smalltalk dict, let them through"		with: obj.! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/28/97 14:40'!writeBehavior: obj	| length |	self new: obj		class: obj class		length: (length _ self sizeInWordsOf: obj)		trace: [1 to: length do: [:i | self trace: (obj instVarAt: i)]]		write: [1 to: 2 do: [:i | self writePointerField: (obj instVarAt: i)].			self writePointerField: (self formatOfCls: obj).			4 to: length do: [:i | self writePointerField: (obj instVarAt: i)]]! !!SystemTracer methodsFor: 'tracing and writing'!writeBytes: obj	self new: obj		class: obj class		length: (self sizeInWordsOf: obj)		trace: []		write: 			[1 to: obj size do: [:i | file nextPut: (obj at: i) asInteger].			file padToNextLongPut: 0]! !!SystemTracer methodsFor: 'tracing and writing'!writeClamped: obj	^false! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/28/97 01:33'!writeContext: obj	"Nil out any garbage above the stack pointer to avoid a crash."	obj stackPtr == nil ifFalse:		[obj stackPtr+1 to: obj size do: [:ind | obj at: ind put: nil]].	^ self writePointers: obj	"Normal Case"! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/28/97 00:20'!writeHashArray: obj permutedBy: perm	"Elements of a Set's hashed array need to be reordered according to perm."	| length |	self new: obj class: obj class length: (length _ self sizeInWordsOf: obj)		trace:	[1 to: length do:					[:i | self trace: (obj basicAt: i)]]		write:	[1 to: length do:					[:i | self writePointerField: ((perm at: i) == nil										ifTrue: [nil]										ifFalse: [obj basicAt: (perm at: i)])]]! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/28/97 00:15'!writeHashArrayPermuted: obj useIdentity: useIdentity	"Elements of a Set's hashed array need to be reordered according to new oops."	| length perm |	self new: obj class: obj class length: (length _ self sizeInWordsOf: obj)		trace:	[1 to: length do: [:i | self trace: (obj basicAt: i)].				"Now get permutation based on new oops"				perm _ self permutationFor: obj useIdentity: useIdentity]		write:	[1 to: length do:					[:i | self writePointerField: ((perm at: i) == nil										ifTrue: [nil]										ifFalse: [obj basicAt: (perm at: i)])]]! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/27/97 20:44'!writeIdentitySet: obj 	"Elements of a Set need to be reordered owing to new oops."	^ self writeSet: obj useIdentity: true! !!SystemTracer methodsFor: 'tracing and writing'!writeMethod: obj	| nptrs |	nptrs _ obj numLiterals + 1.	self new: obj		class: obj class		length: (self sizeInWordsOf: obj)		trace: [2 to: nptrs do: [:i | self trace: (obj objectAt: i)]]		write: 			[self writePointerField: (self methodHeader: obj).			2 to: nptrs do: [:i | self writePointerField: (obj objectAt: i)].			nptrs * 4 + 1 to: obj size do: [:i | file nextPut: (obj at: i)].			file padToNextLongPut: 0]! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/28/97 00:22'!writeMethodDictionary: obj	"Elements of a Set need to be reordered according to new oops."	| perm |	self new: obj class: obj class length: (self sizeInWordsOf: obj)		trace:	["First need to map the indexable fields (selectors)"				1 to: obj basicSize do: [:i | self trace: (obj basicAt: i)].				"Now get permutation based on new oops"				perm _ self permutationFor: obj useIdentity: true.				"Map named inst vars *assuming* 2nd is the hash array"				1 to: obj class instSize do:					[:i | i=2 ifTrue: ["Permute the hash array and note its permutation"									self writeHashArray: (obj instVarAt: i) permutedBy: perm]							ifFalse: ["Other fields get traced normally"									self trace: (obj instVarAt: i)]]]		write:	[1 to: obj class instSize do:					[:i | self writePointerField: (obj instVarAt: i)].				1 to: obj basicSize do:					[:i | self writePointerField: ((perm at: i) == nil											ifTrue: [nil]											ifFalse: [obj basicAt: (perm at: i)])]]! !!SystemTracer methodsFor: 'tracing and writing'!writePointers: obj	| length |	self new: obj		class: obj class		length: (length _ self sizeInWordsOf: obj)		trace: [1 to: length do: [:i | self trace: (obj instVarAt: i)]]		write: [1 to: length do: [:i | self writePointerField: (obj instVarAt: i)]]! !!SystemTracer methodsFor: 'tracing and writing'!writeProcess: obj 	"Substitute new initialProcess for current."	| newObj instSize |	newObj _ obj == Processor activeProcess			ifTrue: [initialProcess]			ifFalse: [obj].	self new: obj		class: newObj class		length: (instSize _ newObj class instSize)		trace: [1 to: instSize do:				[:i | self trace: (newObj instVarAt: i)]]		write: [1 to: instSize do:				[:i | self writePointerField: (newObj instVarAt: i)]]! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/27/97 20:43'!writeSet: obj 	"Elements of a Set need to be reordered owing to new oops."	^ self writeSet: obj useIdentity: false! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/28/97 00:01'!writeSet: obj useIdentity: useIdentity	"Elements of a Set need to be reordered according to new oops."	| |	self basicSize > 0 ifTrue: [self halt. "Not clear how to permute this kind of set"].	self new: obj class: obj class length: (self sizeInWordsOf: obj)		trace: 			["Map named inst vars *assuming* 2nd is the hash array"			1 to: obj class instSize do:				[:i | i=2 ifTrue: ["Permute the hash array and note its permutation"								self writeHashArrayPermuted: (obj instVarAt: i)											useIdentity: useIdentity]						ifFalse: ["Other fields get traced normally"								self trace: (obj instVarAt: i)]]]		write: 			[1 to: obj class instSize do:				[:i | self writePointerField: (obj instVarAt: i)]]! !!SystemTracer methodsFor: 'tracing and writing'!writeWords: obj	self new: obj		class: obj class		length: (self sizeInWordsOf: obj)		trace: []		write: [1 to: obj basicSize do: [:i | self write4Bytes: (obj instVarAt: i)]]! !!SystemTracer methodsFor: 'private' stamp: 'di 9/28/97 14:46'!formatOf: obj	"Make the code that tells the format of this object.	It is like the class's instSpec, but with added low bits for byte size""       0=      No pointer fields        1=      Fixed pointer fields only        2=      Var pointer fields only        3=      Fixed and var pointer fields         4=      unused        5=      unused        6=      var long (bit) fields only        7=      unused         8-11=   var byte fields only                low 2 bits are low 2 bits of size **        12-15   methods -- ie #literals in header, followed by var bytes                same interpretation of low 2 bits"	| class spec |	class _ obj class.	spec _ class instSpec.    "just use what's there"	spec < 8 ifTrue: [^ spec]			ifFalse: ["For byte objects, size = wordSize - spec.lowBits"					^ spec + (3 - (obj size+3 bitAnd: 3))]! !!SystemTracer methodsFor: 'private' stamp: 'di 9/28/97 14:46'!formatOfCls: class	"Return the full word value that encodes instSize, bits, bytes, and variable."	"See the comment in Behavior format:variable:words:pointers:"	^ class format    "just use what's there"! !!SystemTracer methodsFor: 'private' stamp: 'di 9/29/97 08:48'!headersFor: obj withHash: hash	"Create three header words for this object.  Length, class, header bits."	"Three possibilities:		Length, class, header bits		0, class, header bits		0,0, header bits"	| header3 header2 header1 cix sizeFld |	"3 gc bits"	header1 _ 0.  "Mark, old, dirty"	header1 _ header1 bitShift: 12.	"next fld is 12 bits"	header1 _ header1 + (hash bitAnd: 16rFFF).	header1 _ header1 bitShift: 5.	sizeFld _ (self sizeInWordsOf: obj) + 1.	"size in long words, incl hdr0"	cix _ compactClasses indexOf: obj class.	"0 means need full word"	header2 _ self mapAt: obj class.	header1 _ header1 + (cix bitAnd: 16r1F).	header1 _ header1 bitShift: 4.	header1 _ header1 + (self formatOf: obj).	"Class characteristics"	header1 _ header1 bitShift: 6.	sizeFld > 16r3F		ifTrue: [header3 _ sizeFld bitShift: 2.				sizeFld _ 0]		ifFalse: [header3 _ 0].	header1 _ header1 + sizeFld.	header1 _ header1 bitShift: 2.	header3 > 0 ifTrue:		["3-word: type=0"		^ Array with: header3+0 with: header2+0 with: header1+0].	cix = 0 ifTrue:		[ "2-word: type=1"		^ Array with: header2+1 with: header1+1].	"1-word: type=3"	^ Array with: header1+3! !!SystemTracer methodsFor: 'private' stamp: 'di 9/28/97 14:45'!methodHeader: obj	"Return the integer encoding the attributes of this method"	"See the comment in CompiledMethod newBytes:nArgs:nTemps:nStack:nLits:primitive:"	^ obj header  "just use what's there"! !!SystemTracer methodsFor: 'private' stamp: 'di 9/28/97 14:47'!newHashFor: obj	"If an object has a hash derived from its value, it will override on the way here.	This object can use anything as a hash.  Derive one from its oop."	(self mapAt: obj) = UnassignedOop		ifTrue: [self halt]		ifFalse: [^ self mapHashAt: obj]  ! !!SystemTracer methodsFor: 'private' stamp: 'di 9/27/97 20:40'!permutationFor: array useIdentity: useIdentity	"Return an inverse permutation for an array to permute it according to	the mapped oop values. The keys in array MUST have been mapped."	| len perm key hash |	len _ array basicSize.  	perm _ Array new: len.	1 to: len do:		[:i | key _ array basicAt: i.		(key == nil or: [self hasClamped: key])		  ifFalse:			[hash _ useIdentity					ifTrue: [key identityHashMappedBy: self]					ifFalse: [key hashMappedBy: self].			hash _ hash \\ len + 1.			[(perm at: hash) == nil] 				whileFalse:				[hash _ (hash = len ifTrue: [1] ifFalse: [hash + 1])].			perm at: hash put: i]].	^ perm! !!SystemTracer methodsFor: 'private'!sizeInWordsOf: anObject"NOTE: This is the new length of the object in LONG WORDS.		Does not include the class (header) word."	| class |	class _ anObject class.	class isBytes ifTrue: [^ anObject basicSize+3 // 4].	class isBits ifTrue: [^ anObject basicSize].	"in two byte chunks"	class isVariable ifTrue: [^ class instSize + anObject basicSize].	^ class instSize! !!SystemTracer methodsFor: 'private' stamp: 'di 9/28/97 14:20'!write4Bytes: bits 	"Avoid overhead of large integers and nextWord:put:."	| posBits bytes |	bits positive		ifTrue: [posBits _ bits]		ifFalse: ["Change rep to twos complement."				posBits _ 16rFFFFFFFF+(bits+1)].	bytes _ ByteArray new: 4.	bytes at: 1 put: (posBits digitAt: 4).	bytes at: 2 put: (posBits digitAt: 3).	bytes at: 3 put: (posBits digitAt: 2).	bytes at: 4 put: (posBits digitAt: 1).	file nextPutAll: bytes! !!SystemTracer methodsFor: 'private' stamp: 'di 9/28/97 12:03'!writePointerField: obj 	| newOop |	obj class == SmallInteger ifTrue: 		[obj >= 0 ifTrue: [newOop _ obj * 2 + 1]				ifFalse: [newOop _ (16r80000000 + obj) * 2 + 1].		self write4Bytes: newOop.		^ obj].			"normal pointers"	(newOop _ self mapAt: obj) = Clamped		ifTrue: ["If object in this field is not being traced, put out nil."				self write4Bytes: NewNil]		ifFalse: [self write4Bytes: newOop]! !!SystemTracer class methodsFor: 'instance creation' stamp: 'di 9/27/97 14:01'!initialize    "SystemTracer initialize"	"These consts are negative, so they will not match any oop.	It is important, though, that UnassignedOop, at least, have	zero in its low-order 2 bits, (like all oops) so that the use of +	to merge the header type bits (happens in new:class:...) will	not do weird things."	Clamped _ -4.  "Flag clamped objects in oopMap"		UnassignedOop _ -8.  "Flag unassigned oops in oopMap"! !!SystemTracer class methodsFor: 'instance creation' stamp: 'di 9/27/97 12:30'!writeClone  "SystemTracer writeClone"	| tracer |	tracer _ self new.	"Delay shutDown."  "part of Smalltalk processShutDownList."	tracer doit.   " <-- execution in clone resumes after this send"	tracer == nil "will be nil in clone, since it is clamped"		ifTrue: [Smalltalk processStartUpList].	^ tracer! !!SystemWindow methodsFor: 'initialization' stamp: 'di 6/16/97 15:02'!defaultExtent	^ 400@300! !!SystemWindow methodsFor: 'initialization' stamp: 'di 6/16/97 15:03'!extent: newExtent	| inner |	super extent: newExtent.	inner _ self innerBounds.	closeBox position: (inner topLeft + 2).	collapseBox position: (inner topRight - (collapseBox width@0) + (-2@2)).	label bounds: (label bounds align: label bounds topCenter with: inner topCenter).! !!SystemWindow methodsFor: 'initialization' stamp: 'di 6/18/97 05:32'!initialize	super initialize.	borderColor _ #raised.	borderWidth _ 2.	color _ Color r: 0.6 g: 0.2 b: 0.2.	paneColor _ Color r: 0.8 g: 1.0 b: 0.599.	self addMorph: (label _ StringMorph new contents: labelString;						font: ((TextStyle default fontAt: 2) emphasized: 1)).	self addMorph: (closeBox _ SimpleButtonMorph new borderWidth: 2; color: paneColor;							label: 'X'; actionSelector: #delete; target: self).	self addMorph: (collapseBox _ SimpleButtonMorph new borderWidth: 2; color: paneColor;							label: 'O'; actionSelector: #collapse; target: self).	self initPanes.	self allMorphsDo: [:m | m paneColor: paneColor].	self extent: self defaultExtent! !!SystemWindow methodsFor: 'initialization' stamp: 'di 6/16/97 15:06'!initPanes	"To be overridden by subclasses"! !!SystemWindow methodsFor: 'initialization' stamp: 'di 6/16/97 14:46'!labelHeight	^ label height + 1! !!SystemWindow methodsFor: 'initialization' stamp: 'di 6/18/97 05:31'!setLabel: aString	labelString _ aString! !!SystemWindow class methodsFor: 'instance creation' stamp: 'di 6/23/97 00:12'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ self ~~ SystemWindow! !!SystemWindow class methodsFor: 'instance creation' stamp: 'di 6/18/97 05:31'!labelled: labelString	^ (self basicNew setLabel: labelString) initialize! !!TAssignmentNode methodsFor: 'all'!bindVariablesIn: aDictionary	variable _ variable bindVariablesIn: aDictionary.	expression _ expression bindVariablesIn: aDictionary.! !!TAssignmentNode methodsFor: 'all'!copyTree	^self class new		setVariable: variable copyTree		expression: expression copyTree! !!TAssignmentNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	| sel |	self isVariableUpdatingAssignment ifTrue: [		variable emitCCodeOn: aStream level: level generator: aCodeGen.		sel _ expression selector.		sel = #+			ifTrue: [aStream nextPutAll: ' += ']			ifFalse: [aStream nextPutAll: ' -= '].			expression args first emitCCodeOn: aStream level: level generator: aCodeGen.	] ifFalse: [		variable emitCCodeOn: aStream level: level generator: aCodeGen.		aStream nextPutAll: ' = '.		expression emitCCodeOn: aStream level: level generator: aCodeGen.	].! !!TAssignmentNode methodsFor: 'all'!expression	^expression! !!TAssignmentNode methodsFor: 'all'!inlineMethodsUsing: aDictionary	variable inlineMethodsUsing: aDictionary.	expression inlineMethodsUsing: aDictionary.! !!TAssignmentNode methodsFor: 'all'!isAssignment	^true! !!TAssignmentNode methodsFor: 'all'!isVariableUpdatingAssignment	"Return true if this assignment statement is of one of the forms:		var = var + ...		var = var - ...	Such assignments statements can exploit the C updating assignment operators. For example, 'x += 4' can be generated instead of 'x = x + 4'. This produces better code under some C compilers, most notably the CodeWarrior 68K compiler."	| sel |	(expression isSend and: [expression receiver isVariable]) ifFalse: [^ false].	sel _ expression selector.	^ (expression receiver name = variable name) and: [(sel = #+) or: [sel = #-]]! !!TAssignmentNode methodsFor: 'all'!nodesDo: aBlock	variable nodesDo: aBlock.	expression nodesDo: aBlock.	aBlock value: self.! !!TAssignmentNode methodsFor: 'all'!printOn: aStream level: level	variable printOn: aStream level: level.	aStream nextPutAll: ' _ '.	expression printOn: aStream level: level + 2.! !!TAssignmentNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!removeAssertions	expression removeAssertions! !!TAssignmentNode methodsFor: 'all'!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		variable _ variable replaceNodesIn: aDictionary.		expression _ expression replaceNodesIn: aDictionary.		self]! !!TAssignmentNode methodsFor: 'all'!setVariable: varNode expression: expressionNode	variable _ varNode.	expression _ expressionNode.! !!TAssignmentNode methodsFor: 'all'!variable	^variable! !!TCaseStmtNode methodsFor: 'all'!bindVariablesIn: aDictionary	expression _ expression bindVariablesIn: aDictionary.	cases _ cases collect: [ :c | c bindVariablesIn: aDictionary ].! !!TCaseStmtNode methodsFor: 'all'!cases	^cases! !!TCaseStmtNode methodsFor: 'all'!copyTree	^self class new		setExpression: expression copyTree		firsts: firsts copy		lasts: lasts copy		cases: (cases collect: [ :case | case copyTree ])! !!TCaseStmtNode methodsFor: 'all'!customizeCase: caseParseTree forVar: varName from: firstIndex to: lastIndex	"Return a collection of copies of the given parse tree, each of which has the value of the case index substituted for the given variable."	| newCases dict newCase |	newCases _ OrderedCollection new.	firstIndex to: lastIndex do: [ :caseIndex |		dict _ Dictionary new.		dict at: varName put: (TConstantNode new setValue: caseIndex).		newCase _ caseParseTree copyTree bindVariablesIn: dict.		self fixSharedCodeBlocksForCase: caseIndex in: newCase.		newCases addLast: newCase.	].	^ newCases! !!TCaseStmtNode methodsFor: 'all'!customizeShortCasesForDispatchVar: varName	"Make customized versions of a short bytecode methods, substituting a constant having the case index value for the given variable. This produces better code for short bytecodes such as instance variable pushes that encode the index of the instance variable in the bytecode."	| newFirsts newLasts newCases l f case expanded |	newFirsts _ OrderedCollection new.	newLasts _ OrderedCollection new.	newCases _ OrderedCollection new.	1 to: cases size do: [ :i |		l _ lasts at: i.		f _ firsts at: i.		case _ cases at: i.		expanded _ false.		(l - f) > 1 ifTrue: [  "case code covers multiple cases"			case nodeCount < 45 ifTrue: [				newFirsts addAll: (f to: l) asArray.				newLasts addAll: (f to: l) asArray.				newCases addAll: (self customizeCase: case forVar: varName from: f to: l).				expanded _ true.			].		].		expanded ifFalse: [			self fixSharedCodeBlocksForCase: f in: case.			newFirsts addLast: f.			newLasts addLast: l.			newCases addLast: case.		].	].	firsts _ newFirsts asArray.	lasts _ newLasts asArray.	cases _ newCases asArray.! !!TCaseStmtNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	| indent |	indent _ (String new: level) collect: [ :ch | Character tab ].	aStream nextPutAll: 'switch ('.	expression emitCCodeOn: aStream level: level generator: aCodeGen.	aStream nextPutAll: ') {'; cr.	1 to: cases size do: [ :i |		(firsts at: i) to: (lasts at: i) do: [ :caseIndex |			aStream nextPutAll: indent, 'case ', caseIndex printString, ':'; cr.		].		(cases at: i) emitCCodeOn: aStream level: level + 1 generator: aCodeGen.		aStream nextPutAll: indent; tab; nextPutAll: 'break;'.		aStream cr.	].	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!TCaseStmtNode methodsFor: 'all'!expression	^expression! !!TCaseStmtNode methodsFor: 'all' stamp: 'ikp 1/2/98 23:45'!fixSharedCodeBlocksForCase: caseIndex in: caseParseTree	"Process 'sharedCode' directives in the given parse tree. The sharedCode directive allows code replicated in different arms of a case statement to be shared. The replicated code must be the final code of the case so that it ends with a break out of the case statement. The replicated code will be generated in exactly one arm of the case statement; other instances of the shared code will be replaced by branches to that single instance of the code."	| copying oldStmts newStmts stmt codeBlockName |	caseParseTree  nodesDo: [ :node |		node isStmtList ifTrue: [			copying _ true.			oldStmts _ node statements asArray.			newStmts _ nil.  "becomes an OrderedCollection if sharedCode block is found"			1 to: oldStmts size do: [ :i |				copying ifTrue: [					stmt _ oldStmts at: i.					(stmt isSend and: [stmt selector = #sharedCodeNamed:inCase:]) ifTrue: [						newStmts _ (oldStmts copyFrom: 1 to: i - 1) asOrderedCollection.						codeBlockName _ stmt args first value.						(stmt args last value = caseIndex) ifTrue: [							newStmts add: 								(TLabeledCommentNode new setLabel: codeBlockName comment: '').						] ifFalse: [							newStmts add: (TGoToNode new setLabel: codeBlockName).							copying _ false.  "don't copy remaining statements"						].					] ifFalse: [						newStmts = nil ifFalse: [newStmts add: stmt].					].				] ifFalse: [	"ikp: this permits explicit returns before 'goto aSharedCodeLabel'"					stmt _ oldStmts at: i.					(stmt isLabel and: [stmt label ~= nil]) ifTrue: [newStmts add: stmt].				].			].			newStmts = nil ifFalse: [node setStatements: newStmts].		].	].! !!TCaseStmtNode methodsFor: 'all'!inlineMethodsUsing: aDictionary	expression inlineMethodsUsing: aDictionary.	cases do: [ :c | c inlineMethodsUsing: aDictionary ].! !!TCaseStmtNode methodsFor: 'all'!isCaseStmt	^true! !!TCaseStmtNode methodsFor: 'all'!nodesDo: aBlock	expression nodesDo: aBlock.	cases do: [ :c | c nodesDo: aBlock ].	aBlock value: self.! !!TCaseStmtNode methodsFor: 'all'!printOn: aStream level: level	aStream crtab: level.	aStream nextPutAll: 'select '.	expression printOn: aStream level: level.	aStream nextPutAll: ' in'.	1 to: cases size do: [ :i |		(firsts at: i) to: (lasts at: i) do: [ :caseIndex |			aStream crtab: level.			aStream nextPutAll: 'case ', caseIndex printString, ':'.		].		aStream crtab: level + 1.		(cases at: i) printOn: aStream level: level + 1.	].	aStream crtab: level.	aStream nextPutAll: 'end select'.! !!TCaseStmtNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!removeAssertions	expression removeAssertions.	cases do: [ :case | case removeAssertions ].! !!TCaseStmtNode methodsFor: 'all'!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		expression _ expression replaceNodesIn: aDictionary.		cases _ cases collect: [ :c | c replaceNodesIn: aDictionary ].		self]! !!TCaseStmtNode methodsFor: 'all'!setExpression: aNode firsts: firstsList lasts: lastsList cases: caseList	expression _ aNode.	firsts _ firstsList.	lasts _ lastsList.	cases _ caseList.! !!TCaseStmtNode methodsFor: 'all'!setExpression: aNode selectors: selectorList	"Initialize the node from the given set of selectors."	"Note: Each case is a statement list with containing one statement, a send to self of a selector from the given selector list. Having statement list nodes makes inlining easier later."	| selfNode stmt lastSel firstInRun sel |	expression _ aNode.	selfNode _ TVariableNode new setName: 'self'.	firsts _ OrderedCollection new: 400.	lasts _ OrderedCollection new: 400.	cases _ OrderedCollection new: 400.	lastSel _ selectorList first.	firstInRun _ 0.	1 to: selectorList size do: [ :i |		sel _ selectorList at: i.		sel ~= lastSel ifTrue: [			firsts add: firstInRun.			lasts add: i - 2.			stmt _ TSendNode new setSelector: lastSel receiver: selfNode arguments: #().			cases add: (TStmtListNode new setArguments: #() statements: (Array with: stmt)).			lastSel _ sel.			firstInRun _ i - 1.		].	].	firsts add: firstInRun.	lasts add: selectorList size - 1.	stmt _ TSendNode new setSelector: lastSel receiver: selfNode arguments: #().	cases add: (TStmtListNode new setArguments: #() statements: (Array with: stmt)).! !!TConstantNode methodsFor: 'all'!copyTree	^self class new		setValue: value! !!TConstantNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C literal."	aStream nextPutAll: (aCodeGen cLiteralFor: value).! !!TConstantNode methodsFor: 'all'!isConstant	^true! !!TConstantNode methodsFor: 'all'!isLeaf	^true! !!TConstantNode methodsFor: 'all'!printOn: aStream level: level	value storeOn: aStream.! !!TConstantNode methodsFor: 'all'!setValue: anObject	value _ anObject.! !!TConstantNode methodsFor: 'all'!value	^value! !Represents a tempo change in a MIDI score.!!TempoEvent methodsFor: 'all' stamp: 'jm 12/30/97 10:10'!isTempoEvent	^ true! !!TempoEvent methodsFor: 'all' stamp: 'jm 1/3/98 08:34'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': '.	((120.0 * (500000.0 / tempo)) roundTo: 0.01) printOn: aStream.	aStream nextPut: $).! !!TempoEvent methodsFor: 'all' stamp: 'jm 12/30/97 10:09'!tempo	^ tempo! !!TempoEvent methodsFor: 'all' stamp: 'jm 12/30/97 10:09'!tempo: anInteger	tempo _ anInteger.! !TempVariableNode comment:'I am a parse tree leaf representing a temporary variable'!!TempVariableNode methodsFor: 'initialize-release'!isArg: aBoolean	isAnArg _ aBoolean.	isAnArg ifTrue: [hasDefs _ true]! !!TempVariableNode methodsFor: 'initialize-release'!name: varName index: i type: type scope: level	"Only used for initting temporary variables"	name _ varName.	self key: varName		index: i		type: type.	isAnArg _ hasDefs _ hasRefs _ false.	scope _ level! !!TempVariableNode methodsFor: 'initialize-release'!nowHasDef	hasDefs _ true! !!TempVariableNode methodsFor: 'initialize-release'!nowHasRef	hasRefs _ true! !!TempVariableNode methodsFor: 'initialize-release'!scope: level	"Note scope of temporary variables.	Currently only the following distinctions are made:		0	outer level: args and user-declared temps		1	block args and doLimiT temps		-1	a block temp that is no longer active		-2	a block temp that held limit of to:do:"	scope _ level! !!TempVariableNode methodsFor: 'testing'!assignmentCheck: encoder at: location	isAnArg ifTrue: [^ location]			ifFalse: [^ -1]! !!TempVariableNode methodsFor: 'testing'!isArg	^ isAnArg! !!TempVariableNode methodsFor: 'testing'!isTemp	^ true! !!TempVariableNode methodsFor: 'testing'!isUndefTemp	^ hasDefs not! !!TempVariableNode methodsFor: 'testing'!isUnusedTemp	^ hasRefs not! !!TempVariableNode methodsFor: 'testing'!scope	^ scope! !!TempVariableNode methodsFor: 'printing'!printOn: aStream indent: level 	aStream withAttribute: (TextColor color: Color blue)			do: [aStream nextPutAll: name]! !!TestCClass1 methodsFor: 'all'!arg1: a arg2: b	"CCodeGenerator new initialize addClass: TestCClass1"	| i j k |	self var: #i declareC: 'char *i'.	i _ 'abc'.	j _ 2.	k _ 3.! !!TestCClass1 methodsFor: 'all'!ifTests	true ifTrue: [		self print: 'true case'	].	true ifFalse: [		self print: 'false case'	].	true ifTrue: [		self print: 'true case'	] ifFalse: [		self print: 'false case'	].	true ifFalse: [		self print: 'false case'	] ifTrue: [		self print: 'true case'	].! !!TestCClass1 methodsFor: 'all'!isIntegerValue: intValue	"Copied from ObjectMemory."	^ (intValue bitXor: (intValue << 1)) >= 0! !!TestCClass1 methodsFor: 'all'!loopTests	| v |	v _ 0.	[v < 10] whileTrue: [ self printNum: v.  v _ v + 1 ].	self print: ''.	[v < 1] whileFalse: [ self printNum: v.  v _ v - 1 ].	self print: ''.	1 to: 10 do: [ :i | self printNum: i ].	self print: ''.	1 to: 10 by: 2 do: [ :i | self printNum: i ].	self print: ''.! !!TestCClass1 methodsFor: 'all'!method1	"(CCodeGenerator new initialize addClass: TestCClass1) codeString"	x & y ifTrue: [		x _ 10.		y _ 20.	].	y _ nil + 3.	x = nil ifTrue: [ x _ 18 ].	^nil! !!TestCClass1 methodsFor: 'all'!method2	self method1; method8: 0; setX: 10 Y: 20.! !!TestCClass1 methodsFor: 'all'!method3	x > 0 ifTrue: [ ^x ] ifFalse: [ ^y ].! !!TestCClass1 methodsFor: 'all'!method4	x _ 0.	y _ 0.	[x < 100] whileTrue: [		y _ y + x.		x _ x + 1.	].	^y! !!TestCClass1 methodsFor: 'all'!method5	self inline: true.	x & y.	x | y.	x and: [y].	x or: [y].	x not.	x + y.	x - y.	x * y.	x // y.	x \\ y.	x min: y.	x max: y.	x bitAnd: y.	x bitOr: y.	x bitXor: y.	x bitInvert32.	x bitShift: y.	x >> y.	x << y.	x < y.	x <= y.	x = y.	x >= y.	x > y.	x ~= y.	x == y.	x isNil.	x notNil.	[x > y] whileTrue: [ x _ x + 1 ].	[x > y] whileFalse: [ x _ x + 1 ].	x > y ifTrue: [ x _ x - 1 ].	x > y ifFalse: [ x _ x + 1 ].	x > y ifTrue: [ x _ x - 1 ] ifFalse: [ x _ x + 1 ].	x > y ifFalse: [ x _ x + 1 ] ifTrue: [ x _ x - 1 ].	x at: 3.	x at: 3 put: y.	self integerValueOf: x.	self integerObjectOf: x.	(self isIntegerObject: x) ifTrue: [ x _ x - 1 ].	(self isIntegerValue: x) ifTrue: [ x _ x - 1 ].	self cCoerce: x * (y - 1) to: 'int'.	x _ x + 1.	x _ x - 1.	x preDecrement.	y preIncrement > 0 ifTrue: [ x _ x + 1 ].! !!TestCClass1 methodsFor: 'all'!method6	self dispatchOn: x in: #(f1 f2 f3 f4 f5).! !!TestCClass1 methodsFor: 'all'!method7	| t1 |	self method1.	self method2.	t1 _ self method3.	self method4.	self method5.! !!TestCClass1 methodsFor: 'all'!method8: arg	| a |	self returnTypeC: 'float'.	self var: #a    declareC: 'float a = 0'.	self var: #arg declareC: 'float arg'.	self cCode: 'a = arg * 3.14159'.	^a! !!TestCClass1 methodsFor: 'all'!print: val	self cCode: 'printf("%d\n", val)'.! !!TestCClass1 methodsFor: 'all'!printNum: i	self cCode: 'printf("%d ", i)'.! !!TestCClass1 methodsFor: 'all'!setX: newX Y: newY	x _ newX min: newY.	y _ newY.! !!TestCClass2 methodsFor: 'all'!atAllPut	| i |	i _ VectSize.	[i > 0] whileTrue: [		vect at: i put: 5.		i _ i - 1.	].	(vect at: 1) ~= 5 ifTrue: [ self error: 'AtAllPutBenchmark' ].! !!TestCClass2 methodsFor: 'all'!error: s	"Print an error message and exit."	self print: 'Error in %s\n' f: s.	self exit: -1.! !!TestCClass2 methodsFor: 'all'!incrementAll	| oldVal i |	oldVal _ vect at: 1.	i _ VectSize.	[i > 0] whileTrue: [		vect at: i put: ((vect at: i) + 1).		i _ i - 1.	].	(vect at: 1) ~= (oldVal + 1) ifTrue: [ self error: 'IncrementAllBenchmark' ].! !!TestCClass2 methodsFor: 'all'!initialize	VectSize _ 10000.	vect _ Array new: VectSize.! !!TestCClass2 methodsFor: 'all'!main	| startTicks ticks |	self printf: 'atAllPut: '.	startTicks _ self clock.	self atAllPut.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'incrementAll: '.	self incrementAll.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'nestedWhileLoop: '.	self nestedWhileLoop.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sieve: '.	self sieve.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sumAll: '.	self sumAll.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sumFromTo: '.	self sumFromTo.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.! !!TestCClass2 methodsFor: 'all'!nestedWhileLoop	| sum i j |	sum _ 0.	i _ 1000.	[i > 0] whileTrue: [		j _ 100.		[j > 0] whileTrue: [			sum _ sum + 1.			j _ j - 1.		].		i _ i - 1.	].	sum ~= 100000 ifTrue: [ self error: 'NestedWhileBenchmark' ].! !!TestCClass2 methodsFor: 'all'!sieve	| flagsSize flags primeCount i k |	flagsSize _ 8190.	flags _ Array new: flagsSize.	i _ flagsSize.	[i > 0] whileTrue: [		flags at: i put: true.		i _ i - 1.	].	primeCount _ 0.	i _ 2.	[i <= flagsSize] whileTrue: [		(flags at: i) ifTrue: [			primeCount _ primeCount + 1. "i is a prime"			k _ i + i.			[k <= flagsSize] whileTrue: [				flags at: k put: false. "k is not a prime; it is a multiple of i"				k _ k + i.			].		].		i _ i + 1.	].	primeCount ~= 1027 ifTrue: [ self error: 'SieveBenchmark' ].! !!TestCClass2 methodsFor: 'all'!sumAll	| elementVal sum i |	elementVal _ vect at: 1.	sum _ 0.	i _ VectSize.	[i > 0] whileTrue: [		sum _ sum + (vect at: i).		i _ i - 1.	].	sum ~= (VectSize * elementVal) ifTrue: [ self error: 'SumAllBenchmark' ].! !!TestCClass2 methodsFor: 'all'!sumFromTo	| sum i j |	i _ 10.	[i > 0] whileTrue: [		sum _ 0.		j _ 10000.		[j > 0] whileTrue: [			sum _ sum + j.			j _ j - 1.		].		i _ i - 1.	].	sum ~= 50005000 ifTrue: [ self error: 'SumFromToBenchmark' ].! !!TestCClass2 class methodsFor: 'testing'!test	"TestCClass2 test"	"(CCodeGenerator new initialize addClass: TestCClass2) codeString"	| bm |	bm _ self new initialize.	Transcript show: 'atAllPut: '.	Transcript show: (Time millisecondsToRun: [bm atAllPut]) printString; cr.	Transcript show: 'incrementAll: '.	Transcript show: (Time millisecondsToRun: [bm incrementAll]) printString; cr.	Transcript show: 'nestedWhileLoop: '.	Transcript show: (Time millisecondsToRun: [bm nestedWhileLoop]) printString; cr.	Transcript show: 'sieve: '.	Transcript show: (Time millisecondsToRun: [bm sieve]) printString; cr.	Transcript show: 'sumAll: '.	Transcript show: (Time millisecondsToRun: [bm sumAll]) printString; cr.	Transcript show: 'sumFromTo: '.	Transcript show: (Time millisecondsToRun: [bm sumFromTo]) printString; cr.! !!TestCClass3 methodsFor: 'all'!dispatchOn: currentBytecode in: selectorArray	"Simulate a case statement via selector table lookup. The given integer must be between 0 and (selectorArray size - 1), inclusive. Send the selector at (currentBytecode + 1) in selectorArray to the receiver. For speed, no extra range test is done, since it is done by the at: operation."	"Note: Delete this method from the generated code."	"assert: (currentBytecode >= 0) | (currentBytecode < selectorArray size)"	self perform: (selectorArray at: (currentBytecode + 1)).! !!TestCClass3 methodsFor: 'all'!f1	| local r |	local _ self functionWithLabel: 1.	r _ 7.	self print: 'f1'.! !!TestCClass3 methodsFor: 'all'!f2	| local i |	local _ 2.	i _ self functionWithLabel: -2.	i > 0 ifTrue: [ ^ -1 ].	self print: 'f2'.! !!TestCClass3 methodsFor: 'all'!f3	self sharedCodeNamed: 'sharedCode' inCase: 5.	self print: 'f3'.! !!TestCClass3 methodsFor: 'all'!f4	self sharedCodeNamed: 'sharedCode' inCase: 5.	self print: 'f4'.! !!TestCClass3 methodsFor: 'all'!f5	self sharedCodeNamed: 'sharedCode' inCase: 5.	self print: 'f5'.! !!TestCClass3 methodsFor: 'all'!functionWithLabel: arg	arg > 0 ifTrue: [ ^1 ] ifFalse: [ ^-1 ].! !!TestCClass3 methodsFor: 'all'!interpret	"TestCClass3 new main"	"(CCodeGenerator new initialize addClass: TestCClass3) codeString"	0 to: 9 do: [ :currentBytecode |		self dispatchOn: currentBytecode in: #(f1 f2 f2 f3 f3 f3 f4 f4 f5 f2).	].! !!TestCClass3 methodsFor: 'all'!print: s	self var: #s declareC: 'char *s'.	self cCode: 'printf("%s", s)'.! !I represent a character string that has been marked with abstract changes in character appearance. Actual display is performed in the presence of a TextStyle which indicates, for each abstract code, an actual font to be used.  A Text associates a set of TextAttributes with each character in its character string.  These attributes may be font numbers, emphases such as bold or italic, or hyperling actions.  Font numbers are interpreted relative to whatever textStyle appears, along with the text, in a Paragraph.  Since most characters have the same attributes as their neighbors, the attributes are stored in a RunArray for efficiency.  Each of my instances has	string		a String	runs		a RunArray!]style[(148 9 97 13 237 9 163 6 10 8)f1,f1LTextStyle Comment;,f1,f1LTextAttribute Hierarchy;,f1,f1LParagraph Comment;,f1,f1LString Comment;,f1,f1LRunArray Comment;!!Text methodsFor: 'accessing' stamp: 'di 11/10/97 12:53'!rangeOf: attribute startingAt: index	"This is stupid, slow code, but it works"	| start stop |	start _ index.	[start > 1 and: [(self attributesAt: start-1) includes: attribute]]		whileTrue: [start _ start - 1].	stop _ index-1.	[stop < self size and: [(self attributesAt: stop+1) includes: attribute]]		whileTrue: [stop _ stop + 1].	^ start to: stop! !!Text methodsFor: 'accessing' stamp: 'tk 12/30/97 07:17'!replaceFrom: start to: stop with: aText	| txt |	txt _ aText asText.	"might be a string"	string _ string copyReplaceFrom: start to: stop with: txt string.	runs _ runs copyReplaceFrom: start to: stop with: txt runs! !!Text methodsFor: 'comparing'!= other	^ other isText		ifTrue:	[string = other string and: [runs = other asText runs]]		ifFalse: [false]! !!Text methodsFor: 'comparing'!isText	^ true! !!Text methodsFor: 'copying'!copy	^ self class new setString: string copy setRuns: runs copy! !!Text methodsFor: 'copying' stamp: 'tk 1/7/98 10:58'!copyReplaceTokens: oldSubstring with: newSubstring 	"Replace all occurrences of oldSubstring that are surrounded	by non-alphanumeric characters"	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: true	"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick'"! !!Text methodsFor: 'copying' stamp: 'di 11/9/97 17:13'!deepCopy	^ self copy "Both string and runs are assumed to be read-only"! !!Text methodsFor: 'emphasis'!addAttribute: att 	^ self addAttribute: att from: 1 to: self size! !!Text methodsFor: 'emphasis'!addAttribute: att from: start to: stop 	"Set the attribute for characters in the interval start to stop."	runs _  runs copyReplaceFrom: start to: stop			with: ((runs copyFrom: start to: stop)				mapValues:				[:attributes | Text addAttribute: att toArray: attributes])! !!Text methodsFor: 'emphasis'!allBold 	"Force this whole text to be bold."	string size = 0 ifTrue: [^self].	self makeBoldFrom: 1 to: string size! !!Text methodsFor: 'emphasis'!attributesAt: characterIndex 	"Answer the code for characters in the run beginning at characterIndex."	| attributes |	self size = 0		ifTrue: [^ Array with: (TextFontChange new fontNumber: 1)].  "null text tolerates access"	attributes _ runs at: characterIndex.	^ attributes	! !!Text methodsFor: 'emphasis' stamp: 'di 11/10/97 13:36'!find: attribute	"Return the first interval over which this attribute applies"	| begin end |	begin _ 0.	runs withStartStopAndValueDo:		[:start :stop :attributes |		(attributes includes: attribute)			ifTrue: [begin = 0 ifTrue: [begin _ start].					end _ stop]			ifFalse: [begin > 0 ifTrue: [^ begin to: end]]].	begin > 0 ifTrue: [^ begin to: end].	^ nil! !!Text methodsFor: 'emphasis' stamp: 'di 11/9/97 17:41'!fontAt: characterIndex withStyle: aTextStyle	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes font |	self size = 0 ifTrue: [^ aTextStyle fontAt: 1].	"null text tolerates access"	attributes _ runs at: characterIndex.	attributes do:		[:att | att forFontInStyle: aTextStyle do: [:f | font _ f]].	^ font	! !!Text methodsFor: 'emphasis'!fontNumberAt: characterIndex 	"Answer the fontNumber for characters in the run beginning at characterIndex."	| attributes fontNumber |	self size = 0 ifTrue: [^1].	"null text tolerates access"	attributes _ runs at: characterIndex.	fontNumber _ 1.	attributes do: [:att | (att isMemberOf: TextFontChange) ifTrue: [fontNumber _ att fontNumber]].	^ fontNumber	! !!Text methodsFor: 'emphasis'!makeBoldFrom: start to: stop	^ self addAttribute: TextEmphasis bold from: start to: stop! !!Text methodsFor: 'emphasis'!removeAttribute: att from: start to: stop 	"Remove the attribute over the interval start to stop."	runs _  runs copyReplaceFrom: start to: stop			with: ((runs copyFrom: start to: stop)				mapValues:				[:attributes | attributes copyWithout: att])! !!Text methodsFor: 'private' stamp: 'tk 12/16/97 14:14'!setString: aString setRunsChecking: aRunArray	"Check runs and do the best you can to make them fit..."	string _ aString.	"check the runs"	aRunArray ifNil: [^ aString asText].	(aRunArray isKindOf: RunArray) ifFalse: [^ aString asText].	aRunArray runs size = aRunArray values size ifFalse: [^ aString asText].	(aRunArray values includes: #()) ifTrue: [^ aString asText].	"not allowed?"	aRunArray size = aString size ifFalse: [^ aString asText].		runs _ aRunArray.! !!Text methodsFor: 'attributes' stamp: 'tk 12/11/97 17:08'!unembellished	"Return true if the only emphesis is an initial bold.  This is the way a method is with no extra bold, links, etc."	| vv ind |	vv _ runs values.	"Don't care where the runs occur, only what they are"	"((a TextFontChange font: 1 a TextEmphasis code: 1 ) (a TextFontChange font1 ) )"	"bold selector, then unbold method text"	vv size > 2 ifTrue: [^ false].		"more changes"	vv last = (Array with: TextFontChange font1) ifFalse: [^ false].	"not bold"	vv size = 1 ifTrue: [^ true].	"OK if all not bold"	vv first = (Array with: TextFontChange font1 with: TextEmphasis bold) ifFalse: [^ false].		"selector bold"	ind _ string indexOf: Character cr.	"end of first line"	(ind = 0) | (ind = string size) ifTrue: [^ false].	"no second line"	"return true if first char of second line is not bold"	^ ((self attributesAt: ind+1) includes: (TextEmphasis bold)) not! !!Text class methodsFor: 'class initialization'!initialize	"Text initialize"	"Initialize constants shared by classes associated with text display."	TextConstants at: #CaretForm put:				(Form extent: 16@5					fromArray: #(2r001100e26 2r001100e26 2r011110e26 2r111111e26 2r110011e26)					offset: -3@0).	self initTextConstants! !!Text class methodsFor: 'class initialization'!initTextConstants 	"Initialize constants shared by classes associated with text display, e.g., 	Space, Tab, Cr, Bs, ESC."		"1/24/96 sw: in exasperation and confusion, changed cmd-g mapping from 231 to 232 to see if I could gain any relief?!!"	| letter varAndValue tempArray width |	"CtrlA..CtrlZ, Ctrla..Ctrlz"	letter _ $A. 	#(		212 230 228 196 194 226 241 243 214 229 200 217 246 			245 216 202 210 239 211 240 197 198 209 215 242 231	 		1 166 228 132 130 12 232 179 150 165 136 153 182 			14 15 138 17 18 19 11 21 134 145 151 178 167 ) do:		[:kbd |		TextConstants at: ('Ctrl', letter asSymbol) asSymbol put: kbd asCharacter.		letter _ letter == $Z ifTrue: [$a] ifFalse: [(letter asciiValue + 1) asCharacter]].	varAndValue _ #(		Space	32		Tab		9		CR		13		Enter	3		BS		8		BS2		158		ESC		160		Clear 	173	).	varAndValue size odd ifTrue: [self notify: 'unpaired text constant'].	(2 to: varAndValue size by: 2) do:		[:i | TextConstants at: (varAndValue at: i - 1) put: (varAndValue at: i) asCharacter].	varAndValue _ #(		CtrlDigits 			(159 144 143 128 127 129 131 180 149 135)		CtrlOpenBrackets	(201 7 218 249 219 15)			"lparen gottn by ctrl-_ = 201; should be 213 but can't type that on Mac"			"location of non-character stop conditions"		EndOfRun	257		CrossedX	258			"values for alignment"		LeftFlush	0		RightFlush	1		Centered	2		Justified	3			"subscripts for a marginTabsArray tuple"		LeftMarginTab	1		RightMarginTab	2			"font faces"		Basal	0		Bold	1		Italic	2			"in case font doesn't have a width for space character"			"some plausible numbers-- are they the right ones?"		DefaultSpace			4		DefaultTab				24		DefaultLineGrid			16		DefaultBaseline			12		DefaultFontFamilySize	3	"basal, bold, italic"	).	varAndValue size odd ifTrue: [self notify: 'unpaired text constant'].	(2 to: varAndValue size by: 2) do:		[:i | TextConstants at: (varAndValue at: i - 1) put: (varAndValue at: i)].	TextConstants at: #DefaultRule	put: Form over.	TextConstants at: #DefaultMask	put: Color black.	width _ Display width max: 720.	tempArray _ Array new: width // DefaultTab.	1 to: tempArray size do:		[:i | tempArray at: i put: DefaultTab * i].	TextConstants at: #DefaultTabsArray put: tempArray.	tempArray _ Array new: (width // DefaultTab) // 2.	1 to: tempArray size do:		[:i | tempArray at: i put: (Array with: (DefaultTab*i) with: (DefaultTab*i))].	TextConstants at: #DefaultMarginTabsArray put: tempArray."Text initTextConstants "! !!Text class methodsFor: 'instance creation'!fromString: aString 	"Answer an instance of me whose characters are those of the argument, 	aString."	^self string: aString attribute: (TextFontChange fontNumber: 1)! !!Text class methodsFor: 'instance creation'!fromUser	"Answer an instance of me obtained by requesting the user to type some 	characters into a prompter (a FillInTheBlank object)."	FillInTheBlank		request: 'Type text followed by carriage return'		displayAt: (50@ Display boundingBox height//2)		centered: false		action: [:result]		initialAnswer: ''.	^self fromString: result! !!Text class methodsFor: 'instance creation'!streamContents: blockWithArg 	| stream |	stream _ TextStream on: (self new: 400).	blockWithArg value: stream.	^ stream contents! !!Text class methodsFor: 'instance creation'!string: aString attribute: att	"Answer an instance of me whose characters are aString.	att is a TextAttribute."	^self string: aString attributes: (Array with: att)! !!Text class methodsFor: 'instance creation'!string: aString attributes: atts	"Answer an instance of me whose characters are those of aString.	atts is an array of TextAttributes."	^self string: aString runs: (RunArray new: aString size withAll: atts)! !!Text class methodsFor: 'instance creation'!string: aString emphasis: emphasis	"This is an old method that is mainly used by old applications"	emphasis isNumber ifTrue:		[self halt: 'Numeric emphasis is not supported in Squeak'.		"But if you proceed, we will do our best to give you what you want..."		^ self string: aString runs: (RunArray new: aString size withAll: 			(Array with: (TextFontChange new fontNumber: emphasis)))].	^ self string: aString attributes: emphasis! !!Text class methodsFor: 'private' stamp: 'di 10/31/97 11:22'!addAttribute: att toArray: others 	"Add a new text attribute to an existing set"	"NOTE: The use of reset and set in this code is a specific	hack for merging TextKerns."	att reset.	^ Array streamContents:		[:strm | others do:			[:other | (att dominates: other) ifFalse: [strm nextPut: other]].		att set ifTrue: [strm nextPut: att]]! !!TextAction methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:44'!analyze: aString	"Analyze the selected text to find both the parameter to store and the text to emphesize (may be different from original selection).  Does not return self!!.  May be of the form:3+4<3+4>Click Here<3+4><3+4>Click Here"	"Obtain the showing text and the instructions"	| b1 b2 trim param show |	b1 _ aString indexOf: $<.	b2 _ aString indexOf: $>.	(b1 < b2) & (b1 > 0) ifFalse: ["only one part"		param _ self validate: aString.		^ Array with: param with: (param size = 0 ifTrue: [nil] ifFalse: [param])].	"Two parts"	trim _ aString withBlanksTrimmed.	(trim at: 1) == $< 		ifTrue: [(trim last) == $>			ifTrue: ["only instructions" 				param _ self validate: (aString copyFrom: b1+1 to: b2-1).				show _ param size = 0 ifTrue: [nil] ifFalse: [param]]			ifFalse: ["at the front"				param _ self validate: (aString copyFrom: b1+1 to: b2-1).				show _ param size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: b2+1 to: aString size]]]		ifFalse: [(trim last) == $>			ifTrue: ["at the end"				param _ self validate: (aString copyFrom: b1+1 to: b2-1).				show _ param size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: 1 to: b1-1]]			ifFalse: ["Illegal -- <> has text on both sides"				show _ nil]].	^ Array with: param with: show! !!TextAction methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:11'!dominatedByCmd0	"Cmd-0 should turn off active text"	^ true! !!TextAction methodsFor: 'as yet unclassified' stamp: 'di 1/14/98 09:30'!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: Purple! !!TextAction methodsFor: 'as yet unclassified'!mayActOnClick	^ true! !!TextAction methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:48'!validate: aString	"any format is OK with me"	^ aString! !!TextAction class methodsFor: 'as yet unclassified' stamp: 'di 1/14/98 09:30'!initialize   "TextAction initialize"	Purple _ Color r: 0.4 g: 0 b: 1.0! !TextAnchor comment:'TextAnchors support anchoring of images in text.  A TextAnchor exists as an attribute of text emphasis, and it gets control like a FontReference, through the emphasizeScanner: message.  Depending on whether its anchoredMorph is a Morph or a Form, it repositions the morph, or displays the form respectively.  The coordination between composition, display and selection can best be understood by browsing the various implementations of placeEmbeddedObject:.In the morphic world, simply embed any morph in text.  In the old world, you can create an image reference using code such as the following.	ParagraphEditor new clipboardTextPut:		(Text string: ''*''			attribute: (TextAnchor new anchoredMorph: Form fromUser))In this case you select a piece of the screen, and it gets anchored to a one-character text in the editor''s past buffer.  If you then paste into some other text, you will see the image as an embedded image.'!!TextAnchor methodsFor: 'all' stamp: 'di 11/10/97 13:21'!= other 	^ (other class == self class) 		and: [other anchoredMorph = anchoredMorph]! !!TextAnchor methodsFor: 'all' stamp: 'di 11/10/97 13:21'!anchoredMorph	^ anchoredMorph! !!TextAnchor methodsFor: 'all' stamp: 'di 11/10/97 10:47'!anchoredMorph: aMorph 	anchoredMorph _ aMorph! !!TextAnchor methodsFor: 'all' stamp: 'di 11/10/97 14:34'!emphasizeScanner: scanner	scanner placeEmbeddedObject: anchoredMorph! !!TextAnchor methodsFor: 'all' stamp: 'di 11/10/97 14:08'!mayBeExtended	"A textAnchor is designed to modify only a single character, and therefore must not be extended by the ParagraphEditor's emphasisHere facility"	^ false! !TextAttribute comment:'Tells a piece of text to be a certain way.Select text, press Command-6, choose a attribute.  If selected text is of the form 	Hi There<Smalltalk beep>the part in angle brackets is saved for action, and the Hi There appears in the paragraph.  If selection has no angle brackets, use the whole thing as both the text and the action.TextDoIt  --  eval as a Smalltalk expression (the part in angle brackets)TextLink -- Show a method, class comment, class hierarchy, or class defintion.	<Point extent:>, <Point Comment>, <Point Hierarchy>, or <Point Defintion> are what you type.TextURL -- Show the web page. <www.disney.com>These attributes of text need to be stored on the disk in a regular file-out.  It is done in this form: 	(ascii 2)<!!do Smalltalk beep(ascii 3)>Hi There(ascii 3)<!!>	(ascii 2)<!!li Point extent:(ascii 3)>Click here to see the extent: method(ascii 3)<!!>The brackets are for people to see in fileOuts.  The wierd ascii are for the scanner to pick up easily.'!!TextAttribute methodsFor: 'as yet unclassified'!actOnClickFor: model	"Subclasses may override to provide, eg, hot-spot actions"	^ false! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:09'!dominatedByCmd0	"Subclasses may override if cmd-0 should turn them off"	^ false! !!TextAttribute methodsFor: 'as yet unclassified'!dominates: another	"Subclasses may override condense multiple attributes"	^ false! !!TextAttribute methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Subclasses may override to set, eg, font, color, etc"! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 11/9/97 17:46'!forFontInStyle: aTextStyle do: aBlock	"No action is the default.  Overridden by font specs"! !!TextAttribute methodsFor: 'as yet unclassified'!mayActOnClick	"Subclasses may override to provide, eg, hot-spot actions"	^ false! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 11/10/97 14:05'!mayBeExtended	"A quality that may be overridden by subclasses, such as TextAnchors, that really only apply to a single character"	^ true! !!TextAttribute methodsFor: 'as yet unclassified'!oldEmphasisCode: default	"Allows running thorugh possibly multiple attributes	and getting the emphasis out of any that has an emphasis (font number)"	^ default! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:03'!reset	"Allow subclasses to prepare themselves for merging attributes"! !!TextAttribute methodsFor: 'as yet unclassified'!set	"Respond true to include this attribute (as opposed to, eg, a bold	emphasizer that is clearing the property"	^ true! !!TextCollector methodsFor: 'accessing' stamp: 'sw 8/4/97 00:17'!showOnNewLine: aString 	self cr.	self nextPutAll: aString.	self endEntry! !!TextCollector methodsFor: 'character writing' stamp: 'sw 1/31/96'!bs	"Backspace the Transcript.  Put in at Alan's request "	"Transcript bs"	contents _ contents allButLast.	self changed: #update! !!TextCollectorController methodsFor: 'entry control' stamp: 'di 8/29/97 19:20'!appendEntry	"Append the text in the model's writeStream to the editable text. "		view topView isCollapsed		ifTrue: [paragraph text				replaceFrom: 1				to: paragraph text size				with: model contents asText]		ifFalse: 			[self deselect.			paragraph text size > model characterLimit ifTrue: 				[paragraph removeFirstChars: paragraph text size - (model characterLimit // 2)].			self selectWithoutComp: paragraph text size + 1.			self replaceSelectionWith: model nextEntry asText.			self selectWithoutComp: paragraph text size + 1.			model contents: paragraph text]! !!TextCollectorController methodsFor: 'entry control' stamp: 'di 10/17/97 23:26'!changeText: aText 	"The paragraph to be edited is changed to aText."	paragraph text: aText.	self resetState.	self selectWithoutComp: paragraph text size + 1.	self selectAndScroll.	self deselect! !!TextCollectorController methodsFor: 'private' stamp: 'di 8/30/97 11:21'!doOccluded: actionBlock	| paneRect rectSet bottomStrip |	view topView isCollapsed ifTrue: [^ actionBlock value].	paneRect _ paragraph clippingRectangle.	rectSet _ self visibleAreas.	paragraph withClippingRectangle: (paneRect withHeight: 0)		do: [actionBlock value.			self scrollIn: paneRect].	bottomStrip _ paneRect withTop: paragraph compositionRectangle bottom + 1.	rectSet do:		[:rect |		(bottomStrip intersects: rect) ifTrue:			["The subsequent displayOn should clear this strip but it doesnt"			Display fill: (bottomStrip intersect: rect)					fillColor: paragraph backgroundColor].		paragraph withClippingRectangle: rect				do: [paragraph displayOn: Display]]! !!TextCollectorController methodsFor: 'private' stamp: 'di 8/30/97 11:34'!scrollIn: scrollRect	"Altered from selectAndScroll so can use with null clipRect"	"Scroll until the selection is in the view and then highlight it."	| deltaY |	deltaY _ stopBlock top - scrollRect top.	deltaY >= 0 		ifTrue: [deltaY _ stopBlock bottom - scrollRect bottom max: 0].						"check if stopIndex below bottom of scrollRect"	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + paragraph lineGrid - 1) * deltaY sign]! !!TextCollectorController methodsFor: 'private' stamp: 'di 9/28/97 15:08'!visibleAreas	"Transcript dependents last controller visibleAreas"	| visibleAreas rect remnants myTopController |	myTopController _ self view topView controller.	visibleAreas _ Array with: view insetDisplayBox.	myTopController view uncacheBits.	ScheduledControllers scheduledWindowControllers do:		[:c | c == myTopController ifTrue: [^ visibleAreas].		rect _ c view windowBox.		remnants _ OrderedCollection new.		visibleAreas do: [:a | remnants addAll: (a areasOutside: rect)].		visibleAreas _ remnants].	^ visibleAreas! !!TextCollectorView methodsFor: 'updating' stamp: 'di 8/29/97 18:26'!update: aParameter	"Transcript cr; show: 'qwre'.    Transcript clear."	aParameter == #appendEntry ifTrue:		[^ controller doOccluded: [controller appendEntry]].	aParameter == #update ifTrue:		[^ controller doOccluded:				[controller changeText: model contents asText]].	^ super update: aParameter! !TextColor comment:'A TextColor encodes a text color change applicable over a given range of text.'!!TextColor methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:19'!= other 	^ (other class == self class) 		and: [other color = color]! !!TextColor methodsFor: 'as yet unclassified'!color	^ color! !!TextColor methodsFor: 'as yet unclassified'!color: aColor	color _ aColor! !!TextColor methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:20'!dominates: other	^ other class == self class! !!TextColor methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: color! !!TextColor methodsFor: 'as yet unclassified'!printOn: strm	super printOn: strm.	strm nextPutAll: ' code: '; print: color! !!TextColor methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:47'!writeScanOn: strm	"Two formats.  c125000255 or cblue;"	| nn str |	strm nextPut: $c.	(nn _ color name) ifNotNil: [		(self class respondsTo: nn) ifTrue: [			^ strm nextPutAll: nn; nextPut: $;]].	(Array with: color red with: color green with: color blue) do: [:float |		str _ '000', (float * 255) asInteger printString.		strm nextPutAll: (str copyFrom: str size-2 to: str size)]! !!TextColor class methodsFor: 'as yet unclassified'!black	^ self new color: Color black! !!TextColor class methodsFor: 'as yet unclassified'!blue	^ self new color: Color blue! !!TextColor class methodsFor: 'as yet unclassified'!color: aColor	^ self new color: aColor! !!TextColor class methodsFor: 'as yet unclassified'!cyan	^ self new color: Color cyan! !!TextColor class methodsFor: 'as yet unclassified'!green	^ self new color: Color green! !!TextColor class methodsFor: 'as yet unclassified'!magenta	^ self new color: Color magenta! !!TextColor class methodsFor: 'as yet unclassified'!red	^ self new color: Color red! !!TextColor class methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 08:50'!scanFrom: strm	"read a color in the funny format used by Text styles on files. c125000255 or cblue;"	| r g b |	strm peek isDigit ifTrue: [		r _ (strm next: 3) asNumber.		g _ (strm next: 3) asNumber.		b _ (strm next: 3) asNumber.		^ self color: (Color r: r g: g b: b range: 255)].	"A name of a color"	^ self color: (Color perform: (strm upTo: $;) asSymbol)! !!TextColor class methodsFor: 'as yet unclassified'!yellow	^ self new color: Color yellow! !TextContainer comment:'A TextContainer models the shape of an ownerMorph, possibly occluded by one or more occludingMorphs, and scans this shape to provide a list of rectangles suitable for layout of text.  It does this by displaying the shadow of the ownerMorph in black, and any occludingMorphs in white, on its shadowForm.  It then scans horizontal strips of appropriate height to find unbroken intervals of black, greater than minWidth in extent.  Conputation of the rectangles is done on demand, and results are cached so that text can be redisplayed without having to recompute the rectangles.'!!TextContainer methodsFor: 'access' stamp: 'di 11/4/97 14:05'!avoidsOcclusions	^ avoidsOcclusions ifNil: [false]! !!TextContainer methodsFor: 'access' stamp: 'di 11/13/97 14:45'!avoidsOcclusions: aBoolean	avoidsOcclusions _ aBoolean.	self releaseCachedState! !!TextContainer methodsFor: 'access' stamp: 'di 11/4/97 14:05'!fillsOwner	^ fillsOwner ifNil: [true]! !!TextContainer methodsFor: 'access' stamp: 'di 11/13/97 14:45'!fillsOwner: aBoolean	fillsOwner _ aBoolean.	self releaseCachedState! !!TextContainer methodsFor: 'access' stamp: 'jm 11/19/97 19:28'!paragraphClass	^ NewParagraph! !!TextContainer methodsFor: 'access' stamp: 'di 11/16/97 09:39'!releaseCachedState	shadowForm _ nil.	vertProfile _ nil.	rectangleCache _ Dictionary new.! !!TextContainer methodsFor: 'container protocol' stamp: 'di 10/27/97 23:09'!bottom	"Note we should really check for contiguous pixels here"	^ (self vertProfile findLast: [:count | count >= minWidth])		+ shadowForm offset y! !!TextContainer methodsFor: 'container protocol' stamp: 'di 10/28/97 18:33'!left 	^ textMorph owner left! !!TextContainer methodsFor: 'container protocol' stamp: 'di 11/17/97 11:35'!rectanglesAt: lineY height: lineHeight	"Return a list of rectangles that are at least minWidth wide	in the specified horizontal strip of the shadowForm.	Cache the results for later retrieval if the owner does not change."	| hProfile rects thisWidth thisX count pair outerWidth lineRect lineForm |	pair _ Array with: lineY with: lineHeight.	rects _ rectangleCache at: pair ifAbsent: [nil].	rects ifNotNil: [^ rects].	outerWidth _ minWidth + (2*OuterMargin).	lineRect _ 0@(lineY - shadowForm offset y)					extent: shadowForm width@lineHeight.	lineForm _ self shadowForm copy: lineRect.	"Check for a full line -- frequent case"	(lineForm tallyPixelValues at: 2) = lineRect area	ifTrue:		[rects _ Array with: (shadowForm offset x@lineY extent: lineRect extent)]	ifFalse:		["No such luck -- scan the horizontal profile for segments of minWidth"		hProfile _ lineForm xTallyPixelValue: 1 orNot: false.		rects _ OrderedCollection new.		thisWidth _ 0.  thisX _ 0.		1 to: hProfile size do:			[:i | count _ hProfile at: i.			count >= lineHeight ifTrue:				[thisWidth _ thisWidth + 1]				ifFalse:				[thisWidth >= outerWidth ifTrue:					[rects addLast: ((thisX + shadowForm offset x)@lineY									extent: thisWidth@lineHeight)].				thisWidth _ 0. thisX _ i]].		thisWidth >= outerWidth ifTrue:				[rects addLast: ((thisX + shadowForm offset x)@lineY									extent: thisWidth@lineHeight)]].	rects _ rects collect: [:r | r insetBy: OuterMargin@0].	rectangleCache at: pair put: rects.	^ rects! !!TextContainer methodsFor: 'container protocol' stamp: 'di 11/16/97 09:33'!top	"Note we should really check for contiguous pixels here"	| outerWidth |	outerWidth _ minWidth + (2*OuterMargin).	^ (self vertProfile findFirst: [:count | count >= outerWidth]) - 1		+ shadowForm offset y! !!TextContainer methodsFor: 'container protocol' stamp: 'di 10/28/97 18:33'!topLeft  "for compatibility"	^ textMorph owner topLeft! !!TextContainer methodsFor: 'container protocol' stamp: 'di 11/7/97 12:01'!translateBy: delta	self releaseCachedState! !!TextContainer methodsFor: 'container protocol' stamp: 'di 10/28/97 18:32'!width  "for compatibility"	^ textMorph owner width! !!TextContainer methodsFor: 'private' stamp: 'di 11/4/97 15:12'!bounds	| bounds |	self fillsOwner ifTrue:		[self avoidsOcclusions			ifTrue: [bounds _ textMorph owner bounds.					textMorph owner submorphsBehind: textMorph do:						[:m | bounds _ bounds merge: m fullBounds]]			ifFalse: [bounds _ textMorph owner fullBounds]]		ifFalse:		[bounds _ textMorph bounds].	^ bounds! !!TextContainer methodsFor: 'private' stamp: 'di 11/16/97 15:15'!computeShadow	| canvas back bounds |	bounds _ self bounds.	canvas _ (FormCanvas extent: bounds extent depth: 1)			setShadowDrawing; stipple: Color black;			copyOffset: bounds topLeft negated.	self fillsOwner		ifTrue: [(textMorph owner copyWithoutSubmorph: textMorph) fullDrawOn: canvas]		ifFalse: [canvas fillRectangle: textMorph bounds color: Color black].	self avoidsOcclusions ifTrue:		[back _ canvas form deepCopy.		canvas form fillWhite.		textMorph owner submorphsInFrontOf: textMorph do:			[:m | (textMorph isLinkedTo: m)				ifTrue: []				ifFalse: [m fullDrawOn: canvas]].		back displayOn: canvas form at: 0@0 rule: Form reverse].	shadowForm _ canvas form offset: bounds topLeft.	vertProfile _ shadowForm  yTallyPixelValue: 1 orNot: false.	rectangleCache _ Dictionary new.	^ shadowForm! !!TextContainer methodsFor: 'private' stamp: 'di 11/4/97 14:06'!for: aTextMorph minWidth: wid	textMorph _ aTextMorph.	minWidth _ wid.	fillsOwner _ true.	avoidsOcclusions _ false.! !!TextContainer methodsFor: 'private' stamp: 'di 10/27/97 23:09'!shadowForm	shadowForm ifNil: [self computeShadow].	^ shadowForm! !!TextContainer methodsFor: 'private' stamp: 'di 10/27/97 23:08'!vertProfile	vertProfile ifNil: [self computeShadow].	^ vertProfile! !!TextContainer class methodsFor: 'initialization' stamp: 'di 11/16/97 09:25'!initialize    "TextContainer initialize"	OuterMargin _ 2! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/5/97 17:01'!actOnClickFor: anObject	"Note: evalString gets evaluated IN THE CONTEXT OF anObject	 -- meaning that self and all instVars are accessible"	Compiler evaluate: evalString for: anObject logged: false.	^ true ! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:46'!analyze: aString	| list |	list _ super analyze: aString.	evalString _ list at: 1.	^ list at: 2! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/5/97 17:01'!evalString: str	evalString _ str ! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 10:33'!info	^ evalString! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 13:46'!writeScanOn: strm	strm nextPut: $d; nextPutAll: evalString; nextPutAll: ';;'! !!TextDoIt class methodsFor: 'as yet unclassified' stamp: 'tk 12/6/97 20:28'!evalString: str	^ self new evalString: str! !!TextDoIt class methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:06'!scanFrom: strm	"read a doit in the funny format used by Text styles on files. d10 factorial;;  end with two semicolons"	| pos end doit |	pos _ strm position.	[strm skipTo: $;. strm peek == $;] whileFalse.	end _ strm position - 1.	strm position: pos.	doit _ strm next: end-pos.	strm skip: 2.  ";;"	^ self evalString: doit! !TextEmphasis comment:'A TextEmphasis, encodes a characteristic applicable to all fonts.  The encoding is as follows:	1	bold	2	itallic	4	underlined	8	narrow	16	struck out'!!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:15'!= other 	^ (other class == self class) 		and: [other emphasisCode = emphasisCode]! !!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:11'!dominatedByCmd0	"Cmd-0 should turn off emphasis"	^ true! !!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:13'!dominates: other	(emphasisCode = 0 and: [other dominatedByCmd0]) ifTrue: [^ true].	^ (other class == self class)		and: [emphasisCode = other emphasisCode]! !!TextEmphasis methodsFor: 'as yet unclassified'!emphasisCode	^ emphasisCode! !!TextEmphasis methodsFor: 'as yet unclassified'!emphasisCode: int	emphasisCode _ int.	setMode _ true! !!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'di 10/29/97 11:57'!emphasizeScanner: scanner	"Set the emphasist for text scanning"	scanner addEmphasis: emphasisCode! !!TextEmphasis methodsFor: 'as yet unclassified'!printOn: strm	super printOn: strm.	strm nextPutAll: ' code: '; print: emphasisCode! !!TextEmphasis methodsFor: 'as yet unclassified'!set	^ setMode and: [emphasisCode ~= 0]! !!TextEmphasis methodsFor: 'as yet unclassified'!turnOff	setMode _ false! !!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:28'!writeScanOn: strm	emphasisCode = 1 ifTrue: [strm nextPut: $b].	emphasisCode = 2 ifTrue: [strm nextPut: $i].	emphasisCode = 0 ifTrue: [strm nextPut: $n].	emphasisCode = 16 ifTrue: [strm nextPut: $=].	emphasisCode = 4 ifTrue: [strm nextPut: $u].! !!TextEmphasis class methodsFor: 'as yet unclassified'!bold	^ self new emphasisCode: 1! !!TextEmphasis class methodsFor: 'as yet unclassified'!italic	^ self new emphasisCode: 2! !!TextEmphasis class methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:05'!narrow	^ TextKern kern: -1! !!TextEmphasis class methodsFor: 'as yet unclassified'!normal	^ self new emphasisCode: 0! !!TextEmphasis class methodsFor: 'as yet unclassified'!struckOut	^ self new emphasisCode: 16! !!TextEmphasis class methodsFor: 'as yet unclassified'!underlined	^ self new emphasisCode: 4! !TextFontChange comment:'A TextFontChange encodes a font change applicable over a given range of text.  The font number is interpreted relative to the textStyle governing display of this text.'!!TextFontChange methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:15'!= other 	^ (other class == self class) 		and: [other fontNumber = fontNumber]! !!TextFontChange methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:20'!dominates: other	^ other class == self class! !!TextFontChange methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the font for text display"	scanner setFont: fontNumber! !!TextFontChange methodsFor: 'as yet unclassified'!fontNumber	^ fontNumber! !!TextFontChange methodsFor: 'as yet unclassified'!fontNumber: int	fontNumber _ int! !!TextFontChange methodsFor: 'as yet unclassified' stamp: 'di 11/9/97 17:46'!forFontInStyle: aTextStyle do: aBlock	aBlock value: (aTextStyle fontAt: fontNumber)! !!TextFontChange methodsFor: 'as yet unclassified'!printOn: strm	super printOn: strm.	strm nextPutAll: ' font: '; print: fontNumber! !!TextFontChange methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:22'!writeScanOn: strm	strm nextPut: $f.	fontNumber printOn: strm.! !!TextFontChange class methodsFor: 'as yet unclassified'!font1	^ self new fontNumber: 1! !!TextFontChange class methodsFor: 'as yet unclassified'!font2	^ self new fontNumber: 2! !!TextFontChange class methodsFor: 'as yet unclassified'!font3	^ self new fontNumber: 3! !!TextFontChange class methodsFor: 'as yet unclassified'!font4	^ self new fontNumber: 4! !!TextFontChange class methodsFor: 'as yet unclassified'!fontNumber: n	^ self new fontNumber: n! !TextFontReference comment:'A TextFontReference encodes a font change applicable over a given range of text.  The font reference is absolute:  unlike a TextFontChange, it is independent of the textStyle governing display of this text.'!!TextFontReference methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:15'!= other 	^ (other class == self class) 		and: [font == font]! !!TextFontReference methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the actual font for text display"	scanner setActualFont: font! !!TextFontReference methodsFor: 'as yet unclassified' stamp: 'di 11/9/97 17:47'!forFontInStyle: aTextStyle do: aBlock	aBlock value: font! !!TextFontReference methodsFor: 'as yet unclassified'!toFont: aFont	font _ aFont! !!TextFontReference class methodsFor: 'as yet unclassified'!toFont: aFont	^ self new toFont: aFont! !TextKern comment:'A TextKern encodes a kerning change applicable over a given range of text.  Positive values of kern spread letters out, negative kern will cause them to overlap more.  Note that kerns other than 0 will display somewhat slower, as kerning is not yet supported in the text scanning primitive. '!!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:15'!= other 	^ (other class == self class) 		and: [other kern = kern]! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:10'!dominatedByCmd0	"Cmd-0 should turn off kerning"	^ true! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:10'!dominates: other	"NOTE: The use of active in this code is specific to its use in the method		Text class addAttribute: att toArray: others"	(active and: [other class == self class and: [other kern + kern = 0]])		ifTrue: [active _ false.  ^ true].  "can only dominate once"	^ false! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/29/97 11:50'!emphasizeScanner: scanner	"Augment (or diminish) the kerning offset for text display"	scanner addKern: kern! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:12'!kern	^ kern! !!TextKern methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 09:59'!kern: kernValue	kern _ kernValue.	self reset.! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:04'!reset	active _ true! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:11'!set	^ active! !!TextKern methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:31'!writeScanOn: strm	kern > 0 ifTrue: [		kern do: [:kk | strm nextPut: $+]].	kern < 0 ifTrue: [		0-kern do: [:kk | strm nextPut: $-]].! !!TextKern class methodsFor: 'as yet unclassified' stamp: 'di 10/29/97 11:49'!kern: kernValue	^ self new kern: kernValue! !TextLine comment:'A TextLine embodies the layout of a line of composed text.	left right top bottom		The full line rectangle	firstIndex lastIndex		Starting and stopping indices in the full text	internalSpaces		Number of spaces to share paddingWidth	paddingWidth		Number of pixels of extra space in full line	baseline				Distance of baseline below the top of the line	leftMargin			Left margin due to paragraph indentationTextLine''s rather verbose message protocol is required for compatibility with the old CharacterScanners.'!!TextLine methodsFor: 'accessing'!baseline	^ baseline! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!bottom	^ bottom! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!bottomRight	^ right@bottom! !!TextLine methodsFor: 'accessing' stamp: 'di 10/21/97 20:12'!first	^ firstIndex! !!TextLine methodsFor: 'accessing'!internalSpaces	"Answer the number of spaces in the line."	^internalSpaces! !!TextLine methodsFor: 'accessing'!internalSpaces: spacesInteger 	"Set the number of spaces in the line to be spacesInteger."	internalSpaces _ spacesInteger! !!TextLine methodsFor: 'accessing' stamp: 'di 10/21/97 20:14'!last	^ lastIndex! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!left	^ left! !!TextLine methodsFor: 'accessing' stamp: 'di 10/21/97 20:42'!leftMargin	"This has to get fixed -- store during composition"	^ self left! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:47'!leftMargin: lm	leftMargin _ lm! !!TextLine methodsFor: 'accessing' stamp: 'di 10/26/97 16:03'!leftMarginForAlignment: alignmentCode	alignmentCode = 1 ifTrue: [^ self left + paddingWidth].  "right flush"	alignmentCode = 2 ifTrue: [^ self left + (paddingWidth//2)].  "centered"	^ self left  "leftFlush and justified"! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!lineHeight	^ bottom - top! !!TextLine methodsFor: 'accessing'!paddingWidth	"Answer the amount of space to be added to the font."	^paddingWidth! !!TextLine methodsFor: 'accessing'!paddingWidth: padWidthInteger 	"Set the amount of space to be added to the font to be padWidthInteger."	paddingWidth _ padWidthInteger! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 20:00'!rectangle	^ self topLeft corner: self bottomRight! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:59'!rectangle: lineRectangle	left _ lineRectangle left.	right _ lineRectangle right.	top _ lineRectangle top.	bottom _ lineRectangle bottom.	leftMargin _ left! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!right	^ right! !!TextLine methodsFor: 'accessing' stamp: 'di 10/21/97 20:42'!rightMargin	"This has to get fixed -- store during composition"	^ self right! !!TextLine methodsFor: 'accessing' stamp: 'di 11/26/97 16:18'!setRight: x	right _ x! !!TextLine methodsFor: 'accessing' stamp: 'di 10/20/97 23:27'!stop: stopInteger 	"Set the stopping point in the string of the line to be stopInteger."	lastIndex _ stopInteger! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!top	^ top! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!topLeft	^ left @ top! !!TextLine methodsFor: 'accessing' stamp: 'di 11/26/97 16:58'!width	^ right - left! !!TextLine methodsFor: 'comparing' stamp: 'di 10/20/97 23:24'!= line	self species = line species		ifTrue: [^((firstIndex = line first and: [lastIndex = line last])				and: [internalSpaces = line internalSpaces])				and: [paddingWidth = line paddingWidth]]		ifFalse: [^false]! !!TextLine methodsFor: 'scanning'!justifiedPadFor: spaceIndex 	"Compute the width of pad for a given space in a line of justified text."	| pad |	internalSpaces = 0 ifTrue: [^0].	pad _ paddingWidth // internalSpaces.	spaceIndex <= (paddingWidth \\ internalSpaces)		ifTrue: [^pad + 1]		ifFalse: [^pad]! !!TextLine methodsFor: 'scanning'!justifiedTabDeltaFor: spaceIndex 	"Compute the delta for a tab in a line of justified text, so tab falls 	somewhere plausible when line is justified."	| pad extraPad |	internalSpaces = 0 ifTrue: [^0].	pad _ paddingWidth // internalSpaces.	extraPad _ paddingWidth \\ internalSpaces.	spaceIndex <= extraPad		ifTrue: [^spaceIndex * (pad + 1)]		ifFalse: [^extraPad * (pad + 1) + (spaceIndex - extraPad * pad)]! !!TextLine methodsFor: 'updating' stamp: 'di 11/7/97 08:32'!moveBy: delta 	"Move my rectangle by the given delta"	left _ left + delta x.	right _ right + delta x.	top _ top + delta y.	bottom _ bottom + delta y.! !!TextLine methodsFor: 'updating' stamp: 'di 10/20/97 23:25'!slide: delta 	"Change the starting and stopping points of the line by delta."	firstIndex _ firstIndex + delta.	lastIndex _ lastIndex + delta! !!TextLine methodsFor: 'private' stamp: 'di 10/20/97 23:08'!firstIndex: firstInteger lastIndex: lastInteger	firstIndex _ firstInteger.	lastIndex _ lastInteger! !!TextLine methodsFor: 'private'!internalSpaces: spacesInteger paddingWidth: padWidthInteger	internalSpaces _ spacesInteger.	paddingWidth _ padWidthInteger! !!TextLine methodsFor: 'private' stamp: 'di 10/23/97 19:57'!lineHeight: height baseline: ascent	bottom _ top + height.	baseline _ ascent! !!TextLine methodsFor: 'private' stamp: 'di 10/23/97 23:19'!printOn: aStream	super printOn: aStream.	aStream space; print: firstIndex; nextPutAll: ' to: '; print: lastIndex! !!TextLine class methodsFor: 'instance creation' stamp: 'di 10/20/97 23:08'!start: startInteger stop: stopInteger internalSpaces: spacesInteger paddingWidth: padWidthInteger	"Answer an instance of me with the arguments as the start, stop points, 	number of spaces in the line, and width of the padding."	| line |	line _ self new firstIndex: startInteger lastIndex: stopInteger.	^ line internalSpaces: spacesInteger paddingWidth: padWidthInteger! !!TextLineInterval methodsFor: 'accessing'!baseline	^ baseline! !!TextLineInterval methodsFor: 'accessing'!lineHeight	^ lineHeight! !!TextLineInterval methodsFor: 'private'!lineHeight: height baseline: ascent	lineHeight _ height.	baseline _ ascent! !!TextLineInterval class methodsFor: 'instance creation'!start: startInteger stop: stopInteger internalSpaces: spacesInteger paddingWidth: padWidthInteger	"Answer an instance of me with the arguments as the start, stop points, 	number of spaces in the line, and width of the padding."	| newSelf |	newSelf _ super from: startInteger to: stopInteger by: 1.	^newSelf internalSpaces: spacesInteger paddingWidth: padWidthInteger! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/28/97 23:11'!actOnClickFor: anObject	"Open an new LinkedMessageSet and show this method in it.  If anObject is already a LinkedMessageSet, then just add to the end of the list.  (Class method) (Class Comment) (Class Definition) (Class Hierarchy)"	anObject linkMethod: classAndMethod.	^ true! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:49'!analyze: aString	| list |	list _ super analyze: aString.	classAndMethod _ list at: 1.	^ list at: 2! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/6/97 20:52'!analyze: aString with: nonMethod	"Initalize this attribute holder with a piece text the user typed into a paragraph.  Returns the text to emphesize (may be different from selection)  Does not return self!!.  nonMethod is what to show when clicked, i.e. the last part of specifier (Comment, Definition, or Hierarchy).  May be of the form:Point<Point>Click Here<Point><Point>Click Here"	"Obtain the showing text and the instructions"	| b1 b2 trim |	b1 _ aString indexOf: $<.	b2 _ aString indexOf: $>.	(b1 < b2) & (b1 > 0) ifFalse: ["only one part"		classAndMethod _ self validate: aString, ' ', nonMethod.		^ classAndMethod size = 0 ifTrue: [nil] ifFalse: [aString]].	"Two parts"	trim _ aString withBlanksTrimmed.	(trim at: 1) == $< 		ifTrue: [(trim last) == $>			ifTrue: ["only instructions" 				classAndMethod _ self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod size = 0 ifTrue: [nil] ifFalse: [classAndMethod]]			ifFalse: ["at the front"				classAndMethod _ self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: b2+1 to: aString size]]]		ifFalse: [(trim last) == $>			ifTrue: ["at the end"				classAndMethod _ self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: 1 to: b1-1]]			ifFalse: ["Illegal -- <> has text on both sides"				^ nil]]! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/5/97 17:09'!classAndMethod: aString	classAndMethod _ aString! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 10:33'!info	^ classAndMethod! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/6/97 19:28'!validate: specString	"Can this string be decoded to be Class space Method (or Comment, Definition, Hierarchy)? If so, return it in valid format, else nil" 	| list first mid last |	list _ specString findTokens: ' 	.|'.	list size > 3 ifTrue: [^ nil].	list size < 2 ifTrue: [^ nil].	Symbol hasInterned: list first ifTrue: [:sym | first _ sym].	first ifNil: [^ nil].	Smalltalk at: first ifAbsent: [^ nil].	mid _ list size = 3 		ifTrue: [(list at: 2) = 'class' ifTrue: ['class '] ifFalse: [^ nil]]		ifFalse: [''].	"OK if method name is not interned -- may not be defined yet"	last _ list last.	last first isUppercase ifTrue: [		(#('Comment' 'Definition' 'Hierarchy') includes: last) ifFalse: [^ nil]].	^ first, ' ', mid, last! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 13:44'!writeScanOn: strm	strm nextPut: $L; nextPutAll: classAndMethod; nextPut: $;! !!TextLink class methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 08:53'!scanFrom: strm	"read a link in the funny format used by Text styles on files. LPoint +;LPoint Comment;"	^ self new classAndMethod: (strm upTo: $;)! !!TextLinkToImplementors methodsFor: 'as yet unclassified'!actOnClickFor: modelIgnored	Smalltalk browseAllImplementorsOf: selector.	^ true! !!TextLinkToImplementors methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: Color red! !!TextLinkToImplementors methodsFor: 'as yet unclassified'!selector: sel	selector _ sel! !!TextLinkToImplementors class methodsFor: 'as yet unclassified'!of: selector	^ self new selector: selector! !TextMorph comment:'TextMorphs support display of text with emphasis.  They also support reasonable text-editing capabilities, as well as imbedded hot links, and the (soon to be released) ability to embed submorphs in the text.  If text has been embedded in another object, one can elect to fill the owner''s bounds, in which case the text will be laid out in the shape of the owner''s shadow image (including any submorphs othe than the text).  One can also elect to have the text avoid occlusions, in which case it will avoid the bounds of any sibling morphs that appear in front of it.  It may be necessary to update bounds in order for the text runaround to notice the presence of a new occluding shape.'!!TextMorph methodsFor: 'initialization' stamp: 'di 12/29/97 14:42'!beAllFont: aFont	textStyle _ TextStyle fontArray: (Array with: aFont).	self releaseCachedState; changed! !!TextMorph methodsFor: 'initialization' stamp: 'sw 10/2/97 15:16'!configureForKids	super configureForKids.	self lock! !!TextMorph methodsFor: 'initialization' stamp: 'di 11/12/97 09:31'!copy	^ super copy text: text copy textStyle: textStyle copy 		wrap: wrapFlag color: color		predecessor: nil successor: nil! !!TextMorph methodsFor: 'initialization' stamp: 'di 9/30/97 09:25'!initialize	super initialize.	color _ Color black.	textStyle _ TextStyle default copy.	wrapFlag _ true.! !!TextMorph methodsFor: 'initialization' stamp: 'jm 11/13/97 16:32'!releaseCachedState	super releaseCachedState.	self releaseParagraph.! !!TextMorph methodsFor: 'initialization' stamp: 'di 10/20/97 20:14'!string: aString fontName: aName size: aSize	self contentsWrapped: aString.	textStyle _ (TextStyle named: aName asSymbol) copy.	textStyle ifNil: [self halt: 'Error: font ', aName, ' not found.'].	text addAttribute: (TextFontChange fontNumber: (textStyle fontIndexOfSize: aSize))! !!TextMorph methodsFor: 'accessing'!contents	^ text! !!TextMorph methodsFor: 'accessing' stamp: 'di 9/30/97 15:48'!contents: stringOrText	^ self contentsAsIs: stringOrText! !!TextMorph methodsFor: 'accessing' stamp: 'di 9/30/97 15:48'!contentsAsIs: stringOrText	"Accept new text contents with line breaks only as in the text.	Fit my width and height to the result."	wrapFlag _ false.	self newContents: stringOrText! !!TextMorph methodsFor: 'accessing' stamp: 'di 9/30/97 09:51'!contentsWrapped: stringOrText	"Accept new text contents.  Lay it out, wrapping within my current width.	Then fit my height to the result."	wrapFlag _ true.	self newContents: stringOrText! !!TextMorph methodsFor: 'accessing' stamp: 'di 9/29/97 11:47'!copyRecordingIn: dict	"Overridden to copy deeper text structure."	^ (super copyRecordingIn: dict)		text: text copy textStyle: textStyle copy! !!TextMorph methodsFor: 'accessing' stamp: 'di 9/30/97 15:37'!newContents: stringOrText	"Accept new text contents."	| newText |	newText _ stringOrText asText.	text = newText ifTrue: [^ self].  "No substantive change"	text _ newText.	self releaseParagraph.  "update the paragraph cache"	self paragraph.  "re-instantiate to set bounds"! !!TextMorph methodsFor: 'alignment' stamp: 'di 10/25/97 19:19'!centered 	self paragraph centered.	self updateFromParagraph ! !!TextMorph methodsFor: 'alignment' stamp: 'di 10/25/97 19:20'!justified 	self paragraph justified.	self updateFromParagraph! !!TextMorph methodsFor: 'alignment' stamp: 'di 10/25/97 19:20'!leftFlush 	self paragraph leftFlush.	self updateFromParagraph! !!TextMorph methodsFor: 'alignment' stamp: 'di 10/25/97 19:20'!rightFlush 	self paragraph rightFlush.	self updateFromParagraph! !!TextMorph methodsFor: 'drawing' stamp: 'di 12/1/97 03:27'!drawBoundsOn: aCanvas	"Shows where line boundaries are"	container ifNil:			[aCanvas frameRectangle: bounds color: Color green]		ifNotNil:			[self paragraph lines do:				[:line | aCanvas frameRectangle: line rectangle color: Color green]].! !!TextMorph methodsFor: 'drawing' stamp: 'di 12/1/97 03:26'!drawOn: aCanvas	text ifNil: [text _ 'Text' asText allBold].  "Default contents"	"self drawBoundsOn: aCanvas."  "show line rects for debugging"	self startingIndex > text size	ifTrue:		["make null text frame visible"		aCanvas fillRectangle: bounds color: Color lightRed]	ifFalse:		[aCanvas newParagraph: self paragraph bounds: bounds color: color].! !!TextMorph methodsFor: 'editing' stamp: 'di 9/30/97 10:26'!acceptContents	"The message is sent when the user hits enter or Cmd-S. Accept the current contents and end editing. This default implementation does nothing."	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 9/30/97 10:27'!chooseAlignment	self installEditor changeAlignment.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 9/30/97 10:27'!chooseEmphasis	self installEditor changeEmphasis.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 9/30/97 10:28'!chooseFont	self installEditor offerFontMenu.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 9/30/97 10:28'!chooseStyle	self installEditor changeStyle.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 12/3/97 19:59'!handleInteraction: interActionBlock fromEvent: evt	self installEditor.  "Make sure editor is installed"	editor sensor: (KeyboardBuffer new startingEvent: evt).  "Fool MVC"	self selectionChanged.  "Note old selection"		interActionBlock value.	self selectionChanged.  "Note new selection"! !!TextMorph methodsFor: 'editing' stamp: 'jm 11/4/97 15:00'!handlesMouseDown: evt	(self hasProperty: #partsDonor) ifTrue: [^ false].	^ self uncoveredAt: evt cursorPoint! !!TextMorph methodsFor: 'editing' stamp: 'di 9/29/97 11:46'!hasFocus	^ editor ~~ nil! !!TextMorph methodsFor: 'editing' stamp: 'di 11/7/97 12:55'!keyboardFocusChange: aBoolean	| w |	aBoolean		ifTrue: ["A hand is wanting to send us characters..."				self hasFocus ifFalse: [self installEditor]]		ifFalse: ["A hand has clicked elsewhere..."				w _ self world.				(w notNil and: 					[(w hands collect: [:h | h keyboardFocus]) includes: self])					ifFalse: ["Release control unless some hand is still holding on"							self releaseEditor]].! !!TextMorph methodsFor: 'editing' stamp: 'di 12/3/97 20:05'!keyStroke: evt	"Handle a keystroke event."	self handleInteraction: [editor readKeyboard] fromEvent: evt.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 12/3/97 20:04'!mouseDown: evt	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	evt hand newKeyboardFocus: self.	self handleInteraction: [editor mouseDown: evt] fromEvent: evt! !!TextMorph methodsFor: 'editing' stamp: 'di 12/3/97 20:04'!mouseMove: evt	evt redButtonPressed ifFalse: [^ self].	self handleInteraction: [editor mouseMove: evt] fromEvent: evt! !!TextMorph methodsFor: 'editing' stamp: 'di 12/3/97 20:04'!mouseUp: evt	self handleInteraction: [editor mouseUp: evt] fromEvent: evt! !!TextMorph methodsFor: 'editing' stamp: 'di 11/7/97 12:58'!passKeyboardFocusTo: otherMorph	| w |	w _ self world.	w notNil ifTrue: 		[w hands do:			[:h | h keyboardFocus == self				ifTrue: [h newKeyboardFocus: otherMorph]]].	"Release control unless some hand is still holding on"	self releaseEditor.! !!TextMorph methodsFor: 'editing'!xeqLinkText: sourceString withParameter: param	self confirm: 'xeqLinkText:' asText allBold , sourceString asText! !!TextMorph methodsFor: 'printing'!fullPrintOn: aStream	aStream nextPutAll: '('.	super fullPrintOn: aStream.	aStream nextPutAll: ') contents: '; print: text! !!TextMorph methodsFor: 'geometry' stamp: 'jm 10/28/97 18:31'!container	"Return the container for composing this text.  There are four cases:	1.  container is specified as, eg, an arbitrary shape,	2.  container is specified as the bound rectangle, because		this morph is linked to others,	3.  container is nil, and wrap is true -- grow downward as necessary,	4.  container is nil, and wrap is false -- grow in 2D as nexessary."	container ifNil:		[successor ifNotNil: [^ self bounds].		wrapFlag ifTrue: [^ self bounds withHeight: 99999].		^ self position extent: 99999@99999].	^ container! !!TextMorph methodsFor: 'geometry' stamp: 'jm 11/19/97 22:57'!containsPoint: aPoint	self startingIndex > text size ifTrue:		["make null text frame visible"		^ true].	^ self paragraph containsPoint: aPoint! !!TextMorph methodsFor: 'geometry' stamp: 'di 12/5/97 10:08'!extent: aPoint 	self releaseParagraph.  "invalidate the paragraph cache"	super extent: (aPoint max: 9@(textStyle lineGrid+2)).	self fit! !!TextMorph methodsFor: 'geometry' stamp: 'di 11/16/97 16:52'!goBehind	"We need to save the container, as it knows about fill and run-around"	| cont |	container ifNil: [^ super goBehind].	self releaseParagraph.  "Cause recomposition"	cont _ container.  "Save the container"	super goBehind.  "This will change owner, nilling the container"	container _ cont.  "Restore the container"	self changed! !!TextMorph methodsFor: 'geometry' stamp: 'di 11/12/97 09:33'!layoutChanged	self releaseParagraph.	super layoutChanged! !!TextMorph methodsFor: 'geometry' stamp: 'di 11/13/97 14:46'!privateMoveBy: delta	self releaseEditor.	super privateMoveBy: delta.	paragraph ifNotNil: [paragraph moveBy: delta].	container ifNotNil: [container releaseCachedState]! !!TextMorph methodsFor: 'menu' stamp: 'di 12/3/97 10:14'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'add predecessor' action: #addPredecessor:.	aCustomMenu add: 'add successor' action: #addSuccessor:.	((owner isKindOf: PolygonMorph) and: [owner isOpen]) ifTrue:		[container == nil			ifTrue: [aCustomMenu add: 'follow owner''s curve' action: #followCurve]			ifFalse: [aCustomMenu add: 'reverse direction' action: #reverseCurveDirection.					aCustomMenu add: 'set baseline' action: #setCurveBaseline:]]		ifFalse:		[(container == nil or: [container fillsOwner not])			ifTrue: [aCustomMenu add: 'fill owner''s shape' action: #fillingOnOff]			ifFalse: [aCustomMenu add: 'rectangluar bounds' action: #fillingOnOff].		(container == nil or: [container avoidsOcclusions not])			ifTrue: [aCustomMenu add: 'avoid occlusions' action: #occlusionsOnOff]			ifFalse: [aCustomMenu add: 'ignore occlusions' action: #occlusionsOnOff]].! !!TextMorph methodsFor: 'menu' stamp: 'sw 8/12/97 17:33'!addOptionalHandlesTo: aHalo box: box	| aHandle |	aHandle _ aHalo addHandleAt: box bottomLeft color: Color lightGreen.	aHandle on: #mouseDown send: #chooseFont to: self.	aHandle _ aHalo addHandleAt: (box bottomLeft + (20@0)) color: Color lightRed.	aHandle on: #mouseDown send: #chooseStyle to: self.	aHandle _ aHalo addHandleAt: (box bottomLeft + (40@0)) color: Color lightBrown.	aHandle on: #mouseDown send: #chooseEmphasis to: self.! !!TextMorph methodsFor: 'menu' stamp: 'di 12/3/97 09:32'!followCurve	container _ TextOnCurveContainer new baseline: 0; textDirection: 1.	self changed! !!TextMorph methodsFor: 'menu' stamp: 'di 12/3/97 09:40'!reverseCurveDirection	container textDirection: container textDirection negated.	self paragraph composeAll! !!TextMorph methodsFor: 'menu' stamp: 'di 12/3/97 10:25'!setCurveBaseline: evt	| handle origin |	origin _ evt cursorPoint.	handle _ HandleMorph new forEachPointDo:		[:newPoint | handle removeAllMorphs.		handle addMorph:			(PolygonMorph vertices: (Array with: origin with: newPoint)				color: Color black borderWidth: 1 borderColor: Color black).		container baseline: (newPoint - origin) y negated asInteger // 5.		self paragraph composeAll].	evt hand attachMorph: handle.	handle startStepping	! !!TextMorph methodsFor: 'linked frames' stamp: 'di 11/12/97 09:31'!addPredecessor: evt	| newMorph |	newMorph _ TextMorph new text: text textStyle: textStyle wrap: wrapFlag			color: color predecessor: predecessor successor: self.	newMorph extent: self width @ 100.	predecessor ifNotNil: [predecessor setSuccessor: newMorph].	self setPredecessor: newMorph.	predecessor recomposeChain.	evt hand attachMorph: newMorph! !!TextMorph methodsFor: 'linked frames' stamp: 'di 11/12/97 09:31'!addSuccessor: evt	| newMorph |	newMorph _ TextMorph new text: text textStyle: textStyle wrap: wrapFlag			color: color predecessor: self successor: successor.	newMorph extent: self width @ 100.	successor ifNotNil: [successor setPredecessor: newMorph].	self setSuccessor: newMorph.	successor recomposeChain.	evt hand attachMorph: newMorph! !!TextMorph methodsFor: 'linked frames' stamp: 'di 11/8/97 15:51'!firstCharacterIndex	^ self paragraph firstCharacterIndex! !!TextMorph methodsFor: 'linked frames' stamp: 'jm 10/28/97 18:31'!firstInChain	"Return the first morph in a chain of textMorphs"	| first |	first _ self.  	[first predecessor == nil]		whileFalse: [first _ first predecessor].	^ first! !!TextMorph methodsFor: 'linked frames' stamp: 'di 11/16/97 15:15'!isLinkedTo: aMorph	self firstInChain withSuccessorsDo:		[:m | m == aMorph ifTrue: [^ true]].	^ false! !!TextMorph methodsFor: 'linked frames' stamp: 'jm 10/28/97 18:31'!lastCharacterIndex	^ self paragraph lastCharacterIndex! !!TextMorph methodsFor: 'linked frames' stamp: 'jm 10/28/97 18:31'!predecessor	^ predecessor! !!TextMorph methodsFor: 'linked frames' stamp: 'di 11/12/97 09:10'!recomposeChain	"Recompose this textMorph and all that follow it."	self withSuccessorsDo:		[:m |  m text: text textStyle: textStyle;  "Propagate new style if any"				releaseParagraph;  "Force recomposition"				fit  "and propagate the change"]! !!TextMorph methodsFor: 'linked frames' stamp: 'jm 10/28/97 18:31'!startingIndex	predecessor == nil ifTrue: [^ 1].	^ predecessor lastCharacterIndex + 1! !!TextMorph methodsFor: 'linked frames' stamp: 'jm 10/28/97 18:31'!successor	^ successor! !!TextMorph methodsFor: 'linked frames' stamp: 'jm 10/28/97 18:31'!withSuccessorsDo: aBlock	"Evaluate aBlock for each morph in my successor chain"	| each |	each _ self.	[each == nil]		whileFalse: [aBlock value: each.					each _ each successor]! !!TextMorph methodsFor: 'private' stamp: 'di 11/8/97 16:02'!adjustLineIndicesBy: delta	paragraph ifNotNil: [paragraph adjustLineIndicesBy: delta]! !!TextMorph methodsFor: 'private' stamp: 'di 11/7/97 10:00'!delete	predecessor ifNotNil: [predecessor setSuccessor: successor].	successor ifNotNil: [successor setPredecessor: predecessor.						successor recomposeChain].	super delete! !!TextMorph methodsFor: 'private' stamp: 'di 12/5/97 10:08'!fit	"Adjust bounds to fit the text if not in a rigid container."	| newExtent |	newExtent _ (self paragraph extent max: 9@textStyle lineGrid) + (0@2).	newExtent ~= bounds extent ifTrue:		[(container == nil and: [successor == nil]) ifTrue: [super extent: newExtent]].	container ifNotNil:		[self privateBounds: container bounds truncated].	self paragraph positionWhenComposed: self position.	successor ifNotNil:		[successor predecessorChanged].	self changed. "Too conservative: only paragraph composition					should cause invalidation."! !!TextMorph methodsFor: 'private' stamp: 'di 11/7/97 12:55'!installEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'."	editor ifNotNil: [^ editor].	editor _ TextMorphEditor new morph: self.	editor changeParagraph: self paragraph.	self selectionChanged.	^ editor! !!TextMorph methodsFor: 'private' stamp: 'di 11/13/97 15:17'!loadCachedState	"Prepare for fast response -- next page of a book?"	self paragraph! !!TextMorph methodsFor: 'private' stamp: 'jm 11/19/97 20:31'!paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNotNil: [^ paragraph].	text ifNil: [text _ 'Text' asText allBold].  "Default contents"	"...Code here to recreate the paragraph..."	paragraph _ (self paragraphClass new textOwner: owner)					compose: text style: textStyle copy					from: self startingIndex in: self container.	wrapFlag ifFalse:		["Was given huge container at first... now adjust"		paragraph adjustRightX].	self fit.	^ paragraph! !!TextMorph methodsFor: 'private' stamp: 'jm 11/19/97 19:30'!paragraphClass	container ifNil: [^ NewParagraph].	^ container paragraphClass! !!TextMorph methodsFor: 'private' stamp: 'di 11/8/97 15:55'!predecessorChanged	| newStart oldStart |	newStart _ predecessor == nil		ifTrue: [1]		ifFalse: [predecessor lastCharacterIndex + 1].	(self paragraph adjustedFirstCharacterIndex ~= newStart or: [newStart >= text size])		ifTrue: [paragraph composeAllStartingAt: newStart.				self fit]		ifFalse: ["If the offset to end of text has not changed, just slide"				oldStart _ self firstCharacterIndex.				self withSuccessorsDo:					[:m | m adjustLineIndicesBy: newStart - oldStart]].! !!TextMorph methodsFor: 'private' stamp: 'di 12/3/97 10:44'!releaseEditor 	"Release the editor for my paragraph.  This morph no longer 'hasFocus'."	editor ifNotNil:		[self selectionChanged.		self paragraph selectionStart: nil selectionStop: nil.		editor _ nil].! !!TextMorph methodsFor: 'private' stamp: 'di 11/13/97 14:47'!releaseParagraph	"Paragraph instantiation is lazy -- it will be created only when needed"	self releaseEditor.	paragraph ifNotNil:		[paragraph _ nil].	container ifNotNil:		[container releaseCachedState]! !!TextMorph methodsFor: 'private' stamp: 'di 11/30/97 12:13'!selectionChanged	self paragraph selectionRects do: [:r | self invalidRect: r]! !!TextMorph methodsFor: 'private' stamp: 'di 10/25/97 17:11'!setPredecessor: newPredecessor	predecessor _ newPredecessor! !!TextMorph methodsFor: 'private' stamp: 'di 10/25/97 17:10'!setSuccessor: newSuccessor	successor _ newSuccessor! !!TextMorph methodsFor: 'private' stamp: 'di 10/24/97 11:35'!text: t textStyle: s	"Private -- for use only in morphic duplication"	text _ t.	textStyle _ s.	paragraph ifNotNil: [paragraph textStyle: s]! !!TextMorph methodsFor: 'private' stamp: 'di 11/12/97 09:30'!text: t textStyle: s wrap: wrap color: c	predecessor: pred successor: succ	"Private -- for use only in morphic duplication"	text _ t.	textStyle _ s.	wrapFlag _ wrap.	color _ c.	paragraph _ editor _ container _ nil.	predecessor _ pred.	successor _ succ! !!TextMorph methodsFor: 'private' stamp: 'di 11/12/97 09:12'!updateFromParagraph	| newStyle sel oldLast |	paragraph ifNil: [^ self].	wrapFlag ifNil: [wrapFlag _ true].	editor ifNotNil: [sel _ editor selectionInterval].	paragraph textStyle = textStyle		ifTrue: [self fit]		ifFalse: ["Broadcast style changes to all morphs"				newStyle _ paragraph textStyle.				(self firstInChain text: text textStyle: newStyle) recomposeChain.				sel ifNotNil: [self installEditor selectFrom: sel first to: sel last]].	sel ifNil: [^ self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil:		[sel first <= (paragraph lines first last+1) ifTrue:			[oldLast _ predecessor lastCharacterIndex.			predecessor paragraph recomposeFrom: oldLast orLineAbove: false.			oldLast = predecessor lastCharacterIndex				ifFalse: [predecessor changed. "really only last line"						self predecessorChanged]]].	((predecessor~~nil and: [sel first <= paragraph firstCharacterIndex])		or: [successor~~nil and: [sel first > (paragraph lastCharacterIndex+1)]])		ifTrue:		["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."		self releaseEditor.		self firstInChain withSuccessorsDo:			[:m |  (sel first between: m firstCharacterIndex								and: m lastCharacterIndex+1)					ifTrue: [m installEditor selectFrom: sel first to: sel last.							m selectionChanged.							^ self passKeyboardFocusTo: m]].		^ self].	editor ifNil:		["Reinstate selection after, eg, style change"		self installEditor selectFrom: sel first to: sel last]! !!TextMorph methodsFor: 'private' stamp: 'di 11/11/97 20:45'!updateReferencesUsing: refDict	| anchors range new |	super updateReferencesUsing: refDict.	"Update any anchors in the text of a newly copied morph"	anchors _ IdentityDictionary new.	text runs withStartStopAndValueDo:		[:start :stop :attributes |		attributes do: [:att | (att isMemberOf: TextAnchor)							ifTrue: [anchors at: att put: (start to: stop)]]].	anchors isEmpty ifTrue: [^ self].	anchors keysDo:		[:old |  range _ anchors at: old.		text removeAttribute: old from: range first to: range last.		new _ TextAnchor new anchoredMorph:					(refDict at: old anchoredMorph).		text addAttribute: new from: range first to: range last].	self layoutChanged "for good measure"! !!TextMorph methodsFor: 'object fileIn' stamp: 'di 10/1/97 19:47'!convertbosfceptthpeh0: varDict bosfcepttwpe0: smartRefStrm	"These variables are automatically stored into the new instance ('textStyle' 'text' 'paragraph' 'editor' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('wrapFlag' ) and deal with the information in ('hasFocus' 'hideSelection' )"	wrapFlag _ true.	editor _ nil.	self updateFromParagraph; releaseParagraph.! !!TextMorph methodsFor: 'object fileIn' stamp: 'di 10/24/97 22:01'!convertbosfcepttwpe0: varDict bosfcepttwpecps0: smartRefStrm	"These variables are automatically stored into the new instance ('textStyle' 'text' 'wrapFlag' 'paragraph' 'editor' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('container' 'predecessor' 'successor' ) and deal with the information in ()" 	container _ predecessor _ successor _ nil! !!TextMorph methodsFor: 'containment' stamp: 'di 11/4/97 15:37'!fillingOnOff	"Establish a container for this text, with opposite filling status"	self setContainer:	(container		ifNil: [TextContainer new for: self minWidth: textStyle lineGrid*2]		ifNotNil: [(container fillsOwner and: [container avoidsOcclusions not])			ifTrue: [nil  "Return to simple rectangular bounds"]			ifFalse: [container fillsOwner: container fillsOwner not]])! !!TextMorph methodsFor: 'containment' stamp: 'di 11/4/97 15:37'!occlusionsOnOff	"Establish a container for this text, with opposite occlusion avoidance status"	self setContainer:	(container	ifNil: [(TextContainer new for: self minWidth: textStyle lineGrid*2)							fillsOwner: false; avoidsOcclusions: true]	ifNotNil: [(container avoidsOcclusions and: [container fillsOwner not])			ifTrue: [nil  "Return to simple rectangular bounds"]			ifFalse: [container avoidsOcclusions: container avoidsOcclusions not]])! !!TextMorph methodsFor: 'containment' stamp: 'di 11/16/97 15:15'!ownerChanged	container ifNotNil:		[self releaseParagraph]! !!TextMorph methodsFor: 'containment' stamp: 'di 10/28/97 11:00'!privateOwner: newOwner	"Nil the container when text gets extracted"	super privateOwner: newOwner.	container ifNotNil: [self setContainer: nil]! !!TextMorph methodsFor: 'containment' stamp: 'di 11/12/97 09:06'!setContainer: newContainer	"Adopt (or abandon) container shape"	self changed.	container _ newContainer.	self releaseParagraph! !!TextMorph methodsFor: 'anchors' stamp: 'di 12/4/97 15:18'!addMorphBack: aMorph fromWorldPosition: wp 	"Overridden for more specific re-layout and positioning"	| i |	self addMorphBack: aMorph.	i _ (self paragraph characterBlockAtPoint: (self transformFromWorld transform: wp))		stringIndex.	self paragraph replaceFrom: i to: i-1		with: (Text string: '*' attribute: (TextAnchor new anchoredMorph: aMorph))		displaying: false.	self fit! !!TextMorph methodsFor: 'anchors' stamp: 'di 11/12/97 11:31'!privateRemoveMorph: aMorph	| range |	range _ text find: (TextAnchor new anchoredMorph: aMorph).	range ifNotNil:		[self paragraph replaceFrom: range first to: range last				with: Text new displaying: false.		self fit.		aMorph position: 0@0.   "so fits in hand"].	super privateRemoveMorph: aMorph! !!TextMorph class methodsFor: 'as yet unclassified' stamp: 'jm 11/5/97 12:26'!initialize	"TextMorph initialize"	"Initialize constants shared by classes associated with text display."	CaretForm _ (ColorForm extent: 16@5					fromArray: #(2r001100e26 2r001100e26 2r011110e26 2r111111e26 2r110011e26)					offset: -2@0)					colors: (Array with: Color transparent with: self new selectionColor).! !!TextMorphEditor methodsFor: 'all'!accept	"Save the current text of the text being edited as the current acceptable version for purposes of canceling.  Allow my morph to take appropriate action"	super accept.	morph acceptContents! !!TextMorphEditor methodsFor: 'all' stamp: 'di 1/14/98 09:58'!changeEmphasis: characterStream 	"May be a request to create a link (Cmd-6).  Intercept if so, else call super"	| keyCode attribute index colors |	"Test if it's really the droids we're looking for..."	keyCode _ ('0123456789-=' indexOf: sensor keyboardPeek ifAbsent: [1]) - 1.	keyCode ~= 6 ifTrue: [^ super changeEmphasis: characterStream "handle other keys"].	sensor keyboard  "Yes, it is Cmd-6;  consume the command character".	colors _ #(black magenta red yellow green blue cyan white).	index _ (PopUpMenu labelArray: colors , #(active)							lines: (Array with: colors size)) startUp.	index = 0 ifTrue: [^ true].	index <= colors size ifTrue:		[attribute _ TextColor color: (Color perform: (colors at: index))].	(index - colors size) = 1 ifTrue:		[attribute _ TextMorphHotLink new sourceString: self selection asString					targetMorph: morph					parameterString: (FillInTheBlank										request: 'Secondary text for this link (or CR)...'										initialAnswer: '')].	self replaceSelectionWith: (self selection addAttribute: attribute).	^ true! !!TextMorphEditor methodsFor: 'all' stamp: 'tk 10/24/97 15:44'!doIt	^ Utilities evaluate: self selectionAsStream in: nil to: morph! !!TextMorphEditor methodsFor: 'all'!morph: aMorph	"Install a link back to the morph being editted (esp for text links)"	morph _ aMorph! !!TextMorphEditor methodsFor: 'all' stamp: 'tk 1/7/98 12:04'!mouseDown: evt 	"An attempt to break up the old processRedButton code into threee phases"	| clickPoint |	oldInterval _ startBlock stringIndex to: stopBlock stringIndex - 1.	clickPoint _ evt cursorPoint.	(paragraph clickAt: clickPoint for: nil controller: self) ifTrue: [^ self].	self closeTypeIn.  "probably not necess"	sensor leftShiftDown		ifFalse:			[stopBlock _ startBlock _ pivotBlock _				paragraph characterBlockAtPoint: clickPoint]		ifTrue:			[(paragraph characterBlockAtPoint: clickPoint) <= startBlock			ifTrue: [stopBlock _ startBlock.					pivotBlock _ stopBlock]			ifFalse: [startBlock _  stopBlock.					pivotBlock _ startBlock]].	paragraph selectionStart: startBlock selectionStop: stopBlock! !!TextMorphEditor methodsFor: 'all' stamp: 'di 11/30/97 10:48'!mouseMove: evt 	"Change the selection in response to moue-down drag"	| dragBlock |	dragBlock _ paragraph characterBlockAtPoint: (evt cursorPoint).	dragBlock > pivotBlock		ifTrue: [stopBlock _ dragBlock.  startBlock _ pivotBlock]		ifFalse: [startBlock _ dragBlock.  stopBlock _ pivotBlock].	paragraph selectionStart: startBlock selectionStop: stopBlock! !!TextMorphEditor methodsFor: 'all' stamp: 'di 12/1/97 20:09'!mouseUp: evt	"An attempt to break up the old processRedButton code into threee phases"	(startBlock = stopBlock 		and: [oldInterval = (startBlock stringIndex to: startBlock stringIndex-1)])		ifTrue: [self selectWord].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval].	paragraph selectionStart: startBlock selectionStop: stopBlock! !!TextMorphEditor methodsFor: 'all' stamp: 'di 10/2/97 11:38'!mvcRedisplay	"Ignore mvcRedisplay requests."! !!TextMorphEditor methodsFor: 'all' stamp: 'tk 10/24/97 15:27'!printIt	"Treat the current text selection as an expression; evaluate it. Insert the 	description of the result of evaluation after the selection and then make 	this description the new text selection."	| result aString |	result _ self doIt.	result ~~ #failedDoit		ifTrue: [			aString _ result printString.			self replace: (stopBlock stringIndex to: stopBlock stringIndex - 1) 				with: (' ' , aString) asText and: [self selectAndScroll] ]! !!TextMorphEditor methodsFor: 'all' stamp: 'di 11/30/97 11:30'!readKeyboard	super readKeyboard.	paragraph selectionStart: startBlock selectionStop: stopBlock! !!TextMorphEditor methodsFor: 'all' stamp: 'di 10/2/97 09:08'!scrollBy: ignore 	"Ignore scroll requests."! !!TextMorphEditor methodsFor: 'all'!select	"Ignore selection redraw requests."! !!TextMorphEditor methodsFor: 'all'!updateMarker	"Ignore scrollbar redraw requests."! !!TextMorphEditor methodsFor: 'all' stamp: 'di 10/1/97 17:00'!zapSelectionWith: aText	"**overridden to inhibit old-style display"	| start stop |	self deselect.	start _ startBlock stringIndex.	stop _ stopBlock stringIndex.	(start = stop and: [aText size = 0]) ifFalse:		[paragraph replaceFrom: start to: stop - 1			with: aText displaying: false.  "** was true in super"		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval]! !!TextMorphEditor methodsFor: 'as yet unclassified' stamp: 'jm 10/28/97 18:31'!align	"Align text according to the next greater alignment value,	cycling among leftFlush, rightFlush, center, and justified."	paragraph textStyle alignment: paragraph textStyle alignment + 1.	self recomputeInterval! !!TextMorphEditor methodsFor: 'as yet unclassified' stamp: 'jm 10/28/97 18:31'!selectAndScroll	"Ignore scroll requests."! !!TextMorphEditor methodsFor: 'as yet unclassified' stamp: 'di 11/30/97 11:27'!selectFrom: start to: stop	"Select the specified characters inclusive."	self selectInvisiblyFrom: start to: stop.	self closeTypeIn.	paragraph selectionStart: startBlock selectionStop: stopBlock! !!TextMorphHotLink methodsFor: 'all'!actOnClickFor: anObject	"MouseDown on this link"	targetMorph xeqLinkText: evalString withParameter: parameterString.	^ true! !!TextMorphHotLink methodsFor: 'all'!sourceString: str1 targetMorph: morph parameterString: str2	evalString _ str1.	targetMorph _ morph.	parameterString _ str2! !TextOnCurve comment:'This subclass of Paragraph composes and displays text along a segmented line or curve.  It does this by using all the normal text composition machinery, but just to lay text out for each segment of the curve in question.  The display process is somewhat complicated, as it involves rotating the text for each segment, and then merging it into the destination Form with background, selection highlight, and transparency all handled correctly.Because TextMorph flushes its paragraph to save space, the enduring specification of curve layout (direction, baseline, and margin) must be stored in the container.'!!TextOnCurve methodsFor: 'all' stamp: 'di 12/3/97 09:06'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| sourcePoint cb curvePoint |	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(destRect containsPoint: aPoint) ifTrue:			["It's in the destRect; now convert to source coords"			sourcePoint _ self pointInLine: line forDestPoint: aPoint							segStart: segStart segAngle: segAngle.			cb _ (CharacterBlockScanner new text: text textStyle: textStyle)				characterBlockAtPoint: (sourcePoint adhereTo: line rectangle)				index: nil in: line.			(sourcePoint x between: line left and: line right) ifTrue:				["Definitely in this segment"				^ cb]]].	"Point is off curve -- try again with closest point on curve"	curvePoint _ curve closestPointTo: aPoint.	curvePoint = aPoint ifFalse:		[^ self characterBlockAtPoint: curvePoint].	"If all else fails, at least return something acceptable."	^ cb ifNil: [self defaultCharacterBlock]! !!TextOnCurve methodsFor: 'all' stamp: 'di 12/4/97 09:47'!composeLinesFrom: startingIndex withLines: startingLines atY: startingY	"Here we determine the 'lines' of text that will fit along each segment of the curve. For each line, we determine its rectangle, then the dest wuadrilateral that it willbe rotated to.  Then, we take the outer hull to determine a dest rectangle for WarpBlt.  In addition we need the segment pivot point and angle, from which the source quadrilateral may be computed."	| charIndex scanner line firstLine curveSegments segIndex pa pb segLen lineRect textSegments segDelta segAngle destRect destQuad i oldBounds |	(oldBounds _ container bounds) ifNotNil:		[curve invalidRect: oldBounds].	charIndex _ startingIndex.	lines _ startingLines.	curveSegments _ curve lineSegments.	container textDirection < 0 ifTrue:		[curveSegments _ curveSegments reversed collect:				[:seg | Array with: (seg at: 2) with: (seg at: 1)]].	textSegments _ OrderedCollection new.	scanner _ SegmentScanner new text: text textStyle: textStyle.	segIndex _ 1.  "For curves, segIndex is just an index."	firstLine _ true.	pa _ curveSegments first first.	[charIndex <= text size and: [segIndex <= curveSegments size]]		whileTrue:		[curve isCurve ifFalse: [pa _ (curveSegments at: segIndex) first].		pb _ (curveSegments at: segIndex) last.		segDelta _ pb - pa.  "Direction of this segment"		segLen _ segDelta r.		lineRect _ 0@0 extent: segLen asInteger@textStyle lineGrid.		line _ scanner composeFrom: charIndex inRectangle: lineRect						firstLine: firstLine leftSide: true rightSide: true.		line setRight: scanner rightX.		line width > 0 ifTrue:			[lines addLast: line.			segAngle _ segDelta theta.			destQuad _ line rectangle corners collect:						[:p | (p translateBy: pa - (0@(line baseline + container baseline)))								rotateBy: segAngle negated about: pa].			destRect _ Rectangle encompassing: destQuad.			textSegments addLast: (Array with: destRect truncated with: pa with: segAngle).			pa _ pa + ((pb-pa) * line width / segLen).			charIndex _ line last + 1].		segIndex _ segIndex + 1.		firstLine _ false].	lines size = 0 ifTrue:		["No space in container or empty text"		line _ (TextLine start: startingIndex stop: startingIndex-1						internalSpaces: 0 paddingWidth: 0)				rectangle: (0@0 extent: 10@textStyle lineGrid);				lineHeight: textStyle lineGrid baseline: textStyle baseline.		lines _ Array with: line.		textSegments addLast:			(Array with: (curve vertices first extent: line rectangle extent) 					with: curve vertices first with: 0.0).].	"end of segments, now attempt word break."	lines last last < text size ifTrue:		[[lines size > 1 and: [(text at: (i _ lines last last)+1) ~= Character space]]			whileTrue:			[i = lines last first				ifTrue: [lines removeLast.  textSegments removeLast]				ifFalse: [lines last stop: i-1]]].	lines _ lines asArray.	container textSegments: textSegments asArray.	curve invalidRect: container bounds.	^ maxRightX! !!TextOnCurve methodsFor: 'all' stamp: 'di 12/3/97 09:06'!containsPoint: aPoint	"Return true if aPoint is in the actual text areas."	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(destRect containsPoint: aPoint) ifTrue:			["It's in the destRect; now check if really in text area"			(line rectangle containsPoint:				(self pointInLine: line forDestPoint: aPoint					segStart: segStart segAngle: segAngle))				ifTrue: [^ true]]].	^ false! !!TextOnCurve methodsFor: 'all' stamp: 'tk 12/8/97 14:26'!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| maxExtent lineForm leftInRun lineRect warp sourceQuad backgroundColor lineCanvas |	warp _ nil.	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		false ifTrue:			["Show the dest rects for debugging..."			aCanvas frameRectangle: destRect width: 1 color: Color black].		(aCanvas isVisible: destRect) ifTrue:			[warp ifNil:				["Lazy initialization because may hot have to display at all."				maxExtent _ lines inject: lines first rectangle extent 					into: [:maxWid :lin | maxWid max: lin rectangle extent].				lineForm _ Form extent: maxExtent depth: aCanvas depth.				displayScanner setDestForm: lineForm.				lineRect _ lineForm boundingBox.				leftInRun _ 0.				backgroundColor _ (curve borderWidth > 10							ifTrue: [curve color]							ifFalse: [curve owner isHandMorph									ifTrue: [curve owner owner color]									ifFalse: [curve owner color]]) dominantColor.				warp _ (aCanvas warpFrom: lineRect corners toRect: lineRect)						cellSize: 2;  "installs a colormap if smoothing > 1"						sourceForm: lineForm.				warp colorMap: (self warpMapForDepth: aCanvas depth									withTransparentFor: backgroundColor).				lineCanvas _ FormCanvas on: lineForm].			sourceQuad _ destRect innerCorners collect:				[:p | self pointInLine: line forDestPoint: p						segStart: segStart segAngle: segAngle].			lineForm fill: lineForm boundingBox fillColor: backgroundColor.			self displaySelectionInLine: line on: lineCanvas.			leftInRun _ displayScanner displayLine: line offset: 0@0 leftInRun: leftInRun.			warp sourceQuad: sourceQuad destRect: (destRect translateBy: aCanvas origin).			warp warpBits]].! !!TextOnCurve methodsFor: 'all' stamp: 'jm 11/19/97 22:38'!extent	^ curve bounds extent! !!TextOnCurve methodsFor: 'all' stamp: 'di 11/29/97 20:23'!moveBy: delta	positionWhenComposed _ positionWhenComposed + delta.	container _ container translateBy: delta! !!TextOnCurve methodsFor: 'all' stamp: 'di 12/3/97 10:24'!pointInLine: line forDestPoint: p segStart: segStart segAngle: segAngle	^ (p rotateBy: segAngle about: segStart)			translateBy: (0@(line baseline + container baseline)) - segStart! !!TextOnCurve methodsFor: 'all' stamp: 'di 11/29/97 20:15'!releaseCachedState	super releaseCachedState.	CachedWarpMap _ CachedWarpDepth _ CachedWarpColor _ nil! !!TextOnCurve methodsFor: 'all' stamp: 'di 12/3/97 09:06'!selectionRectsFrom: characterBlock1 to: characterBlock2	"Return an array of rectangles encompassing the area	between the two character blocks, presumably a selection."	| rects |	rects _ OrderedCollection new.	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(characterBlock1 stringIndex <= line last			and: [characterBlock2 stringIndex >= line first]) ifTrue:			[rects addLast: destRect].		line first > characterBlock2 stringIndex ifTrue:			[^ rects]].	^ rects! !!TextOnCurve methodsFor: 'all' stamp: 'jm 11/19/97 20:29'!textOwner: theCurve	curve _ theCurve! !!TextOnCurve methodsFor: 'all' stamp: 'di 12/3/97 09:10'!textSegmentsDo: blockForLineDestPivotAngle	| segments segSpec |	(segments _ container textSegments) ifNil: [^ self].	1 to: lines size do:		[:i | segSpec _ segments at: i.		blockForLineDestPivotAngle			value: (lines at: i)			value: (segSpec at: 1)			value: (segSpec at: 2)			value: (segSpec at: 3)]! !!TextOnCurve methodsFor: 'all' stamp: 'di 11/29/97 12:20'!warpMapForDepth: destDepth withTransparentFor: bkgndColor	(CachedWarpDepth = destDepth and: [CachedWarpColor = bkgndColor])		ifTrue: ["Map is OK as is -- return it"				^ CachedWarpMap].	(CachedWarpMap == nil or: [CachedWarpDepth ~= destDepth])		ifTrue: ["Have to recreate the map"				CachedWarpMap _ Color computeColormapFrom: 32 to: destDepth.				CachedWarpDepth _ destDepth]		ifFalse: ["Map is OK, if we restore prior color substiution"				CachedWarpMap at: (CachedWarpColor indexInMap: CachedWarpMap)					put: (CachedWarpColor pixelValueForDepth: destDepth)].	"Now map the background color into transparent, and return the new map"	CachedWarpColor _ bkgndColor.	CachedWarpMap at: (CachedWarpColor indexInMap: CachedWarpMap)					put: 0.	^ CachedWarpMap! !TextOnCurveContainer comment:'I am not really a container in the sense of TextContainer.  However, I get stored in the same field of a textMorph.  My baseline specifies the vertical displacement of the character baselines from the curve center (0 means on center, 5 would mean, eg, the character baselines are 5 pixels above the curve center).  This is ssential enduring information.  I also cache temporary layout information, including the locations, angles and bounding boxes of each of the characters as displayed.'!!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/3/97 10:22'!baseline	baseline ifNil: [^ 0].	^ baseline! !!TextOnCurveContainer methodsFor: 'all' stamp: 'jm 11/19/97 19:30'!baseline: newBaseline	baseline _ newBaseline! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/4/97 08:32'!bounds	textSegments ifNil: [^ nil].	^ textSegments inject: (textSegments first at: 1)		into: [:bnd :each | bnd merge: (each at: 1)]! !!TextOnCurveContainer methodsFor: 'all' stamp: 'jm 11/19/97 19:28'!paragraphClass	^ TextOnCurve! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/4/97 08:28'!releaseCachedState	textSegments _ nil.! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/3/97 09:16'!textDirection	^ textDirection! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/4/97 09:23'!textDirection: plusOrMinusOne	textDirection _ plusOrMinusOne! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/3/97 09:29'!textSegments	^ textSegments! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/3/97 09:29'!textSegments: segments	textSegments _ segments! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 11/21/97 21:48'!top	^ 1  "for compatibility"! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 1/9/98 11:49'!translateBy: delta	textSegments == nil ifTrue: [^ self].	textSegments _ textSegments collect:		[:ls | Array with: ((ls at: 1) translateBy: delta)					with: ((ls at: 2) translateBy: delta)					with: (ls at: 3)]! !!TextStream methodsFor: 'as yet unclassified'!applyAttribute: att beginningAt: startPos	collection addAttribute: att from: startPos to: self position! !!TextStream methodsFor: 'as yet unclassified'!nextPutAll: aCollection 	"Optimized access to get around Text at:Put: overhead"	| n |	n _ aCollection size.	((aCollection isMemberOf: String) not or: [position + n > writeLimit])		ifTrue: [^ super nextPutAll: aCollection].	collection string		replaceFrom: position+1		to: position + n		with: aCollection		startingAt: 1.	position _ position + n! !!TextStream methodsFor: 'as yet unclassified'!withAttribute: att do: strmBlock	| pos1 val |	pos1 _ self position.	val _ strmBlock value.	collection addAttribute: att from: pos1+1 to: self position.	^ val! !A textStyle comprises the formatting information for composing and displaying a unit (usually a paragraph) of text.  Typically one makes a copy of a master textStyle (such as TextStyle default), and then that copy may get altered in the process of editing.  Bad things can happen if you do not copy first.Each of my instances consists of...	fontArray		An array of StrikeFonts	fontFamilySize	unused	lineGrid			An integer; default line spacing for paragraphs	baseline			An integer; default baseline (dist from line top to bottom of an 'a')	alignment		An integer; text alignment, see TextStyle alignment:	firstIndent		An integer; indent of first line in pixels	restIndent		An integer; indent of remaining lines in pixels	rightIndent		An integer; indent of right margin rel to section	tabsArray		An array of integers giving tab offsets in pixels	marginTabsArray	An array of margin tabs	leading			An integer giving default vertical line separationFor a concrete example, look at TextStyle default copy inspect!]style[(367 10 211 20 381 30)f1,f1LStrikeFont Comment;,f1,f1LTextStyle alignment:;,f1,f1dTextStyle default copy inspect;;!!TextStyle methodsFor: 'accessing' stamp: 'di 10/24/97 11:17'!= other	other class == self class ifFalse: [^ false].	1 to: self class instSize do:		[:i | (self instVarAt: i) == (other instVarAt: i) ifFalse: [^ false]].	^ true! !!TextStyle methodsFor: 'accessing'!centered	alignment _ 2! !!TextStyle methodsFor: 'accessing'!justified	alignment _ 3! !!TextStyle methodsFor: 'accessing'!leading	"Leading (from typographers historical use of extra lead (type metal))	is the extra spacing above and beyond that needed just to accomodate	the various font heights in the set."	^ leading! !!TextStyle methodsFor: 'accessing'!leading: yDelta	leading _ yDelta! !!TextStyle methodsFor: 'accessing'!leftFlush	alignment _ 0! !!TextStyle methodsFor: 'accessing' stamp: 'di 10/24/97 11:26'!printOn: aStream	super printOn: aStream.	aStream space; nextPutAll: self defaultFont familySizeFace first! !!TextStyle methodsFor: 'accessing'!rightFlush	alignment _ 1! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'tk 11/24/97 16:02'!collectionFromFileNamed: fileName	"Read the file.  It is an Array of StrikeFonts.  File format is the ReferenceStream format.  (Do not use SmartRefStream, it is too smart.  It only writes a DiskProxy!!)   For any fonts with new names, add them to DefaultTextStyle.fontArray.  	To write out fonts: 		| ff | ff _ ReferenceStream fileNamed: 'new fonts'.		ff nextPut: (TextStyle default fontArray).		ff close.	To read: (TextStyle default collectionFromFileNamed: 'new fonts')*** Do not remove this method *** "	| ff this names |	ff _ ReferenceStream fileNamed: fileName.	this _ ff nextAndClose.		"Only works if file created by ReferenceStream, not SmartRefStream"	this class == Array ifTrue:			[names _ self fontNames.			this do: [:each | each class == StrikeFont ifTrue:				[(names includes: each name) ifFalse:					[fontArray _ fontArray copyWith: each]]]].! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'di 10/11/97 09:23'!fontIndexOfSize: desiredHeight	"Returns an index in fontArray of the font with height <= desiredHeight"	"Leading is not inluded in the comparison"	| bestMatch bestIndex d |	bestMatch _ 9999.  bestIndex _ 1.	1 to: fontArray size do:		[:i | d _ desiredHeight - (fontArray at: i) height.		d = 0 ifTrue: [^ i].		(d > 0 and: [d < bestMatch]) ifTrue: [bestIndex _ i. bestMatch _ d]].	^ bestIndex! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'di 10/11/97 09:33'!fontOfSize: aHeight	"See fontIndexOfSize.	Returns the actual font.  Leading not considered."	^ fontArray at: (self fontIndexOfSize: aHeight)! !!TextStyle methodsFor: 'private'!consolidate	"If this style includes any fonts that are also in the default style,	then replace them with references to the default ones.""	TextStyle allInstancesDo: [:s | s == TextStyle default ifFalse: [s consolidate]]"	| defFonts font |	defFonts _ TextStyle default fontArray.	1 to: fontArray size do:		[:i | font _ fontArray at: i.		1 to: defFonts size do:			[:j | (font name asUppercase copyWithout: $ )			= ((defFonts at: j) name asUppercase copyWithout: $ )			ifTrue: [fontArray at: i put: (defFonts at: j)]]]! !!TextStyle methodsFor: 'private'!gridForFont: fontIndex withLead: leadInteger 	"Force whole style to suit one of its fonts. Assumes only one font referred	to by runs."	| font |	font _ self fontAt: fontIndex.	self lineGrid: font height + leadInteger.	self baseline: font ascent.	self leading: leadInteger! !!TextStyle methodsFor: 'private' stamp: 'tk 8/20/96'!newFontArray: anArray	"Currently there is no supporting protocol for changing these arrays. If an editor wishes to implement margin setting, then a copy of the default should be stored with these instance variables.  	, Make size depend on first font."	fontArray _ anArray.	lineGrid _ (fontArray at: 1) height + leading.	"For whole family"	baseline _ (fontArray at: 1) ascent + leading.	alignment _ 0.	firstIndent _ 0.	restIndent _ 0.	rightIndent _ 0.	tabsArray _ DefaultTabsArray.	marginTabsArray _ DefaultMarginTabsArray"TextStyle allInstancesDo: [:ts | ts newFontArray: TextStyle default fontArray]."! !!TextStyle methodsFor: 'Disk I/O' stamp: 'tk 5/13/97'!storeDataOn: aDataStream	"Store myself on a DataStream. This is a low-level DataStream/ReferenceStream method. See also objectToStoreOnDataStream.  Need this to share tabsArray and marginTabsArray.  Fonts will take care of themselves.  "	| cntInstVars cntIndexedVars instVars ti tm |	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	instVars _ self class allInstVarNames.	ti _ (instVars indexOf: 'tabsArray').	tm _ (instVars indexOf: 'marginTabsArray').	(ti = 0) | (tm = 0) | (ti > tm) ifTrue: [self error: 'this method is out of date'].	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: ti-1 do:		[:i | aDataStream nextPut: (self instVarAt: i)].	tabsArray == DefaultTabsArray 		ifTrue: [aDataStream nextPut: (DiskProxy global: #TextConstants selector: #at: 						args: #(DefaultTabsArray))]		ifFalse: [aDataStream nextPut: tabsArray].	ti+1 to: tm-1 do:		[:i | aDataStream nextPut: (self instVarAt: i)].	marginTabsArray == DefaultMarginTabsArray		ifTrue: [aDataStream nextPut: (DiskProxy global: #TextConstants selector: #at: 						args: #(DefaultMarginTabsArray))]		ifFalse: [aDataStream nextPut: marginTabsArray].	tm+1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !!TextStyle class methodsFor: 'instance creation' stamp: 'di 6/16/97 12:31'!changeDefaultFontSizeBy: delta      "TextStyle changeDefaultFontSizeBy: 1"	"This sample method recreates the default textStyle, with font 1 being a size	larger than the smallest.  It then initializes most references in the system	as well, although most windows will have to beclosed and reopened to get the effect."	| allFonts |	allFonts _ TextStyle default fontArray asSortedCollection: [:a :b | a height < b height].	TextConstants at: #DefaultTextStyle put:		(TextStyle fontArray: ((1 to: allFonts size) collect: [:i | allFonts atWrap: i+delta])).	PopUpMenu initialize.  "Change this method for difft menu font"	ListParagraph initialize.  "Change this method for difft ListPane font"	StandardSystemView initialize.  "Change this method for difft Window label font"! !!TextStyle class methodsFor: 'instance creation'!initDefaultFontsAndStyle	"This provides the system with 10 and 12-pt basal fonts.	Bold and italic versions will be automatically generated as needed"	| fontArray |		fontArray _ Array new: 2.	fontArray at: 1 put: (StrikeFont new readFromStrike2: 'NewYork10.sf2').	fontArray at: 2 put: (StrikeFont new readFromStrike2: 'NewYork12.sf2').	TextConstants at: #DefaultTextStyle put:		(TextStyle fontArray: fontArray).	"TextStyle initDefaultFontsAndStyle."! !!TextStyle class methodsFor: 'instance creation'!new	^ super new leading: 2! !!TextStyle class methodsFor: 'constants' stamp: 'di 10/20/97 20:08'!named: familyName	^ TextConstants at: familyName asSymbol ifAbsent: [nil]! !!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 11:11'!actOnClickFor: anObject	"Do what you can with this URL.  Later a web browser."	| response |	(url asLowercase endsWith: '.gif') ifTrue: [		HTTPSocket httpShowGif: url].	"opens a new window"	response _ (PopUpMenu labels: 'View web page as source\Cancel' withCRs)		startUpWithCaption: 'Sorry, we don''t have a web browser yet'.	response = 1 ifTrue: [HTTPSocket httpShowPage: url].	^ true! !!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:47'!analyze: aString	| list |	list _ super analyze: aString.	url _ list at: 1.	^ list at: 2! !!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 10:33'!info	^ url! !!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 08:55'!url: aString	url _ aString! !!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 13:45'!writeScanOn: strm	strm nextPut: $R; nextPutAll: url; nextPut: $;! !!TextURL class methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:24'!scanFrom: strm	"read a link in the funny format used by Text styles on files. Rhttp://www.disney.com;"	^ self new url: (strm upTo: $;)! !!TGoToNode methodsFor: 'all'!copyTree	^self class new setLabel: label! !!TGoToNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C goto statement."	aStream nextPutAll: 'goto '.	aStream nextPutAll: label.! !!TGoToNode methodsFor: 'all'!isGoTo	^true! !!TGoToNode methodsFor: 'all'!label	^label! !!TGoToNode methodsFor: 'all'!printOn: aStream level: level	aStream nextPutAll: 'goto '.	aStream nextPutAll: label.! !!TGoToNode methodsFor: 'all'!setLabel: aString	label _ aString.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:49'!actionSelector	^ actionSelector! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:49'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:49'!actWhen: condition	"Accepts symbols:  #buttonDown, #buttonUp, and #whilePressed"	actWhen _ condition! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 7/1/97 12:39'!arguments	^ arguments! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 7/1/97 08:39'!arguments: aCollection	arguments _ aCollection asArray copy.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/29/97 21:04'!authorModeOwner: aMorph	AuthorModeOwner _ aMorph! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:52'!doButtonAction	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		Cursor normal showWhile: [			target perform: actionSelector withArguments: arguments]].! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/29/97 21:02'!dragIfAuthoring: evt	"Allow simple dragging if the class var is set to my owner."	owner == AuthorModeOwner ifTrue: [		self center: evt cursorPoint].	^ owner == AuthorModeOwner! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:03'!drawOn: aCanvas	state == #off ifTrue: [		offImage ifNotNil: [aCanvas image: offImage at: bounds origin]].	state == #pressed ifTrue: [		pressedImage ifNotNil: [aCanvas image: pressedImage at: bounds origin]].	state == #on ifTrue: [		image ifNotNil: [aCanvas image: image at: bounds origin]].! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 7/1/97 09:14'!extent	"Do it normally"	^ bounds extent! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 7/1/97 09:14'!extent: aPoint	"Do it normally"		self changed.	bounds _ bounds topLeft extent: aPoint.	self layoutChanged.	self changed.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:52'!handlesMouseDown: evt	^ true! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 7/1/97 08:34'!initialize	super initialize.	state _ #off.	target _ nil.	actionSelector _ #flash.	arguments _ EmptyArray.	actWhen _ #buttonUp.	"self on: #mouseStillDown send: #dragIfAuthoring: to: self."		"real move should include a call on dragIfAuthoring: "! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 11/5/97 17:54'!mouseDown: evt	self state: #pressed.	actWhen == #buttonDown		ifTrue: [self doButtonAction].self flag: #noteToScott.	"Your immediate action on mouseDown is removed.  --Ted."! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 11:01'!mouseMove: evt	(self containsPoint: evt cursorPoint)		ifTrue: [self state: #pressed.				actWhen == #whilePressed ifTrue: [self doButtonAction]]		ifFalse: [self state: #off].! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 7/2/97 08:26'!mouseUp: evt		(actWhen == #buttonUp and: [self containsPoint: evt cursorPoint])		ifTrue: [self state: #on.			self doButtonAction]		ifFalse: [self state: #off.			target ifNotNil: [target mouseUpBalk: evt]].			"Allow owner to keep it selected for radio buttons"! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 10/19/97 15:02'!offImage	^ offImage! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:08'!offImage: aForm	offImage _ aForm.	self invalidRect: self bounds.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 10/19/97 15:02'!onImage	^ image! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:08'!onImage: aForm	image _ aForm.	self invalidRect: self bounds.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 10/19/97 15:02'!pressedImage	^ pressedImage! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:09'!pressedImage: aForm	pressedImage _ aForm.	self invalidRect: self bounds.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 7/1/97 14:06'!printOn: aStream	| string |	aStream nextPutAll: '3PButton'.	arguments size > 0 ifTrue: [string _ arguments at: (2 min: arguments size)].	aStream nextPutAll: '('.	string ifNotNil: [			aStream print: string; space]. 	aStream print: self identityHash;			nextPutAll: ')'.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 11:01'!state: newState	"Change the image and invalidate the rect."	newState == state ifTrue: [^ self].	state _ newState.	self invalidRect: bounds.	"All three images must be the same size"! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:50'!target	^ target! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:50'!target: anObject	target _ anObject! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'jm 7/28/97 11:56'!updateReferencesUsing: aDictionary	"If the arguments array points at a morph we are copying, then update it to point to the new copy. This method also copies the arguments array itself, which is important!!"	super updateReferencesUsing: aDictionary.	arguments _ arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !!ThumbnailMorph methodsFor: 'all' stamp: 'sw 10/18/97 18:03'!drawOn: aCanvas	"Draw a small view of a morph in another place.  Guard againstinfinite recursion if that morph has a thumbnail of itself inside."	| viewedMorphBox myBox scale c shrunkForm diag actualViewee |	super drawOn: aCanvas.	morphToView ifNil: [^ self].	morphToView isInWorld ifFalse: [^ self].	(RecursionDepth _ RecursionDepth + 1) > RecursionMax ifTrue: [^ self].	actualViewee _ viewSelector ifNil: [morphToView] ifNotNil: [morphToView perform: viewSelector].	actualViewee == 0 "Unusual return of valueAtCursor to mean empty!!!!"		ifTrue:			[RecursionDepth _ RecursionDepth - 1. ^ self].	(actualViewee isKindOf: SketchMorph)		ifTrue:			[diag _ actualViewee form extent r asInteger.			viewedMorphBox _				(actualViewee bounds center - (diag // 2)) extent: diag@diag]		ifFalse:			[viewedMorphBox _ actualViewee fullBounds].	myBox _ self innerBounds.	scale _ myBox width / (viewedMorphBox width max: viewedMorphBoxheight).	c _ FormCanvas extent: viewedMorphBox extent depth: aCanvas depth.	c _ c copyOffset: viewedMorphBox topLeft negated.	actualViewee fullDrawOn: c.		"recursion happens here"	shrunkForm _ c form magnify: c form boundingBox by: scale smoothing: 1.	aCanvas image: shrunkForm at: self center - shrunkForm boundingBoxcenter.	RecursionDepth _ RecursionDepth - 1.	"up a level"! !!ThumbnailMorph methodsFor: 'all'!initialize	super initialize.	self extent: 25@25.	self color: (Color r: 0.781 g: 0.781 b: 0.781).	self borderWidth: 1.! !!ThumbnailMorph methodsFor: 'all'!morphToView	^ morphToView! !!ThumbnailMorph methodsFor: 'all' stamp: 'sw 10/18/97 18:03'!morphToView: aMorphOrNil	self morphToView: aMorphOrNil viewSelector: #yourself! !!ThumbnailMorph methodsFor: 'all' stamp: 'sw 10/18/97 18:03'!morphToView: aMorphOrNil viewSelector: aSelector.	(aMorphOrNil allMorphs includes: self) ifTrue:		["cannot view a morph containing myself or drawOn: goes into infinite recursion"		morphToView _ nil.		^ self].	morphToView _ aMorphOrNil..	viewSelector _ aSelector! !!ThumbnailMorph methodsFor: 'all'!step	self changed.! !!ThumbnailMorph methodsFor: 'all'!stepTime	^ 50! !!ThumbnailMorph class methodsFor: 'as yet unclassified' stamp: 'tk 9/8/9708:30'!initialize	RecursionMax _ 2.	RecursionDepth _ 0.! !!ThumbnailMorph class methodsFor: 'as yet unclassified' stamp: 'tk 9/8/9708:43'!recursionReset	"Reset the RecursionDepth counter in case the user interruptedduring a thumbnail being drawn.  Do this just once in a while when nodrawOn: is being called.  tk 9/8/97"	RecursionDepth _ 0.! !!Time class methodsFor: 'instance creation'!fromSeconds: secondCount 	"Answer an instance of me that is secondCount number of seconds since midnight."	| secondsInHour hours secs |	secs _ secondCount asInteger.	hours _ secs // 3600.	secondsInHour _ secs \\ 3600.	^self new hours: hours			   minutes: secondsInHour // 60			   seconds: secondsInHour \\ 60! !!Time class methodsFor: 'general inquiries' stamp: 'jm 12/4/97 19:59'!dateAndTimeFromSeconds: secondCount	^ Array		with: (Time fromSeconds: secondCount \\ 86400)		with: (Date fromDays: secondCount // 86400)! !!TinyPaint methodsFor: 'initialization' stamp: 'jm 11/4/97 07:15'!initialize	super initialize.	color _ Color veryVeryLightGray.	brushColor _ Color red.	brushSize _ 3.	self clear.! !!TinyPaint methodsFor: 'events' stamp: 'jm 11/4/97 07:15'!handlesMouseDown: evt	^ true! !!TinyPaint methodsFor: 'events' stamp: 'jm 11/4/97 07:15'!mouseDown: evt	lastMouse _ evt cursorPoint.! !!TinyPaint methodsFor: 'events' stamp: 'jm 11/4/97 07:15'!mouseMove: evt	| p |	p _ evt cursorPoint.	p = lastMouse ifTrue: [^ self].	brush drawFrom: lastMouse - bounds origin to: p - bounds origin.	self invalidRect: (		((lastMouse min: p) - brush sourceForm extent) corner:		((lastMouse max: p) + brush sourceForm extent)).	lastMouse _ p.! !!TinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'clear' action: #clear.	aCustomMenu add: 'pen color' action: #setPenColor:.	aCustomMenu add: 'pen size' action: #setPenSize.	aCustomMenu add: 'fill' action: #fill.! !!TinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!brushColor: aColor	brushColor _ aColor.	brush color: aColor.! !!TinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:16'!clear	self form: ((Form extent: 400@300 depth: 8) fillColor: color).	brush _ Pen newOnForm: originalForm.	brush roundNib: brushSize.	brush color: brushColor.! !!TinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:16'!fill	| fillPt |	Cursor blank show.	Cursor crossHair showWhile:		[fillPt _ Sensor waitButton - self world viewBox origin - self position].	originalForm shapeFill: brushColor interiorPoint: fillPt.	self changed.! !!TinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:16'!setPenColor: evt	evt hand changeColorTarget: self selector: #brushColor:.! !!TinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:16'!setPenSize	| menu sizes nibSize |	menu _ CustomMenu new.	sizes _ (0 to: 5), (6 to: 12 by: 2), (15 to: 40 by: 5).	sizes do: [:w | menu add: w printString action: w].	nibSize _ menu startUp.	nibSize ifNotNil: [		brushSize _ nibSize.		brush roundNib: nibSize].! !!TLabeledCommentNode methodsFor: 'all'!copyTree	^self class new		setLabel: label		comment: comment! !!TLabeledCommentNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C comment with optional label."	self printOptionalLabelOn: aStream.	aStream nextPutAll: '/* '.	aStream nextPutAll: comment.	aStream nextPutAll: ' */'.! !!TLabeledCommentNode methodsFor: 'all'!isComment	"Answer true if the receiver is just a comment (i.e., it has no label)."	^label = nil! !!TLabeledCommentNode methodsFor: 'all'!isLabel	^true! !!TLabeledCommentNode methodsFor: 'all'!isLeaf	^true! !!TLabeledCommentNode methodsFor: 'all'!label	^label! !!TLabeledCommentNode methodsFor: 'all'!printOn: aStream level: level	self printOptionalLabelOn: aStream.	aStream nextPut: $".	aStream nextPutAll: comment.	aStream nextPut: $".! !!TLabeledCommentNode methodsFor: 'all'!printOptionalLabelOn: aStream	label ~= nil ifTrue: [		self unindentOneTab: aStream.		aStream nextPutAll: label.		aStream nextPut: $:.		aStream tab.		].! !!TLabeledCommentNode methodsFor: 'all'!setComment: commentString	label _ nil.	comment _ commentString.! !!TLabeledCommentNode methodsFor: 'all'!setLabel: labelString	label _ labelString.! !!TLabeledCommentNode methodsFor: 'all'!setLabel: labelString comment: commentString	label _ labelString.	comment _ commentString.! !!TLabeledCommentNode methodsFor: 'all'!unindentOneTab: aStream	"Remove the last tab from the given stream if possible."	(aStream isKindOf: ReadWriteStream) ifFalse: [ ^self ].	aStream position > 0 ifTrue: [		aStream position: aStream position - 1.		"restore stream position if previous char was not a tab"		aStream peek = Character tab ifFalse: [ aStream next ].	].! !!TMethod methodsFor: 'initialization'!setSelector: sel args: argList locals: localList block: aBlockNode	"Initialize this method using the given information."	selector _ sel.	returnType _ 'int'. 	 "assume return type is int for now"	args _ argList asOrderedCollection collect: [ :arg | arg key ].	locals _ localList asOrderedCollection collect: [ :arg | arg key ].	declarations _ Dictionary new.	parseTree _ aBlockNode asTranslatorNode.	labels _ OrderedCollection new.	complete _ false.		"set to true when all possible inlining has been done"	self removeFinalSelfReturn.	self recordDeclarations.! !!TMethod methodsFor: 'initialization'!setSelector: sel returnType: retType args: argList locals: localList declarations: decls parseTree: aNode labels: labelList complete: completeFlag	"Initialize this method using the given information. Used for copying."	selector _ sel.	returnType _ retType.	args _ argList.	locals _ localList.	declarations _ decls.	parseTree _ aNode.	labels _ labelList.	complete _ completeFlag.! !!TMethod methodsFor: 'accessing'!args	"The arguments of this method."	^args! !!TMethod methodsFor: 'accessing'!declarations	"The type declaration dictionary of this method."	^declarations! !!TMethod methodsFor: 'accessing'!isComplete	"A method is 'complete' if it does not contain any more inline-able calls."	^complete! !!TMethod methodsFor: 'accessing'!labels	^labels! !!TMethod methodsFor: 'accessing'!locals	"The local variables of this method."	^locals! !!TMethod methodsFor: 'accessing'!parseTree	"The parse tree of this method."	^parseTree! !!TMethod methodsFor: 'accessing'!parseTree: aNode	"Set the parse tree of this method."	parseTree _ aNode.! !!TMethod methodsFor: 'accessing'!returnType	"The type of the values returned by this method. This string will be used in the C declaration of this function."	^returnType! !!TMethod methodsFor: 'accessing'!selector	"The Smalltalk selector of this method."	^selector! !!TMethod methodsFor: 'accessing'!selector: newSelector	selector _ newSelector.! !!TMethod methodsFor: 'accessing'!statements	parseTree isStmtList		ifFalse: [ self error: 'expected method parse tree to be a TStmtListNode' ].	((parseTree args = nil) or: [parseTree args isEmpty])		ifFalse: [ self error: 'expected method parse tree to have no args' ].	^parseTree statements! !!TMethod methodsFor: 'primitive compilation' stamp: 'ikp 1/4/98 00:02'!argConversionExprFor: varName stackIndex: stackIndex	"Return the parse tree for an expression that fetches and converts the primitive argument at the given stack offset."	| expr decl |	expr _ '(self stackValue: ( ', stackIndex printString, '))'.	(declarations includesKey: varName) ifTrue: [  "array"		decl _ declarations at: varName.		(decl includes: $*) ifTrue: [			expr _ varName, ' _ self arrayValueOf: ', expr.		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			expr _ varName, ' _ self floatValueOf: ', expr.		].	] ifFalse: [  "undeclared variables are taken to be integer"		expr _ varName, ' _ self checkedIntegerValueOf: ', expr.	].	^ self statementsFor: expr varName: varName! !!TMethod methodsFor: 'primitive compilation'!checkSuccessExpr	"Return the parse tree for an expression that aborts the primitive if the successFlag is not true."	| expr |	expr _ 'successFlag ifFalse: [^ nil ]'.	^ self statementsFor: expr varName: ''! !!TMethod methodsFor: 'primitive compilation'!covertToZeroBasedArrayReferences	"Replace the index expressions in at: and at:put: messages with (<expr> - 1), since C uses zero-based array indexing."	| oldIndexExpr newIndexExpr |	parseTree nodesDo: [ :n |		(n isSend and: [(n selector = #at:) or: [ n selector = #at:put: ]]) ifTrue: [			oldIndexExpr _ n args first.			oldIndexExpr isConstant ifTrue: [				"index expression is a constant: decrement the constant now"				newIndexExpr _ TConstantNode new setValue: (n args first value - 1).			] ifFalse: [				"index expression is complex: build an expression to decrement result at runtime"				newIndexExpr _ TSendNode new					setSelector: #-					receiver: oldIndexExpr					arguments: (Array with: (TConstantNode new setValue: 1)).			].			n args at: 1 put: newIndexExpr.		].	].! !!TMethod methodsFor: 'primitive compilation' stamp: 'ikp 1/4/98 00:01'!fetchRcvrExpr	"Return the parse tree for an expression that fetches the receiver from the stack."	| expr |	expr _ 'rcvr _ self stackValue: (', args size printString, ')'.	^ self statementsFor: expr varName: ''! !!TMethod methodsFor: 'primitive compilation'!instVarGetExprFor: varName offset: instIndex	"Return the parse tree for an expression that fetches and converts the value of the instance variable at the given offset."	| decl expr |	(declarations includesKey: varName) ifTrue: [		decl _ declarations at: varName.		(decl includes: $*) ifTrue: [  "array"			expr _ varName, ' _ self fetchArray: ', instIndex printString, ' ofObject: rcvr'.		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			expr _ varName, ' _ self fetchFloat: ', instIndex printString, ' ofObject: rcvr'.		].	] ifFalse: [  "undeclared variables are taken to be integer"		expr _ varName, ' _ self fetchInteger: ', instIndex printString, ' ofObject: rcvr'.	].	^ self statementsFor: expr varName: varName! !!TMethod methodsFor: 'primitive compilation'!instVarPutExprFor: varName offset: instIndex	"Return the parse tree for an expression that saves the value of the integer instance variable at the given offset."	| expr |	(declarations includesKey: varName) ifTrue: [		self error: 'a primitive method can only modify integer instance variables'.	].	expr _ 'self storeInteger: ', instIndex printString, ' ofObject: rcvr withValue: ', varName.	^ self statementsFor: expr varName: varName! !!TMethod methodsFor: 'primitive compilation'!popArgsExpr	"Return the parse tree for an expression that removes the primitive's arguments from the stack."	| expr |	expr _ 'self pop: ', args size printString.	^ self statementsFor: expr varName: ''! !!TMethod methodsFor: 'primitive compilation'!preparePrimitiveInClass: aClass	"Add a prolog and postlog to a primitive method. The prolog copies any instance variables referenced by this primitive method into local variables. The postlog copies values of assigned-to variables back into the instance. The names of the new locals are added to the local variables list.The declarations dictionary defines the types of any non-integer variables (locals, arguments, or instance variables). In particular, it may specify the types:	int *		-- an array of 32-bit values (e.g., a BitMap)	short *		-- an array of 16-bit values (e.g., a SoundBuffer)	char *		-- an array of unsigned bytes (e.g., a String)	double		-- a double precision floating point number (e.g., 3.14159)Undeclared variables are taken to be integers and will be converted from Smalltalk to C ints.""Current restrictions:	o method must not contain explicit returns	o method must not contain message sends	o method must not allocate objects	o method must not manipulate raw oops	o method cannot access class variables	o compiled primitives can only return self"	| prolog postlog instVarsUsed varsAssignedTo instVarList varName |	prolog _ OrderedCollection new.	postlog _ OrderedCollection new.	instVarsUsed _ self freeVariableReferences asSet.	varsAssignedTo _ self variablesAssignedTo asSet.	instVarList _ aClass allInstVarNames.	"add receiver fetch to prolog"	prolog addAll: self fetchRcvrExpr.	"add arg conversions to prolog"	1 to: args size do: [ :argIndex |		varName _ args at: argIndex.		prolog addAll:			(self argConversionExprFor: varName stackIndex: args size - argIndex).	].	"add instance variable fetches to prolog and instance variable stores to postlog"	1 to: instVarList size do: [ :varIndex |		varName _ instVarList at: varIndex.		(instVarsUsed includes: varName) ifTrue: [			locals add: varName.			prolog addAll: (self instVarGetExprFor: varName offset: varIndex - 1).			(varsAssignedTo includes: varName) ifTrue: [				postlog addAll: (self instVarPutExprFor: varName offset: varIndex - 1).			].		].	].	prolog addAll: self checkSuccessExpr.	postlog addAll: self popArgsExpr.	locals addAllFirst: args.	locals addFirst: 'rcvr'.	args _ args class new.	locals asSet size = locals size		ifFalse: [ self error: 'local name conflicts with instance variable name' ].	self hasReturn		ifTrue: [ self error: 'returns in primitive methods are not yet supported' ].	selector _ 'prim', aClass name, selector.	parseTree setStatements: prolog, parseTree statements, postlog.	self covertToZeroBasedArrayReferences.! !!TMethod methodsFor: 'primitive compilation'!statementsFor: sourceText varName: varName	"Return the parse tree for the given expression. The result is the statements list of the method parsed from the given source text."	"Details: Various variables are declared as locals to avoid Undeclared warnings from the parser."	| s |	s _ WriteStream on: ''.	s nextPutAll: 'temp'; cr; cr; tab.	s nextPutAll: '| rcvr stackPointer successFlag ', varName,' |'; cr.	s nextPutAll: sourceText.	^ ((Compiler new parse: s contents in: Object notifying: nil)			asTMethodFromClass: Object) statements! !!TMethod methodsFor: 'transformations'!bindClassVariablesIn: constantDictionary	"Class variables are used as constants. This method replaces all references to class variables in the body of this method with the corresponding constant looked up in the class pool dictionary of the source class. The source class class variables should be initialized before this method is called."	parseTree _ parseTree bindVariablesIn: constantDictionary.! !!TMethod methodsFor: 'transformations'!buildCaseStmt: aSendNode	"Build a case statement node for the given send of dispatchOn:in:."	"Note: the first argument is the variable to be dispatched on. The second argument is a constant node holding an array of unary selectors, which will be turned into sends to self."	((aSendNode args size = 2) and:	 [aSendNode args last isConstant and:	 [aSendNode args last value class = Array]]) ifFalse: [		self error: 'wrong node structure for a case statement'.	].	^TCaseStmtNode new		setExpression: aSendNode args first		selectors: aSendNode args last value! !!TMethod methodsFor: 'transformations'!prepareMethodIn: aCodeGen	"Record sends of builtin operators and replace sends of the special selector dispatchOn:in: with case statement nodes."	"Note: Only replaces top-level sends of dispatchOn:in:. Case statements must be top-level statements; they cannot appear in expressions."	| stmts stmt |	parseTree nodesDo: [ :node |		node isSend ifTrue: [			"record sends of builtin operators"			(aCodeGen builtin: node selector) ifTrue: [ node isBuiltinOperator: true ].		].		node isStmtList ifTrue: [			"replace dispatchOn:in: with case statement node"			stmts _ node statements.			1 to: stmts size do: [ :i |				stmt _ stmts at: i.				(stmt isSend and: [stmt selector = #dispatchOn:in:]) ifTrue: [					stmts at: i put: (self buildCaseStmt: stmt).				].			].		].	].! !!TMethod methodsFor: 'transformations'!recordDeclarations	"Record C type declarations of the forms		self returnTypeC: 'float'.		self var: #foo declareC: 'float foo'	 and remove the declarations from the method body."	| newStatements isDeclaration |	newStatements _ OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		isDeclaration _ false.		stmt isSend ifTrue: [			stmt selector = #var:declareC: ifTrue: [				isDeclaration _ true.				declarations at: stmt args first value asString put: stmt args last value.			].			stmt selector = #returnTypeC: ifTrue: [				isDeclaration _ true.				returnType _ stmt args last value.			].		].		isDeclaration ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.! !!TMethod methodsFor: 'transformations' stamp: 'ikp 9/26/97 14:50'!removeAssertions	parseTree removeAssertions! !!TMethod methodsFor: 'transformations'!removeFinalSelfReturn	"The Smalltalk parser automatically adds the statement '^self' to the end of methods without explicit returns. This method removes such statements, since the generated code has no notion of 'self' anyway."	| stmtList lastStmt |	stmtList _ parseTree statements asOrderedCollection.	lastStmt _ stmtList last.	((lastStmt isReturn) and:	 [(lastStmt expression isVariable) and:	 [lastStmt expression name = 'self']]) ifTrue: [		stmtList removeLast.		parseTree setStatements: stmtList.	].! !!TMethod methodsFor: 'utilities'!allCalls	"Answer a collection of selectors for the messages sent by this method."	^parseTree allCalls! !!TMethod methodsFor: 'utilities'!copy	"Make a deep copy of this TMethod."	^self class basicNew		setSelector: selector		returnType: returnType		args: args copy		locals: locals copy		declarations: declarations copy		parseTree: parseTree copyTree		labels: labels copy		complete: complete! !!TMethod methodsFor: 'utilities'!freeVariableReferences	"Answer a collection of variables referenced this method, excluding locals, arguments, and pseudovariables."	| refs |	refs _ Set new.	parseTree nodesDo: [ :node |		node isVariable ifTrue: [ refs add: node name asString ].	].	args do: [ :var | refs remove: var asString ifAbsent: [] ].	locals do: [ :var | refs remove: var asString ifAbsent: [] ].	#('self' 'nil' 'true' 'false') do: [ :var | refs remove: var ifAbsent: [] ].	^ refs asSortedCollection! !!TMethod methodsFor: 'utilities'!hasNoCCode	"Answer true if the receiver does not use inlined C or C declarations, which are not currently renamed properly by the the inliner."	declarations isEmpty ifFalse: [ ^ false ].	parseTree nodesDo: [ :node |		node isSend ifTrue: [			node selector = #cCode: ifTrue: [ ^ false ].		].	].	^ true! !!TMethod methodsFor: 'utilities'!nodeCount	"Answer the number of nodes in this method's parseTree (a rough measure of its size)."	| cnt |	cnt _ 0.	parseTree nodesDo: [ :n | cnt _ cnt + 1 ].	^cnt! !!TMethod methodsFor: 'utilities'!variablesAssignedTo	"Answer a collection of variables assigned to by this method."	| refs |	refs _ Set new.	parseTree nodesDo: [ :node |		node isAssignment ifTrue: [ refs add: node variable name ].	].	^ refs! !!TMethod methodsFor: 'inlining'!argAssignmentsFor: meth args: argList in: aCodeGen	"Return a collection of assignment nodes that assign the given argument expressions to the formal parameter variables of the given method."	"Optimization: If the actual parameters are either constants or local variables in the target method (the receiver), substitute them directly into the body of meth. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."	| stmtList substitutionDict |	stmtList _ OrderedCollection new: 16.	substitutionDict _ Dictionary new.	meth args with: argList do: [ :argName :exprNode |		(self isSubstitutableNode: exprNode intoMethod: meth in: aCodeGen) ifTrue: [			substitutionDict at: argName asSymbol put: exprNode.			locals remove: argName.		] ifFalse: [			stmtList add: (TAssignmentNode new				setVariable: (TVariableNode new setName: argName)				expression: exprNode copyTree).		].	].	meth parseTree: (meth parseTree bindVariablesIn: substitutionDict).	^stmtList! !!TMethod methodsFor: 'inlining'!checkForCompleteness: stmtLists in: aCodeGen	"Set the complete flag if none of the given statement list nodes contains further candidates for inlining."	complete _ true.	stmtLists do: [ :stmtList |		stmtList statements do: [ :node |			(self inlineableSend: node in: aCodeGen) ifTrue: [				complete _ false.  "more inlining to do"				^self			].		].	].	parseTree nodesDo: [ :n |		(self inlineableFunctionCall: n in: aCodeGen) ifTrue: [			complete _ false.  "more inlining to do"			^self		].	].! !!TMethod methodsFor: 'inlining'!exitVar: exitVar label: exitLabel	"Replace each return statement in this method with an assignment to the exit variable followed by a goto to the given label. Return true if a goto was generated."	"Optimization: If exitVar is nil, the return value of the inlined method is not being used, so don't add the assignment statement."	| newStmts labelUsed |	labelUsed _ false.	parseTree nodesDo: [ :node |		node isStmtList ifTrue: [			newStmts _ OrderedCollection new: 100.			node statements do: [ :stmt |				(stmt isReturn) ifTrue: [					exitVar = nil ifTrue: [						stmt expression isLeaf ifFalse: [							"evaluate return expression even though value isn't used"							newStmts add: stmt expression.						].					] ifFalse: [						"assign return expression to exit variable"						newStmts add:							(TAssignmentNode new								setVariable: (TVariableNode new setName: exitVar)								expression: stmt expression).					].					(stmt == parseTree statements last) ifFalse: [						"generate a goto (this return is NOT the last statement in the method)"						newStmts add: (TGoToNode new setLabel: exitLabel).						labelUsed _ true.					].				] ifFalse: [					newStmts addLast: stmt.				].			].			node setStatements: newStmts asArray.		].	].	^labelUsed! !!TMethod methodsFor: 'inlining'!inlineableFunctionCall: aNode in: aCodeGen	"Answer true if the given send node is a call to a 'functional' method--a method whose body is a single return statement of some expression and whose actual parameters can all be directly substituted."	| m |	aNode isSend ifFalse: [ ^false ].	m _ aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"	((m ~= nil) and: [m isFunctional and: [aCodeGen mayInline: m selector]]) ifTrue: [		aNode args do: [ :a | (self isSubstitutableNode: a intoMethod: m in: aCodeGen) ifFalse: [ ^false ]].		^true	] ifFalse: [		^false	].! !!TMethod methodsFor: 'inlining'!inlineableSend: aNode in: aCodeGen	"Answer true if the given send node is a call to a method that can be inlined."	| m |	aNode isSend ifFalse: [ ^false ].	m _ aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"	^(m ~= nil) and: [m isComplete and: [aCodeGen mayInline: m selector]]! !!TMethod methodsFor: 'inlining'!inlineCaseStatementBranchesIn: aCodeGen localizingVars: varsList	| stmt sel meth newStatements maxTemp usedVars exitLabel v |	maxTemp _ 0.	parseTree nodesDo: [ :n |		n isCaseStmt ifTrue: [			n cases do: [ :stmtNode |				stmt _ stmtNode statements first.				stmt isSend ifTrue: [					sel _ stmt selector.					meth _ aCodeGen methodNamed: sel.					((meth ~= nil) and:					 [meth hasNoCCode and:					 [meth args size = 0]]) ifTrue: [						meth _ meth copy.						maxTemp _ maxTemp max: (meth renameVarsForCaseStmt).						meth hasReturn ifTrue: [							exitLabel _ self unusedLabelForInliningInto: self.							meth exitVar: nil label: exitLabel.							labels add: exitLabel.						] ifFalse: [ exitLabel _ nil ].						meth renameLabelsForInliningInto: self.						meth labels do: [ :label | labels add: label ].						newStatements _ stmtNode statements asOrderedCollection.						newStatements removeFirst.						exitLabel ~= nil ifTrue: [							newStatements addFirst:								(TLabeledCommentNode new									setLabel: exitLabel comment: 'end case').						].						newStatements addAllFirst: meth statements.						newStatements addFirst:							(TLabeledCommentNode new setComment: meth selector).						stmtNode setStatements: newStatements.					].				].			].		].	].	usedVars _ (locals, args) asSet.	1 to: maxTemp do: [ :i |		v _ ('t', i printString).		(usedVars includes: v) ifTrue: [ self error: 'temp variable name conflicts with an existing local or arg' ].		locals addLast: v.	].	"make local versions of the given globals"	varsList do: [ :var |		(usedVars includes: var) ifFalse: [ locals addFirst: var asString ].	].! !!TMethod methodsFor: 'inlining'!inlineCodeOrNilForStatement: aNode in: aCodeGen	"If the given statement node can be inlined, answer the statements that replace it. Otherwise, answer nil."	| stmts |	aNode isReturn ifTrue: [		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [			stmts _ self inlineSend: aNode expression				directReturn: true exitVar: nil in: aCodeGen.			^stmts		].	].	aNode isAssignment ifTrue: [		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [			^self inlineSend: aNode expression				directReturn: false exitVar: aNode variable name in: aCodeGen		].	].	aNode isSend ifTrue: [		(self inlineableSend: aNode in: aCodeGen) ifTrue: [			^self inlineSend: aNode				directReturn: false exitVar: nil in: aCodeGen		].	].	^nil! !!TMethod methodsFor: 'inlining'!inlineFunctionCall: aSendNode in: aCodeGen	"Answer the body of the called function, substituting the actual parameters for the formal argument variables in the method body."	"Assume caller has established that:		1. the method arguments are all substitutable nodes, and		2. the method to be inlined contains no additional embedded returns."	| sel meth substitutionDict |	sel _ aSendNode selector.	meth _ (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	substitutionDict _ Dictionary new.	meth args with: aSendNode args do: [ :argName :exprNode |		substitutionDict at: argName asSymbol put: exprNode.		locals remove: argName.	].	meth parseTree bindVariablesIn: substitutionDict.	^meth statements first expression! !!TMethod methodsFor: 'inlining'!inlineSend: aSendNode directReturn: directReturn exitVar: exitVar in: aCodeGen	"Answer a collection of statments to replace the given send. directReturn indicates that the send is the expression of a return statement, so returns can be left in the body of the inlined method. If exitVar is nil, the value returned by the send is not used; thus, returns need not assign to the output variable."	| sel meth exitLabel labelUsed inlineStmts |	sel _ aSendNode selector.	meth _ (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	meth hasReturn ifTrue: [		directReturn ifTrue: [			"propagate the return type, if necessary"			returnType = meth returnType ifFalse: [ self halt ].  "caller's return type should be declared by user"			returnType _ meth returnType.		] ifFalse: [			exitLabel _ self unusedLabelForInliningInto: self.			labelUsed _ meth exitVar: exitVar label: exitLabel.			labelUsed				ifTrue: [ labels add: exitLabel ]				ifFalse: [ exitLabel _ nil ].		].		"propagate type info if necessary"		((exitVar ~= nil) and: [meth returnType ~= 'int']) ifTrue: [			declarations at: exitVar put: meth returnType, ' ', exitVar.		].	].	inlineStmts _ OrderedCollection new: 100.	inlineStmts add: (TLabeledCommentNode new setComment: 'begin ', sel).	inlineStmts addAll:		(self argAssignmentsFor: meth args: aSendNode args in: aCodeGen).	inlineStmts addAll: meth statements.  "method body"	(directReturn and: [meth endsWithReturn not]) ifTrue: [		inlineStmts add: (TReturnNode new setExpression: (TVariableNode new setName: 'nil')).	].	exitLabel ~= nil ifTrue: [		inlineStmts add:			(TLabeledCommentNode new				setLabel: exitLabel comment: 'end ', meth selector).	].	^inlineStmts! !!TMethod methodsFor: 'inlining'!isFunctional	"Answer true if the receiver is a functional method. That is, if it consists of a single return statement of an expression that contains no other returns."	(parseTree statements size = 1 and:	 [parseTree statements last isReturn]) ifFalse: [ ^false ].	parseTree statements last expression nodesDo: [ :n | n isReturn ifTrue: [ ^false ]].	^true! !!TMethod methodsFor: 'inlining'!isSubstitutableNode: aNode	"Answer true if the given parameter node is either a constant, a local variable, or a formal parameter of the receiver. Such parameter nodes may be substituted directly into the body of the method during inlining. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."	aNode isConstant ifTrue: [ ^true ].	^aNode isVariable and:		[(locals includes: aNode name) or:		[args includes: aNode name]]! !!TMethod methodsFor: 'inlining'!isSubstitutableNode: aNode intoMethod: targetMeth in: aCodeGen	"Answer true if the given parameter node is either a constant, a local variable, or a formal parameter of the receiver. Such parameter nodes may be substituted directly into the body of the method during inlining. Note that global variables cannot be subsituted into methods with possible side effects (i.e., methods that may assign to global variables) because the inlined method might depend on having the value of the global variable captured when it is passed in as an argument."	| var |	aNode isConstant ifTrue: [ ^ true ].	aNode isVariable ifTrue: [		var _ aNode name.		((locals includes: var) or: [args includes: var]) ifTrue: [ ^ true ].		(#(self true false nil) includes: var) ifTrue: [ ^ true ].		(targetMeth maySubstituteGlobal: var in: aCodeGen) ifTrue: [ ^ true ].	].	"scan expression tree; must contain only constants, builtin ops, and inlineable vars"	aNode nodesDo: [ :node |		node isSend ifTrue: [			node isBuiltinOperator ifFalse: [ ^false ].		].		node isVariable ifTrue: [			var _ node name.			((locals includes: var) or:			 [(args includes: var) or:			 [(#(self true false nil) includes: var) or:			 [targetMeth maySubstituteGlobal: var in: aCodeGen]]]) ifFalse: [ ^ false ].		].		(node isConstant or: [node isVariable or: [node isSend]]) ifFalse: [ ^false ].	].	^ true! !!TMethod methodsFor: 'inlining'!statementsListsForInlining	"Answer a collection of statement list nodes that are candidates for inlining. Currently, we cannot inline into the argument blocks of and: and or: messages."	| stmtLists |	stmtLists _ OrderedCollection new: 10.	parseTree nodesDo: [ :node | 		node isStmtList ifTrue: [ stmtLists add: node ].	].	parseTree nodesDo: [ :node | 		node isSend ifTrue: [			((node selector = #and:) or: [node selector = #or:]) ifTrue: [				"Note: the PP 2.3 compiler produces two arg nodes for these selectors"				stmtLists remove: node args first ifAbsent: [].				stmtLists remove: node args last ifAbsent: [].			].			((node selector = #ifTrue:) or: [node selector = #ifFalse:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			((node selector = #ifTrue:ifFalse:) or: [node selector = #ifFalse:ifTrue:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			((node selector = #whileFalse:) or: [node selector = #whileTrue:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			(node selector = #to:do) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: [].			].			(node selector = #to:do) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: [].				stmtLists remove: (node args at: 2) ifAbsent: [].			].		].		node isCaseStmt ifTrue: [			"don't inline cases"			node cases do: [: case | stmtLists remove: case ifAbsent: [] ].		].	].	^stmtLists! !!TMethod methodsFor: 'inlining'!tryToInlineMethodsIn: aCodeGen	"Expand any (complete) inline methods called by this method. Set the complete bit when all inlining has been done. Return true if something was inlined."	| stmtLists didSomething newStatements inlinedStmts sendsToInline |	didSomething _ false.	sendsToInline _ Dictionary new.	parseTree nodesDo: [ :n |		(self inlineableFunctionCall: n in: aCodeGen) ifTrue: [			sendsToInline at: n put: (self inlineFunctionCall: n in: aCodeGen).		].	].	sendsToInline isEmpty ifFalse: [		didSomething _ true.		parseTree _ parseTree replaceNodesIn: sendsToInline.	].	didSomething ifTrue: [		possibleSideEffectsCache _ nil.		^didSomething	].	stmtLists _ self statementsListsForInlining.	stmtLists do: [ :stmtList | 		newStatements _ OrderedCollection new: 100.		stmtList statements do: [ :stmt |			inlinedStmts _ self inlineCodeOrNilForStatement: stmt in: aCodeGen.			(inlinedStmts = nil) ifTrue: [				newStatements addLast: stmt.			] ifFalse: [				didSomething _ true.				newStatements addAllLast: inlinedStmts.			].		].		stmtList setStatements: newStatements asArray.	].	didSomething ifTrue: [		possibleSideEffectsCache _ nil.		^didSomething	].	complete ifFalse: [		self checkForCompleteness: stmtLists in: aCodeGen.		complete ifTrue: [ didSomething _ true ].  "marking a method complete is progress"	].	^didSomething! !!TMethod methodsFor: 'inlining'!unusedLabelForInliningInto: targetMethod	| usedLabels |	usedLabels _ labels asSet.	usedLabels addAll: targetMethod labels.	^self unusedNamePrefixedBy: 'l' avoiding: usedLabels! !!TMethod methodsFor: 'inlining support'!addVarsDeclarationsAndLabelsOf: methodToBeInlined	"Prepare to inline the body of the given method into the receiver by making the args and locals of the argument to the receiver be locals of the receiver. Record any type declarations for these variables. Record labels. Assumes that the variables have already be renamed to avoid name clashes."	methodToBeInlined args, methodToBeInlined locals do: [ :v |		(locals includes: v) ifFalse: [ locals addLast: v ].	].	methodToBeInlined declarations associationsDo: [ :assoc |		declarations add: assoc.	].	methodToBeInlined labels do: [ :label |		labels add: label.	].! !!TMethod methodsFor: 'inlining support'!computePossibleSideEffectsIn: aCodeGen	"Answer true if this method may have side effects. It has side effects if it assigns to a global variable. It may have side effects if it calls a non-built-in method."	parseTree nodesDo: [ :node |		node isSend ifTrue: [			node isBuiltinOperator ifFalse: [ ^true ].		].	].	^ false! !!TMethod methodsFor: 'inlining support'!endsWithReturn	"Answer true if the last statement of this method is a return."	^ parseTree statements last isReturn! !!TMethod methodsFor: 'inlining support'!extractInlineDirective	"Scan the top-level statements for an inlining directive of the form:		self inline: <boolean>	 and remove the directive from the method body. Return the argument of the directive or #dontCare if there is no inlining directive."	| result newStatements |	result _ #dontCare.	newStatements _ OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		(stmt isSend and: [stmt selector = #inline:]) ifTrue: [			result _ stmt args first name = 'true'.		] ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.	^ result! !!TMethod methodsFor: 'inlining support'!hasReturn	"Answer true if this method contains a return statement."	parseTree nodesDo: [ :n | n isReturn ifTrue: [ ^ true ]].	^ false! !!TMethod methodsFor: 'inlining support' stamp: 'ikp 9/26/97 14:50'!isAssertion	^(selector beginsWith: 'assert') or: [selector beginsWith: 'verify']! !!TMethod methodsFor: 'inlining support'!maySubstituteGlobal: globalVar in: aCodeGen	"Answer true if this method does or may have side effects on the given global variable."	possibleSideEffectsCache = nil ifTrue: [		"see if this calls any other method and record the result"		possibleSideEffectsCache _ self computePossibleSideEffectsIn: aCodeGen.	].	possibleSideEffectsCache ifTrue: [ ^ false ].	parseTree nodesDo: [ :node |		node isAssignment ifTrue: [			node variable name = globalVar ifTrue: [ ^ false ].		].	].	"if we get here, receiver calls no other method	 and does not itself assign to the given global variable"	^ true! !!TMethod methodsFor: 'inlining support'!renameLabelsForInliningInto: destMethod	"Rename any labels that would clash with those of the destination method."	| destLabels usedLabels labelMap newLabelName |	destLabels _ destMethod labels asSet.	usedLabels _ destLabels copy.  "usedLabels keeps track of labels in use"	usedLabels addAll: labels.	labelMap _ Dictionary new.	self labels do: [ :l |		(destLabels includes: l) ifTrue: [			newLabelName _ self unusedNamePrefixedBy: 'l' avoiding: usedLabels.			labelMap at: l put: newLabelName.		].	].	self renameLabelsUsing: labelMap.! !!TMethod methodsFor: 'inlining support'!renameLabelsUsing: aDictionary	"Rename all labels according to the old->new mappings of the given dictionary."	labels _ labels collect: [ :label |		(aDictionary includesKey: label) ifTrue: [ aDictionary at: label ] ifFalse: [ label ].	].	parseTree nodesDo: [ :node |		(node isGoTo and: [aDictionary includesKey: node label]) ifTrue: [			node setLabel: (aDictionary at: node label).		].		(node isLabel and: [aDictionary includesKey: node label]) ifTrue: [			node setLabel: (aDictionary at: node label).		].	].! !!TMethod methodsFor: 'inlining support'!renameVariablesUsing: aDictionary	"Rename all variables according to old->new mappings of the given dictionary."	| newDecls |	"map args and locals"	args _ args collect: [ :arg |		(aDictionary includesKey: arg) ifTrue: [ aDictionary at: arg ] ifFalse: [ arg ].	].	locals _ locals collect: [ :v |		(aDictionary includesKey: v) ifTrue: [ aDictionary at: v ] ifFalse: [ v ].	].	"map declarations"	newDecls _ declarations species new.	declarations associationsDo: [ :assoc |		(aDictionary includesKey: assoc key)			ifTrue: [ newDecls at: (aDictionary at: assoc key) put: assoc value ]			ifFalse: [ newDecls add: assoc ].	].	declarations _ newDecls.	"map variable names in parse tree"	parseTree nodesDo: [ :node |		(node isVariable and:		 [aDictionary includesKey: node name]) ifTrue: [			node setName: (aDictionary at: node name).		].		(node isStmtList and: [node args size > 0]) ifTrue: [			node setArguments:				(node args collect: [ :arg |					(aDictionary includesKey: arg)						ifTrue: [ aDictionary at: arg ]						ifFalse: [ arg ].				]).		].	].! !!TMethod methodsFor: 'inlining support'!renameVarsForCaseStmt	"Rename the arguments and locals of this method with names like t1, t2, t3, etc. Return the number of variable names assigned. This is done to allow registers to be shared among the cases."	| i varMap |	i _ 1.	varMap _ Dictionary new.	args, locals do: [ :v |		varMap at: v put: ('t', i printString) asSymbol.		i _ i + 1.	].	self renameVariablesUsing: varMap.	^ i - 1! !!TMethod methodsFor: 'inlining support'!renameVarsForInliningInto: destMethod in: aCodeGen	"Rename any variables that would clash with those of the destination method."	| destVars usedVars varMap newVarName |	destVars _ aCodeGen globalsAsSet copy.	destVars addAll: destMethod locals.	destVars addAll: destMethod args.	usedVars _ destVars copy.  "keeps track of names in use"	usedVars addAll: args; addAll: locals.	varMap _ Dictionary new.	args, locals do: [ :v |		(destVars includes: v) ifTrue: [			newVarName _ self unusedNamePrefixedBy: v avoiding: usedVars.			varMap at: v put: newVarName.		].	].	self renameVariablesUsing: varMap.! !!TMethod methodsFor: 'inlining support'!unusedNamePrefixedBy: aString avoiding: usedNames	"Choose a unique variable or label name with the given string as a prefix, avoiding the names in the given collection. The selected name is added to usedNames."	| n newVarName |	n _ 1.	newVarName _ aString, n printString.	[usedNames includes: newVarName] whileTrue: [		n _ n + 1.		newVarName _ aString, n printString.	].	usedNames add: newVarName.	^ newVarName! !!TMethod methodsFor: 'C code generation'!emitCCodeOn: aStream generator: aCodeGen	"Emit C code for this method onto the given stream. All calls to inlined methods should already have been expanded."	self emitCHeaderOn: aStream generator: aCodeGen.	parseTree emitCCodeOn: aStream level: 1 generator: aCodeGen.	aStream nextPutAll: '}'; cr.! !!TMethod methodsFor: 'C code generation'!emitCFunctionPrototype: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	| arg |	aStream nextPutAll: returnType; space.	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	args isEmpty ifTrue: [ aStream nextPutAll: 'void' ].	1 to: args size do: [ :i |		arg _ args at: i.		(declarations includesKey: arg) ifTrue: [			aStream nextPutAll: (declarations at: arg).		] ifFalse: [			aStream nextPutAll: 'int ', (args at: i).		].		i < args size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !!TMethod methodsFor: 'C code generation'!emitCHeaderOn: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	aStream cr.	self emitCFunctionPrototype: aStream generator: aCodeGen.	aStream nextPutAll: ' {'; cr.	locals do: [ :var |		aStream nextPutAll: '    '.		aStream nextPutAll: (declarations at: var ifAbsent: [ 'int ', var]), ';'; cr.	].	locals isEmpty ifFalse: [ aStream cr ].! !!TMethod methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'TMethod(', selector, ')'.! !!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 10/2/97 16:52'!buttonDownToToggleState	| targetState |	self doButtonAction.	targetState _ (target perform: stateSelector) ifTrue: [#on] ifFalse: [#off].	targetState = state ifFalse: [self toggleState]! !!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 9/19/97 15:11'!mouseDown: evt	self buttonDownToToggleState! !!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 9/19/97 15:06'!mouseMove: evt! !!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 9/19/97 15:02'!mouseUp: evt! !!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 9/19/97 19:43'!setInitialState	state _ (target perform: stateSelector) == true		ifTrue:			[#on]		ifFalse:			[#off]! !!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 9/19/97 15:23'!stateSelector: sym	stateSelector _ sym! !!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 10/2/97 17:03'!toggleState	self state: ((state == #off) ifTrue: [#on] ifFalse: [#off])! !!ToyboxMorph methodsFor: 'initialization' stamp: 'jm 8/3/97 13:33'!initialize	super initialize.	borderWidth _ 0.	color _ (Color r: 0.8 g: 1.0 b: 1.0).	locked _ false.	copyWhenLocked _ true.	clipping _ true.! !!ToyboxMorph methodsFor: 'initialization' stamp: 'sw 8/12/97 14:16'!isPartsBin	^ true! !!ToyboxMorph methodsFor: 'events' stamp: 'jm 8/3/97 13:48'!handlesMouseDown: evt	"Grab mouse events either to drag an object out (if not locked) or to drag out a copy (if locked and copyWhenLocked)."	(locked not or: [copyWhenLocked])		ifTrue: [			submorphs do: [:m |				(m fullContainsPoint: evt cursorPoint) ifTrue: [^ true]]].	^ false! !!ToyboxMorph methodsFor: 'events' stamp: 'jm 8/3/97 13:49'!mouseDown: evt	"Grab or copy the front-mouse submorph at the point where the mouse went down."	| morphToGrab |	submorphs do: [:m |		(m fullContainsPoint: evt cursorPoint) ifTrue: [			(locked and: [copyWhenLocked])				ifTrue: [morphToGrab _ m fullCopy]				ifFalse: [morphToGrab _ m].			evt hand grabMorph: morphToGrab.			^ self]].	evt hand grabMorph: self.! !!ToyboxMorph methodsFor: 'events' stamp: 'jm 8/3/97 12:08'!preemptsMouseDown: evt	"Handle mouse events even when the mouse is pressed over a mouse-sensitive object such a button."	^ self handlesMouseDown: evt! !!ToyboxMorph methodsFor: 'dropping' stamp: 'jm 8/3/97 11:36'!wantsDroppedMorph: aMorph event: evt	"Allows adding morphs by dropping."	^ locked not! !!ToyboxMorph methodsFor: 'clipping' stamp: 'jm 8/3/97 13:34'!fullBounds	"Overridden to clip submorph hit detection to my bounds if clipping is true."	clipping ifFalse: [^ super fullBounds].	^ bounds! !!ToyboxMorph methodsFor: 'clipping' stamp: 'jm 8/3/97 13:34'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds if clipping is true."	| clippingCanvas |	clipping ifFalse: [^ super fullDrawOn: aCanvas].	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self drawOn: aCanvas.	clippingCanvas _ aCanvas copyClipRect: bounds.	submorphs isEmpty ifFalse: [		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]].  "draw back-to-front"! !!ToyboxMorph methodsFor: 'menu' stamp: 'jm 8/3/97 11:35'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu		add: (locked ifTrue: ['unlock me'] ifFalse: ['lock me'])		action: #toggleLocked.	aCustomMenu		add: (copyWhenLocked				ifTrue: ['don''t drag out copies when locked']				ifFalse: ['drag out copies when locked'])		action: #toggleCopyWhenLocked.! !!ToyboxMorph methodsFor: 'menu' stamp: 'jm 8/3/97 11:32'!toggleCopyWhenLocked	"Toggle this morph's ability to make copies of its contents when it is locked."	copyWhenLocked _ copyWhenLocked not.! !!ToyboxMorph methodsFor: 'menu' stamp: 'jm 8/3/97 13:49'!toggleLocked	"Toggle the ability to edit the contents of this morph via drag-n-drop."	locked _ locked not.! !!TParseNode methodsFor: 'all'!allCalls	"Answer a collection of selectors for the messages sent in this parse tree."	| calls |	calls _ Set new: 100.	self nodesDo: [ :node |		node isSend ifTrue: [ calls add: node selector ].	].	^calls! !!TParseNode methodsFor: 'all'!bindVariablesIn: aDictionary	^self! !!TParseNode methodsFor: 'all'!hasExplicitReturn	self nodesDo: [ :node |		node isReturn ifTrue: [ ^true ].	].	^false! !!TParseNode methodsFor: 'all'!inlineMethodsUsing: aDictionary	self! !!TParseNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!isAssertion	^false! !!TParseNode methodsFor: 'all'!isAssignment	^false! !!TParseNode methodsFor: 'all'!isCaseStmt	^false! !!TParseNode methodsFor: 'all'!isComment	^false! !!TParseNode methodsFor: 'all'!isConstant	^false! !!TParseNode methodsFor: 'all'!isGoTo	^false! !!TParseNode methodsFor: 'all'!isLabel	^false! !!TParseNode methodsFor: 'all'!isLeaf	"Answer true if the receiver is a variable or a constant node."	^false! !!TParseNode methodsFor: 'all'!isReturn	^false! !!TParseNode methodsFor: 'all'!isSend	^false! !!TParseNode methodsFor: 'all'!isStmtList	^false! !!TParseNode methodsFor: 'all'!isVariable	^false! !!TParseNode methodsFor: 'all'!nodeCount	"Answer the number of nodes in this parseTree (a rough measure of its size)."	| cnt |	cnt _ 0.	self nodesDo: [ :n | cnt _ cnt + 1 ].	^cnt! !!TParseNode methodsFor: 'all'!nodesDo: aBlock	aBlock value: self.! !!TParseNode methodsFor: 'all'!printOn: aStream 	"Append a description of the receiver onto the given stream."	self printOn: aStream level: 0.! !!TParseNode methodsFor: 'all'!printOn: aStream level: anInteger 	"Typically overridden. If control actually gets here, avoid recursion loop by sending to super."	super printOn: aStream.! !!TParseNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!removeAssertions	"default: do nothing"! !!TParseNode methodsFor: 'all'!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [self]! !TransformMorph class comment:'A WindowMorph introduces a 2-D transformation between its (global) coordinates and the (local) coordinates of its submoprhs, while also clipping all display to its bounds.  Specifically, with no offset, angle or scaling, a submorph with coordinates (0@0) will appear exactly at the topLeft of the windowMorph (its position).  Rotation and scaling are relative to the local origin, (0@0).WindowMorphs operate with two different display strategies, depending on whether the transformation is a pure translation or not.  If so, then they simply use a clipping canvas and display their submorphs with the appropriate offset.  If the transformation includes scaling or rotation, then a caching canvas is used, whose active area covers the fullBounds of the submorphs intersected with the source quadrilateral corresponding to the window bounds.'!!TransformMorph methodsFor: 'initialization'!initialize	super initialize.	color _ Color lightGreen.	smoothing _ 1.	transform _ MorphicTransform identity.! !!TransformMorph methodsFor: 'accessing'!angle	^ transform angle! !!TransformMorph methodsFor: 'accessing'!angle: newAngle	transform _ transform withAngle: newAngle.	self changed! !!TransformMorph methodsFor: 'accessing'!offset	^ transform offset + self innerBounds topLeft! !!TransformMorph methodsFor: 'accessing'!offset: newOffset	transform _ transform withOffset: newOffset - self innerBounds topLeft.	self changed! !!TransformMorph methodsFor: 'accessing'!scale	^ transform scale! !!TransformMorph methodsFor: 'accessing'!scale: newScale	transform _ transform withScale: newScale.	self changed! !!TransformMorph methodsFor: 'accessing'!setOffset: newOffset angle: newAngle scale: newScale	transform _ MorphicTransform offset: newOffset angle: newAngle scale: newScale.	self changed! !!TransformMorph methodsFor: 'accessing'!smoothing: cellSize	smoothing _ cellSize.	self changed! !!TransformMorph methodsFor: 'accessing'!smoothingOff	smoothing _ 1.	self changed! !!TransformMorph methodsFor: 'accessing'!smoothingOn	smoothing _ 2.	self changed! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'sw 8/22/97 23:48'!morphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	(self containsPoint: aPoint) ifFalse:		["TransformMorph clips to bounds"		^ mList].	p _ transform transform: aPoint.	submorphs do: [:m | m morphsAt: p addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'sw 8/22/97 23:46'!unlockedMorphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	self isLocked ifTrue: [^ mList].	(self containsPoint: aPoint) ifFalse:		["TransformMorph clips to bounds"		^ mList].	p _ transform transform: aPoint.	submorphs do: [:m | m unlockedMorphsAt: p addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'drawing'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds,	and to translate, rotate and scale as appropriate."	| clippingCanvas sourceQuad imageForm imageQuad warp innerRect |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self drawOn: aCanvas.	transform isPureTranslation		ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated									clipRect: self innerBounds.		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]]		ifFalse:		[innerRect _ self innerBounds.		sourceQuad _ transform sourceQuadFor: innerRect.		submorphs reverseDo:			[:m | imageForm _ m imageForm.			imageQuad _ sourceQuad collect: [:p | p - imageForm offset].			warp _ aCanvas warpFrom: imageQuad toRect: innerRect.			warp cellSize: smoothing;  "installs a colormap if smoothing > 1"				sourceForm: imageForm;				warpBits]]	! !!TransformMorph methodsFor: 'geometry'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	^ bounds! !!TransformMorph methodsFor: 'geometry' stamp: 'jm 7/5/97 13:20'!privateFullMoveBy: delta	"Private!! Relocate me, but not my subMorphs."	self privateMoveBy: delta.	self offset: self offset - delta.! !!TransformMorph methodsFor: 'geometry'!submorphBounds	| subBounds |	subBounds _ nil.	self submorphsDo:		[:m |		subBounds ifNil: [subBounds _ m fullBounds]				ifNotNil: [subBounds _ subBounds quickMerge: m fullBounds]].	^ subBounds! !!TransformMorph methodsFor: 'change reporting'!changed	"Needs to be overridden to call superclass's invalidRect:."	super invalidRect: self fullBounds.! !!TransformMorph methodsFor: 'change reporting'!invalidRect: damageRect	"Translate damage reports from submorphs by the scrollOffset."	| affectedRect |	owner ifNil: [^ self].	transform isPureTranslation ifTrue:		[^ owner invalidRect: (transform invertRect: damageRect)].	affectedRect _ (transform invert: damageRect topLeft) extent: 0@0.	affectedRect _ affectedRect encompass: (transform invert: damageRect topRight).	affectedRect _ affectedRect encompass: (transform invert: damageRect bottomLeft).	affectedRect _ affectedRect encompass: (transform invert: damageRect bottomRight).	owner invalidRect: (affectedRect expandBy: 1)! !!TransformMorph methodsFor: 'events'!transformFrom: uberMorph	"Return a transform to map coorinates of uberMorph, a morph above me in my owner chain, into the coordinates of my submorphs."	owner == uberMorph ifTrue: [^ transform].	owner ifNil: [^ transform].	^ (owner transformFrom: uberMorph) composedWith: transform! !!TransformMorph methodsFor: 'menu' stamp: 'di 11/4/97 09:04'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	smoothing = 1		ifTrue: [aCustomMenu add: 'turn on smoothing' action: #smoothingOn]		ifFalse: [aCustomMenu add: 'turn off smoothing' action: #smoothingOff]! !!TranslatedMethod class methodsFor: 'class initialization' stamp: 'ikp 1/10/98 02:34'!initialize	self becomeCompact.	Smalltalk recreateSpecialObjectsArray.	Smalltalk specialObjectsArray size = 41		ifFalse: [self error: 'Please check size of special objects array!!']! !TranslucentColor comment:'A TranslucentColor behaves just like a normal color, except that it will pack its alpha value into the high byte of a 32-bit pixelValue.  This allows creating forms with translucency for use with the alpha blend function of BitBlt.  An alpha of zero is transparent, and 1.0 is opaque.'!!TranslucentColor methodsFor: 'accessing'!alpha	"Return my alpha value, a number between 0.0 and 1.0 where 0.0 is completely transparent and 1.0 is completely opaque."	^ alpha asFloat / 255.0! !!TranslucentColor methodsFor: 'equality'!hash	^ rgb bitXor: alpha! !!TranslucentColor methodsFor: 'printing'!storeOn: aStream	super storeOn: aStream.	aStream		skip: -1;	  "get rid of trailing )"		nextPutAll: ' alpha: ';		nextPutAll: alpha printString;		nextPutAll: ')'.! !!TranslucentColor methodsFor: 'conversions'!pixelWordForDepth: depth	"Return the pixel value for this color at the given depth. Translucency only works at a bit-depth of 32; this color will appear opaque at all other depths."	| basicPixelWord |	basicPixelWord _ super pixelWordForDepth: depth.	depth < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ basicPixelWord bitOr: (alpha bitShift: 24)].! !!TranslucentColor methodsFor: 'private'!privateAlpha	"Return my raw alpha value, an integer in the range 0..255. Used for fast equality testing."	^ alpha! !!TranslucentColor methodsFor: 'private'!setRgb: rgbValue alpha: alphaValue	"Set the state of this translucent color. Alpha is represented internally by an integer in the range 0..255."	rgb == nil ifFalse: [self attemptToMutateError].	rgb _ rgbValue.	alpha _ (255.0 * alphaValue) asInteger min: 255 max: 0.! !TransparentColor class comment:'An instance of me is the transparent color.  My pixel value is 0 in any depth.  A NullColor is also used when no fill color is desired, as with the background of transparent text.  It will produce all zeroes in any color map entry initialized from it.  In combination with BitBlt paint mode (which does not store zeroes), this will result in transparency.  Note that when this approach is being used in RGB, true black will look the same as a null color, unless you put something in the alpha bits, or use an off-color black.Transparent _ NullColor r: 0 g: 0 b: 0.Color transparent'!!TransparentColor methodsFor: 'equality' stamp: 'di 10/1/97 20:13'!= aColor	^ aColor isColor and: [aColor isTransparent]! !!TransparentColor methodsFor: 'equality'!hash	^ 0! !!TransparentColor methodsFor: 'queries'!isTransparent	^ true! !!TransparentColor methodsFor: 'transformations'!* aFactor	^ self! !!TransparentColor methodsFor: 'transformations'!+ aColor	^ aColor! !!TransparentColor methodsFor: 'transformations'!- aColor	^ self! !!TransparentColor methodsFor: 'transformations'!/ aFactor	^ self! !!TransparentColor methodsFor: 'transformations' stamp: 'jm 12/4/97 10:45'!contrastingRed	^ Color red! !!TransparentColor methodsFor: 'transformations'!darker	^ self! !!TransparentColor methodsFor: 'transformations'!lighter	^ self! !!TransparentColor methodsFor: 'transformations'!mixed: proportion with: aColor	^ aColor alpha: (1.0 - proportion)! !!TransparentColor methodsFor: 'printing'!shortPrintString	^ 'Transparent'! !!TransparentColor methodsFor: 'printing'!storeOn: aStream	aStream nextPutAll: '(Color transparent)'.! !!TransparentColor methodsFor: 'conversions'!bitPatternForDepth: depth	^ Bitmap with: 0! !!TransparentColor methodsFor: 'conversions'!pixelValueForDepth: d	^ 0! !!TransparentColor methodsFor: 'conversions'!pixelWordForDepth: depth	^ 0! !!TransparentColor methodsFor: 'private'!setRed: r green: g blue: b	"Ignored."! !!TrashCanMorph methodsFor: 'all' stamp: 'sw 10/18/97 18:03'!aboutToTrashColor	^ Color red! !!TrashCanMorph methodsFor: 'all' stamp: 'di 1/13/98 21:56'!acceptDroppingMorph: aMorph event: evt	self world soundsEnabled  ifTrue: [self playDeleteSound].	evt hand endDisplaySuppression.	self color: self normalColor.	aMorph delete.! !!TrashCanMorph methodsFor: 'all' stamp: 'sw 8/16/97 02:00'!addLabel	| m |	self isThisEverCalled.	self removeAllMorphs.	m _ StringMorph new contents: 'Trash'.	self extent: (m width + 6) @ (m height + 10).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!TrashCanMorph methodsFor: 'all' stamp: 'jhm 10/13/97 12:08'!handlesMouseOver: evt	^ true! !!TrashCanMorph methodsFor: 'all' stamp: 'tk 10/11/97 18:22'!hideCursor: evt	"Set the cursor back."	evt hand showTemporaryCursor: nil		hotSpotOffset: 0@0.	"back to normal"! !!TrashCanMorph methodsFor: 'all' stamp: 'sw 10/18/97 18:03'!initialize	super initialize.	color _ self normalColor.	self addLabel: 'Trash'.	submorphs first lock. "So the string won't get the halo on its own"	self setBalloonText:'The Trash CanTo remove an object, drag itover the Trash, and drop it,and it will disappear.'.	self on: #mouseUp send: #openTrash to: self.	self on: #mouseEnter send: #showCursor: to: self.	self on: #mouseLeave send: #hideCursor: to: self.! !!TrashCanMorph methodsFor: 'all' stamp: 'sw 11/16/97 21:40'!mouseEnter: evt	((evt hand submorphCount > 0) and: [evt hand submorphs first ~~ self])		ifTrue:		[self world soundsEnabled  ifTrue: [self playMouseEnterSound].			evt hand startDisplaySuppression.			self world abandonAllHalos.			self color: self aboutToTrashColor].	super mouseEnter: evt.! !!TrashCanMorph methodsFor: 'all' stamp: 'sw 11/16/97 21:41'!mouseLeave: evt	((evt hand submorphCount > 0) and: [evt hand submorphs first ~~ self]) 		ifTrue:			[self world soundsEnabled  ifTrue: [self playMouseLeaveSound].			evt hand endDisplaySuppression.			self color: self normalColor].	super mouseLeave: evt.	! !!TrashCanMorph methodsFor: 'all' stamp: 'sw 10/18/97 18:03'!normalColor	^ Color r: 0.4 g: 0.4 b: 1.0! !!TrashCanMorph methodsFor: 'all' stamp: 'di 1/13/98 21:57'!openTrash	"User wants to see what is in the trash.""Dummied"! !!TrashCanMorph methodsFor: 'all' stamp: 'jhm 10/14/97 03:17'!playDeleteSound	"TrashCanMorph new playDeleteSound"	| snd |	snd _ SampledSound		samples: #(0 11 5 18 42 35 28 54 42 59 52 44 16 18 33 6 -39 -30 -39 -37 -61 -61 -55 -83 -71 -42 -66 -45 -61 -40 -22 1 -3 33 61 69 44 59 59 64 44 81 62 79 91 62 45 55 1 -8 -10 -1 -16 -33 -20 -57 -54 -18 10 5 -1 -6 25 62 47 49 79 52 20 50 76 94 74 91 100 94 69 67 76 76 44 71 62 64 91 93 96 113 93 125 120 108 76 67 79 54 79 69 64 83 37 39 35 6 -13 -57 -62 -52 -79 -94 -100 -78 -105 -101 -59 -69 -64 -25 -55 -33 -57 -33 -39 -33 -16 -16 -16 -30 -25 -1 -27 -32 -39 -44 -1 -18 -23 -61 -55 -45 -67 -74 -47 -23 -22 -55 -50 -18 -47 -39 -22 -32 -28 -45 -28 -50 -69 -83 -83 -66 -93 -84 -74 -74 -84 -76 -94 -52 -69 -62 -35 -3 11 -16 28 5 -10 0 3 25 -1 20 32 25 44 59 18 11 -32 0 -11 -28 -55 -67 -62 -64 -57 -49 -76 -239 -980 -1731 -1565 -478 1153 2646 2919 1799 -1385 -5482 -8325 -8427 -4347 2556 9606 13864 12797 7894 731 -6395 -9218 -6222 1491 9207 12724 10783 3258 -6050 -12631 -14020 -9175 -454 8771 14419 13457 7050 -1679 -8875 -11346 -7670 960 10478 16383 15908 10112 2191 -5150 -8398 -6123 644 8334 12364 11062 5163 -2966 -9760 -12327 -9012 -1947 4977 8880 8495 4412 -1704 -6697 -7935 -5491 -186 5557 9289 9235 4955 -819 -4990 -5843 -3005 2128 7204 9606 7728 2439 -3872 -8469 -9930 -7226 -1385 4532 7567 6452 2154 -3136 -7248 -8045 -4493 1794 7582 10089 8636 3994 -1994 -6473 -7257 -3774 1894 6760 9011 7177 1979 -4364 -8760 -9067 -5465 332 5596 7764 5742 284 -5345 -8517 -7840 -3480 2838 8592 10639 7918 2485 -3435 -7177 -7341 -3630 2542 7333 8449 5514 15 -5645 -9192 -8368 -3540 3111 8083 9218 6558 941 -5119 -8500 -7748 -2905 3329 8259 9891 6975 1192 -4921 -8285 -7411 -3123 3090 7961 9206 5967 -130 -5728 -8793 -7886 -3061 3637 8965 9864 6471 683 -5121 -8324 -7547 -2720 3679 8050 8714 5236 -373 -6032 -9138 -7679 -2653 3679 8166 8982 5906 -111 -5825 -8561 -7094 -2091 3874 8412 9128 5533 -361 -5918 -8320 -6939 -2222 4016 8376 8831 4987 -943 -6130 -8678 -7102 -2117 4149 8322 8296 4768 -744 -5827 -8144 -6444 -1172 4732 8463 8412 4659 -1111 -6519 -8782 -6838 -1876 3818 7423 7601 3966 -1852 -6722 -8505 -6354 -1297 4366 8266 8217 4386 -1206 -5891 -7589 -5647 -595 5092 8402 7645 3372 -2274 -7031 -8958 -6814 -1560 4329 7654 7123 3477 -1869 -6393 -7899 -5367 88 5572 8632 8001 3994 -1711 -6441 -7793 -5287 -393 4497 7216 6430 2176 -3494 -7572 -8412 -5660 -476 4873 7782 6690 2393 -2805 -6588 -7323 -4649 614 5879 8327 6904 2609 -2773 -6848 -7927 -5150 117 5087 7272 5923 1730 -3616 -7575 -8117 -4951 332 5082 7314 6100 1716 -3587 -7162 -7338 -4064 1063 5860 7922 6178 1477 -3845 -7267 -7575 -4571 537 5260 7199 5292 826 -4115 -7486 -7689 -4446 938 5637 7201 5421 1063 -3815 -7109 -7141 -3667 1448 5660 6990 4983 519 -4622 -7833 -7543 -3996 1080 5323 6922 5028 385 -4480 -7416 -7070 -3789 1145 5533 6878 4693 40 -4734 -7506 -7268 -3827 1353 5650 6756 4347 -161 -4821 -7581 -7051 -3301 1993 5847 6707 4347 -198 -4888 -7582 -6814 -2926 2076 5860 6719 4339 -313 -5104 -7557 -6685 -2960 1915 5679 6573 3945 -814 -5333 -7572 -6588 -2787 2269 6052 6597 3789 -877 -5189 -7406 -6525 -2636 2447 5996 6307 3497 -1070 -5450 -7609 -6463 -2340 2658 5945 6230 3482 -1158 -5519 -7458 -5949 -1767 3039 6341 6612 3603 -1267 -5625 -7343 -5857 -1774 3033 6279 6346 3156 -1653 -5721 -7357 -5877 -1742 3158 6256 6039 2848 -1752 -5721 -7285 -5643 -1223 3635 6464 6159 2960 -1731 -5771 -7229 -5280 -936 3662 6266 5823 2488 -2386 -6329 -7457 -5362 -1044 3521 6339 5962 2564 -2183 -5850 -6875 -4841 -536 4120 6763 6062 2488 -2111 -5681 -6838 -4873 -605 3845 6190 5268 1777 -2759 -6413 -7419 -5162 -680 3692 5964 5234 1888 -2556 -5979 -6624 -4157 242 4497 6702 5860 2200 -2597 -6054 -6732 -4381 -111 4183 6330 5153 1346 -3170 -6430 -7031 -4688 -198 4213 6335 5180 1519 -2753 -5777 -6198 -3531 958 5024 6619 5234 1523 -3048 -6295 -6753 -4157 137 3986 5665 4412 788 -3545 -6449 -6469 -3735 539 4539 6246 4921 1172 -3100 -5918 -6010 -3352 905 4800 6313 4702 865 -3363 -6118 -6254 -3609 753 4529 5842 4178 466 -3628 -6305 -6174 -3231 1195 4854 6112 4497 715 -3550 -6183 -5972 -3043 1265 4843 6030 4203 264 -3915 -6352 -5945 -2961 1328 4907 6001 4025 50 -3949 -6240 -5808 -2731 1620 5085 5932 3872 5 -3961 -6174 -5640 -2408 1971 5204 5806 3587 -347 -4320 -6493 -5674 -2252 2103 5245 5818 3709 -300 -4249 -6215 -5309 -2066 2078 5077 5591 3262 -809 -4558 -6335 -5384 -2111 2062 5097 5460 3022 -951 -4570 -6283 -5192 -1733 2491 5348 5475 3024 -912 -4546 -6217 -5077 -1557 2597 5245 5301 2785 -1263 -4934 -6522 -5226 -1716 2385 5104 5206 2680 -1328 -4860 -6276 -4933 -1472 2549 5211 5238 2602 -1389 -4778 -6118 -4834 -1379 2664 5109 4880 2156 -1731 -5007 -6259 -4754 -1121 2883 5297 4973 2318 -1620 -4939 -6086 -4395 -697 3187 5426 5082 2242 -1738 -5026 -6037 -4332 -754 3012 5156 4665 1777 -2237 -5294 -6125 -4310 -676 3177 5313 4707 1704 -2171 -5167 -5962 -4134 -434 3307 5221 4456 1421 -2371 -5287 -5974 -3954 -188 3542 5297 4424 1389 -2456 -5362 -5854 -3667 161 3709 5435 4476 1255 -2671 -5472 -5828 -3589 215 3804 5409 4402 1138 -2724 -5324 -5599 -3384 378 3901 5396 4091 868 -2871 -5385 -5572 -3270 525 3884 5155 3828 575 -3119 -5518 -5503 -2994 826 4095 5277 3886 615 -3100 -5348 -5202 -2603 1202 4405 5579 4064 602 -3109 -5419 -5272 -2790 899 4067 5100 3521 122 -3477 -5592 -5270 -2585 1314 4537 5531 3905 485 -3089 -5226 -4956 -2347 1443 4476 5236 3463 11 -3604 -5711 -5257 -2473 1341 4363 5141 3385 -28 -3584 -5504 -4973 -2164 1586 4456 5218 3413 -64 -3496 -5321 -4707 -1969 1721 4571 5109 3195 -329 -3723 -5474 -4821 -1969 1776 4503 4921 2919 -522 -3845 -5506 -4654 -1676 2057 4687 5036 3068 -415 -3721 -5323 -4408 -1430 2169 4614 4882 2788 -695 -3915 -5313 -4337 -1396 2132 4519 4702 2544 -905 -3866 -5124 -3993 -988 2586 4865 4841 2573 -877 -3859 -5050 -3949 -902 2556 4668 4510 2223 -1141 -4108 -5170 -3808 -703 2720 4719 4553 2271 -1131 -3972 -4907 -3489 -390 2919 4890 4537 2088 -1385 -4154 -4934 -3447 -337 2949 4792 4325 1743 -1562 -4181 -4856 -3273 -33 3316 5041 4439 1923 -1424 -3959 -4570 -2910 317 3423 4907 4088 1355 -2054 -4624 -5056 -3187 140 3307 4809 4030 1323 -2069 -4432 -4695 -2724 597 3694 5114 4179 1360 -1966 -4229 -4478 -2602 675 3715 5019 3932 1027 -2281 -4537 -4753 -2714 656 3687 4919 3859 1085 -2127 -4312 -4403 -2332 965 3786 4910 3750 882 -2391 -4437 -4402 -2254 933 3703 4646 3397 396 -2761 -4724 -4539 -2305 980 3754 4756 3469 590 -2468 -4317 -4120 -1871 1389 4050 4788 3321 318 -2715 -4503 -4201 -1837 1438 4025 4685 3201 220 -2892 -4629 -4167 -1665 1653 4171 4763 3180 93 -2975 -4602 -4015 -1499 1777 4212 4668 2927 -195 -3214 -4712 -4027 -1443 1877 4278 4609 2759 -451 -3440 -4853 -4093 -1385 1983 4334 4570 2726 -405 -3326 -4680 -3794 -1068 2210 4410 4547 2595 -554 -3460 -4715 -3725 -987 2203 4300 4352 2317 -875 -3669 -4760 -3687 -941 2237 4312 4330 2291 -778 -3453 -4486 -3475 -775 2271 4218 4105 1969 -1070 -3682 -4656 -3518 -661 2424 4262 4018 1854 -1197 -3718 -4505 -3141 -252 2809 4564 4264 2067 -1039 -3611 -4369 -3028 -201 2761 4427 4040 1772 -1318 -3740 -4352 -2907 -52 2939 4553 4008 1657 -1414 -3784 -4364 -2858 71 3089 4629 4098 1794 -1219 -3535 -4025 -2500 373 3224 4571 3896 1487 -1553 -3828 -4269 -2661 281 3126 4547 3891 1552 -1413 -3640 -3989 -2363 529 3341 4719 4010 1545 -1452 -3640 -3988 -2305 653 3467 4729 3866 1292 -1740 -3849 -4091 -2325 671 3436 4602 3716 1219 -1733 -3760 -3867 -1994 1031 3708 4758 3730 1100 -1925 -3891 -3898 -1938 1044 3640 4625 3557 921 -2020 -3859 -3776 -1813 1116 3687 4617 3465 815 -2079 -3828 -3713 -1708 1263 3759 4544 3307 641 -2169 -3855 -3674 -1608 1362 3750 4410 3090 425 -2383 -4022 -3725 -1533 1491 3835 4488 3167 390 -2378 -3928 -3509 -1257 1728 4013 4573 3123 286 -2473 -3894 -3404 -1080 1884 4078 4466 2853 -5 -2678 -4035 -3440 -1097 1857 3996 4295 2678 -137 -2821 -4118 -3421 -983 1959 4054 4283 2648 -196 -2873 -4054 -3273 -751 2161 4159 4334 2556 -320 -2965 -4064 -3201 -743 2176 4144 4225 2424 -491 -2999 -4011 -3065 -524 2366 4218 4166 2266 -527 -3007 -3950 -2995 -441 2446 4186 4011 2055 -793 -3221 -4122 -3048 -497 2269 3910 3759 1847 -951 -3318 -4032 -2861 -261 2461 4044 3777 1764 -1048 -3282 -3888 -2595 8 2720 4200 3747 1609 -1195 -3413 -4006 -2727 -94 2586 4001 3501 1396 -1321 -3396 -3835 -2456 164 2756 3984 3385 1253 -1458 -3540 -3889 -2427 161 2654 3835 3194 978 -1743 -3638 -3838 -2295 322 2819 3964 3211 939 -1698 -3550 -3689 -2147 446 2883 3884 3016 726 -1901 -3667 -3765 -2123 530 2870 3745 2848 568 -2028 -3721 -3652 -1884 743 3014 3804 2827 478 -2144 -3779 -3686 -1910 685 2910 3669 2636 249 -2295 -3828 -3676 -1867 787 3011 3681 2564 169 -2269 -3684 -3424 -1508 1109 3282 3789 2575 134 -2334 -3779 -3482 -1543 1073 3099 3608 2339 -127 -2620 -3944 -3519 -1525 1092 3151 3535 2273 -193 -2580 -3787 -3318 -1296 1326 3309 3652 2234 -256 -2634 -3888 -3409 -1348 1282 3204 3491 2125 -346 -2666 -3811 -3204 -1114 1441 3253 3462 2008 -432 -2714 -3692 -3007 -861 1662 3399 3499 1940 -547 -2821 -3765 -2983 -854 1648 3346 3394 1743 -761 -2958 -3849 -3087 -822 1676 3304 3282 1636 -822 -2963 -3772 -2878 -644 1835 3375 3296 1599 -831 -2924 -3667 -2702 -446 1998 3489 3307 1604 -885 -2949 -3667 -2658 -408 1984 3421 3207 1407 -1005 -3028 -3592 -2493 -223 2183 3519 3168 1323 -1124 -3078 -3621 -2468 -157 2191 3465 3090 1216 -1211 -3123 -3584 -2390 -106 2201 3424 2983 1031 -1414 -3236 -3594 -2278 52 2393 3518 2982 1026 -1372 -3185 -3492 -2174 217 2481 3558 2990 999 -1399 -3104 -3323 -1944 391 2603 3528 2824 765 -1645 -3338 -3516 -2118 259 2439 3404 2700 654 -1716 -3375 -3479 -1952 439 2602 3455 2704 617 -1772 -3360 -3404 -1901 493 2585 3413 2571 442 -1901 -3413 -3358 -1742 676 2719 3458 2583 442 -1862 -3275 -3184 -1514 848 2836 3482 2495 313 -1981 -3404 -3224 -1543 771 2719 3268 2198 22 -2217 -3523 -3218 -1457 934 2870 3380 2242 59 -2137 -3336 -3000 -1255 1077 2880 3290 2110 -83 -2249 -3472 -3087 -1267 1111 2885 3257 2040 -176 -2349 -3455 -3004 -1129 1255 3036 3316 2039 -227 -2339 -3367 -2824 -929 1423 3077 3287 1959 -317 -2425 -3404 -2826 -843 1430 3068 3162 1762 -476 -2500 -3382 -2659 -727 1562 3083 3145 1742 -512 -2522 -3314 -2559 -602 1664 3136 3073 1555 -715 -2690 -3413 -2556 -503 1757 3190 3055 1450 -804 -2731 -3387 -2464 -390 1826 3150 2944 1301 -988 -2887 -3487 -2491 -402 1808 3073 2807 1145 -1095 -2921 -3406 -2352 -208 1950 3141 2802 1072 -1204 -2977 -3394 -2252 -139 2044 3163 2751 988 -1284 -2999 -3350 -2217 -88 2015 3102 2629 783 -1424 -3044 -3346 -2157 -30 2050 2988 2449 636 -1582 -3178 -3411 -2135 33 2055 3016 2424 588 -1604 -3153 -3331 -2032 105 2123 3004 2344 451 -1704 -3204 -3309 -1933 240 2208 3055 2334 446 -1723 -3175 -3231 -1818 359 2308 3090 2346 386 -1787 -3260 -3265 -1820 356 2266 2999 2193 254 -1933 -3348 -3302 -1774 369 2222 2917 2042 49 -2030 -3348 -3221 -1676 551 2424 2995 2054 59 -2069 -3306 -3095 -1494 698 2522 3017 1974 -76 -2184 -3380 -3114 -1440 812 2568 3072 2033 -28 -2128 -3285 -2956 -1228 978 2724 3102 2010 -72 -2132 -3243 -2871 -1197 1016 2712 3029 1879 -193 -2206 -3229 -2775 -1056 1151 2797 3009 1818 -259 -2251 -3228 -2729 -924 1199 2758 2960 1718 -366 -2324 -3206 -2607 -812 1346 2836 2951 1687 -417 -2296 -3068 -2403 -625 1489 2924 2973 1616 -495 -2352 -3067 -2391 -554 1545 2861 2807 1397 -666 -2452 -3170 -2430 -598 1455 2785 2736 1312 -666 -2441 -3082 -2300 -371 1625 2866 2787 1319 -715 -2419 -3014 -2215 -357 1630 2768 2593 1134 -895 -2544 -3051 -2178 -300 1721 2892 2634 1145 -873 -2515 -2951 -2057 -198 1786 2807 2505 988 -1041 -2620 -2987 -2040 -173 1787 2775 2424 878 -1146 -2653 -2960 -1923 -22 1884 2870 2447 839 -1131 -2622 -2897 -1799 150 2027 2955 2466 880 -1138 -2624 -2885 -1730 215 2008 2792 2244 532 -1406 -2788 -2907 -1703 271 2074 2865 2293 571 -1377 -2724 -2844 -1597 359 2159 2905 2247 524 -1426 -2756 -2770 -1526 385 2118 2799 2111 366 -1521 -2792 -2805 -1494 476 2227 2856 2176 419 -1497 -2702 -2664 -1365 576 2242 2846 2050 288 -1597 -2805 -2685 -1346 610 2278 2780 1937 101 -1784 -2922 -2737 -1321 656 2274 2778 1906 101 -1762 -2860 -2610 -1156 798 2368 2831 1903 113 -1745 -2832 -2569 -1114 817 2385 2771 1847 64 -1781 -2734 -2446 -980 972 2488 2827 1830 -37 -1804 -2773 -2381 -854 1075 2529 2805 1762 -115 -1871 -2814 -2424 -863 995 2388 2588 1572 -262 -1977 -2756 -2281 -768 1187 2551 2702 1616 -217 -1921 -2693 -2156 -525 1368 2688 2802 1681 -176 -1843 -2583 -2054 -486 1362 2622 2668 1482 -310 -1964 -2658 -2030 -407 1440 2632 2615 1414 -419 -1998 -2603 -1949 -308 1501 2646 2553 1251 -544 -2111 -2641 -1891 -203 1606 2693 2558 1221 -636 -2152 -2639 -1867 -169 1662 2737 2547 1212 -588 -2088 -2498 -1655 66 1843 2843 2575 1178 -659 -2118 -2500 -1614 84 1874 2810 2476 1056 -807 -2218 -2522 -1633 91 1833 2736 2359 912 -917 -2295 -2539 -1521 210 1962 2793 2374 877 -956 -2273 -2486 -1486 273 1960 2763 2318 846 -924 -2200 -2364 -1294 463 2123 2812 2301 746 -1033 -2281 -2395 -1277 478 2088 2770 2203 668 -1089 -2273 -2325 -1138 593 2156 2782 2140 586 -1177 -2335 -2295 -1131 673 2266 2788 2115 527 -1240 -2337 -2291 -1065 714 2232 2751 2049 415 -1301 -2344 -2203 -912 893 2398 2875 2103 441 -1287 -2285 -2145 -860 919 2373 2787 1955 291 -1384 -2390 -2218 -926 895 2315 2670 1786 118 -1521 -2456 -2156 -763 1043 2485 2775 1905 215 -1428 -2301 -1988 -605 1143 2486 2773 1811 106 -1504 -2330 -1949 -517 1224 2539 2766 1765 -1 -1609 -2354 -1901 -485 1265 2576 2702 1630 -103 -1664 -2429 -1998 -532 1202 2383 2439 1382 -313 -1859 -2522 -1972 -449 1268 2454 2522 1407 -266 -1801 -2391 -1793 -269 1458 2597 2563 1399 -335 -1806 -2393 -1781 -264 1457 2571 2525 1296 -424 -1881 -2419 -1738 -169 1570 2620 2485 1246 -483 -1893 -2373 -1645 -76 1594 2564 2400 1128 -595 -2039 -2476 -1670 -79 1582 2556 2366 1092 -661 -2010 -2352 -1514 42 1745 2668 2398 1085 -602 -1954 -2271 -1428 161 1794 2649 2296 1000 -680 -1991 -2286 -1416 208 1781 2580 2232 882 -783 -2025 -2223 -1270 357 1925 2659 2237 856 -861 -2084 -2254 -1331 264 1833 2527 2105 724 -924 -2098 -2169 -1211 463 2013 2658 2137 717 -951 -2037 -2125 -1067 580 2088 2704 2156 712 -922 -1998 -2030 -975 687 2101 2625 2033 553 -1068 -2105 -2113 -992 614 2054 2544 1925 393 -1209 -2193 -2120 -978 659 2095 2553 1852 371 -1175 -2167 -2055 -907 712 2117 2532 1833 351 -1221 -2191 -2064 -904 722 2089 2497 1755 251 -1306 -2191 -1996 -809 793 2079 2441 1687 159 -1350 -2232 -1959 -717 875 2159 2439 1591 74 -1423 -2210 -1928 -710 904 2117 2327 1511 0 -1455 -2184 -1832 -544 1070 2242 2419 1545 6 -1440 -2161 -1769 -468 1124 2271 2393 1463 -93 -1541 -2206 -1748 -459 1145 2278 2366 1367 -193 -1575 -2225 -1774 -398 1206 2305 2327 1348 -193 -1597 -2240 -1767 -379 1195 2225 2232 1192 -351 -1692 -2218 -1655 -300 1255 2262 2245 1173 -381 -1740 -2223 -1589 -193 1358 2339 2254 1162 -359 -1698 -2137 -1513 -130 1419 2361 2208 1099 -480 -1771 -2242 -1558 -110 1399 2259 2096 965 -566 -1838 -2200 -1501 -69 1440 2279 2064 956 -566 -1796 -2127 -1367 47 1509 2339 2071 854 -666 -1862 -2105 -1321 125 1599 2378 2079 834 -676 -1816 -2062 -1279 167 1625 2349 1998 792 -726 -1860 -2055 -1178 296 1692 2369 1979 714 -802 -1893 -2084 -1211 261 1664 2237 1779 464 -1005 -2033 -2147 -1245 259 1594 2166 1720 434 -1065 -2061 -2095 -1133 371 1750 2251 1742 417 -1055 -2010 -2003 -1033 476 1747 2210 1621 274 -1178 -2098 -2074 -1051 405 1660 2091 1502 145 -1277 -2162 -2062 -1043 446 1704 2091 1430 117 -1302 -2130 -2008 -924 534 1752 2081 1391 6 -1401 -2186 -2016 -924 551 1669 1938 1233 -144 -1443 -2208 -1949 -810 656 1764 2040 1273 -74 -1399 -2100 -1818 -690 741 1816 2006 1199 -137 -1418 -2110 -1808 -673 737 1740 1866 1055 -293 -1597 -2213 -1793 -644 736 1752 1869 1050 -301 -1584 -2159 -1776 -568 810 1796 1871 1005 -364 -1608 -2164 -1706 -534 843 1798 1833 919 -422 -1660 -2137 -1655 -454 917 1830 1784 866 -449 -1647 -2147 -1604 -424 965 1801 1743 821 -566 -1743 -2128 -1562 -305 1000 1820 1704 753 -619 -1781 -2127 -1565 -334 1000 1874 1733 710 -631 -1726 -2074 -1487 -225 1072 1849 1676 690 -670 -1771 -2072 -1409 -150 1134 1842 1630 622 -744 -1801 -2088 -1375 -118 1112 1793 1572 517 -861 -1860 -2061 -1360 -125 1153 1801 1499 435 -863 -1843 -2011 -1287 -15 1250 1871 1496 419 -888 -1866 -2020 -1263 25 1240 1801 1457 354 -941 -1864 -1971 -1153 123 1290 1808 1416 300 -992 -1882 -1974 -1136 101 1265 1735 1287 169 -1145 -2027 -2006 -1172 88 1243 1709 1223 74 -1185 -2022 -1994 -1090 201 1290 1665 1151 -5 -1270 -2037 -1964 -1029 254 1341 1723 1148 -30 -1243 -1998 -1893 -990 313 1404 1692 1116 -88 -1318 -2061 -1901 -966 335 1372 1657 1007 -184 -1409 -2127 -1972 -1012 273 1297 1553 922 -283 -1502 -2195 -1944 -924 359 1353 1581 934 -257 -1472 -2069 -1782 -743 544 1508 1721 1005 -239 -1430 -2013 -1728 -726 568 1513 1687 946 -274 -1453 -2000 -1706 -615 656 1560 1662 916 -303 -1462 -2018 -1660 -619 641 1506 1558 765 -459 -1584 -2078 -1667 -602 614 1463 1504 707 -507 -1609 -2050 -1591 -502 732 1547 1574 746 -434 -1467 -1896 -1414 -320 873 1638 1558 717 -546 -1572 -1920 -1423 -303 914 1626 1499 622 -576 -1601 -1947 -1440 -315 878 1564 1413 497 -700 -1630 -1901 -1340 -235 943 1635 1450 505 -673 -1626 -1838 -1268 -117 1063 1699 1487 566 -598 -1531 -1754 -1133 6 1155 1725 1477 520 -692 -1577 -1721 -1087 50 1187 1782 1497 541 -634 -1526 -1698 -1005 122 1201 1737 1426 424 -741 -1599 -1704 -1051 98 1219 1728 1363 347 -795 -1614 -1650 -910 278 1353 1830 1470 405 -761 -1553 -1575 -782 407 1414 1867 1394 356 -827 -1587 -1589 -810 320 1326 1735 1304 232 -916 -1650 -1601 -790 378 1401 1748 1262 196 -924 -1606 -1538 -720 463 1453 1774 1262 215 -880 -1591 -1465 -619 542 1487 1760 1224 169 -924 -1567 -1379 -486 658 1604 1874 1328 256 -834 -1433 -1297 -476 680 1601 1816 1236 149 -922 -1492 -1307 -434 705 1579 1733 1136 59 -1005 -1540 -1331 -395 756 1616 1789 1146 67 -944 -1440 -1162 -234 897 1698 1796 1162 54 -965 -1433 -1126 -196 909 1742 1826 1116 39 -951 -1385 -1117 -179 985 1740 1777 1100 -3 -973 -1397 -1065 -139 965 1709 1708 1009 -83 -1061 -1492 -1114 -176 914 1630 1640 902 -188 -1100 -1497 -1082 -135 948 1676 1636 887 -137 -1063 -1382 -966 10 1061 1728 1681 890 -196 -1095 -1360 -888 52 1082 1706 1594 775 -300 -1194 -1472 -994 -25 1014 1628 1484 690 -420 -1262 -1480 -1007 -10 1063 1653 1467 631 -413 -1268 -1460 -951 27 1033 1557 1336 508 -544 -1350 -1552 -999 1 1027 1506 1307 486 -568 -1367 -1492 -904 123 1082 1574 1307 437 -602 -1372 -1474 -880 135 1083 1518 1204 320 -717 -1489 -1574 -980 22 965 1401 1092 188 -858 -1536 -1564 -893 120 1029 1372 1038 173 -824 -1484 -1470 -809 225 1095 1435 1063 156 -851 -1492 -1482 -804 189 1075 1357 992 79 -941 -1541 -1513 -817 186 1038 1329 909 -1 -951 -1550 -1487 -776 242 1068 1319 907 -37 -970 -1562 -1433 -703 281 1111 1338 877 -22 -994 -1547 -1382 -646 359 1158 1375 877 -39 -917 -1424 -1279 -513 488 1246 1396 895 -42 -944 -1430 -1251 -444 493 1180 1296 748 -193 -1056 -1523 -1294 -507 471 1189 1294 754 -176 -1068 -1426 -1178 -354 617 1314 1423 832 -137 -1029 -1413 -1138 -379 566 1257 1306 693 -251 -1112 -1494 -1204 -366 595 1224 1217 608 -351 -1167 -1513 -1184 -340 595 1201 1206 551 -368 -1260 -1558 -1240 -403 519 1117 1089 435 -536 -1324 -1623 -1250 -366 575 1173 1122 468 -466 -1309 -1516 -1111 -244 680 1257 1162 486 -441 -1211 -1443 -1011 -161 763 1258 1160 463 -481 -1258 -1414 -955 -105 773 1243 1104 435 -491 -1216 -1382 -949 -118 800 1263 1089 332 -585 -1250 -1363 -926 -47 832 1262 1027 296 -598 -1258 -1368 -829 54 919 1299 1085 378 -515 -1153 -1219 -703 189 997 1391 1145 393 -517 -1141 -1201 -678 213 1036 1363 1104 303 -605 -1216 -1279 -683 193 983 1304 1011 249 -641 -1223 -1251 -646 245 1046 1299 1002 205 -671 -1216 -1173 -554 354 1136 1397 1043 225 -659 -1189 -1133 -498 368 1139 1391 1004 178 -646 -1160 -1056 -478 432 1160 1401 978 161 -653 -1138 -1089 -420 459 1139 1341 927 115 -695 -1170 -1038 -381 468 1148 1316 893 61 -744 -1201 -1061 -376 503 1173 1341 899 49 -731 -1155 -1000 -312 536 1168 1335 853 27 -754 -1167 -983 -279 575 1219 1297 797 -8 -790 -1145 -931 -234 617 1223 1245 737 -89 -863 -1195 -949 -218 617 1167 1202 693 -183 -895 -1216 -951 -220 629 1172 1199 664 -128 -836 -1134 -844 -108 731 1265 1229 659 -157 -860 -1119 -809 -91 734 1240 1178 595 -229 -975 -1194 -870 -111 678 1150 1136 537 -283 -943 -1165 -800 -71 766 1226 1106 520 -271 -924 -1129 -800 -49 785 1221 1072 476 -361 -980 -1162 -753 1 768 1204 1063 415 -364 -994 -1122 -678 83 868 1268 1109 498 -329 -938 -1039 -631 137 880 1234 1009 354 -422 -1041 -1109 -663 72 832 1182 994 335 -478 -1029 -1136 -649 152 885 1234 1004 320 -471 -999 -1044 -539 247 926 1272 1070 373 -381 -939 -987 -490 256 966 1294 1007 305 -461 -972 -963 -469 278 966 1228 927 218 -529 -1044 -1041 -517 264 924 1143 853 105 -632 -1104 -1048 -507 313 943 1143 788 98 -670 -1100 -1019 -429 339 968 1141 822 117 -603 -1002 -907 -334 454 1050 1195 795 96 -612 -1014 -934 -369 412 983 1073 680 -47 -759 -1153 -1021 -419 335 919 1053 697 -15 -724 -1067 -916 -332 420 966 1055 659 -67 -734 -1106 -917 -349 385 929 1034 600 -96 -734 -1029 -885 -217 513 1060 1082 676 -40 -698 -1005 -785 -193 580 1063 1097 670 -45 -707 -1005 -787 -178 512 1029 1016 505 -217 -829 -1094 -827 -196 517 949 944 480 -229 -836 -1041 -753 -135 602 1100 1068 615 -83 -695 -948 -644 27 710 1133 1073 549 -179 -793 -1005 -736 -71 617 1044 990 463 -266 -831 -1017 -680 -45 658 1063 978 430 -245 -815 -944 -624 42 707 1034 910 376 -327 -880 -1014 -653 -55 636 966 812 290 -393 -917 -1022 -612 61 698 1034 902 327 -386 -912 -1005 -598 44 673 1002 838 261 -464 -944 -1053 -661 27 676 949 739 130 -537 -1031 -1097 -687 -18 653 922 690 113 -547 -1036 -1033 -597 105 719 983 751 149 -536 -978 -983 -546 125 737 949 681 79 -573 -1005 -1002 -559 108 720 895 648 28 -653 -1050 -1011 -524 137 681 834 536 -93 -754 -1160 -1085 -624 79 603 758 463 -184 -829 -1189 -1080 -563 79 631 788 434 -178 -809 -1129 -965 -454 201 724 861 497 -139 -724 -1082 -980 -405 227 729 804 430 -206 -814 -1158 -992 -439 218 683 751 351 -264 -890 -1177 -988 -449 159 661 726 356 -295 -904 -1131 -936 -415 242 697 707 301 -307 -870 -1106 -926 -337 296 739 739 356 -300 -829 -1053 -814 -212 407 821 839 378 -268 -829 -1026 -814 -232 361 749 744 274 -366 -910 -1090 -814 -254 347 751 676 184 -402 -924 -1077 -785 -189 419 763 683 240 -354 -885 -1017 -707 -117 481 812 722 290 -296 -793 -919 -590 -15 576 897 805 322 -312 -809 -890 -598 -64 544 839 715 242 -385 -836 -895 -592 10 602 878 765 291 -315 -731 -815 -454 123 707 955 826 300 -291 -717 -775 -434 139 710 973 788 254 -347 -732 -765 -391 189 714 961 776 249 -330 -707 -709 -332 230 736 941 736 196 -398 -783 -805 -408 195 663 838 632 94 -490 -849 -815 -435 162 648 822 607 83 -481 -826 -768 -320 259 731 873 649 135 -429 -734 -664 -247 335 802 921 629 89 -463 -753 -681 -300 247 693 792 513 -27 -566 -838 -714 -315 271 697 798 493 -22 -564 -860 -707 -245 281 722 819 541 -13 -505 -734 -617 -195 390 814 858 539 11 -520 -739 -607 -149 449 815 848 497 -45 -510 -790 -605 -171 369 775 780 461 -103 -603 -809 -639 -189 329 693 687 354 -183 -671 -843 -654 -193 368 739 770 376 -149 -575 -761 -578 -93 452 839 804 403 -134 -568 -726 -508 -45 498 778 773 371 -161 -625 -766 -530 -57 485 824 731 378 -179 -598 -727 -532 -25 502 773 698 291 -212 -670 -790 -546 -83 420 712 608 218 -293 -703 -787 -524 -49 471 739 649 274 -249 -661 -739 -452 57 532 810 710 274 -234 -619 -698 -413 61 558 758 602 169 -351 -732 -798 -517 -28 435 653 493 52 -408 -810 -817 -490 20 525 719 532 89 -407 -780 -804 -474 1 463 656 466 40 -463 -785 -809 -459 22 452 642 493 13 -435 -754 -717 -366 113 541 714 471 33 -456 -773 -748 -429 61 495 625 420 -15 -502 -838 -751 -402 106 500 610 395 -37 -510 -787 -739 -342 157 549 646 427 -20 -463 -734 -670 -290 208 608 709 452 -20 -469 -724 -666 -273 218 622 648 390 -44 -495)		samplingRate: 22050.	snd play.! !!TrashCanMorph methodsFor: 'all' stamp: 'sw 10/18/97 18:03'!playMouseEnterSound	| snd |	snd _ SampledSound			samples: #(-37 -24 -30 -30 -25 -23 -11 -8 -38 -40 -34 -21 -18 -27 -34 -20 2 11 8 10 5 7 10 14 34 28 34 54 59 47 54 25 27 43 33 48 23 40 59 63 47 46 27 47 43 41 46 50 64 57 46 57 44 48 12 17 24 28 18 23 27 -7 -17 2 4 1 -4 18 12 11 34 25 43 18 11 20 43 43 11 12 31 -5 -11 -43 -41 -17 -23 -28 -38 -33 -48 -64 -61 -53 -61 -54 -56 -73 -73 -48 -48 -63 -92 -102 -90 -92 -115 -93 -90 -109 -120 -112 -119 -141 -136 -128 -146 -143 -141 -129 -118 -139 -132 -120 -103 -100 -96 -79 -71 -83 -79 -77 -87 -73 -73 -43 -24 -5 -10 20 23 -5 -4 0 28 20 -11 20 4 -11 -23 20 27 7 8 -2 -7 -15 -27 4 0 -8 -34 -31 -38 -34 -50 -40 -64 -46 -59 -51 -82 -80 -82 -80 -89 -95 -122 -89 -97 -67 -64 -31 -21 -34 -56 -25 -35 -48 -63 -37 -54 -34 8 40 82 161 306 503 921 1638 2549 3458 4074 4290 3947 2988 1528 -293 -2417 -4592 -6693 -8734 -10727 -12641 -14255 -15466 -16249 -16383 -15965 -15159 -14019 -12574 -10934 -9124 -7214 -5191 -3092 -856 1418 3639 5667 7543 9156 10532 11608 12361 12795 12922 12755 12307 11574 10473 8964 7129 5084 2911 596 -1773 -4103 -6374 -8593 -10593 -12355 -13748 -14599 -14866 -14527 -13593 -12109 -10146 -7697 -4933 -2022 881 3689 6302 8638 10580 12067 13052 13602 13774 13543 13046 12276 11271 9965 8426 6677 4771 2731 607 -1469 -3420 -5217 -6790 -8196 -9401 -10377 -11001 -11242 -11095 -10600 -9729 -8581 -7114 -5423 -3563 -1566 488 2577 4556 6448 8234 9786 11143 12136 12756 13034 12936 12489 11744 10678 9320 7673 5775 3813 1813 -182 -2113 -3924 -5606 -7123 -8439 -9477 -10213 -10688 -10855 -10663 -10109 -9278 -8125 -6682 -5004 -3147 -1171 791 2762 4655 6386 7944 9222 10201 10800 11120 11163 10885 10313 9434 8363 7050 5604 4048 2395 711 -872 -2376 -3707 -4894 -5875 -6667 -7214 -7489 -7480 -7251 -6739 -6039 -5102 -3987 -2754 -1475 -207 1094 2392 3590 4686 5639 6469 7178 7758 8142 8273 8187 7883 7398 6803 6056 5188 4152 3075 1968 866 -184 -1197 -2143 -2964 -3615 -4163 -4572 -4907 -5100 -5141 -5018 -4723 -4288 -3725 -3031 -2198 -1246 -276 704 1661 2529 3377 4140 4835 5333 5721 5941 6098 6048 5846 5498 5047 4467 3816 3131 2444 1659 856 57 -636 -1301 -1946 -2549 -3099 -3548 -3871 -4057 -4143 -4153 -3999 -3753 -3380 -2893 -2338 -1742 -1098 -391 380 1111 1822 2543 3206 3784 4283 4638 4868 4955 4894 4713 4385 3938 3365 2679 1910 1089 272 -564 -1379 -2145 -2902 -3583 -4127 -4562 -4866 -5010 -4949 -4785 -4468 -4026 -3463 -2817 -2070 -1256 -398 462 1297 2147 2922 3613 4211 4732 5178 5449 5617 5608 5456 5168 4727 4120 3404 2561 1646 706 -218 -1212 -2160 -3018 -3688 -4293 -4726 -5015 -5195 -5231 -5096 -4788 -4321 -3754 -3057 -2240 -1363 -433 515 1446 2340 3118 3820 4401 4851 5133 5256 5195 5011 4696 4209 3627 2934 2168 1334 434 -475 -1357 -2211 -2981 -3669 -4285 -4771 -5116 -5322 -5382 -5315 -5067 -4701 -4169 -3518 -2775 -1937 -1036 -165 735 1626 2440 3115 3681 4154 4467 4625 4681 4589 4344 4008 3583 3008 2353 1615 777 -57 -872 -1713 -2486 -3206 -3843 -4391 -4840 -5116 -5273 -5277 -5128 -4831 -4418 -3868 -3252 -2533 -1744 -898 -67 780 1570 2300 2913 3463 3874 4159 4331 4353 4248 4028 3668 3184 2633 1949 1216 426 -341 -1109 -1852 -2512 -3102 -3597 -3983 -4224 -4349 -4339 -4183 -3910 -3520 -3065 -2510 -1885 -1242 -588 54 685 1249 1839 2352 2777 3106 3327 3466 3488 3417 3234 2948 2617 2185 1671 1117 564 -15 -608 -1174 -1700 -2196 -2650 -3039 -3296 -3481 -3587 -3568 -3460 -3273 -2983 -2614 -2156 -1658 -1154 -626 -89 421 921 1413 1865 2266 2602 2818 3004 3090 3036 2944 2824 2565 2214 1837 1422 954 469 -15 -490 -960 -1413 -1806 -2139 -2421 -2703 -2877 -2949 -2974 -2964 -2820 -2608 -2340 -1972 -1592 -1154 -680 -190 267 745 1183 1592 1947 2225 2473 2624 2696 2723 2692 2565 2408 2219 1916 1579 1200 797 368 -115 -549 -994 -1408 -1767 -2037 -2241 -2394 -2469 -2497 -2427 -2317 -2150 -1887 -1551 -1197 -778 -346 103 544 942 1390 1766 2077 2353 2535 2657 2697 2700 2615 2473 2257 1980 1677 1287 871 466 21 -377 -757 -1134 -1464 -1713 -1932 -2096 -2208 -2243 -2235 -2168 -2051 -1854 -1566 -1229 -888 -499 -100 319 719 1124 1481 1801 2084 2306 2434 2469 2476 2431 2287 2101 1825 1527 1194 836 483 123 -231 -593 -931 -1251 -1541 -1796 -1978 -2122 -2188 -2162 -2106 -1903 -1717 -1467 -1140 -814 -463 -115 254 617 950 1284 1550 1753 1880 1992 1988 1930 1829 1695 1475 1226 924 603 293 -27 -345 -640 -954 -1217 -1471 -1687 -1832 -1917 -1985 -1960 -1900 -1750 -1546 -1356 -1092 -771 -469 -135 200 555 895 1176 1429 1628 1786 1920 1968 1966 1924 1842 1704 1464 1200 922 600 285 -21 -348 -614 -840 -1073 -1266 -1397 -1501 -1595 -1635 -1638 -1585 -1464 -1311 -1151 -971 -735 -501 -267 -43 210 398 643 865 1050 1206 1333 1419 1418 1410 1383 1281 1147 996 803 621 437 226 23 -148 -309 -466 -611 -748 -849 -912 -964 -1016 -1039 -1032 -990 -868 -757 -621 -440 -256 -118 43 194 354 470 564 653 718 780 809 793 748 672 587 453 321 151 8 -142 -308 -499 -647 -819 -950 -1073 -1169 -1243 -1276 -1282 -1262 -1219 -1140 -1016 -921 -809 -624 -475 -335 -142 25 182 339 483 613 702 796 856 899 898 902 858 826 735 656 529 395 263 146 -14 -167 -346 -480 -633 -715 -806 -878 -955 -958 -978 -930 -891 -794 -705 -616 -477 -336 -243 -112 4 109 205 276 332 430 480 519 508 521 513 518 463 384 319 227 112 -8 -100 -202 -348 -505 -596 -725 -833 -906 -951 -940 -927 -883 -806 -692 -542 -365 -207 -60 80 249 400 483 584 626 650 657 634 585 493 443 351 238 158 63 -30 -123 -185 -279 -359 -400 -470 -529 -570 -561 -594 -601 -588 -570 -524 -477 -414 -328 -236 -141 -37 48 99 204 287 391 441 472 495 516 476 418 371 292 204 99 -10 -43 -118 -207 -253 -303 -341 -349 -359 -342 -338 -305 -264 -227 -164 -119 -46 38 99 138 174 227 234 215 231 262 234 227 237 273 218 198 192 192 135 119 90 44 -27 -40 -73 -99 -132 -149 -154 -128 -92 -46 -23 38 59 59 51 57 50 28 17 37 -10 2 -4 -40 -71 -96 -126 -142 -194 -227 -274 -300 -345 -362 -369 -357 -345 -335 -303 -256 -223 -191 -141 -116 -71 -80 -96 -74 -86 -120 -141 -181 -249 -315 -372 -388 -397 -430 -449 -460 -462 -417 -391 -357 -299 -253 -175 -119 -34 43 128 198 241 282 357 410 436 444 472 473 441 413 358 260 191 96 -12 -74 -164 -270 -346 -437 -513 -594 -652 -704 -728 -750 -735 -668 -626 -544 -456 -341 -244 -138 -34 89 195 293 381 459 476 549 597 600 620 601 572 532 475 417 351 233 135 63 -44 -142 -230 -295 -385 -405 -450 -472 -492 -463 -482 -477 -460 -440 -393 -339 -326 -257 -190 -126 -35 63 146 201 283 355 393 401 427 441 411 382 335 282 241 200 133 90 30 -8 -64 -116 -142 -175 -213 -223 -244 -274 -280 -272 -280 -264 -241 -262 -249 -228 -211 -156 -128 -64 -21 43 80 129 142 187 215 227 230 237 243 254 266 267 273 256 254 251 253 236 208 164 128 69 54 30 -18 -69 -86 -106 -143 -167 -188 -218 -246 -247 -233 -220 -169 -138 -95 -44 -23 18 69 116 188 236 298 380 440 503 516 538 544 516 485 475 427 374 310 292 220 109 57 5 -100 -184 -276 -362 -436 -480 -512 -539 -531 -524 -511 -452 -371 -302 -260 -169 -95 -46 59 156 208 262 336 397 421 436 441 427 427 414 368 332 298 237 197 145 93 46 0 -48 -89 -112 -138 -132 -118 -73 -23 0)		samplingRate: 22050.	snd play! !!TrashCanMorph methodsFor: 'all' stamp: 'sw 10/18/97 18:03'!playMouseLeaveSound	| snd |	snd _ SampledSound			samples: #(230 254 256 242 234 246 206 211 179 175 133 111 106 91 46 53 35 54 17 40 67 98 79 114 127 167 162 133 130 119 91 82 98 90 75 87 45 19 -17 1 -16 -1 8 12 -1 53 71 85 109 117 106 159 138 154 133 161 122 138 85 72 67 51 46 20 6 3 -8 8 -8 -4 -1 22 38 53 43 85 71 103 88 87 45 51 43 59 16 -9 -17 1 -45 -20 -32 -8 -38 3 -20 20 43 53 43 37 24 54 30 58 59 32 20 33 17 8 -30 -56 -72 -111 -133 -127 -122 -111 -129 -111 -108 -112 -108 -111 -135 -100 -130 -111 -158 -125 -121 -104 -96 -111 -135 -106 -111 -104 -133 -111 -143 -137 -140 -130 -109 -103 -119 -62 -59 -67 -62 -33 -41 -12 -43 -46 -43 -38 -71 -87 -100 -80 -125 -124 -145 -132 -145 -111 -148 -106 -95 -79 -51 -14 -17 8 22 85 93 111 116 127 138 133 96 67 53 72 45 -22 -30 -20 -33 16 27 121 177 335 500 756 1023 1362 1738 2131 2465 2769 2932 3032 2951 2609 1980 1102 -43 -1326 -2769 -4181 -5598 -6852 -7906 -8630 -9014 -8982 -8390 -7257 -5645 -3637 -1415 1029 3476 5953 8267 10196 11595 12386 12531 12089 10938 9187 6826 4120 1124 -1933 -4946 -7699 -10138 -12005 -13244 -13719 -13418 -12384 -10706 -8485 -5808 -2796 421 3640 6629 9344 11524 13121 14054 14261 13735 12528 10643 8209 5307 2125 -1265 -4592 -7693 -10426 -12683 -14290 -15200 -15273 -14514 -12881 -10583 -7628 -4171 -448 3303 6911 10154 12921 14914 16133 16383 15750 14259 12040 9164 5772 2083 -1721 -5395 -8751 -11629 -13799 -15261 -15758 -15399 -14104 -11989 -9176 -5801 -2022 1844 5593 9006 11905 14064 15405 15842 15387 13957 11834 9005 5754 2215 -1402 -4888 -8044 -10744 -12739 -14054 -14519 -14216 -13070 -11186 -8680 -5729 -2501 789 4023 6924 9450 11320 12489 12920 12629 11614 9949 7764 5214 2411 -495 -3327 -5845 -8006 -9690 -10820 -11288 -11133 -10271 -8914 -6992 -4820 -2357 174 2643 4910 6853 8361 9360 9729 9537 8811 7573 5908 3939 1799 -448 -2695 -4641 -6343 -7628 -8525 -8926 -8785 -8177 -7118 -5640 -3861 -1943 43 2047 3813 5332 6502 7292 7601 7455 6837 5872 4578 3054 1305 -482 -2228 -3781 -5133 -6187 -6850 -7136 -7039 -6529 -5688 -4489 -3071 -1489 109 1726 3166 4447 5398 6034 6235 6151 5651 4847 3747 2483 997 -464 -1915 -3221 -4323 -5159 -5708 -5929 -5812 -5328 -4601 -3635 -2478 -1165 75 1324 2432 3366 4011 4423 4557 4439 3961 3326 2470 1494 422 -616 -1596 -2506 -3267 -3797 -4124 -4258 -4142 -3740 -3235 -2527 -1702 -832 43 919 1718 2391 2820 3151 3276 3206 2988 2569 1983 1321 587 -125 -837 -1516 -2112 -2554 -2854 -2951 -2883 -2669 -2285 -1771 -1186 -539 119 779 1363 1889 2223 2457 2528 2451 2177 1776 1271 681 88 -500 -1079 -1592 -2009 -2283 -2420 -2354 -2230 -1904 -1460 -942 -385 198 766 1263 1660 1967 2138 2185 2094 1889 1518 1102 577 56 -463 -971 -1423 -1799 -2070 -2222 -2244 -2112 -1910 -1554 -1166 -679 -162 353 797 1195 1505 1733 1844 1863 1696 1489 1144 731 267 -201 -706 -1157 -1525 -1834 -2036 -2089 -2033 -1893 -1644 -1281 -865 -367 85 572 968 1342 1591 1783 1812 1699 1481 1186 811 413 -66 -534 -965 -1333 -1699 -1920 -2046 -2022 -1964 -1721 -1410 -989 -505 -14 471 929 1337 1673 1863 1989 1993 1854 1634 1318 898 477 -50 -484 -940 -1320 -1657 -1852 -1978 -1928 -1778 -1531 -1199 -785 -316 174 634 1092 1470 1789 2022 2107 2081 1999 1715 1374 939 488 -27 -493 -953 -1326 -1644 -1880 -1997 -1960 -1875 -1639 -1345 -927 -511 -85 342 834 1202 1570 1801 1938 1989 1893 1721 1436 1068 663 216 -185 -632 -1040 -1384 -1625 -1783 -1857 -1836 -1659 -1466 -1131 -748 -359 46 476 852 1200 1445 1600 1678 1710 1544 1297 1003 676 246 -175 -621 -990 -1353 -1628 -1855 -1947 -1965 -1851 -1639 -1341 -973 -524 -106 376 776 1160 1492 1715 1815 1838 1738 1589 1279 979 559 106 -285 -731 -1128 -1450 -1731 -1922 -2001 -2005 -1863 -1636 -1316 -948 -545 -137 306 755 1126 1466 1717 1893 1955 1915 1760 1531 1190 844 384 -61 -511 -921 -1299 -1584 -1773 -1889 -1880 -1730 -1520 -1152 -716 -256 156 622 1057 1437 1709 1873 1925 1902 1718 1431 1103 706 272 -164 -563 -915 -1224 -1450 -1592 -1642 -1596 -1441 -1194 -879 -527 -133 274 705 1015 1294 1515 1610 1671 1592 1412 1195 876 556 214 -153 -495 -800 -1037 -1189 -1307 -1308 -1260 -1087 -879 -626 -335 8 321 651 900 1137 1299 1402 1387 1341 1165 950 689 388 50 -266 -572 -823 -1028 -1203 -1287 -1265 -1197 -1052 -847 -539 -253 72 411 708 976 1236 1404 1470 1433 1350 1181 965 679 366 71 -217 -547 -789 -971 -1039 -1082 -1008 -884 -726 -476 -185 104 403 697 939 1097 1232 1247 1257 1124 955 756 534 224 -38 -332 -537 -731 -889 -981 -992 -937 -839 -747 -547 -324 -111 116 343 547 724 847 924 910 902 777 676 482 301 85 -104 -272 -445 -597 -702 -779 -782 -800 -766 -653 -500 -390 -187 -59 114 259 417 508 603 643 676 626 572 463 366 200 54 -119 -237 -398 -501 -637 -698 -731 -722 -714 -624 -519 -369 -246 -82 54 248 372 492 540 592 589 526 426 358 211 56 -90 -206 -372 -476 -592 -640 -666 -661 -598 -487 -367 -211 -66 151 290 430 526 663 695 753 719 724 629 563 430 300 153 20 -85 -158 -251 -296 -309 -301 -269 -217 -153 -51 33 151 230 345 429 495 527 558 568 572 508 421 321 240 111 43 -114 -175 -232 -267 -288 -305 -300 -214 -180 -79 4 104 206 324 403 511 555 580 585 618 563 498 458 382 308 279 198 148 108 95 51 51 50 66 91 104 116 162 183 214 195 253 261 274 279 267 266 285 266 285 254 258 254 243 269 235 180 175 154 179 159 119 164 216 227 274 314 371 398 461 495 532 509 485 498 401 325 271 164 100 -27 -116 -166 -204 -230 -227 -222 -166 -106 -4 127 258 364 485 577 663 708 753 743 718 608 547 440 298 188 75 -71 -153 -204 -227 -246 -208 -198 -140 -85 43 137 254 343 438 524 593 610 631 605 572 511 456 338 250 154 62 -17 -33 -103 -77 -114 -69 -38 59 117 193 288 369 390 429 438 456 408 353 303 235 140 80 -29 -95 -164 -192 -208 -185 -166 -119 -58 95 198 288 371 488 519 563 598 582 547 482 387 277 112 4 -132 -179 -319 -376 -447 -416 -416 -382 -298 -169 -80 69 211 364 490 624 718 774 789 811 768 721 601 509 384 271 154 33 -95 -138 -216 -259 -253 -237 -198 -171 -109 -22 56 167 264 374 450 530 551 584 595 553 500 458 348 275 146 51 -62 -166 -201 -254 -295 -266 -253 -164 -137 -59 11 98 214 343 403 514 550 603 632 593 543 509 405 337 196 111 17 -61 -146 -188 -242 -229 -224 -201 -187 -129 -104 -37 77 112 166 237 275 311 292 292 290 235 162 111 43 4 -59 -72 -124 -140 -140 -117 -108 -61 -24 56 109 158 169 240 264 284 292 275 266 256 185 124 109 64 1 -41 -72 -87 -80 -77 -46 -35 -11 41 43 56 69 101 116 119 133 108 51 56 53 59 9 43 32 67 95 104 109 150 167 171 183 204 213 190 171 172 122 130 98 95 30 16 -20 -46 -88 -83 -74 -56 -19 33 85 119 201 272 279 319 342 364 369 376 335 325 282 213 158 108 8 -30 -116 -130 -169 -182 -164 -140 -137 -82 -54 32 116 175 225 284 317 379 369 377 342 314)			samplingRate: 22050.	snd play! !!TrashCanMorph methodsFor: 'all' stamp: 'di 1/13/98 21:55'!showCursor: evt	"If painting, and a stamp, show it.""Dummied"! !!TrashCanMorph methodsFor: 'all' stamp: 'sw 11/16/97 21:46'!wantsDroppedMorph: aMorph event: evt	^ aMorph ~~ self! !!TReturnNode methodsFor: 'all'!bindVariablesIn: aDictionary	expression _ expression bindVariablesIn: aDictionary.! !!TReturnNode methodsFor: 'all'!copyTree	^self class new		setExpression: expression copyTree! !!TReturnNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	aStream nextPutAll: 'return '.	expression emitCCodeOn: aStream level: level generator: aCodeGen.! !!TReturnNode methodsFor: 'all'!expression	^expression! !!TReturnNode methodsFor: 'all'!inlineMethodsUsing: aDictionary	expression _ expression inlineMethodsUsing: aDictionary.! !!TReturnNode methodsFor: 'all'!isReturn	^true! !!TReturnNode methodsFor: 'all'!nodesDo: aBlock	expression nodesDo: aBlock.	aBlock value: self.! !!TReturnNode methodsFor: 'all'!printOn: aStream level: level	aStream nextPut: $^.	expression printOn: aStream level: level.! !!TReturnNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!removeAssertions	expression removeAssertions! !!TReturnNode methodsFor: 'all'!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		expression _ expression replaceNodesIn: aDictionary.		self]! !!TReturnNode methodsFor: 'all'!setExpression: aNode	expression _ aNode.! !!TSendNode methodsFor: 'all'!args	^arguments! !!TSendNode methodsFor: 'all'!bindVariablesIn: aDictionary	receiver _ receiver bindVariablesIn: aDictionary.	arguments _ arguments collect: [ :a | a bindVariablesIn: aDictionary ].! !!TSendNode methodsFor: 'all'!copyTree	^self class new		setSelector: selector		receiver: receiver copyTree		arguments: (arguments collect: [ :arg | arg copyTree ])		isBuiltInOp: isBuiltinOperator! !!TSendNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	"If the selector is a built-in construct, translate it and return"	(aCodeGen emitBuiltinConstructFor: self on: aStream level: level) ifTrue: [ ^self ].	"Translate this message send into a C function call."	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	(receiver isVariable and:	 [(receiver name = 'self') or: [receiver name = 'interpreterProxy']]) ifFalse: [		"self is omitted from the arguments list of the generated call"		"Note: special case for translated BitBltSimulator--also omit		 the receiver if this is a send to the variable 'interpreterProxy'"		receiver emitCCodeOn: aStream level: level generator: aCodeGen.		arguments isEmpty ifFalse: [ aStream nextPutAll: ', ' ].	].	1 to: arguments size do: [ :i |		(arguments at: i) emitCCodeOn: aStream level: level generator: aCodeGen.		i < arguments size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !!TSendNode methodsFor: 'all'!inlineMethodsUsing: aDictionary	arguments _ arguments collect: [ :arg |		arg inlineMethodsUsing: aDictionary.	].	"xxx inline this message if it is in the dictionary xxx"! !!TSendNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!isAssertion	^(selector beginsWith: 'assert') or: [selector beginsWith: 'verify']! !!TSendNode methodsFor: 'all'!isBuiltinOperator	^ isBuiltinOperator! !!TSendNode methodsFor: 'all'!isBuiltinOperator: builtinFlag	isBuiltinOperator _ builtinFlag.! !!TSendNode methodsFor: 'all'!isSend	^true! !!TSendNode methodsFor: 'all'!nodesDo: aBlock	receiver nodesDo: aBlock.	arguments do: [ :arg | arg nodesDo: aBlock ].	aBlock value: self.! !!TSendNode methodsFor: 'all'!printOn: aStream level: level	| keywords |	receiver printOn: aStream level: level.	arguments size = 0 ifTrue: [		aStream space; nextPutAll: selector.		^self	].	keywords _ selector keywords.	1 to: keywords size do: [ :i |		aStream space.		aStream nextPutAll: (keywords at: i); space.		(arguments at: i) printOn: aStream level: level + 1.	].! !!TSendNode methodsFor: 'all'!receiver	^receiver! !!TSendNode methodsFor: 'all'!receiver: aNode	receiver _ aNode.! !!TSendNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!removeAssertions	receiver removeAssertions.	arguments do: [:arg | arg removeAssertions].! !!TSendNode methodsFor: 'all'!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		receiver _ receiver replaceNodesIn: aDictionary.		arguments _ arguments collect: [ :a | a replaceNodesIn: aDictionary ].		self]! !!TSendNode methodsFor: 'all'!selector	^selector! !!TSendNode methodsFor: 'all'!setSelector: aSymbol receiver: rcvrNode arguments: argList	selector _ aSymbol.	receiver _ rcvrNode.	arguments _ argList asArray.	isBuiltinOperator _ false.! !!TSendNode methodsFor: 'all'!setSelector: aSymbol receiver: rcvrNode arguments: argList isBuiltInOp: builtinFlag	selector _ aSymbol.	receiver _ rcvrNode.	arguments _ argList asArray.	isBuiltinOperator _ builtinFlag.! !!TStmtListNode methodsFor: 'all'!args	^arguments! !!TStmtListNode methodsFor: 'all'!bindVariablesIn: aDictionary	statements _ statements collect: [ :s | s bindVariablesIn: aDictionary ].! !!TStmtListNode methodsFor: 'all'!copyTree	^self class new		setArguments: arguments copy		statements: (statements collect: [ :s | s copyTree ])! !!TStmtListNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	statements do: [ :s |		level timesRepeat: [ aStream tab ].		s emitCCodeOn: aStream level: level generator: aCodeGen.		((self endsWithCloseBracket: aStream) or: [s isComment]) ifFalse: [ aStream nextPut: $; ].		aStream cr.	].! !!TStmtListNode methodsFor: 'all'!endsWithCloseBracket: aStream	"Answer true if the given stream ends in with $} character."	| ch pos |	(pos _ aStream position) > 0 ifTrue: [		aStream position: pos - 1.		ch _ aStream next.		aStream position: pos.	].	^ ch = $}" *** There's something wrong with File positioning.  If you execute the following code, it will print '(hello));;' , but it will give an error if you remove the line the says	f position: f position. | f c p1 p2 p3 | f _ FileStream fileNamed: 'test'.f nextPutAll: '(hello))'.f position: (p1 _ f position)-1.p2 _ f position.c _ f next.p3 _ f position.f position: f position.f nextPut: $;; nextPut: $;.f close.(FileStream fileNamed: 'test') contentsOfEntireFile"! !!TStmtListNode methodsFor: 'all'!inlineMethodsUsing: aDictionary	statements do: [ :s | s inlineMethodsUsing: aDictionary ].! !!TStmtListNode methodsFor: 'all'!isStmtList	^true! !!TStmtListNode methodsFor: 'all'!nodesDo: aBlock	statements do: [ :s | s nodesDo: aBlock ].		aBlock value: self.! !!TStmtListNode methodsFor: 'all'!printOn: aStream level: level	aStream nextPut: $[.	arguments size > 0 ifTrue: [		arguments do: [ :arg | aStream nextPutAll: ' :', arg ].		aStream nextPutAll: ' | '.	].	self printStatementsOn: aStream level: level.	aStream nextPut: $].! !!TStmtListNode methodsFor: 'all'!printStatementsOn: aStream level: level	statements size > 1 ifTrue: [ aStream crtab: level + 1 ].	1 to: statements size do: [ :i |		(statements at: i) printOn: aStream level: level.		i = statements size ifTrue: [			(statements size > 1) ifTrue: [				aStream crtab: level.			].		] ifFalse: [			aStream nextPut: $.; crtab: level + 1.		].	].! !!TStmtListNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!removeAssertions	| newStatements |	newStatements _ OrderedCollection new: statements size.	statements do: [ :stmt |		stmt isAssertion ifFalse: [			newStatements add: (stmt removeAssertions; yourself).		]	].	self setStatements: newStatements asArray! !!TStmtListNode methodsFor: 'all'!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		statements _ statements collect: [ :s | s replaceNodesIn: aDictionary ].		self]! !!TStmtListNode methodsFor: 'all'!setArguments: argList	arguments _ argList.! !!TStmtListNode methodsFor: 'all'!setArguments: argList statements: statementList	"Initialize this method using the given information."	arguments _ argList.	statements _ statementList.! !!TStmtListNode methodsFor: 'all'!setStatements: stmtList	statements _ stmtList asOrderedCollection.! !!TStmtListNode methodsFor: 'all'!statements	^statements! !!TVariableNode methodsFor: 'all'!bindVariablesIn: aDictionary	| newNode |	newNode _ aDictionary at: name asSymbol ifAbsent: [ ^self ].	^newNode copyTree! !!TVariableNode methodsFor: 'all'!copyTree	^self class new setName: name! !!TVariableNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	name = 'nil'		ifTrue: [ aStream nextPutAll: (aCodeGen cLiteralFor: nil) ]		ifFalse: [ aStream nextPutAll: name ].! !!TVariableNode methodsFor: 'all'!isLeaf	^true! !!TVariableNode methodsFor: 'all'!isVariable	^true! !!TVariableNode methodsFor: 'all'!name	^name! !!TVariableNode methodsFor: 'all'!printOn: aStream level: level	aStream nextPutAll: name.! !!TVariableNode methodsFor: 'all'!setName: aString	name _ aString.! !UncheckedDynamicInterpreterSimulator comment:'I am a subclass of DynamicInterpreterSimulator.  I override the various assertions defined in my superclass in order to speed up execution of the interpreter simulator.  This extra speed comes at the expense of safety, since the (many) assertions in the interpreter implementation are effectively disabled.'!!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 12/3/97 13:05'!assert: boolean! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 11/30/97 17:48'!assertIsArray: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 12/29/97 21:39'!assertIsArrayOrNil: t1 ! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsCachedBaseContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsCachedBlockContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsCachedContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsCachedMethodContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsCompiledMethod: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsCompiledMethodOrInteger: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsContextOrNull: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsIntegerObject: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalCachedTempPointer: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalInstructionIndex: t1 in: t2 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalInstructionPointer: t1 in: t2 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalStableTempPointer: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalStackOffsetInContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalStackPointer: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalTempOffset: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalTempPointer: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 12/1/97 14:52'!assertIsLegalTranslatedInstructionIndex: t1 in: t2 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 12/1/97 22:21'!assertIsLegalTranslatedInstructionPointer: t1 in: t2 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsNotNull: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsNull: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsOop: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsProcess: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsPseudoActiveContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsPseudoContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsPseudoContextOrNull: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableBaseContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableBlockContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableContextClass: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableContextOrNil: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableContextOrNilOrNull: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableContextOrNull: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableMethodContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 1/1/98 23:53'!assertIsTranslatedMethod: anObject! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 1/5/98 17:55'!assertIsValidPseudoContextAt: cp! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsWordAligned: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 12/18/97 17:59'!assertNotIntegerObject: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertStackPointerIsExternal	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertStackPointerIsInternal	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!verifyCachedContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 12/30/97 01:20'!verifyMethodCache	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!verifyStableContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!verifyStack	^ self! !UncheckedDynamicInterpreterSimulatorLSB comment:'I am a version of UncheckedDynamicInterpreterSimulator tweaked to run on little-endian machines.'!!UncheckedDynamicInterpreterSimulatorLSB methodsFor: 'initialization' stamp: 'ikp 10/27/97 23:47'!nextLongFrom: aStream	"Read a 32-bit quantity from the given (binary) stream."	| bytes |	bytes _ aStream nextInto: (ByteArray new: 4).	^ Integer		byte1: (bytes at: 1)		byte2: (bytes at: 2)		byte3: (bytes at: 3)		byte4: (bytes at: 4)! !!UncheckedDynamicInterpreterSimulatorLSB methodsFor: 'memory access' stamp: 'ikp 10/27/97 23:48'!byteAt: byteAddress	| lowBits |	lowBits _ byteAddress bitAnd: 3.	^((self longAt: byteAddress - lowBits)		bitShift: (0 - lowBits) * 8)		bitAnd: 16rFF! !!UncheckedDynamicInterpreterSimulatorLSB methodsFor: 'memory access' stamp: 'ikp 10/27/97 23:48'!byteAt: byteAddress put: byte	| longWord shift lowBits |	lowBits _ byteAddress bitAnd: 3.	longWord _ self longAt: byteAddress - lowBits.	shift _ lowBits * 8.	longWord _ longWord - (longWord bitAnd: (16rFF bitShift: shift)) + (byte bitShift: shift).	self longAt: byteAddress - lowBits put: longWord! !!UncheckedDynamicInterpreterSimulatorLSB methodsFor: 'debug support' stamp: 'ikp 10/27/97 23:48'!charsOfLong: long	^ (1 to: 4) collect:		[:i | ((long digitAt: i) between: 14 and: 126)					ifTrue: [(long digitAt: i) asCharacter]					ifFalse: [$?]]! !!UndefinedObject methodsFor: 'copying' stamp: 'sw 9/26/97 10:31'!copyRecordingIn: aDictionary	^ self! !!UndefinedObject methodsFor: 'testing'!ifNil: aBlock	"A convenient test, in conjunction with Object ifNil:"	^ aBlock value! !!UndefinedObject methodsFor: 'testing'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block for nil because I'm == nil"	^ nilBlock value! !!UndefinedObject methodsFor: 'testing'!ifNotNil: aBlock	"A convenient test, in conjunction with Object ifNotNil:"	^ self! !!UndefinedObject methodsFor: 'testing'!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am nil, so evaluate the block nilBlock"	^ nilBlock value! !!UndefinedObject methodsFor: 'dependents access'!addDependent: ignored 	"Refer to the comment in Object|dependents."	self error: 'Nil should not have dependents'! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ikp 9/26/97 14:45'!removeSubclass: aClass	"Ignored -- necessary to support disjoint class hierarchies"! !!UndefinedObject methodsFor: 'class hierarchy'!subclass: nameOfClass  "Define root (superclass = nil) of a class hierarchy"	instanceVariableNames: instVarNames	classVariableNames: classVarNames	poolDictionaries: poolDictnames	category: category	| newClass |	newClass _ Object subclass: nameOfClass  "First, define as a normal class"	instanceVariableNames: instVarNames	classVariableNames: classVarNames	poolDictionaries: poolDictnames	category: category.	Object removeSubclass: newClass.   "Then remove it from the old hierarchy"	newClass superclass: nil.	^ newClass! !I represent a Unix FileDirectory.!!UnixFileDirectory methodsFor: 'file names' stamp: 'jm 9/17/97 15:48'!fullNameFor: fileName	"Return the fully-qualified path name for the given file. Correct syntax errors in the file name."	FileDirectory splitName: fileName to: [:path :localName |		^ (path isEmpty ifFalse: [path] ifTrue: [			pathName = self pathNameDelimiter asString ifTrue: [''] ifFalse: [pathName]]),				self pathNameDelimiter asString, (self checkName: localName fixErrors: true)].! !!UnixFileDirectory methodsFor: 'private' stamp: 'jm 12/4/97 23:43'!setPathName: pathString	"Unix path names start with a leading delimiter character."	(pathString isEmpty or: [pathString first ~= self pathNameDelimiter])		ifTrue: [pathName _ self pathNameDelimiter asString, pathString]		ifFalse: [pathName _ pathString].! !!UnixFileDirectory class methodsFor: 'platform specific' stamp: 'jm 9/17/97 15:48'!pathNameDelimiter	^ $/! !UnsavableWorkspace comment:'A workspace whose window will happily close without warning when the user so requests.  Used for throwaway windows, for example, to hold help messages..  1/27/96 sw'!UpdatingStringMorph comment:'floatPrecision = 1. to round to integer.floatPrecision = .1 to round to 1 decimal place, etc.'!!UpdatingStringMorph methodsFor: 'initialization'!initialize	super initialize.	format _ #default.  "formats: #string, #default"	target _ getSelector _ putSelector _ nil.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/13/97 21:52'!floatPrecision	floatPrecision ifNil: [floatPrecision _ 1].	^ floatPrecision! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/13/97 21:52'!floatPrecision: aNumber	floatPrecision _ aNumber! !!UpdatingStringMorph methodsFor: 'accessing'!getSelector	^ getSelector! !!UpdatingStringMorph methodsFor: 'accessing'!getSelector: aSymbol	getSelector _ aSymbol.! !!UpdatingStringMorph methodsFor: 'accessing'!putSelector	^ putSelector! !!UpdatingStringMorph methodsFor: 'accessing'!putSelector: aSymbol	putSelector _ aSymbol.! !!UpdatingStringMorph methodsFor: 'accessing'!target	^ target! !!UpdatingStringMorph methodsFor: 'accessing'!target: anObject	target _ anObject.! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'sw 10/3/97 13:55'!step	| s |	hasFocus ifFalse:		["update contents, but only if user isn't editing this string"		s _ self readFromTarget.		s = contents ifFalse: [self contentsClipped: s]].! !!UpdatingStringMorph methodsFor: 'stepping'!stepTime	^ 50! !!UpdatingStringMorph methodsFor: 'formats'!useDefaultFormat	"Use the object's own printString format."	format _ #default.! !!UpdatingStringMorph methodsFor: 'formats'!useStringFormat	format _ #string.! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 11/2/97 22:05'!informTarget	| newValue |	((target ~~ nil) and: [putSelector ~~ nil]) ifTrue:		[newValue _ self valueFromContents.		newValue ifNotNil:			[target perform: putSelector with: newValue.			target isMorph ifTrue: [target changed]]]! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 10/3/97 13:55'!readFromTarget	| v |	((target == nil) or: [getSelector == nil]) ifTrue: [^ contents].	v _ target perform: getSelector.	lastValue _ v.	format = #string ifTrue: [^ v].	(format = #default and: [v isNumber]) ifTrue:		[v isInteger ifTrue: [^ v asInteger printString].		(v isKindOf: Float) ifTrue: [^ (v roundTo: self floatPrecision) printString]].	^ v printString  "default: use object's printString"! !!UpdatingStringMorph methodsFor: 'target access'!valueFromContents	"Return a new value from the current contents string."	format = #string ifTrue: [^ contents].	^ Compiler evaluate: contents! !!UpdatingStringMorph methodsFor: 'editing'!acceptContents	self informTarget.! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 11/5/97 14:40'!handlesMouseDown: evt	(owner wantsKeyboardFocusFor: self)		ifTrue:			[^ self uncoveredAt: evt cursorPoint].	^ super handlesMouseDown: evt! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'jm 10/16/97 21:14'!keyStroke: evt	"Handle a keystroke event. Accept change if enter key or Cmd-S is pressed."	| ch |	ch _ evt keyCharacter.	ch = Character backspace ifTrue: [  "backspace"		contents size > 0 ifTrue: [			self contentsClipped: (contents copyFrom: 1 to: contents size - 1)].		^ self].	(ch = $x and: [evt commandKeyPressed]) ifTrue: [  "cut"		Smalltalk clipboardText: contents.		^ self contentsClipped: ''].	(ch = $c and: [evt commandKeyPressed]) ifTrue: [  "copy"		Smalltalk clipboardText: contents.		^ self].	(ch = $v and: [evt commandKeyPressed]) ifTrue: [  "paste"		^ self contentsClipped: Smalltalk clipboardText].	((evt keyCharacter = Character enter) or:	 [(evt keyCharacter = Character cr) or:	 [evt keyCharacter = $s and: [evt commandKeyPressed]]]) ifTrue: [  "accept"		self informTarget.		evt hand newKeyboardFocus: evt hand world.		^ self].	self contentsClipped: (contents copyWith: ch).  "append the character"! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 11/3/97 02:11'!mouseDown: evt	(owner wantsKeyboardFocusFor: self) ifTrue:		[evt hand newKeyboardFocus: self]! !!URLmap methodsFor: 'linking' stamp: 'mjg 12/2/97 14:32'!linkFor: string from: peer storingTo: aList	| uString newpage |	uString _ string asUppercase.	(uString indexOfSubCollection: 'HTTP' startingAt: 1) = 1	ifTrue:		[((uString endsWith: 'GIF') or: [(uString endsWith: 'JPEG') or:			[uString endsWith: 'JPG']])		ifTrue: [^'<image src="',string,'">']		ifFalse: [^'<a href="',string,'">',string,'</a>']]	ifFalse: "Serious!! Gotta provide-a-link!!"		[newpage _ pages at: string ifAbsent: [nil].		newpage isNil ifTrue: [ "Create a new page"			newpage _ self newpage: string from: peer.].		(aList indexOf: newpage) ~= 0 ifFalse: [aList add: newpage]. "Add only if not there"		^self pageURL: newpage]! !!URLmap methodsFor: 'linking' stamp: 'mjg 11/25/97 13:23'!linkFor: string to: peer withPrefix: prefix storingTo: aList	| uString newpage |	uString _ string asUppercase.	(uString indexOfSubCollection: 'HTTP' startingAt: 1) = 1	ifTrue:		[((uString endsWith: 'GIF') or: [(uString endsWith: 'JPEG') or:			[uString endsWith: 'JPG']])		ifTrue: [^'<image src="',string,'">']		ifFalse: [^'<a href="',string,'">',string,'</a>']]	ifFalse: "Serious!! Gotta provide-a-link!!"		[newpage _ pages at: string ifAbsent: [nil].		newpage isNil ifTrue: [ "Create a new page"			newpage _ self newpage: string from: peer.].		aList add: newpage.		^'<a href="',prefix,'.',newpage coreID,'">',string,'</a>']! !!URLmap methodsFor: 'searching' stamp: 'mjg 12/3/97 09:06'!recent	| response sortedPages currentDate |	sortedPages _ pages asSortedCollection: [:a :b | a date > b date].	response _ WriteStream on: String new.	response nextPutAll: '<h2>Recent Changes</h2><ul>'. 	currentDate _ Date new.	sortedPages do: [:page |		(currentDate ~= page date)		ifTrue: [			currentDate _ page date.			response nextPutAll: '</ul><p><b>',(currentDate printString),'</b><p><ul>'.].		response nextPutAll: '<li>',(self pageURL: page),'...',(page address).].	response nextPutAll: '</ul>'. 	^response contents				! !!URLmap methodsFor: 'searching' stamp: 'mjg 12/5/97 12:21'!searchFor: aString	| hitlines response |	hitlines _ pages select: [:each | each text includesSubstring: aString caseSensitive: false].	hitlines isEmpty	ifTrue: [^aString, ' not found']	ifFalse: [		response _ WriteStream on: String new.		response nextPutAll: '<h2>Search results for ',aString,'</h2><ul>'.		hitlines do: [:each			|response nextPutAll: '<li>',(self pageURL: each),'...',(each address)].		response nextPutAll: '</ul>'.		^response contents].! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:31'!action	"Answer the receiver's 'action'."	^action! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:31'!action: anObject	"Set the receiver's instance variable 'action' to be anObject."	action := anObject! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 14:30'!at: key	"Return page of a given key."	^pages at: key ifAbsent: [nil]! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/24/97 15:54'!at: key put: anObject	"Add anObject to the pages list."	pages at: key put: anObject! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 14:30'!atID: id	"Return page of a given key."	^pages detect: [:page | page coreID = id] ifNone: [pages at: 'Front Page']! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:31'!directory	"Answer the receiver's 'directory'."	^directory! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:31'!directory: anObject	"Set the receiver's instance variable 'directory' to be anObject."	directory := anObject! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:31'!pages	"Answer the receiver's 'pages'."	^pages! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:31'!pages: anObject	"Set the receiver's instance variable 'pages' to be anObject."	pages := anObject! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 13:52'!pageURL: aPage	^'<a href="',(action name),'.',aPage coreID,'">',(aPage name),'</a>'! !!URLmap methodsFor: 'creating' stamp: 'mjg 11/26/97 12:27'!allPagesFrom: pageRef	^self allPagesFrom: pageRef for: '' "Probably won't create new pages here"! !!URLmap methodsFor: 'creating' stamp: 'mjg 12/3/97 11:25'!allPagesFrom: pageRef for: request	| formattedPage refPages allPages peer |	(request isKindOf: PWS) ifTrue: [peer _ request peerName] ifFalse: [peer_''].	formattedPage _ pageRef copy.  "Make a copy, then format the text."	refPages _ OrderedCollection new.	formattedPage formatted: (HTMLformatter swikify: (pageRef text)								linkhandler: [:link | self linkFor: link													from: peer													storingTo: refPages]).	"Now, put all referenced pages into the page"	allPages _ WriteStream on: String new.	allPages nextPutAll: '<h2>',(pageRef name),'</h2>', formattedPage formatted.	refPages do: [:page |		allPages nextPutAll: '<h2>',(page name),'</h2>'.		allPages nextPutAll: (HTMLformatter swikify: (page text)								linkhandler: [:link | self linkFor: link													from: peer													storingTo: (OrderedCollection new)]).].	formattedPage formatted: allPages contents. "Put all the pages into THE page"	^formattedPage! !!URLmap methodsFor: 'creating' stamp: 'mjg 11/25/97 16:41'!newpage: label from: peer	| newpage newfile |		newpage _ SwikiPage new. 		self at: label put: newpage. newfile _ pages size printString.		newpage address: peer.		newpage date: (Date today).		newpage coreID: newfile.		newpage name: label.		newpage file: ((ServerAction serverDirectory), 			directory, (ServerAction pathSeparator), newfile, '.1').		newpage text: 'Describe ',label,' here'.		newpage map: self.		newpage url: (action name),'.',newfile.	^newpage! !!URLmap methodsFor: 'creating' stamp: 'mjg 11/26/97 10:50'!storeID: id text: text from: peer	| page |	page _ self atID: id.	page text: text.	page address: peer.	page date: (Date today).! !!URLmap methodsFor: 'creating' stamp: 'mjg 11/26/97 10:49'!storePage: page text: text from: peer	page text: text.	page address: peer.	page date: (Date today).! !!Utilities class methodsFor: 'investigations'!inspectGlobals	"Utilities  inspectGlobals"	| associations aDict |	associations _ ((Smalltalk keys select: [:aKey | ((Smalltalk at: aKey) isKindOf: Class) not]) asSortedArray collect:		[:aKey | Smalltalk associationAt: aKey]).	aDict _ IdentityDictionary new.	associations do: [:as | aDict add: as].	aDict inspectWithLabel: 'The Globals'! !!Utilities class methodsFor: 'identification' stamp: 'dhhi 11/6/97 16:48'!authorInitials	"Answer the initials to be used to identify the current code author.  "	[AuthorInitials isEmpty] whileTrue: [self setAuthorInitials].	^ AuthorInitials! !!Utilities class methodsFor: 'identification' stamp: 'di 6/13/97 13:00'!changeStamp 	"Answer a string to be pasted into source code to mark who changed it and when."	^ self authorInitials , ' ' , Date today mmddyy, ' ',		((String streamContents: [:s | Time now print24: true on: s]) copyFrom: 1 to: 5)! !!Utilities class methodsFor: 'identification' stamp: 'di 6/13/97 13:52'!fixStamp: changeStamp 	| parts |	parts _ changeStamp findTokens: ' '.	(parts size > 0 and: [parts last first isLetter]) ifTrue:		["Put initials first in all time stamps..."		^ String streamContents:				[:s | s nextPutAll: parts last.				parts allButLast do: [:p | s space; nextPutAll: p]]].	^ changeStamp! !!Utilities class methodsFor: 'identification' stamp: 'dhhi 11/6/97 16:47'!setAuthorInitials	"Put up a dialog allowing the user to specify the author's initials.  "	self setAuthorInitials:		(FillInTheBlank request: 'Please type your initals: '					initialAnswer: AuthorInitials)! !!Utilities class methodsFor: 'identification' stamp: 'dhhi 11/6/97 16:44'!setAuthorInitials: aString	AuthorInitials _ aString! !!Utilities class methodsFor: 'support windows' stamp: 'tk 1/1/98 17:29'!commandKeyMappings	^ self class firstCommentAt: #commandKeyMappings"Lower-case command keysa	Select allb	Browse itc	Copyd	Do ite	Exchangef	Findg	Find againh	Set Search Stringi	Inspect itj	Again oncek	Set fontl	Cancelm	Implementors of itn	Senders of ito	Spawnp	Print itq	Query symbolr	Recognizers	Save (i.e. accept)u	Alignv	Pastew	Delete preceding wordx	Cuty	Swap charactersz	UndoUpper-case command keys (Hold down Cmd & Shift, or Ctrl key)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateE	Method strings containing itF	Insert 'ifFalse:'J	Again manyK	Set styleL	Outdent (move selection one tab-stop left)N	References to itR	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'W	Selectors containing itV	Paste author's initials<return>		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)esc			Select current type-inshift-delete	Forward delete characterEnclose the selection in a kind of bracket.  Each is a toggle.Control-(	Enclose within ( and ), or remove enclosing ( and )[	Enclose within [ and ], or remove enclosing [ and ]{	Enclose within { and }, or remove enclosing { and }<	Enclose within < and >, or remove enclosing < and >'	Enclose within ' and ', or remove enclosing ' and '""	Enclose within "" and "", or remove enclosing "" and ""(Double click just inside any of the above delimiters to select the text inside it.)Text Emphasis...1	10 point font2	12 point font3	18 point font  (not in base image)4	24 point font  (not in base image)5	36 point font  (not in base image)6	color, action-on-click, link to class comment, link to method, url	Brings up a menu.  To remove these properties, select	more than the active part and then use command-0.7	bold8	italic9	narrow (same as negative kern)0	plain text (resets all emphasis)-	underlined (toggles it)=	struck out (toggles it)Cmd-shift_ (aka shift -)	negative kern (letters 1 pixel closer)+		positive kern (letters 1 pixel larger spread)"!]style[(18 2010 5 107)f1b,f1,f1b,f1! !!Utilities class methodsFor: 'user interface' stamp: 'di 9/1/96'!informUser: aString during: aBlock	"Put a message above (or below if insufficient room) the cursor.	 Like informUser:while:, but end when aBlock ends.  "	(SelectionMenu labels: '') displayAt: Sensor cursorPoint		withCaption: aString during: [aBlock value]! !!Utilities class methodsFor: 'user interface' stamp: 'sw 1/22/96'!informUser: aString while: aBlock	"Put a message above (or below if insufficient room) the cursor.	 "	"Utilities informUser: 'How do you do' while: [Sensor anyButtonPressed not]"	| cp  |	cp _ Sensor cursorPoint.	(SelectionMenu labels: '') displayAt: cp				withCaption: aString				during: [[aBlock value] whileTrue]! !!Utilities class methodsFor: 'common requests' stamp: 'sw 12/12/96'!commonRequestStrings: aString	"Initialize the common request strings from aString.  "	CommonRequestStrings _ StringHolder new contents: aString! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 1/17/97'!browseRecentSubmissions	"Open up a browser on the most recent methods submitted in the image.  5/96 sw.	5/29/96 sw: fixed so the browser doesn't go all wonkie after you submit more code	: reverse the order, have most recent submissions at the top of the list		: use RecentMessageList"	"Utilities browseRecentSubmissions"	| recentMessages |	self recentMethodSubmissions size == 0 ifTrue:		[^ SelectionMenu notify: 'There are no recent submissions'].		recentMessages _ RecentSubmissions copy reversed.	RecentMessageSet openMessageList: recentMessages name: 'Recently submitted methods -- youngest first ' autoSelect: nil! !!Utilities class methodsFor: 'recent method submissions'!recentlySubmittedMessages	^ RecentSubmissions copy reversed! !!Utilities class methodsFor: 'summer97 additions' stamp: 'tk 1/3/98 22:47'!absorbUpdatesFromServer	"Go to two common servers and look for updates.  Do not bring themto the user's disk.  A file on the server called updates.list has the namesof the last N update files.  We look backwards for the first one we do nothave, and start there bringing them in.  tk 9/10/97""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""Utilities absorbUpdatesFromServer"| doc urls failed str |Cursor wait showWhile: [	urls _ self newUpdatesOn: ((Smalltalk at: #EToySystem) serverUrls collect:		[:url | url, 'updates/']).	failed _ 0.	urls do: [:this |		doc _ HTTPSocket httpGet: this accept: 'application/octet-stream'.		"check here that it worked"		doc class == String			ifTrue: [failed _ failed + 1]	"an error loading"			ifFalse: [				doc reset; text.				doc peek asciiValue = 4	"pure object file"					ifTrue: [failed _ failed + 1]	"Must be fileIn, not pure object file"					ifFalse: [						"(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."							"HTML source code not supported here yet"						ChangeSorter newChangesFromStream: doc							named: (this findTokens: '/') last]]].	].str _ 'Loaded ', (urls size - failed) printString ,' new update files.'.failed > 0 ifTrue: [str _ str, '\Could not find ' withCRs, failed printString ,' update files.'].self inform: str.! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 8/16/97 13:13'!chooseFileWithSuffix: aSuffix	"Utilities chooseFileWithSuffix: '.gif'"	| aList aName |	aList _ FileDirectory default fileNamesMatching: '*', aSuffix.	aList size > 0		ifTrue:			[aName _ (SelectionMenu selections: aList) startUpWithCaption: 'Choose a file'.			^ aName]		ifFalse:			[self inform: 'Sorry, there are no fileswhose names end with "', aSuffix, '".'.			^ nil]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 9/13/97 20:44'!classCategoriesStartingWith: aPrefix	"Answer a list of system class categories beginning with the given prefix"	"Utilities classCategoriesStartingWith: 'Files'"	^ SystemOrganization categories select:		[:aCat | (aCat asString findString:  aPrefix startingAt: 1) = 1]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 9/21/97 01:12'!extractThisVersion: list	"Pull out the part of the list that applies to this version."	| delims lines ii out eToySystem |	(eToySystem _ Smalltalk at: #EToySystem ifAbsent: [nil]) ifNil: [^ #()].	delims _ String with: Character cr with: Character linefeed.	lines _ list findTokens: delims.	ii _ lines indexOf: '#', eToySystem version.	ii = 0 ifTrue: [^ #()].	out _ OrderedCollection new.	[(ii _ ii + 1) <= lines size] whileTrue:		[(lines at: ii) first == $# ifTrue: [^ out "next version"].		(lines at: ii) first == $* ifFalse: [out addLast: (lines at: ii)]].	"keep, except comments"	^ out! !!Utilities class methodsFor: 'summer97 additions' stamp: 'di 10/20/97 20:16'!fontSizesFor: aName	| aStyle |	aStyle _ TextStyle named: aName asSymbol.	aStyle ifNil: [self halt: 'not found'].	^ aStyle fontArray collect: [:f | f height]"Utilities fontSizesFor: 'Palatino'"! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 10/2/97 14:01'!fontSizeSummary	"Utilities fontSizeSummary"	| aStream aList |	aStream _ ReadWriteStream on: ''.	aList _ Utilities knownTextStyles.	aList do:		[:aStyleName | aStream nextPutAll: aStyleName, '  ', (Utilities fontSizesFor: aStyleName) asArray storeString.		aStream cr].	UnsavableWorkspace labeled: 'Font styles and sizes '  containing: aStream contents ! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 8/6/97 11:24'!inviolateInstanceVariableNames	"Answer a list of instance variable names not to be used"	^ #()! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 8/6/97 11:23'!isLegalInstVarName: aString	"Answer whether aString is a legal instance variable name."	self flag: #noteToDan.  "Probably redundant with some central system method,?  sw 8/6/97 "	^ (Scanner isLiteralSymbol: aString) and:		[(aString includes: $:) not]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'di 10/20/97 20:22'!knownTextStyles   "Utilities knownTextStyles"	^ (TextConstants select: [:thang | thang isKindOf: TextStyle]) keys asSortedArray! !!Utilities class methodsFor: 'summer97 additions' stamp: 'tk 1/5/98 11:26'!lastUpdateNum: updatesFileStrm	"Look in the Updates file and see what the last sequence number is.  Warn the user if the version it is under is not this image's version."	| verIndex seqIndex char ver fileVer response |	verIndex _ seqIndex _ 0.	 "last # starting a line and last digit starting a line"	updatesFileStrm reset; ascii.	[char _ updatesFileStrm next.	 updatesFileStrm atEnd] whileFalse: [		char == Character cr ifTrue: [			updatesFileStrm peek == $# ifTrue: [verIndex _ updatesFileStrm position +1].			updatesFileStrm peek isDigit ifTrue: [seqIndex _ updatesFileStrm position]]].	updatesFileStrm position: seqIndex.	ver _ 0.	[char _ updatesFileStrm next.	 char isDigit 		ifTrue: [ver _ ver*10 + char digitValue.  true]		ifFalse: [false]			] whileTrue.	updatesFileStrm position: verIndex.	fileVer _ updatesFileStrm upTo: Character cr.	(Smalltalk at: #EToySystem) version = fileVer ifFalse: [		response _ (PopUpMenu labels: 'OK, Update is for latest system\Cancel update' withCRs)			startUpWithCaption: 'Update will apply to version ', fileVer, ', but this system is ',				(Smalltalk at: #EToySystem) version.		response = 1 ifFalse: [^ nil]].	"abort"	^ ver! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 8/7/97 10:11'!methodHierarchyBrowserForClass: aClass selector: sel	"Create and schedule a message set browser on all implementors of the 	currently selected message selector. Do nothing if no message is selected."	| list tab stab |	list _ OrderedCollection new.	tab _ ''.	aClass allSuperclasses reverseDo:		[:cl |		(cl includesSelector: sel) ifTrue:			[list addLast: tab , cl name, ' ', sel].		tab _ tab , '  '].	aClass allSubclassesWithLevelDo:		[:cl :level |		(cl includesSelector: sel) ifTrue:			[stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].			list addLast: tab , stab , cl name, ' ', sel]]	 	startingLevel: 0.	Smalltalk browseMessageList: list		name: 'Inheritance of ' , sel"Utilities methodHierarchyBrowserForClass: ParagraphEditor selector: #isControlActive"! !!Utilities class methodsFor: 'summer97 additions' stamp: 'jm 9/23/97 12:51'!newUpdatesOn: serverList	"Return a list of fully formed URLs of update files we do not yethave.  Go to the listed servers and look at the file 'updates.list' for thenames of the last N update files.  We look backwards for the first one wehave, and make the list from there.  tk 9/10/97"	| existing doc list out ff |	out _ OrderedCollection new.	existing _ ChangeSorter allChangeSetNames.	existing _ existing collect: [:cngSet | cngSet copyReplaceAll: '/' with: '_'].			"Replace slashes with underbars"	serverList do: [:server |		doc _ HTTPSocket httpGet: server,'updates.list' accept: 'application/octet-stream'.		"test here for server being up"		doc class == RWBinaryOrTextStream ifTrue: [			list _ doc reset; contents.	"one file name per line"			list _ self extractThisVersion: list.			list reverseDo: [:fileName |				ff _ (fileName findTokens: '/') last.	"allow subdirectories"				(existing includes: ff sansPeriodSuffix)					ifFalse: [out addFirst: server,fileName]					ifTrue: [^ out]].			^ out "need them all"].		"Server was down, try next one"].	PopUpMenu notify: 'All code update servers seem to be unavailable'.	^ out! !!Utilities class methodsFor: 'summer97 additions' stamp: 'tk 10/21/97 13:52'!objectStrmFromUpdates: fileName	"Go to the known servers and look for this file in the updates folder.  It is an auxillery file, like .morph or a .gif.  Return a RWBinaryOrTextStream on it."| urls doc |Cursor wait showWhile: [	urls _ (Smalltalk at: #EToySystem) serverUrls collect: [:url | url, 'updates/', fileName].	urls do: [:aUrl |		doc _ HTTPSocket httpGet: aUrl accept: 'application/octet-stream'.		"test here for server being up"		doc class == RWBinaryOrTextStream ifTrue: [^ doc reset]]].PopUpMenu notify: 'All update servers are unavailable, or bad file name'.^ nil! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 9/13/97 20:44'!removeMorphicClassesFromChanges	| morphicCats |	morphicCats _ self classCategoriesStartingWith: 'Morphic'.	morphicCats do:		[:cat |		(SystemOrganization superclassOrder: cat)			do: [:class | class removeFromChanges]].! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 7/31/97 17:37'!removeUserClassesFromChanges	"Remove from the current ChangeSet all user-spawned classes, which are recognized by the fact their names end in digits"	"Utiliies removeUserClassesFromChanges"	(Object withAllSubclasses select: [:c | c name endsWithDigit]) do:		[:aClass | aClass removeFromChanges]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 8/7/97 11:57'!spawnHierarchyForClass: aClass selector: aSelector        "Create and schedule a new class hierarchy browser on the requested class/selector."        | newBrowser view |        ((aClass == nil) | (aSelector == nil))  ifTrue: [^ self].        newBrowser _ HierarchyBrowser new initHierarchyForClass: aClass                        meta: aClass isMeta.        view _ BrowserView systemCategoryBrowser: newBrowser editString: nil.        Browser postOpenSuggestion: (Array with: aClass                         with: aSelector).        BrowserView openBrowserView: view                label: aClass name , ' hierarchy'"Utilities spawnHierarchyForClass: SmallInteger selector: #hash"! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 8/6/97 22:37'!temporaryTest	"Trying to see if this works." 	self halt.	"Nothing here"	"Utilities temporaryTest"! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 10/2/97 20:12'!durableChangesMenu	"Utilities durableChangesMenu"	self windowFromMenu: ScheduledControllers screenController changesMenu target: ScheduledControllers screenController title: 'Change controls'! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 10/2/97 16:15'!durableHelpMenu	"Utilities durableHelpMenu"	self windowFromMenu: ScheduledControllers screenController helpMenu target: ScheduledControllers screenController title: 'Help'! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 10/2/97 18:20'!durableOpenMenu	"Utilities durableOpenMenu"	self windowFromMenu: ScheduledControllers screenController openMenu target: ScheduledControllers screenController title: 'Openers'! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 10/2/97 20:11'!durableWindowMenu	"Utilities durableWindowMenu"	self windowFromMenu: ScheduledControllers screenController windowMenu target: ScheduledControllers screenController title: 'Window controls'! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 9/30/97 09:54'!windowFromMenu: aMenu target: aTarget title: aTitle	| n labelList colorPattern targetList selectionList |	"Utilities windowFromMenu: ScheduledControllers screenController helpMenu target: ScheduledControllers screenController title: 'Help'"	n _ aMenu selections size.	labelList _ (1 to: n) asArray  collect:		[:ind | aMenu labelString lineNumber: ind].	colorPattern _ #(lightRed lightGreen lightBlue lightYellow lightGray).				targetList _  (1 to: n) asArray  collect: [:ind | aTarget].	selectionList _ aMenu selections.	self windowMenuWithLabels:  labelList colorPattern: colorPattern targets: targetList selections: selectionList title: aTitle! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 10/2/97 23:23'!windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList title: aTitle	| aWorld n   colorList  pos delta aButton  rightmost |	aWorld _ WorldMorph new.	n _ labelList size.	colorList _  (1 to: n) asArray  collect:		[:ind | Color perform: (colorPattern at: (ind \\ colorPattern size + 1))].				pos _ 4 @ 2.	delta _ 0 @ 30.	rightmost _ 0.	1 to: labelList size do:		[:index |			aButton _ SimpleButtonMorph new.			aButton label: (labelList at: index); 				color: (colorList at: index); 				target: (targetList at: index);				actionSelector: (selectionList at: index);				position: pos.			rightmost _ rightmost max: aButton right.			pos _ pos + delta.			aWorld addMorphBack: aButton].	aWorld setProperty: #initialExtent toValue: ((rightmost @ aButton bottom) + (10@10)).	aWorld openWithTitle: aTitle! !!Utilities class methodsFor: 'vm statistics' stamp: 'ikp 1/13/98 04:30'!vmStatisticsReportString	"StringHolderView open: (StringHolder new contents:		Utilities vmStatisticsReportString) label: 'VM Statistics'"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount mcMisses mcHits icHits upTime sendCount tms tmSize |	params _ Smalltalk getVMParameters.	oldSpaceEnd			_ params at: 1.	youngSpaceEnd		_ params at: 2.	memoryEnd			_ params at: 3.	fullGCs				_ params at: 7.	fullGCTime			_ params at: 8.	incrGCs				_ params at: 9.	incrGCTime			_ params at: 10.	tenureCount			_ params at: 11.	mcMisses			_ params at: 15.	mcHits				_ params at: 16.	icHits				_ params at: 17.	upTime _ Time millisecondClockValue.	sendCount _ mcMisses + mcHits + icHits.	tms _ TranslatedMethod allInstances.	tmSize _ tms inject: 0 into: [:sum :tm | sum + (tm size * 4)].	^String streamContents: [:str |		str	nextPutAll: 'uptime			';			print: (upTime / 1000 / 60 // 60); nextPut: $h;			print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;			print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr.		str	nextPutAll: 'memory			';			nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.		str	nextPutAll:	'	old			';			nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';			print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	young		';			nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';			print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	used		';			nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';			print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	free		';			nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';			print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: 'GCs				';			nextPutAll: (fullGCs + incrGCs) asStringWithCommas;			nextPutAll: ' ('; print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); nextPutAll: 'ms between GCs)'; cr.		str	nextPutAll: '	full			';			print: fullGCs; nextPutAll: ' in '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';			print: ((fullGCTime / upTime * 100) roundTo: 1.0);			nextPutAll: '% uptime)'.		fullGCs = 0 ifFalse:			[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].		str	cr.		str	nextPutAll: '	incr		';			print: incrGCs; nextPutAll: ' in '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';			print: ((incrGCTime / upTime * 100) roundTo: 1.0);			nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.		str	nextPutAll: '	tenures		';			nextPutAll: tenureCount asStringWithCommas.		tenureCount = 0 ifFalse:			[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].		str	cr.		str	nextPutAll: 'sends			';			nextPutAll: sendCount asStringWithCommas; cr.		str	nextPutAll: '	full			';			nextPutAll: mcMisses asStringWithCommas;			nextPutAll: ' ('; print: ((mcMisses / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	m-cache	';			nextPutAll: mcHits asStringWithCommas;			nextPutAll: ' ('; print: ((mcHits / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	i-cache		';			nextPutAll: icHits asStringWithCommas;			nextPutAll: ' ('; print: ((icHits / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: 'methods			';			nextPutAll: tms size asStringWithCommas; nextPutAll: ' translated'; cr.		str	nextPutAll: '	size			';			nextPutAll: tmSize asStringWithCommas; nextPutAll: ' bytes, avg ';			print: ((tmSize / tms size) roundTo: 0.1); nextPutAll: ' bytes/method'; cr.		str	nextPutAll: '	memory		';			print: ((tmSize / youngSpaceEnd * 100) roundTo: 0.1); nextPutAll: '% of used, ';			print: ((tmSize / memoryEnd * 100) roundTo: 0.1); nextPutAll: '% of available'; cr.		]! !!VariableNode methodsFor: 'initialize-release'!name: varName index: i type: type	"Only used for initting instVar refs"	name _ varName.	self key: varName		index: i		type: type! !!VariableNode methodsFor: 'initialize-release'!name: string key: object code: byte	"Only used for initting std variables, nil, true, false, self, etc."	name _ string.	key _ object.	code _ byte! !!VariableNode methodsFor: 'initialize-release'!name: varName key: objRef index: i type: type	"Only used for initting global (litInd) variables"	name _ varName.	self key: objRef		index: i		type: type! !!VariableNode methodsFor: 'testing'!assignmentCheck: encoder at: location	(encoder cantStoreInto: name)		ifTrue: [^ location]		ifFalse: [^ -1]! !!VariableNode methodsFor: 'testing'!isTemp	^ false! !!VariableNode methodsFor: 'code generation'!emitForValue: stack on: strm	code < 256		ifTrue: 			[strm nextPut: (code = LdSuper ifTrue: [LdSelf] ifFalse: [code]).			stack push: 1]		ifFalse: 			[self emitLong: LoadLong on: strm.			stack push: 1]! !!VariableNode methodsFor: 'code generation'!emitStorePop: stack on: strm	(code between: 0 and: 7)		ifTrue: 			[strm nextPut: ShortStoP + code "short stopop inst"]		ifFalse:			[(code between: 16 and: 23)				ifTrue: [strm nextPut: ShortStoP + 8 + code - 16 "short stopop temp"]				ifFalse: [(code >= 256 and: [code \\ 256 > 63 and: [code // 256 = 4]])						ifTrue: [self emitLong: Store on: strm. strm nextPut: Pop]						ifFalse: [self emitLong: StorePop on: strm]]].	stack pop: 1! !!VariableNode methodsFor: 'code generation'!sizeForStore: encoder	self reserve: encoder.	code < 256 ifTrue: [^ 2].	(code \\ 256) <= 63 ifTrue: [^ 2].	^ 3! !!VariableNode methodsFor: 'code generation'!sizeForStorePop: encoder	self reserve: encoder.	(code < 24 and: [code noMask: 8]) ifTrue: [^ 1].	code < 256 ifTrue: [^ 2].	code \\ 256 <= 63 ifTrue: [^ 2].  "extended StorePop"	code // 256 = 1 ifTrue: [^ 3].  "dbl extended StorePopInst"	code // 256 = 4 ifTrue: [^ 4].  "dbl extended StoreLitVar , Pop"	self halt.  "Shouldn't get here"! !!VariableNode methodsFor: 'printing'!printOn: aStream indent: level 	aStream nextPutAll: name! !!VariableNode methodsFor: 'C translation'!asTranslatorNode	^TVariableNode new setName: name! !!VariableNode class methodsFor: 'class initialization'!initialize    "VariableNode initialize.  Decompiler initialize"	| encoder |	encoder _ Encoder new.	StdVariables _ Dictionary new: 16.	encoder		fillDict: StdVariables		with: VariableNode		mapping: #('self' 'thisContext' 'super' 'nil' 'false' 'true' )		to: (Array with: LdSelf with: LdThisContext with: LdSuper)				, (Array with: LdNil with: LdFalse with: LdTrue).	StdSelectors _ Dictionary new: 64.	encoder		fillDict: StdSelectors		with: SelectorNode		mapping: ((1 to: Smalltalk specialSelectorSize) collect: 							[:i | Smalltalk specialSelectorAt: i])		to: (SendPlus to: SendPlus + 31).	StdLiterals _ LiteralDictionary new: 16.	encoder		fillDict: StdLiterals		with: LiteralNode		mapping: #(-1 0 1 2 )		to: (LdMinus1 to: LdMinus1 + 3).	encoder initScopeAndLiteralTables.	NodeNil _ encoder encodeVariable: 'nil'.	NodeTrue _ encoder encodeVariable: 'true'.	NodeFalse _ encoder encodeVariable: 'false'.	NodeSelf _ encoder encodeVariable: 'self'.	NodeThisContext _ encoder encodeVariable: 'thisContext'.	NodeSuper _ encoder encodeVariable: 'super'! !!View methodsFor: 'testing'!bordersOn: otherView along: herSide 	| myBox herBox |	myBox _ self displayBox.	herBox _ otherView displayBox.	(herSide = #right and: [myBox left = herBox right])	| (herSide = #left and: [myBox right = herBox left])		ifTrue:		[^ (myBox top max: herBox top) <= (myBox bottom min: herBox bottom)].	(herSide = #bottom and: [myBox top = herBox bottom])	| (herSide = #top and: [myBox bottom = herBox top])		ifTrue:		[^ (myBox left max: herBox left) <= (myBox right min: herBox right)].	^ false! !!View methodsFor: 'testing'!containsPoint: aPoint	"Answer whether aPoint is within the receiver's display box. It is sent to 	a View's subViews by View|subViewAt: in order to determine which 	subView contains the cursor point (so that, for example, control can be 	pass down to that subView's controller)."	^ self insetDisplayBox containsPoint: aPoint! !!View methodsFor: 'deEmphasizing'!deEmphasizeForDebugger	"Overridden by StandardSystemView. This default behavior does nothing."! !!View methodsFor: 'bordering' stamp: 'di 12/4/97 08:48'!backgroundColor	Display depth <= 2 ifTrue: [^ Color white].	insideColor == nil ifFalse:		[(insideColor isMemberOf: Symbol) ifTrue:			[^ Color perform: insideColor].		^ insideColor].	superView == nil ifFalse: [^ superView backgroundColor].	^ Color white! !!View methodsFor: 'bordering' stamp: 'tk 10/21/97 12:31'!backgroundColor: aColor	Display depth = 1 ifTrue:		[(aColor ~= nil and: [aColor isTransparent not]) ifTrue:			["Avoid stipple due to attempts to match non-whites"			^ insideColor _ Color white]].	insideColor _ aColor! !!View methodsFor: 'bordering'!foregroundColor	borderColor == nil ifFalse:		[(borderColor isMemberOf: Symbol) ifTrue:			[^ Color perform: borderColor].		^ borderColor].	superView == nil ifFalse: [^ superView foregroundColor].	^ Color black! !!View methodsFor: 'clearing'!clear	"Use the border color to paint the display box (including the border, see 	View|displayBox) of the receiver."	borderColor ~= nil ifTrue: [self clear: Color black]! !!View methodsFor: 'miscellaneous'!stretchFrame: newFrameBlock startingWith: startFrame 	"Track the outline of a newFrame as long as mouse drags it.	Maintain max and min constraints throughout the drag"	| frame newFrame click |	frame _ startFrame origin extent: ((startFrame extent min: self maximumSize)											max: self minimumSize).	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	click _ false.	[click and: [Sensor noButtonPressed]] whileFalse: 		[Processor yield.		click _ click | Sensor anyButtonPressed.		newFrame _ newFrameBlock value: frame.		newFrame _ newFrame topLeft extent: ((newFrame extent min: self maximumSize)											max: self minimumSize).		newFrame = frame ifFalse:			[Display border: frame width: 2 rule: Form reverse fillColor: Color gray.			Display border: newFrame width: 2 rule: Form reverse fillColor: Color gray.			frame _ newFrame]].	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	^ frame! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 12/17/97 08:47'!computeSlopeAtMSecs: mSecs	"Private!! Find the next inflection point of this envelope and compute its target volume and the number of milliseconds until the inflection point is reached."	| t i |	((loopEndMSecs ~~ nil) and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"		t _ (points at: loopEndIndex) x + (mSecs - loopEndMSecs).		i _ self indexOfPointAfterMSecs: t startingAt: loopEndIndex.		i == nil ifTrue: [i _ points size].  "past end"		targetVol _ (points at: i) y * decayScale.		mSecsForChange _ ((points at: i) x - t) max: 0.		^ self].	mSecs < loopStartMSecs ifTrue: [  "attack phase"		i _ self indexOfPointAfterMSecs: mSecs startingAt: 1.		targetVol _ (points at: i) y.		mSecsForChange _ ((points at: i) x - mSecs) max: 0.		^ self].	"sustain and loop phase"	loopMSecs = 0 ifTrue: [^ (points at: loopEndIndex) y].  "looping on a single point"	t _ loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).	i _ self indexOfPointAfterMSecs: t startingAt: loopStartIndex.	targetVol _ (points at: i) y.	mSecsForChange _ ((points at: i) x - t) max: 0.! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 12/17/97 08:48'!updateTargetAt: mSecs	"Update the volume envelope slope and limit for my target."	self computeSlopeAtMSecs: mSecs.	mSecs = 0 ifTrue: [target initialVolume: points first y * scale].	target adjustVolumeTo: targetVol * scale overMSecs: mSecsForChange.! !!WarpBlt methodsFor: 'setup'!cellSize	^ cellSize! !!WarpBlt methodsFor: 'setup'!cellSize: s	cellSize _ s.	cellSize = 1 ifTrue: [^ self].	cellSize > 3 ifTrue:		[(self confirm:'Do you really want to averagemore than 3x3 pixels?') ifFalse: [self halt]].	colorMap _ Color colorMapIfNeededFrom: 32 to: destForm depth.! !!WarpBlt methodsFor: 'smoothing' stamp: 'di 6/24/97 00:09'!mixPix: pix sourceMap: sourceMap destMap: destMap	"Average the pixels in array pix to produce a destination pixel.	First average the RGB values either from the pixels directly,	or as supplied in the sourceMap.  Then return either the resulting	RGB value directly, or use it to index the destination color map." 	| r g b rgb nPix bitsPerColor d |	nPix _ pix size.	r _ 0. g _ 0. b _ 0.	1 to: nPix do:		[:i |   "Sum R, G, B values for each pixel"		rgb _ sourceForm depth <= 8				ifTrue: [sourceMap at: (pix at: i) + 1]				ifFalse: [sourceForm depth = 32						ifTrue: [pix at: i]						ifFalse: [self rgbMap: (pix at: i) from: 5 to: 8]].		r _ r + ((rgb bitShift: -16) bitAnd: 16rFF).		g _ g + ((rgb bitShift: -8) bitAnd: 16rFF).		b _ b + ((rgb bitShift: 0) bitAnd: 16rFF)].	destMap == nil		ifTrue: [bitsPerColor _ 3.  "just in case eg depth <= 8 and no map"				destForm depth = 16 ifTrue: [bitsPerColor _ 5].				destForm depth = 32 ifTrue: [bitsPerColor _ 8]]		ifFalse: [destMap size = 512 ifTrue: [bitsPerColor _ 3].				destMap size = 4096 ifTrue: [bitsPerColor _ 4].				destMap size = 32768 ifTrue: [bitsPerColor _ 5]].	d _ bitsPerColor - 8.	rgb _ ((r // nPix bitShift: d) bitShift: bitsPerColor*2)		+ ((g // nPix bitShift: d) bitShift: bitsPerColor)		+ ((b // nPix bitShift: d) bitShift: 0).	destMap == nil		ifTrue: [^ rgb]		ifFalse: [^ destMap at: rgb+1]! !!WarpBlt methodsFor: 'smoothing' stamp: 'di 6/24/97 00:08'!rgbMap: sourcePixel from: nBitsIn to: nBitsOut	"NOTE: This code is copied verbatim from BitBltSimulation so that it	may be removed from the system"	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."	| mask d srcPix destPix |	self inline: true.	(d _ nBitsOut - nBitsIn) > 0		ifTrue:			["Expand to more bits by zero-fill"			mask _ (1 << nBitsIn) - 1.  "Transfer mask"			srcPix _ sourcePixel << d.			mask _ mask << d.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix << d.			^ destPix + (srcPix bitAnd: mask)				 	+ (srcPix << d bitAnd: mask << nBitsOut)]		ifFalse:			["Compress to fewer bits by truncation"			d = 0 ifTrue: [^ sourcePixel].  "no compression"			sourcePixel = 0 ifTrue: [^ sourcePixel].  "always map 0 (transparent) to 0"			d _ nBitsIn - nBitsOut.			mask _ (1 << nBitsOut) - 1.  "Transfer mask"			srcPix _ sourcePixel >> d.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix >> d.			destPix _ destPix + (srcPix bitAnd: mask)					+ (srcPix >> d bitAnd: mask << nBitsOut).			destPix = 0 ifTrue: [^ 1].  "Dont fall into transparent by truncation"			^ destPix]! !!WarpBlt methodsFor: 'primitives'!copyQuad: pts toRect: destRect	self sourceQuad: pts destRect: destRect.	self warpBits! !!WarpBlt methodsFor: 'primitives'!deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments.	x1 is starting pixel, x2 is ending pixel;  assumes n >= 1"	| fixedPtOne |	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"	x2 > x1		ifTrue: [^ x2 - x1 + fixedPtOne // (n+1) + 1]		ifFalse: [x2 = x1 ifTrue: [^ 0].				^ 0 - (x1 - x2 + fixedPtOne // (n+1) + 1)]! !!WarpBlt methodsFor: 'primitives'!sourceQuad: pts destRect: aRectangle	| fixedPt1 |	sourceX _ sourceY _ 0.	self destRect: aRectangle.	fixedPt1 _ (pts at: 1) x isInteger ifTrue: [16384] ifFalse: [16384.0].	p1x _ (pts at: 1) x * fixedPt1.	p2x _ (pts at: 2) x * fixedPt1.	p3x _ (pts at: 3) x * fixedPt1.	p4x _ (pts at: 4) x * fixedPt1.	p1y _ (pts at: 1) y * fixedPt1.	p2y _ (pts at: 2) y * fixedPt1.	p3y _ (pts at: 3) y * fixedPt1.	p4y _ (pts at: 4) y * fixedPt1.	p1z _ p2z _ p3z _ p4z _ 16384.  "z-warp ignored for now"! !!WarpBlt methodsFor: 'primitives'!startFrom: x1 to: x2 offset: sumOfDeltas	"Utility routine for computing Warp increments."	x2 >= x1		ifTrue: [^ x1]		ifFalse: [^ x2 - sumOfDeltas]! !!WarpBlt methodsFor: 'primitives'!warpBits	"Move those pixels!!"	self warpBitsSmoothing: cellSize		sourceMap: (Color colorMapIfNeededFrom: sourceForm depth to: 32).! !!WarpBlt methodsFor: 'primitives'!warpBitsSmoothing: n sourceMap: sourceMap	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix nSteps |	<primitive: 147>	(width < 1) | (height < 1) ifTrue: [^ self].	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"	n > 1 ifTrue:		[(destForm depth < 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFail].		pix _ Array new: n*n].	nSteps _ height-1 max: 1.	deltaP12 _ (self deltaFrom: p1x to: p2x nSteps: nSteps)			@ (self deltaFrom: p1y to: p2y nSteps: nSteps).	pA _ (self startFrom: p1x to: p2x offset: nSteps*deltaP12 x)		@ (self startFrom: p1y to: p2y offset: nSteps*deltaP12 y).	deltaP43 _ (self deltaFrom: p4x to: p3x nSteps: nSteps)			@ (self deltaFrom: p4y to: p3y nSteps: nSteps).	pB _ (self startFrom: p4x to: p3x offset: nSteps*deltaP43 x)		@ (self startFrom: p4y to: p3y offset: nSteps*deltaP43 y).	picker _ BitBlt bitPeekerFromForm: sourceForm.	poker _ BitBlt bitPokerToForm: destForm.	poker clipRect: self clipRect.	nSteps _ width-1 max: 1.	destY to: destY+height-1 do:		[:y |		deltaPAB _ (self deltaFrom: pA x to: pB x nSteps: nSteps)				@ (self deltaFrom: pA y to: pB y nSteps: nSteps).		sp _ (self startFrom: pA x to: pB x offset: nSteps*deltaPAB x)			@ (self startFrom: pA y to: pB y offset: nSteps*deltaPAB x).		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[Transcript cr; print: sp // fixedPtOne asPoint.				poker pixelAt: x@y						put: (picker pixelAt: sp // fixedPtOne asPoint)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPtOne asPoint)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp _ sp + deltaPAB].		pA _ pA + deltaP12.		pB _ pB + deltaP43]! !!WarpBlt class methodsFor: 'initialization'!toForm: destinationForm	"Default cell size is 1 (no pixel smoothing)"	^ (super toForm: destinationForm) cellSize: 1! !!WarpBlt class methodsFor: 'examples'!test1   "Display restoreAfter: [WarpBlt test1]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p ext |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext)]! !!WarpBlt class methodsFor: 'examples'!test12   "Display restoreAfter: [WarpBlt test12]"	"Just like test1, but comparing smooth to non-smooth warps"	| warp pts r1 p0 p ext warp2 |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		cellSize: 2;  "installs a colormap"		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	warp2 _ (self toForm: Display)		clipRect: ((0@0 extent: r1 extent*5) translateBy: 200@0);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translateBy: 200@0).		]! !!WarpBlt class methodsFor: 'examples'!test3   "Display restoreAfter: [WarpBlt test3]"	"The Squeak Release Mandala - 9/23/96 di"	"Move the mouse near the center of the square.	Up and down affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box map d t |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	"Make a color map that steps through the color space"	map _ (Display depth > 8		ifTrue: ["RGB is a bit messy..."				d _ Display depth = 16 ifTrue: [5] ifFalse: [8].				(1 to: 512) collect: [:i | t _ i bitAnd: 511.					((t bitAnd: 16r7) bitShift: d-3)					+ ((t bitAnd: 16r38) bitShift: d-3*2)					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]		ifFalse: ["otherwise simple"				1 to: (1 bitShift: Display depth)])			as: Bitmap.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		colorMap: map;		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !!WarpBlt class methodsFor: 'examples'!test4   "Display restoreAfter: [WarpBlt test4]"	"The Squeak Release Mandala - 9/23/96 di	This version does smoothing"	"Move the mouse near the center ofhe square.	Up and dn affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !!WarpBlt class methodsFor: 'examples'!test5   "Display restoreAfter: [WarpBlt test5]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle fromUser.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		cellSize: 1;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		warp copyQuad: pts toRect: (r1 translateBy: r1 width@0)]! !!WarpBlt class methodsFor: 'form rotation' stamp: 'jm 11/16/97 10:50'!rotate: srcForm degrees: angleInDegrees center: aPoint scaleBy: scalePoint smoothing: cellSize	"Rotate the given Form the given number of degrees about the given center and scale its width and height by x and y of the given scale point. Smooth using the given cell size, an integer between 1 and 3, where 1 means no smoothing. Return a pair where the first element is the rotated Form and the second is the position offset required to align the center of the rotated Form with that of the original. Note that the dimensions of the resulting Form generally differ from those of the original."	| srcRect center radians dstOrigin dstCorner p dstRect inverseScale quad dstForm newCenter warpSrc |	srcRect _ srcForm boundingBox.	center _ srcRect center.	radians _ angleInDegrees degreesToRadians.	dstOrigin _ dstCorner _ center.	srcRect corners do: [:corner |		"find the limits of a rectangle that just encloses the rotated		 original; in general, this rectangle will be larger than the		 original (e.g., consider a square rotated by 45 degrees)"		p _ ((corner - center) scaleBy: scalePoint) + center.		p _ (p rotateBy: radians about: center) rounded.		dstOrigin _ dstOrigin min: p.		dstCorner _ dstCorner max: p].	"rotate the enclosing rectangle back to get the source quadrilateral"	dstRect _ dstOrigin corner: dstCorner.	inverseScale _ (1.0 / scalePoint x)@(1.0 / scalePoint y).	quad _ dstRect innerCorners collect: [:corner |		p _ corner rotateBy: radians negated about: center.		((p - center) scaleBy: inverseScale) + center].	"make a Form to hold the result and do the rotation"	warpSrc _ srcForm.	(srcForm isKindOf: ColorForm)		ifTrue: [			cellSize > 1				ifTrue: [					warpSrc _ Form extent: srcForm extent depth: 16.					srcForm displayOn: warpSrc.					dstForm _ Form extent: dstRect extent depth: 16]  "use 16-bit depth to allow smoothing"				ifFalse: [					dstForm _ srcForm class extent: dstRect extent depth: srcForm depth]]		ifFalse: [			dstForm _ srcForm class extent: dstRect extent depth: srcForm depth].	(WarpBlt toForm: dstForm)		sourceForm: warpSrc;		colorMap: (dstForm colormapIfNeededForDepth: warpSrc depth);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form paint;		copyQuad: quad toRect: dstForm boundingBox.	(dstForm isKindOf: ColorForm) ifTrue: [dstForm colors: srcForm colors copy].	newCenter _ (center rotateBy: radians about: aPoint) truncated.	^ Array with: dstForm with: dstRect origin + (newCenter - center)! !!Wavelets methodsFor: 'all' stamp: 'di 6/21/97 08:15'!at: n at: k	| coeffs |	coeffs _ filters at: n.	^ coeffs at: n + k + 1! !!Wavelets methodsFor: 'all' stamp: 'di 6/21/97 08:15'!at: n at: k put: v	| coeffs |	coeffs _ filters at: n.	coeffs at: n + k + 1 put: v! !!Wavelets methodsFor: 'all' stamp: 'di 6/21/97 08:26'!initFilters    "FilterArray newFromTable"| h |h _ self new: 10.self hAt: 1 at: -1 put: 1.0 / 2.0 sqrt.self hAt: 1 at: 0 put: 1.0 / 2.0 sqrt.self hAt: 2 at: -2 put: 0.4829629131445341.self hAt: 2 at: -1 put: 0.8365163037378077.self hAt: 2 at: 0 put: 0.2241438680420134.self hAt: 2 at: 1 put: -0.1294095225512603.self hAt: 3 at: -3 put: 0.3326705529500825.self hAt: 3 at: -2 put: 0.8068915093110924.self hAt: 3 at: -1 put: 0.4598775021184914.self hAt: 3 at: 0 put: -0.1350110200102546.self hAt: 3 at: 1 put: -0.0854412738820267.self hAt: 3 at: 2 put: 0.0352262918857095.self hAt: 4 at: -4 put: 0.2303778133088964.self hAt: 4 at: -3 put: 0.7148465705529154.self hAt: 4 at: -2 put: 0.6308807679398587.self hAt: 4 at: -1 put: -0.0279837694168599.self hAt: 4 at: 0 put: -0.1870348117190931.self hAt: 4 at: 1 put: 0.0308413818355607.self hAt: 4 at: 2 put: 0.0328830116668852.self hAt: 4 at: 3 put: -0.0105974017850690.self hAt: 5 at: -5 put: 0.1601023979741929.self hAt: 5 at: -4 put: 0.6038292697971895.self hAt: 5 at: -3 put: 0.7243085284377726.self hAt: 5 at: -2 put: 0.1384281459013203.self hAt: 5 at: -1 put: -0.2422948870663823.self hAt: 5 at: 0 put: -0.0322448695846381.self hAt: 5 at: 1 put: 0.0775714938400459.self hAt: 5 at: 2 put: -0.0062414902127983.self hAt: 5 at: 3 put: -0.0125807519990820.self hAt: 5 at: 4 put: 0.0033357252854738.self hAt: 6 at: -6 put: 0.1115407433501095.self hAt: 6 at: -5 put: 0.4946238903984533.self hAt: 6 at: -4 put: 0.7511339080210959.self hAt: 6 at: -3 put: 0.3152503517091982.self hAt: 6 at: -2 put: -0.2262646939654400.self hAt: 6 at: -1 put: -0.1297668675672625.self hAt: 6 at: 0 put: 0.0975016055873225.self hAt: 6 at: 1 put: 0.0275228655303053.self hAt: 6 at: 2 put: -0.0315820393174862.self hAt: 6 at: 3 put: 0.0005538422011614.self hAt: 6 at: 4 put: 0.0047772575109455.self hAt: 6 at: 5 put: -0.0010773010853085.self hAt: 7 at: -7 put: 0.0778520540850037.self hAt: 7 at: -6 put: 0.3965393194818912.self hAt: 7 at: -5 put: 0.7291320908461957.self hAt: 7 at: -4 put: 0.4697822874051889.self hAt: 7 at: -3 put: -0.1439060039285212.self hAt: 7 at: -2 put: -0.2240361849938412.self hAt: 7 at: -1 put: 0.0713092192668272.self hAt: 7 at: 0 put: 0.0806126091510774.self hAt: 7 at: 1 put: -0.0380299369350104.self hAt: 7 at: 2 put: -0.0165745416306655.self hAt: 7 at: 3 put: 0.0125509985560986.self hAt: 7 at: 4 put: 0.0004295779729214.self hAt: 7 at: 5 put: -0.0018016407040473.self hAt: 7 at: 6 put: 0.0003537137999745.self hAt: 8 at: -8 put: 0.0544158422431072.self hAt: 8 at: -7 put: 0.3128715909143166.self hAt: 8 at: -6 put: 0.6756307362973195.self hAt: 8 at: -5 put: 0.5853546836542159.self hAt: 8 at: -4 put: -0.0158291052563823.self hAt: 8 at: -3 put: -0.2840155429615824.self hAt: 8 at: -2 put: 0.0004724845739124.self hAt: 8 at: -1 put: 0.1287474266204893.self hAt: 8 at: 0 put: -0.0173693010018090.self hAt: 8 at: 1 put: -0.0440882539307971.self hAt: 8 at: 2 put: 0.0139810279174001.self hAt: 8 at: 3 put: 0.0087460940474065.self hAt: 8 at: 4 put: -0.0048703529934520.self hAt: 8 at: 5 put: -0.0003917403733770.self hAt: 8 at: 6 put: 0.0006754494064506.self hAt: 8 at: 7 put: -0.0001174767841248.self hAt: 9 at: -9 put: 0.0380779473638778.self hAt: 9 at: -8 put: 0.2438346746125858.self hAt: 9 at: -7 put: 0.6048231236900955.self hAt: 9 at: -6 put: 0.6572880780512736.self hAt: 9 at: -5 put: 0.1331973858249883.self hAt: 9 at: -4 put: -0.2932737832791663.self hAt: 9 at: -3 put: -0.0968407832229492.self hAt: 9 at: -2 put: 0.1485407493381256.self hAt: 9 at: -1 put: 0.0307256814793385.self hAt: 9 at: 0 put: -0.0676328290613279.self hAt: 9 at: 1 put: 0.0002509471148340.self hAt: 9 at: 2 put: 0.0223616621236798.self hAt: 9 at: 3 put: -0.0047232047577518.self hAt: 9 at: 4 put: -0.0042815036824635.self hAt: 9 at: 5 put: 0.0018476468830563.self hAt: 9 at: 6 put: 0.0002303857635232.self hAt: 9 at: 7 put: -0.0002519631889427.self hAt: 9 at: 8 put: 0.0000393473203163.self hAt: 10 at: -10 put: 0.0266700579005473.self hAt: 10 at: -9 put: 0.1881768000776347.self hAt: 10 at: -8 put: 0.5272011889315757.self hAt: 10 at: -7 put: 0.6884590394534363.self hAt: 10 at: -6 put: 0.2811723436605715.self hAt: 10 at: -5 put: -0.2498464243271598.self hAt: 10 at: -4 put: -0.1959462743772862.self hAt: 10 at: -3 put: 0.1273693403357541.self hAt: 10 at: -2 put: 0.0930573646035547.self hAt: 10 at: -1 put: -0.0713941471663501.self hAt: 10 at: 0 put: -0.0294575368218399.self hAt: 10 at: 1 put: 0.0332126740593612.self hAt: 10 at: 2 put: 0.0036065535669870.self hAt: 10 at: 3 put: -0.0107331754833007.self hAt: 10 at: 4 put: 0.0013953517470688.self hAt: 10 at: 5 put: 0.0019924052951925.self hAt: 10 at: 6 put: -0.0006858566949564.self hAt: 10 at: 7 put: -0.0001164668551285.self hAt: 10 at: 8 put: 0.0000935886703202.self hAt: 10 at: 9 put: -0.0000132642028945.^ h! !!Wavelets methodsFor: 'all' stamp: 'di 6/21/97 08:13'!setFilters: anArray	filters _ anArray! !!Wavelets class methodsFor: 'all' stamp: 'di 6/23/97 22:20'!loriSaysComputer	"Return the samples array for Lori saying the word 'Computer'."	^ #(128 128 128 127 127 127 127 127 127 127 126 126 126 126 126 126 126 125 125 125 124 124 124 124 124 124 124 125 124 124 124 124 124 124 124 124 124 124 124 124 124 125 125 125 126 125 125 124 124 124 125 124 124 125 124 126 126 126 126 126 127 126 126 126 126 126 126 127 127 127 127 127 128 128 128 128 128 128 127 127 128 127 127 127 127 127 127 127 127 127 127 126 127 127 127 127 126 127 127 126 127 126 126 125 125 126 125 124 124 124 125 125 125 125 125 125 125 125 125 125 124 124 124 125 124 124 125 124 125 126 126 126 127 125 127 126 126 126 126 126 127 128 127 127 127 127 128 128 128 129 128 128 128 129 128 130 128 129 129 129 129 129 129 129 129 129 130 129 129 129 128 129 129 129 130 129 129 129 128 129 129 129 128 128 128 128 128 129 129 129 129 129 129 129 128 128 128 127 127 128 127 127 128 127 128 128 128 128 128 128 127 127 127 126 126 126 127 126 127 127 127 127 127 127 128 128 127 127 127 127 127 127 127 127 127 127 128 128 128 128 127 128 128 129 129 128 129 129 128 129 129 129 129 129 128 129 128 127 128 127 128 128 128 128 128 128 128 127 127 127 127 126 126 127 126 127 127 127 128 128 128 128 127 127 128 127 127 127 127 127 127 126 126 126 125 126 126 126 126 125 125 125 125 125 125 126 125 125 124 124 124 124 125 125 125 125 125 125 125 125 126 126 126 126 126 126 126 126 126 127 126 127 126 126 127 127 128 128 128 129 129 129 129 128 128 128 128 128 128 128 127 128 128 129 129 128 129 129 128 129 128 128 128 128 128 128 129 128 129 128 129 129 129 129 129 128 128 128 129 129 128 128 128 128 128 128 128 128 128 127 128 128 128 128 127 128 128 128 128 127 127 127 127 127 127 127 126 127 127 126 127 126 126 127 127 126 127 126 126 126 126 127 127 127 127 128 127 128 128 128 129 128 128 128 129 128 129 129 129 129 129 129 130 130 130 130 130 130 131 130 130 130 130 131 131 131 130 130 130 130 130 131 130 130 130 130 129 129 129 129 128 129 129 129 128 128 127 127 128 127 127 127 126 126 126 126 126 126 126 126 125 125 124 123 123 123 123 123 123 122 122 122 122 122 122 122 122 122 122 122 122 122 122 122 123 123 123 124 124 124 125 126 126 126 125 125 126 126 126 126 126 127 126 127 127 127 127 128 128 128 128 128 127 128 128 128 128 128 128 128 128 128 128 128 128 127 127 127 127 127 128 127 127 127 128 127 127 126 126 126 126 126 126 126 126 126 127 127 127 127 126 126 126 126 125 125 125 125 125 125 125 125 125 125 125 125 125 125 124 124 124 124 124 125 124 124 123 124 124 124 124 124 124 124 125 124 124 124 124 124 125 125 125 125 124 125 124 126 125 125 126 126 126 126 127 127 127 127 127 127 126 125 124 125 120 126 89 143 92 156 113 147 134 129 136 112 136 110 132 116 131 121 137 125 115 134 112 135 122 134 126 125 133 115 136 121 118 134 120 134 115 128 119 127 121 127 122 129 109 132 116 126 135 122 103 105 118 112 126 122 136 123 131 120 126 114 126 113 128 122 132 123 132 128 131 130 130 131 130 129 130 132 133 134 130 131 132 131 127 127 132 133 134 125 134 128 135 126 133 126 131 127 129 132 130 127 130 132 134 132 128 125 133 128 133 127 124 130 114 133 118 124 124 126 124 128 128 128 125 128 129 128 126 128 122 125 121 125 127 130 130 127 129 128 130 125 133 127 135 126 131 130 130 127 132 129 131 129 126 134 126 132 129 128 133 127 126 130 129 132 128 130 132 123 129 125 128 126 133 127 134 133 127 130 126 128 127 131 127 133 125 129 130 130 127 128 128 128 133 128 132 129 129 131 131 125 133 126 130 128 131 127 128 125 128 127 125 130 129 128 131 128 125 129 126 126 126 127 126 126 124 126 124 125 127 125 126 128 128 128 129 129 127 128 127 130 128 127 130 126 129 127 130 126 131 124 125 127 125 129 123 126 125 124 122 123 125 125 130 128 131 132 132 135 135 135 134 134 134 130 128 125 119 120 114 117 112 113 109 111 110 116 119 125 135 138 144 151 151 155 159 154 148 146 133 119 115 101 97 97 92 93 93 98 100 110 114 124 133 141 149 158 162 171 171 169 158 148 133 111 104 92 87 89 92 92 94 101 104 110 121 124 132 140 144 153 163 167 168 169 159 148 133 117 108 99 95 97 98 101 103 106 107 112 116 121 125 131 139 142 151 159 162 168 163 159 150 136 124 114 107 101 100 98 98 99 99 102 106 111 118 122 132 142 148 160 167 174 175 172 168 154 140 125 109 97 86 80 75 78 84 90 102 113 122 131 141 150 155 163 171 175 178 174 168 154 137 122 103 92 79 75 68 76 86 94 108 117 129 134 144 151 157 162 167 172 174 173 168 156 137 126 106 96 84 76 74 73 87 93 107 115 124 132 136 146 150 155 160 167 172 173 170 165 145 132 113 100 92 79 78 72 82 89 99 111 117 125 129 139 147 153 159 164 170 173 172 168 156 139 126 105 96 85 79 74 72 83 87 100 109 118 125 131 141 147 154 158 163 166 170 167 163 152 136 123 107 97 88 82 77 77 86 92 104 114 122 128 135 143 147 152 156 160 162 165 166 162 155 143 130 115 104 96 88 83 82 85 92 100 110 117 123 128 134 142 144 150 154 157 162 163 164 160 152 140 126 115 103 94 88 84 84 88 93 101 111 116 123 128 136 141 145 152 155 157 159 160 159 154 147 132 122 111 101 96 91 92 90 95 100 107 115 118 124 126 132 136 139 144 145 148 149 151 153 150 145 137 132 127 121 116 110 107 103 102 105 106 109 112 115 119 124 130 132 137 140 142 145 149 150 150 150 147 143 139 135 129 124 118 111 107 103 106 104 106 110 112 119 122 127 129 133 135 137 140 138 140 139 139 140 140 139 137 135 133 128 127 122 117 115 112 109 106 109 110 112 114 116 119 122 126 127 129 132 137 138 141 142 142 141 140 139 138 135 130 127 124 122 120 118 117 116 115 114 116 115 117 119 121 125 128 133 135 140 140 140 139 140 142 139 136 135 133 130 127 127 126 124 122 120 120 121 122 121 124 126 126 126 128 131 131 131 132 132 133 133 133 133 132 132 129 127 127 125 125 122 120 121 121 122 122 124 125 125 125 124 128 129 130 129 131 129 129 129 127 127 126 124 125 124 122 124 124 125 125 124 123 123 125 124 126 126 127 126 128 129 129 130 130 130 129 128 130 129 127 125 125 124 124 127 126 126 126 124 126 125 127 127 127 128 128 131 131 131 131 132 131 131 131 129 129 126 127 125 127 126 125 125 125 125 124 124 124 124 124 124 126 126 128 127 127 127 127 128 128 128 126 127 125 125 126 126 125 123 123 120 121 121 122 121 123 124 124 126 126 127 128 129 130 130 129 129 130 129 130 129 128 127 126 125 125 124 123 125 124 124 125 125 125 126 127 128 129 131 131 131 132 131 131 131 131 132 130 130 129 129 128 128 129 127 127 127 127 128 127 129 128 129 129 118 124 125 129 116 109 143 109 137 134 134 129 127 125 124 125 122 120 122 123 121 96 137 112 98 152 107 134 134 125 128 127 126 121 124 120 125 122 118 127 122 126 127 108 130 111 129 112 141 129 120 132 131 122 131 120 131 131 122 131 126 126 133 130 132 138 124 135 137 133 123 120 127 133 120 143 118 134 118 133 125 125 128 126 139 126 134 128 131 131 133 129 131 132 126 142 135 130 132 125 116 129 127 132 137 125 135 114 123 112 122 128 126 134 125 135 126 128 126 127 128 135 128 138 123 133 116 129 117 136 125 130 125 140 124 134 122 129 115 136 110 130 127 128 131 140 131 131 125 132 121 116 118 127 126 140 149 150 139 137 125 112 117 112 121 128 118 134 121 124 127 124 139 133 128 128 124 134 121 133 114 120 128 137 135 120 124 121 129 132 126 127 121 130 128 131 126 134 117 123 128 128 137 141 129 126 125 119 119 122 124 120 136 129 137 127 131 126 124 125 126 132 131 130 127 120 117 121 114 137 142 136 133 128 124 133 124 118 113 122 127 122 129 127 128 126 131 128 121 126 113 122 119 132 117 133 128 131 139 130 150 126 126 116 122 113 125 127 134 131 133 127 120 126 117 119 121 132 125 118 139 132 133 128 132 123 133 120 127 116 127 116 120 119 127 118 127 120 130 120 128 111 117 119 126 118 123 123 124 116 131 130 133 131 132 131 124 119 118 112 127 107 117 107 119 110 117 120 112 115 127 129 132 141 152 141 147 143 136 133 132 128 122 109 115 97 108 100 101 106 115 117 123 129 139 132 138 149 163 160 169 155 155 137 139 116 110 93 97 81 90 86 94 104 114 123 136 142 145 150 167 167 169 180 159 155 135 123 112 87 86 76 78 79 84 93 108 119 133 138 153 163 170 178 181 180 180 154 150 122 107 89 74 70 65 70 82 89 106 121 133 146 157 167 177 183 194 187 186 159 153 112 103 75 67 58 62 67 77 100 111 129 142 155 167 178 192 198 198 197 183 160 137 104 82 59 55 48 59 70 88 108 120 141 146 157 162 177 184 201 203 196 181 154 127 95 68 56 43 51 62 71 97 107 129 133 147 156 159 179 190 218 203 213 165 156 104 81 62 36 45 53 64 95 104 139 132 148 142 140 145 155 181 205 188 222 166 165 120 89 75 44 48 57 56 101 100 149 139 153 154 128 137 135 147 179 201 191 225 153 180 101 87 79 28 63 57 74 112 111 159 140 148 147 122 129 134 151 192 187 209 214 125 198 59 95 53 40 63 58 91 122 108 166 132 148 133 121 126 125 154 196 170 212 201 117 199 44 107 38 50 61 62 97 126 113 166 137 141 136 113 128 122 163 204 161 224 191 116 191 30 115 20 66 65 73 104 150 119 175 146 140 137 105 132 115 161 213 150 217 203 95 207 22 123 28 64 84 74 114 159 131 167 165 122 144 88 126 108 152 220 141 232 190 115 187 28 119 25 62 86 81 112 167 129 166 157 117 134 78 123 106 149 214 147 213 205 90 196 27 107 42 56 93 88 112 167 135 147 166 97 132 79 115 110 155 213 150 219 193 104 176 34 102 38 59 93 94 114 168 145 142 172 91 128 72 117 110 159 221 163 220 204 103 171 40 82 49 49 93 103 117 169 162 131 179 92 115 88 98 117 162 219 173 242 167 137 138 29 87 31 54 92 113 118 177 160 138 167 93 108 84 90 117 148 212 176 218 191 115 146 40 71 47 52 89 117 125 164 173 128 163 100 97 91 92 113 159 208 154 219 181 100 153 40 72 62 59 95 129 121 166 174 116 161 103 78 98 91 109 162 210 168 212 206 94 160 52 56 72 58 92 128 135 152 182 119 152 108 81 95 100 111 164 229 151 233 191 97 151 48 58 64 73 81 146 128 155 183 112 144 108 76 88 111 106 169 233 149 225 185 88 139 49 51 63 79 82 152 138 151 186 117 130 109 71 79 111 111 168 243 162 232 181 100 125 47 50 56 86 79 161 141 156 183 125 120 107 77 74 117 119 173 242 169 232 171 107 116 46 51 59 89 84 164 146 159 179 131 113 103 77 70 113 124 173 240 175 226 173 102 111 45 49 56 94 87 160 155 158 172 136 106 97 77 67 110 125 170 239 183 206 190 90 104 53 42 50 100 95 148 172 156 166 138 102 90 81 63 108 128 165 236 190 195 200 90 97 61 44 48 106 104 144 181 163 164 144 106 86 84 65 109 127 168 225 208 182 211 95 92 67 44 48 103 117 133 191 165 161 147 108 80 84 65 100 123 159 198 240 167 208 137 72 83 46 52 80 133 113 183 170 152 152 120 79 85 72 83 119 153 171 240 191 174 189 66 81 59 55 53 137 117 152 190 151 147 129 90 75 86 78 110 145 161 202 229 149 201 109 72 78 66 54 111 136 121 187 157 143 138 121 66 105 78 94 137 153 167 231 185 158 187 72 84 82 66 73 138 116 144 175 143 138 144 101 86 112 79 111 137 145 157 218 159 165 166 82 108 83 88 78 129 107 131 149 132 139 132 121 109 118 104 124 128 145 135 173 128 140 135 114 126 119 138 104 138 110 119 100 117 104 118 139 131 145 143 144 122 128 92 105 100 111 115 146 145 160 160 143 141 117 114 100 105 102 127 123 139 144 142 134 133 112 105 104 97 107 115 127 139 155 143 157 141 132 130 117 118 119 130 128 140 132 137 126 119 109 112 103 115 118 127 130 137 127 125 124 111 125 126 118 148 137 148 142 150 127 132 120 110 110 111 115 113 128 124 136 123 129 127 116 117 115 113 113 123 120 137 138 158 144 141 146 126 128 118 124 108 129 121 128 125 135 125 126 129 126 116 127 115 113 125 107 123 121 131 142 177 149 155 168 118 133 115 107 84 131 104 125 140 148 134 146 139 117 120 103 95 96 103 100 126 138 151 193 189 143 188 107 105 89 101 63 125 128 125 165 155 145 128 139 89 101 89 86 97 115 112 127 147 141 172 210 126 172 153 70 113 95 88 89 160 111 157 162 139 128 126 108 88 101 82 107 102 128 125 139 159 181 215 136 181 144 64 115 79 90 96 160 119 165 170 136 134 117 109 85 105 82 108 114 128 131 142 155 174 220 126 166 148 53 115 90 94 101 165 124 146 178 123 130 116 109 83 120 97 95 126 112 112 132 138 133 204 208 107 192 112 59 110 99 82 107 179 117 166 170 123 120 119 102 81 121 95 103 128 117 103 132 131 123 179 213 167 145 187 52 91 107 67 114 154 167 136 189 142 103 116 96 92 92 122 115 128 136 116 110 121 121 125 154 206 220 130 183 114 39 110 84 94 132 187 150 153 179 99 104 99 90 87 105 137 120 145 128 112 108 111 121 125 156 198 215 121 141 133 15 104 104 99 151 177 163 126 161 93 75 99 78 103 123 154 146 148 144 98 102 98 96 117 139 162 194 221 126 132 140 29 103 121 105 148 171 163 126 145 105 75 113 103 122 138 154 153 135 140 96 99 110 94 121 136 146 171 196 197 114 132 118 39 119 124 115 149 165 151 108 135 114 80 124 123 121 132 144 139 121 137 111 94 117 101 113 123 125 145 157 187 178 103 145 97 58 131 112 120 153 156 143 119 137 103 80 121 119 119 139 149 147 135 146 107 87 112 83 93 122 120 132 166 182 188 174 113 128 92 79 135 116 136 161 142 138 119 109 97 97 125 130 136 149 142 145 129 116 113 96 95 99 113 126 132 137 138 146 155 169 175 123 131 135 72 118 136 107 139 142 131 121 123 122 103 119 130 122 131 136 132 126 124 125 116 116 125 106 113 125 120 127 131 132 129 137 163 174 139 128 133 87 101 132 114 132 146 132 122 121 122 107 112 131 129 130 139 135 131 133 129 124 120 116 109 120 125 120 124 121 115 125 148 156 172 158 135 140 108 109 129 120 128 133 123 118 119 123 121 123 134 135 130 130 125 124 128 121 119 111 117 114 112 126 116 115 135 141 153 175 159 125 138 119 100 128 125 116 129 127 117 119 122 125 119 126 124 114 118 118 118 118 122 121 122 124 122 122 125 139 149 153 161 135 124 132 118 127 140 132 129 128 126 115 111 120 120 122 130 132 123 119 126 118 117 126 121 122 130 134 142 150 160 155 145 143 128 118 124 123 130 133 128 127 122 116 116 117 119 117 119 125 119 125 132 123 124 130 122 124 133 140 144 142 148 138 130 131 126 130 129 130 131 124 125 120 114 117 117 110 115 118 117 123 124 125 124 124 130 130 135 146 144 141 140 134 134 132 130 132 128 128 128 125 121 117 119 114 115 119 118 120 120 120 121 123 123 123 125 125 128 130 126 127 130 132 135 136 137 135 127 126 124 117 119 121 114 116 117 109 109 110 109 111 118 122 124 130 126 123 122 120 118 120 122 120 125 128 128 132 132 129 127 125 125 123 123 128 123 123 125 117 115 117 116 116 121 123 124 130 131 129 129 130 129 129 131 131 131 132 133 133 132 133 133 130 130 134 132 133 133 132 130 128 127 127 126 127 132 128 129 134 130 128 129 128 129 131 134 134 133 134 131 130 131 130 129 130 131 130 131 133 128 128 129 125 124 126 125 124 127 127 128 128 128 125 126 127 125 126 128 127 127 128 127 127 127 126 127 125 126 125 126 126 127 126 127 126 126 128 125 125 126 123 126 127 126 126 127 126 127 129 128 129 128 128 131 127 128 128 124 124 124 124 123 124 127 124 125 127 126 127 129 129 128 128 127 126 125 126 126 124 125 126 126 128 128 126 126 126 126 126 127 127 125 125 123 122 123 121 122 123 122 123 124 125 125 129 127 125 125 125 122 124 122 121 123 123 123 124 125 125 125 125 124 125 124 125 124 123 124 123 124 125 125 125 128 127 128 128 126 128 127 127 127 127 127 127 129 129 128 128 128 125 125 128 126 127 130 128 128 130 128 128 128 129 127 128 129 129 130 130 129 128 128 128 127 128 129 127 128 128 126 126 126 125 125 127 127 127 127 127 127 127 127 126 126 125 125 126 126 126 125 126 126 126 127 126 124 125 124 124 125 125 126 125 125 125 125 124 124 125 125 126 128 128 127 127 126 126 126 125 126 127 126 126 127 126 126 127 127 128 128 128 128 128 127 128 128 128 128 128 127 127 127 127 127 129 129 128 129 128 128 128 128 127 128 128 128 128 128 127 127 127 127 128 128 128 129 129 128 129 128 128 128 129 128 128 128 126 127 127 126 125 126 126 126 127 127 127 128 127 127 127 126 125 126 126 126 126 126 126 127 127 127 127 128 128 128 128 128 128 127 127 127 126 127 127 127 128 128 128 128 128 128 129 129 128 129 129 129 129 129 128 128 128 128 128 128 128 128 128 128 128 128 128 127 127 127 126 126 127 126 126 126 126 126 126 125 125 126 125 125 126 125 125 126 125 124 125 124 123 123 124 124 124 125 124 124 124 124 124 124 124 124 124 124 125 124 125 126 125 125 124 123 124 124 124 125 125 125 125 125 125 126 126 126 126 126 126 127 127 127 127 127 127 127 127 126 127 127 128 128 129 129 129 129 129 128 127 127 127 127 128 127 128 128 128 129 129 128 128 128 128 128 128 128 128 127 127 127 127 126 126 126 126 127 127)"	SampledSound nominalSamplePitch: 400.	SampledSound defaultSampleTable: (Wavelets loriSaysComputer collect: [:s | s * 128]).	(SampledSound pitch: 200.0 dur: 1.0 loudness: 1000) play"! !!Wavelets class methodsFor: 'all' stamp: 'di 6/21/97 08:24'!new	^ super new initialize! !!Wavelets class methodsFor: 'all' stamp: 'di 6/21/97 08:13'!new: n	^ self basicNew setFilters: ((1 to: n) collect: [:i | Array new: 2*i]).! !!Wavelets class methodsFor: 'all' stamp: 'di 6/21/97 08:15'!newFromTable    "FilterArray newFromTable"| h |h _ self new: 10.h at: 1 at: -1 put: 1.0 / 2.0 sqrt.h at: 1 at: 0 put: 1.0 / 2.0 sqrt.h at: 2 at: -2 put: 0.4829629131445341.h at: 2 at: -1 put: 0.8365163037378077.h at: 2 at: 0 put: 0.2241438680420134.h at: 2 at: 1 put: -0.1294095225512603.h at: 3 at: -3 put: 0.3326705529500825.h at: 3 at: -2 put: 0.8068915093110924.h at: 3 at: -1 put: 0.4598775021184914.h at: 3 at: 0 put: -0.1350110200102546.h at: 3 at: 1 put: -0.0854412738820267.h at: 3 at: 2 put: 0.0352262918857095.h at: 4 at: -4 put: 0.2303778133088964.h at: 4 at: -3 put: 0.7148465705529154.h at: 4 at: -2 put: 0.6308807679398587.h at: 4 at: -1 put: -0.0279837694168599.h at: 4 at: 0 put: -0.1870348117190931.h at: 4 at: 1 put: 0.0308413818355607.h at: 4 at: 2 put: 0.0328830116668852.h at: 4 at: 3 put: -0.0105974017850690.h at: 5 at: -5 put: 0.1601023979741929.h at: 5 at: -4 put: 0.6038292697971895.h at: 5 at: -3 put: 0.7243085284377726.h at: 5 at: -2 put: 0.1384281459013203.h at: 5 at: -1 put: -0.2422948870663823.h at: 5 at: 0 put: -0.0322448695846381.h at: 5 at: 1 put: 0.0775714938400459.h at: 5 at: 2 put: -0.0062414902127983.h at: 5 at: 3 put: -0.0125807519990820.h at: 5 at: 4 put: 0.0033357252854738.h at: 6 at: -6 put: 0.1115407433501095.h at: 6 at: -5 put: 0.4946238903984533.h at: 6 at: -4 put: 0.7511339080210959.h at: 6 at: -3 put: 0.3152503517091982.h at: 6 at: -2 put: -0.2262646939654400.h at: 6 at: -1 put: -0.1297668675672625.h at: 6 at: 0 put: 0.0975016055873225.h at: 6 at: 1 put: 0.0275228655303053.h at: 6 at: 2 put: -0.0315820393174862.h at: 6 at: 3 put: 0.0005538422011614.h at: 6 at: 4 put: 0.0047772575109455.h at: 6 at: 5 put: -0.0010773010853085.h at: 7 at: -7 put: 0.0778520540850037.h at: 7 at: -6 put: 0.3965393194818912.h at: 7 at: -5 put: 0.7291320908461957.h at: 7 at: -4 put: 0.4697822874051889.h at: 7 at: -3 put: -0.1439060039285212.h at: 7 at: -2 put: -0.2240361849938412.h at: 7 at: -1 put: 0.0713092192668272.h at: 7 at: 0 put: 0.0806126091510774.h at: 7 at: 1 put: -0.0380299369350104.h at: 7 at: 2 put: -0.0165745416306655.h at: 7 at: 3 put: 0.0125509985560986.h at: 7 at: 4 put: 0.0004295779729214.h at: 7 at: 5 put: -0.0018016407040473.h at: 7 at: 6 put: 0.0003537137999745.h at: 8 at: -8 put: 0.0544158422431072.h at: 8 at: -7 put: 0.3128715909143166.h at: 8 at: -6 put: 0.6756307362973195.h at: 8 at: -5 put: 0.5853546836542159.h at: 8 at: -4 put: -0.0158291052563823.h at: 8 at: -3 put: -0.2840155429615824.h at: 8 at: -2 put: 0.0004724845739124.h at: 8 at: -1 put: 0.1287474266204893.h at: 8 at: 0 put: -0.0173693010018090.h at: 8 at: 1 put: -0.0440882539307971.h at: 8 at: 2 put: 0.0139810279174001.h at: 8 at: 3 put: 0.0087460940474065.h at: 8 at: 4 put: -0.0048703529934520.h at: 8 at: 5 put: -0.0003917403733770.h at: 8 at: 6 put: 0.0006754494064506.h at: 8 at: 7 put: -0.0001174767841248.h at: 9 at: -9 put: 0.0380779473638778.h at: 9 at: -8 put: 0.2438346746125858.h at: 9 at: -7 put: 0.6048231236900955.h at: 9 at: -6 put: 0.6572880780512736.h at: 9 at: -5 put: 0.1331973858249883.h at: 9 at: -4 put: -0.2932737832791663.h at: 9 at: -3 put: -0.0968407832229492.h at: 9 at: -2 put: 0.1485407493381256.h at: 9 at: -1 put: 0.0307256814793385.h at: 9 at: 0 put: -0.0676328290613279.h at: 9 at: 1 put: 0.0002509471148340.h at: 9 at: 2 put: 0.0223616621236798.h at: 9 at: 3 put: -0.0047232047577518.h at: 9 at: 4 put: -0.0042815036824635.h at: 9 at: 5 put: 0.0018476468830563.h at: 9 at: 6 put: 0.0002303857635232.h at: 9 at: 7 put: -0.0002519631889427.h at: 9 at: 8 put: 0.0000393473203163.h at: 10 at: -10 put: 0.0266700579005473.h at: 10 at: -9 put: 0.1881768000776347.h at: 10 at: -8 put: 0.5272011889315757.h at: 10 at: -7 put: 0.6884590394534363.h at: 10 at: -6 put: 0.2811723436605715.h at: 10 at: -5 put: -0.2498464243271598.h at: 10 at: -4 put: -0.1959462743772862.h at: 10 at: -3 put: 0.1273693403357541.h at: 10 at: -2 put: 0.0930573646035547.h at: 10 at: -1 put: -0.0713941471663501.h at: 10 at: 0 put: -0.0294575368218399.h at: 10 at: 1 put: 0.0332126740593612.h at: 10 at: 2 put: 0.0036065535669870.h at: 10 at: 3 put: -0.0107331754833007.h at: 10 at: 4 put: 0.0013953517470688.h at: 10 at: 5 put: 0.0019924052951925.h at: 10 at: 6 put: -0.0006858566949564.h at: 10 at: 7 put: -0.0001164668551285.h at: 10 at: 8 put: 0.0000935886703202.h at: 10 at: 9 put: -0.0000132642028945.^ h! !!Wavelets class methodsFor: 'all' stamp: 'di 6/22/97 11:16'!readLstFileNamed: fName     "Wavelets readLstFilenamed: 'Lori.lst'"	| samples sign f |	f _ FileStream readOnlyFileNamed: fName.	samples _ OrderedCollection new.	[f atEnd]		whileFalse:		[f skipSeparators.		sign _ (f peekFor: $-) ifTrue: [-1.0] ifFalse: [1.0].		samples addLast: (Number readFrom: (f upTo: $,)) * sign].	^ samples asArray"((self collect: [:x | (x * 128.0) rounded + 128]) as: ByteArray) fullPrintString"! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 8/4/97 12:05'!addDefaultHand	self addHand: HandMorph new! !!WorldMorph methodsFor: 'initialization' stamp: 'jm 11/4/97 11:25'!initialize	super initialize.	color _ (Color r:0.937 g: 0.937 b: 0.937).	hands _ Array new.	self addDefaultHand.	viewBox _ canvas _ nil.	damageRecorder _ DamageRecorder new.	stepList _ OrderedCollection new.	lastStepTime _ 0.	model _ nil.! !!WorldMorph methodsFor: 'initialization'!open	"Open a view on this WorldMorph."	MorphWorldView openOn: self.! !!WorldMorph methodsFor: 'initialization' stamp: 'jm 6/21/97 17:03'!openWithTitle: aString	"Open a view on this WorldMorph with the given title."	MorphWorldView openOn: self label: aString! !!WorldMorph methodsFor: 'install / exit'!exit	Cursor normal show.	"restore the normal cursor"	self canvas: nil.		"free my canvas to save space"	Project current exit.! !!WorldMorph methodsFor: 'install / exit'!install	"hide the hardware cursor, since hand will draw it"	Cursor blank show.	self viewBox: Display boundingBox.	hands do: [:h | h initForEvents].	self displayWorld.! !!WorldMorph methodsFor: 'install / exit' stamp: 'sw 9/11/97 14:31'!prepareToDeactivate	"Call this when about to open another MVC window summarily, to obscure the Morphic cursors.  "	hands do:		[:h | h showTemporaryCursor: Cursor blank].	self displayWorld.	hands do:		[:h | h showTemporaryCursor: Cursor normal]! !!WorldMorph methodsFor: 'classification'!isWorldMorph	^ true! !!WorldMorph methodsFor: 'accessing'!canvas	^ canvas! !!WorldMorph methodsFor: 'accessing'!canvas: aCanvas	"Start displaying on the given canvas."	canvas _ aCanvas.	self fullRepaintNeeded.! !!WorldMorph methodsFor: 'accessing'!color: aColor	"Set the background color of this world."	super color: aColor.	self fullRepaintNeeded.	"Propagate to view"	self changed: #newColor.! !!WorldMorph methodsFor: 'accessing'!viewBox		^ viewBox! !!WorldMorph methodsFor: 'accessing' stamp: 'di 6/24/97 10:09'!viewBox: aRectangle	(viewBox == nil or:	 [viewBox extent ~= aRectangle extent])		ifTrue: [self canvas: nil].	viewBox _ aRectangle.	bounds _ 0@0 extent: viewBox extent.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	hands do: [:h | h newKeyboardFocus: nil].	self fullRepaintNeeded.! !!WorldMorph methodsFor: 'structure'!addAllMorphs: array	super addAllMorphs: array.	array do: [:m | self startSteppingSubmorphsOf: m]! !!WorldMorph methodsFor: 'structure'!world	^ self! !!WorldMorph methodsFor: 'submorphs-accessing' stamp: 'jm 6/11/97 17:07'!allMorphsDo: aBlock	"Enumerate all morphs in the world, including those held in hands."	super allMorphsDo: aBlock.	hands reverseDo: [:h | h allMorphsDo: aBlock].! !!WorldMorph methodsFor: 'submorphs-accessing' stamp: 'sw 8/15/97 14:54'!rootMorphsAt: aPoint	"Return the list of root morphs containing the given point, excluding the world and its hands."	| mList |	mList _ OrderedCollection new.	submorphs do: [:m |		((m fullContainsPoint: aPoint) and: [m isLocked not]) ifTrue: [mList addLast: m]].	^ mList! !!WorldMorph methodsFor: 'drawing' stamp: 'jm 11/14/97 13:27'!displayWorld	"Update this world's display."	| rectList |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	damageRecorder updateIsNeeded ifFalse: [^ self].  "display is already up-to-date"	(canvas == nil or:	 [(canvas extent ~= viewBox extent) or:	 [canvas form depth ~= Display depth]]) ifTrue: [		"allocate a new offscreen canvas the size of the window"		self canvas: (FormCanvas extent: viewBox extent)].	false ifTrue: [  "*make this true to flash damaged areas for testing*"		damageRecorder blackenDamageOn: canvas.		canvas showAt: viewBox origin].	rectList _ self drawInvalidAreasOn: canvas.  "redraw on offscreen canvas"	canvas showAt: viewBox origin invalidRects: rectList.  "copy redrawn rects to Display"	Smalltalk forceDisplayUpdate.! !!WorldMorph methodsFor: 'drawing' stamp: 'jj 10/20/97 16:14'!displayWorldAsTwoTone	"Display the world in living black-and-white. (This is typically done to save space.)"	| f |	f _ ColorForm extent: viewBox extent depth: 1.	f colors: (Array with: color dominantColor with: Color black).	self canvas: (FormCanvas on: f).	"force the entire canvas to be redrawn"	self fullRepaintNeeded.	self drawInvalidAreasOn: canvas.  "redraw on offscreen canvas"	canvas showAt: viewBox origin.  "copy redrawn areas to Display"	Smalltalk forceDisplayUpdate.	self canvas: nil.  "forget my canvas to save space"! !!WorldMorph methodsFor: 'drawing' stamp: 'jj 10/20/97 16:14'!displayWorldNonIncrementally	"Display the morph world non-incrementally. Used for testing."	(canvas == nil or:	 [(canvas extent ~= viewBox extent) or:	 [canvas form depth ~= Display depth]]) ifTrue: [		"allocate a new offscreen canvas the size of the window"		self canvas: (FormCanvas extent: viewBox extent)].	canvas fillColor: color.	submorphs reverseDo: [:m | m fullDrawOn: canvas].	hands reverseDo: [:h | h fullDrawOn: canvas].	canvas form displayOn: Display at: viewBox origin.	self fullRepaintNeeded.  "don't collect damage"	Smalltalk forceDisplayUpdate.! !!WorldMorph methodsFor: 'drawing' stamp: 'di 11/14/97 13:35'!drawInvalidAreasOn: aCanvas	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| rectList c |	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: aCanvas extent).	damageRecorder reset.	rectList do: [:r |		c _ aCanvas copyClipRect: r.		"** change to true to try out optimized drawing **"		"Fails currently for Transforms and ScreeningMorphs"		false		ifTrue: [(self visibleMorphsIn: r)					do: [:m | m == self ifTrue: [c fillColor: color]									ifFalse: [m drawOn: c]]]		ifFalse: [c fillColor: color.				submorphs reverseDo: [:m | m fullDrawOn: c]				"Used to be..."				"submorphs reverseDo: [:m |					(m fullBounds intersects: r)					ifTrue: [m drawOn: c]]."				].		hands reverseDo: [:h | h fullDrawOn: c]].	^ rectList! !!WorldMorph methodsFor: 'events'!handlesMouseDown: evt	^ true! !!WorldMorph methodsFor: 'events'!mouseDown: evt	"Handle a mouse down event on the world."	evt hand newKeyboardFocus: self.! !!WorldMorph methodsFor: 'stepping' stamp: 'ack 7/5/97 16:23'!adjustWakeupTimes	"Fix the wakeup times in my step list. This is necessary when this world has been restarted after a pause, say because some other view had control, after a snapshot, or because the millisecond clock has wrapped around. (The latter is a rare occurence with a 32-bit clock!!)"	| earliestTime t now m oldWakeupTime |	"find earliest wakeup time"	earliestTime _ SmallInteger maxVal.	stepList do: [:entry |		t _ entry at: 2.		t < earliestTime ifTrue: [earliestTime _ t]].	"recompute all wakeup times, using earliestTime as the origin"	now _ Time millisecondClockValue.	stepList do: [:entry |		m _ entry at: 1.		oldWakeupTime _ entry at: 2.		entry at: 2 put: now + ((oldWakeupTime - earliestTime) min: m stepTime)].	lastStepTime _ now.! !!WorldMorph methodsFor: 'stepping' stamp: 'ack 7/5/97 16:09'!adjustWakeupTimesIfNecessary	"Fix the wakeup times in my step list if necessary. This is needed after a snapshot, after a long pause (say because some other view had control or because the user was selecting from an MVC-style menu) or when the millisecond clock wraps around (a very rare occurence with a 32-bit clock!!)."	| now |	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"! !!WorldMorph methodsFor: 'stepping' stamp: 'tk 9/30/97 14:42'!isStepping: aMorph	"Return true if the given morph is in the step list."	stepList do: [:entry | entry first == aMorph ifTrue: [^ true]].  "already stepping"	^ false! !!WorldMorph methodsFor: 'stepping' stamp: 'jm 11/19/97 08:55'!runStepMethods	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world."	| now deletions wakeupTime m |	stepList size = 0 ifTrue: [^ self].	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"	deletions _ OrderedCollection new.	stepList do: [:entry |		wakeupTime _ entry at: 2.		m _ entry at: 1.		m world == self			ifTrue: [				wakeupTime <= now					ifTrue: [						m step.						entry at: 2 put: now + m stepTime]]			ifFalse: [deletions addLast: m]].	deletions do: [:goner |		self stopStepping: goner.		goner stopStepping].	lastStepTime _ now.! !!WorldMorph methodsFor: 'stepping' stamp: 'ack 7/5/97 16:01'!startStepping: aMorph	"Add the given morph to the step list. Do nothing if it is already being stepped."	stepList do: [:entry | entry first = aMorph ifTrue: [^ self]].  "already stepping"	self adjustWakeupTimesIfNecessary.	stepList add:		(Array with: aMorph with: Time millisecondClockValue).! !!WorldMorph methodsFor: 'stepping' stamp: 'jm 10/17/97 15:04'!startSteppingSubmorphsOf: aMorph	"Ensure that all submorphs of the given morph that want to be stepped are added to the step list. Typically used after adding a morph to the world."	aMorph allMorphsDo: [:m |		m wantsSteps ifTrue: [m startStepping]].! !!WorldMorph methodsFor: 'stepping'!stopStepping: aMorph	"Remove the given morph from the step list."	stepList copy do: [:entry |		entry first == aMorph ifTrue: [stepList remove: entry ifAbsent: []]].! !!WorldMorph methodsFor: 'hands' stamp: 'jm 9/26/97 15:00'!addHand: aHandMorph	"Add the given hand to the list of hands for this world."	hands _ hands copyWith: aHandMorph.	aHandMorph privateOwner: self.! !!WorldMorph methodsFor: 'hands'!hands	^ hands copy! !!WorldMorph methodsFor: 'hands' stamp: 'jm 11/4/97 07:16'!removeHand: aHandMorph	"Remove the given hand from the list of hands for this world."	(hands includes: aHandMorph) ifTrue: [		aHandMorph dropMorphsEvent: MorphicEvent new.		hands _ hands copyWithout: aHandMorph].! !!WorldMorph methodsFor: 'change reporting'!fullRepaintNeeded	damageRecorder doFullRepaint.! !!WorldMorph methodsFor: 'change reporting'!invalidRect: damageRect	"Record the given rectangle in the damage list."	damageRecorder recordInvalidRect: damageRect.! !!WorldMorph methodsFor: 'change reporting'!layoutChanged	fullBounds _ nil.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'jm 11/19/97 08:53'!doOneCycle	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	hands do: [:h | h processEvents].  "process user input events"	self runStepMethods.	self displayWorld.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'jm 11/19/97 08:52'!doOneCycleInBackground	"Do one cycle of the interactive loop. This method is called repeatedly when this world is not the active window but is running in the background."	"process user input events, but only for remote hands"	hands do: [:h | (h isKindOf: RemoteHandMorph) ifTrue: [h processEvents]].	self runStepMethods.	self displayWorld.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'jm 11/4/97 07:16'!startBackgroundProcess	"Start a process to update this world in the background. Return the process created."	| p |	p _ [[true] whileTrue: [		self doOneCycleInBackground.		(Delay forMilliseconds: 20) wait]] newProcess.	p resume.	^ p! !!WorldMorph methodsFor: 'model access'!createCustomModel	"Create a model object for this world if it does not yet have one. A model object is an initially empty subclass of MorphicModel. As the user names parts and adds behavior, instance variables and methods are added to this class."	model == nil ifFalse: [^ self].  "already has a model"	model _ MorphicModel newSubclass new.! !!WorldMorph methodsFor: 'model access'!model	"Return the model object for this world. If the world has no model, then create one."	self createCustomModel.	^ model! !!WorldMorph methodsFor: 'model access'!modelOrNil	"Return the model object for this world, or nil if it doesn't have one."	^ model! !!WorldMorph methodsFor: 'model access'!setModel: aModelMorph	"Set the model for this world. Methods for sensitized morphs will be compiled into the class for this model."	model _ aModelMorph! !!WorldMorph methodsFor: 'dropping' stamp: 'sw 10/18/97 18:03'!acceptDroppingMorph: aMorph event: evt	"Add the given morph to this world and make sure it is getting stepped if it wants to be."	self addMorphFront: aMorph.	(aMorph fullBounds intersects: (0@0 extent: self viewBox extent)) ifFalse:		[self beep.  aMorph position: self bounds center].	self startSteppingSubmorphsOf: aMorph.! !!WorldMorph methodsFor: 'painting support' stamp: 'tk 7/14/97 18:06'!installForm: aForm	"Accept a Form from the outside, create a SketchMorph, and put it on the Hand."	| f |	f _ SketchMorph new form: aForm.	hands first attachMorph: f.! !!WorldMorph methodsFor: 'painting support' stamp: 'di 1/13/98 22:07'!paintArea	"What rectangle should the user be allowed to create a new painting in??  An area beside the paintBox.  Allow playArea to override with its own bounds!!  "	| paintBoxBounds |	paintBoxBounds _ self paintBox bounds.	self hands first targetOffset x < paintBoxBounds center x		ifTrue: [^ bounds topLeft corner: paintBoxBounds left@bounds bottom]   "paint on left side"		ifFalse: [^ paintBoxBounds right@bounds top corner: bounds bottomRight].  "paint on right side"! !!WorldMorph methodsFor: 'painting support' stamp: 'sw 8/17/97 18:28'!paintAreaFor: aSketchMorph	"What rectangle should the the painting arena for painting aSketchMorph.  Overridden in EToyWorld; here, we just defer to the old way that takes no account of the sketch morh"	^ self paintArea! !!WorldMorph methodsFor: 'painting support' stamp: 'di 1/13/98 21:57'!paintBox	"Return the painting controls widget (PaintBoxMorph) to be used for painting in this world. If there is not already a PaintBox morph, or if it has been deleted from this world, create a new one."	| newPaintBox |	self allMorphsDo: [:m | (m isKindOf: PaintBoxMorph) ifTrue: [^ m]].	newPaintBox _ PaintBoxMorph new position: 300@0.	self addMorph: newPaintBox.	^ newPaintBox! !!WorldMorph methodsFor: 'sensing'!colorAt: aPoint belowMorph: aMorph	"Return the color of the pixel immediately behind the given morph at the given point."	| c root |	c _ FormCanvas extent: 1@1 depth: Display depth.	c _ c copyOrigin: aPoint negated clipRect: ((0@0) extent: 1@1).	c fillColor: color.	root _ aMorph root.	submorphs reverseDo: [:m |		m == root ifTrue: [			(m morphsAt: aPoint) reverseDo: [:subM |				subM == aMorph ifTrue: [^ c form colorAt: 0@0].				subM drawOn: c]].		m fullDrawOn: c].	hands reverseDo: [:h |		h submorphsReverseDo: [:m |			m == root ifTrue: [				(m morphsAt: aPoint) reverseDo: [:subM |					subM == aMorph ifTrue: [^ c form colorAt: 0@0].					subM drawOn: c]].			m fullDrawOn: c]].	^ c form colorAt: 0@0! !!WorldMorph methodsFor: 'save/store' stamp: 'jm 10/17/97 15:04'!addMorphsAndModel: aDummyWorld	"Dump in submorphs, model, and stepList from a dummyWorld.  Used to bring a world in from an object file.  "	| |	aDummyWorld isMorph ifTrue: [		aDummyWorld isWorldMorph ifFalse: ["one morph, put on hand"			"aDummyWorld installModelIn: self.  	a chance to install model pointers"			self startSteppingSubmorphsOf: aDummyWorld.			self hands first attachMorph: aDummyWorld		] ifTrue: [			model == nil ifTrue: [self setModel: (aDummyWorld modelOrNil)]					ifFalse: [aDummyWorld modelOrNil ifNotNil: [								aDummyWorld modelOrNil privateOwner: nil.								self addMorph: (aDummyWorld modelOrNil)]].			aDummyWorld privateSubmorphs reverseDo: [:m |				m privateOwner: nil.				self addMorph: m.				m changed].			(aDummyWorld instVarNamed: 'stepList') do:				[:entry | entry first startStepping]]	] ifFalse: ["list, add them all"		aDummyWorld reverseDo: [:m |			m privateOwner: nil.			self addMorph: m.			self startSteppingSubmorphsOf: m.	"It may not want this!!"			m changed]].! !!WorldMorph methodsFor: 'save/store'!saveAsWorld	| worldName s |	worldName _ FillInTheBlank		request: 'Please give this world a name'		initialAnswer: 'test'.	((self class class includesSelector: worldName asSymbol) and:		[(PopUpMenu confirm: 'OK to overwrite ' , worldName , '?') not])		ifTrue: [^ self].	s _ WriteStream on: (String new: 1000).	s	nextPutAll: worldName; cr; tab;		nextPutAll: '"' , self class name , ' ' , worldName, ' open"'; cr; cr; tab;		nextPutAll: '^ '.	self printConstructorOn: s indent: 0.	s cr.	self class class		compile: s contents		classified: 'examples'		notifying: nil.! !!WorldMorph methodsFor: 'save/store' stamp: 'tk 5/30/97'!storeDataOn: aDataStream	"WorldMorphs only save certain fields when written to the disk.  Save only the world's submorphs, model, and stepList. See DataStream.typeIDFor:  "	| cntInstVars cntIndexedVars instVars data ind |	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	instVars _ self class allInstVarNames.	data _ Array new: instVars size.	"Add any additional fields to write here"	ind _ (instVars indexOf: 'model').	(ind = 0) ifTrue: [self error: 'this method is out of date']			ifFalse: [data at: ind put: model].	ind _ (instVars indexOf: 'submorphs').	(ind = 0) ifTrue: [self error: 'this method is out of date']			ifFalse: [data at: ind put: submorphs].	ind _ (instVars indexOf: 'stepList').	(ind = 0) ifTrue: [self error: 'this method is out of date']			ifFalse: [data at: ind put: stepList].	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: cntInstVars do:		[:i | aDataStream nextPut: (data at: i)].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !!WorldMorph methodsFor: 'halos' stamp: 'sw 9/5/97 16:11'!abandonAllHalos	self haloMorphs do: [:m | m delete]! !!WorldMorph methodsFor: 'halos' stamp: 'sw 9/19/97 13:24'!balloonHelpEnabled	^ BalloonMorph mouseOverEnabled ! !!WorldMorph methodsFor: 'halos' stamp: 'sw 9/5/97 16:28'!haloMorphOrNil	| m |	^ (m _ self haloMorphs) size > 0 ifTrue: [m first] ifFalse: [nil]! !!WorldMorph methodsFor: 'halos' stamp: 'sw 9/5/97 16:10'!haloMorphs	^ submorphs select: [:m | m isKindOf: HaloMorph]! !!WorldMorph methodsFor: 'halos' stamp: 'sw 9/19/97 13:38'!mouseOverHalosEnabled	^ BalloonMorph mouseOverEnabled ! !!WorldMorph methodsFor: 'etoy support' stamp: 'jm 11/4/97 11:20'!noteDeletionOf: aMorph	"Note that the given morph is being deleted. This default implementation does nothing."! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 9/19/97 19:07'!soundsEnabled	^ true! !!WorldMorph methodsFor: 'etoy support' stamp: 'jm 9/23/97 11:58'!stopRunningAll	"Do nothing; for compatability with EToyWorld."! !!WorldMorph class methodsFor: 'all' stamp: 'di 6/22/97 09:07'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!WriteStream methodsFor: 'fileIn/Out' stamp: 'tk 12/30/97 10:55'!nextChunkPutWithStyle: aStringOrText	"Append the argument, aText, to the receiver, doubling embedded terminators.  Put out one chunk for the string and one for the style runs.  Mark the style with ]style[."	aStringOrText class == String ifTrue: [^ self nextChunkPut: aStringOrText].	aStringOrText runs coalesce.	aStringOrText unembellished ifTrue: [^ self nextChunkPut: aStringOrText asString].	self nextChunkPut: aStringOrText asString.	self cr; nextPutAll: ']style['.	self nextChunkPut: 		(String streamContents: [:strm | 			aStringOrText runs writeScanOn: strm]).! !!WriteStream methodsFor: 'private' stamp: 'di 6/20/97 08:39'!pastEndPut: anObject	collection _ collection ,		(collection class new: ((collection size max: 20) min: 20000)).	writeLimit _ collection size.	collection at: (position _ position + 1) put: anObject! !!WriteStream methodsFor: 'private'!withAttribute: att do: strmBlock 	"No-op here is overriden in TextStream for font emphasis"	^ strmBlock value! !!ZoomMorph methodsFor: 'all'!initialize	super initialize.	color _ Color transparent! !!ZoomMorph methodsFor: 'all'!step	boundsSeq isEmpty ifTrue:		["If all done, then grant one final request and vanish"		finalAction value.		^ self delete].	"Otherwise, zoom to the next rectangle"	self zoomTo: boundsSeq removeFirst! !!ZoomMorph methodsFor: 'all'!stepTime	^ 40! !!ZoomMorph methodsFor: 'all'!zoomFromMorph: m1 toMorph: m2 andThen: actionBlock	| nSteps topLeft r2 r1 extent ratio r mouthDeltas |	fromMorph _ m1.	toMorph _ m2.	r1 _ fromMorph fullBounds.	r2 _ toMorph fullBounds.	finalAction _ actionBlock.	nSteps _ 8.	boundsSeq _ OrderedCollection new.	r _ (1/nSteps) asFloat.	ratio _ r.r1 _ 105@326 corner: 130@348.mouthDeltas _ {-7@24. -6@21. -6@18. -4@14. -4@10. -3@8. -3@3. 0@0}.	1 to: nSteps do:		[:i | topLeft _ ((r2 topLeft - r1 topLeft) * ratio) asIntegerPoint + r1 topLeft.		extent _ ((r2 extent - r1 extent) * ratio) asIntegerPoint + r1 extent.		boundsSeq addLast: (topLeft + (mouthDeltas at: i) extent: extent).		ratio _ ratio + r].	self addMorph: toMorph.	self step! !!ZoomMorph methodsFor: 'all'!zoomTo: newBounds	| scale |	self bounds: newBounds.	scale _ newBounds extent / toMorph fullBounds extent.	self setOffset: toMorph position - self position angle: 0.0 scale: scale! !	Smalltalk condenseChanges.!----QUIT----(16 January 1998 5:58:00 pm ) priorSource: 3476069!Object classPool at: #DependentsFields!Object classPool at: #DependentsFields!Smalltalk reclaimDependents!Object classPool at: #DependentsFields!----QUIT----(16 January 1998 6:04:45 pm ) priorSource: 3476100!MIDIFileReader playURLNamed: 		'http://www.midiworld.com/mid/c2/wtellovr.mid'.!('zort ^ 5' asText makeSelectorBoldIn: Integer) rangeOf: TextEmphasis bold startingAt: 2!!Paragraph methodsFor: 'selecting' stamp: 'di 1/16/98 23:29' prior: 35945084!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range box boxes |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex) 		do: [:att | att mayActOnClick ifTrue:				[range _ text rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box _ boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: box repeating: []						ifSucceed: [							aController controlTerminate.							(att actOnClickFor: model) ifTrue: [action _ true].							aController controlInitialize].				]].	^ action! !!NewParagraph methodsFor: 'editing' stamp: 'di 1/16/98 23:35' prior: 35792416!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range boxes box |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex) 		do: [:att | att mayActOnClick ifTrue:				[range _ text rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last).				box _ boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: (box translateBy: self world viewBox topLeft)						repeating: []						ifSucceed: [							self controlTerminate.							(att actOnClickFor: model) ifTrue: [action _ true].							self controlInitialize].				]].	^ action! !!TextMorphEditor methodsFor: 'all' stamp: 'di 1/16/98 23:40'!textMorph	^ morph! !!NewParagraph methodsFor: 'editing' stamp: 'di 1/16/98 23:40' prior: 37031999!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range boxes box |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex) 		do: [:att | att mayActOnClick ifTrue:				[range _ text rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last).				box _ boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: (box translateBy: aController textMorph world viewBox topLeft "HACK")						repeating: []						ifSucceed: [							self controlTerminate.							(att actOnClickFor: model) ifTrue: [action _ true].							self controlInitialize].				]].	^ action! !!NewParagraph methodsFor: 'editing' stamp: 'di 1/16/98 23:40' prior: 37033048!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range boxes box |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex) 		do: [:att | att mayActOnClick ifTrue:				[range _ text rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box _ boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: (box translateBy: self world viewBox topLeft)						repeating: []						ifSucceed: [							self controlTerminate.							(att actOnClickFor: model) ifTrue: [action _ true].							self controlInitialize].				]].	^ action! !!Utilities class methodsFor: 'common requests' stamp: 'di 1/16/98 23:48' prior: 18636366!initializeCommonRequestStrings	"Initialize an array of common request strings.  2/1/96 sw	 5/10/96 sw: converted over to new format of StringHolder"	CommonRequestStrings _ StringHolder new contents: 'Utilities emergencyCollapseSensor keyboardCursor normal show-----------------------------------------------------Utilities durableHelpMenuUtilities durableOpenMenuUtilities durableWindowMenuUtilities durableChangesMenuUtilities fontSizeSummary-----------------------------------------------------ProjectView open: Project newMorphicForm fromUser bitEditUndeclared inspectUndeclared removeUnreferencedKeysTranscript clear'"Utilities initializeCommonRequestStrings"! !----QUIT----(16 January 1998 11:54:32 pm ) priorSource: 3476318!